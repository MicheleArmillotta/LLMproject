[
  {
    "function_name": "float_compare_desc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_selfuncs.c",
    "lines": "1181-1193",
    "snippet": "static int\nfloat_compare_desc(const void *key1, const void *key2)\n{\n\tfloat\t\td1 = *((const float *) key1);\n\tfloat\t\td2 = *((const float *) key2);\n\n\tif (d1 > d2)\n\t\treturn -1;\n\telse if (d1 < d2)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tfloat_compare_desc(const void *key1, const void *key2);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/clauses.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nstatic int\tfloat_compare_desc(const void *key1, const void *key2);\n\nstatic int\nfloat_compare_desc(const void *key1, const void *key2)\n{\n\tfloat\t\td1 = *((const float *) key1);\n\tfloat\t\td2 = *((const float *) key2);\n\n\tif (d1 > d2)\n\t\treturn -1;\n\telse if (d1 < d2)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}"
  },
  {
    "function_name": "element_compare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_selfuncs.c",
    "lines": "1166-1176",
    "snippet": "static int\nelement_compare(const void *key1, const void *key2, void *arg)\n{\n\tDatum\t\td1 = *((const Datum *) key1);\n\tDatum\t\td2 = *((const Datum *) key2);\n\tFmgrInfo   *cmpfunc = (FmgrInfo *) arg;\n\tDatum\t\tc;\n\n\tc = FunctionCall2Coll(cmpfunc, DEFAULT_COLLATION_OID, d1, d2);\n\treturn DatumGetInt32(c);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Selectivity mcelem_array_selec(ArrayType *array,\n\t\t\t\t   TypeCacheEntry *typentry,\n\t\t\t\t   Datum *mcelem, int nmcelem,\n\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t   float4 *hist, int nhist,\n\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);",
      "static Selectivity mcelem_array_contain_overlap_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t\t   Datum *array_data, int nitems,\n\t\t\t\t\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);",
      "static Selectivity mcelem_array_contained_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t Datum *array_data, int nitems,\n\t\t\t\t\t\t\t float4 *hist, int nhist,\n\t\t\t\t\t\t\t Oid operator, FmgrInfo *cmpfunc);",
      "static bool find_next_mcelem(Datum *mcelem, int nmcelem, Datum value,\n\t\t\t\t int *index, FmgrInfo *cmpfunc);",
      "static int\telement_compare(const void *key1, const void *key2, void *arg);",
      "static int\tfloat_compare_desc(const void *key1, const void *key2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DatumGetInt32",
          "args": [
            "c"
          ],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FunctionCall2Coll",
          "args": [
            "cmpfunc",
            "DEFAULT_COLLATION_OID",
            "d1",
            "d2"
          ],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "OidFunctionCall2Coll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1427-1450",
          "snippet": "Datum\nOidFunctionCall2Coll(Oid functionId, Oid collation, Datum arg1, Datum arg2)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 2, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nOidFunctionCall2Coll(Oid functionId, Oid collation, Datum arg1, Datum arg2)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 2, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/clauses.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Selectivity mcelem_array_selec(ArrayType *array,\n\t\t\t\t   TypeCacheEntry *typentry,\n\t\t\t\t   Datum *mcelem, int nmcelem,\n\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t   float4 *hist, int nhist,\n\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);\nstatic Selectivity mcelem_array_contain_overlap_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t\t   Datum *array_data, int nitems,\n\t\t\t\t\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);\nstatic Selectivity mcelem_array_contained_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t Datum *array_data, int nitems,\n\t\t\t\t\t\t\t float4 *hist, int nhist,\n\t\t\t\t\t\t\t Oid operator, FmgrInfo *cmpfunc);\nstatic bool find_next_mcelem(Datum *mcelem, int nmcelem, Datum value,\n\t\t\t\t int *index, FmgrInfo *cmpfunc);\nstatic int\telement_compare(const void *key1, const void *key2, void *arg);\nstatic int\tfloat_compare_desc(const void *key1, const void *key2);\n\nstatic int\nelement_compare(const void *key1, const void *key2, void *arg)\n{\n\tDatum\t\td1 = *((const Datum *) key1);\n\tDatum\t\td2 = *((const Datum *) key2);\n\tFmgrInfo   *cmpfunc = (FmgrInfo *) arg;\n\tDatum\t\tc;\n\n\tc = FunctionCall2Coll(cmpfunc, DEFAULT_COLLATION_OID, d1, d2);\n\treturn DatumGetInt32(c);\n}"
  },
  {
    "function_name": "find_next_mcelem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_selfuncs.c",
    "lines": "1131-1156",
    "snippet": "static bool\nfind_next_mcelem(Datum *mcelem, int nmcelem, Datum value, int *index,\n\t\t\t\t FmgrInfo *cmpfunc)\n{\n\tint\t\t\tl = *index,\n\t\t\t\tr = nmcelem - 1,\n\t\t\t\ti,\n\t\t\t\tres;\n\n\twhile (l <= r)\n\t{\n\t\ti = (l + r) / 2;\n\t\tres = element_compare(&mcelem[i], &value, cmpfunc);\n\t\tif (res == 0)\n\t\t{\n\t\t\t*index = i;\n\t\t\treturn true;\n\t\t}\n\t\telse if (res < 0)\n\t\t\tl = i + 1;\n\t\telse\n\t\t\tr = i - 1;\n\t}\n\t*index = l;\n\treturn false;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Selectivity mcelem_array_selec(ArrayType *array,\n\t\t\t\t   TypeCacheEntry *typentry,\n\t\t\t\t   Datum *mcelem, int nmcelem,\n\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t   float4 *hist, int nhist,\n\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);",
      "static Selectivity mcelem_array_contain_overlap_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t\t   Datum *array_data, int nitems,\n\t\t\t\t\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);",
      "static Selectivity mcelem_array_contained_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t Datum *array_data, int nitems,\n\t\t\t\t\t\t\t float4 *hist, int nhist,\n\t\t\t\t\t\t\t Oid operator, FmgrInfo *cmpfunc);",
      "static bool find_next_mcelem(Datum *mcelem, int nmcelem, Datum value,\n\t\t\t\t int *index, FmgrInfo *cmpfunc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "element_compare",
          "args": [
            "&mcelem[i]",
            "&value",
            "cmpfunc"
          ],
          "line": 1143
        },
        "resolved": true,
        "details": {
          "function_name": "element_compare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_selfuncs.c",
          "lines": "1166-1176",
          "snippet": "static int\nelement_compare(const void *key1, const void *key2, void *arg)\n{\n\tDatum\t\td1 = *((const Datum *) key1);\n\tDatum\t\td2 = *((const Datum *) key2);\n\tFmgrInfo   *cmpfunc = (FmgrInfo *) arg;\n\tDatum\t\tc;\n\n\tc = FunctionCall2Coll(cmpfunc, DEFAULT_COLLATION_OID, d1, d2);\n\treturn DatumGetInt32(c);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Selectivity mcelem_array_selec(ArrayType *array,\n\t\t\t\t   TypeCacheEntry *typentry,\n\t\t\t\t   Datum *mcelem, int nmcelem,\n\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t   float4 *hist, int nhist,\n\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);",
            "static Selectivity mcelem_array_contain_overlap_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t\t   Datum *array_data, int nitems,\n\t\t\t\t\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);",
            "static Selectivity mcelem_array_contained_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t Datum *array_data, int nitems,\n\t\t\t\t\t\t\t float4 *hist, int nhist,\n\t\t\t\t\t\t\t Oid operator, FmgrInfo *cmpfunc);",
            "static bool find_next_mcelem(Datum *mcelem, int nmcelem, Datum value,\n\t\t\t\t int *index, FmgrInfo *cmpfunc);",
            "static int\telement_compare(const void *key1, const void *key2, void *arg);",
            "static int\tfloat_compare_desc(const void *key1, const void *key2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/clauses.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Selectivity mcelem_array_selec(ArrayType *array,\n\t\t\t\t   TypeCacheEntry *typentry,\n\t\t\t\t   Datum *mcelem, int nmcelem,\n\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t   float4 *hist, int nhist,\n\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);\nstatic Selectivity mcelem_array_contain_overlap_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t\t   Datum *array_data, int nitems,\n\t\t\t\t\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);\nstatic Selectivity mcelem_array_contained_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t Datum *array_data, int nitems,\n\t\t\t\t\t\t\t float4 *hist, int nhist,\n\t\t\t\t\t\t\t Oid operator, FmgrInfo *cmpfunc);\nstatic bool find_next_mcelem(Datum *mcelem, int nmcelem, Datum value,\n\t\t\t\t int *index, FmgrInfo *cmpfunc);\nstatic int\telement_compare(const void *key1, const void *key2, void *arg);\nstatic int\tfloat_compare_desc(const void *key1, const void *key2);\n\nstatic int\nelement_compare(const void *key1, const void *key2, void *arg)\n{\n\tDatum\t\td1 = *((const Datum *) key1);\n\tDatum\t\td2 = *((const Datum *) key2);\n\tFmgrInfo   *cmpfunc = (FmgrInfo *) arg;\n\tDatum\t\tc;\n\n\tc = FunctionCall2Coll(cmpfunc, DEFAULT_COLLATION_OID, d1, d2);\n\treturn DatumGetInt32(c);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/clauses.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Selectivity mcelem_array_selec(ArrayType *array,\n\t\t\t\t   TypeCacheEntry *typentry,\n\t\t\t\t   Datum *mcelem, int nmcelem,\n\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t   float4 *hist, int nhist,\n\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);\nstatic Selectivity mcelem_array_contain_overlap_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t\t   Datum *array_data, int nitems,\n\t\t\t\t\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);\nstatic Selectivity mcelem_array_contained_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t Datum *array_data, int nitems,\n\t\t\t\t\t\t\t float4 *hist, int nhist,\n\t\t\t\t\t\t\t Oid operator, FmgrInfo *cmpfunc);\nstatic bool find_next_mcelem(Datum *mcelem, int nmcelem, Datum value,\n\t\t\t\t int *index, FmgrInfo *cmpfunc);\n\nstatic bool\nfind_next_mcelem(Datum *mcelem, int nmcelem, Datum value, int *index,\n\t\t\t\t FmgrInfo *cmpfunc)\n{\n\tint\t\t\tl = *index,\n\t\t\t\tr = nmcelem - 1,\n\t\t\t\ti,\n\t\t\t\tres;\n\n\twhile (l <= r)\n\t{\n\t\ti = (l + r) / 2;\n\t\tres = element_compare(&mcelem[i], &value, cmpfunc);\n\t\tif (res == 0)\n\t\t{\n\t\t\t*index = i;\n\t\t\treturn true;\n\t\t}\n\t\telse if (res < 0)\n\t\t\tl = i + 1;\n\t\telse\n\t\t\tr = i - 1;\n\t}\n\t*index = l;\n\treturn false;\n}"
  },
  {
    "function_name": "floor_log2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_selfuncs.c",
    "lines": "1090-1122",
    "snippet": "static int\nfloor_log2(uint32 n)\n{\n\tint\t\t\tlogval = 0;\n\n\tif (n == 0)\n\t\treturn -1;\n\tif (n >= (1 << 16))\n\t{\n\t\tn >>= 16;\n\t\tlogval += 16;\n\t}\n\tif (n >= (1 << 8))\n\t{\n\t\tn >>= 8;\n\t\tlogval += 8;\n\t}\n\tif (n >= (1 << 4))\n\t{\n\t\tn >>= 4;\n\t\tlogval += 4;\n\t}\n\tif (n >= (1 << 2))\n\t{\n\t\tn >>= 2;\n\t\tlogval += 2;\n\t}\n\tif (n >= (1 << 1))\n\t{\n\t\tlogval += 1;\n\t}\n\treturn logval;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static float *calc_hist(const float4 *hist, int nhist, int n);",
      "static int\tfloor_log2(uint32 n);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/clauses.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nstatic float *calc_hist(const float4 *hist, int nhist, int n);\nstatic int\tfloor_log2(uint32 n);\n\nstatic int\nfloor_log2(uint32 n)\n{\n\tint\t\t\tlogval = 0;\n\n\tif (n == 0)\n\t\treturn -1;\n\tif (n >= (1 << 16))\n\t{\n\t\tn >>= 16;\n\t\tlogval += 16;\n\t}\n\tif (n >= (1 << 8))\n\t{\n\t\tn >>= 8;\n\t\tlogval += 8;\n\t}\n\tif (n >= (1 << 4))\n\t{\n\t\tn >>= 4;\n\t\tlogval += 4;\n\t}\n\tif (n >= (1 << 2))\n\t{\n\t\tn >>= 2;\n\t\tlogval += 2;\n\t}\n\tif (n >= (1 << 1))\n\t{\n\t\tlogval += 1;\n\t}\n\treturn logval;\n}"
  },
  {
    "function_name": "calc_distr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_selfuncs.c",
    "lines": "1011-1087",
    "snippet": "static float *\ncalc_distr(const float *p, int n, int m, float rest)\n{\n\tfloat\t   *row,\n\t\t\t   *prev_row,\n\t\t\t   *tmp;\n\tint\t\t\ti,\n\t\t\t\tj;\n\n\t/*\n\t * Since we return only the last row of the matrix and need only the\n\t * current and previous row for calculations, allocate two rows.\n\t */\n\trow = (float *) palloc((m + 1) * sizeof(float));\n\tprev_row = (float *) palloc((m + 1) * sizeof(float));\n\n\t/* M[0,0] = 1 */\n\trow[0] = 1.0f;\n\tfor (i = 1; i <= n; i++)\n\t{\n\t\tfloat\t\tt = p[i - 1];\n\n\t\t/* Swap rows */\n\t\ttmp = row;\n\t\trow = prev_row;\n\t\tprev_row = tmp;\n\n\t\t/* Calculate next row */\n\t\tfor (j = 0; j <= i && j <= m; j++)\n\t\t{\n\t\t\tfloat\t\tval = 0.0f;\n\n\t\t\tif (j < i)\n\t\t\t\tval += prev_row[j] * (1.0f - t);\n\t\t\tif (j > 0)\n\t\t\t\tval += prev_row[j - 1] * t;\n\t\t\trow[j] = val;\n\t\t}\n\t}\n\n\t/*\n\t * The presence of many distinct rare (not in \"p\") elements materially\n\t * decreases selectivity.  Model their collective occurrence with the\n\t * Poisson distribution.\n\t */\n\tif (rest > DEFAULT_CONTAIN_SEL)\n\t{\n\t\tfloat\t\tt;\n\n\t\t/* Swap rows */\n\t\ttmp = row;\n\t\trow = prev_row;\n\t\tprev_row = tmp;\n\n\t\tfor (i = 0; i <= m; i++)\n\t\t\trow[i] = 0.0f;\n\n\t\t/* Value of Poisson distribution for 0 occurrences */\n\t\tt = exp(-rest);\n\n\t\t/*\n\t\t * Calculate convolution of previously computed distribution and the\n\t\t * Poisson distribution.\n\t\t */\n\t\tfor (i = 0; i <= m; i++)\n\t\t{\n\t\t\tfor (j = 0; j <= m - i; j++)\n\t\t\t\trow[j + i] += prev_row[j] * t;\n\n\t\t\t/* Get Poisson distribution value for (i + 1) occurrences */\n\t\t\tt *= rest / (float) (i + 1);\n\t\t}\n\t}\n\n\tpfree(prev_row);\n\treturn row;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define DEFAULT_CONTAIN_SEL 0.005"
    ],
    "globals_used": [
      "static float *calc_hist(const float4 *hist, int nhist, int n);",
      "static float *calc_distr(const float *p, int n, int m, float rest);",
      "static int\tfloor_log2(uint32 n);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "prev_row"
          ],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exp",
          "args": [
            "-rest"
          ],
          "line": 1069
        },
        "resolved": true,
        "details": {
          "function_name": "pg_get_expr_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ruleutils.c",
          "lines": "2341-2364",
          "snippet": "Datum\npg_get_expr_ext(PG_FUNCTION_ARGS)\n{\n\ttext\t   *expr = PG_GETARG_TEXT_PP(0);\n\tOid\t\t\trelid = PG_GETARG_OID(1);\n\tbool\t\tpretty = PG_GETARG_BOOL(2);\n\tint\t\t\tprettyFlags;\n\tchar\t   *relname;\n\n\tprettyFlags = pretty ? (PRETTYFLAG_PAREN | PRETTYFLAG_INDENT | PRETTYFLAG_SCHEMA) : PRETTYFLAG_INDENT;\n\n\tif (OidIsValid(relid))\n\t{\n\t\t/* Get the name for the relation */\n\t\trelname = get_rel_name(relid);\n\t\t/* See notes above */\n\t\tif (relname == NULL)\n\t\t\tPG_RETURN_NULL();\n\t}\n\telse\n\t\trelname = NULL;\n\n\tPG_RETURN_TEXT_P(pg_get_expr_worker(expr, relid, relname, prettyFlags));\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/ruleutils.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"rewrite/rewriteSupport.h\"",
            "#include \"rewrite/rewriteManip.h\"",
            "#include \"rewrite/rewriteHandler.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parser.h\"",
            "#include \"parser/parse_oper.h\"",
            "#include \"parser/parse_func.h\"",
            "#include \"parser/parse_agg.h\"",
            "#include \"parser/parse_node.h\"",
            "#include \"optimizer/tlist.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"common/keywords.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/dependency.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/amapi.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define PRETTYFLAG_SCHEMA\t\t0x0004",
            "#define PRETTYFLAG_INDENT\t\t0x0002",
            "#define PRETTYFLAG_PAREN\t\t0x0001"
          ],
          "globals_used": [
            "static char *pg_get_triggerdef_worker(Oid trigid, bool pretty);",
            "static char *pg_get_ruledef_worker(Oid ruleoid, int prettyFlags);",
            "static text *pg_get_expr_worker(text *expr, Oid relid, const char *relname,\n\t\t\t\t   int prettyFlags);",
            "static void make_ruledef(StringInfo buf, HeapTuple ruletup, TupleDesc rulettc,\n\t\t\t int prettyFlags);",
            "static const char *get_simple_binary_op_name(OpExpr *expr);",
            "static bool isSimpleNode(Node *node, Node *parentNode, int prettyFlags);",
            "static char *get_relation_name(Oid relid);",
            "static char *generate_qualified_relation_name(Oid relid);",
            "static char *flatten_reloptions(Oid relid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/ruleutils.h\"\n#include \"utils/rel.h\"\n#include \"utils/partcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"rewrite/rewriteSupport.h\"\n#include \"rewrite/rewriteManip.h\"\n#include \"rewrite/rewriteHandler.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parser.h\"\n#include \"parser/parse_oper.h\"\n#include \"parser/parse_func.h\"\n#include \"parser/parse_agg.h\"\n#include \"parser/parse_node.h\"\n#include \"optimizer/tlist.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"common/keywords.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/dependency.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/amapi.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define PRETTYFLAG_SCHEMA\t\t0x0004\n#define PRETTYFLAG_INDENT\t\t0x0002\n#define PRETTYFLAG_PAREN\t\t0x0001\n\nstatic char *pg_get_triggerdef_worker(Oid trigid, bool pretty);\nstatic char *pg_get_ruledef_worker(Oid ruleoid, int prettyFlags);\nstatic text *pg_get_expr_worker(text *expr, Oid relid, const char *relname,\n\t\t\t\t   int prettyFlags);\nstatic void make_ruledef(StringInfo buf, HeapTuple ruletup, TupleDesc rulettc,\n\t\t\t int prettyFlags);\nstatic const char *get_simple_binary_op_name(OpExpr *expr);\nstatic bool isSimpleNode(Node *node, Node *parentNode, int prettyFlags);\nstatic char *get_relation_name(Oid relid);\nstatic char *generate_qualified_relation_name(Oid relid);\nstatic char *flatten_reloptions(Oid relid);\n\nDatum\npg_get_expr_ext(PG_FUNCTION_ARGS)\n{\n\ttext\t   *expr = PG_GETARG_TEXT_PP(0);\n\tOid\t\t\trelid = PG_GETARG_OID(1);\n\tbool\t\tpretty = PG_GETARG_BOOL(2);\n\tint\t\t\tprettyFlags;\n\tchar\t   *relname;\n\n\tprettyFlags = pretty ? (PRETTYFLAG_PAREN | PRETTYFLAG_INDENT | PRETTYFLAG_SCHEMA) : PRETTYFLAG_INDENT;\n\n\tif (OidIsValid(relid))\n\t{\n\t\t/* Get the name for the relation */\n\t\trelname = get_rel_name(relid);\n\t\t/* See notes above */\n\t\tif (relname == NULL)\n\t\t\tPG_RETURN_NULL();\n\t}\n\telse\n\t\trelname = NULL;\n\n\tPG_RETURN_TEXT_P(pg_get_expr_worker(expr, relid, relname, prettyFlags));\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "(m + 1) * sizeof(float)"
          ],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/clauses.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\n#define DEFAULT_CONTAIN_SEL 0.005\n\nstatic float *calc_hist(const float4 *hist, int nhist, int n);\nstatic float *calc_distr(const float *p, int n, int m, float rest);\nstatic int\tfloor_log2(uint32 n);\n\nstatic float *\ncalc_distr(const float *p, int n, int m, float rest)\n{\n\tfloat\t   *row,\n\t\t\t   *prev_row,\n\t\t\t   *tmp;\n\tint\t\t\ti,\n\t\t\t\tj;\n\n\t/*\n\t * Since we return only the last row of the matrix and need only the\n\t * current and previous row for calculations, allocate two rows.\n\t */\n\trow = (float *) palloc((m + 1) * sizeof(float));\n\tprev_row = (float *) palloc((m + 1) * sizeof(float));\n\n\t/* M[0,0] = 1 */\n\trow[0] = 1.0f;\n\tfor (i = 1; i <= n; i++)\n\t{\n\t\tfloat\t\tt = p[i - 1];\n\n\t\t/* Swap rows */\n\t\ttmp = row;\n\t\trow = prev_row;\n\t\tprev_row = tmp;\n\n\t\t/* Calculate next row */\n\t\tfor (j = 0; j <= i && j <= m; j++)\n\t\t{\n\t\t\tfloat\t\tval = 0.0f;\n\n\t\t\tif (j < i)\n\t\t\t\tval += prev_row[j] * (1.0f - t);\n\t\t\tif (j > 0)\n\t\t\t\tval += prev_row[j - 1] * t;\n\t\t\trow[j] = val;\n\t\t}\n\t}\n\n\t/*\n\t * The presence of many distinct rare (not in \"p\") elements materially\n\t * decreases selectivity.  Model their collective occurrence with the\n\t * Poisson distribution.\n\t */\n\tif (rest > DEFAULT_CONTAIN_SEL)\n\t{\n\t\tfloat\t\tt;\n\n\t\t/* Swap rows */\n\t\ttmp = row;\n\t\trow = prev_row;\n\t\tprev_row = tmp;\n\n\t\tfor (i = 0; i <= m; i++)\n\t\t\trow[i] = 0.0f;\n\n\t\t/* Value of Poisson distribution for 0 occurrences */\n\t\tt = exp(-rest);\n\n\t\t/*\n\t\t * Calculate convolution of previously computed distribution and the\n\t\t * Poisson distribution.\n\t\t */\n\t\tfor (i = 0; i <= m; i++)\n\t\t{\n\t\t\tfor (j = 0; j <= m - i; j++)\n\t\t\t\trow[j + i] += prev_row[j] * t;\n\n\t\t\t/* Get Poisson distribution value for (i + 1) occurrences */\n\t\t\tt *= rest / (float) (i + 1);\n\t\t}\n\t}\n\n\tpfree(prev_row);\n\treturn row;\n}"
  },
  {
    "function_name": "calc_hist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_selfuncs.c",
    "lines": "922-993",
    "snippet": "static float *\ncalc_hist(const float4 *hist, int nhist, int n)\n{\n\tfloat\t   *hist_part;\n\tint\t\t\tk,\n\t\t\t\ti = 0;\n\tfloat\t\tprev_interval = 0,\n\t\t\t\tnext_interval;\n\tfloat\t\tfrac;\n\n\thist_part = (float *) palloc((n + 1) * sizeof(float));\n\n\t/*\n\t * frac is a probability contribution for each interval between histogram\n\t * values.  We have nhist - 1 intervals, so contribution of each one will\n\t * be 1 / (nhist - 1).\n\t */\n\tfrac = 1.0f / ((float) (nhist - 1));\n\n\tfor (k = 0; k <= n; k++)\n\t{\n\t\tint\t\t\tcount = 0;\n\n\t\t/*\n\t\t * Count the histogram boundaries equal to k.  (Although the histogram\n\t\t * should theoretically contain only exact integers, entries are\n\t\t * floats so there could be roundoff error in large values.  Treat any\n\t\t * fractional value as equal to the next larger k.)\n\t\t */\n\t\twhile (i < nhist && hist[i] <= k)\n\t\t{\n\t\t\tcount++;\n\t\t\ti++;\n\t\t}\n\n\t\tif (count > 0)\n\t\t{\n\t\t\t/* k is an exact bound for at least one histogram box. */\n\t\t\tfloat\t\tval;\n\n\t\t\t/* Find length between current histogram value and the next one */\n\t\t\tif (i < nhist)\n\t\t\t\tnext_interval = hist[i] - hist[i - 1];\n\t\t\telse\n\t\t\t\tnext_interval = 0;\n\n\t\t\t/*\n\t\t\t * count - 1 histogram boxes contain k exclusively.  They\n\t\t\t * contribute a total of (count - 1) * frac probability.  Also\n\t\t\t * factor in the partial histogram boxes on either side.\n\t\t\t */\n\t\t\tval = (float) (count - 1);\n\t\t\tif (next_interval > 0)\n\t\t\t\tval += 0.5f / next_interval;\n\t\t\tif (prev_interval > 0)\n\t\t\t\tval += 0.5f / prev_interval;\n\t\t\thist_part[k] = frac * val;\n\n\t\t\tprev_interval = next_interval;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* k does not appear as an exact histogram bound. */\n\t\t\tif (prev_interval > 0)\n\t\t\t\thist_part[k] = frac / prev_interval;\n\t\t\telse\n\t\t\t\thist_part[k] = 0.0f;\n\t\t}\n\t}\n\n\treturn hist_part;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static float *calc_hist(const float4 *hist, int nhist, int n);",
      "static int\tfloor_log2(uint32 n);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "(n + 1) * sizeof(float)"
          ],
          "line": 932
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/clauses.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nstatic float *calc_hist(const float4 *hist, int nhist, int n);\nstatic int\tfloor_log2(uint32 n);\n\nstatic float *\ncalc_hist(const float4 *hist, int nhist, int n)\n{\n\tfloat\t   *hist_part;\n\tint\t\t\tk,\n\t\t\t\ti = 0;\n\tfloat\t\tprev_interval = 0,\n\t\t\t\tnext_interval;\n\tfloat\t\tfrac;\n\n\thist_part = (float *) palloc((n + 1) * sizeof(float));\n\n\t/*\n\t * frac is a probability contribution for each interval between histogram\n\t * values.  We have nhist - 1 intervals, so contribution of each one will\n\t * be 1 / (nhist - 1).\n\t */\n\tfrac = 1.0f / ((float) (nhist - 1));\n\n\tfor (k = 0; k <= n; k++)\n\t{\n\t\tint\t\t\tcount = 0;\n\n\t\t/*\n\t\t * Count the histogram boundaries equal to k.  (Although the histogram\n\t\t * should theoretically contain only exact integers, entries are\n\t\t * floats so there could be roundoff error in large values.  Treat any\n\t\t * fractional value as equal to the next larger k.)\n\t\t */\n\t\twhile (i < nhist && hist[i] <= k)\n\t\t{\n\t\t\tcount++;\n\t\t\ti++;\n\t\t}\n\n\t\tif (count > 0)\n\t\t{\n\t\t\t/* k is an exact bound for at least one histogram box. */\n\t\t\tfloat\t\tval;\n\n\t\t\t/* Find length between current histogram value and the next one */\n\t\t\tif (i < nhist)\n\t\t\t\tnext_interval = hist[i] - hist[i - 1];\n\t\t\telse\n\t\t\t\tnext_interval = 0;\n\n\t\t\t/*\n\t\t\t * count - 1 histogram boxes contain k exclusively.  They\n\t\t\t * contribute a total of (count - 1) * frac probability.  Also\n\t\t\t * factor in the partial histogram boxes on either side.\n\t\t\t */\n\t\t\tval = (float) (count - 1);\n\t\t\tif (next_interval > 0)\n\t\t\t\tval += 0.5f / next_interval;\n\t\t\tif (prev_interval > 0)\n\t\t\t\tval += 0.5f / prev_interval;\n\t\t\thist_part[k] = frac * val;\n\n\t\t\tprev_interval = next_interval;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* k does not appear as an exact histogram bound. */\n\t\t\tif (prev_interval > 0)\n\t\t\t\thist_part[k] = frac / prev_interval;\n\t\t\telse\n\t\t\t\thist_part[k] = 0.0f;\n\t\t}\n\t}\n\n\treturn hist_part;\n}"
  },
  {
    "function_name": "mcelem_array_contained_selec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_selfuncs.c",
    "lines": "697-909",
    "snippet": "static Selectivity\nmcelem_array_contained_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t Datum *array_data, int nitems,\n\t\t\t\t\t\t\t float4 *hist, int nhist,\n\t\t\t\t\t\t\t Oid operator, FmgrInfo *cmpfunc)\n{\n\tint\t\t\tmcelem_index,\n\t\t\t\ti,\n\t\t\t\tunique_nitems = 0;\n\tfloat\t\tselec,\n\t\t\t\tminfreq,\n\t\t\t\tnullelem_freq;\n\tfloat\t   *dist,\n\t\t\t   *mcelem_dist,\n\t\t\t   *hist_part;\n\tfloat\t\tavg_count,\n\t\t\t\tmult,\n\t\t\t\trest;\n\tfloat\t   *elem_selec;\n\n\t/*\n\t * There should be three more Numbers than Values in the MCELEM slot,\n\t * because the last three cells should hold minimal and maximal frequency\n\t * among the non-null elements, and then the frequency of null elements.\n\t * Punt if not right, because we can't do much without the element freqs.\n\t */\n\tif (numbers == NULL || nnumbers != nmcelem + 3)\n\t\treturn DEFAULT_CONTAIN_SEL;\n\n\t/* Can't do much without a count histogram, either */\n\tif (hist == NULL || nhist < 3)\n\t\treturn DEFAULT_CONTAIN_SEL;\n\n\t/*\n\t * Grab some of the summary statistics that compute_array_stats() stores:\n\t * lowest frequency, frequency of null elements, and average distinct\n\t * element count.\n\t */\n\tminfreq = numbers[nmcelem];\n\tnullelem_freq = numbers[nmcelem + 2];\n\tavg_count = hist[nhist - 1];\n\n\t/*\n\t * \"rest\" will be the sum of the frequencies of all elements not\n\t * represented in MCELEM.  The average distinct element count is the sum\n\t * of the frequencies of *all* elements.  Begin with that; we will proceed\n\t * to subtract the MCELEM frequencies.\n\t */\n\trest = avg_count;\n\n\t/*\n\t * mult is a multiplier representing estimate of probability that each\n\t * mcelem that is not present in constant doesn't occur.\n\t */\n\tmult = 1.0f;\n\n\t/*\n\t * elem_selec is array of estimated frequencies for elements in the\n\t * constant.\n\t */\n\telem_selec = (float *) palloc(sizeof(float) * nitems);\n\n\t/* Scan mcelem and array in parallel. */\n\tmcelem_index = 0;\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tbool\t\tmatch = false;\n\n\t\t/* Ignore any duplicates in the array data. */\n\t\tif (i > 0 &&\n\t\t\telement_compare(&array_data[i - 1], &array_data[i], cmpfunc) == 0)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Iterate over MCELEM until we find an entry greater than or equal to\n\t\t * this element of the constant.  Update \"rest\" and \"mult\" for mcelem\n\t\t * entries skipped over.\n\t\t */\n\t\twhile (mcelem_index < nmcelem)\n\t\t{\n\t\t\tint\t\t\tcmp = element_compare(&mcelem[mcelem_index],\n\t\t\t\t\t\t\t\t\t\t\t  &array_data[i],\n\t\t\t\t\t\t\t\t\t\t\t  cmpfunc);\n\n\t\t\tif (cmp < 0)\n\t\t\t{\n\t\t\t\tmult *= (1.0f - numbers[mcelem_index]);\n\t\t\t\trest -= numbers[mcelem_index];\n\t\t\t\tmcelem_index++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (cmp == 0)\n\t\t\t\t\tmatch = true;\t/* mcelem is found */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (match)\n\t\t{\n\t\t\t/* MCELEM matches the array item. */\n\t\t\telem_selec[unique_nitems] = numbers[mcelem_index];\n\t\t\t/* \"rest\" is decremented for all mcelems, matched or not */\n\t\t\trest -= numbers[mcelem_index];\n\t\t\tmcelem_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * The element is not in MCELEM.  Punt, but assume that the\n\t\t\t * selectivity cannot be more than minfreq / 2.\n\t\t\t */\n\t\t\telem_selec[unique_nitems] = Min(DEFAULT_CONTAIN_SEL,\n\t\t\t\t\t\t\t\t\t\t\tminfreq / 2);\n\t\t}\n\n\t\tunique_nitems++;\n\t}\n\n\t/*\n\t * If we handled all constant elements without exhausting the MCELEM\n\t * array, finish walking it to complete calculation of \"rest\" and \"mult\".\n\t */\n\twhile (mcelem_index < nmcelem)\n\t{\n\t\tmult *= (1.0f - numbers[mcelem_index]);\n\t\trest -= numbers[mcelem_index];\n\t\tmcelem_index++;\n\t}\n\n\t/*\n\t * The presence of many distinct rare elements materially decreases\n\t * selectivity.  Use the Poisson distribution to estimate the probability\n\t * of a column value having zero occurrences of such elements.  See above\n\t * for the definition of \"rest\".\n\t */\n\tmult *= exp(-rest);\n\n\t/*----------\n\t * Using the distinct element count histogram requires\n\t *\t\tO(unique_nitems * (nmcelem + unique_nitems))\n\t * operations.  Beyond a certain computational cost threshold, it's\n\t * reasonable to sacrifice accuracy for decreased planning time.  We limit\n\t * the number of operations to EFFORT * nmcelem; since nmcelem is limited\n\t * by the column's statistics target, the work done is user-controllable.\n\t *\n\t * If the number of operations would be too large, we can reduce it\n\t * without losing all accuracy by reducing unique_nitems and considering\n\t * only the most-common elements of the constant array.  To make the\n\t * results exactly match what we would have gotten with only those\n\t * elements to start with, we'd have to remove any discarded elements'\n\t * frequencies from \"mult\", but since this is only an approximation\n\t * anyway, we don't bother with that.  Therefore it's sufficient to qsort\n\t * elem_selec[] and take the largest elements.  (They will no longer match\n\t * up with the elements of array_data[], but we don't care.)\n\t *----------\n\t */\n#define EFFORT 100\n\n\tif ((nmcelem + unique_nitems) > 0 &&\n\t\tunique_nitems > EFFORT * nmcelem / (nmcelem + unique_nitems))\n\t{\n\t\t/*\n\t\t * Use the quadratic formula to solve for largest allowable N.  We\n\t\t * have A = 1, B = nmcelem, C = - EFFORT * nmcelem.\n\t\t */\n\t\tdouble\t\tb = (double) nmcelem;\n\t\tint\t\t\tn;\n\n\t\tn = (int) ((sqrt(b * b + 4 * EFFORT * b) - b) / 2);\n\n\t\t/* Sort, then take just the first n elements */\n\t\tqsort(elem_selec, unique_nitems, sizeof(float),\n\t\t\t  float_compare_desc);\n\t\tunique_nitems = n;\n\t}\n\n\t/*\n\t * Calculate probabilities of each distinct element count for both mcelems\n\t * and constant elements.  At this point, assume independent element\n\t * occurrence.\n\t */\n\tdist = calc_distr(elem_selec, unique_nitems, unique_nitems, 0.0f);\n\tmcelem_dist = calc_distr(numbers, nmcelem, unique_nitems, rest);\n\n\t/* ignore hist[nhist-1], which is the average not a histogram member */\n\thist_part = calc_hist(hist, nhist - 1, unique_nitems);\n\n\tselec = 0.0f;\n\tfor (i = 0; i <= unique_nitems; i++)\n\t{\n\t\t/*\n\t\t * mult * dist[i] / mcelem_dist[i] gives us probability of qual\n\t\t * matching from assumption of independent element occurrence with the\n\t\t * condition that distinct element count = i.\n\t\t */\n\t\tif (mcelem_dist[i] > 0)\n\t\t\tselec += hist_part[i] * mult * dist[i] / mcelem_dist[i];\n\t}\n\n\tpfree(dist);\n\tpfree(mcelem_dist);\n\tpfree(hist_part);\n\tpfree(elem_selec);\n\n\t/* Take into account occurrence of NULL element. */\n\tselec *= (1.0f - nullelem_freq);\n\n\tCLAMP_PROBABILITY(selec);\n\n\treturn selec;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define EFFORT 100",
      "#define DEFAULT_CONTAIN_SEL 0.005"
    ],
    "globals_used": [
      "static Selectivity calc_arraycontsel(VariableStatData *vardata, Datum constval,\n\t\t\t\t  Oid elemtype, Oid operator);",
      "static Selectivity mcelem_array_selec(ArrayType *array,\n\t\t\t\t   TypeCacheEntry *typentry,\n\t\t\t\t   Datum *mcelem, int nmcelem,\n\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t   float4 *hist, int nhist,\n\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);",
      "static Selectivity mcelem_array_contain_overlap_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t\t   Datum *array_data, int nitems,\n\t\t\t\t\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);",
      "static Selectivity mcelem_array_contained_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t Datum *array_data, int nitems,\n\t\t\t\t\t\t\t float4 *hist, int nhist,\n\t\t\t\t\t\t\t Oid operator, FmgrInfo *cmpfunc);",
      "static float *calc_hist(const float4 *hist, int nhist, int n);",
      "static float *calc_distr(const float *p, int n, int m, float rest);",
      "static int\tfloor_log2(uint32 n);",
      "static bool find_next_mcelem(Datum *mcelem, int nmcelem, Datum value,\n\t\t\t\t int *index, FmgrInfo *cmpfunc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CLAMP_PROBABILITY",
          "args": [
            "selec"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "elem_selec"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "calc_hist",
          "args": [
            "hist",
            "nhist - 1",
            "unique_nitems"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "calc_hist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_selfuncs.c",
          "lines": "922-993",
          "snippet": "static float *\ncalc_hist(const float4 *hist, int nhist, int n)\n{\n\tfloat\t   *hist_part;\n\tint\t\t\tk,\n\t\t\t\ti = 0;\n\tfloat\t\tprev_interval = 0,\n\t\t\t\tnext_interval;\n\tfloat\t\tfrac;\n\n\thist_part = (float *) palloc((n + 1) * sizeof(float));\n\n\t/*\n\t * frac is a probability contribution for each interval between histogram\n\t * values.  We have nhist - 1 intervals, so contribution of each one will\n\t * be 1 / (nhist - 1).\n\t */\n\tfrac = 1.0f / ((float) (nhist - 1));\n\n\tfor (k = 0; k <= n; k++)\n\t{\n\t\tint\t\t\tcount = 0;\n\n\t\t/*\n\t\t * Count the histogram boundaries equal to k.  (Although the histogram\n\t\t * should theoretically contain only exact integers, entries are\n\t\t * floats so there could be roundoff error in large values.  Treat any\n\t\t * fractional value as equal to the next larger k.)\n\t\t */\n\t\twhile (i < nhist && hist[i] <= k)\n\t\t{\n\t\t\tcount++;\n\t\t\ti++;\n\t\t}\n\n\t\tif (count > 0)\n\t\t{\n\t\t\t/* k is an exact bound for at least one histogram box. */\n\t\t\tfloat\t\tval;\n\n\t\t\t/* Find length between current histogram value and the next one */\n\t\t\tif (i < nhist)\n\t\t\t\tnext_interval = hist[i] - hist[i - 1];\n\t\t\telse\n\t\t\t\tnext_interval = 0;\n\n\t\t\t/*\n\t\t\t * count - 1 histogram boxes contain k exclusively.  They\n\t\t\t * contribute a total of (count - 1) * frac probability.  Also\n\t\t\t * factor in the partial histogram boxes on either side.\n\t\t\t */\n\t\t\tval = (float) (count - 1);\n\t\t\tif (next_interval > 0)\n\t\t\t\tval += 0.5f / next_interval;\n\t\t\tif (prev_interval > 0)\n\t\t\t\tval += 0.5f / prev_interval;\n\t\t\thist_part[k] = frac * val;\n\n\t\t\tprev_interval = next_interval;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* k does not appear as an exact histogram bound. */\n\t\t\tif (prev_interval > 0)\n\t\t\t\thist_part[k] = frac / prev_interval;\n\t\t\telse\n\t\t\t\thist_part[k] = 0.0f;\n\t\t}\n\t}\n\n\treturn hist_part;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static float *calc_hist(const float4 *hist, int nhist, int n);",
            "static int\tfloor_log2(uint32 n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/clauses.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nstatic float *calc_hist(const float4 *hist, int nhist, int n);\nstatic int\tfloor_log2(uint32 n);\n\nstatic float *\ncalc_hist(const float4 *hist, int nhist, int n)\n{\n\tfloat\t   *hist_part;\n\tint\t\t\tk,\n\t\t\t\ti = 0;\n\tfloat\t\tprev_interval = 0,\n\t\t\t\tnext_interval;\n\tfloat\t\tfrac;\n\n\thist_part = (float *) palloc((n + 1) * sizeof(float));\n\n\t/*\n\t * frac is a probability contribution for each interval between histogram\n\t * values.  We have nhist - 1 intervals, so contribution of each one will\n\t * be 1 / (nhist - 1).\n\t */\n\tfrac = 1.0f / ((float) (nhist - 1));\n\n\tfor (k = 0; k <= n; k++)\n\t{\n\t\tint\t\t\tcount = 0;\n\n\t\t/*\n\t\t * Count the histogram boundaries equal to k.  (Although the histogram\n\t\t * should theoretically contain only exact integers, entries are\n\t\t * floats so there could be roundoff error in large values.  Treat any\n\t\t * fractional value as equal to the next larger k.)\n\t\t */\n\t\twhile (i < nhist && hist[i] <= k)\n\t\t{\n\t\t\tcount++;\n\t\t\ti++;\n\t\t}\n\n\t\tif (count > 0)\n\t\t{\n\t\t\t/* k is an exact bound for at least one histogram box. */\n\t\t\tfloat\t\tval;\n\n\t\t\t/* Find length between current histogram value and the next one */\n\t\t\tif (i < nhist)\n\t\t\t\tnext_interval = hist[i] - hist[i - 1];\n\t\t\telse\n\t\t\t\tnext_interval = 0;\n\n\t\t\t/*\n\t\t\t * count - 1 histogram boxes contain k exclusively.  They\n\t\t\t * contribute a total of (count - 1) * frac probability.  Also\n\t\t\t * factor in the partial histogram boxes on either side.\n\t\t\t */\n\t\t\tval = (float) (count - 1);\n\t\t\tif (next_interval > 0)\n\t\t\t\tval += 0.5f / next_interval;\n\t\t\tif (prev_interval > 0)\n\t\t\t\tval += 0.5f / prev_interval;\n\t\t\thist_part[k] = frac * val;\n\n\t\t\tprev_interval = next_interval;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* k does not appear as an exact histogram bound. */\n\t\t\tif (prev_interval > 0)\n\t\t\t\thist_part[k] = frac / prev_interval;\n\t\t\telse\n\t\t\t\thist_part[k] = 0.0f;\n\t\t}\n\t}\n\n\treturn hist_part;\n}"
        }
      },
      {
        "call_info": {
          "callee": "calc_distr",
          "args": [
            "numbers",
            "nmcelem",
            "unique_nitems",
            "rest"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "calc_distr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_selfuncs.c",
          "lines": "1011-1087",
          "snippet": "static float *\ncalc_distr(const float *p, int n, int m, float rest)\n{\n\tfloat\t   *row,\n\t\t\t   *prev_row,\n\t\t\t   *tmp;\n\tint\t\t\ti,\n\t\t\t\tj;\n\n\t/*\n\t * Since we return only the last row of the matrix and need only the\n\t * current and previous row for calculations, allocate two rows.\n\t */\n\trow = (float *) palloc((m + 1) * sizeof(float));\n\tprev_row = (float *) palloc((m + 1) * sizeof(float));\n\n\t/* M[0,0] = 1 */\n\trow[0] = 1.0f;\n\tfor (i = 1; i <= n; i++)\n\t{\n\t\tfloat\t\tt = p[i - 1];\n\n\t\t/* Swap rows */\n\t\ttmp = row;\n\t\trow = prev_row;\n\t\tprev_row = tmp;\n\n\t\t/* Calculate next row */\n\t\tfor (j = 0; j <= i && j <= m; j++)\n\t\t{\n\t\t\tfloat\t\tval = 0.0f;\n\n\t\t\tif (j < i)\n\t\t\t\tval += prev_row[j] * (1.0f - t);\n\t\t\tif (j > 0)\n\t\t\t\tval += prev_row[j - 1] * t;\n\t\t\trow[j] = val;\n\t\t}\n\t}\n\n\t/*\n\t * The presence of many distinct rare (not in \"p\") elements materially\n\t * decreases selectivity.  Model their collective occurrence with the\n\t * Poisson distribution.\n\t */\n\tif (rest > DEFAULT_CONTAIN_SEL)\n\t{\n\t\tfloat\t\tt;\n\n\t\t/* Swap rows */\n\t\ttmp = row;\n\t\trow = prev_row;\n\t\tprev_row = tmp;\n\n\t\tfor (i = 0; i <= m; i++)\n\t\t\trow[i] = 0.0f;\n\n\t\t/* Value of Poisson distribution for 0 occurrences */\n\t\tt = exp(-rest);\n\n\t\t/*\n\t\t * Calculate convolution of previously computed distribution and the\n\t\t * Poisson distribution.\n\t\t */\n\t\tfor (i = 0; i <= m; i++)\n\t\t{\n\t\t\tfor (j = 0; j <= m - i; j++)\n\t\t\t\trow[j + i] += prev_row[j] * t;\n\n\t\t\t/* Get Poisson distribution value for (i + 1) occurrences */\n\t\t\tt *= rest / (float) (i + 1);\n\t\t}\n\t}\n\n\tpfree(prev_row);\n\treturn row;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DEFAULT_CONTAIN_SEL 0.005"
          ],
          "globals_used": [
            "static float *calc_hist(const float4 *hist, int nhist, int n);",
            "static float *calc_distr(const float *p, int n, int m, float rest);",
            "static int\tfloor_log2(uint32 n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/clauses.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\n#define DEFAULT_CONTAIN_SEL 0.005\n\nstatic float *calc_hist(const float4 *hist, int nhist, int n);\nstatic float *calc_distr(const float *p, int n, int m, float rest);\nstatic int\tfloor_log2(uint32 n);\n\nstatic float *\ncalc_distr(const float *p, int n, int m, float rest)\n{\n\tfloat\t   *row,\n\t\t\t   *prev_row,\n\t\t\t   *tmp;\n\tint\t\t\ti,\n\t\t\t\tj;\n\n\t/*\n\t * Since we return only the last row of the matrix and need only the\n\t * current and previous row for calculations, allocate two rows.\n\t */\n\trow = (float *) palloc((m + 1) * sizeof(float));\n\tprev_row = (float *) palloc((m + 1) * sizeof(float));\n\n\t/* M[0,0] = 1 */\n\trow[0] = 1.0f;\n\tfor (i = 1; i <= n; i++)\n\t{\n\t\tfloat\t\tt = p[i - 1];\n\n\t\t/* Swap rows */\n\t\ttmp = row;\n\t\trow = prev_row;\n\t\tprev_row = tmp;\n\n\t\t/* Calculate next row */\n\t\tfor (j = 0; j <= i && j <= m; j++)\n\t\t{\n\t\t\tfloat\t\tval = 0.0f;\n\n\t\t\tif (j < i)\n\t\t\t\tval += prev_row[j] * (1.0f - t);\n\t\t\tif (j > 0)\n\t\t\t\tval += prev_row[j - 1] * t;\n\t\t\trow[j] = val;\n\t\t}\n\t}\n\n\t/*\n\t * The presence of many distinct rare (not in \"p\") elements materially\n\t * decreases selectivity.  Model their collective occurrence with the\n\t * Poisson distribution.\n\t */\n\tif (rest > DEFAULT_CONTAIN_SEL)\n\t{\n\t\tfloat\t\tt;\n\n\t\t/* Swap rows */\n\t\ttmp = row;\n\t\trow = prev_row;\n\t\tprev_row = tmp;\n\n\t\tfor (i = 0; i <= m; i++)\n\t\t\trow[i] = 0.0f;\n\n\t\t/* Value of Poisson distribution for 0 occurrences */\n\t\tt = exp(-rest);\n\n\t\t/*\n\t\t * Calculate convolution of previously computed distribution and the\n\t\t * Poisson distribution.\n\t\t */\n\t\tfor (i = 0; i <= m; i++)\n\t\t{\n\t\t\tfor (j = 0; j <= m - i; j++)\n\t\t\t\trow[j + i] += prev_row[j] * t;\n\n\t\t\t/* Get Poisson distribution value for (i + 1) occurrences */\n\t\t\tt *= rest / (float) (i + 1);\n\t\t}\n\t}\n\n\tpfree(prev_row);\n\treturn row;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qsort",
          "args": [
            "elem_selec",
            "unique_nitems",
            "sizeof(float)",
            "float_compare_desc"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sqrt",
          "args": [
            "b * b + 4 * EFFORT * b"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "dsqrt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "1613-1628",
          "snippet": "Datum\ndsqrt(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\tif (arg1 < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_ARGUMENT_FOR_POWER_FUNCTION),\n\t\t\t\t errmsg(\"cannot take square root of a negative number\")));\n\n\tresult = sqrt(arg1);\n\n\tCHECKFLOATVAL(result, isinf(arg1), arg1 == 0);\n\tPG_RETURN_FLOAT8(result);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndsqrt(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\tif (arg1 < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_ARGUMENT_FOR_POWER_FUNCTION),\n\t\t\t\t errmsg(\"cannot take square root of a negative number\")));\n\n\tresult = sqrt(arg1);\n\n\tCHECKFLOATVAL(result, isinf(arg1), arg1 == 0);\n\tPG_RETURN_FLOAT8(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exp",
          "args": [
            "-rest"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "pg_get_expr_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ruleutils.c",
          "lines": "2341-2364",
          "snippet": "Datum\npg_get_expr_ext(PG_FUNCTION_ARGS)\n{\n\ttext\t   *expr = PG_GETARG_TEXT_PP(0);\n\tOid\t\t\trelid = PG_GETARG_OID(1);\n\tbool\t\tpretty = PG_GETARG_BOOL(2);\n\tint\t\t\tprettyFlags;\n\tchar\t   *relname;\n\n\tprettyFlags = pretty ? (PRETTYFLAG_PAREN | PRETTYFLAG_INDENT | PRETTYFLAG_SCHEMA) : PRETTYFLAG_INDENT;\n\n\tif (OidIsValid(relid))\n\t{\n\t\t/* Get the name for the relation */\n\t\trelname = get_rel_name(relid);\n\t\t/* See notes above */\n\t\tif (relname == NULL)\n\t\t\tPG_RETURN_NULL();\n\t}\n\telse\n\t\trelname = NULL;\n\n\tPG_RETURN_TEXT_P(pg_get_expr_worker(expr, relid, relname, prettyFlags));\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/ruleutils.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"rewrite/rewriteSupport.h\"",
            "#include \"rewrite/rewriteManip.h\"",
            "#include \"rewrite/rewriteHandler.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parser.h\"",
            "#include \"parser/parse_oper.h\"",
            "#include \"parser/parse_func.h\"",
            "#include \"parser/parse_agg.h\"",
            "#include \"parser/parse_node.h\"",
            "#include \"optimizer/tlist.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"common/keywords.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/dependency.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/amapi.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define PRETTYFLAG_SCHEMA\t\t0x0004",
            "#define PRETTYFLAG_INDENT\t\t0x0002",
            "#define PRETTYFLAG_PAREN\t\t0x0001"
          ],
          "globals_used": [
            "static char *pg_get_triggerdef_worker(Oid trigid, bool pretty);",
            "static char *pg_get_ruledef_worker(Oid ruleoid, int prettyFlags);",
            "static text *pg_get_expr_worker(text *expr, Oid relid, const char *relname,\n\t\t\t\t   int prettyFlags);",
            "static void make_ruledef(StringInfo buf, HeapTuple ruletup, TupleDesc rulettc,\n\t\t\t int prettyFlags);",
            "static const char *get_simple_binary_op_name(OpExpr *expr);",
            "static bool isSimpleNode(Node *node, Node *parentNode, int prettyFlags);",
            "static char *get_relation_name(Oid relid);",
            "static char *generate_qualified_relation_name(Oid relid);",
            "static char *flatten_reloptions(Oid relid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/ruleutils.h\"\n#include \"utils/rel.h\"\n#include \"utils/partcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"rewrite/rewriteSupport.h\"\n#include \"rewrite/rewriteManip.h\"\n#include \"rewrite/rewriteHandler.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parser.h\"\n#include \"parser/parse_oper.h\"\n#include \"parser/parse_func.h\"\n#include \"parser/parse_agg.h\"\n#include \"parser/parse_node.h\"\n#include \"optimizer/tlist.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"common/keywords.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/dependency.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/amapi.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define PRETTYFLAG_SCHEMA\t\t0x0004\n#define PRETTYFLAG_INDENT\t\t0x0002\n#define PRETTYFLAG_PAREN\t\t0x0001\n\nstatic char *pg_get_triggerdef_worker(Oid trigid, bool pretty);\nstatic char *pg_get_ruledef_worker(Oid ruleoid, int prettyFlags);\nstatic text *pg_get_expr_worker(text *expr, Oid relid, const char *relname,\n\t\t\t\t   int prettyFlags);\nstatic void make_ruledef(StringInfo buf, HeapTuple ruletup, TupleDesc rulettc,\n\t\t\t int prettyFlags);\nstatic const char *get_simple_binary_op_name(OpExpr *expr);\nstatic bool isSimpleNode(Node *node, Node *parentNode, int prettyFlags);\nstatic char *get_relation_name(Oid relid);\nstatic char *generate_qualified_relation_name(Oid relid);\nstatic char *flatten_reloptions(Oid relid);\n\nDatum\npg_get_expr_ext(PG_FUNCTION_ARGS)\n{\n\ttext\t   *expr = PG_GETARG_TEXT_PP(0);\n\tOid\t\t\trelid = PG_GETARG_OID(1);\n\tbool\t\tpretty = PG_GETARG_BOOL(2);\n\tint\t\t\tprettyFlags;\n\tchar\t   *relname;\n\n\tprettyFlags = pretty ? (PRETTYFLAG_PAREN | PRETTYFLAG_INDENT | PRETTYFLAG_SCHEMA) : PRETTYFLAG_INDENT;\n\n\tif (OidIsValid(relid))\n\t{\n\t\t/* Get the name for the relation */\n\t\trelname = get_rel_name(relid);\n\t\t/* See notes above */\n\t\tif (relname == NULL)\n\t\t\tPG_RETURN_NULL();\n\t}\n\telse\n\t\trelname = NULL;\n\n\tPG_RETURN_TEXT_P(pg_get_expr_worker(expr, relid, relname, prettyFlags));\n}"
        }
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "DEFAULT_CONTAIN_SEL",
            "minfreq / 2"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "element_compare",
          "args": [
            "&mcelem[mcelem_index]",
            "&array_data[i]",
            "cmpfunc"
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "element_compare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_selfuncs.c",
          "lines": "1166-1176",
          "snippet": "static int\nelement_compare(const void *key1, const void *key2, void *arg)\n{\n\tDatum\t\td1 = *((const Datum *) key1);\n\tDatum\t\td2 = *((const Datum *) key2);\n\tFmgrInfo   *cmpfunc = (FmgrInfo *) arg;\n\tDatum\t\tc;\n\n\tc = FunctionCall2Coll(cmpfunc, DEFAULT_COLLATION_OID, d1, d2);\n\treturn DatumGetInt32(c);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Selectivity mcelem_array_selec(ArrayType *array,\n\t\t\t\t   TypeCacheEntry *typentry,\n\t\t\t\t   Datum *mcelem, int nmcelem,\n\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t   float4 *hist, int nhist,\n\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);",
            "static Selectivity mcelem_array_contain_overlap_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t\t   Datum *array_data, int nitems,\n\t\t\t\t\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);",
            "static Selectivity mcelem_array_contained_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t Datum *array_data, int nitems,\n\t\t\t\t\t\t\t float4 *hist, int nhist,\n\t\t\t\t\t\t\t Oid operator, FmgrInfo *cmpfunc);",
            "static bool find_next_mcelem(Datum *mcelem, int nmcelem, Datum value,\n\t\t\t\t int *index, FmgrInfo *cmpfunc);",
            "static int\telement_compare(const void *key1, const void *key2, void *arg);",
            "static int\tfloat_compare_desc(const void *key1, const void *key2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/clauses.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Selectivity mcelem_array_selec(ArrayType *array,\n\t\t\t\t   TypeCacheEntry *typentry,\n\t\t\t\t   Datum *mcelem, int nmcelem,\n\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t   float4 *hist, int nhist,\n\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);\nstatic Selectivity mcelem_array_contain_overlap_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t\t   Datum *array_data, int nitems,\n\t\t\t\t\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);\nstatic Selectivity mcelem_array_contained_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t Datum *array_data, int nitems,\n\t\t\t\t\t\t\t float4 *hist, int nhist,\n\t\t\t\t\t\t\t Oid operator, FmgrInfo *cmpfunc);\nstatic bool find_next_mcelem(Datum *mcelem, int nmcelem, Datum value,\n\t\t\t\t int *index, FmgrInfo *cmpfunc);\nstatic int\telement_compare(const void *key1, const void *key2, void *arg);\nstatic int\tfloat_compare_desc(const void *key1, const void *key2);\n\nstatic int\nelement_compare(const void *key1, const void *key2, void *arg)\n{\n\tDatum\t\td1 = *((const Datum *) key1);\n\tDatum\t\td2 = *((const Datum *) key2);\n\tFmgrInfo   *cmpfunc = (FmgrInfo *) arg;\n\tDatum\t\tc;\n\n\tc = FunctionCall2Coll(cmpfunc, DEFAULT_COLLATION_OID, d1, d2);\n\treturn DatumGetInt32(c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(float) * nitems"
          ],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/clauses.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\n#define EFFORT 100\n#define DEFAULT_CONTAIN_SEL 0.005\n\nstatic Selectivity calc_arraycontsel(VariableStatData *vardata, Datum constval,\n\t\t\t\t  Oid elemtype, Oid operator);\nstatic Selectivity mcelem_array_selec(ArrayType *array,\n\t\t\t\t   TypeCacheEntry *typentry,\n\t\t\t\t   Datum *mcelem, int nmcelem,\n\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t   float4 *hist, int nhist,\n\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);\nstatic Selectivity mcelem_array_contain_overlap_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t\t   Datum *array_data, int nitems,\n\t\t\t\t\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);\nstatic Selectivity mcelem_array_contained_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t Datum *array_data, int nitems,\n\t\t\t\t\t\t\t float4 *hist, int nhist,\n\t\t\t\t\t\t\t Oid operator, FmgrInfo *cmpfunc);\nstatic float *calc_hist(const float4 *hist, int nhist, int n);\nstatic float *calc_distr(const float *p, int n, int m, float rest);\nstatic int\tfloor_log2(uint32 n);\nstatic bool find_next_mcelem(Datum *mcelem, int nmcelem, Datum value,\n\t\t\t\t int *index, FmgrInfo *cmpfunc);\n\nstatic Selectivity\nmcelem_array_contained_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t Datum *array_data, int nitems,\n\t\t\t\t\t\t\t float4 *hist, int nhist,\n\t\t\t\t\t\t\t Oid operator, FmgrInfo *cmpfunc)\n{\n\tint\t\t\tmcelem_index,\n\t\t\t\ti,\n\t\t\t\tunique_nitems = 0;\n\tfloat\t\tselec,\n\t\t\t\tminfreq,\n\t\t\t\tnullelem_freq;\n\tfloat\t   *dist,\n\t\t\t   *mcelem_dist,\n\t\t\t   *hist_part;\n\tfloat\t\tavg_count,\n\t\t\t\tmult,\n\t\t\t\trest;\n\tfloat\t   *elem_selec;\n\n\t/*\n\t * There should be three more Numbers than Values in the MCELEM slot,\n\t * because the last three cells should hold minimal and maximal frequency\n\t * among the non-null elements, and then the frequency of null elements.\n\t * Punt if not right, because we can't do much without the element freqs.\n\t */\n\tif (numbers == NULL || nnumbers != nmcelem + 3)\n\t\treturn DEFAULT_CONTAIN_SEL;\n\n\t/* Can't do much without a count histogram, either */\n\tif (hist == NULL || nhist < 3)\n\t\treturn DEFAULT_CONTAIN_SEL;\n\n\t/*\n\t * Grab some of the summary statistics that compute_array_stats() stores:\n\t * lowest frequency, frequency of null elements, and average distinct\n\t * element count.\n\t */\n\tminfreq = numbers[nmcelem];\n\tnullelem_freq = numbers[nmcelem + 2];\n\tavg_count = hist[nhist - 1];\n\n\t/*\n\t * \"rest\" will be the sum of the frequencies of all elements not\n\t * represented in MCELEM.  The average distinct element count is the sum\n\t * of the frequencies of *all* elements.  Begin with that; we will proceed\n\t * to subtract the MCELEM frequencies.\n\t */\n\trest = avg_count;\n\n\t/*\n\t * mult is a multiplier representing estimate of probability that each\n\t * mcelem that is not present in constant doesn't occur.\n\t */\n\tmult = 1.0f;\n\n\t/*\n\t * elem_selec is array of estimated frequencies for elements in the\n\t * constant.\n\t */\n\telem_selec = (float *) palloc(sizeof(float) * nitems);\n\n\t/* Scan mcelem and array in parallel. */\n\tmcelem_index = 0;\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tbool\t\tmatch = false;\n\n\t\t/* Ignore any duplicates in the array data. */\n\t\tif (i > 0 &&\n\t\t\telement_compare(&array_data[i - 1], &array_data[i], cmpfunc) == 0)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Iterate over MCELEM until we find an entry greater than or equal to\n\t\t * this element of the constant.  Update \"rest\" and \"mult\" for mcelem\n\t\t * entries skipped over.\n\t\t */\n\t\twhile (mcelem_index < nmcelem)\n\t\t{\n\t\t\tint\t\t\tcmp = element_compare(&mcelem[mcelem_index],\n\t\t\t\t\t\t\t\t\t\t\t  &array_data[i],\n\t\t\t\t\t\t\t\t\t\t\t  cmpfunc);\n\n\t\t\tif (cmp < 0)\n\t\t\t{\n\t\t\t\tmult *= (1.0f - numbers[mcelem_index]);\n\t\t\t\trest -= numbers[mcelem_index];\n\t\t\t\tmcelem_index++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (cmp == 0)\n\t\t\t\t\tmatch = true;\t/* mcelem is found */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (match)\n\t\t{\n\t\t\t/* MCELEM matches the array item. */\n\t\t\telem_selec[unique_nitems] = numbers[mcelem_index];\n\t\t\t/* \"rest\" is decremented for all mcelems, matched or not */\n\t\t\trest -= numbers[mcelem_index];\n\t\t\tmcelem_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * The element is not in MCELEM.  Punt, but assume that the\n\t\t\t * selectivity cannot be more than minfreq / 2.\n\t\t\t */\n\t\t\telem_selec[unique_nitems] = Min(DEFAULT_CONTAIN_SEL,\n\t\t\t\t\t\t\t\t\t\t\tminfreq / 2);\n\t\t}\n\n\t\tunique_nitems++;\n\t}\n\n\t/*\n\t * If we handled all constant elements without exhausting the MCELEM\n\t * array, finish walking it to complete calculation of \"rest\" and \"mult\".\n\t */\n\twhile (mcelem_index < nmcelem)\n\t{\n\t\tmult *= (1.0f - numbers[mcelem_index]);\n\t\trest -= numbers[mcelem_index];\n\t\tmcelem_index++;\n\t}\n\n\t/*\n\t * The presence of many distinct rare elements materially decreases\n\t * selectivity.  Use the Poisson distribution to estimate the probability\n\t * of a column value having zero occurrences of such elements.  See above\n\t * for the definition of \"rest\".\n\t */\n\tmult *= exp(-rest);\n\n\t/*----------\n\t * Using the distinct element count histogram requires\n\t *\t\tO(unique_nitems * (nmcelem + unique_nitems))\n\t * operations.  Beyond a certain computational cost threshold, it's\n\t * reasonable to sacrifice accuracy for decreased planning time.  We limit\n\t * the number of operations to EFFORT * nmcelem; since nmcelem is limited\n\t * by the column's statistics target, the work done is user-controllable.\n\t *\n\t * If the number of operations would be too large, we can reduce it\n\t * without losing all accuracy by reducing unique_nitems and considering\n\t * only the most-common elements of the constant array.  To make the\n\t * results exactly match what we would have gotten with only those\n\t * elements to start with, we'd have to remove any discarded elements'\n\t * frequencies from \"mult\", but since this is only an approximation\n\t * anyway, we don't bother with that.  Therefore it's sufficient to qsort\n\t * elem_selec[] and take the largest elements.  (They will no longer match\n\t * up with the elements of array_data[], but we don't care.)\n\t *----------\n\t */\n#define EFFORT 100\n\n\tif ((nmcelem + unique_nitems) > 0 &&\n\t\tunique_nitems > EFFORT * nmcelem / (nmcelem + unique_nitems))\n\t{\n\t\t/*\n\t\t * Use the quadratic formula to solve for largest allowable N.  We\n\t\t * have A = 1, B = nmcelem, C = - EFFORT * nmcelem.\n\t\t */\n\t\tdouble\t\tb = (double) nmcelem;\n\t\tint\t\t\tn;\n\n\t\tn = (int) ((sqrt(b * b + 4 * EFFORT * b) - b) / 2);\n\n\t\t/* Sort, then take just the first n elements */\n\t\tqsort(elem_selec, unique_nitems, sizeof(float),\n\t\t\t  float_compare_desc);\n\t\tunique_nitems = n;\n\t}\n\n\t/*\n\t * Calculate probabilities of each distinct element count for both mcelems\n\t * and constant elements.  At this point, assume independent element\n\t * occurrence.\n\t */\n\tdist = calc_distr(elem_selec, unique_nitems, unique_nitems, 0.0f);\n\tmcelem_dist = calc_distr(numbers, nmcelem, unique_nitems, rest);\n\n\t/* ignore hist[nhist-1], which is the average not a histogram member */\n\thist_part = calc_hist(hist, nhist - 1, unique_nitems);\n\n\tselec = 0.0f;\n\tfor (i = 0; i <= unique_nitems; i++)\n\t{\n\t\t/*\n\t\t * mult * dist[i] / mcelem_dist[i] gives us probability of qual\n\t\t * matching from assumption of independent element occurrence with the\n\t\t * condition that distinct element count = i.\n\t\t */\n\t\tif (mcelem_dist[i] > 0)\n\t\t\tselec += hist_part[i] * mult * dist[i] / mcelem_dist[i];\n\t}\n\n\tpfree(dist);\n\tpfree(mcelem_dist);\n\tpfree(hist_part);\n\tpfree(elem_selec);\n\n\t/* Take into account occurrence of NULL element. */\n\tselec *= (1.0f - nullelem_freq);\n\n\tCLAMP_PROBABILITY(selec);\n\n\treturn selec;\n}"
  },
  {
    "function_name": "mcelem_array_contain_overlap_selec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_selfuncs.c",
    "lines": "522-646",
    "snippet": "static Selectivity\nmcelem_array_contain_overlap_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t\t   Datum *array_data, int nitems,\n\t\t\t\t\t\t\t\t   Oid operator, FmgrInfo *cmpfunc)\n{\n\tSelectivity selec,\n\t\t\t\telem_selec;\n\tint\t\t\tmcelem_index,\n\t\t\t\ti;\n\tbool\t\tuse_bsearch;\n\tfloat4\t\tminfreq;\n\n\t/*\n\t * There should be three more Numbers than Values, because the last three\n\t * cells should hold minimal and maximal frequency among the non-null\n\t * elements, and then the frequency of null elements.  Ignore the Numbers\n\t * if not right.\n\t */\n\tif (nnumbers != nmcelem + 3)\n\t{\n\t\tnumbers = NULL;\n\t\tnnumbers = 0;\n\t}\n\n\tif (numbers)\n\t{\n\t\t/* Grab the lowest observed frequency */\n\t\tminfreq = numbers[nmcelem];\n\t}\n\telse\n\t{\n\t\t/* Without statistics make some default assumptions */\n\t\tminfreq = 2 * (float4) DEFAULT_CONTAIN_SEL;\n\t}\n\n\t/* Decide whether it is faster to use binary search or not. */\n\tif (nitems * floor_log2((uint32) nmcelem) < nmcelem + nitems)\n\t\tuse_bsearch = true;\n\telse\n\t\tuse_bsearch = false;\n\n\tif (operator == OID_ARRAY_CONTAINS_OP)\n\t{\n\t\t/*\n\t\t * Initial selectivity for \"column @> const\" query is 1.0, and it will\n\t\t * be decreased with each element of constant array.\n\t\t */\n\t\tselec = 1.0;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Initial selectivity for \"column && const\" query is 0.0, and it will\n\t\t * be increased with each element of constant array.\n\t\t */\n\t\tselec = 0.0;\n\t}\n\n\t/* Scan mcelem and array in parallel. */\n\tmcelem_index = 0;\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tbool\t\tmatch = false;\n\n\t\t/* Ignore any duplicates in the array data. */\n\t\tif (i > 0 &&\n\t\t\telement_compare(&array_data[i - 1], &array_data[i], cmpfunc) == 0)\n\t\t\tcontinue;\n\n\t\t/* Find the smallest MCELEM >= this array item. */\n\t\tif (use_bsearch)\n\t\t{\n\t\t\tmatch = find_next_mcelem(mcelem, nmcelem, array_data[i],\n\t\t\t\t\t\t\t\t\t &mcelem_index, cmpfunc);\n\t\t}\n\t\telse\n\t\t{\n\t\t\twhile (mcelem_index < nmcelem)\n\t\t\t{\n\t\t\t\tint\t\t\tcmp = element_compare(&mcelem[mcelem_index],\n\t\t\t\t\t\t\t\t\t\t\t\t  &array_data[i],\n\t\t\t\t\t\t\t\t\t\t\t\t  cmpfunc);\n\n\t\t\t\tif (cmp < 0)\n\t\t\t\t\tmcelem_index++;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (cmp == 0)\n\t\t\t\t\t\tmatch = true;\t/* mcelem is found */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (match && numbers)\n\t\t{\n\t\t\t/* MCELEM matches the array item; use its frequency. */\n\t\t\telem_selec = numbers[mcelem_index];\n\t\t\tmcelem_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * The element is not in MCELEM.  Punt, but assume that the\n\t\t\t * selectivity cannot be more than minfreq / 2.\n\t\t\t */\n\t\t\telem_selec = Min(DEFAULT_CONTAIN_SEL, minfreq / 2);\n\t\t}\n\n\t\t/*\n\t\t * Update overall selectivity using the current element's selectivity\n\t\t * and an assumption of element occurrence independence.\n\t\t */\n\t\tif (operator == OID_ARRAY_CONTAINS_OP)\n\t\t\tselec *= elem_selec;\n\t\telse\n\t\t\tselec = selec + elem_selec - selec * elem_selec;\n\n\t\t/* Clamp intermediate results to stay sane despite roundoff error */\n\t\tCLAMP_PROBABILITY(selec);\n\t}\n\n\treturn selec;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define DEFAULT_CONTAIN_SEL 0.005"
    ],
    "globals_used": [
      "static Selectivity calc_arraycontsel(VariableStatData *vardata, Datum constval,\n\t\t\t\t  Oid elemtype, Oid operator);",
      "static Selectivity mcelem_array_selec(ArrayType *array,\n\t\t\t\t   TypeCacheEntry *typentry,\n\t\t\t\t   Datum *mcelem, int nmcelem,\n\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t   float4 *hist, int nhist,\n\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);",
      "static Selectivity mcelem_array_contain_overlap_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t\t   Datum *array_data, int nitems,\n\t\t\t\t\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);",
      "static Selectivity mcelem_array_contained_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t Datum *array_data, int nitems,\n\t\t\t\t\t\t\t float4 *hist, int nhist,\n\t\t\t\t\t\t\t Oid operator, FmgrInfo *cmpfunc);",
      "static bool find_next_mcelem(Datum *mcelem, int nmcelem, Datum value,\n\t\t\t\t int *index, FmgrInfo *cmpfunc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CLAMP_PROBABILITY",
          "args": [
            "selec"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "DEFAULT_CONTAIN_SEL",
            "minfreq / 2"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "element_compare",
          "args": [
            "&mcelem[mcelem_index]",
            "&array_data[i]",
            "cmpfunc"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "element_compare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_selfuncs.c",
          "lines": "1166-1176",
          "snippet": "static int\nelement_compare(const void *key1, const void *key2, void *arg)\n{\n\tDatum\t\td1 = *((const Datum *) key1);\n\tDatum\t\td2 = *((const Datum *) key2);\n\tFmgrInfo   *cmpfunc = (FmgrInfo *) arg;\n\tDatum\t\tc;\n\n\tc = FunctionCall2Coll(cmpfunc, DEFAULT_COLLATION_OID, d1, d2);\n\treturn DatumGetInt32(c);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Selectivity mcelem_array_selec(ArrayType *array,\n\t\t\t\t   TypeCacheEntry *typentry,\n\t\t\t\t   Datum *mcelem, int nmcelem,\n\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t   float4 *hist, int nhist,\n\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);",
            "static Selectivity mcelem_array_contain_overlap_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t\t   Datum *array_data, int nitems,\n\t\t\t\t\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);",
            "static Selectivity mcelem_array_contained_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t Datum *array_data, int nitems,\n\t\t\t\t\t\t\t float4 *hist, int nhist,\n\t\t\t\t\t\t\t Oid operator, FmgrInfo *cmpfunc);",
            "static bool find_next_mcelem(Datum *mcelem, int nmcelem, Datum value,\n\t\t\t\t int *index, FmgrInfo *cmpfunc);",
            "static int\telement_compare(const void *key1, const void *key2, void *arg);",
            "static int\tfloat_compare_desc(const void *key1, const void *key2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/clauses.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Selectivity mcelem_array_selec(ArrayType *array,\n\t\t\t\t   TypeCacheEntry *typentry,\n\t\t\t\t   Datum *mcelem, int nmcelem,\n\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t   float4 *hist, int nhist,\n\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);\nstatic Selectivity mcelem_array_contain_overlap_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t\t   Datum *array_data, int nitems,\n\t\t\t\t\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);\nstatic Selectivity mcelem_array_contained_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t Datum *array_data, int nitems,\n\t\t\t\t\t\t\t float4 *hist, int nhist,\n\t\t\t\t\t\t\t Oid operator, FmgrInfo *cmpfunc);\nstatic bool find_next_mcelem(Datum *mcelem, int nmcelem, Datum value,\n\t\t\t\t int *index, FmgrInfo *cmpfunc);\nstatic int\telement_compare(const void *key1, const void *key2, void *arg);\nstatic int\tfloat_compare_desc(const void *key1, const void *key2);\n\nstatic int\nelement_compare(const void *key1, const void *key2, void *arg)\n{\n\tDatum\t\td1 = *((const Datum *) key1);\n\tDatum\t\td2 = *((const Datum *) key2);\n\tFmgrInfo   *cmpfunc = (FmgrInfo *) arg;\n\tDatum\t\tc;\n\n\tc = FunctionCall2Coll(cmpfunc, DEFAULT_COLLATION_OID, d1, d2);\n\treturn DatumGetInt32(c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_next_mcelem",
          "args": [
            "mcelem",
            "nmcelem",
            "array_data[i]",
            "&mcelem_index",
            "cmpfunc"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "find_next_mcelem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_selfuncs.c",
          "lines": "1131-1156",
          "snippet": "static bool\nfind_next_mcelem(Datum *mcelem, int nmcelem, Datum value, int *index,\n\t\t\t\t FmgrInfo *cmpfunc)\n{\n\tint\t\t\tl = *index,\n\t\t\t\tr = nmcelem - 1,\n\t\t\t\ti,\n\t\t\t\tres;\n\n\twhile (l <= r)\n\t{\n\t\ti = (l + r) / 2;\n\t\tres = element_compare(&mcelem[i], &value, cmpfunc);\n\t\tif (res == 0)\n\t\t{\n\t\t\t*index = i;\n\t\t\treturn true;\n\t\t}\n\t\telse if (res < 0)\n\t\t\tl = i + 1;\n\t\telse\n\t\t\tr = i - 1;\n\t}\n\t*index = l;\n\treturn false;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Selectivity mcelem_array_selec(ArrayType *array,\n\t\t\t\t   TypeCacheEntry *typentry,\n\t\t\t\t   Datum *mcelem, int nmcelem,\n\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t   float4 *hist, int nhist,\n\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);",
            "static Selectivity mcelem_array_contain_overlap_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t\t   Datum *array_data, int nitems,\n\t\t\t\t\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);",
            "static Selectivity mcelem_array_contained_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t Datum *array_data, int nitems,\n\t\t\t\t\t\t\t float4 *hist, int nhist,\n\t\t\t\t\t\t\t Oid operator, FmgrInfo *cmpfunc);",
            "static bool find_next_mcelem(Datum *mcelem, int nmcelem, Datum value,\n\t\t\t\t int *index, FmgrInfo *cmpfunc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/clauses.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Selectivity mcelem_array_selec(ArrayType *array,\n\t\t\t\t   TypeCacheEntry *typentry,\n\t\t\t\t   Datum *mcelem, int nmcelem,\n\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t   float4 *hist, int nhist,\n\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);\nstatic Selectivity mcelem_array_contain_overlap_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t\t   Datum *array_data, int nitems,\n\t\t\t\t\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);\nstatic Selectivity mcelem_array_contained_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t Datum *array_data, int nitems,\n\t\t\t\t\t\t\t float4 *hist, int nhist,\n\t\t\t\t\t\t\t Oid operator, FmgrInfo *cmpfunc);\nstatic bool find_next_mcelem(Datum *mcelem, int nmcelem, Datum value,\n\t\t\t\t int *index, FmgrInfo *cmpfunc);\n\nstatic bool\nfind_next_mcelem(Datum *mcelem, int nmcelem, Datum value, int *index,\n\t\t\t\t FmgrInfo *cmpfunc)\n{\n\tint\t\t\tl = *index,\n\t\t\t\tr = nmcelem - 1,\n\t\t\t\ti,\n\t\t\t\tres;\n\n\twhile (l <= r)\n\t{\n\t\ti = (l + r) / 2;\n\t\tres = element_compare(&mcelem[i], &value, cmpfunc);\n\t\tif (res == 0)\n\t\t{\n\t\t\t*index = i;\n\t\t\treturn true;\n\t\t}\n\t\telse if (res < 0)\n\t\t\tl = i + 1;\n\t\telse\n\t\t\tr = i - 1;\n\t}\n\t*index = l;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "floor_log2",
          "args": [
            "(uint32) nmcelem"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "floor_log2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_selfuncs.c",
          "lines": "1090-1122",
          "snippet": "static int\nfloor_log2(uint32 n)\n{\n\tint\t\t\tlogval = 0;\n\n\tif (n == 0)\n\t\treturn -1;\n\tif (n >= (1 << 16))\n\t{\n\t\tn >>= 16;\n\t\tlogval += 16;\n\t}\n\tif (n >= (1 << 8))\n\t{\n\t\tn >>= 8;\n\t\tlogval += 8;\n\t}\n\tif (n >= (1 << 4))\n\t{\n\t\tn >>= 4;\n\t\tlogval += 4;\n\t}\n\tif (n >= (1 << 2))\n\t{\n\t\tn >>= 2;\n\t\tlogval += 2;\n\t}\n\tif (n >= (1 << 1))\n\t{\n\t\tlogval += 1;\n\t}\n\treturn logval;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static float *calc_hist(const float4 *hist, int nhist, int n);",
            "static int\tfloor_log2(uint32 n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/clauses.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nstatic float *calc_hist(const float4 *hist, int nhist, int n);\nstatic int\tfloor_log2(uint32 n);\n\nstatic int\nfloor_log2(uint32 n)\n{\n\tint\t\t\tlogval = 0;\n\n\tif (n == 0)\n\t\treturn -1;\n\tif (n >= (1 << 16))\n\t{\n\t\tn >>= 16;\n\t\tlogval += 16;\n\t}\n\tif (n >= (1 << 8))\n\t{\n\t\tn >>= 8;\n\t\tlogval += 8;\n\t}\n\tif (n >= (1 << 4))\n\t{\n\t\tn >>= 4;\n\t\tlogval += 4;\n\t}\n\tif (n >= (1 << 2))\n\t{\n\t\tn >>= 2;\n\t\tlogval += 2;\n\t}\n\tif (n >= (1 << 1))\n\t{\n\t\tlogval += 1;\n\t}\n\treturn logval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/clauses.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\n#define DEFAULT_CONTAIN_SEL 0.005\n\nstatic Selectivity calc_arraycontsel(VariableStatData *vardata, Datum constval,\n\t\t\t\t  Oid elemtype, Oid operator);\nstatic Selectivity mcelem_array_selec(ArrayType *array,\n\t\t\t\t   TypeCacheEntry *typentry,\n\t\t\t\t   Datum *mcelem, int nmcelem,\n\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t   float4 *hist, int nhist,\n\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);\nstatic Selectivity mcelem_array_contain_overlap_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t\t   Datum *array_data, int nitems,\n\t\t\t\t\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);\nstatic Selectivity mcelem_array_contained_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t Datum *array_data, int nitems,\n\t\t\t\t\t\t\t float4 *hist, int nhist,\n\t\t\t\t\t\t\t Oid operator, FmgrInfo *cmpfunc);\nstatic bool find_next_mcelem(Datum *mcelem, int nmcelem, Datum value,\n\t\t\t\t int *index, FmgrInfo *cmpfunc);\n\nstatic Selectivity\nmcelem_array_contain_overlap_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t\t   Datum *array_data, int nitems,\n\t\t\t\t\t\t\t\t   Oid operator, FmgrInfo *cmpfunc)\n{\n\tSelectivity selec,\n\t\t\t\telem_selec;\n\tint\t\t\tmcelem_index,\n\t\t\t\ti;\n\tbool\t\tuse_bsearch;\n\tfloat4\t\tminfreq;\n\n\t/*\n\t * There should be three more Numbers than Values, because the last three\n\t * cells should hold minimal and maximal frequency among the non-null\n\t * elements, and then the frequency of null elements.  Ignore the Numbers\n\t * if not right.\n\t */\n\tif (nnumbers != nmcelem + 3)\n\t{\n\t\tnumbers = NULL;\n\t\tnnumbers = 0;\n\t}\n\n\tif (numbers)\n\t{\n\t\t/* Grab the lowest observed frequency */\n\t\tminfreq = numbers[nmcelem];\n\t}\n\telse\n\t{\n\t\t/* Without statistics make some default assumptions */\n\t\tminfreq = 2 * (float4) DEFAULT_CONTAIN_SEL;\n\t}\n\n\t/* Decide whether it is faster to use binary search or not. */\n\tif (nitems * floor_log2((uint32) nmcelem) < nmcelem + nitems)\n\t\tuse_bsearch = true;\n\telse\n\t\tuse_bsearch = false;\n\n\tif (operator == OID_ARRAY_CONTAINS_OP)\n\t{\n\t\t/*\n\t\t * Initial selectivity for \"column @> const\" query is 1.0, and it will\n\t\t * be decreased with each element of constant array.\n\t\t */\n\t\tselec = 1.0;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Initial selectivity for \"column && const\" query is 0.0, and it will\n\t\t * be increased with each element of constant array.\n\t\t */\n\t\tselec = 0.0;\n\t}\n\n\t/* Scan mcelem and array in parallel. */\n\tmcelem_index = 0;\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tbool\t\tmatch = false;\n\n\t\t/* Ignore any duplicates in the array data. */\n\t\tif (i > 0 &&\n\t\t\telement_compare(&array_data[i - 1], &array_data[i], cmpfunc) == 0)\n\t\t\tcontinue;\n\n\t\t/* Find the smallest MCELEM >= this array item. */\n\t\tif (use_bsearch)\n\t\t{\n\t\t\tmatch = find_next_mcelem(mcelem, nmcelem, array_data[i],\n\t\t\t\t\t\t\t\t\t &mcelem_index, cmpfunc);\n\t\t}\n\t\telse\n\t\t{\n\t\t\twhile (mcelem_index < nmcelem)\n\t\t\t{\n\t\t\t\tint\t\t\tcmp = element_compare(&mcelem[mcelem_index],\n\t\t\t\t\t\t\t\t\t\t\t\t  &array_data[i],\n\t\t\t\t\t\t\t\t\t\t\t\t  cmpfunc);\n\n\t\t\t\tif (cmp < 0)\n\t\t\t\t\tmcelem_index++;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (cmp == 0)\n\t\t\t\t\t\tmatch = true;\t/* mcelem is found */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (match && numbers)\n\t\t{\n\t\t\t/* MCELEM matches the array item; use its frequency. */\n\t\t\telem_selec = numbers[mcelem_index];\n\t\t\tmcelem_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * The element is not in MCELEM.  Punt, but assume that the\n\t\t\t * selectivity cannot be more than minfreq / 2.\n\t\t\t */\n\t\t\telem_selec = Min(DEFAULT_CONTAIN_SEL, minfreq / 2);\n\t\t}\n\n\t\t/*\n\t\t * Update overall selectivity using the current element's selectivity\n\t\t * and an assumption of element occurrence independence.\n\t\t */\n\t\tif (operator == OID_ARRAY_CONTAINS_OP)\n\t\t\tselec *= elem_selec;\n\t\telse\n\t\t\tselec = selec + elem_selec - selec * elem_selec;\n\n\t\t/* Clamp intermediate results to stay sane despite roundoff error */\n\t\tCLAMP_PROBABILITY(selec);\n\t}\n\n\treturn selec;\n}"
  },
  {
    "function_name": "mcelem_array_selec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_selfuncs.c",
    "lines": "429-503",
    "snippet": "static Selectivity\nmcelem_array_selec(ArrayType *array, TypeCacheEntry *typentry,\n\t\t\t\t   Datum *mcelem, int nmcelem,\n\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t   float4 *hist, int nhist,\n\t\t\t\t   Oid operator, FmgrInfo *cmpfunc)\n{\n\tSelectivity selec;\n\tint\t\t\tnum_elems;\n\tDatum\t   *elem_values;\n\tbool\t   *elem_nulls;\n\tbool\t\tnull_present;\n\tint\t\t\tnonnull_nitems;\n\tint\t\t\ti;\n\n\t/*\n\t * Prepare constant array data for sorting.  Sorting lets us find unique\n\t * elements and efficiently merge with the MCELEM array.\n\t */\n\tdeconstruct_array(array,\n\t\t\t\t\t  typentry->type_id,\n\t\t\t\t\t  typentry->typlen,\n\t\t\t\t\t  typentry->typbyval,\n\t\t\t\t\t  typentry->typalign,\n\t\t\t\t\t  &elem_values, &elem_nulls, &num_elems);\n\n\t/* Collapse out any null elements */\n\tnonnull_nitems = 0;\n\tnull_present = false;\n\tfor (i = 0; i < num_elems; i++)\n\t{\n\t\tif (elem_nulls[i])\n\t\t\tnull_present = true;\n\t\telse\n\t\t\telem_values[nonnull_nitems++] = elem_values[i];\n\t}\n\n\t/*\n\t * Query \"column @> '{anything, null}'\" matches nothing.  For the other\n\t * two operators, presence of a null in the constant can be ignored.\n\t */\n\tif (null_present && operator == OID_ARRAY_CONTAINS_OP)\n\t{\n\t\tpfree(elem_values);\n\t\tpfree(elem_nulls);\n\t\treturn (Selectivity) 0.0;\n\t}\n\n\t/* Sort extracted elements using their default comparison function. */\n\tqsort_arg(elem_values, nonnull_nitems, sizeof(Datum),\n\t\t\t  element_compare, cmpfunc);\n\n\t/* Separate cases according to operator */\n\tif (operator == OID_ARRAY_CONTAINS_OP || operator == OID_ARRAY_OVERLAP_OP)\n\t\tselec = mcelem_array_contain_overlap_selec(mcelem, nmcelem,\n\t\t\t\t\t\t\t\t\t\t\t\t   numbers, nnumbers,\n\t\t\t\t\t\t\t\t\t\t\t\t   elem_values, nonnull_nitems,\n\t\t\t\t\t\t\t\t\t\t\t\t   operator, cmpfunc);\n\telse if (operator == OID_ARRAY_CONTAINED_OP)\n\t\tselec = mcelem_array_contained_selec(mcelem, nmcelem,\n\t\t\t\t\t\t\t\t\t\t\t numbers, nnumbers,\n\t\t\t\t\t\t\t\t\t\t\t elem_values, nonnull_nitems,\n\t\t\t\t\t\t\t\t\t\t\t hist, nhist,\n\t\t\t\t\t\t\t\t\t\t\t operator, cmpfunc);\n\telse\n\t{\n\t\telog(ERROR, \"arraycontsel called for unrecognized operator %u\",\n\t\t\t operator);\n\t\tselec = 0.0;\t\t\t/* keep compiler quiet */\n\t}\n\n\tpfree(elem_values);\n\tpfree(elem_nulls);\n\treturn selec;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Selectivity calc_arraycontsel(VariableStatData *vardata, Datum constval,\n\t\t\t\t  Oid elemtype, Oid operator);",
      "static Selectivity mcelem_array_selec(ArrayType *array,\n\t\t\t\t   TypeCacheEntry *typentry,\n\t\t\t\t   Datum *mcelem, int nmcelem,\n\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t   float4 *hist, int nhist,\n\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);",
      "static Selectivity mcelem_array_contain_overlap_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t\t   Datum *array_data, int nitems,\n\t\t\t\t\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);",
      "static Selectivity mcelem_array_contained_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t Datum *array_data, int nitems,\n\t\t\t\t\t\t\t float4 *hist, int nhist,\n\t\t\t\t\t\t\t Oid operator, FmgrInfo *cmpfunc);",
      "static bool find_next_mcelem(Datum *mcelem, int nmcelem, Datum value,\n\t\t\t\t int *index, FmgrInfo *cmpfunc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "elem_nulls"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"arraycontsel called for unrecognized operator %u\"",
            "operator"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mcelem_array_contained_selec",
          "args": [
            "mcelem",
            "nmcelem",
            "numbers",
            "nnumbers",
            "elem_values",
            "nonnull_nitems",
            "hist",
            "nhist",
            "operator",
            "cmpfunc"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "mcelem_array_contained_selec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_selfuncs.c",
          "lines": "697-909",
          "snippet": "static Selectivity\nmcelem_array_contained_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t Datum *array_data, int nitems,\n\t\t\t\t\t\t\t float4 *hist, int nhist,\n\t\t\t\t\t\t\t Oid operator, FmgrInfo *cmpfunc)\n{\n\tint\t\t\tmcelem_index,\n\t\t\t\ti,\n\t\t\t\tunique_nitems = 0;\n\tfloat\t\tselec,\n\t\t\t\tminfreq,\n\t\t\t\tnullelem_freq;\n\tfloat\t   *dist,\n\t\t\t   *mcelem_dist,\n\t\t\t   *hist_part;\n\tfloat\t\tavg_count,\n\t\t\t\tmult,\n\t\t\t\trest;\n\tfloat\t   *elem_selec;\n\n\t/*\n\t * There should be three more Numbers than Values in the MCELEM slot,\n\t * because the last three cells should hold minimal and maximal frequency\n\t * among the non-null elements, and then the frequency of null elements.\n\t * Punt if not right, because we can't do much without the element freqs.\n\t */\n\tif (numbers == NULL || nnumbers != nmcelem + 3)\n\t\treturn DEFAULT_CONTAIN_SEL;\n\n\t/* Can't do much without a count histogram, either */\n\tif (hist == NULL || nhist < 3)\n\t\treturn DEFAULT_CONTAIN_SEL;\n\n\t/*\n\t * Grab some of the summary statistics that compute_array_stats() stores:\n\t * lowest frequency, frequency of null elements, and average distinct\n\t * element count.\n\t */\n\tminfreq = numbers[nmcelem];\n\tnullelem_freq = numbers[nmcelem + 2];\n\tavg_count = hist[nhist - 1];\n\n\t/*\n\t * \"rest\" will be the sum of the frequencies of all elements not\n\t * represented in MCELEM.  The average distinct element count is the sum\n\t * of the frequencies of *all* elements.  Begin with that; we will proceed\n\t * to subtract the MCELEM frequencies.\n\t */\n\trest = avg_count;\n\n\t/*\n\t * mult is a multiplier representing estimate of probability that each\n\t * mcelem that is not present in constant doesn't occur.\n\t */\n\tmult = 1.0f;\n\n\t/*\n\t * elem_selec is array of estimated frequencies for elements in the\n\t * constant.\n\t */\n\telem_selec = (float *) palloc(sizeof(float) * nitems);\n\n\t/* Scan mcelem and array in parallel. */\n\tmcelem_index = 0;\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tbool\t\tmatch = false;\n\n\t\t/* Ignore any duplicates in the array data. */\n\t\tif (i > 0 &&\n\t\t\telement_compare(&array_data[i - 1], &array_data[i], cmpfunc) == 0)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Iterate over MCELEM until we find an entry greater than or equal to\n\t\t * this element of the constant.  Update \"rest\" and \"mult\" for mcelem\n\t\t * entries skipped over.\n\t\t */\n\t\twhile (mcelem_index < nmcelem)\n\t\t{\n\t\t\tint\t\t\tcmp = element_compare(&mcelem[mcelem_index],\n\t\t\t\t\t\t\t\t\t\t\t  &array_data[i],\n\t\t\t\t\t\t\t\t\t\t\t  cmpfunc);\n\n\t\t\tif (cmp < 0)\n\t\t\t{\n\t\t\t\tmult *= (1.0f - numbers[mcelem_index]);\n\t\t\t\trest -= numbers[mcelem_index];\n\t\t\t\tmcelem_index++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (cmp == 0)\n\t\t\t\t\tmatch = true;\t/* mcelem is found */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (match)\n\t\t{\n\t\t\t/* MCELEM matches the array item. */\n\t\t\telem_selec[unique_nitems] = numbers[mcelem_index];\n\t\t\t/* \"rest\" is decremented for all mcelems, matched or not */\n\t\t\trest -= numbers[mcelem_index];\n\t\t\tmcelem_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * The element is not in MCELEM.  Punt, but assume that the\n\t\t\t * selectivity cannot be more than minfreq / 2.\n\t\t\t */\n\t\t\telem_selec[unique_nitems] = Min(DEFAULT_CONTAIN_SEL,\n\t\t\t\t\t\t\t\t\t\t\tminfreq / 2);\n\t\t}\n\n\t\tunique_nitems++;\n\t}\n\n\t/*\n\t * If we handled all constant elements without exhausting the MCELEM\n\t * array, finish walking it to complete calculation of \"rest\" and \"mult\".\n\t */\n\twhile (mcelem_index < nmcelem)\n\t{\n\t\tmult *= (1.0f - numbers[mcelem_index]);\n\t\trest -= numbers[mcelem_index];\n\t\tmcelem_index++;\n\t}\n\n\t/*\n\t * The presence of many distinct rare elements materially decreases\n\t * selectivity.  Use the Poisson distribution to estimate the probability\n\t * of a column value having zero occurrences of such elements.  See above\n\t * for the definition of \"rest\".\n\t */\n\tmult *= exp(-rest);\n\n\t/*----------\n\t * Using the distinct element count histogram requires\n\t *\t\tO(unique_nitems * (nmcelem + unique_nitems))\n\t * operations.  Beyond a certain computational cost threshold, it's\n\t * reasonable to sacrifice accuracy for decreased planning time.  We limit\n\t * the number of operations to EFFORT * nmcelem; since nmcelem is limited\n\t * by the column's statistics target, the work done is user-controllable.\n\t *\n\t * If the number of operations would be too large, we can reduce it\n\t * without losing all accuracy by reducing unique_nitems and considering\n\t * only the most-common elements of the constant array.  To make the\n\t * results exactly match what we would have gotten with only those\n\t * elements to start with, we'd have to remove any discarded elements'\n\t * frequencies from \"mult\", but since this is only an approximation\n\t * anyway, we don't bother with that.  Therefore it's sufficient to qsort\n\t * elem_selec[] and take the largest elements.  (They will no longer match\n\t * up with the elements of array_data[], but we don't care.)\n\t *----------\n\t */\n#define EFFORT 100\n\n\tif ((nmcelem + unique_nitems) > 0 &&\n\t\tunique_nitems > EFFORT * nmcelem / (nmcelem + unique_nitems))\n\t{\n\t\t/*\n\t\t * Use the quadratic formula to solve for largest allowable N.  We\n\t\t * have A = 1, B = nmcelem, C = - EFFORT * nmcelem.\n\t\t */\n\t\tdouble\t\tb = (double) nmcelem;\n\t\tint\t\t\tn;\n\n\t\tn = (int) ((sqrt(b * b + 4 * EFFORT * b) - b) / 2);\n\n\t\t/* Sort, then take just the first n elements */\n\t\tqsort(elem_selec, unique_nitems, sizeof(float),\n\t\t\t  float_compare_desc);\n\t\tunique_nitems = n;\n\t}\n\n\t/*\n\t * Calculate probabilities of each distinct element count for both mcelems\n\t * and constant elements.  At this point, assume independent element\n\t * occurrence.\n\t */\n\tdist = calc_distr(elem_selec, unique_nitems, unique_nitems, 0.0f);\n\tmcelem_dist = calc_distr(numbers, nmcelem, unique_nitems, rest);\n\n\t/* ignore hist[nhist-1], which is the average not a histogram member */\n\thist_part = calc_hist(hist, nhist - 1, unique_nitems);\n\n\tselec = 0.0f;\n\tfor (i = 0; i <= unique_nitems; i++)\n\t{\n\t\t/*\n\t\t * mult * dist[i] / mcelem_dist[i] gives us probability of qual\n\t\t * matching from assumption of independent element occurrence with the\n\t\t * condition that distinct element count = i.\n\t\t */\n\t\tif (mcelem_dist[i] > 0)\n\t\t\tselec += hist_part[i] * mult * dist[i] / mcelem_dist[i];\n\t}\n\n\tpfree(dist);\n\tpfree(mcelem_dist);\n\tpfree(hist_part);\n\tpfree(elem_selec);\n\n\t/* Take into account occurrence of NULL element. */\n\tselec *= (1.0f - nullelem_freq);\n\n\tCLAMP_PROBABILITY(selec);\n\n\treturn selec;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define EFFORT 100",
            "#define DEFAULT_CONTAIN_SEL 0.005"
          ],
          "globals_used": [
            "static Selectivity calc_arraycontsel(VariableStatData *vardata, Datum constval,\n\t\t\t\t  Oid elemtype, Oid operator);",
            "static Selectivity mcelem_array_selec(ArrayType *array,\n\t\t\t\t   TypeCacheEntry *typentry,\n\t\t\t\t   Datum *mcelem, int nmcelem,\n\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t   float4 *hist, int nhist,\n\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);",
            "static Selectivity mcelem_array_contain_overlap_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t\t   Datum *array_data, int nitems,\n\t\t\t\t\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);",
            "static Selectivity mcelem_array_contained_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t Datum *array_data, int nitems,\n\t\t\t\t\t\t\t float4 *hist, int nhist,\n\t\t\t\t\t\t\t Oid operator, FmgrInfo *cmpfunc);",
            "static float *calc_hist(const float4 *hist, int nhist, int n);",
            "static float *calc_distr(const float *p, int n, int m, float rest);",
            "static int\tfloor_log2(uint32 n);",
            "static bool find_next_mcelem(Datum *mcelem, int nmcelem, Datum value,\n\t\t\t\t int *index, FmgrInfo *cmpfunc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/clauses.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\n#define EFFORT 100\n#define DEFAULT_CONTAIN_SEL 0.005\n\nstatic Selectivity calc_arraycontsel(VariableStatData *vardata, Datum constval,\n\t\t\t\t  Oid elemtype, Oid operator);\nstatic Selectivity mcelem_array_selec(ArrayType *array,\n\t\t\t\t   TypeCacheEntry *typentry,\n\t\t\t\t   Datum *mcelem, int nmcelem,\n\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t   float4 *hist, int nhist,\n\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);\nstatic Selectivity mcelem_array_contain_overlap_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t\t   Datum *array_data, int nitems,\n\t\t\t\t\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);\nstatic Selectivity mcelem_array_contained_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t Datum *array_data, int nitems,\n\t\t\t\t\t\t\t float4 *hist, int nhist,\n\t\t\t\t\t\t\t Oid operator, FmgrInfo *cmpfunc);\nstatic float *calc_hist(const float4 *hist, int nhist, int n);\nstatic float *calc_distr(const float *p, int n, int m, float rest);\nstatic int\tfloor_log2(uint32 n);\nstatic bool find_next_mcelem(Datum *mcelem, int nmcelem, Datum value,\n\t\t\t\t int *index, FmgrInfo *cmpfunc);\n\nstatic Selectivity\nmcelem_array_contained_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t Datum *array_data, int nitems,\n\t\t\t\t\t\t\t float4 *hist, int nhist,\n\t\t\t\t\t\t\t Oid operator, FmgrInfo *cmpfunc)\n{\n\tint\t\t\tmcelem_index,\n\t\t\t\ti,\n\t\t\t\tunique_nitems = 0;\n\tfloat\t\tselec,\n\t\t\t\tminfreq,\n\t\t\t\tnullelem_freq;\n\tfloat\t   *dist,\n\t\t\t   *mcelem_dist,\n\t\t\t   *hist_part;\n\tfloat\t\tavg_count,\n\t\t\t\tmult,\n\t\t\t\trest;\n\tfloat\t   *elem_selec;\n\n\t/*\n\t * There should be three more Numbers than Values in the MCELEM slot,\n\t * because the last three cells should hold minimal and maximal frequency\n\t * among the non-null elements, and then the frequency of null elements.\n\t * Punt if not right, because we can't do much without the element freqs.\n\t */\n\tif (numbers == NULL || nnumbers != nmcelem + 3)\n\t\treturn DEFAULT_CONTAIN_SEL;\n\n\t/* Can't do much without a count histogram, either */\n\tif (hist == NULL || nhist < 3)\n\t\treturn DEFAULT_CONTAIN_SEL;\n\n\t/*\n\t * Grab some of the summary statistics that compute_array_stats() stores:\n\t * lowest frequency, frequency of null elements, and average distinct\n\t * element count.\n\t */\n\tminfreq = numbers[nmcelem];\n\tnullelem_freq = numbers[nmcelem + 2];\n\tavg_count = hist[nhist - 1];\n\n\t/*\n\t * \"rest\" will be the sum of the frequencies of all elements not\n\t * represented in MCELEM.  The average distinct element count is the sum\n\t * of the frequencies of *all* elements.  Begin with that; we will proceed\n\t * to subtract the MCELEM frequencies.\n\t */\n\trest = avg_count;\n\n\t/*\n\t * mult is a multiplier representing estimate of probability that each\n\t * mcelem that is not present in constant doesn't occur.\n\t */\n\tmult = 1.0f;\n\n\t/*\n\t * elem_selec is array of estimated frequencies for elements in the\n\t * constant.\n\t */\n\telem_selec = (float *) palloc(sizeof(float) * nitems);\n\n\t/* Scan mcelem and array in parallel. */\n\tmcelem_index = 0;\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tbool\t\tmatch = false;\n\n\t\t/* Ignore any duplicates in the array data. */\n\t\tif (i > 0 &&\n\t\t\telement_compare(&array_data[i - 1], &array_data[i], cmpfunc) == 0)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Iterate over MCELEM until we find an entry greater than or equal to\n\t\t * this element of the constant.  Update \"rest\" and \"mult\" for mcelem\n\t\t * entries skipped over.\n\t\t */\n\t\twhile (mcelem_index < nmcelem)\n\t\t{\n\t\t\tint\t\t\tcmp = element_compare(&mcelem[mcelem_index],\n\t\t\t\t\t\t\t\t\t\t\t  &array_data[i],\n\t\t\t\t\t\t\t\t\t\t\t  cmpfunc);\n\n\t\t\tif (cmp < 0)\n\t\t\t{\n\t\t\t\tmult *= (1.0f - numbers[mcelem_index]);\n\t\t\t\trest -= numbers[mcelem_index];\n\t\t\t\tmcelem_index++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (cmp == 0)\n\t\t\t\t\tmatch = true;\t/* mcelem is found */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (match)\n\t\t{\n\t\t\t/* MCELEM matches the array item. */\n\t\t\telem_selec[unique_nitems] = numbers[mcelem_index];\n\t\t\t/* \"rest\" is decremented for all mcelems, matched or not */\n\t\t\trest -= numbers[mcelem_index];\n\t\t\tmcelem_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * The element is not in MCELEM.  Punt, but assume that the\n\t\t\t * selectivity cannot be more than minfreq / 2.\n\t\t\t */\n\t\t\telem_selec[unique_nitems] = Min(DEFAULT_CONTAIN_SEL,\n\t\t\t\t\t\t\t\t\t\t\tminfreq / 2);\n\t\t}\n\n\t\tunique_nitems++;\n\t}\n\n\t/*\n\t * If we handled all constant elements without exhausting the MCELEM\n\t * array, finish walking it to complete calculation of \"rest\" and \"mult\".\n\t */\n\twhile (mcelem_index < nmcelem)\n\t{\n\t\tmult *= (1.0f - numbers[mcelem_index]);\n\t\trest -= numbers[mcelem_index];\n\t\tmcelem_index++;\n\t}\n\n\t/*\n\t * The presence of many distinct rare elements materially decreases\n\t * selectivity.  Use the Poisson distribution to estimate the probability\n\t * of a column value having zero occurrences of such elements.  See above\n\t * for the definition of \"rest\".\n\t */\n\tmult *= exp(-rest);\n\n\t/*----------\n\t * Using the distinct element count histogram requires\n\t *\t\tO(unique_nitems * (nmcelem + unique_nitems))\n\t * operations.  Beyond a certain computational cost threshold, it's\n\t * reasonable to sacrifice accuracy for decreased planning time.  We limit\n\t * the number of operations to EFFORT * nmcelem; since nmcelem is limited\n\t * by the column's statistics target, the work done is user-controllable.\n\t *\n\t * If the number of operations would be too large, we can reduce it\n\t * without losing all accuracy by reducing unique_nitems and considering\n\t * only the most-common elements of the constant array.  To make the\n\t * results exactly match what we would have gotten with only those\n\t * elements to start with, we'd have to remove any discarded elements'\n\t * frequencies from \"mult\", but since this is only an approximation\n\t * anyway, we don't bother with that.  Therefore it's sufficient to qsort\n\t * elem_selec[] and take the largest elements.  (They will no longer match\n\t * up with the elements of array_data[], but we don't care.)\n\t *----------\n\t */\n#define EFFORT 100\n\n\tif ((nmcelem + unique_nitems) > 0 &&\n\t\tunique_nitems > EFFORT * nmcelem / (nmcelem + unique_nitems))\n\t{\n\t\t/*\n\t\t * Use the quadratic formula to solve for largest allowable N.  We\n\t\t * have A = 1, B = nmcelem, C = - EFFORT * nmcelem.\n\t\t */\n\t\tdouble\t\tb = (double) nmcelem;\n\t\tint\t\t\tn;\n\n\t\tn = (int) ((sqrt(b * b + 4 * EFFORT * b) - b) / 2);\n\n\t\t/* Sort, then take just the first n elements */\n\t\tqsort(elem_selec, unique_nitems, sizeof(float),\n\t\t\t  float_compare_desc);\n\t\tunique_nitems = n;\n\t}\n\n\t/*\n\t * Calculate probabilities of each distinct element count for both mcelems\n\t * and constant elements.  At this point, assume independent element\n\t * occurrence.\n\t */\n\tdist = calc_distr(elem_selec, unique_nitems, unique_nitems, 0.0f);\n\tmcelem_dist = calc_distr(numbers, nmcelem, unique_nitems, rest);\n\n\t/* ignore hist[nhist-1], which is the average not a histogram member */\n\thist_part = calc_hist(hist, nhist - 1, unique_nitems);\n\n\tselec = 0.0f;\n\tfor (i = 0; i <= unique_nitems; i++)\n\t{\n\t\t/*\n\t\t * mult * dist[i] / mcelem_dist[i] gives us probability of qual\n\t\t * matching from assumption of independent element occurrence with the\n\t\t * condition that distinct element count = i.\n\t\t */\n\t\tif (mcelem_dist[i] > 0)\n\t\t\tselec += hist_part[i] * mult * dist[i] / mcelem_dist[i];\n\t}\n\n\tpfree(dist);\n\tpfree(mcelem_dist);\n\tpfree(hist_part);\n\tpfree(elem_selec);\n\n\t/* Take into account occurrence of NULL element. */\n\tselec *= (1.0f - nullelem_freq);\n\n\tCLAMP_PROBABILITY(selec);\n\n\treturn selec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mcelem_array_contain_overlap_selec",
          "args": [
            "mcelem",
            "nmcelem",
            "numbers",
            "nnumbers",
            "elem_values",
            "nonnull_nitems",
            "operator",
            "cmpfunc"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "mcelem_array_contain_overlap_selec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_selfuncs.c",
          "lines": "522-646",
          "snippet": "static Selectivity\nmcelem_array_contain_overlap_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t\t   Datum *array_data, int nitems,\n\t\t\t\t\t\t\t\t   Oid operator, FmgrInfo *cmpfunc)\n{\n\tSelectivity selec,\n\t\t\t\telem_selec;\n\tint\t\t\tmcelem_index,\n\t\t\t\ti;\n\tbool\t\tuse_bsearch;\n\tfloat4\t\tminfreq;\n\n\t/*\n\t * There should be three more Numbers than Values, because the last three\n\t * cells should hold minimal and maximal frequency among the non-null\n\t * elements, and then the frequency of null elements.  Ignore the Numbers\n\t * if not right.\n\t */\n\tif (nnumbers != nmcelem + 3)\n\t{\n\t\tnumbers = NULL;\n\t\tnnumbers = 0;\n\t}\n\n\tif (numbers)\n\t{\n\t\t/* Grab the lowest observed frequency */\n\t\tminfreq = numbers[nmcelem];\n\t}\n\telse\n\t{\n\t\t/* Without statistics make some default assumptions */\n\t\tminfreq = 2 * (float4) DEFAULT_CONTAIN_SEL;\n\t}\n\n\t/* Decide whether it is faster to use binary search or not. */\n\tif (nitems * floor_log2((uint32) nmcelem) < nmcelem + nitems)\n\t\tuse_bsearch = true;\n\telse\n\t\tuse_bsearch = false;\n\n\tif (operator == OID_ARRAY_CONTAINS_OP)\n\t{\n\t\t/*\n\t\t * Initial selectivity for \"column @> const\" query is 1.0, and it will\n\t\t * be decreased with each element of constant array.\n\t\t */\n\t\tselec = 1.0;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Initial selectivity for \"column && const\" query is 0.0, and it will\n\t\t * be increased with each element of constant array.\n\t\t */\n\t\tselec = 0.0;\n\t}\n\n\t/* Scan mcelem and array in parallel. */\n\tmcelem_index = 0;\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tbool\t\tmatch = false;\n\n\t\t/* Ignore any duplicates in the array data. */\n\t\tif (i > 0 &&\n\t\t\telement_compare(&array_data[i - 1], &array_data[i], cmpfunc) == 0)\n\t\t\tcontinue;\n\n\t\t/* Find the smallest MCELEM >= this array item. */\n\t\tif (use_bsearch)\n\t\t{\n\t\t\tmatch = find_next_mcelem(mcelem, nmcelem, array_data[i],\n\t\t\t\t\t\t\t\t\t &mcelem_index, cmpfunc);\n\t\t}\n\t\telse\n\t\t{\n\t\t\twhile (mcelem_index < nmcelem)\n\t\t\t{\n\t\t\t\tint\t\t\tcmp = element_compare(&mcelem[mcelem_index],\n\t\t\t\t\t\t\t\t\t\t\t\t  &array_data[i],\n\t\t\t\t\t\t\t\t\t\t\t\t  cmpfunc);\n\n\t\t\t\tif (cmp < 0)\n\t\t\t\t\tmcelem_index++;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (cmp == 0)\n\t\t\t\t\t\tmatch = true;\t/* mcelem is found */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (match && numbers)\n\t\t{\n\t\t\t/* MCELEM matches the array item; use its frequency. */\n\t\t\telem_selec = numbers[mcelem_index];\n\t\t\tmcelem_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * The element is not in MCELEM.  Punt, but assume that the\n\t\t\t * selectivity cannot be more than minfreq / 2.\n\t\t\t */\n\t\t\telem_selec = Min(DEFAULT_CONTAIN_SEL, minfreq / 2);\n\t\t}\n\n\t\t/*\n\t\t * Update overall selectivity using the current element's selectivity\n\t\t * and an assumption of element occurrence independence.\n\t\t */\n\t\tif (operator == OID_ARRAY_CONTAINS_OP)\n\t\t\tselec *= elem_selec;\n\t\telse\n\t\t\tselec = selec + elem_selec - selec * elem_selec;\n\n\t\t/* Clamp intermediate results to stay sane despite roundoff error */\n\t\tCLAMP_PROBABILITY(selec);\n\t}\n\n\treturn selec;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DEFAULT_CONTAIN_SEL 0.005"
          ],
          "globals_used": [
            "static Selectivity calc_arraycontsel(VariableStatData *vardata, Datum constval,\n\t\t\t\t  Oid elemtype, Oid operator);",
            "static Selectivity mcelem_array_selec(ArrayType *array,\n\t\t\t\t   TypeCacheEntry *typentry,\n\t\t\t\t   Datum *mcelem, int nmcelem,\n\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t   float4 *hist, int nhist,\n\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);",
            "static Selectivity mcelem_array_contain_overlap_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t\t   Datum *array_data, int nitems,\n\t\t\t\t\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);",
            "static Selectivity mcelem_array_contained_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t Datum *array_data, int nitems,\n\t\t\t\t\t\t\t float4 *hist, int nhist,\n\t\t\t\t\t\t\t Oid operator, FmgrInfo *cmpfunc);",
            "static bool find_next_mcelem(Datum *mcelem, int nmcelem, Datum value,\n\t\t\t\t int *index, FmgrInfo *cmpfunc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/clauses.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\n#define DEFAULT_CONTAIN_SEL 0.005\n\nstatic Selectivity calc_arraycontsel(VariableStatData *vardata, Datum constval,\n\t\t\t\t  Oid elemtype, Oid operator);\nstatic Selectivity mcelem_array_selec(ArrayType *array,\n\t\t\t\t   TypeCacheEntry *typentry,\n\t\t\t\t   Datum *mcelem, int nmcelem,\n\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t   float4 *hist, int nhist,\n\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);\nstatic Selectivity mcelem_array_contain_overlap_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t\t   Datum *array_data, int nitems,\n\t\t\t\t\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);\nstatic Selectivity mcelem_array_contained_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t Datum *array_data, int nitems,\n\t\t\t\t\t\t\t float4 *hist, int nhist,\n\t\t\t\t\t\t\t Oid operator, FmgrInfo *cmpfunc);\nstatic bool find_next_mcelem(Datum *mcelem, int nmcelem, Datum value,\n\t\t\t\t int *index, FmgrInfo *cmpfunc);\n\nstatic Selectivity\nmcelem_array_contain_overlap_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t\t   Datum *array_data, int nitems,\n\t\t\t\t\t\t\t\t   Oid operator, FmgrInfo *cmpfunc)\n{\n\tSelectivity selec,\n\t\t\t\telem_selec;\n\tint\t\t\tmcelem_index,\n\t\t\t\ti;\n\tbool\t\tuse_bsearch;\n\tfloat4\t\tminfreq;\n\n\t/*\n\t * There should be three more Numbers than Values, because the last three\n\t * cells should hold minimal and maximal frequency among the non-null\n\t * elements, and then the frequency of null elements.  Ignore the Numbers\n\t * if not right.\n\t */\n\tif (nnumbers != nmcelem + 3)\n\t{\n\t\tnumbers = NULL;\n\t\tnnumbers = 0;\n\t}\n\n\tif (numbers)\n\t{\n\t\t/* Grab the lowest observed frequency */\n\t\tminfreq = numbers[nmcelem];\n\t}\n\telse\n\t{\n\t\t/* Without statistics make some default assumptions */\n\t\tminfreq = 2 * (float4) DEFAULT_CONTAIN_SEL;\n\t}\n\n\t/* Decide whether it is faster to use binary search or not. */\n\tif (nitems * floor_log2((uint32) nmcelem) < nmcelem + nitems)\n\t\tuse_bsearch = true;\n\telse\n\t\tuse_bsearch = false;\n\n\tif (operator == OID_ARRAY_CONTAINS_OP)\n\t{\n\t\t/*\n\t\t * Initial selectivity for \"column @> const\" query is 1.0, and it will\n\t\t * be decreased with each element of constant array.\n\t\t */\n\t\tselec = 1.0;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Initial selectivity for \"column && const\" query is 0.0, and it will\n\t\t * be increased with each element of constant array.\n\t\t */\n\t\tselec = 0.0;\n\t}\n\n\t/* Scan mcelem and array in parallel. */\n\tmcelem_index = 0;\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tbool\t\tmatch = false;\n\n\t\t/* Ignore any duplicates in the array data. */\n\t\tif (i > 0 &&\n\t\t\telement_compare(&array_data[i - 1], &array_data[i], cmpfunc) == 0)\n\t\t\tcontinue;\n\n\t\t/* Find the smallest MCELEM >= this array item. */\n\t\tif (use_bsearch)\n\t\t{\n\t\t\tmatch = find_next_mcelem(mcelem, nmcelem, array_data[i],\n\t\t\t\t\t\t\t\t\t &mcelem_index, cmpfunc);\n\t\t}\n\t\telse\n\t\t{\n\t\t\twhile (mcelem_index < nmcelem)\n\t\t\t{\n\t\t\t\tint\t\t\tcmp = element_compare(&mcelem[mcelem_index],\n\t\t\t\t\t\t\t\t\t\t\t\t  &array_data[i],\n\t\t\t\t\t\t\t\t\t\t\t\t  cmpfunc);\n\n\t\t\t\tif (cmp < 0)\n\t\t\t\t\tmcelem_index++;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (cmp == 0)\n\t\t\t\t\t\tmatch = true;\t/* mcelem is found */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (match && numbers)\n\t\t{\n\t\t\t/* MCELEM matches the array item; use its frequency. */\n\t\t\telem_selec = numbers[mcelem_index];\n\t\t\tmcelem_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * The element is not in MCELEM.  Punt, but assume that the\n\t\t\t * selectivity cannot be more than minfreq / 2.\n\t\t\t */\n\t\t\telem_selec = Min(DEFAULT_CONTAIN_SEL, minfreq / 2);\n\t\t}\n\n\t\t/*\n\t\t * Update overall selectivity using the current element's selectivity\n\t\t * and an assumption of element occurrence independence.\n\t\t */\n\t\tif (operator == OID_ARRAY_CONTAINS_OP)\n\t\t\tselec *= elem_selec;\n\t\telse\n\t\t\tselec = selec + elem_selec - selec * elem_selec;\n\n\t\t/* Clamp intermediate results to stay sane despite roundoff error */\n\t\tCLAMP_PROBABILITY(selec);\n\t}\n\n\treturn selec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qsort_arg",
          "args": [
            "elem_values",
            "nonnull_nitems",
            "sizeof(Datum)",
            "element_compare",
            "cmpfunc"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deconstruct_array",
          "args": [
            "array",
            "typentry->type_id",
            "typentry->typlen",
            "typentry->typbyval",
            "typentry->typalign",
            "&elem_values",
            "&elem_nulls",
            "&num_elems"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "deconstruct_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3460-3519",
          "snippet": "void\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\n\nvoid\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/clauses.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Selectivity calc_arraycontsel(VariableStatData *vardata, Datum constval,\n\t\t\t\t  Oid elemtype, Oid operator);\nstatic Selectivity mcelem_array_selec(ArrayType *array,\n\t\t\t\t   TypeCacheEntry *typentry,\n\t\t\t\t   Datum *mcelem, int nmcelem,\n\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t   float4 *hist, int nhist,\n\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);\nstatic Selectivity mcelem_array_contain_overlap_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t\t   Datum *array_data, int nitems,\n\t\t\t\t\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);\nstatic Selectivity mcelem_array_contained_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t Datum *array_data, int nitems,\n\t\t\t\t\t\t\t float4 *hist, int nhist,\n\t\t\t\t\t\t\t Oid operator, FmgrInfo *cmpfunc);\nstatic bool find_next_mcelem(Datum *mcelem, int nmcelem, Datum value,\n\t\t\t\t int *index, FmgrInfo *cmpfunc);\n\nstatic Selectivity\nmcelem_array_selec(ArrayType *array, TypeCacheEntry *typentry,\n\t\t\t\t   Datum *mcelem, int nmcelem,\n\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t   float4 *hist, int nhist,\n\t\t\t\t   Oid operator, FmgrInfo *cmpfunc)\n{\n\tSelectivity selec;\n\tint\t\t\tnum_elems;\n\tDatum\t   *elem_values;\n\tbool\t   *elem_nulls;\n\tbool\t\tnull_present;\n\tint\t\t\tnonnull_nitems;\n\tint\t\t\ti;\n\n\t/*\n\t * Prepare constant array data for sorting.  Sorting lets us find unique\n\t * elements and efficiently merge with the MCELEM array.\n\t */\n\tdeconstruct_array(array,\n\t\t\t\t\t  typentry->type_id,\n\t\t\t\t\t  typentry->typlen,\n\t\t\t\t\t  typentry->typbyval,\n\t\t\t\t\t  typentry->typalign,\n\t\t\t\t\t  &elem_values, &elem_nulls, &num_elems);\n\n\t/* Collapse out any null elements */\n\tnonnull_nitems = 0;\n\tnull_present = false;\n\tfor (i = 0; i < num_elems; i++)\n\t{\n\t\tif (elem_nulls[i])\n\t\t\tnull_present = true;\n\t\telse\n\t\t\telem_values[nonnull_nitems++] = elem_values[i];\n\t}\n\n\t/*\n\t * Query \"column @> '{anything, null}'\" matches nothing.  For the other\n\t * two operators, presence of a null in the constant can be ignored.\n\t */\n\tif (null_present && operator == OID_ARRAY_CONTAINS_OP)\n\t{\n\t\tpfree(elem_values);\n\t\tpfree(elem_nulls);\n\t\treturn (Selectivity) 0.0;\n\t}\n\n\t/* Sort extracted elements using their default comparison function. */\n\tqsort_arg(elem_values, nonnull_nitems, sizeof(Datum),\n\t\t\t  element_compare, cmpfunc);\n\n\t/* Separate cases according to operator */\n\tif (operator == OID_ARRAY_CONTAINS_OP || operator == OID_ARRAY_OVERLAP_OP)\n\t\tselec = mcelem_array_contain_overlap_selec(mcelem, nmcelem,\n\t\t\t\t\t\t\t\t\t\t\t\t   numbers, nnumbers,\n\t\t\t\t\t\t\t\t\t\t\t\t   elem_values, nonnull_nitems,\n\t\t\t\t\t\t\t\t\t\t\t\t   operator, cmpfunc);\n\telse if (operator == OID_ARRAY_CONTAINED_OP)\n\t\tselec = mcelem_array_contained_selec(mcelem, nmcelem,\n\t\t\t\t\t\t\t\t\t\t\t numbers, nnumbers,\n\t\t\t\t\t\t\t\t\t\t\t elem_values, nonnull_nitems,\n\t\t\t\t\t\t\t\t\t\t\t hist, nhist,\n\t\t\t\t\t\t\t\t\t\t\t operator, cmpfunc);\n\telse\n\t{\n\t\telog(ERROR, \"arraycontsel called for unrecognized operator %u\",\n\t\t\t operator);\n\t\tselec = 0.0;\t\t\t/* keep compiler quiet */\n\t}\n\n\tpfree(elem_values);\n\tpfree(elem_nulls);\n\treturn selec;\n}"
  },
  {
    "function_name": "calc_arraycontsel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_selfuncs.c",
    "lines": "338-420",
    "snippet": "static Selectivity\ncalc_arraycontsel(VariableStatData *vardata, Datum constval,\n\t\t\t\t  Oid elemtype, Oid operator)\n{\n\tSelectivity selec;\n\tTypeCacheEntry *typentry;\n\tFmgrInfo   *cmpfunc;\n\tArrayType  *array;\n\n\t/* Get element type's default comparison function */\n\ttypentry = lookup_type_cache(elemtype, TYPECACHE_CMP_PROC_FINFO);\n\tif (!OidIsValid(typentry->cmp_proc_finfo.fn_oid))\n\t\treturn DEFAULT_SEL(operator);\n\tcmpfunc = &typentry->cmp_proc_finfo;\n\n\t/*\n\t * The caller made sure the const is an array with same element type, so\n\t * get it now\n\t */\n\tarray = DatumGetArrayTypeP(constval);\n\n\tif (HeapTupleIsValid(vardata->statsTuple) &&\n\t\tstatistic_proc_security_check(vardata, cmpfunc->fn_oid))\n\t{\n\t\tForm_pg_statistic stats;\n\t\tAttStatsSlot sslot;\n\t\tAttStatsSlot hslot;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata->statsTuple);\n\n\t\t/* MCELEM will be an array of same type as column */\n\t\tif (get_attstatsslot(&sslot, vardata->statsTuple,\n\t\t\t\t\t\t\t STATISTIC_KIND_MCELEM, InvalidOid,\n\t\t\t\t\t\t\t ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS))\n\t\t{\n\t\t\t/*\n\t\t\t * For \"array <@ const\" case we also need histogram of distinct\n\t\t\t * element counts.\n\t\t\t */\n\t\t\tif (operator != OID_ARRAY_CONTAINED_OP ||\n\t\t\t\t!get_attstatsslot(&hslot, vardata->statsTuple,\n\t\t\t\t\t\t\t\t  STATISTIC_KIND_DECHIST, InvalidOid,\n\t\t\t\t\t\t\t\t  ATTSTATSSLOT_NUMBERS))\n\t\t\t\tmemset(&hslot, 0, sizeof(hslot));\n\n\t\t\t/* Use the most-common-elements slot for the array Var. */\n\t\t\tselec = mcelem_array_selec(array, typentry,\n\t\t\t\t\t\t\t\t\t   sslot.values, sslot.nvalues,\n\t\t\t\t\t\t\t\t\t   sslot.numbers, sslot.nnumbers,\n\t\t\t\t\t\t\t\t\t   hslot.numbers, hslot.nnumbers,\n\t\t\t\t\t\t\t\t\t   operator, cmpfunc);\n\n\t\t\tfree_attstatsslot(&hslot);\n\t\t\tfree_attstatsslot(&sslot);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* No most-common-elements info, so do without */\n\t\t\tselec = mcelem_array_selec(array, typentry,\n\t\t\t\t\t\t\t\t\t   NULL, 0, NULL, 0, NULL, 0,\n\t\t\t\t\t\t\t\t\t   operator, cmpfunc);\n\t\t}\n\n\t\t/*\n\t\t * MCE stats count only non-null rows, so adjust for null rows.\n\t\t */\n\t\tselec *= (1.0 - stats->stanullfrac);\n\t}\n\telse\n\t{\n\t\t/* No stats at all, so do without */\n\t\tselec = mcelem_array_selec(array, typentry,\n\t\t\t\t\t\t\t\t   NULL, 0, NULL, 0, NULL, 0,\n\t\t\t\t\t\t\t\t   operator, cmpfunc);\n\t\t/* we assume no nulls here, so no stanullfrac correction */\n\t}\n\n\t/* If constant was toasted, release the copy we made */\n\tif (PointerGetDatum(array) != constval)\n\t\tpfree(array);\n\n\treturn selec;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Selectivity calc_arraycontsel(VariableStatData *vardata, Datum constval,\n\t\t\t\t  Oid elemtype, Oid operator);",
      "static Selectivity mcelem_array_selec(ArrayType *array,\n\t\t\t\t   TypeCacheEntry *typentry,\n\t\t\t\t   Datum *mcelem, int nmcelem,\n\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t   float4 *hist, int nhist,\n\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);",
      "static Selectivity mcelem_array_contain_overlap_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t\t   Datum *array_data, int nitems,\n\t\t\t\t\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);",
      "static Selectivity mcelem_array_contained_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t Datum *array_data, int nitems,\n\t\t\t\t\t\t\t float4 *hist, int nhist,\n\t\t\t\t\t\t\t Oid operator, FmgrInfo *cmpfunc);",
      "static bool find_next_mcelem(Datum *mcelem, int nmcelem, Datum value,\n\t\t\t\t int *index, FmgrInfo *cmpfunc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "array"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "array"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mcelem_array_selec",
          "args": [
            "array",
            "typentry",
            "NULL",
            "0",
            "NULL",
            "0",
            "NULL",
            "0",
            "operator",
            "cmpfunc"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "mcelem_array_selec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_selfuncs.c",
          "lines": "429-503",
          "snippet": "static Selectivity\nmcelem_array_selec(ArrayType *array, TypeCacheEntry *typentry,\n\t\t\t\t   Datum *mcelem, int nmcelem,\n\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t   float4 *hist, int nhist,\n\t\t\t\t   Oid operator, FmgrInfo *cmpfunc)\n{\n\tSelectivity selec;\n\tint\t\t\tnum_elems;\n\tDatum\t   *elem_values;\n\tbool\t   *elem_nulls;\n\tbool\t\tnull_present;\n\tint\t\t\tnonnull_nitems;\n\tint\t\t\ti;\n\n\t/*\n\t * Prepare constant array data for sorting.  Sorting lets us find unique\n\t * elements and efficiently merge with the MCELEM array.\n\t */\n\tdeconstruct_array(array,\n\t\t\t\t\t  typentry->type_id,\n\t\t\t\t\t  typentry->typlen,\n\t\t\t\t\t  typentry->typbyval,\n\t\t\t\t\t  typentry->typalign,\n\t\t\t\t\t  &elem_values, &elem_nulls, &num_elems);\n\n\t/* Collapse out any null elements */\n\tnonnull_nitems = 0;\n\tnull_present = false;\n\tfor (i = 0; i < num_elems; i++)\n\t{\n\t\tif (elem_nulls[i])\n\t\t\tnull_present = true;\n\t\telse\n\t\t\telem_values[nonnull_nitems++] = elem_values[i];\n\t}\n\n\t/*\n\t * Query \"column @> '{anything, null}'\" matches nothing.  For the other\n\t * two operators, presence of a null in the constant can be ignored.\n\t */\n\tif (null_present && operator == OID_ARRAY_CONTAINS_OP)\n\t{\n\t\tpfree(elem_values);\n\t\tpfree(elem_nulls);\n\t\treturn (Selectivity) 0.0;\n\t}\n\n\t/* Sort extracted elements using their default comparison function. */\n\tqsort_arg(elem_values, nonnull_nitems, sizeof(Datum),\n\t\t\t  element_compare, cmpfunc);\n\n\t/* Separate cases according to operator */\n\tif (operator == OID_ARRAY_CONTAINS_OP || operator == OID_ARRAY_OVERLAP_OP)\n\t\tselec = mcelem_array_contain_overlap_selec(mcelem, nmcelem,\n\t\t\t\t\t\t\t\t\t\t\t\t   numbers, nnumbers,\n\t\t\t\t\t\t\t\t\t\t\t\t   elem_values, nonnull_nitems,\n\t\t\t\t\t\t\t\t\t\t\t\t   operator, cmpfunc);\n\telse if (operator == OID_ARRAY_CONTAINED_OP)\n\t\tselec = mcelem_array_contained_selec(mcelem, nmcelem,\n\t\t\t\t\t\t\t\t\t\t\t numbers, nnumbers,\n\t\t\t\t\t\t\t\t\t\t\t elem_values, nonnull_nitems,\n\t\t\t\t\t\t\t\t\t\t\t hist, nhist,\n\t\t\t\t\t\t\t\t\t\t\t operator, cmpfunc);\n\telse\n\t{\n\t\telog(ERROR, \"arraycontsel called for unrecognized operator %u\",\n\t\t\t operator);\n\t\tselec = 0.0;\t\t\t/* keep compiler quiet */\n\t}\n\n\tpfree(elem_values);\n\tpfree(elem_nulls);\n\treturn selec;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Selectivity calc_arraycontsel(VariableStatData *vardata, Datum constval,\n\t\t\t\t  Oid elemtype, Oid operator);",
            "static Selectivity mcelem_array_selec(ArrayType *array,\n\t\t\t\t   TypeCacheEntry *typentry,\n\t\t\t\t   Datum *mcelem, int nmcelem,\n\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t   float4 *hist, int nhist,\n\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);",
            "static Selectivity mcelem_array_contain_overlap_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t\t   Datum *array_data, int nitems,\n\t\t\t\t\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);",
            "static Selectivity mcelem_array_contained_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t Datum *array_data, int nitems,\n\t\t\t\t\t\t\t float4 *hist, int nhist,\n\t\t\t\t\t\t\t Oid operator, FmgrInfo *cmpfunc);",
            "static bool find_next_mcelem(Datum *mcelem, int nmcelem, Datum value,\n\t\t\t\t int *index, FmgrInfo *cmpfunc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/clauses.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Selectivity calc_arraycontsel(VariableStatData *vardata, Datum constval,\n\t\t\t\t  Oid elemtype, Oid operator);\nstatic Selectivity mcelem_array_selec(ArrayType *array,\n\t\t\t\t   TypeCacheEntry *typentry,\n\t\t\t\t   Datum *mcelem, int nmcelem,\n\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t   float4 *hist, int nhist,\n\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);\nstatic Selectivity mcelem_array_contain_overlap_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t\t   Datum *array_data, int nitems,\n\t\t\t\t\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);\nstatic Selectivity mcelem_array_contained_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t Datum *array_data, int nitems,\n\t\t\t\t\t\t\t float4 *hist, int nhist,\n\t\t\t\t\t\t\t Oid operator, FmgrInfo *cmpfunc);\nstatic bool find_next_mcelem(Datum *mcelem, int nmcelem, Datum value,\n\t\t\t\t int *index, FmgrInfo *cmpfunc);\n\nstatic Selectivity\nmcelem_array_selec(ArrayType *array, TypeCacheEntry *typentry,\n\t\t\t\t   Datum *mcelem, int nmcelem,\n\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t   float4 *hist, int nhist,\n\t\t\t\t   Oid operator, FmgrInfo *cmpfunc)\n{\n\tSelectivity selec;\n\tint\t\t\tnum_elems;\n\tDatum\t   *elem_values;\n\tbool\t   *elem_nulls;\n\tbool\t\tnull_present;\n\tint\t\t\tnonnull_nitems;\n\tint\t\t\ti;\n\n\t/*\n\t * Prepare constant array data for sorting.  Sorting lets us find unique\n\t * elements and efficiently merge with the MCELEM array.\n\t */\n\tdeconstruct_array(array,\n\t\t\t\t\t  typentry->type_id,\n\t\t\t\t\t  typentry->typlen,\n\t\t\t\t\t  typentry->typbyval,\n\t\t\t\t\t  typentry->typalign,\n\t\t\t\t\t  &elem_values, &elem_nulls, &num_elems);\n\n\t/* Collapse out any null elements */\n\tnonnull_nitems = 0;\n\tnull_present = false;\n\tfor (i = 0; i < num_elems; i++)\n\t{\n\t\tif (elem_nulls[i])\n\t\t\tnull_present = true;\n\t\telse\n\t\t\telem_values[nonnull_nitems++] = elem_values[i];\n\t}\n\n\t/*\n\t * Query \"column @> '{anything, null}'\" matches nothing.  For the other\n\t * two operators, presence of a null in the constant can be ignored.\n\t */\n\tif (null_present && operator == OID_ARRAY_CONTAINS_OP)\n\t{\n\t\tpfree(elem_values);\n\t\tpfree(elem_nulls);\n\t\treturn (Selectivity) 0.0;\n\t}\n\n\t/* Sort extracted elements using their default comparison function. */\n\tqsort_arg(elem_values, nonnull_nitems, sizeof(Datum),\n\t\t\t  element_compare, cmpfunc);\n\n\t/* Separate cases according to operator */\n\tif (operator == OID_ARRAY_CONTAINS_OP || operator == OID_ARRAY_OVERLAP_OP)\n\t\tselec = mcelem_array_contain_overlap_selec(mcelem, nmcelem,\n\t\t\t\t\t\t\t\t\t\t\t\t   numbers, nnumbers,\n\t\t\t\t\t\t\t\t\t\t\t\t   elem_values, nonnull_nitems,\n\t\t\t\t\t\t\t\t\t\t\t\t   operator, cmpfunc);\n\telse if (operator == OID_ARRAY_CONTAINED_OP)\n\t\tselec = mcelem_array_contained_selec(mcelem, nmcelem,\n\t\t\t\t\t\t\t\t\t\t\t numbers, nnumbers,\n\t\t\t\t\t\t\t\t\t\t\t elem_values, nonnull_nitems,\n\t\t\t\t\t\t\t\t\t\t\t hist, nhist,\n\t\t\t\t\t\t\t\t\t\t\t operator, cmpfunc);\n\telse\n\t{\n\t\telog(ERROR, \"arraycontsel called for unrecognized operator %u\",\n\t\t\t operator);\n\t\tselec = 0.0;\t\t\t/* keep compiler quiet */\n\t}\n\n\tpfree(elem_values);\n\tpfree(elem_nulls);\n\treturn selec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_attstatsslot",
          "args": [
            "&sslot"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "free_attstatsslot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "3052-3064",
          "snippet": "void\nfree_attstatsslot(AttStatsSlot *sslot)\n{\n\t/* The values[] array was separately palloc'd by deconstruct_array */\n\tif (sslot->values)\n\t\tpfree(sslot->values);\n\t/* The numbers[] array points into numbers_arr, do not pfree it */\n\t/* Free the detoasted array objects, if any */\n\tif (sslot->values_arr)\n\t\tpfree(sslot->values_arr);\n\tif (sslot->numbers_arr)\n\t\tpfree(sslot->numbers_arr);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nfree_attstatsslot(AttStatsSlot *sslot)\n{\n\t/* The values[] array was separately palloc'd by deconstruct_array */\n\tif (sslot->values)\n\t\tpfree(sslot->values);\n\t/* The numbers[] array points into numbers_arr, do not pfree it */\n\t/* Free the detoasted array objects, if any */\n\tif (sslot->values_arr)\n\t\tpfree(sslot->values_arr);\n\tif (sslot->numbers_arr)\n\t\tpfree(sslot->numbers_arr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&hslot",
            "0",
            "sizeof(hslot)"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_attstatsslot",
          "args": [
            "&hslot",
            "vardata->statsTuple",
            "STATISTIC_KIND_DECHIST",
            "InvalidOid",
            "ATTSTATSSLOT_NUMBERS"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "get_attstatsslot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2936-3046",
          "snippet": "bool\nget_attstatsslot(AttStatsSlot *sslot, HeapTuple statstuple,\n\t\t\t\t int reqkind, Oid reqop, int flags)\n{\n\tForm_pg_statistic stats = (Form_pg_statistic) GETSTRUCT(statstuple);\n\tint\t\t\ti;\n\tDatum\t\tval;\n\tbool\t\tisnull;\n\tArrayType  *statarray;\n\tOid\t\t\tarrayelemtype;\n\tint\t\t\tnarrayelem;\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type typeForm;\n\n\t/* initialize *sslot properly */\n\tmemset(sslot, 0, sizeof(AttStatsSlot));\n\n\tfor (i = 0; i < STATISTIC_NUM_SLOTS; i++)\n\t{\n\t\tif ((&stats->stakind1)[i] == reqkind &&\n\t\t\t(reqop == InvalidOid || (&stats->staop1)[i] == reqop))\n\t\t\tbreak;\n\t}\n\tif (i >= STATISTIC_NUM_SLOTS)\n\t\treturn false;\t\t\t/* not there */\n\n\tsslot->staop = (&stats->staop1)[i];\n\n\tif (flags & ATTSTATSSLOT_VALUES)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stavalues1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stavalues is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * Extract the actual array element type, and pass it back in case the\n\t\t * caller needs it.\n\t\t */\n\t\tsslot->valuetype = arrayelemtype = ARR_ELEMTYPE(statarray);\n\n\t\t/* Need info about element type */\n\t\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(arrayelemtype));\n\t\tif (!HeapTupleIsValid(typeTuple))\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", arrayelemtype);\n\t\ttypeForm = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\t\t/* Deconstruct array into Datum elements; NULLs not expected */\n\t\tdeconstruct_array(statarray,\n\t\t\t\t\t\t  arrayelemtype,\n\t\t\t\t\t\t  typeForm->typlen,\n\t\t\t\t\t\t  typeForm->typbyval,\n\t\t\t\t\t\t  typeForm->typalign,\n\t\t\t\t\t\t  &sslot->values, NULL, &sslot->nvalues);\n\n\t\t/*\n\t\t * If the element type is pass-by-reference, we now have a bunch of\n\t\t * Datums that are pointers into the statarray, so we need to keep\n\t\t * that until free_attstatsslot.  Otherwise, all the useful info is in\n\t\t * sslot->values[], so we can free the array object immediately.\n\t\t */\n\t\tif (!typeForm->typbyval)\n\t\t\tsslot->values_arr = statarray;\n\t\telse\n\t\t\tpfree(statarray);\n\n\t\tReleaseSysCache(typeTuple);\n\t}\n\n\tif (flags & ATTSTATSSLOT_NUMBERS)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stanumbers1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stanumbers is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * We expect the array to be a 1-D float4 array; verify that. We don't\n\t\t * need to use deconstruct_array() since the array data is just going\n\t\t * to look like a C array of float4 values.\n\t\t */\n\t\tnarrayelem = ARR_DIMS(statarray)[0];\n\t\tif (ARR_NDIM(statarray) != 1 || narrayelem <= 0 ||\n\t\t\tARR_HASNULL(statarray) ||\n\t\t\tARR_ELEMTYPE(statarray) != FLOAT4OID)\n\t\t\telog(ERROR, \"stanumbers is not a 1-D float4 array\");\n\n\t\t/* Give caller a pointer directly into the statarray */\n\t\tsslot->numbers = (float4 *) ARR_DATA_PTR(statarray);\n\t\tsslot->nnumbers = narrayelem;\n\n\t\t/* We'll free the statarray in free_attstatsslot */\n\t\tsslot->numbers_arr = statarray;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nget_attstatsslot(AttStatsSlot *sslot, HeapTuple statstuple,\n\t\t\t\t int reqkind, Oid reqop, int flags)\n{\n\tForm_pg_statistic stats = (Form_pg_statistic) GETSTRUCT(statstuple);\n\tint\t\t\ti;\n\tDatum\t\tval;\n\tbool\t\tisnull;\n\tArrayType  *statarray;\n\tOid\t\t\tarrayelemtype;\n\tint\t\t\tnarrayelem;\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type typeForm;\n\n\t/* initialize *sslot properly */\n\tmemset(sslot, 0, sizeof(AttStatsSlot));\n\n\tfor (i = 0; i < STATISTIC_NUM_SLOTS; i++)\n\t{\n\t\tif ((&stats->stakind1)[i] == reqkind &&\n\t\t\t(reqop == InvalidOid || (&stats->staop1)[i] == reqop))\n\t\t\tbreak;\n\t}\n\tif (i >= STATISTIC_NUM_SLOTS)\n\t\treturn false;\t\t\t/* not there */\n\n\tsslot->staop = (&stats->staop1)[i];\n\n\tif (flags & ATTSTATSSLOT_VALUES)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stavalues1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stavalues is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * Extract the actual array element type, and pass it back in case the\n\t\t * caller needs it.\n\t\t */\n\t\tsslot->valuetype = arrayelemtype = ARR_ELEMTYPE(statarray);\n\n\t\t/* Need info about element type */\n\t\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(arrayelemtype));\n\t\tif (!HeapTupleIsValid(typeTuple))\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", arrayelemtype);\n\t\ttypeForm = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\t\t/* Deconstruct array into Datum elements; NULLs not expected */\n\t\tdeconstruct_array(statarray,\n\t\t\t\t\t\t  arrayelemtype,\n\t\t\t\t\t\t  typeForm->typlen,\n\t\t\t\t\t\t  typeForm->typbyval,\n\t\t\t\t\t\t  typeForm->typalign,\n\t\t\t\t\t\t  &sslot->values, NULL, &sslot->nvalues);\n\n\t\t/*\n\t\t * If the element type is pass-by-reference, we now have a bunch of\n\t\t * Datums that are pointers into the statarray, so we need to keep\n\t\t * that until free_attstatsslot.  Otherwise, all the useful info is in\n\t\t * sslot->values[], so we can free the array object immediately.\n\t\t */\n\t\tif (!typeForm->typbyval)\n\t\t\tsslot->values_arr = statarray;\n\t\telse\n\t\t\tpfree(statarray);\n\n\t\tReleaseSysCache(typeTuple);\n\t}\n\n\tif (flags & ATTSTATSSLOT_NUMBERS)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stanumbers1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stanumbers is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * We expect the array to be a 1-D float4 array; verify that. We don't\n\t\t * need to use deconstruct_array() since the array data is just going\n\t\t * to look like a C array of float4 values.\n\t\t */\n\t\tnarrayelem = ARR_DIMS(statarray)[0];\n\t\tif (ARR_NDIM(statarray) != 1 || narrayelem <= 0 ||\n\t\t\tARR_HASNULL(statarray) ||\n\t\t\tARR_ELEMTYPE(statarray) != FLOAT4OID)\n\t\t\telog(ERROR, \"stanumbers is not a 1-D float4 array\");\n\n\t\t/* Give caller a pointer directly into the statarray */\n\t\tsslot->numbers = (float4 *) ARR_DATA_PTR(statarray);\n\t\tsslot->nnumbers = narrayelem;\n\n\t\t/* We'll free the statarray in free_attstatsslot */\n\t\tsslot->numbers_arr = statarray;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "vardata->statsTuple"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "statistic_proc_security_check",
          "args": [
            "vardata",
            "cmpfunc->fn_oid"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "statistic_proc_security_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "5167-5183",
          "snippet": "bool\nstatistic_proc_security_check(VariableStatData *vardata, Oid func_oid)\n{\n\tif (vardata->acl_ok)\n\t\treturn true;\n\n\tif (!OidIsValid(func_oid))\n\t\treturn false;\n\n\tif (get_func_leakproof(func_oid))\n\t\treturn true;\n\n\tereport(DEBUG2,\n\t\t\t(errmsg_internal(\"not using statistics because function \\\"%s\\\" is not leak-proof\",\n\t\t\t\t\t\t\t get_func_name(func_oid))));\n\treturn false;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nbool\nstatistic_proc_security_check(VariableStatData *vardata, Oid func_oid)\n{\n\tif (vardata->acl_ok)\n\t\treturn true;\n\n\tif (!OidIsValid(func_oid))\n\t\treturn false;\n\n\tif (get_func_leakproof(func_oid))\n\t\treturn true;\n\n\tereport(DEBUG2,\n\t\t\t(errmsg_internal(\"not using statistics because function \\\"%s\\\" is not leak-proof\",\n\t\t\t\t\t\t\t get_func_name(func_oid))));\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "vardata->statsTuple"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetArrayTypeP",
          "args": [
            "constval"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFAULT_SEL",
          "args": [
            "operator"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "typentry->cmp_proc_finfo.fn_oid"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_type_cache",
          "args": [
            "elemtype",
            "TYPECACHE_CMP_PROC_FINFO"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_type_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "320-778",
          "snippet": "TypeCacheEntry *\nlookup_type_cache(Oid type_id, int flags)\n{\n\tTypeCacheEntry *typentry;\n\tbool\t\tfound;\n\n\tif (TypeCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(TypeCacheEntry);\n\t\tTypeCacheHash = hash_create(\"Type information cache\", 64,\n\t\t\t\t\t\t\t\t\t&ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also set up callbacks for SI invalidations */\n\t\tCacheRegisterRelcacheCallback(TypeCacheRelCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CLAOID, TypeCacheOpcCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CONSTROID, TypeCacheConstrCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(TYPEOID, TypeCacheConstrCallback, (Datum) 0);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Try to look up an existing entry */\n\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (typentry == NULL)\n\t{\n\t\t/*\n\t\t * If we didn't find one, we want to make one.  But first look up the\n\t\t * pg_type row, just to make sure we don't make a cache entry for an\n\t\t * invalid type OID.  If the type OID is not valid, present a\n\t\t * user-facing error, since some code paths such as domain_in() allow\n\t\t * this function to be reached with a user-supplied OID.\n\t\t */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_type typtup;\n\n\t\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_id));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type with OID %u does not exist\", type_id)));\n\t\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t\tif (!typtup->typisdefined)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type \\\"%s\\\" is only a shell\",\n\t\t\t\t\t\t\tNameStr(typtup->typname))));\n\n\t\t/* Now make the typcache entry */\n\t\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\t\tAssert(!found);\t\t\t/* it wasn't there a moment ago */\n\n\t\tMemSet(typentry, 0, sizeof(TypeCacheEntry));\n\t\ttypentry->type_id = type_id;\n\t\ttypentry->typlen = typtup->typlen;\n\t\ttypentry->typbyval = typtup->typbyval;\n\t\ttypentry->typalign = typtup->typalign;\n\t\ttypentry->typstorage = typtup->typstorage;\n\t\ttypentry->typtype = typtup->typtype;\n\t\ttypentry->typrelid = typtup->typrelid;\n\t\ttypentry->typelem = typtup->typelem;\n\n\t\t/* If it's a domain, immediately thread it into the domain cache list */\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\ttypentry->nextDomain = firstDomainTypeEntry;\n\t\t\tfirstDomainTypeEntry = typentry;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Look up opclasses if we haven't already and any dependent info is\n\t * requested.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_LT_OPR | TYPECACHE_GT_OPR |\n\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t  TYPECACHE_EQ_OPR_FINFO | TYPECACHE_CMP_PROC_FINFO |\n\t\t\t\t  TYPECACHE_BTREE_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_BTREE_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, BTREE_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->btree_opf = get_opclass_family(opclass);\n\t\t\ttypentry->btree_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->btree_opf = typentry->btree_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from btree opclass.  Note in particular\n\t\t * that we'll redetermine the eq_opr even if we previously found one;\n\t\t * this matters in case a btree opclass has been added to a type that\n\t\t * previously had only a hash opclass.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_EQ_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_LT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_GT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_CMP_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_BTREE_OPCLASS;\n\t}\n\n\t/*\n\t * If we need to look up equality operator, and there's no btree opclass,\n\t * force lookup of hash opclass.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR) &&\n\t\ttypentry->btree_opf == InvalidOid)\n\t\tflags |= TYPECACHE_HASH_OPFAMILY;\n\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, HASH_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->hash_opf = get_opclass_family(opclass);\n\t\t\ttypentry->hash_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->hash_opf = typentry->hash_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from hash opclass.  We do *not* reset the\n\t\t * eq_opr; if we already found one from the btree opclass, that\n\t\t * decision is still good.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_OPCLASS;\n\t}\n\n\t/*\n\t * Look for requested operators and functions, if we haven't already.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR))\n\t{\n\t\tOid\t\t\teq_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\t\tif (eq_opr == InvalidOid &&\n\t\t\ttypentry->hash_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber);\n\n\t\t/*\n\t\t * If the proposed equality operator is array_eq or record_eq, check\n\t\t * to see if the element type or column types support equality.  If\n\t\t * not, array_eq or record_eq would fail at runtime, so we don't want\n\t\t * to report that the type has equality.  (We can omit similar\n\t\t * checking for ranges because ranges can't be created in the first\n\t\t * place unless their subtypes support equality.)\n\t\t */\n\t\tif (eq_opr == ARRAY_EQ_OP &&\n\t\t\t!array_element_has_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\t\telse if (eq_opr == RECORD_EQ_OP &&\n\t\t\t\t !record_fields_have_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\n\t\t/* Force update of eq_opr_finfo only if we're changing state */\n\t\tif (typentry->eq_opr != eq_opr)\n\t\t\ttypentry->eq_opr_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->eq_opr = eq_opr;\n\n\t\t/*\n\t\t * Reset info about hash functions whenever we pick up new info about\n\t\t * equality operator.  This is so we can ensure that the hash\n\t\t * functions match the operator.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_EQ_OPR;\n\t}\n\tif ((flags & TYPECACHE_LT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_LT_OPR))\n\t{\n\t\tOid\t\t\tlt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tlt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (lt_opr == ARRAY_LT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\t\telse if (lt_opr == RECORD_LT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\n\t\ttypentry->lt_opr = lt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_LT_OPR;\n\t}\n\tif ((flags & TYPECACHE_GT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_GT_OPR))\n\t{\n\t\tOid\t\t\tgt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tgt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTGreaterStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (gt_opr == ARRAY_GT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\t\telse if (gt_opr == RECORD_GT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\n\t\ttypentry->gt_opr = gt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_GT_OPR;\n\t}\n\tif ((flags & (TYPECACHE_CMP_PROC | TYPECACHE_CMP_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_CMP_PROC))\n\t{\n\t\tOid\t\t\tcmp_proc = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tcmp_proc = get_opfamily_proc(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (cmp_proc == F_BTARRAYCMP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\t\telse if (cmp_proc == F_BTRECORDCMP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\n\t\t/* Force update of cmp_proc_finfo only if we're changing state */\n\t\tif (typentry->cmp_proc != cmp_proc)\n\t\t\ttypentry->cmp_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->cmp_proc = cmp_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_CMP_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_PROC))\n\t{\n\t\tOid\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  HASHSTANDARD_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array will succeed.  We don't currently\n\t\t * support hashing for composite types, but when we do, we'll need\n\t\t * more logic here to check that case too.\n\t\t */\n\t\tif (hash_proc == F_HASH_ARRAY &&\n\t\t\t!array_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range.\n\t\t */\n\t\tif (hash_proc == F_HASH_RANGE &&\n\t\t\t!range_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/* Force update of hash_proc_finfo only if we're changing state */\n\t\tif (typentry->hash_proc != hash_proc)\n\t\t\ttypentry->hash_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_proc = hash_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_EXTENDED_PROC))\n\t{\n\t\tOid\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_extended_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   HASHEXTENDED_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array_extended will succeed.  We don't\n\t\t * currently support hashing for composite types, but when we do,\n\t\t * we'll need more logic here to check that case too.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_ARRAY_EXTENDED &&\n\t\t\t!array_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range_extended.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_RANGE_EXTENDED &&\n\t\t\t!range_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/* Force update of proc finfo only if we're changing state */\n\t\tif (typentry->hash_extended_proc != hash_extended_proc)\n\t\t\ttypentry->hash_extended_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_extended_proc = hash_extended_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_EXTENDED_PROC;\n\t}\n\n\t/*\n\t * Set up fmgr lookup info as requested\n\t *\n\t * Note: we tell fmgr the finfo structures live in CacheMemoryContext,\n\t * which is not quite right (they're really in the hash table's private\n\t * memory context) but this will do for our purposes.\n\t *\n\t * Note: the code above avoids invalidating the finfo structs unless the\n\t * referenced operator/function OID actually changes.  This is to prevent\n\t * unnecessary leakage of any subsidiary data attached to an finfo, since\n\t * that would cause session-lifespan memory leaks.\n\t */\n\tif ((flags & TYPECACHE_EQ_OPR_FINFO) &&\n\t\ttypentry->eq_opr_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->eq_opr != InvalidOid)\n\t{\n\t\tOid\t\t\teq_opr_func;\n\n\t\teq_opr_func = get_opcode(typentry->eq_opr);\n\t\tif (eq_opr_func != InvalidOid)\n\t\t\tfmgr_info_cxt(eq_opr_func, &typentry->eq_opr_finfo,\n\t\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_CMP_PROC_FINFO) &&\n\t\ttypentry->cmp_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->cmp_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->cmp_proc, &typentry->cmp_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_PROC_FINFO) &&\n\t\ttypentry->hash_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_proc, &typentry->hash_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_EXTENDED_PROC_FINFO) &&\n\t\ttypentry->hash_extended_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_extended_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_extended_proc,\n\t\t\t\t\t  &typentry->hash_extended_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\n\t/*\n\t * If it's a composite type (row type), get tupdesc if requested\n\t */\n\tif ((flags & TYPECACHE_TUPDESC) &&\n\t\ttypentry->tupDesc == NULL &&\n\t\ttypentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tload_typcache_tupdesc(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a range type\n\t */\n\tif ((flags & TYPECACHE_RANGE_INFO) &&\n\t\ttypentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t{\n\t\tload_rangetype_info(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a domain type\n\t */\n\tif ((flags & TYPECACHE_DOMAIN_BASE_INFO) &&\n\t\ttypentry->domainBaseType == InvalidOid &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\ttypentry->domainBaseTypmod = -1;\n\t\ttypentry->domainBaseType =\n\t\t\tgetBaseTypeAndTypmod(type_id, &typentry->domainBaseTypmod);\n\t}\n\tif ((flags & TYPECACHE_DOMAIN_CONSTR_INFO) &&\n\t\t(typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\tload_domaintype_info(typentry);\n\t}\n\n\treturn typentry;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000",
            "#define TCFLAGS_CHECKED_HASH_EXTENDED_PROC\t0x000080",
            "#define TCFLAGS_CHECKED_HASH_PROC\t\t\t0x000040",
            "#define TCFLAGS_CHECKED_CMP_PROC\t\t\t0x000020",
            "#define TCFLAGS_CHECKED_GT_OPR\t\t\t\t0x000010",
            "#define TCFLAGS_CHECKED_LT_OPR\t\t\t\t0x000008",
            "#define TCFLAGS_CHECKED_EQ_OPR\t\t\t\t0x000004",
            "#define TCFLAGS_CHECKED_HASH_OPCLASS\t\t0x000002",
            "#define TCFLAGS_CHECKED_BTREE_OPCLASS\t\t0x000001"
          ],
          "globals_used": [
            "static HTAB *TypeCacheHash = NULL;",
            "static TypeCacheEntry *firstDomainTypeEntry = NULL;",
            "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
            "static void load_rangetype_info(TypeCacheEntry *typentry);",
            "static void load_domaintype_info(TypeCacheEntry *typentry);",
            "static bool array_element_has_equality(TypeCacheEntry *typentry);",
            "static bool array_element_has_compare(TypeCacheEntry *typentry);",
            "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_array_element_properties(TypeCacheEntry *typentry);",
            "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
            "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
            "static void cache_record_field_properties(TypeCacheEntry *typentry);",
            "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_range_element_properties(TypeCacheEntry *typentry);",
            "static int\tenum_oid_cmp(const void *left, const void *right);",
            "static TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000\n#define TCFLAGS_CHECKED_HASH_EXTENDED_PROC\t0x000080\n#define TCFLAGS_CHECKED_HASH_PROC\t\t\t0x000040\n#define TCFLAGS_CHECKED_CMP_PROC\t\t\t0x000020\n#define TCFLAGS_CHECKED_GT_OPR\t\t\t\t0x000010\n#define TCFLAGS_CHECKED_LT_OPR\t\t\t\t0x000008\n#define TCFLAGS_CHECKED_EQ_OPR\t\t\t\t0x000004\n#define TCFLAGS_CHECKED_HASH_OPCLASS\t\t0x000002\n#define TCFLAGS_CHECKED_BTREE_OPCLASS\t\t0x000001\n\nstatic HTAB *TypeCacheHash = NULL;\nstatic TypeCacheEntry *firstDomainTypeEntry = NULL;\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\nstatic int\tenum_oid_cmp(const void *left, const void *right);\nstatic TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);\n\nTypeCacheEntry *\nlookup_type_cache(Oid type_id, int flags)\n{\n\tTypeCacheEntry *typentry;\n\tbool\t\tfound;\n\n\tif (TypeCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(TypeCacheEntry);\n\t\tTypeCacheHash = hash_create(\"Type information cache\", 64,\n\t\t\t\t\t\t\t\t\t&ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also set up callbacks for SI invalidations */\n\t\tCacheRegisterRelcacheCallback(TypeCacheRelCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CLAOID, TypeCacheOpcCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CONSTROID, TypeCacheConstrCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(TYPEOID, TypeCacheConstrCallback, (Datum) 0);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Try to look up an existing entry */\n\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (typentry == NULL)\n\t{\n\t\t/*\n\t\t * If we didn't find one, we want to make one.  But first look up the\n\t\t * pg_type row, just to make sure we don't make a cache entry for an\n\t\t * invalid type OID.  If the type OID is not valid, present a\n\t\t * user-facing error, since some code paths such as domain_in() allow\n\t\t * this function to be reached with a user-supplied OID.\n\t\t */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_type typtup;\n\n\t\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_id));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type with OID %u does not exist\", type_id)));\n\t\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t\tif (!typtup->typisdefined)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type \\\"%s\\\" is only a shell\",\n\t\t\t\t\t\t\tNameStr(typtup->typname))));\n\n\t\t/* Now make the typcache entry */\n\t\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\t\tAssert(!found);\t\t\t/* it wasn't there a moment ago */\n\n\t\tMemSet(typentry, 0, sizeof(TypeCacheEntry));\n\t\ttypentry->type_id = type_id;\n\t\ttypentry->typlen = typtup->typlen;\n\t\ttypentry->typbyval = typtup->typbyval;\n\t\ttypentry->typalign = typtup->typalign;\n\t\ttypentry->typstorage = typtup->typstorage;\n\t\ttypentry->typtype = typtup->typtype;\n\t\ttypentry->typrelid = typtup->typrelid;\n\t\ttypentry->typelem = typtup->typelem;\n\n\t\t/* If it's a domain, immediately thread it into the domain cache list */\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\ttypentry->nextDomain = firstDomainTypeEntry;\n\t\t\tfirstDomainTypeEntry = typentry;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Look up opclasses if we haven't already and any dependent info is\n\t * requested.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_LT_OPR | TYPECACHE_GT_OPR |\n\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t  TYPECACHE_EQ_OPR_FINFO | TYPECACHE_CMP_PROC_FINFO |\n\t\t\t\t  TYPECACHE_BTREE_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_BTREE_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, BTREE_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->btree_opf = get_opclass_family(opclass);\n\t\t\ttypentry->btree_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->btree_opf = typentry->btree_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from btree opclass.  Note in particular\n\t\t * that we'll redetermine the eq_opr even if we previously found one;\n\t\t * this matters in case a btree opclass has been added to a type that\n\t\t * previously had only a hash opclass.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_EQ_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_LT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_GT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_CMP_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_BTREE_OPCLASS;\n\t}\n\n\t/*\n\t * If we need to look up equality operator, and there's no btree opclass,\n\t * force lookup of hash opclass.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR) &&\n\t\ttypentry->btree_opf == InvalidOid)\n\t\tflags |= TYPECACHE_HASH_OPFAMILY;\n\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, HASH_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->hash_opf = get_opclass_family(opclass);\n\t\t\ttypentry->hash_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->hash_opf = typentry->hash_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from hash opclass.  We do *not* reset the\n\t\t * eq_opr; if we already found one from the btree opclass, that\n\t\t * decision is still good.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_OPCLASS;\n\t}\n\n\t/*\n\t * Look for requested operators and functions, if we haven't already.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR))\n\t{\n\t\tOid\t\t\teq_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\t\tif (eq_opr == InvalidOid &&\n\t\t\ttypentry->hash_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber);\n\n\t\t/*\n\t\t * If the proposed equality operator is array_eq or record_eq, check\n\t\t * to see if the element type or column types support equality.  If\n\t\t * not, array_eq or record_eq would fail at runtime, so we don't want\n\t\t * to report that the type has equality.  (We can omit similar\n\t\t * checking for ranges because ranges can't be created in the first\n\t\t * place unless their subtypes support equality.)\n\t\t */\n\t\tif (eq_opr == ARRAY_EQ_OP &&\n\t\t\t!array_element_has_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\t\telse if (eq_opr == RECORD_EQ_OP &&\n\t\t\t\t !record_fields_have_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\n\t\t/* Force update of eq_opr_finfo only if we're changing state */\n\t\tif (typentry->eq_opr != eq_opr)\n\t\t\ttypentry->eq_opr_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->eq_opr = eq_opr;\n\n\t\t/*\n\t\t * Reset info about hash functions whenever we pick up new info about\n\t\t * equality operator.  This is so we can ensure that the hash\n\t\t * functions match the operator.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_EQ_OPR;\n\t}\n\tif ((flags & TYPECACHE_LT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_LT_OPR))\n\t{\n\t\tOid\t\t\tlt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tlt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (lt_opr == ARRAY_LT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\t\telse if (lt_opr == RECORD_LT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\n\t\ttypentry->lt_opr = lt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_LT_OPR;\n\t}\n\tif ((flags & TYPECACHE_GT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_GT_OPR))\n\t{\n\t\tOid\t\t\tgt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tgt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTGreaterStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (gt_opr == ARRAY_GT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\t\telse if (gt_opr == RECORD_GT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\n\t\ttypentry->gt_opr = gt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_GT_OPR;\n\t}\n\tif ((flags & (TYPECACHE_CMP_PROC | TYPECACHE_CMP_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_CMP_PROC))\n\t{\n\t\tOid\t\t\tcmp_proc = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tcmp_proc = get_opfamily_proc(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (cmp_proc == F_BTARRAYCMP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\t\telse if (cmp_proc == F_BTRECORDCMP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\n\t\t/* Force update of cmp_proc_finfo only if we're changing state */\n\t\tif (typentry->cmp_proc != cmp_proc)\n\t\t\ttypentry->cmp_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->cmp_proc = cmp_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_CMP_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_PROC))\n\t{\n\t\tOid\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  HASHSTANDARD_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array will succeed.  We don't currently\n\t\t * support hashing for composite types, but when we do, we'll need\n\t\t * more logic here to check that case too.\n\t\t */\n\t\tif (hash_proc == F_HASH_ARRAY &&\n\t\t\t!array_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range.\n\t\t */\n\t\tif (hash_proc == F_HASH_RANGE &&\n\t\t\t!range_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/* Force update of hash_proc_finfo only if we're changing state */\n\t\tif (typentry->hash_proc != hash_proc)\n\t\t\ttypentry->hash_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_proc = hash_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_EXTENDED_PROC))\n\t{\n\t\tOid\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_extended_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   HASHEXTENDED_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array_extended will succeed.  We don't\n\t\t * currently support hashing for composite types, but when we do,\n\t\t * we'll need more logic here to check that case too.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_ARRAY_EXTENDED &&\n\t\t\t!array_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range_extended.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_RANGE_EXTENDED &&\n\t\t\t!range_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/* Force update of proc finfo only if we're changing state */\n\t\tif (typentry->hash_extended_proc != hash_extended_proc)\n\t\t\ttypentry->hash_extended_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_extended_proc = hash_extended_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_EXTENDED_PROC;\n\t}\n\n\t/*\n\t * Set up fmgr lookup info as requested\n\t *\n\t * Note: we tell fmgr the finfo structures live in CacheMemoryContext,\n\t * which is not quite right (they're really in the hash table's private\n\t * memory context) but this will do for our purposes.\n\t *\n\t * Note: the code above avoids invalidating the finfo structs unless the\n\t * referenced operator/function OID actually changes.  This is to prevent\n\t * unnecessary leakage of any subsidiary data attached to an finfo, since\n\t * that would cause session-lifespan memory leaks.\n\t */\n\tif ((flags & TYPECACHE_EQ_OPR_FINFO) &&\n\t\ttypentry->eq_opr_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->eq_opr != InvalidOid)\n\t{\n\t\tOid\t\t\teq_opr_func;\n\n\t\teq_opr_func = get_opcode(typentry->eq_opr);\n\t\tif (eq_opr_func != InvalidOid)\n\t\t\tfmgr_info_cxt(eq_opr_func, &typentry->eq_opr_finfo,\n\t\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_CMP_PROC_FINFO) &&\n\t\ttypentry->cmp_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->cmp_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->cmp_proc, &typentry->cmp_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_PROC_FINFO) &&\n\t\ttypentry->hash_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_proc, &typentry->hash_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_EXTENDED_PROC_FINFO) &&\n\t\ttypentry->hash_extended_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_extended_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_extended_proc,\n\t\t\t\t\t  &typentry->hash_extended_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\n\t/*\n\t * If it's a composite type (row type), get tupdesc if requested\n\t */\n\tif ((flags & TYPECACHE_TUPDESC) &&\n\t\ttypentry->tupDesc == NULL &&\n\t\ttypentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tload_typcache_tupdesc(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a range type\n\t */\n\tif ((flags & TYPECACHE_RANGE_INFO) &&\n\t\ttypentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t{\n\t\tload_rangetype_info(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a domain type\n\t */\n\tif ((flags & TYPECACHE_DOMAIN_BASE_INFO) &&\n\t\ttypentry->domainBaseType == InvalidOid &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\ttypentry->domainBaseTypmod = -1;\n\t\ttypentry->domainBaseType =\n\t\t\tgetBaseTypeAndTypmod(type_id, &typentry->domainBaseTypmod);\n\t}\n\tif ((flags & TYPECACHE_DOMAIN_CONSTR_INFO) &&\n\t\t(typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\tload_domaintype_info(typentry);\n\t}\n\n\treturn typentry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/clauses.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Selectivity calc_arraycontsel(VariableStatData *vardata, Datum constval,\n\t\t\t\t  Oid elemtype, Oid operator);\nstatic Selectivity mcelem_array_selec(ArrayType *array,\n\t\t\t\t   TypeCacheEntry *typentry,\n\t\t\t\t   Datum *mcelem, int nmcelem,\n\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t   float4 *hist, int nhist,\n\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);\nstatic Selectivity mcelem_array_contain_overlap_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t\t   Datum *array_data, int nitems,\n\t\t\t\t\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);\nstatic Selectivity mcelem_array_contained_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t Datum *array_data, int nitems,\n\t\t\t\t\t\t\t float4 *hist, int nhist,\n\t\t\t\t\t\t\t Oid operator, FmgrInfo *cmpfunc);\nstatic bool find_next_mcelem(Datum *mcelem, int nmcelem, Datum value,\n\t\t\t\t int *index, FmgrInfo *cmpfunc);\n\nstatic Selectivity\ncalc_arraycontsel(VariableStatData *vardata, Datum constval,\n\t\t\t\t  Oid elemtype, Oid operator)\n{\n\tSelectivity selec;\n\tTypeCacheEntry *typentry;\n\tFmgrInfo   *cmpfunc;\n\tArrayType  *array;\n\n\t/* Get element type's default comparison function */\n\ttypentry = lookup_type_cache(elemtype, TYPECACHE_CMP_PROC_FINFO);\n\tif (!OidIsValid(typentry->cmp_proc_finfo.fn_oid))\n\t\treturn DEFAULT_SEL(operator);\n\tcmpfunc = &typentry->cmp_proc_finfo;\n\n\t/*\n\t * The caller made sure the const is an array with same element type, so\n\t * get it now\n\t */\n\tarray = DatumGetArrayTypeP(constval);\n\n\tif (HeapTupleIsValid(vardata->statsTuple) &&\n\t\tstatistic_proc_security_check(vardata, cmpfunc->fn_oid))\n\t{\n\t\tForm_pg_statistic stats;\n\t\tAttStatsSlot sslot;\n\t\tAttStatsSlot hslot;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata->statsTuple);\n\n\t\t/* MCELEM will be an array of same type as column */\n\t\tif (get_attstatsslot(&sslot, vardata->statsTuple,\n\t\t\t\t\t\t\t STATISTIC_KIND_MCELEM, InvalidOid,\n\t\t\t\t\t\t\t ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS))\n\t\t{\n\t\t\t/*\n\t\t\t * For \"array <@ const\" case we also need histogram of distinct\n\t\t\t * element counts.\n\t\t\t */\n\t\t\tif (operator != OID_ARRAY_CONTAINED_OP ||\n\t\t\t\t!get_attstatsslot(&hslot, vardata->statsTuple,\n\t\t\t\t\t\t\t\t  STATISTIC_KIND_DECHIST, InvalidOid,\n\t\t\t\t\t\t\t\t  ATTSTATSSLOT_NUMBERS))\n\t\t\t\tmemset(&hslot, 0, sizeof(hslot));\n\n\t\t\t/* Use the most-common-elements slot for the array Var. */\n\t\t\tselec = mcelem_array_selec(array, typentry,\n\t\t\t\t\t\t\t\t\t   sslot.values, sslot.nvalues,\n\t\t\t\t\t\t\t\t\t   sslot.numbers, sslot.nnumbers,\n\t\t\t\t\t\t\t\t\t   hslot.numbers, hslot.nnumbers,\n\t\t\t\t\t\t\t\t\t   operator, cmpfunc);\n\n\t\t\tfree_attstatsslot(&hslot);\n\t\t\tfree_attstatsslot(&sslot);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* No most-common-elements info, so do without */\n\t\t\tselec = mcelem_array_selec(array, typentry,\n\t\t\t\t\t\t\t\t\t   NULL, 0, NULL, 0, NULL, 0,\n\t\t\t\t\t\t\t\t\t   operator, cmpfunc);\n\t\t}\n\n\t\t/*\n\t\t * MCE stats count only non-null rows, so adjust for null rows.\n\t\t */\n\t\tselec *= (1.0 - stats->stanullfrac);\n\t}\n\telse\n\t{\n\t\t/* No stats at all, so do without */\n\t\tselec = mcelem_array_selec(array, typentry,\n\t\t\t\t\t\t\t\t   NULL, 0, NULL, 0, NULL, 0,\n\t\t\t\t\t\t\t\t   operator, cmpfunc);\n\t\t/* we assume no nulls here, so no stanullfrac correction */\n\t}\n\n\t/* If constant was toasted, release the copy we made */\n\tif (PointerGetDatum(array) != constval)\n\t\tpfree(array);\n\n\treturn selec;\n}"
  },
  {
    "function_name": "arraycontjoinsel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_selfuncs.c",
    "lines": "322-329",
    "snippet": "Datum\narraycontjoinsel(PG_FUNCTION_ARGS)\n{\n\t/* For the moment this is just a stub */\n\tOid\t\t\toperator = PG_GETARG_OID(1);\n\n\tPG_RETURN_FLOAT8(DEFAULT_SEL(operator));\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Selectivity calc_arraycontsel(VariableStatData *vardata, Datum constval,\n\t\t\t\t  Oid elemtype, Oid operator);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "DEFAULT_SEL(operator)"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFAULT_SEL",
          "args": [
            "operator"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "1"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/clauses.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Selectivity calc_arraycontsel(VariableStatData *vardata, Datum constval,\n\t\t\t\t  Oid elemtype, Oid operator);\n\nDatum\narraycontjoinsel(PG_FUNCTION_ARGS)\n{\n\t/* For the moment this is just a stub */\n\tOid\t\t\toperator = PG_GETARG_OID(1);\n\n\tPG_RETURN_FLOAT8(DEFAULT_SEL(operator));\n}"
  },
  {
    "function_name": "arraycontsel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_selfuncs.c",
    "lines": "242-317",
    "snippet": "Datum\narraycontsel(PG_FUNCTION_ARGS)\n{\n\tPlannerInfo *root = (PlannerInfo *) PG_GETARG_POINTER(0);\n\tOid\t\t\toperator = PG_GETARG_OID(1);\n\tList\t   *args = (List *) PG_GETARG_POINTER(2);\n\tint\t\t\tvarRelid = PG_GETARG_INT32(3);\n\tVariableStatData vardata;\n\tNode\t   *other;\n\tbool\t\tvaronleft;\n\tSelectivity selec;\n\tOid\t\t\telement_typeid;\n\n\t/*\n\t * If expression is not (variable op something) or (something op\n\t * variable), then punt and return a default estimate.\n\t */\n\tif (!get_restriction_variable(root, args, varRelid,\n\t\t\t\t\t\t\t\t  &vardata, &other, &varonleft))\n\t\tPG_RETURN_FLOAT8(DEFAULT_SEL(operator));\n\n\t/*\n\t * Can't do anything useful if the something is not a constant, either.\n\t */\n\tif (!IsA(other, Const))\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\tPG_RETURN_FLOAT8(DEFAULT_SEL(operator));\n\t}\n\n\t/*\n\t * The \"&&\", \"@>\" and \"<@\" operators are strict, so we can cope with a\n\t * NULL constant right away.\n\t */\n\tif (((Const *) other)->constisnull)\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\tPG_RETURN_FLOAT8(0.0);\n\t}\n\n\t/*\n\t * If var is on the right, commute the operator, so that we can assume the\n\t * var is on the left in what follows.\n\t */\n\tif (!varonleft)\n\t{\n\t\tif (operator == OID_ARRAY_CONTAINS_OP)\n\t\t\toperator = OID_ARRAY_CONTAINED_OP;\n\t\telse if (operator == OID_ARRAY_CONTAINED_OP)\n\t\t\toperator = OID_ARRAY_CONTAINS_OP;\n\t}\n\n\t/*\n\t * OK, there's a Var and a Const we're dealing with here.  We need the\n\t * Const to be an array with same element type as column, else we can't do\n\t * anything useful.  (Such cases will likely fail at runtime, but here\n\t * we'd rather just return a default estimate.)\n\t */\n\telement_typeid = get_base_element_type(((Const *) other)->consttype);\n\tif (element_typeid != InvalidOid &&\n\t\telement_typeid == get_base_element_type(vardata.vartype))\n\t{\n\t\tselec = calc_arraycontsel(&vardata, ((Const *) other)->constvalue,\n\t\t\t\t\t\t\t\t  element_typeid, operator);\n\t}\n\telse\n\t{\n\t\tselec = DEFAULT_SEL(operator);\n\t}\n\n\tReleaseVariableStats(vardata);\n\n\tCLAMP_PROBABILITY(selec);\n\n\tPG_RETURN_FLOAT8((float8) selec);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Selectivity calc_arraycontsel(VariableStatData *vardata, Datum constval,\n\t\t\t\t  Oid elemtype, Oid operator);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "(float8) selec"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLAMP_PROBABILITY",
          "args": [
            "selec"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseVariableStats",
          "args": [
            "vardata"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFAULT_SEL",
          "args": [
            "operator"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calc_arraycontsel",
          "args": [
            "&vardata",
            "((Const *) other)->constvalue",
            "element_typeid",
            "operator"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "calc_arraycontsel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_selfuncs.c",
          "lines": "338-420",
          "snippet": "static Selectivity\ncalc_arraycontsel(VariableStatData *vardata, Datum constval,\n\t\t\t\t  Oid elemtype, Oid operator)\n{\n\tSelectivity selec;\n\tTypeCacheEntry *typentry;\n\tFmgrInfo   *cmpfunc;\n\tArrayType  *array;\n\n\t/* Get element type's default comparison function */\n\ttypentry = lookup_type_cache(elemtype, TYPECACHE_CMP_PROC_FINFO);\n\tif (!OidIsValid(typentry->cmp_proc_finfo.fn_oid))\n\t\treturn DEFAULT_SEL(operator);\n\tcmpfunc = &typentry->cmp_proc_finfo;\n\n\t/*\n\t * The caller made sure the const is an array with same element type, so\n\t * get it now\n\t */\n\tarray = DatumGetArrayTypeP(constval);\n\n\tif (HeapTupleIsValid(vardata->statsTuple) &&\n\t\tstatistic_proc_security_check(vardata, cmpfunc->fn_oid))\n\t{\n\t\tForm_pg_statistic stats;\n\t\tAttStatsSlot sslot;\n\t\tAttStatsSlot hslot;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata->statsTuple);\n\n\t\t/* MCELEM will be an array of same type as column */\n\t\tif (get_attstatsslot(&sslot, vardata->statsTuple,\n\t\t\t\t\t\t\t STATISTIC_KIND_MCELEM, InvalidOid,\n\t\t\t\t\t\t\t ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS))\n\t\t{\n\t\t\t/*\n\t\t\t * For \"array <@ const\" case we also need histogram of distinct\n\t\t\t * element counts.\n\t\t\t */\n\t\t\tif (operator != OID_ARRAY_CONTAINED_OP ||\n\t\t\t\t!get_attstatsslot(&hslot, vardata->statsTuple,\n\t\t\t\t\t\t\t\t  STATISTIC_KIND_DECHIST, InvalidOid,\n\t\t\t\t\t\t\t\t  ATTSTATSSLOT_NUMBERS))\n\t\t\t\tmemset(&hslot, 0, sizeof(hslot));\n\n\t\t\t/* Use the most-common-elements slot for the array Var. */\n\t\t\tselec = mcelem_array_selec(array, typentry,\n\t\t\t\t\t\t\t\t\t   sslot.values, sslot.nvalues,\n\t\t\t\t\t\t\t\t\t   sslot.numbers, sslot.nnumbers,\n\t\t\t\t\t\t\t\t\t   hslot.numbers, hslot.nnumbers,\n\t\t\t\t\t\t\t\t\t   operator, cmpfunc);\n\n\t\t\tfree_attstatsslot(&hslot);\n\t\t\tfree_attstatsslot(&sslot);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* No most-common-elements info, so do without */\n\t\t\tselec = mcelem_array_selec(array, typentry,\n\t\t\t\t\t\t\t\t\t   NULL, 0, NULL, 0, NULL, 0,\n\t\t\t\t\t\t\t\t\t   operator, cmpfunc);\n\t\t}\n\n\t\t/*\n\t\t * MCE stats count only non-null rows, so adjust for null rows.\n\t\t */\n\t\tselec *= (1.0 - stats->stanullfrac);\n\t}\n\telse\n\t{\n\t\t/* No stats at all, so do without */\n\t\tselec = mcelem_array_selec(array, typentry,\n\t\t\t\t\t\t\t\t   NULL, 0, NULL, 0, NULL, 0,\n\t\t\t\t\t\t\t\t   operator, cmpfunc);\n\t\t/* we assume no nulls here, so no stanullfrac correction */\n\t}\n\n\t/* If constant was toasted, release the copy we made */\n\tif (PointerGetDatum(array) != constval)\n\t\tpfree(array);\n\n\treturn selec;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Selectivity calc_arraycontsel(VariableStatData *vardata, Datum constval,\n\t\t\t\t  Oid elemtype, Oid operator);",
            "static Selectivity mcelem_array_selec(ArrayType *array,\n\t\t\t\t   TypeCacheEntry *typentry,\n\t\t\t\t   Datum *mcelem, int nmcelem,\n\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t   float4 *hist, int nhist,\n\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);",
            "static Selectivity mcelem_array_contain_overlap_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t\t   Datum *array_data, int nitems,\n\t\t\t\t\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);",
            "static Selectivity mcelem_array_contained_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t Datum *array_data, int nitems,\n\t\t\t\t\t\t\t float4 *hist, int nhist,\n\t\t\t\t\t\t\t Oid operator, FmgrInfo *cmpfunc);",
            "static bool find_next_mcelem(Datum *mcelem, int nmcelem, Datum value,\n\t\t\t\t int *index, FmgrInfo *cmpfunc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/clauses.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Selectivity calc_arraycontsel(VariableStatData *vardata, Datum constval,\n\t\t\t\t  Oid elemtype, Oid operator);\nstatic Selectivity mcelem_array_selec(ArrayType *array,\n\t\t\t\t   TypeCacheEntry *typentry,\n\t\t\t\t   Datum *mcelem, int nmcelem,\n\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t   float4 *hist, int nhist,\n\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);\nstatic Selectivity mcelem_array_contain_overlap_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t\t   Datum *array_data, int nitems,\n\t\t\t\t\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);\nstatic Selectivity mcelem_array_contained_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t Datum *array_data, int nitems,\n\t\t\t\t\t\t\t float4 *hist, int nhist,\n\t\t\t\t\t\t\t Oid operator, FmgrInfo *cmpfunc);\nstatic bool find_next_mcelem(Datum *mcelem, int nmcelem, Datum value,\n\t\t\t\t int *index, FmgrInfo *cmpfunc);\n\nstatic Selectivity\ncalc_arraycontsel(VariableStatData *vardata, Datum constval,\n\t\t\t\t  Oid elemtype, Oid operator)\n{\n\tSelectivity selec;\n\tTypeCacheEntry *typentry;\n\tFmgrInfo   *cmpfunc;\n\tArrayType  *array;\n\n\t/* Get element type's default comparison function */\n\ttypentry = lookup_type_cache(elemtype, TYPECACHE_CMP_PROC_FINFO);\n\tif (!OidIsValid(typentry->cmp_proc_finfo.fn_oid))\n\t\treturn DEFAULT_SEL(operator);\n\tcmpfunc = &typentry->cmp_proc_finfo;\n\n\t/*\n\t * The caller made sure the const is an array with same element type, so\n\t * get it now\n\t */\n\tarray = DatumGetArrayTypeP(constval);\n\n\tif (HeapTupleIsValid(vardata->statsTuple) &&\n\t\tstatistic_proc_security_check(vardata, cmpfunc->fn_oid))\n\t{\n\t\tForm_pg_statistic stats;\n\t\tAttStatsSlot sslot;\n\t\tAttStatsSlot hslot;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata->statsTuple);\n\n\t\t/* MCELEM will be an array of same type as column */\n\t\tif (get_attstatsslot(&sslot, vardata->statsTuple,\n\t\t\t\t\t\t\t STATISTIC_KIND_MCELEM, InvalidOid,\n\t\t\t\t\t\t\t ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS))\n\t\t{\n\t\t\t/*\n\t\t\t * For \"array <@ const\" case we also need histogram of distinct\n\t\t\t * element counts.\n\t\t\t */\n\t\t\tif (operator != OID_ARRAY_CONTAINED_OP ||\n\t\t\t\t!get_attstatsslot(&hslot, vardata->statsTuple,\n\t\t\t\t\t\t\t\t  STATISTIC_KIND_DECHIST, InvalidOid,\n\t\t\t\t\t\t\t\t  ATTSTATSSLOT_NUMBERS))\n\t\t\t\tmemset(&hslot, 0, sizeof(hslot));\n\n\t\t\t/* Use the most-common-elements slot for the array Var. */\n\t\t\tselec = mcelem_array_selec(array, typentry,\n\t\t\t\t\t\t\t\t\t   sslot.values, sslot.nvalues,\n\t\t\t\t\t\t\t\t\t   sslot.numbers, sslot.nnumbers,\n\t\t\t\t\t\t\t\t\t   hslot.numbers, hslot.nnumbers,\n\t\t\t\t\t\t\t\t\t   operator, cmpfunc);\n\n\t\t\tfree_attstatsslot(&hslot);\n\t\t\tfree_attstatsslot(&sslot);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* No most-common-elements info, so do without */\n\t\t\tselec = mcelem_array_selec(array, typentry,\n\t\t\t\t\t\t\t\t\t   NULL, 0, NULL, 0, NULL, 0,\n\t\t\t\t\t\t\t\t\t   operator, cmpfunc);\n\t\t}\n\n\t\t/*\n\t\t * MCE stats count only non-null rows, so adjust for null rows.\n\t\t */\n\t\tselec *= (1.0 - stats->stanullfrac);\n\t}\n\telse\n\t{\n\t\t/* No stats at all, so do without */\n\t\tselec = mcelem_array_selec(array, typentry,\n\t\t\t\t\t\t\t\t   NULL, 0, NULL, 0, NULL, 0,\n\t\t\t\t\t\t\t\t   operator, cmpfunc);\n\t\t/* we assume no nulls here, so no stanullfrac correction */\n\t}\n\n\t/* If constant was toasted, release the copy we made */\n\tif (PointerGetDatum(array) != constval)\n\t\tpfree(array);\n\n\treturn selec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_base_element_type",
          "args": [
            "vardata.vartype"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "get_base_element_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2598-2633",
          "snippet": "Oid\nget_base_element_type(Oid typid)\n{\n\t/*\n\t * We loop to find the bottom base type in a stack of domains.\n\t */\n\tfor (;;)\n\t{\n\t\tHeapTuple\ttup;\n\t\tForm_pg_type typTup;\n\n\t\ttup = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\t\tif (!HeapTupleIsValid(tup))\n\t\t\tbreak;\n\t\ttypTup = (Form_pg_type) GETSTRUCT(tup);\n\t\tif (typTup->typtype != TYPTYPE_DOMAIN)\n\t\t{\n\t\t\t/* Not a domain, so stop descending */\n\t\t\tOid\t\t\tresult;\n\n\t\t\t/* This test must match get_element_type */\n\t\t\tif (typTup->typlen == -1)\n\t\t\t\tresult = typTup->typelem;\n\t\t\telse\n\t\t\t\tresult = InvalidOid;\n\t\t\tReleaseSysCache(tup);\n\t\t\treturn result;\n\t\t}\n\n\t\ttypid = typTup->typbasetype;\n\t\tReleaseSysCache(tup);\n\t}\n\n\t/* Like get_element_type, silently return InvalidOid for bogus input */\n\treturn InvalidOid;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nOid\nget_base_element_type(Oid typid)\n{\n\t/*\n\t * We loop to find the bottom base type in a stack of domains.\n\t */\n\tfor (;;)\n\t{\n\t\tHeapTuple\ttup;\n\t\tForm_pg_type typTup;\n\n\t\ttup = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\t\tif (!HeapTupleIsValid(tup))\n\t\t\tbreak;\n\t\ttypTup = (Form_pg_type) GETSTRUCT(tup);\n\t\tif (typTup->typtype != TYPTYPE_DOMAIN)\n\t\t{\n\t\t\t/* Not a domain, so stop descending */\n\t\t\tOid\t\t\tresult;\n\n\t\t\t/* This test must match get_element_type */\n\t\t\tif (typTup->typlen == -1)\n\t\t\t\tresult = typTup->typelem;\n\t\t\telse\n\t\t\t\tresult = InvalidOid;\n\t\t\tReleaseSysCache(tup);\n\t\t\treturn result;\n\t\t}\n\n\t\ttypid = typTup->typbasetype;\n\t\tReleaseSysCache(tup);\n\t}\n\n\t/* Like get_element_type, silently return InvalidOid for bogus input */\n\treturn InvalidOid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "0.0"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseVariableStats",
          "args": [
            "vardata"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "DEFAULT_SEL(operator)"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFAULT_SEL",
          "args": [
            "operator"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseVariableStats",
          "args": [
            "vardata"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "other",
            "Const"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "DEFAULT_SEL(operator)"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFAULT_SEL",
          "args": [
            "operator"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_restriction_variable",
          "args": [
            "root",
            "args",
            "varRelid",
            "&vardata",
            "&other",
            "&varonleft"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "get_restriction_variable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "4653-4701",
          "snippet": "bool\nget_restriction_variable(PlannerInfo *root, List *args, int varRelid,\n\t\t\t\t\t\t VariableStatData *vardata, Node **other,\n\t\t\t\t\t\t bool *varonleft)\n{\n\tNode\t   *left,\n\t\t\t   *right;\n\tVariableStatData rdata;\n\n\t/* Fail if not a binary opclause (probably shouldn't happen) */\n\tif (list_length(args) != 2)\n\t\treturn false;\n\n\tleft = (Node *) linitial(args);\n\tright = (Node *) lsecond(args);\n\n\t/*\n\t * Examine both sides.  Note that when varRelid is nonzero, Vars of other\n\t * relations will be treated as pseudoconstants.\n\t */\n\texamine_variable(root, left, varRelid, vardata);\n\texamine_variable(root, right, varRelid, &rdata);\n\n\t/*\n\t * If one side is a variable and the other not, we win.\n\t */\n\tif (vardata->rel && rdata.rel == NULL)\n\t{\n\t\t*varonleft = true;\n\t\t*other = estimate_expression_value(root, rdata.var);\n\t\t/* Assume we need no ReleaseVariableStats(rdata) here */\n\t\treturn true;\n\t}\n\n\tif (vardata->rel == NULL && rdata.rel)\n\t{\n\t\t*varonleft = false;\n\t\t*other = estimate_expression_value(root, vardata->var);\n\t\t/* Assume we need no ReleaseVariableStats(*vardata) here */\n\t\t*vardata = rdata;\n\t\treturn true;\n\t}\n\n\t/* Oops, clause has wrong structure (probably var op var) */\n\tReleaseVariableStats(*vardata);\n\tReleaseVariableStats(rdata);\n\n\treturn false;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nbool\nget_restriction_variable(PlannerInfo *root, List *args, int varRelid,\n\t\t\t\t\t\t VariableStatData *vardata, Node **other,\n\t\t\t\t\t\t bool *varonleft)\n{\n\tNode\t   *left,\n\t\t\t   *right;\n\tVariableStatData rdata;\n\n\t/* Fail if not a binary opclause (probably shouldn't happen) */\n\tif (list_length(args) != 2)\n\t\treturn false;\n\n\tleft = (Node *) linitial(args);\n\tright = (Node *) lsecond(args);\n\n\t/*\n\t * Examine both sides.  Note that when varRelid is nonzero, Vars of other\n\t * relations will be treated as pseudoconstants.\n\t */\n\texamine_variable(root, left, varRelid, vardata);\n\texamine_variable(root, right, varRelid, &rdata);\n\n\t/*\n\t * If one side is a variable and the other not, we win.\n\t */\n\tif (vardata->rel && rdata.rel == NULL)\n\t{\n\t\t*varonleft = true;\n\t\t*other = estimate_expression_value(root, rdata.var);\n\t\t/* Assume we need no ReleaseVariableStats(rdata) here */\n\t\treturn true;\n\t}\n\n\tif (vardata->rel == NULL && rdata.rel)\n\t{\n\t\t*varonleft = false;\n\t\t*other = estimate_expression_value(root, vardata->var);\n\t\t/* Assume we need no ReleaseVariableStats(*vardata) here */\n\t\t*vardata = rdata;\n\t\treturn true;\n\t}\n\n\t/* Oops, clause has wrong structure (probably var op var) */\n\tReleaseVariableStats(*vardata);\n\tReleaseVariableStats(rdata);\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "3"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "2"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "1"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/clauses.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Selectivity calc_arraycontsel(VariableStatData *vardata, Datum constval,\n\t\t\t\t  Oid elemtype, Oid operator);\n\nDatum\narraycontsel(PG_FUNCTION_ARGS)\n{\n\tPlannerInfo *root = (PlannerInfo *) PG_GETARG_POINTER(0);\n\tOid\t\t\toperator = PG_GETARG_OID(1);\n\tList\t   *args = (List *) PG_GETARG_POINTER(2);\n\tint\t\t\tvarRelid = PG_GETARG_INT32(3);\n\tVariableStatData vardata;\n\tNode\t   *other;\n\tbool\t\tvaronleft;\n\tSelectivity selec;\n\tOid\t\t\telement_typeid;\n\n\t/*\n\t * If expression is not (variable op something) or (something op\n\t * variable), then punt and return a default estimate.\n\t */\n\tif (!get_restriction_variable(root, args, varRelid,\n\t\t\t\t\t\t\t\t  &vardata, &other, &varonleft))\n\t\tPG_RETURN_FLOAT8(DEFAULT_SEL(operator));\n\n\t/*\n\t * Can't do anything useful if the something is not a constant, either.\n\t */\n\tif (!IsA(other, Const))\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\tPG_RETURN_FLOAT8(DEFAULT_SEL(operator));\n\t}\n\n\t/*\n\t * The \"&&\", \"@>\" and \"<@\" operators are strict, so we can cope with a\n\t * NULL constant right away.\n\t */\n\tif (((Const *) other)->constisnull)\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\tPG_RETURN_FLOAT8(0.0);\n\t}\n\n\t/*\n\t * If var is on the right, commute the operator, so that we can assume the\n\t * var is on the left in what follows.\n\t */\n\tif (!varonleft)\n\t{\n\t\tif (operator == OID_ARRAY_CONTAINS_OP)\n\t\t\toperator = OID_ARRAY_CONTAINED_OP;\n\t\telse if (operator == OID_ARRAY_CONTAINED_OP)\n\t\t\toperator = OID_ARRAY_CONTAINS_OP;\n\t}\n\n\t/*\n\t * OK, there's a Var and a Const we're dealing with here.  We need the\n\t * Const to be an array with same element type as column, else we can't do\n\t * anything useful.  (Such cases will likely fail at runtime, but here\n\t * we'd rather just return a default estimate.)\n\t */\n\telement_typeid = get_base_element_type(((Const *) other)->consttype);\n\tif (element_typeid != InvalidOid &&\n\t\telement_typeid == get_base_element_type(vardata.vartype))\n\t{\n\t\tselec = calc_arraycontsel(&vardata, ((Const *) other)->constvalue,\n\t\t\t\t\t\t\t\t  element_typeid, operator);\n\t}\n\telse\n\t{\n\t\tselec = DEFAULT_SEL(operator);\n\t}\n\n\tReleaseVariableStats(vardata);\n\n\tCLAMP_PROBABILITY(selec);\n\n\tPG_RETURN_FLOAT8((float8) selec);\n}"
  },
  {
    "function_name": "scalararraysel_containment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_selfuncs.c",
    "lines": "82-237",
    "snippet": "Selectivity\nscalararraysel_containment(PlannerInfo *root,\n\t\t\t\t\t\t   Node *leftop, Node *rightop,\n\t\t\t\t\t\t   Oid elemtype, bool isEquality, bool useOr,\n\t\t\t\t\t\t   int varRelid)\n{\n\tSelectivity selec;\n\tVariableStatData vardata;\n\tDatum\t\tconstval;\n\tTypeCacheEntry *typentry;\n\tFmgrInfo   *cmpfunc;\n\n\t/*\n\t * rightop must be a variable, else punt.\n\t */\n\texamine_variable(root, rightop, varRelid, &vardata);\n\tif (!vardata.rel)\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn -1.0;\n\t}\n\n\t/*\n\t * leftop must be a constant, else punt.\n\t */\n\tif (!IsA(leftop, Const))\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn -1.0;\n\t}\n\tif (((Const *) leftop)->constisnull)\n\t{\n\t\t/* qual can't succeed if null on left */\n\t\tReleaseVariableStats(vardata);\n\t\treturn (Selectivity) 0.0;\n\t}\n\tconstval = ((Const *) leftop)->constvalue;\n\n\t/* Get element type's default comparison function */\n\ttypentry = lookup_type_cache(elemtype, TYPECACHE_CMP_PROC_FINFO);\n\tif (!OidIsValid(typentry->cmp_proc_finfo.fn_oid))\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn -1.0;\n\t}\n\tcmpfunc = &typentry->cmp_proc_finfo;\n\n\t/*\n\t * If the operator is <>, swap ANY/ALL, then invert the result later.\n\t */\n\tif (!isEquality)\n\t\tuseOr = !useOr;\n\n\t/* Get array element stats for var, if available */\n\tif (HeapTupleIsValid(vardata.statsTuple) &&\n\t\tstatistic_proc_security_check(&vardata, cmpfunc->fn_oid))\n\t{\n\t\tForm_pg_statistic stats;\n\t\tAttStatsSlot sslot;\n\t\tAttStatsSlot hslot;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata.statsTuple);\n\n\t\t/* MCELEM will be an array of same type as element */\n\t\tif (get_attstatsslot(&sslot, vardata.statsTuple,\n\t\t\t\t\t\t\t STATISTIC_KIND_MCELEM, InvalidOid,\n\t\t\t\t\t\t\t ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS))\n\t\t{\n\t\t\t/* For ALL case, also get histogram of distinct-element counts */\n\t\t\tif (useOr ||\n\t\t\t\t!get_attstatsslot(&hslot, vardata.statsTuple,\n\t\t\t\t\t\t\t\t  STATISTIC_KIND_DECHIST, InvalidOid,\n\t\t\t\t\t\t\t\t  ATTSTATSSLOT_NUMBERS))\n\t\t\t\tmemset(&hslot, 0, sizeof(hslot));\n\n\t\t\t/*\n\t\t\t * For = ANY, estimate as var @> ARRAY[const].\n\t\t\t *\n\t\t\t * For = ALL, estimate as var <@ ARRAY[const].\n\t\t\t */\n\t\t\tif (useOr)\n\t\t\t\tselec = mcelem_array_contain_overlap_selec(sslot.values,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   sslot.nvalues,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   sslot.numbers,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   sslot.nnumbers,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   &constval, 1,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   OID_ARRAY_CONTAINS_OP,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   cmpfunc);\n\t\t\telse\n\t\t\t\tselec = mcelem_array_contained_selec(sslot.values,\n\t\t\t\t\t\t\t\t\t\t\t\t\t sslot.nvalues,\n\t\t\t\t\t\t\t\t\t\t\t\t\t sslot.numbers,\n\t\t\t\t\t\t\t\t\t\t\t\t\t sslot.nnumbers,\n\t\t\t\t\t\t\t\t\t\t\t\t\t &constval, 1,\n\t\t\t\t\t\t\t\t\t\t\t\t\t hslot.numbers,\n\t\t\t\t\t\t\t\t\t\t\t\t\t hslot.nnumbers,\n\t\t\t\t\t\t\t\t\t\t\t\t\t OID_ARRAY_CONTAINED_OP,\n\t\t\t\t\t\t\t\t\t\t\t\t\t cmpfunc);\n\n\t\t\tfree_attstatsslot(&hslot);\n\t\t\tfree_attstatsslot(&sslot);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* No most-common-elements info, so do without */\n\t\t\tif (useOr)\n\t\t\t\tselec = mcelem_array_contain_overlap_selec(NULL, 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   NULL, 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   &constval, 1,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   OID_ARRAY_CONTAINS_OP,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   cmpfunc);\n\t\t\telse\n\t\t\t\tselec = mcelem_array_contained_selec(NULL, 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t NULL, 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t &constval, 1,\n\t\t\t\t\t\t\t\t\t\t\t\t\t NULL, 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t OID_ARRAY_CONTAINED_OP,\n\t\t\t\t\t\t\t\t\t\t\t\t\t cmpfunc);\n\t\t}\n\n\t\t/*\n\t\t * MCE stats count only non-null rows, so adjust for null rows.\n\t\t */\n\t\tselec *= (1.0 - stats->stanullfrac);\n\t}\n\telse\n\t{\n\t\t/* No stats at all, so do without */\n\t\tif (useOr)\n\t\t\tselec = mcelem_array_contain_overlap_selec(NULL, 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   NULL, 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   &constval, 1,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   OID_ARRAY_CONTAINS_OP,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   cmpfunc);\n\t\telse\n\t\t\tselec = mcelem_array_contained_selec(NULL, 0,\n\t\t\t\t\t\t\t\t\t\t\t\t NULL, 0,\n\t\t\t\t\t\t\t\t\t\t\t\t &constval, 1,\n\t\t\t\t\t\t\t\t\t\t\t\t NULL, 0,\n\t\t\t\t\t\t\t\t\t\t\t\t OID_ARRAY_CONTAINED_OP,\n\t\t\t\t\t\t\t\t\t\t\t\t cmpfunc);\n\t\t/* we assume no nulls here, so no stanullfrac correction */\n\t}\n\n\tReleaseVariableStats(vardata);\n\n\t/*\n\t * If the operator is <>, invert the results.\n\t */\n\tif (!isEquality)\n\t\tselec = 1.0 - selec;\n\n\tCLAMP_PROBABILITY(selec);\n\n\treturn selec;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/htup_details.h\"",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Selectivity calc_arraycontsel(VariableStatData *vardata, Datum constval,\n\t\t\t\t  Oid elemtype, Oid operator);",
      "static Selectivity mcelem_array_selec(ArrayType *array,\n\t\t\t\t   TypeCacheEntry *typentry,\n\t\t\t\t   Datum *mcelem, int nmcelem,\n\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t   float4 *hist, int nhist,\n\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);",
      "static Selectivity mcelem_array_contain_overlap_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t\t   Datum *array_data, int nitems,\n\t\t\t\t\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);",
      "static Selectivity mcelem_array_contained_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t Datum *array_data, int nitems,\n\t\t\t\t\t\t\t float4 *hist, int nhist,\n\t\t\t\t\t\t\t Oid operator, FmgrInfo *cmpfunc);",
      "static bool find_next_mcelem(Datum *mcelem, int nmcelem, Datum value,\n\t\t\t\t int *index, FmgrInfo *cmpfunc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CLAMP_PROBABILITY",
          "args": [
            "selec"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseVariableStats",
          "args": [
            "vardata"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mcelem_array_contained_selec",
          "args": [
            "NULL",
            "0",
            "NULL",
            "0",
            "&constval",
            "1",
            "NULL",
            "0",
            "OID_ARRAY_CONTAINED_OP",
            "cmpfunc"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "mcelem_array_contained_selec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_selfuncs.c",
          "lines": "697-909",
          "snippet": "static Selectivity\nmcelem_array_contained_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t Datum *array_data, int nitems,\n\t\t\t\t\t\t\t float4 *hist, int nhist,\n\t\t\t\t\t\t\t Oid operator, FmgrInfo *cmpfunc)\n{\n\tint\t\t\tmcelem_index,\n\t\t\t\ti,\n\t\t\t\tunique_nitems = 0;\n\tfloat\t\tselec,\n\t\t\t\tminfreq,\n\t\t\t\tnullelem_freq;\n\tfloat\t   *dist,\n\t\t\t   *mcelem_dist,\n\t\t\t   *hist_part;\n\tfloat\t\tavg_count,\n\t\t\t\tmult,\n\t\t\t\trest;\n\tfloat\t   *elem_selec;\n\n\t/*\n\t * There should be three more Numbers than Values in the MCELEM slot,\n\t * because the last three cells should hold minimal and maximal frequency\n\t * among the non-null elements, and then the frequency of null elements.\n\t * Punt if not right, because we can't do much without the element freqs.\n\t */\n\tif (numbers == NULL || nnumbers != nmcelem + 3)\n\t\treturn DEFAULT_CONTAIN_SEL;\n\n\t/* Can't do much without a count histogram, either */\n\tif (hist == NULL || nhist < 3)\n\t\treturn DEFAULT_CONTAIN_SEL;\n\n\t/*\n\t * Grab some of the summary statistics that compute_array_stats() stores:\n\t * lowest frequency, frequency of null elements, and average distinct\n\t * element count.\n\t */\n\tminfreq = numbers[nmcelem];\n\tnullelem_freq = numbers[nmcelem + 2];\n\tavg_count = hist[nhist - 1];\n\n\t/*\n\t * \"rest\" will be the sum of the frequencies of all elements not\n\t * represented in MCELEM.  The average distinct element count is the sum\n\t * of the frequencies of *all* elements.  Begin with that; we will proceed\n\t * to subtract the MCELEM frequencies.\n\t */\n\trest = avg_count;\n\n\t/*\n\t * mult is a multiplier representing estimate of probability that each\n\t * mcelem that is not present in constant doesn't occur.\n\t */\n\tmult = 1.0f;\n\n\t/*\n\t * elem_selec is array of estimated frequencies for elements in the\n\t * constant.\n\t */\n\telem_selec = (float *) palloc(sizeof(float) * nitems);\n\n\t/* Scan mcelem and array in parallel. */\n\tmcelem_index = 0;\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tbool\t\tmatch = false;\n\n\t\t/* Ignore any duplicates in the array data. */\n\t\tif (i > 0 &&\n\t\t\telement_compare(&array_data[i - 1], &array_data[i], cmpfunc) == 0)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Iterate over MCELEM until we find an entry greater than or equal to\n\t\t * this element of the constant.  Update \"rest\" and \"mult\" for mcelem\n\t\t * entries skipped over.\n\t\t */\n\t\twhile (mcelem_index < nmcelem)\n\t\t{\n\t\t\tint\t\t\tcmp = element_compare(&mcelem[mcelem_index],\n\t\t\t\t\t\t\t\t\t\t\t  &array_data[i],\n\t\t\t\t\t\t\t\t\t\t\t  cmpfunc);\n\n\t\t\tif (cmp < 0)\n\t\t\t{\n\t\t\t\tmult *= (1.0f - numbers[mcelem_index]);\n\t\t\t\trest -= numbers[mcelem_index];\n\t\t\t\tmcelem_index++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (cmp == 0)\n\t\t\t\t\tmatch = true;\t/* mcelem is found */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (match)\n\t\t{\n\t\t\t/* MCELEM matches the array item. */\n\t\t\telem_selec[unique_nitems] = numbers[mcelem_index];\n\t\t\t/* \"rest\" is decremented for all mcelems, matched or not */\n\t\t\trest -= numbers[mcelem_index];\n\t\t\tmcelem_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * The element is not in MCELEM.  Punt, but assume that the\n\t\t\t * selectivity cannot be more than minfreq / 2.\n\t\t\t */\n\t\t\telem_selec[unique_nitems] = Min(DEFAULT_CONTAIN_SEL,\n\t\t\t\t\t\t\t\t\t\t\tminfreq / 2);\n\t\t}\n\n\t\tunique_nitems++;\n\t}\n\n\t/*\n\t * If we handled all constant elements without exhausting the MCELEM\n\t * array, finish walking it to complete calculation of \"rest\" and \"mult\".\n\t */\n\twhile (mcelem_index < nmcelem)\n\t{\n\t\tmult *= (1.0f - numbers[mcelem_index]);\n\t\trest -= numbers[mcelem_index];\n\t\tmcelem_index++;\n\t}\n\n\t/*\n\t * The presence of many distinct rare elements materially decreases\n\t * selectivity.  Use the Poisson distribution to estimate the probability\n\t * of a column value having zero occurrences of such elements.  See above\n\t * for the definition of \"rest\".\n\t */\n\tmult *= exp(-rest);\n\n\t/*----------\n\t * Using the distinct element count histogram requires\n\t *\t\tO(unique_nitems * (nmcelem + unique_nitems))\n\t * operations.  Beyond a certain computational cost threshold, it's\n\t * reasonable to sacrifice accuracy for decreased planning time.  We limit\n\t * the number of operations to EFFORT * nmcelem; since nmcelem is limited\n\t * by the column's statistics target, the work done is user-controllable.\n\t *\n\t * If the number of operations would be too large, we can reduce it\n\t * without losing all accuracy by reducing unique_nitems and considering\n\t * only the most-common elements of the constant array.  To make the\n\t * results exactly match what we would have gotten with only those\n\t * elements to start with, we'd have to remove any discarded elements'\n\t * frequencies from \"mult\", but since this is only an approximation\n\t * anyway, we don't bother with that.  Therefore it's sufficient to qsort\n\t * elem_selec[] and take the largest elements.  (They will no longer match\n\t * up with the elements of array_data[], but we don't care.)\n\t *----------\n\t */\n#define EFFORT 100\n\n\tif ((nmcelem + unique_nitems) > 0 &&\n\t\tunique_nitems > EFFORT * nmcelem / (nmcelem + unique_nitems))\n\t{\n\t\t/*\n\t\t * Use the quadratic formula to solve for largest allowable N.  We\n\t\t * have A = 1, B = nmcelem, C = - EFFORT * nmcelem.\n\t\t */\n\t\tdouble\t\tb = (double) nmcelem;\n\t\tint\t\t\tn;\n\n\t\tn = (int) ((sqrt(b * b + 4 * EFFORT * b) - b) / 2);\n\n\t\t/* Sort, then take just the first n elements */\n\t\tqsort(elem_selec, unique_nitems, sizeof(float),\n\t\t\t  float_compare_desc);\n\t\tunique_nitems = n;\n\t}\n\n\t/*\n\t * Calculate probabilities of each distinct element count for both mcelems\n\t * and constant elements.  At this point, assume independent element\n\t * occurrence.\n\t */\n\tdist = calc_distr(elem_selec, unique_nitems, unique_nitems, 0.0f);\n\tmcelem_dist = calc_distr(numbers, nmcelem, unique_nitems, rest);\n\n\t/* ignore hist[nhist-1], which is the average not a histogram member */\n\thist_part = calc_hist(hist, nhist - 1, unique_nitems);\n\n\tselec = 0.0f;\n\tfor (i = 0; i <= unique_nitems; i++)\n\t{\n\t\t/*\n\t\t * mult * dist[i] / mcelem_dist[i] gives us probability of qual\n\t\t * matching from assumption of independent element occurrence with the\n\t\t * condition that distinct element count = i.\n\t\t */\n\t\tif (mcelem_dist[i] > 0)\n\t\t\tselec += hist_part[i] * mult * dist[i] / mcelem_dist[i];\n\t}\n\n\tpfree(dist);\n\tpfree(mcelem_dist);\n\tpfree(hist_part);\n\tpfree(elem_selec);\n\n\t/* Take into account occurrence of NULL element. */\n\tselec *= (1.0f - nullelem_freq);\n\n\tCLAMP_PROBABILITY(selec);\n\n\treturn selec;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define EFFORT 100",
            "#define DEFAULT_CONTAIN_SEL 0.005"
          ],
          "globals_used": [
            "static Selectivity calc_arraycontsel(VariableStatData *vardata, Datum constval,\n\t\t\t\t  Oid elemtype, Oid operator);",
            "static Selectivity mcelem_array_selec(ArrayType *array,\n\t\t\t\t   TypeCacheEntry *typentry,\n\t\t\t\t   Datum *mcelem, int nmcelem,\n\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t   float4 *hist, int nhist,\n\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);",
            "static Selectivity mcelem_array_contain_overlap_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t\t   Datum *array_data, int nitems,\n\t\t\t\t\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);",
            "static Selectivity mcelem_array_contained_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t Datum *array_data, int nitems,\n\t\t\t\t\t\t\t float4 *hist, int nhist,\n\t\t\t\t\t\t\t Oid operator, FmgrInfo *cmpfunc);",
            "static float *calc_hist(const float4 *hist, int nhist, int n);",
            "static float *calc_distr(const float *p, int n, int m, float rest);",
            "static int\tfloor_log2(uint32 n);",
            "static bool find_next_mcelem(Datum *mcelem, int nmcelem, Datum value,\n\t\t\t\t int *index, FmgrInfo *cmpfunc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/clauses.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\n#define EFFORT 100\n#define DEFAULT_CONTAIN_SEL 0.005\n\nstatic Selectivity calc_arraycontsel(VariableStatData *vardata, Datum constval,\n\t\t\t\t  Oid elemtype, Oid operator);\nstatic Selectivity mcelem_array_selec(ArrayType *array,\n\t\t\t\t   TypeCacheEntry *typentry,\n\t\t\t\t   Datum *mcelem, int nmcelem,\n\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t   float4 *hist, int nhist,\n\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);\nstatic Selectivity mcelem_array_contain_overlap_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t\t   Datum *array_data, int nitems,\n\t\t\t\t\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);\nstatic Selectivity mcelem_array_contained_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t Datum *array_data, int nitems,\n\t\t\t\t\t\t\t float4 *hist, int nhist,\n\t\t\t\t\t\t\t Oid operator, FmgrInfo *cmpfunc);\nstatic float *calc_hist(const float4 *hist, int nhist, int n);\nstatic float *calc_distr(const float *p, int n, int m, float rest);\nstatic int\tfloor_log2(uint32 n);\nstatic bool find_next_mcelem(Datum *mcelem, int nmcelem, Datum value,\n\t\t\t\t int *index, FmgrInfo *cmpfunc);\n\nstatic Selectivity\nmcelem_array_contained_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t Datum *array_data, int nitems,\n\t\t\t\t\t\t\t float4 *hist, int nhist,\n\t\t\t\t\t\t\t Oid operator, FmgrInfo *cmpfunc)\n{\n\tint\t\t\tmcelem_index,\n\t\t\t\ti,\n\t\t\t\tunique_nitems = 0;\n\tfloat\t\tselec,\n\t\t\t\tminfreq,\n\t\t\t\tnullelem_freq;\n\tfloat\t   *dist,\n\t\t\t   *mcelem_dist,\n\t\t\t   *hist_part;\n\tfloat\t\tavg_count,\n\t\t\t\tmult,\n\t\t\t\trest;\n\tfloat\t   *elem_selec;\n\n\t/*\n\t * There should be three more Numbers than Values in the MCELEM slot,\n\t * because the last three cells should hold minimal and maximal frequency\n\t * among the non-null elements, and then the frequency of null elements.\n\t * Punt if not right, because we can't do much without the element freqs.\n\t */\n\tif (numbers == NULL || nnumbers != nmcelem + 3)\n\t\treturn DEFAULT_CONTAIN_SEL;\n\n\t/* Can't do much without a count histogram, either */\n\tif (hist == NULL || nhist < 3)\n\t\treturn DEFAULT_CONTAIN_SEL;\n\n\t/*\n\t * Grab some of the summary statistics that compute_array_stats() stores:\n\t * lowest frequency, frequency of null elements, and average distinct\n\t * element count.\n\t */\n\tminfreq = numbers[nmcelem];\n\tnullelem_freq = numbers[nmcelem + 2];\n\tavg_count = hist[nhist - 1];\n\n\t/*\n\t * \"rest\" will be the sum of the frequencies of all elements not\n\t * represented in MCELEM.  The average distinct element count is the sum\n\t * of the frequencies of *all* elements.  Begin with that; we will proceed\n\t * to subtract the MCELEM frequencies.\n\t */\n\trest = avg_count;\n\n\t/*\n\t * mult is a multiplier representing estimate of probability that each\n\t * mcelem that is not present in constant doesn't occur.\n\t */\n\tmult = 1.0f;\n\n\t/*\n\t * elem_selec is array of estimated frequencies for elements in the\n\t * constant.\n\t */\n\telem_selec = (float *) palloc(sizeof(float) * nitems);\n\n\t/* Scan mcelem and array in parallel. */\n\tmcelem_index = 0;\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tbool\t\tmatch = false;\n\n\t\t/* Ignore any duplicates in the array data. */\n\t\tif (i > 0 &&\n\t\t\telement_compare(&array_data[i - 1], &array_data[i], cmpfunc) == 0)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Iterate over MCELEM until we find an entry greater than or equal to\n\t\t * this element of the constant.  Update \"rest\" and \"mult\" for mcelem\n\t\t * entries skipped over.\n\t\t */\n\t\twhile (mcelem_index < nmcelem)\n\t\t{\n\t\t\tint\t\t\tcmp = element_compare(&mcelem[mcelem_index],\n\t\t\t\t\t\t\t\t\t\t\t  &array_data[i],\n\t\t\t\t\t\t\t\t\t\t\t  cmpfunc);\n\n\t\t\tif (cmp < 0)\n\t\t\t{\n\t\t\t\tmult *= (1.0f - numbers[mcelem_index]);\n\t\t\t\trest -= numbers[mcelem_index];\n\t\t\t\tmcelem_index++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (cmp == 0)\n\t\t\t\t\tmatch = true;\t/* mcelem is found */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (match)\n\t\t{\n\t\t\t/* MCELEM matches the array item. */\n\t\t\telem_selec[unique_nitems] = numbers[mcelem_index];\n\t\t\t/* \"rest\" is decremented for all mcelems, matched or not */\n\t\t\trest -= numbers[mcelem_index];\n\t\t\tmcelem_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * The element is not in MCELEM.  Punt, but assume that the\n\t\t\t * selectivity cannot be more than minfreq / 2.\n\t\t\t */\n\t\t\telem_selec[unique_nitems] = Min(DEFAULT_CONTAIN_SEL,\n\t\t\t\t\t\t\t\t\t\t\tminfreq / 2);\n\t\t}\n\n\t\tunique_nitems++;\n\t}\n\n\t/*\n\t * If we handled all constant elements without exhausting the MCELEM\n\t * array, finish walking it to complete calculation of \"rest\" and \"mult\".\n\t */\n\twhile (mcelem_index < nmcelem)\n\t{\n\t\tmult *= (1.0f - numbers[mcelem_index]);\n\t\trest -= numbers[mcelem_index];\n\t\tmcelem_index++;\n\t}\n\n\t/*\n\t * The presence of many distinct rare elements materially decreases\n\t * selectivity.  Use the Poisson distribution to estimate the probability\n\t * of a column value having zero occurrences of such elements.  See above\n\t * for the definition of \"rest\".\n\t */\n\tmult *= exp(-rest);\n\n\t/*----------\n\t * Using the distinct element count histogram requires\n\t *\t\tO(unique_nitems * (nmcelem + unique_nitems))\n\t * operations.  Beyond a certain computational cost threshold, it's\n\t * reasonable to sacrifice accuracy for decreased planning time.  We limit\n\t * the number of operations to EFFORT * nmcelem; since nmcelem is limited\n\t * by the column's statistics target, the work done is user-controllable.\n\t *\n\t * If the number of operations would be too large, we can reduce it\n\t * without losing all accuracy by reducing unique_nitems and considering\n\t * only the most-common elements of the constant array.  To make the\n\t * results exactly match what we would have gotten with only those\n\t * elements to start with, we'd have to remove any discarded elements'\n\t * frequencies from \"mult\", but since this is only an approximation\n\t * anyway, we don't bother with that.  Therefore it's sufficient to qsort\n\t * elem_selec[] and take the largest elements.  (They will no longer match\n\t * up with the elements of array_data[], but we don't care.)\n\t *----------\n\t */\n#define EFFORT 100\n\n\tif ((nmcelem + unique_nitems) > 0 &&\n\t\tunique_nitems > EFFORT * nmcelem / (nmcelem + unique_nitems))\n\t{\n\t\t/*\n\t\t * Use the quadratic formula to solve for largest allowable N.  We\n\t\t * have A = 1, B = nmcelem, C = - EFFORT * nmcelem.\n\t\t */\n\t\tdouble\t\tb = (double) nmcelem;\n\t\tint\t\t\tn;\n\n\t\tn = (int) ((sqrt(b * b + 4 * EFFORT * b) - b) / 2);\n\n\t\t/* Sort, then take just the first n elements */\n\t\tqsort(elem_selec, unique_nitems, sizeof(float),\n\t\t\t  float_compare_desc);\n\t\tunique_nitems = n;\n\t}\n\n\t/*\n\t * Calculate probabilities of each distinct element count for both mcelems\n\t * and constant elements.  At this point, assume independent element\n\t * occurrence.\n\t */\n\tdist = calc_distr(elem_selec, unique_nitems, unique_nitems, 0.0f);\n\tmcelem_dist = calc_distr(numbers, nmcelem, unique_nitems, rest);\n\n\t/* ignore hist[nhist-1], which is the average not a histogram member */\n\thist_part = calc_hist(hist, nhist - 1, unique_nitems);\n\n\tselec = 0.0f;\n\tfor (i = 0; i <= unique_nitems; i++)\n\t{\n\t\t/*\n\t\t * mult * dist[i] / mcelem_dist[i] gives us probability of qual\n\t\t * matching from assumption of independent element occurrence with the\n\t\t * condition that distinct element count = i.\n\t\t */\n\t\tif (mcelem_dist[i] > 0)\n\t\t\tselec += hist_part[i] * mult * dist[i] / mcelem_dist[i];\n\t}\n\n\tpfree(dist);\n\tpfree(mcelem_dist);\n\tpfree(hist_part);\n\tpfree(elem_selec);\n\n\t/* Take into account occurrence of NULL element. */\n\tselec *= (1.0f - nullelem_freq);\n\n\tCLAMP_PROBABILITY(selec);\n\n\treturn selec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mcelem_array_contain_overlap_selec",
          "args": [
            "NULL",
            "0",
            "NULL",
            "0",
            "&constval",
            "1",
            "OID_ARRAY_CONTAINS_OP",
            "cmpfunc"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "mcelem_array_contain_overlap_selec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_selfuncs.c",
          "lines": "522-646",
          "snippet": "static Selectivity\nmcelem_array_contain_overlap_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t\t   Datum *array_data, int nitems,\n\t\t\t\t\t\t\t\t   Oid operator, FmgrInfo *cmpfunc)\n{\n\tSelectivity selec,\n\t\t\t\telem_selec;\n\tint\t\t\tmcelem_index,\n\t\t\t\ti;\n\tbool\t\tuse_bsearch;\n\tfloat4\t\tminfreq;\n\n\t/*\n\t * There should be three more Numbers than Values, because the last three\n\t * cells should hold minimal and maximal frequency among the non-null\n\t * elements, and then the frequency of null elements.  Ignore the Numbers\n\t * if not right.\n\t */\n\tif (nnumbers != nmcelem + 3)\n\t{\n\t\tnumbers = NULL;\n\t\tnnumbers = 0;\n\t}\n\n\tif (numbers)\n\t{\n\t\t/* Grab the lowest observed frequency */\n\t\tminfreq = numbers[nmcelem];\n\t}\n\telse\n\t{\n\t\t/* Without statistics make some default assumptions */\n\t\tminfreq = 2 * (float4) DEFAULT_CONTAIN_SEL;\n\t}\n\n\t/* Decide whether it is faster to use binary search or not. */\n\tif (nitems * floor_log2((uint32) nmcelem) < nmcelem + nitems)\n\t\tuse_bsearch = true;\n\telse\n\t\tuse_bsearch = false;\n\n\tif (operator == OID_ARRAY_CONTAINS_OP)\n\t{\n\t\t/*\n\t\t * Initial selectivity for \"column @> const\" query is 1.0, and it will\n\t\t * be decreased with each element of constant array.\n\t\t */\n\t\tselec = 1.0;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Initial selectivity for \"column && const\" query is 0.0, and it will\n\t\t * be increased with each element of constant array.\n\t\t */\n\t\tselec = 0.0;\n\t}\n\n\t/* Scan mcelem and array in parallel. */\n\tmcelem_index = 0;\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tbool\t\tmatch = false;\n\n\t\t/* Ignore any duplicates in the array data. */\n\t\tif (i > 0 &&\n\t\t\telement_compare(&array_data[i - 1], &array_data[i], cmpfunc) == 0)\n\t\t\tcontinue;\n\n\t\t/* Find the smallest MCELEM >= this array item. */\n\t\tif (use_bsearch)\n\t\t{\n\t\t\tmatch = find_next_mcelem(mcelem, nmcelem, array_data[i],\n\t\t\t\t\t\t\t\t\t &mcelem_index, cmpfunc);\n\t\t}\n\t\telse\n\t\t{\n\t\t\twhile (mcelem_index < nmcelem)\n\t\t\t{\n\t\t\t\tint\t\t\tcmp = element_compare(&mcelem[mcelem_index],\n\t\t\t\t\t\t\t\t\t\t\t\t  &array_data[i],\n\t\t\t\t\t\t\t\t\t\t\t\t  cmpfunc);\n\n\t\t\t\tif (cmp < 0)\n\t\t\t\t\tmcelem_index++;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (cmp == 0)\n\t\t\t\t\t\tmatch = true;\t/* mcelem is found */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (match && numbers)\n\t\t{\n\t\t\t/* MCELEM matches the array item; use its frequency. */\n\t\t\telem_selec = numbers[mcelem_index];\n\t\t\tmcelem_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * The element is not in MCELEM.  Punt, but assume that the\n\t\t\t * selectivity cannot be more than minfreq / 2.\n\t\t\t */\n\t\t\telem_selec = Min(DEFAULT_CONTAIN_SEL, minfreq / 2);\n\t\t}\n\n\t\t/*\n\t\t * Update overall selectivity using the current element's selectivity\n\t\t * and an assumption of element occurrence independence.\n\t\t */\n\t\tif (operator == OID_ARRAY_CONTAINS_OP)\n\t\t\tselec *= elem_selec;\n\t\telse\n\t\t\tselec = selec + elem_selec - selec * elem_selec;\n\n\t\t/* Clamp intermediate results to stay sane despite roundoff error */\n\t\tCLAMP_PROBABILITY(selec);\n\t}\n\n\treturn selec;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define DEFAULT_CONTAIN_SEL 0.005"
          ],
          "globals_used": [
            "static Selectivity calc_arraycontsel(VariableStatData *vardata, Datum constval,\n\t\t\t\t  Oid elemtype, Oid operator);",
            "static Selectivity mcelem_array_selec(ArrayType *array,\n\t\t\t\t   TypeCacheEntry *typentry,\n\t\t\t\t   Datum *mcelem, int nmcelem,\n\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t   float4 *hist, int nhist,\n\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);",
            "static Selectivity mcelem_array_contain_overlap_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t\t   Datum *array_data, int nitems,\n\t\t\t\t\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);",
            "static Selectivity mcelem_array_contained_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t Datum *array_data, int nitems,\n\t\t\t\t\t\t\t float4 *hist, int nhist,\n\t\t\t\t\t\t\t Oid operator, FmgrInfo *cmpfunc);",
            "static bool find_next_mcelem(Datum *mcelem, int nmcelem, Datum value,\n\t\t\t\t int *index, FmgrInfo *cmpfunc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/clauses.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\n#define DEFAULT_CONTAIN_SEL 0.005\n\nstatic Selectivity calc_arraycontsel(VariableStatData *vardata, Datum constval,\n\t\t\t\t  Oid elemtype, Oid operator);\nstatic Selectivity mcelem_array_selec(ArrayType *array,\n\t\t\t\t   TypeCacheEntry *typentry,\n\t\t\t\t   Datum *mcelem, int nmcelem,\n\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t   float4 *hist, int nhist,\n\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);\nstatic Selectivity mcelem_array_contain_overlap_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t\t   Datum *array_data, int nitems,\n\t\t\t\t\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);\nstatic Selectivity mcelem_array_contained_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t Datum *array_data, int nitems,\n\t\t\t\t\t\t\t float4 *hist, int nhist,\n\t\t\t\t\t\t\t Oid operator, FmgrInfo *cmpfunc);\nstatic bool find_next_mcelem(Datum *mcelem, int nmcelem, Datum value,\n\t\t\t\t int *index, FmgrInfo *cmpfunc);\n\nstatic Selectivity\nmcelem_array_contain_overlap_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t\t   Datum *array_data, int nitems,\n\t\t\t\t\t\t\t\t   Oid operator, FmgrInfo *cmpfunc)\n{\n\tSelectivity selec,\n\t\t\t\telem_selec;\n\tint\t\t\tmcelem_index,\n\t\t\t\ti;\n\tbool\t\tuse_bsearch;\n\tfloat4\t\tminfreq;\n\n\t/*\n\t * There should be three more Numbers than Values, because the last three\n\t * cells should hold minimal and maximal frequency among the non-null\n\t * elements, and then the frequency of null elements.  Ignore the Numbers\n\t * if not right.\n\t */\n\tif (nnumbers != nmcelem + 3)\n\t{\n\t\tnumbers = NULL;\n\t\tnnumbers = 0;\n\t}\n\n\tif (numbers)\n\t{\n\t\t/* Grab the lowest observed frequency */\n\t\tminfreq = numbers[nmcelem];\n\t}\n\telse\n\t{\n\t\t/* Without statistics make some default assumptions */\n\t\tminfreq = 2 * (float4) DEFAULT_CONTAIN_SEL;\n\t}\n\n\t/* Decide whether it is faster to use binary search or not. */\n\tif (nitems * floor_log2((uint32) nmcelem) < nmcelem + nitems)\n\t\tuse_bsearch = true;\n\telse\n\t\tuse_bsearch = false;\n\n\tif (operator == OID_ARRAY_CONTAINS_OP)\n\t{\n\t\t/*\n\t\t * Initial selectivity for \"column @> const\" query is 1.0, and it will\n\t\t * be decreased with each element of constant array.\n\t\t */\n\t\tselec = 1.0;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Initial selectivity for \"column && const\" query is 0.0, and it will\n\t\t * be increased with each element of constant array.\n\t\t */\n\t\tselec = 0.0;\n\t}\n\n\t/* Scan mcelem and array in parallel. */\n\tmcelem_index = 0;\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tbool\t\tmatch = false;\n\n\t\t/* Ignore any duplicates in the array data. */\n\t\tif (i > 0 &&\n\t\t\telement_compare(&array_data[i - 1], &array_data[i], cmpfunc) == 0)\n\t\t\tcontinue;\n\n\t\t/* Find the smallest MCELEM >= this array item. */\n\t\tif (use_bsearch)\n\t\t{\n\t\t\tmatch = find_next_mcelem(mcelem, nmcelem, array_data[i],\n\t\t\t\t\t\t\t\t\t &mcelem_index, cmpfunc);\n\t\t}\n\t\telse\n\t\t{\n\t\t\twhile (mcelem_index < nmcelem)\n\t\t\t{\n\t\t\t\tint\t\t\tcmp = element_compare(&mcelem[mcelem_index],\n\t\t\t\t\t\t\t\t\t\t\t\t  &array_data[i],\n\t\t\t\t\t\t\t\t\t\t\t\t  cmpfunc);\n\n\t\t\t\tif (cmp < 0)\n\t\t\t\t\tmcelem_index++;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (cmp == 0)\n\t\t\t\t\t\tmatch = true;\t/* mcelem is found */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (match && numbers)\n\t\t{\n\t\t\t/* MCELEM matches the array item; use its frequency. */\n\t\t\telem_selec = numbers[mcelem_index];\n\t\t\tmcelem_index++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * The element is not in MCELEM.  Punt, but assume that the\n\t\t\t * selectivity cannot be more than minfreq / 2.\n\t\t\t */\n\t\t\telem_selec = Min(DEFAULT_CONTAIN_SEL, minfreq / 2);\n\t\t}\n\n\t\t/*\n\t\t * Update overall selectivity using the current element's selectivity\n\t\t * and an assumption of element occurrence independence.\n\t\t */\n\t\tif (operator == OID_ARRAY_CONTAINS_OP)\n\t\t\tselec *= elem_selec;\n\t\telse\n\t\t\tselec = selec + elem_selec - selec * elem_selec;\n\n\t\t/* Clamp intermediate results to stay sane despite roundoff error */\n\t\tCLAMP_PROBABILITY(selec);\n\t}\n\n\treturn selec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_attstatsslot",
          "args": [
            "&sslot"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "free_attstatsslot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "3052-3064",
          "snippet": "void\nfree_attstatsslot(AttStatsSlot *sslot)\n{\n\t/* The values[] array was separately palloc'd by deconstruct_array */\n\tif (sslot->values)\n\t\tpfree(sslot->values);\n\t/* The numbers[] array points into numbers_arr, do not pfree it */\n\t/* Free the detoasted array objects, if any */\n\tif (sslot->values_arr)\n\t\tpfree(sslot->values_arr);\n\tif (sslot->numbers_arr)\n\t\tpfree(sslot->numbers_arr);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nfree_attstatsslot(AttStatsSlot *sslot)\n{\n\t/* The values[] array was separately palloc'd by deconstruct_array */\n\tif (sslot->values)\n\t\tpfree(sslot->values);\n\t/* The numbers[] array points into numbers_arr, do not pfree it */\n\t/* Free the detoasted array objects, if any */\n\tif (sslot->values_arr)\n\t\tpfree(sslot->values_arr);\n\tif (sslot->numbers_arr)\n\t\tpfree(sslot->numbers_arr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&hslot",
            "0",
            "sizeof(hslot)"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_attstatsslot",
          "args": [
            "&hslot",
            "vardata.statsTuple",
            "STATISTIC_KIND_DECHIST",
            "InvalidOid",
            "ATTSTATSSLOT_NUMBERS"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "get_attstatsslot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2936-3046",
          "snippet": "bool\nget_attstatsslot(AttStatsSlot *sslot, HeapTuple statstuple,\n\t\t\t\t int reqkind, Oid reqop, int flags)\n{\n\tForm_pg_statistic stats = (Form_pg_statistic) GETSTRUCT(statstuple);\n\tint\t\t\ti;\n\tDatum\t\tval;\n\tbool\t\tisnull;\n\tArrayType  *statarray;\n\tOid\t\t\tarrayelemtype;\n\tint\t\t\tnarrayelem;\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type typeForm;\n\n\t/* initialize *sslot properly */\n\tmemset(sslot, 0, sizeof(AttStatsSlot));\n\n\tfor (i = 0; i < STATISTIC_NUM_SLOTS; i++)\n\t{\n\t\tif ((&stats->stakind1)[i] == reqkind &&\n\t\t\t(reqop == InvalidOid || (&stats->staop1)[i] == reqop))\n\t\t\tbreak;\n\t}\n\tif (i >= STATISTIC_NUM_SLOTS)\n\t\treturn false;\t\t\t/* not there */\n\n\tsslot->staop = (&stats->staop1)[i];\n\n\tif (flags & ATTSTATSSLOT_VALUES)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stavalues1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stavalues is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * Extract the actual array element type, and pass it back in case the\n\t\t * caller needs it.\n\t\t */\n\t\tsslot->valuetype = arrayelemtype = ARR_ELEMTYPE(statarray);\n\n\t\t/* Need info about element type */\n\t\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(arrayelemtype));\n\t\tif (!HeapTupleIsValid(typeTuple))\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", arrayelemtype);\n\t\ttypeForm = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\t\t/* Deconstruct array into Datum elements; NULLs not expected */\n\t\tdeconstruct_array(statarray,\n\t\t\t\t\t\t  arrayelemtype,\n\t\t\t\t\t\t  typeForm->typlen,\n\t\t\t\t\t\t  typeForm->typbyval,\n\t\t\t\t\t\t  typeForm->typalign,\n\t\t\t\t\t\t  &sslot->values, NULL, &sslot->nvalues);\n\n\t\t/*\n\t\t * If the element type is pass-by-reference, we now have a bunch of\n\t\t * Datums that are pointers into the statarray, so we need to keep\n\t\t * that until free_attstatsslot.  Otherwise, all the useful info is in\n\t\t * sslot->values[], so we can free the array object immediately.\n\t\t */\n\t\tif (!typeForm->typbyval)\n\t\t\tsslot->values_arr = statarray;\n\t\telse\n\t\t\tpfree(statarray);\n\n\t\tReleaseSysCache(typeTuple);\n\t}\n\n\tif (flags & ATTSTATSSLOT_NUMBERS)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stanumbers1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stanumbers is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * We expect the array to be a 1-D float4 array; verify that. We don't\n\t\t * need to use deconstruct_array() since the array data is just going\n\t\t * to look like a C array of float4 values.\n\t\t */\n\t\tnarrayelem = ARR_DIMS(statarray)[0];\n\t\tif (ARR_NDIM(statarray) != 1 || narrayelem <= 0 ||\n\t\t\tARR_HASNULL(statarray) ||\n\t\t\tARR_ELEMTYPE(statarray) != FLOAT4OID)\n\t\t\telog(ERROR, \"stanumbers is not a 1-D float4 array\");\n\n\t\t/* Give caller a pointer directly into the statarray */\n\t\tsslot->numbers = (float4 *) ARR_DATA_PTR(statarray);\n\t\tsslot->nnumbers = narrayelem;\n\n\t\t/* We'll free the statarray in free_attstatsslot */\n\t\tsslot->numbers_arr = statarray;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nget_attstatsslot(AttStatsSlot *sslot, HeapTuple statstuple,\n\t\t\t\t int reqkind, Oid reqop, int flags)\n{\n\tForm_pg_statistic stats = (Form_pg_statistic) GETSTRUCT(statstuple);\n\tint\t\t\ti;\n\tDatum\t\tval;\n\tbool\t\tisnull;\n\tArrayType  *statarray;\n\tOid\t\t\tarrayelemtype;\n\tint\t\t\tnarrayelem;\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type typeForm;\n\n\t/* initialize *sslot properly */\n\tmemset(sslot, 0, sizeof(AttStatsSlot));\n\n\tfor (i = 0; i < STATISTIC_NUM_SLOTS; i++)\n\t{\n\t\tif ((&stats->stakind1)[i] == reqkind &&\n\t\t\t(reqop == InvalidOid || (&stats->staop1)[i] == reqop))\n\t\t\tbreak;\n\t}\n\tif (i >= STATISTIC_NUM_SLOTS)\n\t\treturn false;\t\t\t/* not there */\n\n\tsslot->staop = (&stats->staop1)[i];\n\n\tif (flags & ATTSTATSSLOT_VALUES)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stavalues1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stavalues is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * Extract the actual array element type, and pass it back in case the\n\t\t * caller needs it.\n\t\t */\n\t\tsslot->valuetype = arrayelemtype = ARR_ELEMTYPE(statarray);\n\n\t\t/* Need info about element type */\n\t\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(arrayelemtype));\n\t\tif (!HeapTupleIsValid(typeTuple))\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", arrayelemtype);\n\t\ttypeForm = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\t\t/* Deconstruct array into Datum elements; NULLs not expected */\n\t\tdeconstruct_array(statarray,\n\t\t\t\t\t\t  arrayelemtype,\n\t\t\t\t\t\t  typeForm->typlen,\n\t\t\t\t\t\t  typeForm->typbyval,\n\t\t\t\t\t\t  typeForm->typalign,\n\t\t\t\t\t\t  &sslot->values, NULL, &sslot->nvalues);\n\n\t\t/*\n\t\t * If the element type is pass-by-reference, we now have a bunch of\n\t\t * Datums that are pointers into the statarray, so we need to keep\n\t\t * that until free_attstatsslot.  Otherwise, all the useful info is in\n\t\t * sslot->values[], so we can free the array object immediately.\n\t\t */\n\t\tif (!typeForm->typbyval)\n\t\t\tsslot->values_arr = statarray;\n\t\telse\n\t\t\tpfree(statarray);\n\n\t\tReleaseSysCache(typeTuple);\n\t}\n\n\tif (flags & ATTSTATSSLOT_NUMBERS)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stanumbers1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stanumbers is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * We expect the array to be a 1-D float4 array; verify that. We don't\n\t\t * need to use deconstruct_array() since the array data is just going\n\t\t * to look like a C array of float4 values.\n\t\t */\n\t\tnarrayelem = ARR_DIMS(statarray)[0];\n\t\tif (ARR_NDIM(statarray) != 1 || narrayelem <= 0 ||\n\t\t\tARR_HASNULL(statarray) ||\n\t\t\tARR_ELEMTYPE(statarray) != FLOAT4OID)\n\t\t\telog(ERROR, \"stanumbers is not a 1-D float4 array\");\n\n\t\t/* Give caller a pointer directly into the statarray */\n\t\tsslot->numbers = (float4 *) ARR_DATA_PTR(statarray);\n\t\tsslot->nnumbers = narrayelem;\n\n\t\t/* We'll free the statarray in free_attstatsslot */\n\t\tsslot->numbers_arr = statarray;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "vardata.statsTuple"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "statistic_proc_security_check",
          "args": [
            "&vardata",
            "cmpfunc->fn_oid"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "statistic_proc_security_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "5167-5183",
          "snippet": "bool\nstatistic_proc_security_check(VariableStatData *vardata, Oid func_oid)\n{\n\tif (vardata->acl_ok)\n\t\treturn true;\n\n\tif (!OidIsValid(func_oid))\n\t\treturn false;\n\n\tif (get_func_leakproof(func_oid))\n\t\treturn true;\n\n\tereport(DEBUG2,\n\t\t\t(errmsg_internal(\"not using statistics because function \\\"%s\\\" is not leak-proof\",\n\t\t\t\t\t\t\t get_func_name(func_oid))));\n\treturn false;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nbool\nstatistic_proc_security_check(VariableStatData *vardata, Oid func_oid)\n{\n\tif (vardata->acl_ok)\n\t\treturn true;\n\n\tif (!OidIsValid(func_oid))\n\t\treturn false;\n\n\tif (get_func_leakproof(func_oid))\n\t\treturn true;\n\n\tereport(DEBUG2,\n\t\t\t(errmsg_internal(\"not using statistics because function \\\"%s\\\" is not leak-proof\",\n\t\t\t\t\t\t\t get_func_name(func_oid))));\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "vardata.statsTuple"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseVariableStats",
          "args": [
            "vardata"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "typentry->cmp_proc_finfo.fn_oid"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_type_cache",
          "args": [
            "elemtype",
            "TYPECACHE_CMP_PROC_FINFO"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_type_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "320-778",
          "snippet": "TypeCacheEntry *\nlookup_type_cache(Oid type_id, int flags)\n{\n\tTypeCacheEntry *typentry;\n\tbool\t\tfound;\n\n\tif (TypeCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(TypeCacheEntry);\n\t\tTypeCacheHash = hash_create(\"Type information cache\", 64,\n\t\t\t\t\t\t\t\t\t&ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also set up callbacks for SI invalidations */\n\t\tCacheRegisterRelcacheCallback(TypeCacheRelCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CLAOID, TypeCacheOpcCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CONSTROID, TypeCacheConstrCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(TYPEOID, TypeCacheConstrCallback, (Datum) 0);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Try to look up an existing entry */\n\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (typentry == NULL)\n\t{\n\t\t/*\n\t\t * If we didn't find one, we want to make one.  But first look up the\n\t\t * pg_type row, just to make sure we don't make a cache entry for an\n\t\t * invalid type OID.  If the type OID is not valid, present a\n\t\t * user-facing error, since some code paths such as domain_in() allow\n\t\t * this function to be reached with a user-supplied OID.\n\t\t */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_type typtup;\n\n\t\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_id));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type with OID %u does not exist\", type_id)));\n\t\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t\tif (!typtup->typisdefined)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type \\\"%s\\\" is only a shell\",\n\t\t\t\t\t\t\tNameStr(typtup->typname))));\n\n\t\t/* Now make the typcache entry */\n\t\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\t\tAssert(!found);\t\t\t/* it wasn't there a moment ago */\n\n\t\tMemSet(typentry, 0, sizeof(TypeCacheEntry));\n\t\ttypentry->type_id = type_id;\n\t\ttypentry->typlen = typtup->typlen;\n\t\ttypentry->typbyval = typtup->typbyval;\n\t\ttypentry->typalign = typtup->typalign;\n\t\ttypentry->typstorage = typtup->typstorage;\n\t\ttypentry->typtype = typtup->typtype;\n\t\ttypentry->typrelid = typtup->typrelid;\n\t\ttypentry->typelem = typtup->typelem;\n\n\t\t/* If it's a domain, immediately thread it into the domain cache list */\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\ttypentry->nextDomain = firstDomainTypeEntry;\n\t\t\tfirstDomainTypeEntry = typentry;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Look up opclasses if we haven't already and any dependent info is\n\t * requested.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_LT_OPR | TYPECACHE_GT_OPR |\n\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t  TYPECACHE_EQ_OPR_FINFO | TYPECACHE_CMP_PROC_FINFO |\n\t\t\t\t  TYPECACHE_BTREE_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_BTREE_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, BTREE_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->btree_opf = get_opclass_family(opclass);\n\t\t\ttypentry->btree_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->btree_opf = typentry->btree_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from btree opclass.  Note in particular\n\t\t * that we'll redetermine the eq_opr even if we previously found one;\n\t\t * this matters in case a btree opclass has been added to a type that\n\t\t * previously had only a hash opclass.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_EQ_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_LT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_GT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_CMP_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_BTREE_OPCLASS;\n\t}\n\n\t/*\n\t * If we need to look up equality operator, and there's no btree opclass,\n\t * force lookup of hash opclass.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR) &&\n\t\ttypentry->btree_opf == InvalidOid)\n\t\tflags |= TYPECACHE_HASH_OPFAMILY;\n\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, HASH_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->hash_opf = get_opclass_family(opclass);\n\t\t\ttypentry->hash_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->hash_opf = typentry->hash_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from hash opclass.  We do *not* reset the\n\t\t * eq_opr; if we already found one from the btree opclass, that\n\t\t * decision is still good.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_OPCLASS;\n\t}\n\n\t/*\n\t * Look for requested operators and functions, if we haven't already.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR))\n\t{\n\t\tOid\t\t\teq_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\t\tif (eq_opr == InvalidOid &&\n\t\t\ttypentry->hash_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber);\n\n\t\t/*\n\t\t * If the proposed equality operator is array_eq or record_eq, check\n\t\t * to see if the element type or column types support equality.  If\n\t\t * not, array_eq or record_eq would fail at runtime, so we don't want\n\t\t * to report that the type has equality.  (We can omit similar\n\t\t * checking for ranges because ranges can't be created in the first\n\t\t * place unless their subtypes support equality.)\n\t\t */\n\t\tif (eq_opr == ARRAY_EQ_OP &&\n\t\t\t!array_element_has_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\t\telse if (eq_opr == RECORD_EQ_OP &&\n\t\t\t\t !record_fields_have_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\n\t\t/* Force update of eq_opr_finfo only if we're changing state */\n\t\tif (typentry->eq_opr != eq_opr)\n\t\t\ttypentry->eq_opr_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->eq_opr = eq_opr;\n\n\t\t/*\n\t\t * Reset info about hash functions whenever we pick up new info about\n\t\t * equality operator.  This is so we can ensure that the hash\n\t\t * functions match the operator.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_EQ_OPR;\n\t}\n\tif ((flags & TYPECACHE_LT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_LT_OPR))\n\t{\n\t\tOid\t\t\tlt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tlt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (lt_opr == ARRAY_LT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\t\telse if (lt_opr == RECORD_LT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\n\t\ttypentry->lt_opr = lt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_LT_OPR;\n\t}\n\tif ((flags & TYPECACHE_GT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_GT_OPR))\n\t{\n\t\tOid\t\t\tgt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tgt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTGreaterStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (gt_opr == ARRAY_GT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\t\telse if (gt_opr == RECORD_GT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\n\t\ttypentry->gt_opr = gt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_GT_OPR;\n\t}\n\tif ((flags & (TYPECACHE_CMP_PROC | TYPECACHE_CMP_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_CMP_PROC))\n\t{\n\t\tOid\t\t\tcmp_proc = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tcmp_proc = get_opfamily_proc(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (cmp_proc == F_BTARRAYCMP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\t\telse if (cmp_proc == F_BTRECORDCMP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\n\t\t/* Force update of cmp_proc_finfo only if we're changing state */\n\t\tif (typentry->cmp_proc != cmp_proc)\n\t\t\ttypentry->cmp_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->cmp_proc = cmp_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_CMP_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_PROC))\n\t{\n\t\tOid\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  HASHSTANDARD_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array will succeed.  We don't currently\n\t\t * support hashing for composite types, but when we do, we'll need\n\t\t * more logic here to check that case too.\n\t\t */\n\t\tif (hash_proc == F_HASH_ARRAY &&\n\t\t\t!array_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range.\n\t\t */\n\t\tif (hash_proc == F_HASH_RANGE &&\n\t\t\t!range_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/* Force update of hash_proc_finfo only if we're changing state */\n\t\tif (typentry->hash_proc != hash_proc)\n\t\t\ttypentry->hash_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_proc = hash_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_EXTENDED_PROC))\n\t{\n\t\tOid\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_extended_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   HASHEXTENDED_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array_extended will succeed.  We don't\n\t\t * currently support hashing for composite types, but when we do,\n\t\t * we'll need more logic here to check that case too.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_ARRAY_EXTENDED &&\n\t\t\t!array_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range_extended.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_RANGE_EXTENDED &&\n\t\t\t!range_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/* Force update of proc finfo only if we're changing state */\n\t\tif (typentry->hash_extended_proc != hash_extended_proc)\n\t\t\ttypentry->hash_extended_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_extended_proc = hash_extended_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_EXTENDED_PROC;\n\t}\n\n\t/*\n\t * Set up fmgr lookup info as requested\n\t *\n\t * Note: we tell fmgr the finfo structures live in CacheMemoryContext,\n\t * which is not quite right (they're really in the hash table's private\n\t * memory context) but this will do for our purposes.\n\t *\n\t * Note: the code above avoids invalidating the finfo structs unless the\n\t * referenced operator/function OID actually changes.  This is to prevent\n\t * unnecessary leakage of any subsidiary data attached to an finfo, since\n\t * that would cause session-lifespan memory leaks.\n\t */\n\tif ((flags & TYPECACHE_EQ_OPR_FINFO) &&\n\t\ttypentry->eq_opr_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->eq_opr != InvalidOid)\n\t{\n\t\tOid\t\t\teq_opr_func;\n\n\t\teq_opr_func = get_opcode(typentry->eq_opr);\n\t\tif (eq_opr_func != InvalidOid)\n\t\t\tfmgr_info_cxt(eq_opr_func, &typentry->eq_opr_finfo,\n\t\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_CMP_PROC_FINFO) &&\n\t\ttypentry->cmp_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->cmp_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->cmp_proc, &typentry->cmp_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_PROC_FINFO) &&\n\t\ttypentry->hash_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_proc, &typentry->hash_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_EXTENDED_PROC_FINFO) &&\n\t\ttypentry->hash_extended_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_extended_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_extended_proc,\n\t\t\t\t\t  &typentry->hash_extended_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\n\t/*\n\t * If it's a composite type (row type), get tupdesc if requested\n\t */\n\tif ((flags & TYPECACHE_TUPDESC) &&\n\t\ttypentry->tupDesc == NULL &&\n\t\ttypentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tload_typcache_tupdesc(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a range type\n\t */\n\tif ((flags & TYPECACHE_RANGE_INFO) &&\n\t\ttypentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t{\n\t\tload_rangetype_info(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a domain type\n\t */\n\tif ((flags & TYPECACHE_DOMAIN_BASE_INFO) &&\n\t\ttypentry->domainBaseType == InvalidOid &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\ttypentry->domainBaseTypmod = -1;\n\t\ttypentry->domainBaseType =\n\t\t\tgetBaseTypeAndTypmod(type_id, &typentry->domainBaseTypmod);\n\t}\n\tif ((flags & TYPECACHE_DOMAIN_CONSTR_INFO) &&\n\t\t(typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\tload_domaintype_info(typentry);\n\t}\n\n\treturn typentry;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000",
            "#define TCFLAGS_CHECKED_HASH_EXTENDED_PROC\t0x000080",
            "#define TCFLAGS_CHECKED_HASH_PROC\t\t\t0x000040",
            "#define TCFLAGS_CHECKED_CMP_PROC\t\t\t0x000020",
            "#define TCFLAGS_CHECKED_GT_OPR\t\t\t\t0x000010",
            "#define TCFLAGS_CHECKED_LT_OPR\t\t\t\t0x000008",
            "#define TCFLAGS_CHECKED_EQ_OPR\t\t\t\t0x000004",
            "#define TCFLAGS_CHECKED_HASH_OPCLASS\t\t0x000002",
            "#define TCFLAGS_CHECKED_BTREE_OPCLASS\t\t0x000001"
          ],
          "globals_used": [
            "static HTAB *TypeCacheHash = NULL;",
            "static TypeCacheEntry *firstDomainTypeEntry = NULL;",
            "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
            "static void load_rangetype_info(TypeCacheEntry *typentry);",
            "static void load_domaintype_info(TypeCacheEntry *typentry);",
            "static bool array_element_has_equality(TypeCacheEntry *typentry);",
            "static bool array_element_has_compare(TypeCacheEntry *typentry);",
            "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_array_element_properties(TypeCacheEntry *typentry);",
            "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
            "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
            "static void cache_record_field_properties(TypeCacheEntry *typentry);",
            "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_range_element_properties(TypeCacheEntry *typentry);",
            "static int\tenum_oid_cmp(const void *left, const void *right);",
            "static TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000\n#define TCFLAGS_CHECKED_HASH_EXTENDED_PROC\t0x000080\n#define TCFLAGS_CHECKED_HASH_PROC\t\t\t0x000040\n#define TCFLAGS_CHECKED_CMP_PROC\t\t\t0x000020\n#define TCFLAGS_CHECKED_GT_OPR\t\t\t\t0x000010\n#define TCFLAGS_CHECKED_LT_OPR\t\t\t\t0x000008\n#define TCFLAGS_CHECKED_EQ_OPR\t\t\t\t0x000004\n#define TCFLAGS_CHECKED_HASH_OPCLASS\t\t0x000002\n#define TCFLAGS_CHECKED_BTREE_OPCLASS\t\t0x000001\n\nstatic HTAB *TypeCacheHash = NULL;\nstatic TypeCacheEntry *firstDomainTypeEntry = NULL;\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\nstatic int\tenum_oid_cmp(const void *left, const void *right);\nstatic TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);\n\nTypeCacheEntry *\nlookup_type_cache(Oid type_id, int flags)\n{\n\tTypeCacheEntry *typentry;\n\tbool\t\tfound;\n\n\tif (TypeCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(TypeCacheEntry);\n\t\tTypeCacheHash = hash_create(\"Type information cache\", 64,\n\t\t\t\t\t\t\t\t\t&ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also set up callbacks for SI invalidations */\n\t\tCacheRegisterRelcacheCallback(TypeCacheRelCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CLAOID, TypeCacheOpcCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CONSTROID, TypeCacheConstrCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(TYPEOID, TypeCacheConstrCallback, (Datum) 0);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Try to look up an existing entry */\n\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (typentry == NULL)\n\t{\n\t\t/*\n\t\t * If we didn't find one, we want to make one.  But first look up the\n\t\t * pg_type row, just to make sure we don't make a cache entry for an\n\t\t * invalid type OID.  If the type OID is not valid, present a\n\t\t * user-facing error, since some code paths such as domain_in() allow\n\t\t * this function to be reached with a user-supplied OID.\n\t\t */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_type typtup;\n\n\t\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_id));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type with OID %u does not exist\", type_id)));\n\t\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t\tif (!typtup->typisdefined)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type \\\"%s\\\" is only a shell\",\n\t\t\t\t\t\t\tNameStr(typtup->typname))));\n\n\t\t/* Now make the typcache entry */\n\t\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\t\tAssert(!found);\t\t\t/* it wasn't there a moment ago */\n\n\t\tMemSet(typentry, 0, sizeof(TypeCacheEntry));\n\t\ttypentry->type_id = type_id;\n\t\ttypentry->typlen = typtup->typlen;\n\t\ttypentry->typbyval = typtup->typbyval;\n\t\ttypentry->typalign = typtup->typalign;\n\t\ttypentry->typstorage = typtup->typstorage;\n\t\ttypentry->typtype = typtup->typtype;\n\t\ttypentry->typrelid = typtup->typrelid;\n\t\ttypentry->typelem = typtup->typelem;\n\n\t\t/* If it's a domain, immediately thread it into the domain cache list */\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\ttypentry->nextDomain = firstDomainTypeEntry;\n\t\t\tfirstDomainTypeEntry = typentry;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Look up opclasses if we haven't already and any dependent info is\n\t * requested.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_LT_OPR | TYPECACHE_GT_OPR |\n\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t  TYPECACHE_EQ_OPR_FINFO | TYPECACHE_CMP_PROC_FINFO |\n\t\t\t\t  TYPECACHE_BTREE_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_BTREE_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, BTREE_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->btree_opf = get_opclass_family(opclass);\n\t\t\ttypentry->btree_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->btree_opf = typentry->btree_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from btree opclass.  Note in particular\n\t\t * that we'll redetermine the eq_opr even if we previously found one;\n\t\t * this matters in case a btree opclass has been added to a type that\n\t\t * previously had only a hash opclass.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_EQ_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_LT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_GT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_CMP_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_BTREE_OPCLASS;\n\t}\n\n\t/*\n\t * If we need to look up equality operator, and there's no btree opclass,\n\t * force lookup of hash opclass.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR) &&\n\t\ttypentry->btree_opf == InvalidOid)\n\t\tflags |= TYPECACHE_HASH_OPFAMILY;\n\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, HASH_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->hash_opf = get_opclass_family(opclass);\n\t\t\ttypentry->hash_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->hash_opf = typentry->hash_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from hash opclass.  We do *not* reset the\n\t\t * eq_opr; if we already found one from the btree opclass, that\n\t\t * decision is still good.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_OPCLASS;\n\t}\n\n\t/*\n\t * Look for requested operators and functions, if we haven't already.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR))\n\t{\n\t\tOid\t\t\teq_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\t\tif (eq_opr == InvalidOid &&\n\t\t\ttypentry->hash_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber);\n\n\t\t/*\n\t\t * If the proposed equality operator is array_eq or record_eq, check\n\t\t * to see if the element type or column types support equality.  If\n\t\t * not, array_eq or record_eq would fail at runtime, so we don't want\n\t\t * to report that the type has equality.  (We can omit similar\n\t\t * checking for ranges because ranges can't be created in the first\n\t\t * place unless their subtypes support equality.)\n\t\t */\n\t\tif (eq_opr == ARRAY_EQ_OP &&\n\t\t\t!array_element_has_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\t\telse if (eq_opr == RECORD_EQ_OP &&\n\t\t\t\t !record_fields_have_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\n\t\t/* Force update of eq_opr_finfo only if we're changing state */\n\t\tif (typentry->eq_opr != eq_opr)\n\t\t\ttypentry->eq_opr_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->eq_opr = eq_opr;\n\n\t\t/*\n\t\t * Reset info about hash functions whenever we pick up new info about\n\t\t * equality operator.  This is so we can ensure that the hash\n\t\t * functions match the operator.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_EQ_OPR;\n\t}\n\tif ((flags & TYPECACHE_LT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_LT_OPR))\n\t{\n\t\tOid\t\t\tlt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tlt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (lt_opr == ARRAY_LT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\t\telse if (lt_opr == RECORD_LT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\n\t\ttypentry->lt_opr = lt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_LT_OPR;\n\t}\n\tif ((flags & TYPECACHE_GT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_GT_OPR))\n\t{\n\t\tOid\t\t\tgt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tgt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTGreaterStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (gt_opr == ARRAY_GT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\t\telse if (gt_opr == RECORD_GT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\n\t\ttypentry->gt_opr = gt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_GT_OPR;\n\t}\n\tif ((flags & (TYPECACHE_CMP_PROC | TYPECACHE_CMP_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_CMP_PROC))\n\t{\n\t\tOid\t\t\tcmp_proc = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tcmp_proc = get_opfamily_proc(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (cmp_proc == F_BTARRAYCMP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\t\telse if (cmp_proc == F_BTRECORDCMP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\n\t\t/* Force update of cmp_proc_finfo only if we're changing state */\n\t\tif (typentry->cmp_proc != cmp_proc)\n\t\t\ttypentry->cmp_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->cmp_proc = cmp_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_CMP_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_PROC))\n\t{\n\t\tOid\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  HASHSTANDARD_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array will succeed.  We don't currently\n\t\t * support hashing for composite types, but when we do, we'll need\n\t\t * more logic here to check that case too.\n\t\t */\n\t\tif (hash_proc == F_HASH_ARRAY &&\n\t\t\t!array_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range.\n\t\t */\n\t\tif (hash_proc == F_HASH_RANGE &&\n\t\t\t!range_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/* Force update of hash_proc_finfo only if we're changing state */\n\t\tif (typentry->hash_proc != hash_proc)\n\t\t\ttypentry->hash_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_proc = hash_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_EXTENDED_PROC))\n\t{\n\t\tOid\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_extended_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   HASHEXTENDED_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array_extended will succeed.  We don't\n\t\t * currently support hashing for composite types, but when we do,\n\t\t * we'll need more logic here to check that case too.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_ARRAY_EXTENDED &&\n\t\t\t!array_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range_extended.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_RANGE_EXTENDED &&\n\t\t\t!range_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/* Force update of proc finfo only if we're changing state */\n\t\tif (typentry->hash_extended_proc != hash_extended_proc)\n\t\t\ttypentry->hash_extended_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_extended_proc = hash_extended_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_EXTENDED_PROC;\n\t}\n\n\t/*\n\t * Set up fmgr lookup info as requested\n\t *\n\t * Note: we tell fmgr the finfo structures live in CacheMemoryContext,\n\t * which is not quite right (they're really in the hash table's private\n\t * memory context) but this will do for our purposes.\n\t *\n\t * Note: the code above avoids invalidating the finfo structs unless the\n\t * referenced operator/function OID actually changes.  This is to prevent\n\t * unnecessary leakage of any subsidiary data attached to an finfo, since\n\t * that would cause session-lifespan memory leaks.\n\t */\n\tif ((flags & TYPECACHE_EQ_OPR_FINFO) &&\n\t\ttypentry->eq_opr_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->eq_opr != InvalidOid)\n\t{\n\t\tOid\t\t\teq_opr_func;\n\n\t\teq_opr_func = get_opcode(typentry->eq_opr);\n\t\tif (eq_opr_func != InvalidOid)\n\t\t\tfmgr_info_cxt(eq_opr_func, &typentry->eq_opr_finfo,\n\t\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_CMP_PROC_FINFO) &&\n\t\ttypentry->cmp_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->cmp_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->cmp_proc, &typentry->cmp_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_PROC_FINFO) &&\n\t\ttypentry->hash_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_proc, &typentry->hash_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_EXTENDED_PROC_FINFO) &&\n\t\ttypentry->hash_extended_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_extended_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_extended_proc,\n\t\t\t\t\t  &typentry->hash_extended_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\n\t/*\n\t * If it's a composite type (row type), get tupdesc if requested\n\t */\n\tif ((flags & TYPECACHE_TUPDESC) &&\n\t\ttypentry->tupDesc == NULL &&\n\t\ttypentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tload_typcache_tupdesc(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a range type\n\t */\n\tif ((flags & TYPECACHE_RANGE_INFO) &&\n\t\ttypentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t{\n\t\tload_rangetype_info(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a domain type\n\t */\n\tif ((flags & TYPECACHE_DOMAIN_BASE_INFO) &&\n\t\ttypentry->domainBaseType == InvalidOid &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\ttypentry->domainBaseTypmod = -1;\n\t\ttypentry->domainBaseType =\n\t\t\tgetBaseTypeAndTypmod(type_id, &typentry->domainBaseTypmod);\n\t}\n\tif ((flags & TYPECACHE_DOMAIN_CONSTR_INFO) &&\n\t\t(typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\tload_domaintype_info(typentry);\n\t}\n\n\treturn typentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ReleaseVariableStats",
          "args": [
            "vardata"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseVariableStats",
          "args": [
            "vardata"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "leftop",
            "Const"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseVariableStats",
          "args": [
            "vardata"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "examine_variable",
          "args": [
            "root",
            "rightop",
            "varRelid",
            "&vardata"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "examine_variable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "4775-4984",
          "snippet": "void\nexamine_variable(PlannerInfo *root, Node *node, int varRelid,\n\t\t\t\t VariableStatData *vardata)\n{\n\tNode\t   *basenode;\n\tRelids\t\tvarnos;\n\tRelOptInfo *onerel;\n\n\t/* Make sure we don't return dangling pointers in vardata */\n\tMemSet(vardata, 0, sizeof(VariableStatData));\n\n\t/* Save the exposed type of the expression */\n\tvardata->vartype = exprType(node);\n\n\t/* Look inside any binary-compatible relabeling */\n\n\tif (IsA(node, RelabelType))\n\t\tbasenode = (Node *) ((RelabelType *) node)->arg;\n\telse\n\t\tbasenode = node;\n\n\t/* Fast path for a simple Var */\n\n\tif (IsA(basenode, Var) &&\n\t\t(varRelid == 0 || varRelid == ((Var *) basenode)->varno))\n\t{\n\t\tVar\t\t   *var = (Var *) basenode;\n\n\t\t/* Set up result fields other than the stats tuple */\n\t\tvardata->var = basenode;\t/* return Var without relabeling */\n\t\tvardata->rel = find_base_rel(root, var->varno);\n\t\tvardata->atttype = var->vartype;\n\t\tvardata->atttypmod = var->vartypmod;\n\t\tvardata->isunique = has_unique_index(vardata->rel, var->varattno);\n\n\t\t/* Try to locate some stats */\n\t\texamine_simple_variable(root, var, vardata);\n\n\t\treturn;\n\t}\n\n\t/*\n\t * Okay, it's a more complicated expression.  Determine variable\n\t * membership.  Note that when varRelid isn't zero, only vars of that\n\t * relation are considered \"real\" vars.\n\t */\n\tvarnos = pull_varnos(basenode);\n\n\tonerel = NULL;\n\n\tswitch (bms_membership(varnos))\n\t{\n\t\tcase BMS_EMPTY_SET:\n\t\t\t/* No Vars at all ... must be pseudo-constant clause */\n\t\t\tbreak;\n\t\tcase BMS_SINGLETON:\n\t\t\tif (varRelid == 0 || bms_is_member(varRelid, varnos))\n\t\t\t{\n\t\t\t\tonerel = find_base_rel(root,\n\t\t\t\t\t\t\t\t\t   (varRelid ? varRelid : bms_singleton_member(varnos)));\n\t\t\t\tvardata->rel = onerel;\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t}\n\t\t\t/* else treat it as a constant */\n\t\t\tbreak;\n\t\tcase BMS_MULTIPLE:\n\t\t\tif (varRelid == 0)\n\t\t\t{\n\t\t\t\t/* treat it as a variable of a join relation */\n\t\t\t\tvardata->rel = find_join_rel(root, varnos);\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t}\n\t\t\telse if (bms_is_member(varRelid, varnos))\n\t\t\t{\n\t\t\t\t/* ignore the vars belonging to other relations */\n\t\t\t\tvardata->rel = find_base_rel(root, varRelid);\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t\t/* note: no point in expressional-index search here */\n\t\t\t}\n\t\t\t/* else treat it as a constant */\n\t\t\tbreak;\n\t}\n\n\tbms_free(varnos);\n\n\tvardata->var = node;\n\tvardata->atttype = exprType(node);\n\tvardata->atttypmod = exprTypmod(node);\n\n\tif (onerel)\n\t{\n\t\t/*\n\t\t * We have an expression in vars of a single relation.  Try to match\n\t\t * it to expressional index columns, in hopes of finding some\n\t\t * statistics.\n\t\t *\n\t\t * Note that we consider all index columns including INCLUDE columns,\n\t\t * since there could be stats for such columns.  But the test for\n\t\t * uniqueness needs to be warier.\n\t\t *\n\t\t * XXX it's conceivable that there are multiple matches with different\n\t\t * index opfamilies; if so, we need to pick one that matches the\n\t\t * operator we are estimating for.  FIXME later.\n\t\t */\n\t\tListCell   *ilist;\n\n\t\tforeach(ilist, onerel->indexlist)\n\t\t{\n\t\t\tIndexOptInfo *index = (IndexOptInfo *) lfirst(ilist);\n\t\t\tListCell   *indexpr_item;\n\t\t\tint\t\t\tpos;\n\n\t\t\tindexpr_item = list_head(index->indexprs);\n\t\t\tif (indexpr_item == NULL)\n\t\t\t\tcontinue;\t\t/* no expressions here... */\n\n\t\t\tfor (pos = 0; pos < index->ncolumns; pos++)\n\t\t\t{\n\t\t\t\tif (index->indexkeys[pos] == 0)\n\t\t\t\t{\n\t\t\t\t\tNode\t   *indexkey;\n\n\t\t\t\t\tif (indexpr_item == NULL)\n\t\t\t\t\t\telog(ERROR, \"too few entries in indexprs list\");\n\t\t\t\t\tindexkey = (Node *) lfirst(indexpr_item);\n\t\t\t\t\tif (indexkey && IsA(indexkey, RelabelType))\n\t\t\t\t\t\tindexkey = (Node *) ((RelabelType *) indexkey)->arg;\n\t\t\t\t\tif (equal(node, indexkey))\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Found a match ... is it a unique index? Tests here\n\t\t\t\t\t\t * should match has_unique_index().\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (index->unique &&\n\t\t\t\t\t\t\tindex->nkeycolumns == 1 &&\n\t\t\t\t\t\t\tpos == 0 &&\n\t\t\t\t\t\t\t(index->indpred == NIL || index->predOK))\n\t\t\t\t\t\t\tvardata->isunique = true;\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Has it got stats?  We only consider stats for\n\t\t\t\t\t\t * non-partial indexes, since partial indexes probably\n\t\t\t\t\t\t * don't reflect whole-relation statistics; the above\n\t\t\t\t\t\t * check for uniqueness is the only info we take from\n\t\t\t\t\t\t * a partial index.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * An index stats hook, however, must make its own\n\t\t\t\t\t\t * decisions about what to do with partial indexes.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (get_index_stats_hook &&\n\t\t\t\t\t\t\t(*get_index_stats_hook) (root, index->indexoid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t pos + 1, vardata))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * The hook took control of acquiring a stats\n\t\t\t\t\t\t\t * tuple.  If it did supply a tuple, it'd better\n\t\t\t\t\t\t\t * have supplied a freefunc.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tif (HeapTupleIsValid(vardata->statsTuple) &&\n\t\t\t\t\t\t\t\t!vardata->freefunc)\n\t\t\t\t\t\t\t\telog(ERROR, \"no function provided to release variable stats with\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (index->indpred == NIL)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvardata->statsTuple =\n\t\t\t\t\t\t\t\tSearchSysCache3(STATRELATTINH,\n\t\t\t\t\t\t\t\t\t\t\t\tObjectIdGetDatum(index->indexoid),\n\t\t\t\t\t\t\t\t\t\t\t\tInt16GetDatum(pos + 1),\n\t\t\t\t\t\t\t\t\t\t\t\tBoolGetDatum(false));\n\t\t\t\t\t\t\tvardata->freefunc = ReleaseSysCache;\n\n\t\t\t\t\t\t\tif (HeapTupleIsValid(vardata->statsTuple))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/* Get index's table for permission check */\n\t\t\t\t\t\t\t\tRangeTblEntry *rte;\n\n\t\t\t\t\t\t\t\trte = planner_rt_fetch(index->rel->relid, root);\n\t\t\t\t\t\t\t\tAssert(rte->rtekind == RTE_RELATION);\n\n\t\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\t * For simplicity, we insist on the whole\n\t\t\t\t\t\t\t\t * table being selectable, rather than trying\n\t\t\t\t\t\t\t\t * to identify which column(s) the index\n\t\t\t\t\t\t\t\t * depends on.  Also require all rows to be\n\t\t\t\t\t\t\t\t * selectable --- there must be no\n\t\t\t\t\t\t\t\t * securityQuals from security barrier views\n\t\t\t\t\t\t\t\t * or RLS policies.\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tvardata->acl_ok =\n\t\t\t\t\t\t\t\t\trte->securityQuals == NIL &&\n\t\t\t\t\t\t\t\t\t(pg_class_aclcheck(rte->relid, GetUserId(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t   ACL_SELECT) == ACLCHECK_OK);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/* suppress leakproofness checks later */\n\t\t\t\t\t\t\t\tvardata->acl_ok = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (vardata->statsTuple)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tindexpr_item = lnext(indexpr_item);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (vardata->statsTuple)\n\t\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "get_index_stats_hook_type get_index_stats_hook = NULL;",
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nget_index_stats_hook_type get_index_stats_hook = NULL;\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nvoid\nexamine_variable(PlannerInfo *root, Node *node, int varRelid,\n\t\t\t\t VariableStatData *vardata)\n{\n\tNode\t   *basenode;\n\tRelids\t\tvarnos;\n\tRelOptInfo *onerel;\n\n\t/* Make sure we don't return dangling pointers in vardata */\n\tMemSet(vardata, 0, sizeof(VariableStatData));\n\n\t/* Save the exposed type of the expression */\n\tvardata->vartype = exprType(node);\n\n\t/* Look inside any binary-compatible relabeling */\n\n\tif (IsA(node, RelabelType))\n\t\tbasenode = (Node *) ((RelabelType *) node)->arg;\n\telse\n\t\tbasenode = node;\n\n\t/* Fast path for a simple Var */\n\n\tif (IsA(basenode, Var) &&\n\t\t(varRelid == 0 || varRelid == ((Var *) basenode)->varno))\n\t{\n\t\tVar\t\t   *var = (Var *) basenode;\n\n\t\t/* Set up result fields other than the stats tuple */\n\t\tvardata->var = basenode;\t/* return Var without relabeling */\n\t\tvardata->rel = find_base_rel(root, var->varno);\n\t\tvardata->atttype = var->vartype;\n\t\tvardata->atttypmod = var->vartypmod;\n\t\tvardata->isunique = has_unique_index(vardata->rel, var->varattno);\n\n\t\t/* Try to locate some stats */\n\t\texamine_simple_variable(root, var, vardata);\n\n\t\treturn;\n\t}\n\n\t/*\n\t * Okay, it's a more complicated expression.  Determine variable\n\t * membership.  Note that when varRelid isn't zero, only vars of that\n\t * relation are considered \"real\" vars.\n\t */\n\tvarnos = pull_varnos(basenode);\n\n\tonerel = NULL;\n\n\tswitch (bms_membership(varnos))\n\t{\n\t\tcase BMS_EMPTY_SET:\n\t\t\t/* No Vars at all ... must be pseudo-constant clause */\n\t\t\tbreak;\n\t\tcase BMS_SINGLETON:\n\t\t\tif (varRelid == 0 || bms_is_member(varRelid, varnos))\n\t\t\t{\n\t\t\t\tonerel = find_base_rel(root,\n\t\t\t\t\t\t\t\t\t   (varRelid ? varRelid : bms_singleton_member(varnos)));\n\t\t\t\tvardata->rel = onerel;\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t}\n\t\t\t/* else treat it as a constant */\n\t\t\tbreak;\n\t\tcase BMS_MULTIPLE:\n\t\t\tif (varRelid == 0)\n\t\t\t{\n\t\t\t\t/* treat it as a variable of a join relation */\n\t\t\t\tvardata->rel = find_join_rel(root, varnos);\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t}\n\t\t\telse if (bms_is_member(varRelid, varnos))\n\t\t\t{\n\t\t\t\t/* ignore the vars belonging to other relations */\n\t\t\t\tvardata->rel = find_base_rel(root, varRelid);\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t\t/* note: no point in expressional-index search here */\n\t\t\t}\n\t\t\t/* else treat it as a constant */\n\t\t\tbreak;\n\t}\n\n\tbms_free(varnos);\n\n\tvardata->var = node;\n\tvardata->atttype = exprType(node);\n\tvardata->atttypmod = exprTypmod(node);\n\n\tif (onerel)\n\t{\n\t\t/*\n\t\t * We have an expression in vars of a single relation.  Try to match\n\t\t * it to expressional index columns, in hopes of finding some\n\t\t * statistics.\n\t\t *\n\t\t * Note that we consider all index columns including INCLUDE columns,\n\t\t * since there could be stats for such columns.  But the test for\n\t\t * uniqueness needs to be warier.\n\t\t *\n\t\t * XXX it's conceivable that there are multiple matches with different\n\t\t * index opfamilies; if so, we need to pick one that matches the\n\t\t * operator we are estimating for.  FIXME later.\n\t\t */\n\t\tListCell   *ilist;\n\n\t\tforeach(ilist, onerel->indexlist)\n\t\t{\n\t\t\tIndexOptInfo *index = (IndexOptInfo *) lfirst(ilist);\n\t\t\tListCell   *indexpr_item;\n\t\t\tint\t\t\tpos;\n\n\t\t\tindexpr_item = list_head(index->indexprs);\n\t\t\tif (indexpr_item == NULL)\n\t\t\t\tcontinue;\t\t/* no expressions here... */\n\n\t\t\tfor (pos = 0; pos < index->ncolumns; pos++)\n\t\t\t{\n\t\t\t\tif (index->indexkeys[pos] == 0)\n\t\t\t\t{\n\t\t\t\t\tNode\t   *indexkey;\n\n\t\t\t\t\tif (indexpr_item == NULL)\n\t\t\t\t\t\telog(ERROR, \"too few entries in indexprs list\");\n\t\t\t\t\tindexkey = (Node *) lfirst(indexpr_item);\n\t\t\t\t\tif (indexkey && IsA(indexkey, RelabelType))\n\t\t\t\t\t\tindexkey = (Node *) ((RelabelType *) indexkey)->arg;\n\t\t\t\t\tif (equal(node, indexkey))\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Found a match ... is it a unique index? Tests here\n\t\t\t\t\t\t * should match has_unique_index().\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (index->unique &&\n\t\t\t\t\t\t\tindex->nkeycolumns == 1 &&\n\t\t\t\t\t\t\tpos == 0 &&\n\t\t\t\t\t\t\t(index->indpred == NIL || index->predOK))\n\t\t\t\t\t\t\tvardata->isunique = true;\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Has it got stats?  We only consider stats for\n\t\t\t\t\t\t * non-partial indexes, since partial indexes probably\n\t\t\t\t\t\t * don't reflect whole-relation statistics; the above\n\t\t\t\t\t\t * check for uniqueness is the only info we take from\n\t\t\t\t\t\t * a partial index.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * An index stats hook, however, must make its own\n\t\t\t\t\t\t * decisions about what to do with partial indexes.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (get_index_stats_hook &&\n\t\t\t\t\t\t\t(*get_index_stats_hook) (root, index->indexoid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t pos + 1, vardata))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * The hook took control of acquiring a stats\n\t\t\t\t\t\t\t * tuple.  If it did supply a tuple, it'd better\n\t\t\t\t\t\t\t * have supplied a freefunc.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tif (HeapTupleIsValid(vardata->statsTuple) &&\n\t\t\t\t\t\t\t\t!vardata->freefunc)\n\t\t\t\t\t\t\t\telog(ERROR, \"no function provided to release variable stats with\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (index->indpred == NIL)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvardata->statsTuple =\n\t\t\t\t\t\t\t\tSearchSysCache3(STATRELATTINH,\n\t\t\t\t\t\t\t\t\t\t\t\tObjectIdGetDatum(index->indexoid),\n\t\t\t\t\t\t\t\t\t\t\t\tInt16GetDatum(pos + 1),\n\t\t\t\t\t\t\t\t\t\t\t\tBoolGetDatum(false));\n\t\t\t\t\t\t\tvardata->freefunc = ReleaseSysCache;\n\n\t\t\t\t\t\t\tif (HeapTupleIsValid(vardata->statsTuple))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/* Get index's table for permission check */\n\t\t\t\t\t\t\t\tRangeTblEntry *rte;\n\n\t\t\t\t\t\t\t\trte = planner_rt_fetch(index->rel->relid, root);\n\t\t\t\t\t\t\t\tAssert(rte->rtekind == RTE_RELATION);\n\n\t\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\t * For simplicity, we insist on the whole\n\t\t\t\t\t\t\t\t * table being selectable, rather than trying\n\t\t\t\t\t\t\t\t * to identify which column(s) the index\n\t\t\t\t\t\t\t\t * depends on.  Also require all rows to be\n\t\t\t\t\t\t\t\t * selectable --- there must be no\n\t\t\t\t\t\t\t\t * securityQuals from security barrier views\n\t\t\t\t\t\t\t\t * or RLS policies.\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tvardata->acl_ok =\n\t\t\t\t\t\t\t\t\trte->securityQuals == NIL &&\n\t\t\t\t\t\t\t\t\t(pg_class_aclcheck(rte->relid, GetUserId(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t   ACL_SELECT) == ACLCHECK_OK);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/* suppress leakproofness checks later */\n\t\t\t\t\t\t\t\tvardata->acl_ok = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (vardata->statsTuple)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tindexpr_item = lnext(indexpr_item);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (vardata->statsTuple)\n\t\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/clauses.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Selectivity calc_arraycontsel(VariableStatData *vardata, Datum constval,\n\t\t\t\t  Oid elemtype, Oid operator);\nstatic Selectivity mcelem_array_selec(ArrayType *array,\n\t\t\t\t   TypeCacheEntry *typentry,\n\t\t\t\t   Datum *mcelem, int nmcelem,\n\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t   float4 *hist, int nhist,\n\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);\nstatic Selectivity mcelem_array_contain_overlap_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t\t   Datum *array_data, int nitems,\n\t\t\t\t\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);\nstatic Selectivity mcelem_array_contained_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t Datum *array_data, int nitems,\n\t\t\t\t\t\t\t float4 *hist, int nhist,\n\t\t\t\t\t\t\t Oid operator, FmgrInfo *cmpfunc);\nstatic bool find_next_mcelem(Datum *mcelem, int nmcelem, Datum value,\n\t\t\t\t int *index, FmgrInfo *cmpfunc);\n\nSelectivity\nscalararraysel_containment(PlannerInfo *root,\n\t\t\t\t\t\t   Node *leftop, Node *rightop,\n\t\t\t\t\t\t   Oid elemtype, bool isEquality, bool useOr,\n\t\t\t\t\t\t   int varRelid)\n{\n\tSelectivity selec;\n\tVariableStatData vardata;\n\tDatum\t\tconstval;\n\tTypeCacheEntry *typentry;\n\tFmgrInfo   *cmpfunc;\n\n\t/*\n\t * rightop must be a variable, else punt.\n\t */\n\texamine_variable(root, rightop, varRelid, &vardata);\n\tif (!vardata.rel)\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn -1.0;\n\t}\n\n\t/*\n\t * leftop must be a constant, else punt.\n\t */\n\tif (!IsA(leftop, Const))\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn -1.0;\n\t}\n\tif (((Const *) leftop)->constisnull)\n\t{\n\t\t/* qual can't succeed if null on left */\n\t\tReleaseVariableStats(vardata);\n\t\treturn (Selectivity) 0.0;\n\t}\n\tconstval = ((Const *) leftop)->constvalue;\n\n\t/* Get element type's default comparison function */\n\ttypentry = lookup_type_cache(elemtype, TYPECACHE_CMP_PROC_FINFO);\n\tif (!OidIsValid(typentry->cmp_proc_finfo.fn_oid))\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn -1.0;\n\t}\n\tcmpfunc = &typentry->cmp_proc_finfo;\n\n\t/*\n\t * If the operator is <>, swap ANY/ALL, then invert the result later.\n\t */\n\tif (!isEquality)\n\t\tuseOr = !useOr;\n\n\t/* Get array element stats for var, if available */\n\tif (HeapTupleIsValid(vardata.statsTuple) &&\n\t\tstatistic_proc_security_check(&vardata, cmpfunc->fn_oid))\n\t{\n\t\tForm_pg_statistic stats;\n\t\tAttStatsSlot sslot;\n\t\tAttStatsSlot hslot;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata.statsTuple);\n\n\t\t/* MCELEM will be an array of same type as element */\n\t\tif (get_attstatsslot(&sslot, vardata.statsTuple,\n\t\t\t\t\t\t\t STATISTIC_KIND_MCELEM, InvalidOid,\n\t\t\t\t\t\t\t ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS))\n\t\t{\n\t\t\t/* For ALL case, also get histogram of distinct-element counts */\n\t\t\tif (useOr ||\n\t\t\t\t!get_attstatsslot(&hslot, vardata.statsTuple,\n\t\t\t\t\t\t\t\t  STATISTIC_KIND_DECHIST, InvalidOid,\n\t\t\t\t\t\t\t\t  ATTSTATSSLOT_NUMBERS))\n\t\t\t\tmemset(&hslot, 0, sizeof(hslot));\n\n\t\t\t/*\n\t\t\t * For = ANY, estimate as var @> ARRAY[const].\n\t\t\t *\n\t\t\t * For = ALL, estimate as var <@ ARRAY[const].\n\t\t\t */\n\t\t\tif (useOr)\n\t\t\t\tselec = mcelem_array_contain_overlap_selec(sslot.values,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   sslot.nvalues,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   sslot.numbers,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   sslot.nnumbers,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   &constval, 1,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   OID_ARRAY_CONTAINS_OP,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   cmpfunc);\n\t\t\telse\n\t\t\t\tselec = mcelem_array_contained_selec(sslot.values,\n\t\t\t\t\t\t\t\t\t\t\t\t\t sslot.nvalues,\n\t\t\t\t\t\t\t\t\t\t\t\t\t sslot.numbers,\n\t\t\t\t\t\t\t\t\t\t\t\t\t sslot.nnumbers,\n\t\t\t\t\t\t\t\t\t\t\t\t\t &constval, 1,\n\t\t\t\t\t\t\t\t\t\t\t\t\t hslot.numbers,\n\t\t\t\t\t\t\t\t\t\t\t\t\t hslot.nnumbers,\n\t\t\t\t\t\t\t\t\t\t\t\t\t OID_ARRAY_CONTAINED_OP,\n\t\t\t\t\t\t\t\t\t\t\t\t\t cmpfunc);\n\n\t\t\tfree_attstatsslot(&hslot);\n\t\t\tfree_attstatsslot(&sslot);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* No most-common-elements info, so do without */\n\t\t\tif (useOr)\n\t\t\t\tselec = mcelem_array_contain_overlap_selec(NULL, 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   NULL, 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   &constval, 1,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   OID_ARRAY_CONTAINS_OP,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   cmpfunc);\n\t\t\telse\n\t\t\t\tselec = mcelem_array_contained_selec(NULL, 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t NULL, 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t &constval, 1,\n\t\t\t\t\t\t\t\t\t\t\t\t\t NULL, 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t OID_ARRAY_CONTAINED_OP,\n\t\t\t\t\t\t\t\t\t\t\t\t\t cmpfunc);\n\t\t}\n\n\t\t/*\n\t\t * MCE stats count only non-null rows, so adjust for null rows.\n\t\t */\n\t\tselec *= (1.0 - stats->stanullfrac);\n\t}\n\telse\n\t{\n\t\t/* No stats at all, so do without */\n\t\tif (useOr)\n\t\t\tselec = mcelem_array_contain_overlap_selec(NULL, 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   NULL, 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   &constval, 1,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   OID_ARRAY_CONTAINS_OP,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   cmpfunc);\n\t\telse\n\t\t\tselec = mcelem_array_contained_selec(NULL, 0,\n\t\t\t\t\t\t\t\t\t\t\t\t NULL, 0,\n\t\t\t\t\t\t\t\t\t\t\t\t &constval, 1,\n\t\t\t\t\t\t\t\t\t\t\t\t NULL, 0,\n\t\t\t\t\t\t\t\t\t\t\t\t OID_ARRAY_CONTAINED_OP,\n\t\t\t\t\t\t\t\t\t\t\t\t cmpfunc);\n\t\t/* we assume no nulls here, so no stanullfrac correction */\n\t}\n\n\tReleaseVariableStats(vardata);\n\n\t/*\n\t * If the operator is <>, invert the results.\n\t */\n\tif (!isEquality)\n\t\tselec = 1.0 - selec;\n\n\tCLAMP_PROBABILITY(selec);\n\n\treturn selec;\n}"
  }
]