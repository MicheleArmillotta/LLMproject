[
  {
    "function_name": "printMixedStruct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/help_config.c",
    "lines": "88-138",
    "snippet": "static void\nprintMixedStruct(mixedStruct *structToPrint)\n{\n\tprintf(\"%s\\t%s\\t%s\\t\",\n\t\t   structToPrint->generic.name,\n\t\t   GucContext_Names[structToPrint->generic.context],\n\t\t   _(config_group_names[structToPrint->generic.group]));\n\n\tswitch (structToPrint->generic.vartype)\n\t{\n\n\t\tcase PGC_BOOL:\n\t\t\tprintf(\"BOOLEAN\\t%s\\t\\t\\t\",\n\t\t\t\t   (structToPrint->_bool.reset_val == 0) ?\n\t\t\t\t   \"FALSE\" : \"TRUE\");\n\t\t\tbreak;\n\n\t\tcase PGC_INT:\n\t\t\tprintf(\"INTEGER\\t%d\\t%d\\t%d\\t\",\n\t\t\t\t   structToPrint->integer.reset_val,\n\t\t\t\t   structToPrint->integer.min,\n\t\t\t\t   structToPrint->integer.max);\n\t\t\tbreak;\n\n\t\tcase PGC_REAL:\n\t\t\tprintf(\"REAL\\t%g\\t%g\\t%g\\t\",\n\t\t\t\t   structToPrint->real.reset_val,\n\t\t\t\t   structToPrint->real.min,\n\t\t\t\t   structToPrint->real.max);\n\t\t\tbreak;\n\n\t\tcase PGC_STRING:\n\t\t\tprintf(\"STRING\\t%s\\t\\t\\t\",\n\t\t\t\t   structToPrint->string.boot_val ? structToPrint->string.boot_val : \"\");\n\t\t\tbreak;\n\n\t\tcase PGC_ENUM:\n\t\t\tprintf(\"ENUM\\t%s\\t\\t\\t\",\n\t\t\t\t   config_enum_lookup_by_value(&structToPrint->_enum,\n\t\t\t\t\t\t\t\t\t\t\t   structToPrint->_enum.boot_val));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\twrite_stderr(\"internal error: unrecognized run-time parameter type\\n\");\n\t\t\tbreak;\n\t}\n\n\tprintf(\"%s\\t%s\\n\",\n\t\t   (structToPrint->generic.short_desc == NULL) ? \"\" : _(structToPrint->generic.short_desc),\n\t\t   (structToPrint->generic.long_desc == NULL) ? \"\" : _(structToPrint->generic.long_desc));\n}",
    "includes": [
      "#include \"utils/help_config.h\"",
      "#include \"utils/guc_tables.h\"",
      "#include <unistd.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void printMixedStruct(mixedStruct *structToPrint);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s\\t%s\\n\"",
            "(structToPrint->generic.short_desc == NULL) ? \"\" : _(structToPrint->generic.short_desc)",
            "(structToPrint->generic.long_desc == NULL) ? \"\" : _(structToPrint->generic.long_desc)"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "structToPrint->generic.long_desc"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "load_tzoffsets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/tzparser.c",
          "lines": "437-476",
          "snippet": "TimeZoneAbbrevTable *\nload_tzoffsets(const char *filename)\n{\n\tTimeZoneAbbrevTable *result = NULL;\n\tMemoryContext tmpContext;\n\tMemoryContext oldContext;\n\ttzEntry    *array;\n\tint\t\t\tarraysize;\n\tint\t\t\tn;\n\n\t/*\n\t * Create a temp memory context to work in.  This makes it easy to clean\n\t * up afterwards.\n\t */\n\ttmpContext = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t   \"TZParserMemory\",\n\t\t\t\t\t\t\t\t\t   ALLOCSET_SMALL_SIZES);\n\toldContext = MemoryContextSwitchTo(tmpContext);\n\n\t/* Initialize array at a reasonable size */\n\tarraysize = 128;\n\tarray = (tzEntry *) palloc(arraysize * sizeof(tzEntry));\n\n\t/* Parse the file(s) */\n\tn = ParseTzFile(filename, 0, &array, &arraysize, 0);\n\n\t/* If no errors so far, let datetime.c allocate memory & convert format */\n\tif (n >= 0)\n\t{\n\t\tresult = ConvertTimeZoneAbbrevs(array, n);\n\t\tif (!result)\n\t\t\tGUC_check_errmsg(\"out of memory\");\n\t}\n\n\t/* Clean up */\n\tMemoryContextSwitchTo(oldContext);\n\tMemoryContextDelete(tmpContext);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"storage/fd.h\"",
            "#include \"miscadmin.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int ParseTzFile(const char *filename, int depth,\n\t\t\ttzEntry **base, int *arraysize, int n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"storage/fd.h\"\n#include \"miscadmin.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int ParseTzFile(const char *filename, int depth,\n\t\t\ttzEntry **base, int *arraysize, int n);\n\nTimeZoneAbbrevTable *\nload_tzoffsets(const char *filename)\n{\n\tTimeZoneAbbrevTable *result = NULL;\n\tMemoryContext tmpContext;\n\tMemoryContext oldContext;\n\ttzEntry    *array;\n\tint\t\t\tarraysize;\n\tint\t\t\tn;\n\n\t/*\n\t * Create a temp memory context to work in.  This makes it easy to clean\n\t * up afterwards.\n\t */\n\ttmpContext = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t   \"TZParserMemory\",\n\t\t\t\t\t\t\t\t\t   ALLOCSET_SMALL_SIZES);\n\toldContext = MemoryContextSwitchTo(tmpContext);\n\n\t/* Initialize array at a reasonable size */\n\tarraysize = 128;\n\tarray = (tzEntry *) palloc(arraysize * sizeof(tzEntry));\n\n\t/* Parse the file(s) */\n\tn = ParseTzFile(filename, 0, &array, &arraysize, 0);\n\n\t/* If no errors so far, let datetime.c allocate memory & convert format */\n\tif (n >= 0)\n\t{\n\t\tresult = ConvertTimeZoneAbbrevs(array, n);\n\t\tif (!result)\n\t\t\tGUC_check_errmsg(\"out of memory\");\n\t}\n\n\t/* Clean up */\n\tMemoryContextSwitchTo(oldContext);\n\tMemoryContextDelete(tmpContext);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_stderr",
          "args": [
            "\"internal error: unrecognized run-time parameter type\\n\""
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "write_stderr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "3668-3703",
          "snippet": "void\nwrite_stderr(const char *fmt,...)\n{\n\tva_list\t\tap;\n\n#ifdef WIN32\n\tchar\t\terrbuf[2048];\t/* Arbitrary size? */\n#endif\n\n\tfmt = _(fmt);\n\n\tva_start(ap, fmt);\n#ifndef WIN32\n\t/* On Unix, we just fprintf to stderr */\n\tvfprintf(stderr, fmt, ap);\n\tfflush(stderr);\n#else\n\tvsnprintf(errbuf, sizeof(errbuf), fmt, ap);\n\n\t/*\n\t * On Win32, we print to stderr if running on a console, or write to\n\t * eventlog if running as a service\n\t */\n\tif (pgwin32_is_service())\t/* Running as a service */\n\t{\n\t\twrite_eventlog(ERROR, errbuf, strlen(errbuf));\n\t}\n\telse\n\t{\n\t\t/* Not running as service, write to stderr */\n\t\twrite_console(errbuf, strlen(errbuf));\n\t\tfflush(stderr);\n\t}\n#endif\n\tva_end(ap);\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nvoid\nwrite_stderr(const char *fmt,...)\n{\n\tva_list\t\tap;\n\n#ifdef WIN32\n\tchar\t\terrbuf[2048];\t/* Arbitrary size? */\n#endif\n\n\tfmt = _(fmt);\n\n\tva_start(ap, fmt);\n#ifndef WIN32\n\t/* On Unix, we just fprintf to stderr */\n\tvfprintf(stderr, fmt, ap);\n\tfflush(stderr);\n#else\n\tvsnprintf(errbuf, sizeof(errbuf), fmt, ap);\n\n\t/*\n\t * On Win32, we print to stderr if running on a console, or write to\n\t * eventlog if running as a service\n\t */\n\tif (pgwin32_is_service())\t/* Running as a service */\n\t{\n\t\twrite_eventlog(ERROR, errbuf, strlen(errbuf));\n\t}\n\telse\n\t{\n\t\t/* Not running as service, write to stderr */\n\t\twrite_console(errbuf, strlen(errbuf));\n\t\tfflush(stderr);\n\t}\n#endif\n\tva_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ENUM\\t%s\\t\\t\\t\"",
            "config_enum_lookup_by_value(&structToPrint->_enum,\n\t\t\t\t\t\t\t\t\t\t\t   structToPrint->_enum.boot_val)"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "config_enum_lookup_by_value",
          "args": [
            "&structToPrint->_enum",
            "structToPrint->_enum.boot_val"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "config_enum_lookup_by_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/guc.c",
          "lines": "5874-5888",
          "snippet": "const char *\nconfig_enum_lookup_by_value(struct config_enum *record, int val)\n{\n\tconst struct config_enum_entry *entry;\n\n\tfor (entry = record->options; entry && entry->name; entry++)\n\t{\n\t\tif (entry->val == val)\n\t\t\treturn entry->name;\n\t}\n\n\telog(ERROR, \"could not find enum option %d for %s\",\n\t\t val, record->gen.name);\n\treturn NULL;\t\t\t\t/* silence compiler */\n}",
          "includes": [
            "#include \"guc-file.c\"",
            "#include \"utils/xml.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/tzparser.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/ps_status.h\"",
            "#include \"utils/portal.h\"",
            "#include \"utils/plancache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc_tables.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_cache.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pg_shmem.h\"",
            "#include \"storage/large_object.h\"",
            "#include \"storage/fd.h\"",
            "#include \"storage/standby.h\"",
            "#include \"storage/dsm_impl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"replication/walsender.h\"",
            "#include \"replication/walreceiver.h\"",
            "#include \"replication/syncrep.h\"",
            "#include \"replication/slot.h\"",
            "#include \"replication/logicallauncher.h\"",
            "#include \"postmaster/walwriter.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/bgwriter.h\"",
            "#include \"postmaster/bgworker_internals.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"parser/parser.h\"",
            "#include \"parser/parse_type.h\"",
            "#include \"parser/parse_expr.h\"",
            "#include \"optimizer/planmain.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/geqo.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"libpq/auth.h\"",
            "#include \"jit/jit.h\"",
            "#include \"funcapi.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/variable.h\"",
            "#include \"commands/vacuum.h\"",
            "#include \"commands/user.h\"",
            "#include \"commands/prepare.h\"",
            "#include \"commands/async.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xlog_internal.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/twophase.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/rmgr.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/commit_ts.h\"",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ReportGUCOption(struct config_generic *record);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"guc-file.c\"\n#include \"utils/xml.h\"\n#include \"utils/varlena.h\"\n#include \"utils/tzparser.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/ps_status.h\"\n#include \"utils/portal.h\"\n#include \"utils/plancache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc_tables.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_cache.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/predicate.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/large_object.h\"\n#include \"storage/fd.h\"\n#include \"storage/standby.h\"\n#include \"storage/dsm_impl.h\"\n#include \"storage/bufmgr.h\"\n#include \"replication/walsender.h\"\n#include \"replication/walreceiver.h\"\n#include \"replication/syncrep.h\"\n#include \"replication/slot.h\"\n#include \"replication/logicallauncher.h\"\n#include \"postmaster/walwriter.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/bgwriter.h\"\n#include \"postmaster/bgworker_internals.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parser.h\"\n#include \"parser/parse_type.h\"\n#include \"parser/parse_expr.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/geqo.h\"\n#include \"optimizer/cost.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"libpq/auth.h\"\n#include \"jit/jit.h\"\n#include \"funcapi.h\"\n#include \"commands/trigger.h\"\n#include \"commands/variable.h\"\n#include \"commands/vacuum.h\"\n#include \"commands/user.h\"\n#include \"commands/prepare.h\"\n#include \"commands/async.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xlog_internal.h\"\n#include \"access/xact.h\"\n#include \"access/twophase.h\"\n#include \"access/transam.h\"\n#include \"access/rmgr.h\"\n#include \"access/gin.h\"\n#include \"access/commit_ts.h\"\n#include <syslog.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void ReportGUCOption(struct config_generic *record);\n\nconst char *\nconfig_enum_lookup_by_value(struct config_enum *record, int val)\n{\n\tconst struct config_enum_entry *entry;\n\n\tfor (entry = record->options; entry && entry->name; entry++)\n\t{\n\t\tif (entry->val == val)\n\t\t\treturn entry->name;\n\t}\n\n\telog(ERROR, \"could not find enum option %d for %s\",\n\t\t val, record->gen.name);\n\treturn NULL;\t\t\t\t/* silence compiler */\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"STRING\\t%s\\t\\t\\t\"",
            "structToPrint->string.boot_val ? structToPrint->string.boot_val : \"\""
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"REAL\\t%g\\t%g\\t%g\\t\"",
            "structToPrint->real.reset_val",
            "structToPrint->real.min",
            "structToPrint->real.max"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"INTEGER\\t%d\\t%d\\t%d\\t\"",
            "structToPrint->integer.reset_val",
            "structToPrint->integer.min",
            "structToPrint->integer.max"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"BOOLEAN\\t%s\\t\\t\\t\"",
            "(structToPrint->_bool.reset_val == 0) ?\n\t\t\t\t   \"FALSE\" : \"TRUE\""
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s\\t%s\\t%s\\t\"",
            "structToPrint->generic.name",
            "GucContext_Names[structToPrint->generic.context]",
            "_(config_group_names[structToPrint->generic.group])"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/help_config.h\"\n#include \"utils/guc_tables.h\"\n#include <unistd.h>\n#include <limits.h>\n#include <float.h>\n#include \"postgres.h\"\n\nstatic void printMixedStruct(mixedStruct *structToPrint);\n\nstatic void\nprintMixedStruct(mixedStruct *structToPrint)\n{\n\tprintf(\"%s\\t%s\\t%s\\t\",\n\t\t   structToPrint->generic.name,\n\t\t   GucContext_Names[structToPrint->generic.context],\n\t\t   _(config_group_names[structToPrint->generic.group]));\n\n\tswitch (structToPrint->generic.vartype)\n\t{\n\n\t\tcase PGC_BOOL:\n\t\t\tprintf(\"BOOLEAN\\t%s\\t\\t\\t\",\n\t\t\t\t   (structToPrint->_bool.reset_val == 0) ?\n\t\t\t\t   \"FALSE\" : \"TRUE\");\n\t\t\tbreak;\n\n\t\tcase PGC_INT:\n\t\t\tprintf(\"INTEGER\\t%d\\t%d\\t%d\\t\",\n\t\t\t\t   structToPrint->integer.reset_val,\n\t\t\t\t   structToPrint->integer.min,\n\t\t\t\t   structToPrint->integer.max);\n\t\t\tbreak;\n\n\t\tcase PGC_REAL:\n\t\t\tprintf(\"REAL\\t%g\\t%g\\t%g\\t\",\n\t\t\t\t   structToPrint->real.reset_val,\n\t\t\t\t   structToPrint->real.min,\n\t\t\t\t   structToPrint->real.max);\n\t\t\tbreak;\n\n\t\tcase PGC_STRING:\n\t\t\tprintf(\"STRING\\t%s\\t\\t\\t\",\n\t\t\t\t   structToPrint->string.boot_val ? structToPrint->string.boot_val : \"\");\n\t\t\tbreak;\n\n\t\tcase PGC_ENUM:\n\t\t\tprintf(\"ENUM\\t%s\\t\\t\\t\",\n\t\t\t\t   config_enum_lookup_by_value(&structToPrint->_enum,\n\t\t\t\t\t\t\t\t\t\t\t   structToPrint->_enum.boot_val));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\twrite_stderr(\"internal error: unrecognized run-time parameter type\\n\");\n\t\t\tbreak;\n\t}\n\n\tprintf(\"%s\\t%s\\n\",\n\t\t   (structToPrint->generic.short_desc == NULL) ? \"\" : _(structToPrint->generic.short_desc),\n\t\t   (structToPrint->generic.long_desc == NULL) ? \"\" : _(structToPrint->generic.long_desc));\n}"
  },
  {
    "function_name": "displayStruct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/help_config.c",
    "lines": "75-81",
    "snippet": "static bool\ndisplayStruct(mixedStruct *structToDisplay)\n{\n\treturn !(structToDisplay->generic.flags & (GUC_NO_SHOW_ALL |\n\t\t\t\t\t\t\t\t\t\t\t   GUC_NOT_IN_SAMPLE |\n\t\t\t\t\t\t\t\t\t\t\t   GUC_DISALLOW_IN_FILE));\n}",
    "includes": [
      "#include \"utils/help_config.h\"",
      "#include \"utils/guc_tables.h\"",
      "#include <unistd.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool displayStruct(mixedStruct *structToDisplay);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/help_config.h\"\n#include \"utils/guc_tables.h\"\n#include <unistd.h>\n#include <limits.h>\n#include <float.h>\n#include \"postgres.h\"\n\nstatic bool displayStruct(mixedStruct *structToDisplay);\n\nstatic bool\ndisplayStruct(mixedStruct *structToDisplay)\n{\n\treturn !(structToDisplay->generic.flags & (GUC_NO_SHOW_ALL |\n\t\t\t\t\t\t\t\t\t\t\t   GUC_NOT_IN_SAMPLE |\n\t\t\t\t\t\t\t\t\t\t\t   GUC_DISALLOW_IN_FILE));\n}"
  },
  {
    "function_name": "GucInfoMain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/help_config.c",
    "lines": "46-68",
    "snippet": "void\nGucInfoMain(void)\n{\n\tstruct config_generic **guc_vars;\n\tint\t\t\tnumOpts,\n\t\t\t\ti;\n\n\t/* Initialize the guc_variables[] array */\n\tbuild_guc_variables();\n\n\tguc_vars = get_guc_variables();\n\tnumOpts = GetNumConfigOptions();\n\n\tfor (i = 0; i < numOpts; i++)\n\t{\n\t\tmixedStruct *var = (mixedStruct *) guc_vars[i];\n\n\t\tif (displayStruct(var))\n\t\t\tprintMixedStruct(var);\n\t}\n\n\texit(0);\n}",
    "includes": [
      "#include \"utils/help_config.h\"",
      "#include \"utils/guc_tables.h\"",
      "#include <unistd.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printMixedStruct",
          "args": [
            "var"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "printMixedStruct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/help_config.c",
          "lines": "88-138",
          "snippet": "static void\nprintMixedStruct(mixedStruct *structToPrint)\n{\n\tprintf(\"%s\\t%s\\t%s\\t\",\n\t\t   structToPrint->generic.name,\n\t\t   GucContext_Names[structToPrint->generic.context],\n\t\t   _(config_group_names[structToPrint->generic.group]));\n\n\tswitch (structToPrint->generic.vartype)\n\t{\n\n\t\tcase PGC_BOOL:\n\t\t\tprintf(\"BOOLEAN\\t%s\\t\\t\\t\",\n\t\t\t\t   (structToPrint->_bool.reset_val == 0) ?\n\t\t\t\t   \"FALSE\" : \"TRUE\");\n\t\t\tbreak;\n\n\t\tcase PGC_INT:\n\t\t\tprintf(\"INTEGER\\t%d\\t%d\\t%d\\t\",\n\t\t\t\t   structToPrint->integer.reset_val,\n\t\t\t\t   structToPrint->integer.min,\n\t\t\t\t   structToPrint->integer.max);\n\t\t\tbreak;\n\n\t\tcase PGC_REAL:\n\t\t\tprintf(\"REAL\\t%g\\t%g\\t%g\\t\",\n\t\t\t\t   structToPrint->real.reset_val,\n\t\t\t\t   structToPrint->real.min,\n\t\t\t\t   structToPrint->real.max);\n\t\t\tbreak;\n\n\t\tcase PGC_STRING:\n\t\t\tprintf(\"STRING\\t%s\\t\\t\\t\",\n\t\t\t\t   structToPrint->string.boot_val ? structToPrint->string.boot_val : \"\");\n\t\t\tbreak;\n\n\t\tcase PGC_ENUM:\n\t\t\tprintf(\"ENUM\\t%s\\t\\t\\t\",\n\t\t\t\t   config_enum_lookup_by_value(&structToPrint->_enum,\n\t\t\t\t\t\t\t\t\t\t\t   structToPrint->_enum.boot_val));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\twrite_stderr(\"internal error: unrecognized run-time parameter type\\n\");\n\t\t\tbreak;\n\t}\n\n\tprintf(\"%s\\t%s\\n\",\n\t\t   (structToPrint->generic.short_desc == NULL) ? \"\" : _(structToPrint->generic.short_desc),\n\t\t   (structToPrint->generic.long_desc == NULL) ? \"\" : _(structToPrint->generic.long_desc));\n}",
          "includes": [
            "#include \"utils/help_config.h\"",
            "#include \"utils/guc_tables.h\"",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void printMixedStruct(mixedStruct *structToPrint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/help_config.h\"\n#include \"utils/guc_tables.h\"\n#include <unistd.h>\n#include <limits.h>\n#include <float.h>\n#include \"postgres.h\"\n\nstatic void printMixedStruct(mixedStruct *structToPrint);\n\nstatic void\nprintMixedStruct(mixedStruct *structToPrint)\n{\n\tprintf(\"%s\\t%s\\t%s\\t\",\n\t\t   structToPrint->generic.name,\n\t\t   GucContext_Names[structToPrint->generic.context],\n\t\t   _(config_group_names[structToPrint->generic.group]));\n\n\tswitch (structToPrint->generic.vartype)\n\t{\n\n\t\tcase PGC_BOOL:\n\t\t\tprintf(\"BOOLEAN\\t%s\\t\\t\\t\",\n\t\t\t\t   (structToPrint->_bool.reset_val == 0) ?\n\t\t\t\t   \"FALSE\" : \"TRUE\");\n\t\t\tbreak;\n\n\t\tcase PGC_INT:\n\t\t\tprintf(\"INTEGER\\t%d\\t%d\\t%d\\t\",\n\t\t\t\t   structToPrint->integer.reset_val,\n\t\t\t\t   structToPrint->integer.min,\n\t\t\t\t   structToPrint->integer.max);\n\t\t\tbreak;\n\n\t\tcase PGC_REAL:\n\t\t\tprintf(\"REAL\\t%g\\t%g\\t%g\\t\",\n\t\t\t\t   structToPrint->real.reset_val,\n\t\t\t\t   structToPrint->real.min,\n\t\t\t\t   structToPrint->real.max);\n\t\t\tbreak;\n\n\t\tcase PGC_STRING:\n\t\t\tprintf(\"STRING\\t%s\\t\\t\\t\",\n\t\t\t\t   structToPrint->string.boot_val ? structToPrint->string.boot_val : \"\");\n\t\t\tbreak;\n\n\t\tcase PGC_ENUM:\n\t\t\tprintf(\"ENUM\\t%s\\t\\t\\t\",\n\t\t\t\t   config_enum_lookup_by_value(&structToPrint->_enum,\n\t\t\t\t\t\t\t\t\t\t\t   structToPrint->_enum.boot_val));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\twrite_stderr(\"internal error: unrecognized run-time parameter type\\n\");\n\t\t\tbreak;\n\t}\n\n\tprintf(\"%s\\t%s\\n\",\n\t\t   (structToPrint->generic.short_desc == NULL) ? \"\" : _(structToPrint->generic.short_desc),\n\t\t   (structToPrint->generic.long_desc == NULL) ? \"\" : _(structToPrint->generic.long_desc));\n}"
        }
      },
      {
        "call_info": {
          "callee": "displayStruct",
          "args": [
            "var"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "displayStruct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/help_config.c",
          "lines": "75-81",
          "snippet": "static bool\ndisplayStruct(mixedStruct *structToDisplay)\n{\n\treturn !(structToDisplay->generic.flags & (GUC_NO_SHOW_ALL |\n\t\t\t\t\t\t\t\t\t\t\t   GUC_NOT_IN_SAMPLE |\n\t\t\t\t\t\t\t\t\t\t\t   GUC_DISALLOW_IN_FILE));\n}",
          "includes": [
            "#include \"utils/help_config.h\"",
            "#include \"utils/guc_tables.h\"",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool displayStruct(mixedStruct *structToDisplay);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/help_config.h\"\n#include \"utils/guc_tables.h\"\n#include <unistd.h>\n#include <limits.h>\n#include <float.h>\n#include \"postgres.h\"\n\nstatic bool displayStruct(mixedStruct *structToDisplay);\n\nstatic bool\ndisplayStruct(mixedStruct *structToDisplay)\n{\n\treturn !(structToDisplay->generic.flags & (GUC_NO_SHOW_ALL |\n\t\t\t\t\t\t\t\t\t\t\t   GUC_NOT_IN_SAMPLE |\n\t\t\t\t\t\t\t\t\t\t\t   GUC_DISALLOW_IN_FILE));\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetNumConfigOptions",
          "args": [],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "GetNumConfigOptions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/guc.c",
          "lines": "8631-8635",
          "snippet": "int\nGetNumConfigOptions(void)\n{\n\treturn num_guc_variables;\n}",
          "includes": [
            "#include \"guc-file.c\"",
            "#include \"utils/xml.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/tzparser.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/ps_status.h\"",
            "#include \"utils/portal.h\"",
            "#include \"utils/plancache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc_tables.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_cache.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pg_shmem.h\"",
            "#include \"storage/large_object.h\"",
            "#include \"storage/fd.h\"",
            "#include \"storage/standby.h\"",
            "#include \"storage/dsm_impl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"replication/walsender.h\"",
            "#include \"replication/walreceiver.h\"",
            "#include \"replication/syncrep.h\"",
            "#include \"replication/slot.h\"",
            "#include \"replication/logicallauncher.h\"",
            "#include \"postmaster/walwriter.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/bgwriter.h\"",
            "#include \"postmaster/bgworker_internals.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"parser/parser.h\"",
            "#include \"parser/parse_type.h\"",
            "#include \"parser/parse_expr.h\"",
            "#include \"optimizer/planmain.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/geqo.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"libpq/auth.h\"",
            "#include \"jit/jit.h\"",
            "#include \"funcapi.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/variable.h\"",
            "#include \"commands/vacuum.h\"",
            "#include \"commands/user.h\"",
            "#include \"commands/prepare.h\"",
            "#include \"commands/async.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xlog_internal.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/twophase.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/rmgr.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/commit_ts.h\"",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tnum_guc_variables;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"guc-file.c\"\n#include \"utils/xml.h\"\n#include \"utils/varlena.h\"\n#include \"utils/tzparser.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/ps_status.h\"\n#include \"utils/portal.h\"\n#include \"utils/plancache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc_tables.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_cache.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/predicate.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/large_object.h\"\n#include \"storage/fd.h\"\n#include \"storage/standby.h\"\n#include \"storage/dsm_impl.h\"\n#include \"storage/bufmgr.h\"\n#include \"replication/walsender.h\"\n#include \"replication/walreceiver.h\"\n#include \"replication/syncrep.h\"\n#include \"replication/slot.h\"\n#include \"replication/logicallauncher.h\"\n#include \"postmaster/walwriter.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/bgwriter.h\"\n#include \"postmaster/bgworker_internals.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parser.h\"\n#include \"parser/parse_type.h\"\n#include \"parser/parse_expr.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/geqo.h\"\n#include \"optimizer/cost.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"libpq/auth.h\"\n#include \"jit/jit.h\"\n#include \"funcapi.h\"\n#include \"commands/trigger.h\"\n#include \"commands/variable.h\"\n#include \"commands/vacuum.h\"\n#include \"commands/user.h\"\n#include \"commands/prepare.h\"\n#include \"commands/async.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xlog_internal.h\"\n#include \"access/xact.h\"\n#include \"access/twophase.h\"\n#include \"access/transam.h\"\n#include \"access/rmgr.h\"\n#include \"access/gin.h\"\n#include \"access/commit_ts.h\"\n#include <syslog.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\tnum_guc_variables;\n\nint\nGetNumConfigOptions(void)\n{\n\treturn num_guc_variables;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_guc_variables",
          "args": [],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "get_guc_variables",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/guc.c",
          "lines": "4439-4443",
          "snippet": "struct config_generic **\nget_guc_variables(void)\n{\n\treturn guc_variables;\n}",
          "includes": [
            "#include \"guc-file.c\"",
            "#include \"utils/xml.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/tzparser.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/ps_status.h\"",
            "#include \"utils/portal.h\"",
            "#include \"utils/plancache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc_tables.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_cache.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pg_shmem.h\"",
            "#include \"storage/large_object.h\"",
            "#include \"storage/fd.h\"",
            "#include \"storage/standby.h\"",
            "#include \"storage/dsm_impl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"replication/walsender.h\"",
            "#include \"replication/walreceiver.h\"",
            "#include \"replication/syncrep.h\"",
            "#include \"replication/slot.h\"",
            "#include \"replication/logicallauncher.h\"",
            "#include \"postmaster/walwriter.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/bgwriter.h\"",
            "#include \"postmaster/bgworker_internals.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"parser/parser.h\"",
            "#include \"parser/parse_type.h\"",
            "#include \"parser/parse_expr.h\"",
            "#include \"optimizer/planmain.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/geqo.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"libpq/auth.h\"",
            "#include \"jit/jit.h\"",
            "#include \"funcapi.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/variable.h\"",
            "#include \"commands/vacuum.h\"",
            "#include \"commands/user.h\"",
            "#include \"commands/prepare.h\"",
            "#include \"commands/async.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xlog_internal.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/twophase.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/rmgr.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/commit_ts.h\"",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct config_generic **guc_variables;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"guc-file.c\"\n#include \"utils/xml.h\"\n#include \"utils/varlena.h\"\n#include \"utils/tzparser.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/ps_status.h\"\n#include \"utils/portal.h\"\n#include \"utils/plancache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc_tables.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_cache.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/predicate.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/large_object.h\"\n#include \"storage/fd.h\"\n#include \"storage/standby.h\"\n#include \"storage/dsm_impl.h\"\n#include \"storage/bufmgr.h\"\n#include \"replication/walsender.h\"\n#include \"replication/walreceiver.h\"\n#include \"replication/syncrep.h\"\n#include \"replication/slot.h\"\n#include \"replication/logicallauncher.h\"\n#include \"postmaster/walwriter.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/bgwriter.h\"\n#include \"postmaster/bgworker_internals.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parser.h\"\n#include \"parser/parse_type.h\"\n#include \"parser/parse_expr.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/geqo.h\"\n#include \"optimizer/cost.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"libpq/auth.h\"\n#include \"jit/jit.h\"\n#include \"funcapi.h\"\n#include \"commands/trigger.h\"\n#include \"commands/variable.h\"\n#include \"commands/vacuum.h\"\n#include \"commands/user.h\"\n#include \"commands/prepare.h\"\n#include \"commands/async.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xlog_internal.h\"\n#include \"access/xact.h\"\n#include \"access/twophase.h\"\n#include \"access/transam.h\"\n#include \"access/rmgr.h\"\n#include \"access/gin.h\"\n#include \"access/commit_ts.h\"\n#include <syslog.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic struct config_generic **guc_variables;\n\nstruct config_generic **\nget_guc_variables(void)\n{\n\treturn guc_variables;\n}"
        }
      },
      {
        "call_info": {
          "callee": "build_guc_variables",
          "args": [],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "build_guc_variables",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/guc.c",
          "lines": "4451-4532",
          "snippet": "void\nbuild_guc_variables(void)\n{\n\tint\t\t\tsize_vars;\n\tint\t\t\tnum_vars = 0;\n\tstruct config_generic **guc_vars;\n\tint\t\t\ti;\n\n\tfor (i = 0; ConfigureNamesBool[i].gen.name; i++)\n\t{\n\t\tstruct config_bool *conf = &ConfigureNamesBool[i];\n\n\t\t/* Rather than requiring vartype to be filled in by hand, do this: */\n\t\tconf->gen.vartype = PGC_BOOL;\n\t\tnum_vars++;\n\t}\n\n\tfor (i = 0; ConfigureNamesInt[i].gen.name; i++)\n\t{\n\t\tstruct config_int *conf = &ConfigureNamesInt[i];\n\n\t\tconf->gen.vartype = PGC_INT;\n\t\tnum_vars++;\n\t}\n\n\tfor (i = 0; ConfigureNamesReal[i].gen.name; i++)\n\t{\n\t\tstruct config_real *conf = &ConfigureNamesReal[i];\n\n\t\tconf->gen.vartype = PGC_REAL;\n\t\tnum_vars++;\n\t}\n\n\tfor (i = 0; ConfigureNamesString[i].gen.name; i++)\n\t{\n\t\tstruct config_string *conf = &ConfigureNamesString[i];\n\n\t\tconf->gen.vartype = PGC_STRING;\n\t\tnum_vars++;\n\t}\n\n\tfor (i = 0; ConfigureNamesEnum[i].gen.name; i++)\n\t{\n\t\tstruct config_enum *conf = &ConfigureNamesEnum[i];\n\n\t\tconf->gen.vartype = PGC_ENUM;\n\t\tnum_vars++;\n\t}\n\n\t/*\n\t * Create table with 20% slack\n\t */\n\tsize_vars = num_vars + num_vars / 4;\n\n\tguc_vars = (struct config_generic **)\n\t\tguc_malloc(FATAL, size_vars * sizeof(struct config_generic *));\n\n\tnum_vars = 0;\n\n\tfor (i = 0; ConfigureNamesBool[i].gen.name; i++)\n\t\tguc_vars[num_vars++] = &ConfigureNamesBool[i].gen;\n\n\tfor (i = 0; ConfigureNamesInt[i].gen.name; i++)\n\t\tguc_vars[num_vars++] = &ConfigureNamesInt[i].gen;\n\n\tfor (i = 0; ConfigureNamesReal[i].gen.name; i++)\n\t\tguc_vars[num_vars++] = &ConfigureNamesReal[i].gen;\n\n\tfor (i = 0; ConfigureNamesString[i].gen.name; i++)\n\t\tguc_vars[num_vars++] = &ConfigureNamesString[i].gen;\n\n\tfor (i = 0; ConfigureNamesEnum[i].gen.name; i++)\n\t\tguc_vars[num_vars++] = &ConfigureNamesEnum[i].gen;\n\n\tif (guc_variables)\n\t\tfree(guc_variables);\n\tguc_variables = guc_vars;\n\tnum_guc_variables = num_vars;\n\tsize_guc_variables = size_vars;\n\tqsort((void *) guc_variables, num_guc_variables,\n\t\t  sizeof(struct config_generic *), guc_var_compare);\n}",
          "includes": [
            "#include \"guc-file.c\"",
            "#include \"utils/xml.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/tzparser.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/ps_status.h\"",
            "#include \"utils/portal.h\"",
            "#include \"utils/plancache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc_tables.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_cache.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pg_shmem.h\"",
            "#include \"storage/large_object.h\"",
            "#include \"storage/fd.h\"",
            "#include \"storage/standby.h\"",
            "#include \"storage/dsm_impl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"replication/walsender.h\"",
            "#include \"replication/walreceiver.h\"",
            "#include \"replication/syncrep.h\"",
            "#include \"replication/slot.h\"",
            "#include \"replication/logicallauncher.h\"",
            "#include \"postmaster/walwriter.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/bgwriter.h\"",
            "#include \"postmaster/bgworker_internals.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"parser/parser.h\"",
            "#include \"parser/parse_type.h\"",
            "#include \"parser/parse_expr.h\"",
            "#include \"optimizer/planmain.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/geqo.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"libpq/auth.h\"",
            "#include \"jit/jit.h\"",
            "#include \"funcapi.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/variable.h\"",
            "#include \"commands/vacuum.h\"",
            "#include \"commands/user.h\"",
            "#include \"commands/prepare.h\"",
            "#include \"commands/async.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xlog_internal.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/twophase.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/rmgr.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/commit_ts.h\"",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct config_bool ConfigureNamesBool[] =\n{\n\t{\n\t\t{\"enable_seqscan\", PGC_USERSET, QUERY_TUNING_METHOD,\n\t\t\tgettext_noop(\"Enables the planner's use of sequential-scan plans.\"),\n\t\t\tNULL\n\t\t},\n\t\t&enable_seqscan,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"enable_indexscan\", PGC_USERSET, QUERY_TUNING_METHOD,\n\t\t\tgettext_noop(\"Enables the planner's use of index-scan plans.\"),\n\t\t\tNULL\n\t\t},\n\t\t&enable_indexscan,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"enable_indexonlyscan\", PGC_USERSET, QUERY_TUNING_METHOD,\n\t\t\tgettext_noop(\"Enables the planner's use of index-only-scan plans.\"),\n\t\t\tNULL\n\t\t},\n\t\t&enable_indexonlyscan,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"enable_bitmapscan\", PGC_USERSET, QUERY_TUNING_METHOD,\n\t\t\tgettext_noop(\"Enables the planner's use of bitmap-scan plans.\"),\n\t\t\tNULL\n\t\t},\n\t\t&enable_bitmapscan,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"enable_tidscan\", PGC_USERSET, QUERY_TUNING_METHOD,\n\t\t\tgettext_noop(\"Enables the planner's use of TID scan plans.\"),\n\t\t\tNULL\n\t\t},\n\t\t&enable_tidscan,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"enable_sort\", PGC_USERSET, QUERY_TUNING_METHOD,\n\t\t\tgettext_noop(\"Enables the planner's use of explicit sort steps.\"),\n\t\t\tNULL\n\t\t},\n\t\t&enable_sort,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"enable_hashagg\", PGC_USERSET, QUERY_TUNING_METHOD,\n\t\t\tgettext_noop(\"Enables the planner's use of hashed aggregation plans.\"),\n\t\t\tNULL\n\t\t},\n\t\t&enable_hashagg,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"enable_material\", PGC_USERSET, QUERY_TUNING_METHOD,\n\t\t\tgettext_noop(\"Enables the planner's use of materialization.\"),\n\t\t\tNULL\n\t\t},\n\t\t&enable_material,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"enable_nestloop\", PGC_USERSET, QUERY_TUNING_METHOD,\n\t\t\tgettext_noop(\"Enables the planner's use of nested-loop join plans.\"),\n\t\t\tNULL\n\t\t},\n\t\t&enable_nestloop,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"enable_mergejoin\", PGC_USERSET, QUERY_TUNING_METHOD,\n\t\t\tgettext_noop(\"Enables the planner's use of merge join plans.\"),\n\t\t\tNULL\n\t\t},\n\t\t&enable_mergejoin,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"enable_hashjoin\", PGC_USERSET, QUERY_TUNING_METHOD,\n\t\t\tgettext_noop(\"Enables the planner's use of hash join plans.\"),\n\t\t\tNULL\n\t\t},\n\t\t&enable_hashjoin,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"enable_gathermerge\", PGC_USERSET, QUERY_TUNING_METHOD,\n\t\t\tgettext_noop(\"Enables the planner's use of gather merge plans.\"),\n\t\t\tNULL\n\t\t},\n\t\t&enable_gathermerge,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"enable_partitionwise_join\", PGC_USERSET, QUERY_TUNING_METHOD,\n\t\t\tgettext_noop(\"Enables partitionwise join.\"),\n\t\t\tNULL\n\t\t},\n\t\t&enable_partitionwise_join,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"enable_partitionwise_aggregate\", PGC_USERSET, QUERY_TUNING_METHOD,\n\t\t\tgettext_noop(\"Enables partitionwise aggregation and grouping.\"),\n\t\t\tNULL\n\t\t},\n\t\t&enable_partitionwise_aggregate,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"enable_parallel_append\", PGC_USERSET, QUERY_TUNING_METHOD,\n\t\t\tgettext_noop(\"Enables the planner's use of parallel append plans.\"),\n\t\t\tNULL\n\t\t},\n\t\t&enable_parallel_append,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"enable_parallel_hash\", PGC_USERSET, QUERY_TUNING_METHOD,\n\t\t\tgettext_noop(\"Enables the planner's use of parallel hash plans.\"),\n\t\t\tNULL\n\t\t},\n\t\t&enable_parallel_hash,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"enable_partition_pruning\", PGC_USERSET, QUERY_TUNING_METHOD,\n\t\t\tgettext_noop(\"Enable plan-time and run-time partition pruning.\"),\n\t\t\tgettext_noop(\"Allows the query planner and executor to compare partition \"\n\t\t\t\t\t\t \"bounds to conditions in the query to determine which \"\n\t\t\t\t\t\t \"partitions must be scanned.\")\n\t\t},\n\t\t&enable_partition_pruning,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"geqo\", PGC_USERSET, QUERY_TUNING_GEQO,\n\t\t\tgettext_noop(\"Enables genetic query optimization.\"),\n\t\t\tgettext_noop(\"This algorithm attempts to do planning without \"\n\t\t\t\t\t\t \"exhaustive searching.\")\n\t\t},\n\t\t&enable_geqo,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t/* Not for general use --- used by SET SESSION AUTHORIZATION */\n\t\t{\"is_superuser\", PGC_INTERNAL, UNGROUPED,\n\t\t\tgettext_noop(\"Shows whether the current user is a superuser.\"),\n\t\t\tNULL,\n\t\t\tGUC_REPORT | GUC_NO_SHOW_ALL | GUC_NO_RESET_ALL | GUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE\n\t\t},\n\t\t&session_auth_is_superuser,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"bonjour\", PGC_POSTMASTER, CONN_AUTH_SETTINGS,\n\t\t\tgettext_noop(\"Enables advertising the server via Bonjour.\"),\n\t\t\tNULL\n\t\t},\n\t\t&enable_bonjour,\n\t\tfalse,\n\t\tcheck_bonjour, NULL, NULL\n\t},\n\t{\n\t\t{\"track_commit_timestamp\", PGC_POSTMASTER, REPLICATION,\n\t\t\tgettext_noop(\"Collects transaction commit time.\"),\n\t\t\tNULL\n\t\t},\n\t\t&track_commit_timestamp,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"ssl\", PGC_SIGHUP, CONN_AUTH_SSL,\n\t\t\tgettext_noop(\"Enables SSL connections.\"),\n\t\t\tNULL\n\t\t},\n\t\t&EnableSSL,\n\t\tfalse,\n\t\tcheck_ssl, NULL, NULL\n\t},\n\t{\n\t\t{\"ssl_passphrase_command_supports_reload\", PGC_SIGHUP, CONN_AUTH_SSL,\n\t\t\tgettext_noop(\"Also use ssl_passphrase_command during server reload.\"),\n\t\t\tNULL\n\t\t},\n\t\t&ssl_passphrase_command_supports_reload,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"ssl_prefer_server_ciphers\", PGC_SIGHUP, CONN_AUTH_SSL,\n\t\t\tgettext_noop(\"Give priority to server ciphersuite order.\"),\n\t\t\tNULL\n\t\t},\n\t\t&SSLPreferServerCiphers,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"fsync\", PGC_SIGHUP, WAL_SETTINGS,\n\t\t\tgettext_noop(\"Forces synchronization of updates to disk.\"),\n\t\t\tgettext_noop(\"The server will use the fsync() system call in several places to make \"\n\t\t\t\t\t\t \"sure that updates are physically written to disk. This insures \"\n\t\t\t\t\t\t \"that a database cluster will recover to a consistent state after \"\n\t\t\t\t\t\t \"an operating system or hardware crash.\")\n\t\t},\n\t\t&enableFsync,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"ignore_checksum_failure\", PGC_SUSET, DEVELOPER_OPTIONS,\n\t\t\tgettext_noop(\"Continues processing after a checksum failure.\"),\n\t\t\tgettext_noop(\"Detection of a checksum failure normally causes PostgreSQL to \"\n\t\t\t\t\t\t \"report an error, aborting the current transaction. Setting \"\n\t\t\t\t\t\t \"ignore_checksum_failure to true causes the system to ignore the failure \"\n\t\t\t\t\t\t \"(but still report a warning), and continue processing. This \"\n\t\t\t\t\t\t \"behavior could cause crashes or other serious problems. Only \"\n\t\t\t\t\t\t \"has an effect if checksums are enabled.\"),\n\t\t\tGUC_NOT_IN_SAMPLE\n\t\t},\n\t\t&ignore_checksum_failure,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"zero_damaged_pages\", PGC_SUSET, DEVELOPER_OPTIONS,\n\t\t\tgettext_noop(\"Continues processing past damaged page headers.\"),\n\t\t\tgettext_noop(\"Detection of a damaged page header normally causes PostgreSQL to \"\n\t\t\t\t\t\t \"report an error, aborting the current transaction. Setting \"\n\t\t\t\t\t\t \"zero_damaged_pages to true causes the system to instead report a \"\n\t\t\t\t\t\t \"warning, zero out the damaged page, and continue processing. This \"\n\t\t\t\t\t\t \"behavior will destroy data, namely all the rows on the damaged page.\"),\n\t\t\tGUC_NOT_IN_SAMPLE\n\t\t},\n\t\t&zero_damaged_pages,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"full_page_writes\", PGC_SIGHUP, WAL_SETTINGS,\n\t\t\tgettext_noop(\"Writes full pages to WAL when first modified after a checkpoint.\"),\n\t\t\tgettext_noop(\"A page write in process during an operating system crash might be \"\n\t\t\t\t\t\t \"only partially written to disk.  During recovery, the row changes \"\n\t\t\t\t\t\t \"stored in WAL are not enough to recover.  This option writes \"\n\t\t\t\t\t\t \"pages when first modified after a checkpoint to WAL so full recovery \"\n\t\t\t\t\t\t \"is possible.\")\n\t\t},\n\t\t&fullPageWrites,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"wal_log_hints\", PGC_POSTMASTER, WAL_SETTINGS,\n\t\t\tgettext_noop(\"Writes full pages to WAL when first modified after a checkpoint, even for a non-critical modifications.\"),\n\t\t\tNULL\n\t\t},\n\t\t&wal_log_hints,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"wal_compression\", PGC_SUSET, WAL_SETTINGS,\n\t\t\tgettext_noop(\"Compresses full-page writes written in WAL file.\"),\n\t\t\tNULL\n\t\t},\n\t\t&wal_compression,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"log_checkpoints\", PGC_SIGHUP, LOGGING_WHAT,\n\t\t\tgettext_noop(\"Logs each checkpoint.\"),\n\t\t\tNULL\n\t\t},\n\t\t&log_checkpoints,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"log_connections\", PGC_SU_BACKEND, LOGGING_WHAT,\n\t\t\tgettext_noop(\"Logs each successful connection.\"),\n\t\t\tNULL\n\t\t},\n\t\t&Log_connections,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"log_disconnections\", PGC_SU_BACKEND, LOGGING_WHAT,\n\t\t\tgettext_noop(\"Logs end of a session, including duration.\"),\n\t\t\tNULL\n\t\t},\n\t\t&Log_disconnections,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"log_replication_commands\", PGC_SUSET, LOGGING_WHAT,\n\t\t\tgettext_noop(\"Logs each replication command.\"),\n\t\t\tNULL\n\t\t},\n\t\t&log_replication_commands,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"debug_assertions\", PGC_INTERNAL, PRESET_OPTIONS,\n\t\t\tgettext_noop(\"Shows whether the running server has assertion checks enabled.\"),\n\t\t\tNULL,\n\t\t\tGUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE\n\t\t},\n\t\t&assert_enabled,\n#ifdef USE_ASSERT_CHECKING\n\t\ttrue,\n#else\n\t\tfalse,\n#endif\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"exit_on_error\", PGC_USERSET, ERROR_HANDLING_OPTIONS,\n\t\t\tgettext_noop(\"Terminate session on any error.\"),\n\t\t\tNULL\n\t\t},\n\t\t&ExitOnAnyError,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"restart_after_crash\", PGC_SIGHUP, ERROR_HANDLING_OPTIONS,\n\t\t\tgettext_noop(\"Reinitialize server after backend crash.\"),\n\t\t\tNULL\n\t\t},\n\t\t&restart_after_crash,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"log_duration\", PGC_SUSET, LOGGING_WHAT,\n\t\t\tgettext_noop(\"Logs the duration of each completed SQL statement.\"),\n\t\t\tNULL\n\t\t},\n\t\t&log_duration,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"debug_print_parse\", PGC_USERSET, LOGGING_WHAT,\n\t\t\tgettext_noop(\"Logs each query's parse tree.\"),\n\t\t\tNULL\n\t\t},\n\t\t&Debug_print_parse,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"debug_print_rewritten\", PGC_USERSET, LOGGING_WHAT,\n\t\t\tgettext_noop(\"Logs each query's rewritten parse tree.\"),\n\t\t\tNULL\n\t\t},\n\t\t&Debug_print_rewritten,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"debug_print_plan\", PGC_USERSET, LOGGING_WHAT,\n\t\t\tgettext_noop(\"Logs each query's execution plan.\"),\n\t\t\tNULL\n\t\t},\n\t\t&Debug_print_plan,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"debug_pretty_print\", PGC_USERSET, LOGGING_WHAT,\n\t\t\tgettext_noop(\"Indents parse and plan tree displays.\"),\n\t\t\tNULL\n\t\t},\n\t\t&Debug_pretty_print,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"log_parser_stats\", PGC_SUSET, STATS_MONITORING,\n\t\t\tgettext_noop(\"Writes parser performance statistics to the server log.\"),\n\t\t\tNULL\n\t\t},\n\t\t&log_parser_stats,\n\t\tfalse,\n\t\tcheck_stage_log_stats, NULL, NULL\n\t},\n\t{\n\t\t{\"log_planner_stats\", PGC_SUSET, STATS_MONITORING,\n\t\t\tgettext_noop(\"Writes planner performance statistics to the server log.\"),\n\t\t\tNULL\n\t\t},\n\t\t&log_planner_stats,\n\t\tfalse,\n\t\tcheck_stage_log_stats, NULL, NULL\n\t},\n\t{\n\t\t{\"log_executor_stats\", PGC_SUSET, STATS_MONITORING,\n\t\t\tgettext_noop(\"Writes executor performance statistics to the server log.\"),\n\t\t\tNULL\n\t\t},\n\t\t&log_executor_stats,\n\t\tfalse,\n\t\tcheck_stage_log_stats, NULL, NULL\n\t},\n\t{\n\t\t{\"log_statement_stats\", PGC_SUSET, STATS_MONITORING,\n\t\t\tgettext_noop(\"Writes cumulative performance statistics to the server log.\"),\n\t\t\tNULL\n\t\t},\n\t\t&log_statement_stats,\n\t\tfalse,\n\t\tcheck_log_stats, NULL, NULL\n\t},\n#ifdef BTREE_BUILD_STATS\n\t{\n\t\t{\"log_btree_build_stats\", PGC_SUSET, DEVELOPER_OPTIONS,\n\t\t\tgettext_noop(\"Logs system resource usage statistics (memory and CPU) on various B-tree operations.\"),\n\t\t\tNULL,\n\t\t\tGUC_NOT_IN_SAMPLE\n\t\t},\n\t\t&log_btree_build_stats,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n#endif\n\n\t{\n\t\t{\"track_activities\", PGC_SUSET, STATS_COLLECTOR,\n\t\t\tgettext_noop(\"Collects information about executing commands.\"),\n\t\t\tgettext_noop(\"Enables the collection of information on the currently \"\n\t\t\t\t\t\t \"executing command of each session, along with \"\n\t\t\t\t\t\t \"the time at which that command began execution.\")\n\t\t},\n\t\t&pgstat_track_activities,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"track_counts\", PGC_SUSET, STATS_COLLECTOR,\n\t\t\tgettext_noop(\"Collects statistics on database activity.\"),\n\t\t\tNULL\n\t\t},\n\t\t&pgstat_track_counts,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"track_io_timing\", PGC_SUSET, STATS_COLLECTOR,\n\t\t\tgettext_noop(\"Collects timing statistics for database I/O activity.\"),\n\t\t\tNULL\n\t\t},\n\t\t&track_io_timing,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"update_process_title\", PGC_SUSET, PROCESS_TITLE,\n\t\t\tgettext_noop(\"Updates the process title to show the active SQL command.\"),\n\t\t\tgettext_noop(\"Enables updating of the process title every time a new SQL command is received by the server.\")\n\t\t},\n\t\t&update_process_title,\n#ifdef WIN32\n\t\tfalse,\n#else\n\t\ttrue,\n#endif\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"autovacuum\", PGC_SIGHUP, AUTOVACUUM,\n\t\t\tgettext_noop(\"Starts the autovacuum subprocess.\"),\n\t\t\tNULL\n\t\t},\n\t\t&autovacuum_start_daemon,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"trace_notify\", PGC_USERSET, DEVELOPER_OPTIONS,\n\t\t\tgettext_noop(\"Generates debugging output for LISTEN and NOTIFY.\"),\n\t\t\tNULL,\n\t\t\tGUC_NOT_IN_SAMPLE\n\t\t},\n\t\t&Trace_notify,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\n#ifdef LOCK_DEBUG\n\t{\n\t\t{\"trace_locks\", PGC_SUSET, DEVELOPER_OPTIONS,\n\t\t\tgettext_noop(\"Emits information about lock usage.\"),\n\t\t\tNULL,\n\t\t\tGUC_NOT_IN_SAMPLE\n\t\t},\n\t\t&Trace_locks,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"trace_userlocks\", PGC_SUSET, DEVELOPER_OPTIONS,\n\t\t\tgettext_noop(\"Emits information about user lock usage.\"),\n\t\t\tNULL,\n\t\t\tGUC_NOT_IN_SAMPLE\n\t\t},\n\t\t&Trace_userlocks,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"trace_lwlocks\", PGC_SUSET, DEVELOPER_OPTIONS,\n\t\t\tgettext_noop(\"Emits information about lightweight lock usage.\"),\n\t\t\tNULL,\n\t\t\tGUC_NOT_IN_SAMPLE\n\t\t},\n\t\t&Trace_lwlocks,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"debug_deadlocks\", PGC_SUSET, DEVELOPER_OPTIONS,\n\t\t\tgettext_noop(\"Dumps information about all current locks when a deadlock timeout occurs.\"),\n\t\t\tNULL,\n\t\t\tGUC_NOT_IN_SAMPLE\n\t\t},\n\t\t&Debug_deadlocks,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n#endif\n\n\t{\n\t\t{\"log_lock_waits\", PGC_SUSET, LOGGING_WHAT,\n\t\t\tgettext_noop(\"Logs long lock waits.\"),\n\t\t\tNULL\n\t\t},\n\t\t&log_lock_waits,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"log_hostname\", PGC_SIGHUP, LOGGING_WHAT,\n\t\t\tgettext_noop(\"Logs the host name in the connection logs.\"),\n\t\t\tgettext_noop(\"By default, connection logs only show the IP address \"\n\t\t\t\t\t\t \"of the connecting host. If you want them to show the host name you \"\n\t\t\t\t\t\t \"can turn this on, but depending on your host name resolution \"\n\t\t\t\t\t\t \"setup it might impose a non-negligible performance penalty.\")\n\t\t},\n\t\t&log_hostname,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"transform_null_equals\", PGC_USERSET, COMPAT_OPTIONS_CLIENT,\n\t\t\tgettext_noop(\"Treats \\\"expr=NULL\\\" as \\\"expr IS NULL\\\".\"),\n\t\t\tgettext_noop(\"When turned on, expressions of the form expr = NULL \"\n\t\t\t\t\t\t \"(or NULL = expr) are treated as expr IS NULL, that is, they \"\n\t\t\t\t\t\t \"return true if expr evaluates to the null value, and false \"\n\t\t\t\t\t\t \"otherwise. The correct behavior of expr = NULL is to always \"\n\t\t\t\t\t\t \"return null (unknown).\")\n\t\t},\n\t\t&Transform_null_equals,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"db_user_namespace\", PGC_SIGHUP, CONN_AUTH_AUTH,\n\t\t\tgettext_noop(\"Enables per-database user names.\"),\n\t\t\tNULL\n\t\t},\n\t\t&Db_user_namespace,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"default_transaction_read_only\", PGC_USERSET, CLIENT_CONN_STATEMENT,\n\t\t\tgettext_noop(\"Sets the default read-only status of new transactions.\"),\n\t\t\tNULL\n\t\t},\n\t\t&DefaultXactReadOnly,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"transaction_read_only\", PGC_USERSET, CLIENT_CONN_STATEMENT,\n\t\t\tgettext_noop(\"Sets the current transaction's read-only status.\"),\n\t\t\tNULL,\n\t\t\tGUC_NO_RESET_ALL | GUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE\n\t\t},\n\t\t&XactReadOnly,\n\t\tfalse,\n\t\tcheck_transaction_read_only, NULL, NULL\n\t},\n\t{\n\t\t{\"default_transaction_deferrable\", PGC_USERSET, CLIENT_CONN_STATEMENT,\n\t\t\tgettext_noop(\"Sets the default deferrable status of new transactions.\"),\n\t\t\tNULL\n\t\t},\n\t\t&DefaultXactDeferrable,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"transaction_deferrable\", PGC_USERSET, CLIENT_CONN_STATEMENT,\n\t\t\tgettext_noop(\"Whether to defer a read-only serializable transaction until it can be executed with no possible serialization failures.\"),\n\t\t\tNULL,\n\t\t\tGUC_NO_RESET_ALL | GUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE\n\t\t},\n\t\t&XactDeferrable,\n\t\tfalse,\n\t\tcheck_transaction_deferrable, NULL, NULL\n\t},\n\t{\n\t\t{\"row_security\", PGC_USERSET, CLIENT_CONN_STATEMENT,\n\t\t\tgettext_noop(\"Enable row security.\"),\n\t\t\tgettext_noop(\"When enabled, row security will be applied to all users.\")\n\t\t},\n\t\t&row_security,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"check_function_bodies\", PGC_USERSET, CLIENT_CONN_STATEMENT,\n\t\t\tgettext_noop(\"Check function bodies during CREATE FUNCTION.\"),\n\t\t\tNULL\n\t\t},\n\t\t&check_function_bodies,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"array_nulls\", PGC_USERSET, COMPAT_OPTIONS_PREVIOUS,\n\t\t\tgettext_noop(\"Enable input of NULL elements in arrays.\"),\n\t\t\tgettext_noop(\"When turned on, unquoted NULL in an array input \"\n\t\t\t\t\t\t \"value means a null value; \"\n\t\t\t\t\t\t \"otherwise it is taken literally.\")\n\t\t},\n\t\t&Array_nulls,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"default_with_oids\", PGC_USERSET, COMPAT_OPTIONS_PREVIOUS,\n\t\t\tgettext_noop(\"Create new tables with OIDs by default.\"),\n\t\t\tNULL\n\t\t},\n\t\t&default_with_oids,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"logging_collector\", PGC_POSTMASTER, LOGGING_WHERE,\n\t\t\tgettext_noop(\"Start a subprocess to capture stderr output and/or csvlogs into log files.\"),\n\t\t\tNULL\n\t\t},\n\t\t&Logging_collector,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"log_truncate_on_rotation\", PGC_SIGHUP, LOGGING_WHERE,\n\t\t\tgettext_noop(\"Truncate existing log files of same name during log rotation.\"),\n\t\t\tNULL\n\t\t},\n\t\t&Log_truncate_on_rotation,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\n#ifdef TRACE_SORT\n\t{\n\t\t{\"trace_sort\", PGC_USERSET, DEVELOPER_OPTIONS,\n\t\t\tgettext_noop(\"Emit information about resource usage in sorting.\"),\n\t\t\tNULL,\n\t\t\tGUC_NOT_IN_SAMPLE\n\t\t},\n\t\t&trace_sort,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n#endif\n\n#ifdef TRACE_SYNCSCAN\n\t/* this is undocumented because not exposed in a standard build */\n\t{\n\t\t{\"trace_syncscan\", PGC_USERSET, DEVELOPER_OPTIONS,\n\t\t\tgettext_noop(\"Generate debugging output for synchronized scanning.\"),\n\t\t\tNULL,\n\t\t\tGUC_NOT_IN_SAMPLE\n\t\t},\n\t\t&trace_syncscan,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n#endif\n\n#ifdef DEBUG_BOUNDED_SORT\n\t/* this is undocumented because not exposed in a standard build */\n\t{\n\t\t{\n\t\t\t\"optimize_bounded_sort\", PGC_USERSET, QUERY_TUNING_METHOD,\n\t\t\tgettext_noop(\"Enable bounded sorting using heap sort.\"),\n\t\t\tNULL,\n\t\t\tGUC_NOT_IN_SAMPLE\n\t\t},\n\t\t&optimize_bounded_sort,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n#endif\n\n#ifdef WAL_DEBUG\n\t{\n\t\t{\"wal_debug\", PGC_SUSET, DEVELOPER_OPTIONS,\n\t\t\tgettext_noop(\"Emit WAL-related debugging output.\"),\n\t\t\tNULL,\n\t\t\tGUC_NOT_IN_SAMPLE\n\t\t},\n\t\t&XLOG_DEBUG,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n#endif\n\n\t{\n\t\t{\"integer_datetimes\", PGC_INTERNAL, PRESET_OPTIONS,\n\t\t\tgettext_noop(\"Datetimes are integer based.\"),\n\t\t\tNULL,\n\t\t\tGUC_REPORT | GUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE\n\t\t},\n\t\t&integer_datetimes,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"krb_caseins_users\", PGC_SIGHUP, CONN_AUTH_AUTH,\n\t\t\tgettext_noop(\"Sets whether Kerberos and GSSAPI user names should be treated as case-insensitive.\"),\n\t\t\tNULL\n\t\t},\n\t\t&pg_krb_caseins_users,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"escape_string_warning\", PGC_USERSET, COMPAT_OPTIONS_PREVIOUS,\n\t\t\tgettext_noop(\"Warn about backslash escapes in ordinary string literals.\"),\n\t\t\tNULL\n\t\t},\n\t\t&escape_string_warning,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"standard_conforming_strings\", PGC_USERSET, COMPAT_OPTIONS_PREVIOUS,\n\t\t\tgettext_noop(\"Causes '...' strings to treat backslashes literally.\"),\n\t\t\tNULL,\n\t\t\tGUC_REPORT\n\t\t},\n\t\t&standard_conforming_strings,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"synchronize_seqscans\", PGC_USERSET, COMPAT_OPTIONS_PREVIOUS,\n\t\t\tgettext_noop(\"Enable synchronized sequential scans.\"),\n\t\t\tNULL\n\t\t},\n\t\t&synchronize_seqscans,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"hot_standby\", PGC_POSTMASTER, REPLICATION_STANDBY,\n\t\t\tgettext_noop(\"Allows connections and queries during recovery.\"),\n\t\t\tNULL\n\t\t},\n\t\t&EnableHotStandby,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"hot_standby_feedback\", PGC_SIGHUP, REPLICATION_STANDBY,\n\t\t\tgettext_noop(\"Allows feedback from a hot standby to the primary that will avoid query conflicts.\"),\n\t\t\tNULL\n\t\t},\n\t\t&hot_standby_feedback,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"allow_system_table_mods\", PGC_POSTMASTER, DEVELOPER_OPTIONS,\n\t\t\tgettext_noop(\"Allows modifications of the structure of system tables.\"),\n\t\t\tNULL,\n\t\t\tGUC_NOT_IN_SAMPLE\n\t\t},\n\t\t&allowSystemTableMods,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"ignore_system_indexes\", PGC_BACKEND, DEVELOPER_OPTIONS,\n\t\t\tgettext_noop(\"Disables reading from system indexes.\"),\n\t\t\tgettext_noop(\"It does not prevent updating the indexes, so it is safe \"\n\t\t\t\t\t\t \"to use.  The worst consequence is slowness.\"),\n\t\t\tGUC_NOT_IN_SAMPLE\n\t\t},\n\t\t&IgnoreSystemIndexes,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"lo_compat_privileges\", PGC_SUSET, COMPAT_OPTIONS_PREVIOUS,\n\t\t\tgettext_noop(\"Enables backward compatibility mode for privilege checks on large objects.\"),\n\t\t\tgettext_noop(\"Skips privilege checks when reading or modifying large objects, \"\n\t\t\t\t\t\t \"for compatibility with PostgreSQL releases prior to 9.0.\")\n\t\t},\n\t\t&lo_compat_privileges,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"operator_precedence_warning\", PGC_USERSET, COMPAT_OPTIONS_PREVIOUS,\n\t\t\tgettext_noop(\"Emit a warning for constructs that changed meaning since PostgreSQL 9.4.\"),\n\t\t\tNULL,\n\t\t},\n\t\t&operator_precedence_warning,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"quote_all_identifiers\", PGC_USERSET, COMPAT_OPTIONS_PREVIOUS,\n\t\t\tgettext_noop(\"When generating SQL fragments, quote all identifiers.\"),\n\t\t\tNULL,\n\t\t},\n\t\t&quote_all_identifiers,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"data_checksums\", PGC_INTERNAL, PRESET_OPTIONS,\n\t\t\tgettext_noop(\"Shows whether data checksums are turned on for this cluster.\"),\n\t\t\tNULL,\n\t\t\tGUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE\n\t\t},\n\t\t&data_checksums,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"syslog_sequence_numbers\", PGC_SIGHUP, LOGGING_WHERE,\n\t\t\tgettext_noop(\"Add sequence number to syslog messages to avoid duplicate suppression.\"),\n\t\t\tNULL\n\t\t},\n\t\t&syslog_sequence_numbers,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"syslog_split_messages\", PGC_SIGHUP, LOGGING_WHERE,\n\t\t\tgettext_noop(\"Split messages sent to syslog by lines and to fit into 1024 bytes.\"),\n\t\t\tNULL\n\t\t},\n\t\t&syslog_split_messages,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"parallel_leader_participation\", PGC_USERSET, RESOURCES_ASYNCHRONOUS,\n\t\t\tgettext_noop(\"Controls whether Gather and Gather Merge also run subplans.\"),\n\t\t\tgettext_noop(\"Should gather nodes also run subplans, or just gather tuples?\")\n\t\t},\n\t\t&parallel_leader_participation,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"jit\", PGC_USERSET, QUERY_TUNING_OTHER,\n\t\t\tgettext_noop(\"Allow JIT compilation.\"),\n\t\t\tNULL\n\t\t},\n\t\t&jit_enabled,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"jit_debugging_support\", PGC_SU_BACKEND, DEVELOPER_OPTIONS,\n\t\t\tgettext_noop(\"Register JIT compiled function with debugger.\"),\n\t\t\tNULL,\n\t\t\tGUC_NOT_IN_SAMPLE\n\t\t},\n\t\t&jit_debugging_support,\n\t\tfalse,\n\n\t\t/*\n\t\t * This is not guaranteed to be available, but given it's a developer\n\t\t * oriented option, it doesn't seem worth adding code checking\n\t\t * availability.\n\t\t */\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"jit_dump_bitcode\", PGC_SUSET, DEVELOPER_OPTIONS,\n\t\t\tgettext_noop(\"Write out LLVM bitcode to facilitate JIT debugging.\"),\n\t\t\tNULL,\n\t\t\tGUC_NOT_IN_SAMPLE\n\t\t},\n\t\t&jit_dump_bitcode,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"jit_expressions\", PGC_USERSET, DEVELOPER_OPTIONS,\n\t\t\tgettext_noop(\"Allow JIT compilation of expressions.\"),\n\t\t\tNULL,\n\t\t\tGUC_NOT_IN_SAMPLE\n\t\t},\n\t\t&jit_expressions,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"jit_profiling_support\", PGC_SU_BACKEND, DEVELOPER_OPTIONS,\n\t\t\tgettext_noop(\"Register JIT compiled function with perf profiler.\"),\n\t\t\tNULL,\n\t\t\tGUC_NOT_IN_SAMPLE\n\t\t},\n\t\t&jit_profiling_support,\n\t\tfalse,\n\n\t\t/*\n\t\t * This is not guaranteed to be available, but given it's a developer\n\t\t * oriented option, it doesn't seem worth adding code checking\n\t\t * availability.\n\t\t */\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"jit_tuple_deforming\", PGC_USERSET, DEVELOPER_OPTIONS,\n\t\t\tgettext_noop(\"Allow JIT compilation of tuple deforming.\"),\n\t\t\tNULL,\n\t\t\tGUC_NOT_IN_SAMPLE\n\t\t},\n\t\t&jit_tuple_deforming,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"data_sync_retry\", PGC_POSTMASTER, ERROR_HANDLING_OPTIONS,\n\t\t\tgettext_noop(\"Whether to continue running after a failure to sync data files.\"),\n\t\t},\n\t\t&data_sync_retry,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\n\t/* End-of-list marker */\n\t{\n\t\t{NULL, 0, 0, NULL, NULL}, NULL, false, NULL, NULL, NULL\n\t}\n};",
            "static struct config_int ConfigureNamesInt[] =\n{\n\t{\n\t\t{\"archive_timeout\", PGC_SIGHUP, WAL_ARCHIVING,\n\t\t\tgettext_noop(\"Forces a switch to the next WAL file if a \"\n\t\t\t\t\t\t \"new file has not been started within N seconds.\"),\n\t\t\tNULL,\n\t\t\tGUC_UNIT_S\n\t\t},\n\t\t&XLogArchiveTimeout,\n\t\t0, 0, INT_MAX / 2,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"post_auth_delay\", PGC_BACKEND, DEVELOPER_OPTIONS,\n\t\t\tgettext_noop(\"Waits N seconds on connection startup after authentication.\"),\n\t\t\tgettext_noop(\"This allows attaching a debugger to the process.\"),\n\t\t\tGUC_NOT_IN_SAMPLE | GUC_UNIT_S\n\t\t},\n\t\t&PostAuthDelay,\n\t\t0, 0, INT_MAX / 1000000,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"default_statistics_target\", PGC_USERSET, QUERY_TUNING_OTHER,\n\t\t\tgettext_noop(\"Sets the default statistics target.\"),\n\t\t\tgettext_noop(\"This applies to table columns that have not had a \"\n\t\t\t\t\t\t \"column-specific target set via ALTER TABLE SET STATISTICS.\")\n\t\t},\n\t\t&default_statistics_target,\n\t\t100, 1, 10000,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"from_collapse_limit\", PGC_USERSET, QUERY_TUNING_OTHER,\n\t\t\tgettext_noop(\"Sets the FROM-list size beyond which subqueries \"\n\t\t\t\t\t\t \"are not collapsed.\"),\n\t\t\tgettext_noop(\"The planner will merge subqueries into upper \"\n\t\t\t\t\t\t \"queries if the resulting FROM list would have no more than \"\n\t\t\t\t\t\t \"this many items.\")\n\t\t},\n\t\t&from_collapse_limit,\n\t\t8, 1, INT_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"join_collapse_limit\", PGC_USERSET, QUERY_TUNING_OTHER,\n\t\t\tgettext_noop(\"Sets the FROM-list size beyond which JOIN \"\n\t\t\t\t\t\t \"constructs are not flattened.\"),\n\t\t\tgettext_noop(\"The planner will flatten explicit JOIN \"\n\t\t\t\t\t\t \"constructs into lists of FROM items whenever a \"\n\t\t\t\t\t\t \"list of no more than this many items would result.\")\n\t\t},\n\t\t&join_collapse_limit,\n\t\t8, 1, INT_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"geqo_threshold\", PGC_USERSET, QUERY_TUNING_GEQO,\n\t\t\tgettext_noop(\"Sets the threshold of FROM items beyond which GEQO is used.\"),\n\t\t\tNULL\n\t\t},\n\t\t&geqo_threshold,\n\t\t12, 2, INT_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"geqo_effort\", PGC_USERSET, QUERY_TUNING_GEQO,\n\t\t\tgettext_noop(\"GEQO: effort is used to set the default for other GEQO parameters.\"),\n\t\t\tNULL\n\t\t},\n\t\t&Geqo_effort,\n\t\tDEFAULT_GEQO_EFFORT, MIN_GEQO_EFFORT, MAX_GEQO_EFFORT,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"geqo_pool_size\", PGC_USERSET, QUERY_TUNING_GEQO,\n\t\t\tgettext_noop(\"GEQO: number of individuals in the population.\"),\n\t\t\tgettext_noop(\"Zero selects a suitable default value.\")\n\t\t},\n\t\t&Geqo_pool_size,\n\t\t0, 0, INT_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"geqo_generations\", PGC_USERSET, QUERY_TUNING_GEQO,\n\t\t\tgettext_noop(\"GEQO: number of iterations of the algorithm.\"),\n\t\t\tgettext_noop(\"Zero selects a suitable default value.\")\n\t\t},\n\t\t&Geqo_generations,\n\t\t0, 0, INT_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t/* This is PGC_SUSET to prevent hiding from log_lock_waits. */\n\t\t{\"deadlock_timeout\", PGC_SUSET, LOCK_MANAGEMENT,\n\t\t\tgettext_noop(\"Sets the time to wait on a lock before checking for deadlock.\"),\n\t\t\tNULL,\n\t\t\tGUC_UNIT_MS\n\t\t},\n\t\t&DeadlockTimeout,\n\t\t1000, 1, INT_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"max_standby_archive_delay\", PGC_SIGHUP, REPLICATION_STANDBY,\n\t\t\tgettext_noop(\"Sets the maximum delay before canceling queries when a hot standby server is processing archived WAL data.\"),\n\t\t\tNULL,\n\t\t\tGUC_UNIT_MS\n\t\t},\n\t\t&max_standby_archive_delay,\n\t\t30 * 1000, -1, INT_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"max_standby_streaming_delay\", PGC_SIGHUP, REPLICATION_STANDBY,\n\t\t\tgettext_noop(\"Sets the maximum delay before canceling queries when a hot standby server is processing streamed WAL data.\"),\n\t\t\tNULL,\n\t\t\tGUC_UNIT_MS\n\t\t},\n\t\t&max_standby_streaming_delay,\n\t\t30 * 1000, -1, INT_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"wal_receiver_status_interval\", PGC_SIGHUP, REPLICATION_STANDBY,\n\t\t\tgettext_noop(\"Sets the maximum interval between WAL receiver status reports to the primary.\"),\n\t\t\tNULL,\n\t\t\tGUC_UNIT_S\n\t\t},\n\t\t&wal_receiver_status_interval,\n\t\t10, 0, INT_MAX / 1000,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"wal_receiver_timeout\", PGC_SIGHUP, REPLICATION_STANDBY,\n\t\t\tgettext_noop(\"Sets the maximum wait time to receive data from the primary.\"),\n\t\t\tNULL,\n\t\t\tGUC_UNIT_MS\n\t\t},\n\t\t&wal_receiver_timeout,\n\t\t60 * 1000, 0, INT_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"max_connections\", PGC_POSTMASTER, CONN_AUTH_SETTINGS,\n\t\t\tgettext_noop(\"Sets the maximum number of concurrent connections.\"),\n\t\t\tNULL\n\t\t},\n\t\t&MaxConnections,\n\t\t100, 1, MAX_BACKENDS,\n\t\tcheck_maxconnections, NULL, NULL\n\t},\n\n\t{\n\t\t/* see max_connections and max_wal_senders */\n\t\t{\"superuser_reserved_connections\", PGC_POSTMASTER, CONN_AUTH_SETTINGS,\n\t\t\tgettext_noop(\"Sets the number of connection slots reserved for superusers.\"),\n\t\t\tNULL\n\t\t},\n\t\t&ReservedBackends,\n\t\t3, 0, MAX_BACKENDS,\n\t\tNULL, NULL, NULL\n\t},\n\n\t/*\n\t * We sometimes multiply the number of shared buffers by two without\n\t * checking for overflow, so we mustn't allow more than INT_MAX / 2.\n\t */\n\t{\n\t\t{\"shared_buffers\", PGC_POSTMASTER, RESOURCES_MEM,\n\t\t\tgettext_noop(\"Sets the number of shared memory buffers used by the server.\"),\n\t\t\tNULL,\n\t\t\tGUC_UNIT_BLOCKS\n\t\t},\n\t\t&NBuffers,\n\t\t1024, 16, INT_MAX / 2,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"temp_buffers\", PGC_USERSET, RESOURCES_MEM,\n\t\t\tgettext_noop(\"Sets the maximum number of temporary buffers used by each session.\"),\n\t\t\tNULL,\n\t\t\tGUC_UNIT_BLOCKS\n\t\t},\n\t\t&num_temp_buffers,\n\t\t1024, 100, INT_MAX / 2,\n\t\tcheck_temp_buffers, NULL, NULL\n\t},\n\n\t{\n\t\t{\"port\", PGC_POSTMASTER, CONN_AUTH_SETTINGS,\n\t\t\tgettext_noop(\"Sets the TCP port the server listens on.\"),\n\t\t\tNULL\n\t\t},\n\t\t&PostPortNumber,\n\t\tDEF_PGPORT, 1, 65535,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"unix_socket_permissions\", PGC_POSTMASTER, CONN_AUTH_SETTINGS,\n\t\t\tgettext_noop(\"Sets the access permissions of the Unix-domain socket.\"),\n\t\t\tgettext_noop(\"Unix-domain sockets use the usual Unix file system \"\n\t\t\t\t\t\t \"permission set. The parameter value is expected \"\n\t\t\t\t\t\t \"to be a numeric mode specification in the form \"\n\t\t\t\t\t\t \"accepted by the chmod and umask system calls. \"\n\t\t\t\t\t\t \"(To use the customary octal format the number must \"\n\t\t\t\t\t\t \"start with a 0 (zero).)\")\n\t\t},\n\t\t&Unix_socket_permissions,\n\t\t0777, 0000, 0777,\n\t\tNULL, NULL, show_unix_socket_permissions\n\t},\n\n\t{\n\t\t{\"log_file_mode\", PGC_SIGHUP, LOGGING_WHERE,\n\t\t\tgettext_noop(\"Sets the file permissions for log files.\"),\n\t\t\tgettext_noop(\"The parameter value is expected \"\n\t\t\t\t\t\t \"to be a numeric mode specification in the form \"\n\t\t\t\t\t\t \"accepted by the chmod and umask system calls. \"\n\t\t\t\t\t\t \"(To use the customary octal format the number must \"\n\t\t\t\t\t\t \"start with a 0 (zero).)\")\n\t\t},\n\t\t&Log_file_mode,\n\t\t0600, 0000, 0777,\n\t\tNULL, NULL, show_log_file_mode\n\t},\n\n\n\t{\n\t\t{\"data_directory_mode\", PGC_INTERNAL, PRESET_OPTIONS,\n\t\t\tgettext_noop(\"Mode of the data directory.\"),\n\t\t\tgettext_noop(\"The parameter value is a numeric mode specification \"\n\t\t\t\t\t\t \"in the form accepted by the chmod and umask system \"\n\t\t\t\t\t\t \"calls. (To use the customary octal format the number \"\n\t\t\t\t\t\t \"must start with a 0 (zero).)\"),\n\t\t\tGUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE\n\t\t},\n\t\t&data_directory_mode,\n\t\t0700, 0000, 0777,\n\t\tNULL, NULL, show_data_directory_mode\n\t},\n\n\t{\n\t\t{\"work_mem\", PGC_USERSET, RESOURCES_MEM,\n\t\t\tgettext_noop(\"Sets the maximum memory to be used for query workspaces.\"),\n\t\t\tgettext_noop(\"This much memory can be used by each internal \"\n\t\t\t\t\t\t \"sort operation and hash table before switching to \"\n\t\t\t\t\t\t \"temporary disk files.\"),\n\t\t\tGUC_UNIT_KB\n\t\t},\n\t\t&work_mem,\n\t\t4096, 64, MAX_KILOBYTES,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"maintenance_work_mem\", PGC_USERSET, RESOURCES_MEM,\n\t\t\tgettext_noop(\"Sets the maximum memory to be used for maintenance operations.\"),\n\t\t\tgettext_noop(\"This includes operations such as VACUUM and CREATE INDEX.\"),\n\t\t\tGUC_UNIT_KB\n\t\t},\n\t\t&maintenance_work_mem,\n\t\t65536, 1024, MAX_KILOBYTES,\n\t\tNULL, NULL, NULL\n\t},\n\n\t/*\n\t * We use the hopefully-safely-small value of 100kB as the compiled-in\n\t * default for max_stack_depth.  InitializeGUCOptions will increase it if\n\t * possible, depending on the actual platform-specific stack limit.\n\t */\n\t{\n\t\t{\"max_stack_depth\", PGC_SUSET, RESOURCES_MEM,\n\t\t\tgettext_noop(\"Sets the maximum stack depth, in kilobytes.\"),\n\t\t\tNULL,\n\t\t\tGUC_UNIT_KB\n\t\t},\n\t\t&max_stack_depth,\n\t\t100, 100, MAX_KILOBYTES,\n\t\tcheck_max_stack_depth, assign_max_stack_depth, NULL\n\t},\n\n\t{\n\t\t{\"temp_file_limit\", PGC_SUSET, RESOURCES_DISK,\n\t\t\tgettext_noop(\"Limits the total size of all temporary files used by each process.\"),\n\t\t\tgettext_noop(\"-1 means no limit.\"),\n\t\t\tGUC_UNIT_KB\n\t\t},\n\t\t&temp_file_limit,\n\t\t-1, -1, INT_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"vacuum_cost_page_hit\", PGC_USERSET, RESOURCES_VACUUM_DELAY,\n\t\t\tgettext_noop(\"Vacuum cost for a page found in the buffer cache.\"),\n\t\t\tNULL\n\t\t},\n\t\t&VacuumCostPageHit,\n\t\t1, 0, 10000,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"vacuum_cost_page_miss\", PGC_USERSET, RESOURCES_VACUUM_DELAY,\n\t\t\tgettext_noop(\"Vacuum cost for a page not found in the buffer cache.\"),\n\t\t\tNULL\n\t\t},\n\t\t&VacuumCostPageMiss,\n\t\t10, 0, 10000,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"vacuum_cost_page_dirty\", PGC_USERSET, RESOURCES_VACUUM_DELAY,\n\t\t\tgettext_noop(\"Vacuum cost for a page dirtied by vacuum.\"),\n\t\t\tNULL\n\t\t},\n\t\t&VacuumCostPageDirty,\n\t\t20, 0, 10000,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"vacuum_cost_limit\", PGC_USERSET, RESOURCES_VACUUM_DELAY,\n\t\t\tgettext_noop(\"Vacuum cost amount available before napping.\"),\n\t\t\tNULL\n\t\t},\n\t\t&VacuumCostLimit,\n\t\t200, 1, 10000,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"vacuum_cost_delay\", PGC_USERSET, RESOURCES_VACUUM_DELAY,\n\t\t\tgettext_noop(\"Vacuum cost delay in milliseconds.\"),\n\t\t\tNULL,\n\t\t\tGUC_UNIT_MS\n\t\t},\n\t\t&VacuumCostDelay,\n\t\t0, 0, 100,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"autovacuum_vacuum_cost_delay\", PGC_SIGHUP, AUTOVACUUM,\n\t\t\tgettext_noop(\"Vacuum cost delay in milliseconds, for autovacuum.\"),\n\t\t\tNULL,\n\t\t\tGUC_UNIT_MS\n\t\t},\n\t\t&autovacuum_vac_cost_delay,\n\t\t20, -1, 100,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"autovacuum_vacuum_cost_limit\", PGC_SIGHUP, AUTOVACUUM,\n\t\t\tgettext_noop(\"Vacuum cost amount available before napping, for autovacuum.\"),\n\t\t\tNULL\n\t\t},\n\t\t&autovacuum_vac_cost_limit,\n\t\t-1, -1, 10000,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"max_files_per_process\", PGC_POSTMASTER, RESOURCES_KERNEL,\n\t\t\tgettext_noop(\"Sets the maximum number of simultaneously open files for each server process.\"),\n\t\t\tNULL\n\t\t},\n\t\t&max_files_per_process,\n\t\t1000, 25, INT_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\n\t/*\n\t * See also CheckRequiredParameterValues() if this parameter changes\n\t */\n\t{\n\t\t{\"max_prepared_transactions\", PGC_POSTMASTER, RESOURCES_MEM,\n\t\t\tgettext_noop(\"Sets the maximum number of simultaneously prepared transactions.\"),\n\t\t\tNULL\n\t\t},\n\t\t&max_prepared_xacts,\n\t\t0, 0, MAX_BACKENDS,\n\t\tNULL, NULL, NULL\n\t},\n\n#ifdef LOCK_DEBUG\n\t{\n\t\t{\"trace_lock_oidmin\", PGC_SUSET, DEVELOPER_OPTIONS,\n\t\t\tgettext_noop(\"Sets the minimum OID of tables for tracking locks.\"),\n\t\t\tgettext_noop(\"Is used to avoid output on system tables.\"),\n\t\t\tGUC_NOT_IN_SAMPLE\n\t\t},\n\t\t&Trace_lock_oidmin,\n\t\tFirstNormalObjectId, 0, INT_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"trace_lock_table\", PGC_SUSET, DEVELOPER_OPTIONS,\n\t\t\tgettext_noop(\"Sets the OID of the table with unconditionally lock tracing.\"),\n\t\t\tNULL,\n\t\t\tGUC_NOT_IN_SAMPLE\n\t\t},\n\t\t&Trace_lock_table,\n\t\t0, 0, INT_MAX,\n\t\tNULL, NULL, NULL\n\t},\n#endif\n\n\t{\n\t\t{\"statement_timeout\", PGC_USERSET, CLIENT_CONN_STATEMENT,\n\t\t\tgettext_noop(\"Sets the maximum allowed duration of any statement.\"),\n\t\t\tgettext_noop(\"A value of 0 turns off the timeout.\"),\n\t\t\tGUC_UNIT_MS\n\t\t},\n\t\t&StatementTimeout,\n\t\t0, 0, INT_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"lock_timeout\", PGC_USERSET, CLIENT_CONN_STATEMENT,\n\t\t\tgettext_noop(\"Sets the maximum allowed duration of any wait for a lock.\"),\n\t\t\tgettext_noop(\"A value of 0 turns off the timeout.\"),\n\t\t\tGUC_UNIT_MS\n\t\t},\n\t\t&LockTimeout,\n\t\t0, 0, INT_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"idle_in_transaction_session_timeout\", PGC_USERSET, CLIENT_CONN_STATEMENT,\n\t\t\tgettext_noop(\"Sets the maximum allowed duration of any idling transaction.\"),\n\t\t\tgettext_noop(\"A value of 0 turns off the timeout.\"),\n\t\t\tGUC_UNIT_MS\n\t\t},\n\t\t&IdleInTransactionSessionTimeout,\n\t\t0, 0, INT_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"vacuum_freeze_min_age\", PGC_USERSET, CLIENT_CONN_STATEMENT,\n\t\t\tgettext_noop(\"Minimum age at which VACUUM should freeze a table row.\"),\n\t\t\tNULL\n\t\t},\n\t\t&vacuum_freeze_min_age,\n\t\t50000000, 0, 1000000000,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"vacuum_freeze_table_age\", PGC_USERSET, CLIENT_CONN_STATEMENT,\n\t\t\tgettext_noop(\"Age at which VACUUM should scan whole table to freeze tuples.\"),\n\t\t\tNULL\n\t\t},\n\t\t&vacuum_freeze_table_age,\n\t\t150000000, 0, 2000000000,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"vacuum_multixact_freeze_min_age\", PGC_USERSET, CLIENT_CONN_STATEMENT,\n\t\t\tgettext_noop(\"Minimum age at which VACUUM should freeze a MultiXactId in a table row.\"),\n\t\t\tNULL\n\t\t},\n\t\t&vacuum_multixact_freeze_min_age,\n\t\t5000000, 0, 1000000000,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"vacuum_multixact_freeze_table_age\", PGC_USERSET, CLIENT_CONN_STATEMENT,\n\t\t\tgettext_noop(\"Multixact age at which VACUUM should scan whole table to freeze tuples.\"),\n\t\t\tNULL\n\t\t},\n\t\t&vacuum_multixact_freeze_table_age,\n\t\t150000000, 0, 2000000000,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"vacuum_defer_cleanup_age\", PGC_SIGHUP, REPLICATION_MASTER,\n\t\t\tgettext_noop(\"Number of transactions by which VACUUM and HOT cleanup should be deferred, if any.\"),\n\t\t\tNULL\n\t\t},\n\t\t&vacuum_defer_cleanup_age,\n\t\t0, 0, 1000000,\n\t\tNULL, NULL, NULL\n\t},\n\n\t/*\n\t * See also CheckRequiredParameterValues() if this parameter changes\n\t */\n\t{\n\t\t{\"max_locks_per_transaction\", PGC_POSTMASTER, LOCK_MANAGEMENT,\n\t\t\tgettext_noop(\"Sets the maximum number of locks per transaction.\"),\n\t\t\tgettext_noop(\"The shared lock table is sized on the assumption that \"\n\t\t\t\t\t\t \"at most max_locks_per_transaction * max_connections distinct \"\n\t\t\t\t\t\t \"objects will need to be locked at any one time.\")\n\t\t},\n\t\t&max_locks_per_xact,\n\t\t64, 10, INT_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"max_pred_locks_per_transaction\", PGC_POSTMASTER, LOCK_MANAGEMENT,\n\t\t\tgettext_noop(\"Sets the maximum number of predicate locks per transaction.\"),\n\t\t\tgettext_noop(\"The shared predicate lock table is sized on the assumption that \"\n\t\t\t\t\t\t \"at most max_pred_locks_per_transaction * max_connections distinct \"\n\t\t\t\t\t\t \"objects will need to be locked at any one time.\")\n\t\t},\n\t\t&max_predicate_locks_per_xact,\n\t\t64, 10, INT_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"max_pred_locks_per_relation\", PGC_SIGHUP, LOCK_MANAGEMENT,\n\t\t\tgettext_noop(\"Sets the maximum number of predicate-locked pages and tuples per relation.\"),\n\t\t\tgettext_noop(\"If more than this total of pages and tuples in the same relation are locked \"\n\t\t\t\t\t\t \"by a connection, those locks are replaced by a relation-level lock.\")\n\t\t},\n\t\t&max_predicate_locks_per_relation,\n\t\t-2, INT_MIN, INT_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"max_pred_locks_per_page\", PGC_SIGHUP, LOCK_MANAGEMENT,\n\t\t\tgettext_noop(\"Sets the maximum number of predicate-locked tuples per page.\"),\n\t\t\tgettext_noop(\"If more than this number of tuples on the same page are locked \"\n\t\t\t\t\t\t \"by a connection, those locks are replaced by a page-level lock.\")\n\t\t},\n\t\t&max_predicate_locks_per_page,\n\t\t2, 0, INT_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"authentication_timeout\", PGC_SIGHUP, CONN_AUTH_AUTH,\n\t\t\tgettext_noop(\"Sets the maximum allowed time to complete client authentication.\"),\n\t\t\tNULL,\n\t\t\tGUC_UNIT_S\n\t\t},\n\t\t&AuthenticationTimeout,\n\t\t60, 1, 600,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t/* Not for general use */\n\t\t{\"pre_auth_delay\", PGC_SIGHUP, DEVELOPER_OPTIONS,\n\t\t\tgettext_noop(\"Waits N seconds on connection startup before authentication.\"),\n\t\t\tgettext_noop(\"This allows attaching a debugger to the process.\"),\n\t\t\tGUC_NOT_IN_SAMPLE | GUC_UNIT_S\n\t\t},\n\t\t&PreAuthDelay,\n\t\t0, 0, 60,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"wal_keep_segments\", PGC_SIGHUP, REPLICATION_SENDING,\n\t\t\tgettext_noop(\"Sets the number of WAL files held for standby servers.\"),\n\t\t\tNULL\n\t\t},\n\t\t&wal_keep_segments,\n\t\t0, 0, INT_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"min_wal_size\", PGC_SIGHUP, WAL_CHECKPOINTS,\n\t\t\tgettext_noop(\"Sets the minimum size to shrink the WAL to.\"),\n\t\t\tNULL,\n\t\t\tGUC_UNIT_MB\n\t\t},\n\t\t&min_wal_size_mb,\n\t\tDEFAULT_MIN_WAL_SEGS * (DEFAULT_XLOG_SEG_SIZE / (1024 * 1024)),\n\t\t2, MAX_KILOBYTES,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"max_wal_size\", PGC_SIGHUP, WAL_CHECKPOINTS,\n\t\t\tgettext_noop(\"Sets the WAL size that triggers a checkpoint.\"),\n\t\t\tNULL,\n\t\t\tGUC_UNIT_MB\n\t\t},\n\t\t&max_wal_size_mb,\n\t\tDEFAULT_MAX_WAL_SEGS * (DEFAULT_XLOG_SEG_SIZE / (1024 * 1024)),\n\t\t2, MAX_KILOBYTES,\n\t\tNULL, assign_max_wal_size, NULL\n\t},\n\n\t{\n\t\t{\"checkpoint_timeout\", PGC_SIGHUP, WAL_CHECKPOINTS,\n\t\t\tgettext_noop(\"Sets the maximum time between automatic WAL checkpoints.\"),\n\t\t\tNULL,\n\t\t\tGUC_UNIT_S\n\t\t},\n\t\t&CheckPointTimeout,\n\t\t300, 30, 86400,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"checkpoint_warning\", PGC_SIGHUP, WAL_CHECKPOINTS,\n\t\t\tgettext_noop(\"Enables warnings if checkpoint segments are filled more \"\n\t\t\t\t\t\t \"frequently than this.\"),\n\t\t\tgettext_noop(\"Write a message to the server log if checkpoints \"\n\t\t\t\t\t\t \"caused by the filling of checkpoint segment files happens more \"\n\t\t\t\t\t\t \"frequently than this number of seconds. Zero turns off the warning.\"),\n\t\t\tGUC_UNIT_S\n\t\t},\n\t\t&CheckPointWarning,\n\t\t30, 0, INT_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"checkpoint_flush_after\", PGC_SIGHUP, WAL_CHECKPOINTS,\n\t\t\tgettext_noop(\"Number of pages after which previously performed writes are flushed to disk.\"),\n\t\t\tNULL,\n\t\t\tGUC_UNIT_BLOCKS\n\t\t},\n\t\t&checkpoint_flush_after,\n\t\tDEFAULT_CHECKPOINT_FLUSH_AFTER, 0, WRITEBACK_MAX_PENDING_FLUSHES,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"wal_buffers\", PGC_POSTMASTER, WAL_SETTINGS,\n\t\t\tgettext_noop(\"Sets the number of disk-page buffers in shared memory for WAL.\"),\n\t\t\tNULL,\n\t\t\tGUC_UNIT_XBLOCKS\n\t\t},\n\t\t&XLOGbuffers,\n\t\t-1, -1, (INT_MAX / XLOG_BLCKSZ),\n\t\tcheck_wal_buffers, NULL, NULL\n\t},\n\n\t{\n\t\t{\"wal_writer_delay\", PGC_SIGHUP, WAL_SETTINGS,\n\t\t\tgettext_noop(\"Time between WAL flushes performed in the WAL writer.\"),\n\t\t\tNULL,\n\t\t\tGUC_UNIT_MS\n\t\t},\n\t\t&WalWriterDelay,\n\t\t200, 1, 10000,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"wal_writer_flush_after\", PGC_SIGHUP, WAL_SETTINGS,\n\t\t\tgettext_noop(\"Amount of WAL written out by WAL writer that triggers a flush.\"),\n\t\t\tNULL,\n\t\t\tGUC_UNIT_XBLOCKS\n\t\t},\n\t\t&WalWriterFlushAfter,\n\t\t(1024 * 1024) / XLOG_BLCKSZ, 0, INT_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t/* see max_connections and superuser_reserved_connections */\n\t\t{\"max_wal_senders\", PGC_POSTMASTER, REPLICATION_SENDING,\n\t\t\tgettext_noop(\"Sets the maximum number of simultaneously running WAL sender processes.\"),\n\t\t\tNULL\n\t\t},\n\t\t&max_wal_senders,\n\t\t10, 0, MAX_BACKENDS,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t/* see max_wal_senders */\n\t\t{\"max_replication_slots\", PGC_POSTMASTER, REPLICATION_SENDING,\n\t\t\tgettext_noop(\"Sets the maximum number of simultaneously defined replication slots.\"),\n\t\t\tNULL\n\t\t},\n\t\t&max_replication_slots,\n\t\t10, 0, MAX_BACKENDS /* XXX? */ ,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"wal_sender_timeout\", PGC_SIGHUP, REPLICATION_SENDING,\n\t\t\tgettext_noop(\"Sets the maximum time to wait for WAL replication.\"),\n\t\t\tNULL,\n\t\t\tGUC_UNIT_MS\n\t\t},\n\t\t&wal_sender_timeout,\n\t\t60 * 1000, 0, INT_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"commit_delay\", PGC_SUSET, WAL_SETTINGS,\n\t\t\tgettext_noop(\"Sets the delay in microseconds between transaction commit and \"\n\t\t\t\t\t\t \"flushing WAL to disk.\"),\n\t\t\tNULL\n\t\t\t/* we have no microseconds designation, so can't supply units here */\n\t\t},\n\t\t&CommitDelay,\n\t\t0, 0, 100000,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"commit_siblings\", PGC_USERSET, WAL_SETTINGS,\n\t\t\tgettext_noop(\"Sets the minimum concurrent open transactions before performing \"\n\t\t\t\t\t\t \"commit_delay.\"),\n\t\t\tNULL\n\t\t},\n\t\t&CommitSiblings,\n\t\t5, 0, 1000,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"extra_float_digits\", PGC_USERSET, CLIENT_CONN_LOCALE,\n\t\t\tgettext_noop(\"Sets the number of digits displayed for floating-point values.\"),\n\t\t\tgettext_noop(\"This affects real, double precision, and geometric data types. \"\n\t\t\t\t\t\t \"The parameter value is added to the standard number of digits \"\n\t\t\t\t\t\t \"(FLT_DIG or DBL_DIG as appropriate).\")\n\t\t},\n\t\t&extra_float_digits,\n\t\t0, -15, 3,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"log_min_duration_statement\", PGC_SUSET, LOGGING_WHEN,\n\t\t\tgettext_noop(\"Sets the minimum execution time above which \"\n\t\t\t\t\t\t \"statements will be logged.\"),\n\t\t\tgettext_noop(\"Zero prints all queries. -1 turns this feature off.\"),\n\t\t\tGUC_UNIT_MS\n\t\t},\n\t\t&log_min_duration_statement,\n\t\t-1, -1, INT_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"log_autovacuum_min_duration\", PGC_SIGHUP, LOGGING_WHAT,\n\t\t\tgettext_noop(\"Sets the minimum execution time above which \"\n\t\t\t\t\t\t \"autovacuum actions will be logged.\"),\n\t\t\tgettext_noop(\"Zero prints all actions. -1 turns autovacuum logging off.\"),\n\t\t\tGUC_UNIT_MS\n\t\t},\n\t\t&Log_autovacuum_min_duration,\n\t\t-1, -1, INT_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"bgwriter_delay\", PGC_SIGHUP, RESOURCES_BGWRITER,\n\t\t\tgettext_noop(\"Background writer sleep time between rounds.\"),\n\t\t\tNULL,\n\t\t\tGUC_UNIT_MS\n\t\t},\n\t\t&BgWriterDelay,\n\t\t200, 10, 10000,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"bgwriter_lru_maxpages\", PGC_SIGHUP, RESOURCES_BGWRITER,\n\t\t\tgettext_noop(\"Background writer maximum number of LRU pages to flush per round.\"),\n\t\t\tNULL\n\t\t},\n\t\t&bgwriter_lru_maxpages,\n\t\t100, 0, INT_MAX / 2,\t/* Same upper limit as shared_buffers */\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"bgwriter_flush_after\", PGC_SIGHUP, RESOURCES_BGWRITER,\n\t\t\tgettext_noop(\"Number of pages after which previously performed writes are flushed to disk.\"),\n\t\t\tNULL,\n\t\t\tGUC_UNIT_BLOCKS\n\t\t},\n\t\t&bgwriter_flush_after,\n\t\tDEFAULT_BGWRITER_FLUSH_AFTER, 0, WRITEBACK_MAX_PENDING_FLUSHES,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"effective_io_concurrency\",\n\t\t\tPGC_USERSET,\n\t\t\tRESOURCES_ASYNCHRONOUS,\n\t\t\tgettext_noop(\"Number of simultaneous requests that can be handled efficiently by the disk subsystem.\"),\n\t\t\tgettext_noop(\"For RAID arrays, this should be approximately the number of drive spindles in the array.\")\n\t\t},\n\t\t&effective_io_concurrency,\n#ifdef USE_PREFETCH\n\t\t1,\n#else\n\t\t0,\n#endif\n\t\t0, MAX_IO_CONCURRENCY,\n\t\tcheck_effective_io_concurrency, assign_effective_io_concurrency, NULL\n\t},\n\n\t{\n\t\t{\"backend_flush_after\", PGC_USERSET, RESOURCES_ASYNCHRONOUS,\n\t\t\tgettext_noop(\"Number of pages after which previously performed writes are flushed to disk.\"),\n\t\t\tNULL,\n\t\t\tGUC_UNIT_BLOCKS\n\t\t},\n\t\t&backend_flush_after,\n\t\tDEFAULT_BACKEND_FLUSH_AFTER, 0, WRITEBACK_MAX_PENDING_FLUSHES,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"max_worker_processes\",\n\t\t\tPGC_POSTMASTER,\n\t\t\tRESOURCES_ASYNCHRONOUS,\n\t\t\tgettext_noop(\"Maximum number of concurrent worker processes.\"),\n\t\t\tNULL,\n\t\t},\n\t\t&max_worker_processes,\n\t\t8, 0, MAX_BACKENDS,\n\t\tcheck_max_worker_processes, NULL, NULL\n\t},\n\n\t{\n\t\t{\"max_logical_replication_workers\",\n\t\t\tPGC_POSTMASTER,\n\t\t\tREPLICATION_SUBSCRIBERS,\n\t\t\tgettext_noop(\"Maximum number of logical replication worker processes.\"),\n\t\t\tNULL,\n\t\t},\n\t\t&max_logical_replication_workers,\n\t\t4, 0, MAX_BACKENDS,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"max_sync_workers_per_subscription\",\n\t\t\tPGC_SIGHUP,\n\t\t\tREPLICATION_SUBSCRIBERS,\n\t\t\tgettext_noop(\"Maximum number of table synchronization workers per subscription.\"),\n\t\t\tNULL,\n\t\t},\n\t\t&max_sync_workers_per_subscription,\n\t\t2, 0, MAX_BACKENDS,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"log_rotation_age\", PGC_SIGHUP, LOGGING_WHERE,\n\t\t\tgettext_noop(\"Automatic log file rotation will occur after N minutes.\"),\n\t\t\tNULL,\n\t\t\tGUC_UNIT_MIN\n\t\t},\n\t\t&Log_RotationAge,\n\t\tHOURS_PER_DAY * MINS_PER_HOUR, 0, INT_MAX / SECS_PER_MINUTE,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"log_rotation_size\", PGC_SIGHUP, LOGGING_WHERE,\n\t\t\tgettext_noop(\"Automatic log file rotation will occur after N kilobytes.\"),\n\t\t\tNULL,\n\t\t\tGUC_UNIT_KB\n\t\t},\n\t\t&Log_RotationSize,\n\t\t10 * 1024, 0, INT_MAX / 1024,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"max_function_args\", PGC_INTERNAL, PRESET_OPTIONS,\n\t\t\tgettext_noop(\"Shows the maximum number of function arguments.\"),\n\t\t\tNULL,\n\t\t\tGUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE\n\t\t},\n\t\t&max_function_args,\n\t\tFUNC_MAX_ARGS, FUNC_MAX_ARGS, FUNC_MAX_ARGS,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"max_index_keys\", PGC_INTERNAL, PRESET_OPTIONS,\n\t\t\tgettext_noop(\"Shows the maximum number of index keys.\"),\n\t\t\tNULL,\n\t\t\tGUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE\n\t\t},\n\t\t&max_index_keys,\n\t\tINDEX_MAX_KEYS, INDEX_MAX_KEYS, INDEX_MAX_KEYS,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"max_identifier_length\", PGC_INTERNAL, PRESET_OPTIONS,\n\t\t\tgettext_noop(\"Shows the maximum identifier length.\"),\n\t\t\tNULL,\n\t\t\tGUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE\n\t\t},\n\t\t&max_identifier_length,\n\t\tNAMEDATALEN - 1, NAMEDATALEN - 1, NAMEDATALEN - 1,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"block_size\", PGC_INTERNAL, PRESET_OPTIONS,\n\t\t\tgettext_noop(\"Shows the size of a disk block.\"),\n\t\t\tNULL,\n\t\t\tGUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE\n\t\t},\n\t\t&block_size,\n\t\tBLCKSZ, BLCKSZ, BLCKSZ,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"segment_size\", PGC_INTERNAL, PRESET_OPTIONS,\n\t\t\tgettext_noop(\"Shows the number of pages per disk file.\"),\n\t\t\tNULL,\n\t\t\tGUC_UNIT_BLOCKS | GUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE\n\t\t},\n\t\t&segment_size,\n\t\tRELSEG_SIZE, RELSEG_SIZE, RELSEG_SIZE,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"wal_block_size\", PGC_INTERNAL, PRESET_OPTIONS,\n\t\t\tgettext_noop(\"Shows the block size in the write ahead log.\"),\n\t\t\tNULL,\n\t\t\tGUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE\n\t\t},\n\t\t&wal_block_size,\n\t\tXLOG_BLCKSZ, XLOG_BLCKSZ, XLOG_BLCKSZ,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"wal_retrieve_retry_interval\", PGC_SIGHUP, REPLICATION_STANDBY,\n\t\t\tgettext_noop(\"Sets the time to wait before retrying to retrieve WAL \"\n\t\t\t\t\t\t \"after a failed attempt.\"),\n\t\t\tNULL,\n\t\t\tGUC_UNIT_MS\n\t\t},\n\t\t&wal_retrieve_retry_interval,\n\t\t5000, 1, INT_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"wal_segment_size\", PGC_INTERNAL, PRESET_OPTIONS,\n\t\t\tgettext_noop(\"Shows the size of write ahead log segments.\"),\n\t\t\tNULL,\n\t\t\tGUC_UNIT_BYTE | GUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE\n\t\t},\n\t\t&wal_segment_size,\n\t\tDEFAULT_XLOG_SEG_SIZE,\n\t\tWalSegMinSize,\n\t\tWalSegMaxSize,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"autovacuum_naptime\", PGC_SIGHUP, AUTOVACUUM,\n\t\t\tgettext_noop(\"Time to sleep between autovacuum runs.\"),\n\t\t\tNULL,\n\t\t\tGUC_UNIT_S\n\t\t},\n\t\t&autovacuum_naptime,\n\t\t60, 1, INT_MAX / 1000,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"autovacuum_vacuum_threshold\", PGC_SIGHUP, AUTOVACUUM,\n\t\t\tgettext_noop(\"Minimum number of tuple updates or deletes prior to vacuum.\"),\n\t\t\tNULL\n\t\t},\n\t\t&autovacuum_vac_thresh,\n\t\t50, 0, INT_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"autovacuum_analyze_threshold\", PGC_SIGHUP, AUTOVACUUM,\n\t\t\tgettext_noop(\"Minimum number of tuple inserts, updates, or deletes prior to analyze.\"),\n\t\t\tNULL\n\t\t},\n\t\t&autovacuum_anl_thresh,\n\t\t50, 0, INT_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t/* see varsup.c for why this is PGC_POSTMASTER not PGC_SIGHUP */\n\t\t{\"autovacuum_freeze_max_age\", PGC_POSTMASTER, AUTOVACUUM,\n\t\t\tgettext_noop(\"Age at which to autovacuum a table to prevent transaction ID wraparound.\"),\n\t\t\tNULL\n\t\t},\n\t\t&autovacuum_freeze_max_age,\n\t\t/* see pg_resetwal if you change the upper-limit value */\n\t\t200000000, 100000, 2000000000,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t/* see multixact.c for why this is PGC_POSTMASTER not PGC_SIGHUP */\n\t\t{\"autovacuum_multixact_freeze_max_age\", PGC_POSTMASTER, AUTOVACUUM,\n\t\t\tgettext_noop(\"Multixact age at which to autovacuum a table to prevent multixact wraparound.\"),\n\t\t\tNULL\n\t\t},\n\t\t&autovacuum_multixact_freeze_max_age,\n\t\t400000000, 10000, 2000000000,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t/* see max_connections */\n\t\t{\"autovacuum_max_workers\", PGC_POSTMASTER, AUTOVACUUM,\n\t\t\tgettext_noop(\"Sets the maximum number of simultaneously running autovacuum worker processes.\"),\n\t\t\tNULL\n\t\t},\n\t\t&autovacuum_max_workers,\n\t\t3, 1, MAX_BACKENDS,\n\t\tcheck_autovacuum_max_workers, NULL, NULL\n\t},\n\n\t{\n\t\t{\"max_parallel_maintenance_workers\", PGC_USERSET, RESOURCES_ASYNCHRONOUS,\n\t\t\tgettext_noop(\"Sets the maximum number of parallel processes per maintenance operation.\"),\n\t\t\tNULL\n\t\t},\n\t\t&max_parallel_maintenance_workers,\n\t\t2, 0, 1024,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"max_parallel_workers_per_gather\", PGC_USERSET, RESOURCES_ASYNCHRONOUS,\n\t\t\tgettext_noop(\"Sets the maximum number of parallel processes per executor node.\"),\n\t\t\tNULL\n\t\t},\n\t\t&max_parallel_workers_per_gather,\n\t\t2, 0, MAX_PARALLEL_WORKER_LIMIT,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"max_parallel_workers\", PGC_USERSET, RESOURCES_ASYNCHRONOUS,\n\t\t\tgettext_noop(\"Sets the maximum number of parallel workers that can be active at one time.\"),\n\t\t\tNULL\n\t\t},\n\t\t&max_parallel_workers,\n\t\t8, 0, MAX_PARALLEL_WORKER_LIMIT,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"autovacuum_work_mem\", PGC_SIGHUP, RESOURCES_MEM,\n\t\t\tgettext_noop(\"Sets the maximum memory to be used by each autovacuum worker process.\"),\n\t\t\tNULL,\n\t\t\tGUC_UNIT_KB\n\t\t},\n\t\t&autovacuum_work_mem,\n\t\t-1, -1, MAX_KILOBYTES,\n\t\tcheck_autovacuum_work_mem, NULL, NULL\n\t},\n\n\t{\n\t\t{\"old_snapshot_threshold\", PGC_POSTMASTER, RESOURCES_ASYNCHRONOUS,\n\t\t\tgettext_noop(\"Time before a snapshot is too old to read pages changed after the snapshot was taken.\"),\n\t\t\tgettext_noop(\"A value of -1 disables this feature.\"),\n\t\t\tGUC_UNIT_MIN\n\t\t},\n\t\t&old_snapshot_threshold,\n\t\t-1, -1, MINS_PER_HOUR * HOURS_PER_DAY * 60,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"tcp_keepalives_idle\", PGC_USERSET, CLIENT_CONN_OTHER,\n\t\t\tgettext_noop(\"Time between issuing TCP keepalives.\"),\n\t\t\tgettext_noop(\"A value of 0 uses the system default.\"),\n\t\t\tGUC_UNIT_S\n\t\t},\n\t\t&tcp_keepalives_idle,\n\t\t0, 0, INT_MAX,\n\t\tNULL, assign_tcp_keepalives_idle, show_tcp_keepalives_idle\n\t},\n\n\t{\n\t\t{\"tcp_keepalives_interval\", PGC_USERSET, CLIENT_CONN_OTHER,\n\t\t\tgettext_noop(\"Time between TCP keepalive retransmits.\"),\n\t\t\tgettext_noop(\"A value of 0 uses the system default.\"),\n\t\t\tGUC_UNIT_S\n\t\t},\n\t\t&tcp_keepalives_interval,\n\t\t0, 0, INT_MAX,\n\t\tNULL, assign_tcp_keepalives_interval, show_tcp_keepalives_interval\n\t},\n\n\t{\n\t\t{\"ssl_renegotiation_limit\", PGC_USERSET, CONN_AUTH_SSL,\n\t\t\tgettext_noop(\"SSL renegotiation is no longer supported; this can only be 0.\"),\n\t\t\tNULL,\n\t\t\tGUC_NO_SHOW_ALL | GUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE,\n\t\t},\n\t\t&ssl_renegotiation_limit,\n\t\t0, 0, 0,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"tcp_keepalives_count\", PGC_USERSET, CLIENT_CONN_OTHER,\n\t\t\tgettext_noop(\"Maximum number of TCP keepalive retransmits.\"),\n\t\t\tgettext_noop(\"This controls the number of consecutive keepalive retransmits that can be \"\n\t\t\t\t\t\t \"lost before a connection is considered dead. A value of 0 uses the \"\n\t\t\t\t\t\t \"system default.\"),\n\t\t},\n\t\t&tcp_keepalives_count,\n\t\t0, 0, INT_MAX,\n\t\tNULL, assign_tcp_keepalives_count, show_tcp_keepalives_count\n\t},\n\n\t{\n\t\t{\"gin_fuzzy_search_limit\", PGC_USERSET, CLIENT_CONN_OTHER,\n\t\t\tgettext_noop(\"Sets the maximum allowed result for exact search by GIN.\"),\n\t\t\tNULL,\n\t\t\t0\n\t\t},\n\t\t&GinFuzzySearchLimit,\n\t\t0, 0, INT_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"effective_cache_size\", PGC_USERSET, QUERY_TUNING_COST,\n\t\t\tgettext_noop(\"Sets the planner's assumption about the total size of the data caches.\"),\n\t\t\tgettext_noop(\"That is, the total size of the caches (kernel cache and shared buffers) used for PostgreSQL data files. \"\n\t\t\t\t\t\t \"This is measured in disk pages, which are normally 8 kB each.\"),\n\t\t\tGUC_UNIT_BLOCKS,\n\t\t},\n\t\t&effective_cache_size,\n\t\tDEFAULT_EFFECTIVE_CACHE_SIZE, 1, INT_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"min_parallel_table_scan_size\", PGC_USERSET, QUERY_TUNING_COST,\n\t\t\tgettext_noop(\"Sets the minimum amount of table data for a parallel scan.\"),\n\t\t\tgettext_noop(\"If the planner estimates that it will read a number of table pages too small to reach this limit, a parallel scan will not be considered.\"),\n\t\t\tGUC_UNIT_BLOCKS,\n\t\t},\n\t\t&min_parallel_table_scan_size,\n\t\t(8 * 1024 * 1024) / BLCKSZ, 0, INT_MAX / 3,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"min_parallel_index_scan_size\", PGC_USERSET, QUERY_TUNING_COST,\n\t\t\tgettext_noop(\"Sets the minimum amount of index data for a parallel scan.\"),\n\t\t\tgettext_noop(\"If the planner estimates that it will read a number of index pages too small to reach this limit, a parallel scan will not be considered.\"),\n\t\t\tGUC_UNIT_BLOCKS,\n\t\t},\n\t\t&min_parallel_index_scan_size,\n\t\t(512 * 1024) / BLCKSZ, 0, INT_MAX / 3,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t/* Can't be set in postgresql.conf */\n\t\t{\"server_version_num\", PGC_INTERNAL, PRESET_OPTIONS,\n\t\t\tgettext_noop(\"Shows the server version as an integer.\"),\n\t\t\tNULL,\n\t\t\tGUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE\n\t\t},\n\t\t&server_version_num,\n\t\tPG_VERSION_NUM, PG_VERSION_NUM, PG_VERSION_NUM,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"log_temp_files\", PGC_SUSET, LOGGING_WHAT,\n\t\t\tgettext_noop(\"Log the use of temporary files larger than this number of kilobytes.\"),\n\t\t\tgettext_noop(\"Zero logs all files. The default is -1 (turning this feature off).\"),\n\t\t\tGUC_UNIT_KB\n\t\t},\n\t\t&log_temp_files,\n\t\t-1, -1, INT_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"track_activity_query_size\", PGC_POSTMASTER, RESOURCES_MEM,\n\t\t\tgettext_noop(\"Sets the size reserved for pg_stat_activity.query, in bytes.\"),\n\t\t\tNULL,\n\t\t\tGUC_UNIT_BYTE\n\t\t},\n\t\t&pgstat_track_activity_query_size,\n\t\t1024, 100, 102400,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"gin_pending_list_limit\", PGC_USERSET, CLIENT_CONN_STATEMENT,\n\t\t\tgettext_noop(\"Sets the maximum size of the pending list for GIN index.\"),\n\t\t\tNULL,\n\t\t\tGUC_UNIT_KB\n\t\t},\n\t\t&gin_pending_list_limit,\n\t\t4096, 64, MAX_KILOBYTES,\n\t\tNULL, NULL, NULL\n\t},\n\n\t/* End-of-list marker */\n\t{\n\t\t{NULL, 0, 0, NULL, NULL}, NULL, 0, 0, 0, NULL, NULL, NULL\n\t}\n};",
            "static struct config_real ConfigureNamesReal[] =\n{\n\t{\n\t\t{\"seq_page_cost\", PGC_USERSET, QUERY_TUNING_COST,\n\t\t\tgettext_noop(\"Sets the planner's estimate of the cost of a \"\n\t\t\t\t\t\t \"sequentially fetched disk page.\"),\n\t\t\tNULL\n\t\t},\n\t\t&seq_page_cost,\n\t\tDEFAULT_SEQ_PAGE_COST, 0, DBL_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"random_page_cost\", PGC_USERSET, QUERY_TUNING_COST,\n\t\t\tgettext_noop(\"Sets the planner's estimate of the cost of a \"\n\t\t\t\t\t\t \"nonsequentially fetched disk page.\"),\n\t\t\tNULL\n\t\t},\n\t\t&random_page_cost,\n\t\tDEFAULT_RANDOM_PAGE_COST, 0, DBL_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"cpu_tuple_cost\", PGC_USERSET, QUERY_TUNING_COST,\n\t\t\tgettext_noop(\"Sets the planner's estimate of the cost of \"\n\t\t\t\t\t\t \"processing each tuple (row).\"),\n\t\t\tNULL\n\t\t},\n\t\t&cpu_tuple_cost,\n\t\tDEFAULT_CPU_TUPLE_COST, 0, DBL_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"cpu_index_tuple_cost\", PGC_USERSET, QUERY_TUNING_COST,\n\t\t\tgettext_noop(\"Sets the planner's estimate of the cost of \"\n\t\t\t\t\t\t \"processing each index entry during an index scan.\"),\n\t\t\tNULL\n\t\t},\n\t\t&cpu_index_tuple_cost,\n\t\tDEFAULT_CPU_INDEX_TUPLE_COST, 0, DBL_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"cpu_operator_cost\", PGC_USERSET, QUERY_TUNING_COST,\n\t\t\tgettext_noop(\"Sets the planner's estimate of the cost of \"\n\t\t\t\t\t\t \"processing each operator or function call.\"),\n\t\t\tNULL\n\t\t},\n\t\t&cpu_operator_cost,\n\t\tDEFAULT_CPU_OPERATOR_COST, 0, DBL_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"parallel_tuple_cost\", PGC_USERSET, QUERY_TUNING_COST,\n\t\t\tgettext_noop(\"Sets the planner's estimate of the cost of \"\n\t\t\t\t\t\t \"passing each tuple (row) from worker to master backend.\"),\n\t\t\tNULL\n\t\t},\n\t\t&parallel_tuple_cost,\n\t\tDEFAULT_PARALLEL_TUPLE_COST, 0, DBL_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"parallel_setup_cost\", PGC_USERSET, QUERY_TUNING_COST,\n\t\t\tgettext_noop(\"Sets the planner's estimate of the cost of \"\n\t\t\t\t\t\t \"starting up worker processes for parallel query.\"),\n\t\t\tNULL\n\t\t},\n\t\t&parallel_setup_cost,\n\t\tDEFAULT_PARALLEL_SETUP_COST, 0, DBL_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"jit_above_cost\", PGC_USERSET, QUERY_TUNING_COST,\n\t\t\tgettext_noop(\"Perform JIT compilation if query is more expensive.\"),\n\t\t\tgettext_noop(\"-1 disables JIT compilation.\")\n\t\t},\n\t\t&jit_above_cost,\n\t\t100000, -1, DBL_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"jit_optimize_above_cost\", PGC_USERSET, QUERY_TUNING_COST,\n\t\t\tgettext_noop(\"Optimize JITed functions if query is more expensive.\"),\n\t\t\tgettext_noop(\"-1 disables optimization.\")\n\t\t},\n\t\t&jit_optimize_above_cost,\n\t\t500000, -1, DBL_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"jit_inline_above_cost\", PGC_USERSET, QUERY_TUNING_COST,\n\t\t\tgettext_noop(\"Perform JIT inlining if query is more expensive.\"),\n\t\t\tgettext_noop(\"-1 disables inlining.\")\n\t\t},\n\t\t&jit_inline_above_cost,\n\t\t500000, -1, DBL_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"cursor_tuple_fraction\", PGC_USERSET, QUERY_TUNING_OTHER,\n\t\t\tgettext_noop(\"Sets the planner's estimate of the fraction of \"\n\t\t\t\t\t\t \"a cursor's rows that will be retrieved.\"),\n\t\t\tNULL\n\t\t},\n\t\t&cursor_tuple_fraction,\n\t\tDEFAULT_CURSOR_TUPLE_FRACTION, 0.0, 1.0,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"geqo_selection_bias\", PGC_USERSET, QUERY_TUNING_GEQO,\n\t\t\tgettext_noop(\"GEQO: selective pressure within the population.\"),\n\t\t\tNULL\n\t\t},\n\t\t&Geqo_selection_bias,\n\t\tDEFAULT_GEQO_SELECTION_BIAS,\n\t\tMIN_GEQO_SELECTION_BIAS, MAX_GEQO_SELECTION_BIAS,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"geqo_seed\", PGC_USERSET, QUERY_TUNING_GEQO,\n\t\t\tgettext_noop(\"GEQO: seed for random path selection.\"),\n\t\t\tNULL\n\t\t},\n\t\t&Geqo_seed,\n\t\t0.0, 0.0, 1.0,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"bgwriter_lru_multiplier\", PGC_SIGHUP, RESOURCES_BGWRITER,\n\t\t\tgettext_noop(\"Multiple of the average buffer usage to free per round.\"),\n\t\t\tNULL\n\t\t},\n\t\t&bgwriter_lru_multiplier,\n\t\t2.0, 0.0, 10.0,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"seed\", PGC_USERSET, UNGROUPED,\n\t\t\tgettext_noop(\"Sets the seed for random-number generation.\"),\n\t\t\tNULL,\n\t\t\tGUC_NO_SHOW_ALL | GUC_NO_RESET_ALL | GUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE\n\t\t},\n\t\t&phony_random_seed,\n\t\t0.0, -1.0, 1.0,\n\t\tcheck_random_seed, assign_random_seed, show_random_seed\n\t},\n\n\t{\n\t\t{\"autovacuum_vacuum_scale_factor\", PGC_SIGHUP, AUTOVACUUM,\n\t\t\tgettext_noop(\"Number of tuple updates or deletes prior to vacuum as a fraction of reltuples.\"),\n\t\t\tNULL\n\t\t},\n\t\t&autovacuum_vac_scale,\n\t\t0.2, 0.0, 100.0,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"autovacuum_analyze_scale_factor\", PGC_SIGHUP, AUTOVACUUM,\n\t\t\tgettext_noop(\"Number of tuple inserts, updates, or deletes prior to analyze as a fraction of reltuples.\"),\n\t\t\tNULL\n\t\t},\n\t\t&autovacuum_anl_scale,\n\t\t0.1, 0.0, 100.0,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"checkpoint_completion_target\", PGC_SIGHUP, WAL_CHECKPOINTS,\n\t\t\tgettext_noop(\"Time spent flushing dirty buffers during checkpoint, as fraction of checkpoint interval.\"),\n\t\t\tNULL\n\t\t},\n\t\t&CheckPointCompletionTarget,\n\t\t0.5, 0.0, 1.0,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"vacuum_cleanup_index_scale_factor\", PGC_USERSET, CLIENT_CONN_STATEMENT,\n\t\t\tgettext_noop(\"Number of tuple inserts prior to index cleanup as a fraction of reltuples.\"),\n\t\t\tNULL\n\t\t},\n\t\t&vacuum_cleanup_index_scale_factor,\n\t\t0.1, 0.0, 1e10,\n\t\tNULL, NULL, NULL\n\t},\n\n\t/* End-of-list marker */\n\t{\n\t\t{NULL, 0, 0, NULL, NULL}, NULL, 0.0, 0.0, 0.0, NULL, NULL, NULL\n\t}\n};",
            "static struct config_string ConfigureNamesString[] =\n{\n\t{\n\t\t{\"archive_command\", PGC_SIGHUP, WAL_ARCHIVING,\n\t\t\tgettext_noop(\"Sets the shell command that will be called to archive a WAL file.\"),\n\t\t\tNULL\n\t\t},\n\t\t&XLogArchiveCommand,\n\t\t\"\",\n\t\tNULL, NULL, show_archive_command\n\t},\n\n\t{\n\t\t{\"client_encoding\", PGC_USERSET, CLIENT_CONN_LOCALE,\n\t\t\tgettext_noop(\"Sets the client's character set encoding.\"),\n\t\t\tNULL,\n\t\t\tGUC_IS_NAME | GUC_REPORT\n\t\t},\n\t\t&client_encoding_string,\n\t\t\"SQL_ASCII\",\n\t\tcheck_client_encoding, assign_client_encoding, NULL\n\t},\n\n\t{\n\t\t{\"log_line_prefix\", PGC_SIGHUP, LOGGING_WHAT,\n\t\t\tgettext_noop(\"Controls information prefixed to each log line.\"),\n\t\t\tgettext_noop(\"If blank, no prefix is used.\")\n\t\t},\n\t\t&Log_line_prefix,\n\t\t\"%m [%p] \",\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"log_timezone\", PGC_SIGHUP, LOGGING_WHAT,\n\t\t\tgettext_noop(\"Sets the time zone to use in log messages.\"),\n\t\t\tNULL\n\t\t},\n\t\t&log_timezone_string,\n\t\t\"GMT\",\n\t\tcheck_log_timezone, assign_log_timezone, show_log_timezone\n\t},\n\n\t{\n\t\t{\"DateStyle\", PGC_USERSET, CLIENT_CONN_LOCALE,\n\t\t\tgettext_noop(\"Sets the display format for date and time values.\"),\n\t\t\tgettext_noop(\"Also controls interpretation of ambiguous \"\n\t\t\t\t\t\t \"date inputs.\"),\n\t\t\tGUC_LIST_INPUT | GUC_REPORT\n\t\t},\n\t\t&datestyle_string,\n\t\t\"ISO, MDY\",\n\t\tcheck_datestyle, assign_datestyle, NULL\n\t},\n\n\t{\n\t\t{\"default_tablespace\", PGC_USERSET, CLIENT_CONN_STATEMENT,\n\t\t\tgettext_noop(\"Sets the default tablespace to create tables and indexes in.\"),\n\t\t\tgettext_noop(\"An empty string selects the database's default tablespace.\"),\n\t\t\tGUC_IS_NAME\n\t\t},\n\t\t&default_tablespace,\n\t\t\"\",\n\t\tcheck_default_tablespace, NULL, NULL\n\t},\n\n\t{\n\t\t{\"temp_tablespaces\", PGC_USERSET, CLIENT_CONN_STATEMENT,\n\t\t\tgettext_noop(\"Sets the tablespace(s) to use for temporary tables and sort files.\"),\n\t\t\tNULL,\n\t\t\tGUC_LIST_INPUT | GUC_LIST_QUOTE\n\t\t},\n\t\t&temp_tablespaces,\n\t\t\"\",\n\t\tcheck_temp_tablespaces, assign_temp_tablespaces, NULL\n\t},\n\n\t{\n\t\t{\"dynamic_library_path\", PGC_SUSET, CLIENT_CONN_OTHER,\n\t\t\tgettext_noop(\"Sets the path for dynamically loadable modules.\"),\n\t\t\tgettext_noop(\"If a dynamically loadable module needs to be opened and \"\n\t\t\t\t\t\t \"the specified name does not have a directory component (i.e., the \"\n\t\t\t\t\t\t \"name does not contain a slash), the system will search this path for \"\n\t\t\t\t\t\t \"the specified file.\"),\n\t\t\tGUC_SUPERUSER_ONLY\n\t\t},\n\t\t&Dynamic_library_path,\n\t\t\"$libdir\",\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"krb_server_keyfile\", PGC_SIGHUP, CONN_AUTH_AUTH,\n\t\t\tgettext_noop(\"Sets the location of the Kerberos server key file.\"),\n\t\t\tNULL,\n\t\t\tGUC_SUPERUSER_ONLY\n\t\t},\n\t\t&pg_krb_server_keyfile,\n\t\tPG_KRB_SRVTAB,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"bonjour_name\", PGC_POSTMASTER, CONN_AUTH_SETTINGS,\n\t\t\tgettext_noop(\"Sets the Bonjour service name.\"),\n\t\t\tNULL\n\t\t},\n\t\t&bonjour_name,\n\t\t\"\",\n\t\tNULL, NULL, NULL\n\t},\n\n\t/* See main.c about why defaults for LC_foo are not all alike */\n\n\t{\n\t\t{\"lc_collate\", PGC_INTERNAL, CLIENT_CONN_LOCALE,\n\t\t\tgettext_noop(\"Shows the collation order locale.\"),\n\t\t\tNULL,\n\t\t\tGUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE\n\t\t},\n\t\t&locale_collate,\n\t\t\"C\",\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"lc_ctype\", PGC_INTERNAL, CLIENT_CONN_LOCALE,\n\t\t\tgettext_noop(\"Shows the character classification and case conversion locale.\"),\n\t\t\tNULL,\n\t\t\tGUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE\n\t\t},\n\t\t&locale_ctype,\n\t\t\"C\",\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"lc_messages\", PGC_SUSET, CLIENT_CONN_LOCALE,\n\t\t\tgettext_noop(\"Sets the language in which messages are displayed.\"),\n\t\t\tNULL\n\t\t},\n\t\t&locale_messages,\n\t\t\"\",\n\t\tcheck_locale_messages, assign_locale_messages, NULL\n\t},\n\n\t{\n\t\t{\"lc_monetary\", PGC_USERSET, CLIENT_CONN_LOCALE,\n\t\t\tgettext_noop(\"Sets the locale for formatting monetary amounts.\"),\n\t\t\tNULL\n\t\t},\n\t\t&locale_monetary,\n\t\t\"C\",\n\t\tcheck_locale_monetary, assign_locale_monetary, NULL\n\t},\n\n\t{\n\t\t{\"lc_numeric\", PGC_USERSET, CLIENT_CONN_LOCALE,\n\t\t\tgettext_noop(\"Sets the locale for formatting numbers.\"),\n\t\t\tNULL\n\t\t},\n\t\t&locale_numeric,\n\t\t\"C\",\n\t\tcheck_locale_numeric, assign_locale_numeric, NULL\n\t},\n\n\t{\n\t\t{\"lc_time\", PGC_USERSET, CLIENT_CONN_LOCALE,\n\t\t\tgettext_noop(\"Sets the locale for formatting date and time values.\"),\n\t\t\tNULL\n\t\t},\n\t\t&locale_time,\n\t\t\"C\",\n\t\tcheck_locale_time, assign_locale_time, NULL\n\t},\n\n\t{\n\t\t{\"session_preload_libraries\", PGC_SUSET, CLIENT_CONN_PRELOAD,\n\t\t\tgettext_noop(\"Lists shared libraries to preload into each backend.\"),\n\t\t\tNULL,\n\t\t\tGUC_LIST_INPUT | GUC_LIST_QUOTE | GUC_SUPERUSER_ONLY\n\t\t},\n\t\t&session_preload_libraries_string,\n\t\t\"\",\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"shared_preload_libraries\", PGC_POSTMASTER, CLIENT_CONN_PRELOAD,\n\t\t\tgettext_noop(\"Lists shared libraries to preload into server.\"),\n\t\t\tNULL,\n\t\t\tGUC_LIST_INPUT | GUC_LIST_QUOTE | GUC_SUPERUSER_ONLY\n\t\t},\n\t\t&shared_preload_libraries_string,\n\t\t\"\",\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"local_preload_libraries\", PGC_USERSET, CLIENT_CONN_PRELOAD,\n\t\t\tgettext_noop(\"Lists unprivileged shared libraries to preload into each backend.\"),\n\t\t\tNULL,\n\t\t\tGUC_LIST_INPUT | GUC_LIST_QUOTE\n\t\t},\n\t\t&local_preload_libraries_string,\n\t\t\"\",\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"search_path\", PGC_USERSET, CLIENT_CONN_STATEMENT,\n\t\t\tgettext_noop(\"Sets the schema search order for names that are not schema-qualified.\"),\n\t\t\tNULL,\n\t\t\tGUC_LIST_INPUT | GUC_LIST_QUOTE\n\t\t},\n\t\t&namespace_search_path,\n\t\t\"\\\"$user\\\", public\",\n\t\tcheck_search_path, assign_search_path, NULL\n\t},\n\n\t{\n\t\t/* Can't be set in postgresql.conf */\n\t\t{\"server_encoding\", PGC_INTERNAL, CLIENT_CONN_LOCALE,\n\t\t\tgettext_noop(\"Sets the server (database) character set encoding.\"),\n\t\t\tNULL,\n\t\t\tGUC_IS_NAME | GUC_REPORT | GUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE\n\t\t},\n\t\t&server_encoding_string,\n\t\t\"SQL_ASCII\",\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t/* Can't be set in postgresql.conf */\n\t\t{\"server_version\", PGC_INTERNAL, PRESET_OPTIONS,\n\t\t\tgettext_noop(\"Shows the server version.\"),\n\t\t\tNULL,\n\t\t\tGUC_REPORT | GUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE\n\t\t},\n\t\t&server_version_string,\n\t\tPG_VERSION,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t/* Not for general use --- used by SET ROLE */\n\t\t{\"role\", PGC_USERSET, UNGROUPED,\n\t\t\tgettext_noop(\"Sets the current role.\"),\n\t\t\tNULL,\n\t\t\tGUC_IS_NAME | GUC_NO_SHOW_ALL | GUC_NO_RESET_ALL | GUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE | GUC_NOT_WHILE_SEC_REST\n\t\t},\n\t\t&role_string,\n\t\t\"none\",\n\t\tcheck_role, assign_role, show_role\n\t},\n\n\t{\n\t\t/* Not for general use --- used by SET SESSION AUTHORIZATION */\n\t\t{\"session_authorization\", PGC_USERSET, UNGROUPED,\n\t\t\tgettext_noop(\"Sets the session user name.\"),\n\t\t\tNULL,\n\t\t\tGUC_IS_NAME | GUC_REPORT | GUC_NO_SHOW_ALL | GUC_NO_RESET_ALL | GUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE | GUC_NOT_WHILE_SEC_REST\n\t\t},\n\t\t&session_authorization_string,\n\t\tNULL,\n\t\tcheck_session_authorization, assign_session_authorization, NULL\n\t},\n\n\t{\n\t\t{\"log_destination\", PGC_SIGHUP, LOGGING_WHERE,\n\t\t\tgettext_noop(\"Sets the destination for server log output.\"),\n\t\t\tgettext_noop(\"Valid values are combinations of \\\"stderr\\\", \"\n\t\t\t\t\t\t \"\\\"syslog\\\", \\\"csvlog\\\", and \\\"eventlog\\\", \"\n\t\t\t\t\t\t \"depending on the platform.\"),\n\t\t\tGUC_LIST_INPUT\n\t\t},\n\t\t&Log_destination_string,\n\t\t\"stderr\",\n\t\tcheck_log_destination, assign_log_destination, NULL\n\t},\n\t{\n\t\t{\"log_directory\", PGC_SIGHUP, LOGGING_WHERE,\n\t\t\tgettext_noop(\"Sets the destination directory for log files.\"),\n\t\t\tgettext_noop(\"Can be specified as relative to the data directory \"\n\t\t\t\t\t\t \"or as absolute path.\"),\n\t\t\tGUC_SUPERUSER_ONLY\n\t\t},\n\t\t&Log_directory,\n\t\t\"log\",\n\t\tcheck_canonical_path, NULL, NULL\n\t},\n\t{\n\t\t{\"log_filename\", PGC_SIGHUP, LOGGING_WHERE,\n\t\t\tgettext_noop(\"Sets the file name pattern for log files.\"),\n\t\t\tNULL,\n\t\t\tGUC_SUPERUSER_ONLY\n\t\t},\n\t\t&Log_filename,\n\t\t\"postgresql-%Y-%m-%d_%H%M%S.log\",\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"syslog_ident\", PGC_SIGHUP, LOGGING_WHERE,\n\t\t\tgettext_noop(\"Sets the program name used to identify PostgreSQL \"\n\t\t\t\t\t\t \"messages in syslog.\"),\n\t\t\tNULL\n\t\t},\n\t\t&syslog_ident_str,\n\t\t\"postgres\",\n\t\tNULL, assign_syslog_ident, NULL\n\t},\n\n\t{\n\t\t{\"event_source\", PGC_POSTMASTER, LOGGING_WHERE,\n\t\t\tgettext_noop(\"Sets the application name used to identify \"\n\t\t\t\t\t\t \"PostgreSQL messages in the event log.\"),\n\t\t\tNULL\n\t\t},\n\t\t&event_source,\n\t\tDEFAULT_EVENT_SOURCE,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"TimeZone\", PGC_USERSET, CLIENT_CONN_LOCALE,\n\t\t\tgettext_noop(\"Sets the time zone for displaying and interpreting time stamps.\"),\n\t\t\tNULL,\n\t\t\tGUC_REPORT\n\t\t},\n\t\t&timezone_string,\n\t\t\"GMT\",\n\t\tcheck_timezone, assign_timezone, show_timezone\n\t},\n\t{\n\t\t{\"timezone_abbreviations\", PGC_USERSET, CLIENT_CONN_LOCALE,\n\t\t\tgettext_noop(\"Selects a file of time zone abbreviations.\"),\n\t\t\tNULL\n\t\t},\n\t\t&timezone_abbreviations_string,\n\t\tNULL,\n\t\tcheck_timezone_abbreviations, assign_timezone_abbreviations, NULL\n\t},\n\n\t{\n\t\t{\"transaction_isolation\", PGC_USERSET, CLIENT_CONN_STATEMENT,\n\t\t\tgettext_noop(\"Sets the current transaction's isolation level.\"),\n\t\t\tNULL,\n\t\t\tGUC_NO_RESET_ALL | GUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE\n\t\t},\n\t\t&XactIsoLevel_string,\n\t\t\"default\",\n\t\tcheck_XactIsoLevel, assign_XactIsoLevel, show_XactIsoLevel\n\t},\n\n\t{\n\t\t{\"unix_socket_group\", PGC_POSTMASTER, CONN_AUTH_SETTINGS,\n\t\t\tgettext_noop(\"Sets the owning group of the Unix-domain socket.\"),\n\t\t\tgettext_noop(\"The owning user of the socket is always the user \"\n\t\t\t\t\t\t \"that starts the server.\")\n\t\t},\n\t\t&Unix_socket_group,\n\t\t\"\",\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"unix_socket_directories\", PGC_POSTMASTER, CONN_AUTH_SETTINGS,\n\t\t\tgettext_noop(\"Sets the directories where Unix-domain sockets will be created.\"),\n\t\t\tNULL,\n\t\t\tGUC_SUPERUSER_ONLY\n\t\t},\n\t\t&Unix_socket_directories,\n#ifdef HAVE_UNIX_SOCKETS\n\t\tDEFAULT_PGSOCKET_DIR,\n#else\n\t\t\"\",\n#endif\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"listen_addresses\", PGC_POSTMASTER, CONN_AUTH_SETTINGS,\n\t\t\tgettext_noop(\"Sets the host name or IP address(es) to listen to.\"),\n\t\t\tNULL,\n\t\t\tGUC_LIST_INPUT\n\t\t},\n\t\t&ListenAddresses,\n\t\t\"localhost\",\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t/*\n\t\t * Can't be set by ALTER SYSTEM as it can lead to recursive definition\n\t\t * of data_directory.\n\t\t */\n\t\t{\"data_directory\", PGC_POSTMASTER, FILE_LOCATIONS,\n\t\t\tgettext_noop(\"Sets the server's data directory.\"),\n\t\t\tNULL,\n\t\t\tGUC_SUPERUSER_ONLY | GUC_DISALLOW_IN_AUTO_FILE\n\t\t},\n\t\t&data_directory,\n\t\tNULL,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"config_file\", PGC_POSTMASTER, FILE_LOCATIONS,\n\t\t\tgettext_noop(\"Sets the server's main configuration file.\"),\n\t\t\tNULL,\n\t\t\tGUC_DISALLOW_IN_FILE | GUC_SUPERUSER_ONLY\n\t\t},\n\t\t&ConfigFileName,\n\t\tNULL,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"hba_file\", PGC_POSTMASTER, FILE_LOCATIONS,\n\t\t\tgettext_noop(\"Sets the server's \\\"hba\\\" configuration file.\"),\n\t\t\tNULL,\n\t\t\tGUC_SUPERUSER_ONLY\n\t\t},\n\t\t&HbaFileName,\n\t\tNULL,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"ident_file\", PGC_POSTMASTER, FILE_LOCATIONS,\n\t\t\tgettext_noop(\"Sets the server's \\\"ident\\\" configuration file.\"),\n\t\t\tNULL,\n\t\t\tGUC_SUPERUSER_ONLY\n\t\t},\n\t\t&IdentFileName,\n\t\tNULL,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"external_pid_file\", PGC_POSTMASTER, FILE_LOCATIONS,\n\t\t\tgettext_noop(\"Writes the postmaster PID to the specified file.\"),\n\t\t\tNULL,\n\t\t\tGUC_SUPERUSER_ONLY\n\t\t},\n\t\t&external_pid_file,\n\t\tNULL,\n\t\tcheck_canonical_path, NULL, NULL\n\t},\n\n\t{\n\t\t{\"ssl_cert_file\", PGC_SIGHUP, CONN_AUTH_SSL,\n\t\t\tgettext_noop(\"Location of the SSL server certificate file.\"),\n\t\t\tNULL\n\t\t},\n\t\t&ssl_cert_file,\n\t\t\"server.crt\",\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"ssl_key_file\", PGC_SIGHUP, CONN_AUTH_SSL,\n\t\t\tgettext_noop(\"Location of the SSL server private key file.\"),\n\t\t\tNULL\n\t\t},\n\t\t&ssl_key_file,\n\t\t\"server.key\",\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"ssl_ca_file\", PGC_SIGHUP, CONN_AUTH_SSL,\n\t\t\tgettext_noop(\"Location of the SSL certificate authority file.\"),\n\t\t\tNULL\n\t\t},\n\t\t&ssl_ca_file,\n\t\t\"\",\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"ssl_crl_file\", PGC_SIGHUP, CONN_AUTH_SSL,\n\t\t\tgettext_noop(\"Location of the SSL certificate revocation list file.\"),\n\t\t\tNULL\n\t\t},\n\t\t&ssl_crl_file,\n\t\t\"\",\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"stats_temp_directory\", PGC_SIGHUP, STATS_COLLECTOR,\n\t\t\tgettext_noop(\"Writes temporary statistics files to the specified directory.\"),\n\t\t\tNULL,\n\t\t\tGUC_SUPERUSER_ONLY\n\t\t},\n\t\t&pgstat_temp_directory,\n\t\tPG_STAT_TMP_DIR,\n\t\tcheck_canonical_path, assign_pgstat_temp_directory, NULL\n\t},\n\n\t{\n\t\t{\"synchronous_standby_names\", PGC_SIGHUP, REPLICATION_MASTER,\n\t\t\tgettext_noop(\"Number of synchronous standbys and list of names of potential synchronous ones.\"),\n\t\t\tNULL,\n\t\t\tGUC_LIST_INPUT\n\t\t},\n\t\t&SyncRepStandbyNames,\n\t\t\"\",\n\t\tcheck_synchronous_standby_names, assign_synchronous_standby_names, NULL\n\t},\n\n\t{\n\t\t{\"default_text_search_config\", PGC_USERSET, CLIENT_CONN_LOCALE,\n\t\t\tgettext_noop(\"Sets default text search configuration.\"),\n\t\t\tNULL\n\t\t},\n\t\t&TSCurrentConfig,\n\t\t\"pg_catalog.simple\",\n\t\tcheck_TSCurrentConfig, assign_TSCurrentConfig, NULL\n\t},\n\n\t{\n\t\t{\"ssl_ciphers\", PGC_SIGHUP, CONN_AUTH_SSL,\n\t\t\tgettext_noop(\"Sets the list of allowed SSL ciphers.\"),\n\t\t\tNULL,\n\t\t\tGUC_SUPERUSER_ONLY\n\t\t},\n\t\t&SSLCipherSuites,\n#ifdef USE_SSL\n\t\t\"HIGH:MEDIUM:+3DES:!aNULL\",\n#else\n\t\t\"none\",\n#endif\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"ssl_ecdh_curve\", PGC_SIGHUP, CONN_AUTH_SSL,\n\t\t\tgettext_noop(\"Sets the curve to use for ECDH.\"),\n\t\t\tNULL,\n\t\t\tGUC_SUPERUSER_ONLY\n\t\t},\n\t\t&SSLECDHCurve,\n#ifdef USE_SSL\n\t\t\"prime256v1\",\n#else\n\t\t\"none\",\n#endif\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"ssl_dh_params_file\", PGC_SIGHUP, CONN_AUTH_SSL,\n\t\t\tgettext_noop(\"Location of the SSL DH parameters file.\"),\n\t\t\tNULL,\n\t\t\tGUC_SUPERUSER_ONLY\n\t\t},\n\t\t&ssl_dh_params_file,\n\t\t\"\",\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"ssl_passphrase_command\", PGC_SIGHUP, CONN_AUTH_SSL,\n\t\t\tgettext_noop(\"Command to obtain passphrases for SSL.\"),\n\t\t\tNULL\n\t\t},\n\t\t&ssl_passphrase_command,\n\t\t\"\",\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"application_name\", PGC_USERSET, LOGGING_WHAT,\n\t\t\tgettext_noop(\"Sets the application name to be reported in statistics and logs.\"),\n\t\t\tNULL,\n\t\t\tGUC_IS_NAME | GUC_REPORT | GUC_NOT_IN_SAMPLE\n\t\t},\n\t\t&application_name,\n\t\t\"\",\n\t\tcheck_application_name, assign_application_name, NULL\n\t},\n\n\t{\n\t\t{\"cluster_name\", PGC_POSTMASTER, PROCESS_TITLE,\n\t\t\tgettext_noop(\"Sets the name of the cluster, which is included in the process title.\"),\n\t\t\tNULL,\n\t\t\tGUC_IS_NAME\n\t\t},\n\t\t&cluster_name,\n\t\t\"\",\n\t\tcheck_cluster_name, NULL, NULL\n\t},\n\n\t{\n\t\t{\"wal_consistency_checking\", PGC_SUSET, DEVELOPER_OPTIONS,\n\t\t\tgettext_noop(\"Sets the WAL resource managers for which WAL consistency checks are done.\"),\n\t\t\tgettext_noop(\"Full-page images will be logged for all data blocks and cross-checked against the results of WAL replay.\"),\n\t\t\tGUC_LIST_INPUT | GUC_NOT_IN_SAMPLE\n\t\t},\n\t\t&wal_consistency_checking_string,\n\t\t\"\",\n\t\tcheck_wal_consistency_checking, assign_wal_consistency_checking, NULL\n\t},\n\n\t{\n\t\t{\"jit_provider\", PGC_POSTMASTER, CLIENT_CONN_PRELOAD,\n\t\t\tgettext_noop(\"JIT provider to use.\"),\n\t\t\tNULL,\n\t\t\tGUC_SUPERUSER_ONLY\n\t\t},\n\t\t&jit_provider,\n\t\t\"llvmjit\",\n\t\tNULL, NULL, NULL\n\t},\n\n\t/* End-of-list marker */\n\t{\n\t\t{NULL, 0, 0, NULL, NULL}, NULL, NULL, NULL, NULL, NULL\n\t}\n};",
            "static struct config_enum ConfigureNamesEnum[] =\n{\n\t{\n\t\t{\"backslash_quote\", PGC_USERSET, COMPAT_OPTIONS_PREVIOUS,\n\t\t\tgettext_noop(\"Sets whether \\\"\\\\'\\\" is allowed in string literals.\"),\n\t\t\tNULL\n\t\t},\n\t\t&backslash_quote,\n\t\tBACKSLASH_QUOTE_SAFE_ENCODING, backslash_quote_options,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"bytea_output\", PGC_USERSET, CLIENT_CONN_STATEMENT,\n\t\t\tgettext_noop(\"Sets the output format for bytea.\"),\n\t\t\tNULL\n\t\t},\n\t\t&bytea_output,\n\t\tBYTEA_OUTPUT_HEX, bytea_output_options,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"client_min_messages\", PGC_USERSET, CLIENT_CONN_STATEMENT,\n\t\t\tgettext_noop(\"Sets the message levels that are sent to the client.\"),\n\t\t\tgettext_noop(\"Each level includes all the levels that follow it. The later\"\n\t\t\t\t\t\t \" the level, the fewer messages are sent.\")\n\t\t},\n\t\t&client_min_messages,\n\t\tNOTICE, client_message_level_options,\n\t\tcheck_client_min_messages, NULL, NULL\n\t},\n\n\t{\n\t\t{\"constraint_exclusion\", PGC_USERSET, QUERY_TUNING_OTHER,\n\t\t\tgettext_noop(\"Enables the planner to use constraints to optimize queries.\"),\n\t\t\tgettext_noop(\"Table scans will be skipped if their constraints\"\n\t\t\t\t\t\t \" guarantee that no rows match the query.\")\n\t\t},\n\t\t&constraint_exclusion,\n\t\tCONSTRAINT_EXCLUSION_PARTITION, constraint_exclusion_options,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"default_transaction_isolation\", PGC_USERSET, CLIENT_CONN_STATEMENT,\n\t\t\tgettext_noop(\"Sets the transaction isolation level of each new transaction.\"),\n\t\t\tNULL\n\t\t},\n\t\t&DefaultXactIsoLevel,\n\t\tXACT_READ_COMMITTED, isolation_level_options,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"IntervalStyle\", PGC_USERSET, CLIENT_CONN_LOCALE,\n\t\t\tgettext_noop(\"Sets the display format for interval values.\"),\n\t\t\tNULL,\n\t\t\tGUC_REPORT\n\t\t},\n\t\t&IntervalStyle,\n\t\tINTSTYLE_POSTGRES, intervalstyle_options,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"log_error_verbosity\", PGC_SUSET, LOGGING_WHAT,\n\t\t\tgettext_noop(\"Sets the verbosity of logged messages.\"),\n\t\t\tNULL\n\t\t},\n\t\t&Log_error_verbosity,\n\t\tPGERROR_DEFAULT, log_error_verbosity_options,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"log_min_messages\", PGC_SUSET, LOGGING_WHEN,\n\t\t\tgettext_noop(\"Sets the message levels that are logged.\"),\n\t\t\tgettext_noop(\"Each level includes all the levels that follow it. The later\"\n\t\t\t\t\t\t \" the level, the fewer messages are sent.\")\n\t\t},\n\t\t&log_min_messages,\n\t\tWARNING, server_message_level_options,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"log_min_error_statement\", PGC_SUSET, LOGGING_WHEN,\n\t\t\tgettext_noop(\"Causes all statements generating error at or above this level to be logged.\"),\n\t\t\tgettext_noop(\"Each level includes all the levels that follow it. The later\"\n\t\t\t\t\t\t \" the level, the fewer messages are sent.\")\n\t\t},\n\t\t&log_min_error_statement,\n\t\tERROR, server_message_level_options,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"log_statement\", PGC_SUSET, LOGGING_WHAT,\n\t\t\tgettext_noop(\"Sets the type of statements logged.\"),\n\t\t\tNULL\n\t\t},\n\t\t&log_statement,\n\t\tLOGSTMT_NONE, log_statement_options,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"syslog_facility\", PGC_SIGHUP, LOGGING_WHERE,\n\t\t\tgettext_noop(\"Sets the syslog \\\"facility\\\" to be used when syslog enabled.\"),\n\t\t\tNULL\n\t\t},\n\t\t&syslog_facility,\n#ifdef HAVE_SYSLOG\n\t\tLOG_LOCAL0,\n#else\n\t\t0,\n#endif\n\t\tsyslog_facility_options,\n\t\tNULL, assign_syslog_facility, NULL\n\t},\n\n\t{\n\t\t{\"session_replication_role\", PGC_SUSET, CLIENT_CONN_STATEMENT,\n\t\t\tgettext_noop(\"Sets the session's behavior for triggers and rewrite rules.\"),\n\t\t\tNULL\n\t\t},\n\t\t&SessionReplicationRole,\n\t\tSESSION_REPLICATION_ROLE_ORIGIN, session_replication_role_options,\n\t\tNULL, assign_session_replication_role, NULL\n\t},\n\n\t{\n\t\t{\"synchronous_commit\", PGC_USERSET, WAL_SETTINGS,\n\t\t\tgettext_noop(\"Sets the current transaction's synchronization level.\"),\n\t\t\tNULL\n\t\t},\n\t\t&synchronous_commit,\n\t\tSYNCHRONOUS_COMMIT_ON, synchronous_commit_options,\n\t\tNULL, assign_synchronous_commit, NULL\n\t},\n\n\t{\n\t\t{\"archive_mode\", PGC_POSTMASTER, WAL_ARCHIVING,\n\t\t\tgettext_noop(\"Allows archiving of WAL files using archive_command.\"),\n\t\t\tNULL\n\t\t},\n\t\t&XLogArchiveMode,\n\t\tARCHIVE_MODE_OFF, archive_mode_options,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"trace_recovery_messages\", PGC_SIGHUP, DEVELOPER_OPTIONS,\n\t\t\tgettext_noop(\"Enables logging of recovery-related debugging information.\"),\n\t\t\tgettext_noop(\"Each level includes all the levels that follow it. The later\"\n\t\t\t\t\t\t \" the level, the fewer messages are sent.\")\n\t\t},\n\t\t&trace_recovery_messages,\n\n\t\t/*\n\t\t * client_message_level_options allows too many values, really, but\n\t\t * it's not worth having a separate options array for this.\n\t\t */\n\t\tLOG, client_message_level_options,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"track_functions\", PGC_SUSET, STATS_COLLECTOR,\n\t\t\tgettext_noop(\"Collects function-level statistics on database activity.\"),\n\t\t\tNULL\n\t\t},\n\t\t&pgstat_track_functions,\n\t\tTRACK_FUNC_OFF, track_function_options,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"wal_level\", PGC_POSTMASTER, WAL_SETTINGS,\n\t\t\tgettext_noop(\"Set the level of information written to the WAL.\"),\n\t\t\tNULL\n\t\t},\n\t\t&wal_level,\n\t\tWAL_LEVEL_REPLICA, wal_level_options,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"dynamic_shared_memory_type\", PGC_POSTMASTER, RESOURCES_MEM,\n\t\t\tgettext_noop(\"Selects the dynamic shared memory implementation used.\"),\n\t\t\tNULL\n\t\t},\n\t\t&dynamic_shared_memory_type,\n\t\tDEFAULT_DYNAMIC_SHARED_MEMORY_TYPE, dynamic_shared_memory_options,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"wal_sync_method\", PGC_SIGHUP, WAL_SETTINGS,\n\t\t\tgettext_noop(\"Selects the method used for forcing WAL updates to disk.\"),\n\t\t\tNULL\n\t\t},\n\t\t&sync_method,\n\t\tDEFAULT_SYNC_METHOD, sync_method_options,\n\t\tNULL, assign_xlog_sync_method, NULL\n\t},\n\n\t{\n\t\t{\"xmlbinary\", PGC_USERSET, CLIENT_CONN_STATEMENT,\n\t\t\tgettext_noop(\"Sets how binary values are to be encoded in XML.\"),\n\t\t\tNULL\n\t\t},\n\t\t&xmlbinary,\n\t\tXMLBINARY_BASE64, xmlbinary_options,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"xmloption\", PGC_USERSET, CLIENT_CONN_STATEMENT,\n\t\t\tgettext_noop(\"Sets whether XML data in implicit parsing and serialization \"\n\t\t\t\t\t\t \"operations is to be considered as documents or content fragments.\"),\n\t\t\tNULL\n\t\t},\n\t\t&xmloption,\n\t\tXMLOPTION_CONTENT, xmloption_options,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"huge_pages\", PGC_POSTMASTER, RESOURCES_MEM,\n\t\t\tgettext_noop(\"Use of huge pages on Linux or Windows.\"),\n\t\t\tNULL\n\t\t},\n\t\t&huge_pages,\n\t\tHUGE_PAGES_TRY, huge_pages_options,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"force_parallel_mode\", PGC_USERSET, QUERY_TUNING_OTHER,\n\t\t\tgettext_noop(\"Forces use of parallel query facilities.\"),\n\t\t\tgettext_noop(\"If possible, run query using a parallel worker and with parallel restrictions.\")\n\t\t},\n\t\t&force_parallel_mode,\n\t\tFORCE_PARALLEL_OFF, force_parallel_mode_options,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"password_encryption\", PGC_USERSET, CONN_AUTH_AUTH,\n\t\t\tgettext_noop(\"Encrypt passwords.\"),\n\t\t\tgettext_noop(\"When a password is specified in CREATE USER or \"\n\t\t\t\t\t\t \"ALTER USER without writing either ENCRYPTED or UNENCRYPTED, \"\n\t\t\t\t\t\t \"this parameter determines whether the password is to be encrypted.\")\n\t\t},\n\t\t&Password_encryption,\n\t\tPASSWORD_TYPE_MD5, password_encryption_options,\n\t\tNULL, NULL, NULL\n\t},\n\n\t/* End-of-list marker */\n\t{\n\t\t{NULL, 0, 0, NULL, NULL}, NULL, 0, NULL, NULL, NULL, NULL\n\t}\n};",
            "static struct config_generic **guc_variables;",
            "static int\tnum_guc_variables;",
            "static int\tsize_guc_variables;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"guc-file.c\"\n#include \"utils/xml.h\"\n#include \"utils/varlena.h\"\n#include \"utils/tzparser.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/ps_status.h\"\n#include \"utils/portal.h\"\n#include \"utils/plancache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc_tables.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_cache.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/predicate.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/large_object.h\"\n#include \"storage/fd.h\"\n#include \"storage/standby.h\"\n#include \"storage/dsm_impl.h\"\n#include \"storage/bufmgr.h\"\n#include \"replication/walsender.h\"\n#include \"replication/walreceiver.h\"\n#include \"replication/syncrep.h\"\n#include \"replication/slot.h\"\n#include \"replication/logicallauncher.h\"\n#include \"postmaster/walwriter.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/bgwriter.h\"\n#include \"postmaster/bgworker_internals.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parser.h\"\n#include \"parser/parse_type.h\"\n#include \"parser/parse_expr.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/geqo.h\"\n#include \"optimizer/cost.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"libpq/auth.h\"\n#include \"jit/jit.h\"\n#include \"funcapi.h\"\n#include \"commands/trigger.h\"\n#include \"commands/variable.h\"\n#include \"commands/vacuum.h\"\n#include \"commands/user.h\"\n#include \"commands/prepare.h\"\n#include \"commands/async.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xlog_internal.h\"\n#include \"access/xact.h\"\n#include \"access/twophase.h\"\n#include \"access/transam.h\"\n#include \"access/rmgr.h\"\n#include \"access/gin.h\"\n#include \"access/commit_ts.h\"\n#include <syslog.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic struct config_bool ConfigureNamesBool[] =\n{\n\t{\n\t\t{\"enable_seqscan\", PGC_USERSET, QUERY_TUNING_METHOD,\n\t\t\tgettext_noop(\"Enables the planner's use of sequential-scan plans.\"),\n\t\t\tNULL\n\t\t},\n\t\t&enable_seqscan,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"enable_indexscan\", PGC_USERSET, QUERY_TUNING_METHOD,\n\t\t\tgettext_noop(\"Enables the planner's use of index-scan plans.\"),\n\t\t\tNULL\n\t\t},\n\t\t&enable_indexscan,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"enable_indexonlyscan\", PGC_USERSET, QUERY_TUNING_METHOD,\n\t\t\tgettext_noop(\"Enables the planner's use of index-only-scan plans.\"),\n\t\t\tNULL\n\t\t},\n\t\t&enable_indexonlyscan,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"enable_bitmapscan\", PGC_USERSET, QUERY_TUNING_METHOD,\n\t\t\tgettext_noop(\"Enables the planner's use of bitmap-scan plans.\"),\n\t\t\tNULL\n\t\t},\n\t\t&enable_bitmapscan,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"enable_tidscan\", PGC_USERSET, QUERY_TUNING_METHOD,\n\t\t\tgettext_noop(\"Enables the planner's use of TID scan plans.\"),\n\t\t\tNULL\n\t\t},\n\t\t&enable_tidscan,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"enable_sort\", PGC_USERSET, QUERY_TUNING_METHOD,\n\t\t\tgettext_noop(\"Enables the planner's use of explicit sort steps.\"),\n\t\t\tNULL\n\t\t},\n\t\t&enable_sort,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"enable_hashagg\", PGC_USERSET, QUERY_TUNING_METHOD,\n\t\t\tgettext_noop(\"Enables the planner's use of hashed aggregation plans.\"),\n\t\t\tNULL\n\t\t},\n\t\t&enable_hashagg,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"enable_material\", PGC_USERSET, QUERY_TUNING_METHOD,\n\t\t\tgettext_noop(\"Enables the planner's use of materialization.\"),\n\t\t\tNULL\n\t\t},\n\t\t&enable_material,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"enable_nestloop\", PGC_USERSET, QUERY_TUNING_METHOD,\n\t\t\tgettext_noop(\"Enables the planner's use of nested-loop join plans.\"),\n\t\t\tNULL\n\t\t},\n\t\t&enable_nestloop,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"enable_mergejoin\", PGC_USERSET, QUERY_TUNING_METHOD,\n\t\t\tgettext_noop(\"Enables the planner's use of merge join plans.\"),\n\t\t\tNULL\n\t\t},\n\t\t&enable_mergejoin,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"enable_hashjoin\", PGC_USERSET, QUERY_TUNING_METHOD,\n\t\t\tgettext_noop(\"Enables the planner's use of hash join plans.\"),\n\t\t\tNULL\n\t\t},\n\t\t&enable_hashjoin,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"enable_gathermerge\", PGC_USERSET, QUERY_TUNING_METHOD,\n\t\t\tgettext_noop(\"Enables the planner's use of gather merge plans.\"),\n\t\t\tNULL\n\t\t},\n\t\t&enable_gathermerge,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"enable_partitionwise_join\", PGC_USERSET, QUERY_TUNING_METHOD,\n\t\t\tgettext_noop(\"Enables partitionwise join.\"),\n\t\t\tNULL\n\t\t},\n\t\t&enable_partitionwise_join,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"enable_partitionwise_aggregate\", PGC_USERSET, QUERY_TUNING_METHOD,\n\t\t\tgettext_noop(\"Enables partitionwise aggregation and grouping.\"),\n\t\t\tNULL\n\t\t},\n\t\t&enable_partitionwise_aggregate,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"enable_parallel_append\", PGC_USERSET, QUERY_TUNING_METHOD,\n\t\t\tgettext_noop(\"Enables the planner's use of parallel append plans.\"),\n\t\t\tNULL\n\t\t},\n\t\t&enable_parallel_append,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"enable_parallel_hash\", PGC_USERSET, QUERY_TUNING_METHOD,\n\t\t\tgettext_noop(\"Enables the planner's use of parallel hash plans.\"),\n\t\t\tNULL\n\t\t},\n\t\t&enable_parallel_hash,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"enable_partition_pruning\", PGC_USERSET, QUERY_TUNING_METHOD,\n\t\t\tgettext_noop(\"Enable plan-time and run-time partition pruning.\"),\n\t\t\tgettext_noop(\"Allows the query planner and executor to compare partition \"\n\t\t\t\t\t\t \"bounds to conditions in the query to determine which \"\n\t\t\t\t\t\t \"partitions must be scanned.\")\n\t\t},\n\t\t&enable_partition_pruning,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"geqo\", PGC_USERSET, QUERY_TUNING_GEQO,\n\t\t\tgettext_noop(\"Enables genetic query optimization.\"),\n\t\t\tgettext_noop(\"This algorithm attempts to do planning without \"\n\t\t\t\t\t\t \"exhaustive searching.\")\n\t\t},\n\t\t&enable_geqo,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t/* Not for general use --- used by SET SESSION AUTHORIZATION */\n\t\t{\"is_superuser\", PGC_INTERNAL, UNGROUPED,\n\t\t\tgettext_noop(\"Shows whether the current user is a superuser.\"),\n\t\t\tNULL,\n\t\t\tGUC_REPORT | GUC_NO_SHOW_ALL | GUC_NO_RESET_ALL | GUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE\n\t\t},\n\t\t&session_auth_is_superuser,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"bonjour\", PGC_POSTMASTER, CONN_AUTH_SETTINGS,\n\t\t\tgettext_noop(\"Enables advertising the server via Bonjour.\"),\n\t\t\tNULL\n\t\t},\n\t\t&enable_bonjour,\n\t\tfalse,\n\t\tcheck_bonjour, NULL, NULL\n\t},\n\t{\n\t\t{\"track_commit_timestamp\", PGC_POSTMASTER, REPLICATION,\n\t\t\tgettext_noop(\"Collects transaction commit time.\"),\n\t\t\tNULL\n\t\t},\n\t\t&track_commit_timestamp,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"ssl\", PGC_SIGHUP, CONN_AUTH_SSL,\n\t\t\tgettext_noop(\"Enables SSL connections.\"),\n\t\t\tNULL\n\t\t},\n\t\t&EnableSSL,\n\t\tfalse,\n\t\tcheck_ssl, NULL, NULL\n\t},\n\t{\n\t\t{\"ssl_passphrase_command_supports_reload\", PGC_SIGHUP, CONN_AUTH_SSL,\n\t\t\tgettext_noop(\"Also use ssl_passphrase_command during server reload.\"),\n\t\t\tNULL\n\t\t},\n\t\t&ssl_passphrase_command_supports_reload,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"ssl_prefer_server_ciphers\", PGC_SIGHUP, CONN_AUTH_SSL,\n\t\t\tgettext_noop(\"Give priority to server ciphersuite order.\"),\n\t\t\tNULL\n\t\t},\n\t\t&SSLPreferServerCiphers,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"fsync\", PGC_SIGHUP, WAL_SETTINGS,\n\t\t\tgettext_noop(\"Forces synchronization of updates to disk.\"),\n\t\t\tgettext_noop(\"The server will use the fsync() system call in several places to make \"\n\t\t\t\t\t\t \"sure that updates are physically written to disk. This insures \"\n\t\t\t\t\t\t \"that a database cluster will recover to a consistent state after \"\n\t\t\t\t\t\t \"an operating system or hardware crash.\")\n\t\t},\n\t\t&enableFsync,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"ignore_checksum_failure\", PGC_SUSET, DEVELOPER_OPTIONS,\n\t\t\tgettext_noop(\"Continues processing after a checksum failure.\"),\n\t\t\tgettext_noop(\"Detection of a checksum failure normally causes PostgreSQL to \"\n\t\t\t\t\t\t \"report an error, aborting the current transaction. Setting \"\n\t\t\t\t\t\t \"ignore_checksum_failure to true causes the system to ignore the failure \"\n\t\t\t\t\t\t \"(but still report a warning), and continue processing. This \"\n\t\t\t\t\t\t \"behavior could cause crashes or other serious problems. Only \"\n\t\t\t\t\t\t \"has an effect if checksums are enabled.\"),\n\t\t\tGUC_NOT_IN_SAMPLE\n\t\t},\n\t\t&ignore_checksum_failure,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"zero_damaged_pages\", PGC_SUSET, DEVELOPER_OPTIONS,\n\t\t\tgettext_noop(\"Continues processing past damaged page headers.\"),\n\t\t\tgettext_noop(\"Detection of a damaged page header normally causes PostgreSQL to \"\n\t\t\t\t\t\t \"report an error, aborting the current transaction. Setting \"\n\t\t\t\t\t\t \"zero_damaged_pages to true causes the system to instead report a \"\n\t\t\t\t\t\t \"warning, zero out the damaged page, and continue processing. This \"\n\t\t\t\t\t\t \"behavior will destroy data, namely all the rows on the damaged page.\"),\n\t\t\tGUC_NOT_IN_SAMPLE\n\t\t},\n\t\t&zero_damaged_pages,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"full_page_writes\", PGC_SIGHUP, WAL_SETTINGS,\n\t\t\tgettext_noop(\"Writes full pages to WAL when first modified after a checkpoint.\"),\n\t\t\tgettext_noop(\"A page write in process during an operating system crash might be \"\n\t\t\t\t\t\t \"only partially written to disk.  During recovery, the row changes \"\n\t\t\t\t\t\t \"stored in WAL are not enough to recover.  This option writes \"\n\t\t\t\t\t\t \"pages when first modified after a checkpoint to WAL so full recovery \"\n\t\t\t\t\t\t \"is possible.\")\n\t\t},\n\t\t&fullPageWrites,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"wal_log_hints\", PGC_POSTMASTER, WAL_SETTINGS,\n\t\t\tgettext_noop(\"Writes full pages to WAL when first modified after a checkpoint, even for a non-critical modifications.\"),\n\t\t\tNULL\n\t\t},\n\t\t&wal_log_hints,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"wal_compression\", PGC_SUSET, WAL_SETTINGS,\n\t\t\tgettext_noop(\"Compresses full-page writes written in WAL file.\"),\n\t\t\tNULL\n\t\t},\n\t\t&wal_compression,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"log_checkpoints\", PGC_SIGHUP, LOGGING_WHAT,\n\t\t\tgettext_noop(\"Logs each checkpoint.\"),\n\t\t\tNULL\n\t\t},\n\t\t&log_checkpoints,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"log_connections\", PGC_SU_BACKEND, LOGGING_WHAT,\n\t\t\tgettext_noop(\"Logs each successful connection.\"),\n\t\t\tNULL\n\t\t},\n\t\t&Log_connections,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"log_disconnections\", PGC_SU_BACKEND, LOGGING_WHAT,\n\t\t\tgettext_noop(\"Logs end of a session, including duration.\"),\n\t\t\tNULL\n\t\t},\n\t\t&Log_disconnections,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"log_replication_commands\", PGC_SUSET, LOGGING_WHAT,\n\t\t\tgettext_noop(\"Logs each replication command.\"),\n\t\t\tNULL\n\t\t},\n\t\t&log_replication_commands,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"debug_assertions\", PGC_INTERNAL, PRESET_OPTIONS,\n\t\t\tgettext_noop(\"Shows whether the running server has assertion checks enabled.\"),\n\t\t\tNULL,\n\t\t\tGUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE\n\t\t},\n\t\t&assert_enabled,\n#ifdef USE_ASSERT_CHECKING\n\t\ttrue,\n#else\n\t\tfalse,\n#endif\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"exit_on_error\", PGC_USERSET, ERROR_HANDLING_OPTIONS,\n\t\t\tgettext_noop(\"Terminate session on any error.\"),\n\t\t\tNULL\n\t\t},\n\t\t&ExitOnAnyError,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"restart_after_crash\", PGC_SIGHUP, ERROR_HANDLING_OPTIONS,\n\t\t\tgettext_noop(\"Reinitialize server after backend crash.\"),\n\t\t\tNULL\n\t\t},\n\t\t&restart_after_crash,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"log_duration\", PGC_SUSET, LOGGING_WHAT,\n\t\t\tgettext_noop(\"Logs the duration of each completed SQL statement.\"),\n\t\t\tNULL\n\t\t},\n\t\t&log_duration,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"debug_print_parse\", PGC_USERSET, LOGGING_WHAT,\n\t\t\tgettext_noop(\"Logs each query's parse tree.\"),\n\t\t\tNULL\n\t\t},\n\t\t&Debug_print_parse,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"debug_print_rewritten\", PGC_USERSET, LOGGING_WHAT,\n\t\t\tgettext_noop(\"Logs each query's rewritten parse tree.\"),\n\t\t\tNULL\n\t\t},\n\t\t&Debug_print_rewritten,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"debug_print_plan\", PGC_USERSET, LOGGING_WHAT,\n\t\t\tgettext_noop(\"Logs each query's execution plan.\"),\n\t\t\tNULL\n\t\t},\n\t\t&Debug_print_plan,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"debug_pretty_print\", PGC_USERSET, LOGGING_WHAT,\n\t\t\tgettext_noop(\"Indents parse and plan tree displays.\"),\n\t\t\tNULL\n\t\t},\n\t\t&Debug_pretty_print,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"log_parser_stats\", PGC_SUSET, STATS_MONITORING,\n\t\t\tgettext_noop(\"Writes parser performance statistics to the server log.\"),\n\t\t\tNULL\n\t\t},\n\t\t&log_parser_stats,\n\t\tfalse,\n\t\tcheck_stage_log_stats, NULL, NULL\n\t},\n\t{\n\t\t{\"log_planner_stats\", PGC_SUSET, STATS_MONITORING,\n\t\t\tgettext_noop(\"Writes planner performance statistics to the server log.\"),\n\t\t\tNULL\n\t\t},\n\t\t&log_planner_stats,\n\t\tfalse,\n\t\tcheck_stage_log_stats, NULL, NULL\n\t},\n\t{\n\t\t{\"log_executor_stats\", PGC_SUSET, STATS_MONITORING,\n\t\t\tgettext_noop(\"Writes executor performance statistics to the server log.\"),\n\t\t\tNULL\n\t\t},\n\t\t&log_executor_stats,\n\t\tfalse,\n\t\tcheck_stage_log_stats, NULL, NULL\n\t},\n\t{\n\t\t{\"log_statement_stats\", PGC_SUSET, STATS_MONITORING,\n\t\t\tgettext_noop(\"Writes cumulative performance statistics to the server log.\"),\n\t\t\tNULL\n\t\t},\n\t\t&log_statement_stats,\n\t\tfalse,\n\t\tcheck_log_stats, NULL, NULL\n\t},\n#ifdef BTREE_BUILD_STATS\n\t{\n\t\t{\"log_btree_build_stats\", PGC_SUSET, DEVELOPER_OPTIONS,\n\t\t\tgettext_noop(\"Logs system resource usage statistics (memory and CPU) on various B-tree operations.\"),\n\t\t\tNULL,\n\t\t\tGUC_NOT_IN_SAMPLE\n\t\t},\n\t\t&log_btree_build_stats,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n#endif\n\n\t{\n\t\t{\"track_activities\", PGC_SUSET, STATS_COLLECTOR,\n\t\t\tgettext_noop(\"Collects information about executing commands.\"),\n\t\t\tgettext_noop(\"Enables the collection of information on the currently \"\n\t\t\t\t\t\t \"executing command of each session, along with \"\n\t\t\t\t\t\t \"the time at which that command began execution.\")\n\t\t},\n\t\t&pgstat_track_activities,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"track_counts\", PGC_SUSET, STATS_COLLECTOR,\n\t\t\tgettext_noop(\"Collects statistics on database activity.\"),\n\t\t\tNULL\n\t\t},\n\t\t&pgstat_track_counts,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"track_io_timing\", PGC_SUSET, STATS_COLLECTOR,\n\t\t\tgettext_noop(\"Collects timing statistics for database I/O activity.\"),\n\t\t\tNULL\n\t\t},\n\t\t&track_io_timing,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"update_process_title\", PGC_SUSET, PROCESS_TITLE,\n\t\t\tgettext_noop(\"Updates the process title to show the active SQL command.\"),\n\t\t\tgettext_noop(\"Enables updating of the process title every time a new SQL command is received by the server.\")\n\t\t},\n\t\t&update_process_title,\n#ifdef WIN32\n\t\tfalse,\n#else\n\t\ttrue,\n#endif\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"autovacuum\", PGC_SIGHUP, AUTOVACUUM,\n\t\t\tgettext_noop(\"Starts the autovacuum subprocess.\"),\n\t\t\tNULL\n\t\t},\n\t\t&autovacuum_start_daemon,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"trace_notify\", PGC_USERSET, DEVELOPER_OPTIONS,\n\t\t\tgettext_noop(\"Generates debugging output for LISTEN and NOTIFY.\"),\n\t\t\tNULL,\n\t\t\tGUC_NOT_IN_SAMPLE\n\t\t},\n\t\t&Trace_notify,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\n#ifdef LOCK_DEBUG\n\t{\n\t\t{\"trace_locks\", PGC_SUSET, DEVELOPER_OPTIONS,\n\t\t\tgettext_noop(\"Emits information about lock usage.\"),\n\t\t\tNULL,\n\t\t\tGUC_NOT_IN_SAMPLE\n\t\t},\n\t\t&Trace_locks,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"trace_userlocks\", PGC_SUSET, DEVELOPER_OPTIONS,\n\t\t\tgettext_noop(\"Emits information about user lock usage.\"),\n\t\t\tNULL,\n\t\t\tGUC_NOT_IN_SAMPLE\n\t\t},\n\t\t&Trace_userlocks,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"trace_lwlocks\", PGC_SUSET, DEVELOPER_OPTIONS,\n\t\t\tgettext_noop(\"Emits information about lightweight lock usage.\"),\n\t\t\tNULL,\n\t\t\tGUC_NOT_IN_SAMPLE\n\t\t},\n\t\t&Trace_lwlocks,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"debug_deadlocks\", PGC_SUSET, DEVELOPER_OPTIONS,\n\t\t\tgettext_noop(\"Dumps information about all current locks when a deadlock timeout occurs.\"),\n\t\t\tNULL,\n\t\t\tGUC_NOT_IN_SAMPLE\n\t\t},\n\t\t&Debug_deadlocks,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n#endif\n\n\t{\n\t\t{\"log_lock_waits\", PGC_SUSET, LOGGING_WHAT,\n\t\t\tgettext_noop(\"Logs long lock waits.\"),\n\t\t\tNULL\n\t\t},\n\t\t&log_lock_waits,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"log_hostname\", PGC_SIGHUP, LOGGING_WHAT,\n\t\t\tgettext_noop(\"Logs the host name in the connection logs.\"),\n\t\t\tgettext_noop(\"By default, connection logs only show the IP address \"\n\t\t\t\t\t\t \"of the connecting host. If you want them to show the host name you \"\n\t\t\t\t\t\t \"can turn this on, but depending on your host name resolution \"\n\t\t\t\t\t\t \"setup it might impose a non-negligible performance penalty.\")\n\t\t},\n\t\t&log_hostname,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"transform_null_equals\", PGC_USERSET, COMPAT_OPTIONS_CLIENT,\n\t\t\tgettext_noop(\"Treats \\\"expr=NULL\\\" as \\\"expr IS NULL\\\".\"),\n\t\t\tgettext_noop(\"When turned on, expressions of the form expr = NULL \"\n\t\t\t\t\t\t \"(or NULL = expr) are treated as expr IS NULL, that is, they \"\n\t\t\t\t\t\t \"return true if expr evaluates to the null value, and false \"\n\t\t\t\t\t\t \"otherwise. The correct behavior of expr = NULL is to always \"\n\t\t\t\t\t\t \"return null (unknown).\")\n\t\t},\n\t\t&Transform_null_equals,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"db_user_namespace\", PGC_SIGHUP, CONN_AUTH_AUTH,\n\t\t\tgettext_noop(\"Enables per-database user names.\"),\n\t\t\tNULL\n\t\t},\n\t\t&Db_user_namespace,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"default_transaction_read_only\", PGC_USERSET, CLIENT_CONN_STATEMENT,\n\t\t\tgettext_noop(\"Sets the default read-only status of new transactions.\"),\n\t\t\tNULL\n\t\t},\n\t\t&DefaultXactReadOnly,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"transaction_read_only\", PGC_USERSET, CLIENT_CONN_STATEMENT,\n\t\t\tgettext_noop(\"Sets the current transaction's read-only status.\"),\n\t\t\tNULL,\n\t\t\tGUC_NO_RESET_ALL | GUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE\n\t\t},\n\t\t&XactReadOnly,\n\t\tfalse,\n\t\tcheck_transaction_read_only, NULL, NULL\n\t},\n\t{\n\t\t{\"default_transaction_deferrable\", PGC_USERSET, CLIENT_CONN_STATEMENT,\n\t\t\tgettext_noop(\"Sets the default deferrable status of new transactions.\"),\n\t\t\tNULL\n\t\t},\n\t\t&DefaultXactDeferrable,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"transaction_deferrable\", PGC_USERSET, CLIENT_CONN_STATEMENT,\n\t\t\tgettext_noop(\"Whether to defer a read-only serializable transaction until it can be executed with no possible serialization failures.\"),\n\t\t\tNULL,\n\t\t\tGUC_NO_RESET_ALL | GUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE\n\t\t},\n\t\t&XactDeferrable,\n\t\tfalse,\n\t\tcheck_transaction_deferrable, NULL, NULL\n\t},\n\t{\n\t\t{\"row_security\", PGC_USERSET, CLIENT_CONN_STATEMENT,\n\t\t\tgettext_noop(\"Enable row security.\"),\n\t\t\tgettext_noop(\"When enabled, row security will be applied to all users.\")\n\t\t},\n\t\t&row_security,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"check_function_bodies\", PGC_USERSET, CLIENT_CONN_STATEMENT,\n\t\t\tgettext_noop(\"Check function bodies during CREATE FUNCTION.\"),\n\t\t\tNULL\n\t\t},\n\t\t&check_function_bodies,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"array_nulls\", PGC_USERSET, COMPAT_OPTIONS_PREVIOUS,\n\t\t\tgettext_noop(\"Enable input of NULL elements in arrays.\"),\n\t\t\tgettext_noop(\"When turned on, unquoted NULL in an array input \"\n\t\t\t\t\t\t \"value means a null value; \"\n\t\t\t\t\t\t \"otherwise it is taken literally.\")\n\t\t},\n\t\t&Array_nulls,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"default_with_oids\", PGC_USERSET, COMPAT_OPTIONS_PREVIOUS,\n\t\t\tgettext_noop(\"Create new tables with OIDs by default.\"),\n\t\t\tNULL\n\t\t},\n\t\t&default_with_oids,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"logging_collector\", PGC_POSTMASTER, LOGGING_WHERE,\n\t\t\tgettext_noop(\"Start a subprocess to capture stderr output and/or csvlogs into log files.\"),\n\t\t\tNULL\n\t\t},\n\t\t&Logging_collector,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"log_truncate_on_rotation\", PGC_SIGHUP, LOGGING_WHERE,\n\t\t\tgettext_noop(\"Truncate existing log files of same name during log rotation.\"),\n\t\t\tNULL\n\t\t},\n\t\t&Log_truncate_on_rotation,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\n#ifdef TRACE_SORT\n\t{\n\t\t{\"trace_sort\", PGC_USERSET, DEVELOPER_OPTIONS,\n\t\t\tgettext_noop(\"Emit information about resource usage in sorting.\"),\n\t\t\tNULL,\n\t\t\tGUC_NOT_IN_SAMPLE\n\t\t},\n\t\t&trace_sort,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n#endif\n\n#ifdef TRACE_SYNCSCAN\n\t/* this is undocumented because not exposed in a standard build */\n\t{\n\t\t{\"trace_syncscan\", PGC_USERSET, DEVELOPER_OPTIONS,\n\t\t\tgettext_noop(\"Generate debugging output for synchronized scanning.\"),\n\t\t\tNULL,\n\t\t\tGUC_NOT_IN_SAMPLE\n\t\t},\n\t\t&trace_syncscan,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n#endif\n\n#ifdef DEBUG_BOUNDED_SORT\n\t/* this is undocumented because not exposed in a standard build */\n\t{\n\t\t{\n\t\t\t\"optimize_bounded_sort\", PGC_USERSET, QUERY_TUNING_METHOD,\n\t\t\tgettext_noop(\"Enable bounded sorting using heap sort.\"),\n\t\t\tNULL,\n\t\t\tGUC_NOT_IN_SAMPLE\n\t\t},\n\t\t&optimize_bounded_sort,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n#endif\n\n#ifdef WAL_DEBUG\n\t{\n\t\t{\"wal_debug\", PGC_SUSET, DEVELOPER_OPTIONS,\n\t\t\tgettext_noop(\"Emit WAL-related debugging output.\"),\n\t\t\tNULL,\n\t\t\tGUC_NOT_IN_SAMPLE\n\t\t},\n\t\t&XLOG_DEBUG,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n#endif\n\n\t{\n\t\t{\"integer_datetimes\", PGC_INTERNAL, PRESET_OPTIONS,\n\t\t\tgettext_noop(\"Datetimes are integer based.\"),\n\t\t\tNULL,\n\t\t\tGUC_REPORT | GUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE\n\t\t},\n\t\t&integer_datetimes,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"krb_caseins_users\", PGC_SIGHUP, CONN_AUTH_AUTH,\n\t\t\tgettext_noop(\"Sets whether Kerberos and GSSAPI user names should be treated as case-insensitive.\"),\n\t\t\tNULL\n\t\t},\n\t\t&pg_krb_caseins_users,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"escape_string_warning\", PGC_USERSET, COMPAT_OPTIONS_PREVIOUS,\n\t\t\tgettext_noop(\"Warn about backslash escapes in ordinary string literals.\"),\n\t\t\tNULL\n\t\t},\n\t\t&escape_string_warning,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"standard_conforming_strings\", PGC_USERSET, COMPAT_OPTIONS_PREVIOUS,\n\t\t\tgettext_noop(\"Causes '...' strings to treat backslashes literally.\"),\n\t\t\tNULL,\n\t\t\tGUC_REPORT\n\t\t},\n\t\t&standard_conforming_strings,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"synchronize_seqscans\", PGC_USERSET, COMPAT_OPTIONS_PREVIOUS,\n\t\t\tgettext_noop(\"Enable synchronized sequential scans.\"),\n\t\t\tNULL\n\t\t},\n\t\t&synchronize_seqscans,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"hot_standby\", PGC_POSTMASTER, REPLICATION_STANDBY,\n\t\t\tgettext_noop(\"Allows connections and queries during recovery.\"),\n\t\t\tNULL\n\t\t},\n\t\t&EnableHotStandby,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"hot_standby_feedback\", PGC_SIGHUP, REPLICATION_STANDBY,\n\t\t\tgettext_noop(\"Allows feedback from a hot standby to the primary that will avoid query conflicts.\"),\n\t\t\tNULL\n\t\t},\n\t\t&hot_standby_feedback,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"allow_system_table_mods\", PGC_POSTMASTER, DEVELOPER_OPTIONS,\n\t\t\tgettext_noop(\"Allows modifications of the structure of system tables.\"),\n\t\t\tNULL,\n\t\t\tGUC_NOT_IN_SAMPLE\n\t\t},\n\t\t&allowSystemTableMods,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"ignore_system_indexes\", PGC_BACKEND, DEVELOPER_OPTIONS,\n\t\t\tgettext_noop(\"Disables reading from system indexes.\"),\n\t\t\tgettext_noop(\"It does not prevent updating the indexes, so it is safe \"\n\t\t\t\t\t\t \"to use.  The worst consequence is slowness.\"),\n\t\t\tGUC_NOT_IN_SAMPLE\n\t\t},\n\t\t&IgnoreSystemIndexes,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"lo_compat_privileges\", PGC_SUSET, COMPAT_OPTIONS_PREVIOUS,\n\t\t\tgettext_noop(\"Enables backward compatibility mode for privilege checks on large objects.\"),\n\t\t\tgettext_noop(\"Skips privilege checks when reading or modifying large objects, \"\n\t\t\t\t\t\t \"for compatibility with PostgreSQL releases prior to 9.0.\")\n\t\t},\n\t\t&lo_compat_privileges,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"operator_precedence_warning\", PGC_USERSET, COMPAT_OPTIONS_PREVIOUS,\n\t\t\tgettext_noop(\"Emit a warning for constructs that changed meaning since PostgreSQL 9.4.\"),\n\t\t\tNULL,\n\t\t},\n\t\t&operator_precedence_warning,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"quote_all_identifiers\", PGC_USERSET, COMPAT_OPTIONS_PREVIOUS,\n\t\t\tgettext_noop(\"When generating SQL fragments, quote all identifiers.\"),\n\t\t\tNULL,\n\t\t},\n\t\t&quote_all_identifiers,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"data_checksums\", PGC_INTERNAL, PRESET_OPTIONS,\n\t\t\tgettext_noop(\"Shows whether data checksums are turned on for this cluster.\"),\n\t\t\tNULL,\n\t\t\tGUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE\n\t\t},\n\t\t&data_checksums,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"syslog_sequence_numbers\", PGC_SIGHUP, LOGGING_WHERE,\n\t\t\tgettext_noop(\"Add sequence number to syslog messages to avoid duplicate suppression.\"),\n\t\t\tNULL\n\t\t},\n\t\t&syslog_sequence_numbers,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"syslog_split_messages\", PGC_SIGHUP, LOGGING_WHERE,\n\t\t\tgettext_noop(\"Split messages sent to syslog by lines and to fit into 1024 bytes.\"),\n\t\t\tNULL\n\t\t},\n\t\t&syslog_split_messages,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"parallel_leader_participation\", PGC_USERSET, RESOURCES_ASYNCHRONOUS,\n\t\t\tgettext_noop(\"Controls whether Gather and Gather Merge also run subplans.\"),\n\t\t\tgettext_noop(\"Should gather nodes also run subplans, or just gather tuples?\")\n\t\t},\n\t\t&parallel_leader_participation,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"jit\", PGC_USERSET, QUERY_TUNING_OTHER,\n\t\t\tgettext_noop(\"Allow JIT compilation.\"),\n\t\t\tNULL\n\t\t},\n\t\t&jit_enabled,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"jit_debugging_support\", PGC_SU_BACKEND, DEVELOPER_OPTIONS,\n\t\t\tgettext_noop(\"Register JIT compiled function with debugger.\"),\n\t\t\tNULL,\n\t\t\tGUC_NOT_IN_SAMPLE\n\t\t},\n\t\t&jit_debugging_support,\n\t\tfalse,\n\n\t\t/*\n\t\t * This is not guaranteed to be available, but given it's a developer\n\t\t * oriented option, it doesn't seem worth adding code checking\n\t\t * availability.\n\t\t */\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"jit_dump_bitcode\", PGC_SUSET, DEVELOPER_OPTIONS,\n\t\t\tgettext_noop(\"Write out LLVM bitcode to facilitate JIT debugging.\"),\n\t\t\tNULL,\n\t\t\tGUC_NOT_IN_SAMPLE\n\t\t},\n\t\t&jit_dump_bitcode,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"jit_expressions\", PGC_USERSET, DEVELOPER_OPTIONS,\n\t\t\tgettext_noop(\"Allow JIT compilation of expressions.\"),\n\t\t\tNULL,\n\t\t\tGUC_NOT_IN_SAMPLE\n\t\t},\n\t\t&jit_expressions,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"jit_profiling_support\", PGC_SU_BACKEND, DEVELOPER_OPTIONS,\n\t\t\tgettext_noop(\"Register JIT compiled function with perf profiler.\"),\n\t\t\tNULL,\n\t\t\tGUC_NOT_IN_SAMPLE\n\t\t},\n\t\t&jit_profiling_support,\n\t\tfalse,\n\n\t\t/*\n\t\t * This is not guaranteed to be available, but given it's a developer\n\t\t * oriented option, it doesn't seem worth adding code checking\n\t\t * availability.\n\t\t */\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"jit_tuple_deforming\", PGC_USERSET, DEVELOPER_OPTIONS,\n\t\t\tgettext_noop(\"Allow JIT compilation of tuple deforming.\"),\n\t\t\tNULL,\n\t\t\tGUC_NOT_IN_SAMPLE\n\t\t},\n\t\t&jit_tuple_deforming,\n\t\ttrue,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"data_sync_retry\", PGC_POSTMASTER, ERROR_HANDLING_OPTIONS,\n\t\t\tgettext_noop(\"Whether to continue running after a failure to sync data files.\"),\n\t\t},\n\t\t&data_sync_retry,\n\t\tfalse,\n\t\tNULL, NULL, NULL\n\t},\n\n\t/* End-of-list marker */\n\t{\n\t\t{NULL, 0, 0, NULL, NULL}, NULL, false, NULL, NULL, NULL\n\t}\n};\nstatic struct config_int ConfigureNamesInt[] =\n{\n\t{\n\t\t{\"archive_timeout\", PGC_SIGHUP, WAL_ARCHIVING,\n\t\t\tgettext_noop(\"Forces a switch to the next WAL file if a \"\n\t\t\t\t\t\t \"new file has not been started within N seconds.\"),\n\t\t\tNULL,\n\t\t\tGUC_UNIT_S\n\t\t},\n\t\t&XLogArchiveTimeout,\n\t\t0, 0, INT_MAX / 2,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"post_auth_delay\", PGC_BACKEND, DEVELOPER_OPTIONS,\n\t\t\tgettext_noop(\"Waits N seconds on connection startup after authentication.\"),\n\t\t\tgettext_noop(\"This allows attaching a debugger to the process.\"),\n\t\t\tGUC_NOT_IN_SAMPLE | GUC_UNIT_S\n\t\t},\n\t\t&PostAuthDelay,\n\t\t0, 0, INT_MAX / 1000000,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"default_statistics_target\", PGC_USERSET, QUERY_TUNING_OTHER,\n\t\t\tgettext_noop(\"Sets the default statistics target.\"),\n\t\t\tgettext_noop(\"This applies to table columns that have not had a \"\n\t\t\t\t\t\t \"column-specific target set via ALTER TABLE SET STATISTICS.\")\n\t\t},\n\t\t&default_statistics_target,\n\t\t100, 1, 10000,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"from_collapse_limit\", PGC_USERSET, QUERY_TUNING_OTHER,\n\t\t\tgettext_noop(\"Sets the FROM-list size beyond which subqueries \"\n\t\t\t\t\t\t \"are not collapsed.\"),\n\t\t\tgettext_noop(\"The planner will merge subqueries into upper \"\n\t\t\t\t\t\t \"queries if the resulting FROM list would have no more than \"\n\t\t\t\t\t\t \"this many items.\")\n\t\t},\n\t\t&from_collapse_limit,\n\t\t8, 1, INT_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"join_collapse_limit\", PGC_USERSET, QUERY_TUNING_OTHER,\n\t\t\tgettext_noop(\"Sets the FROM-list size beyond which JOIN \"\n\t\t\t\t\t\t \"constructs are not flattened.\"),\n\t\t\tgettext_noop(\"The planner will flatten explicit JOIN \"\n\t\t\t\t\t\t \"constructs into lists of FROM items whenever a \"\n\t\t\t\t\t\t \"list of no more than this many items would result.\")\n\t\t},\n\t\t&join_collapse_limit,\n\t\t8, 1, INT_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"geqo_threshold\", PGC_USERSET, QUERY_TUNING_GEQO,\n\t\t\tgettext_noop(\"Sets the threshold of FROM items beyond which GEQO is used.\"),\n\t\t\tNULL\n\t\t},\n\t\t&geqo_threshold,\n\t\t12, 2, INT_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"geqo_effort\", PGC_USERSET, QUERY_TUNING_GEQO,\n\t\t\tgettext_noop(\"GEQO: effort is used to set the default for other GEQO parameters.\"),\n\t\t\tNULL\n\t\t},\n\t\t&Geqo_effort,\n\t\tDEFAULT_GEQO_EFFORT, MIN_GEQO_EFFORT, MAX_GEQO_EFFORT,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"geqo_pool_size\", PGC_USERSET, QUERY_TUNING_GEQO,\n\t\t\tgettext_noop(\"GEQO: number of individuals in the population.\"),\n\t\t\tgettext_noop(\"Zero selects a suitable default value.\")\n\t\t},\n\t\t&Geqo_pool_size,\n\t\t0, 0, INT_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"geqo_generations\", PGC_USERSET, QUERY_TUNING_GEQO,\n\t\t\tgettext_noop(\"GEQO: number of iterations of the algorithm.\"),\n\t\t\tgettext_noop(\"Zero selects a suitable default value.\")\n\t\t},\n\t\t&Geqo_generations,\n\t\t0, 0, INT_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t/* This is PGC_SUSET to prevent hiding from log_lock_waits. */\n\t\t{\"deadlock_timeout\", PGC_SUSET, LOCK_MANAGEMENT,\n\t\t\tgettext_noop(\"Sets the time to wait on a lock before checking for deadlock.\"),\n\t\t\tNULL,\n\t\t\tGUC_UNIT_MS\n\t\t},\n\t\t&DeadlockTimeout,\n\t\t1000, 1, INT_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"max_standby_archive_delay\", PGC_SIGHUP, REPLICATION_STANDBY,\n\t\t\tgettext_noop(\"Sets the maximum delay before canceling queries when a hot standby server is processing archived WAL data.\"),\n\t\t\tNULL,\n\t\t\tGUC_UNIT_MS\n\t\t},\n\t\t&max_standby_archive_delay,\n\t\t30 * 1000, -1, INT_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"max_standby_streaming_delay\", PGC_SIGHUP, REPLICATION_STANDBY,\n\t\t\tgettext_noop(\"Sets the maximum delay before canceling queries when a hot standby server is processing streamed WAL data.\"),\n\t\t\tNULL,\n\t\t\tGUC_UNIT_MS\n\t\t},\n\t\t&max_standby_streaming_delay,\n\t\t30 * 1000, -1, INT_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"wal_receiver_status_interval\", PGC_SIGHUP, REPLICATION_STANDBY,\n\t\t\tgettext_noop(\"Sets the maximum interval between WAL receiver status reports to the primary.\"),\n\t\t\tNULL,\n\t\t\tGUC_UNIT_S\n\t\t},\n\t\t&wal_receiver_status_interval,\n\t\t10, 0, INT_MAX / 1000,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"wal_receiver_timeout\", PGC_SIGHUP, REPLICATION_STANDBY,\n\t\t\tgettext_noop(\"Sets the maximum wait time to receive data from the primary.\"),\n\t\t\tNULL,\n\t\t\tGUC_UNIT_MS\n\t\t},\n\t\t&wal_receiver_timeout,\n\t\t60 * 1000, 0, INT_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"max_connections\", PGC_POSTMASTER, CONN_AUTH_SETTINGS,\n\t\t\tgettext_noop(\"Sets the maximum number of concurrent connections.\"),\n\t\t\tNULL\n\t\t},\n\t\t&MaxConnections,\n\t\t100, 1, MAX_BACKENDS,\n\t\tcheck_maxconnections, NULL, NULL\n\t},\n\n\t{\n\t\t/* see max_connections and max_wal_senders */\n\t\t{\"superuser_reserved_connections\", PGC_POSTMASTER, CONN_AUTH_SETTINGS,\n\t\t\tgettext_noop(\"Sets the number of connection slots reserved for superusers.\"),\n\t\t\tNULL\n\t\t},\n\t\t&ReservedBackends,\n\t\t3, 0, MAX_BACKENDS,\n\t\tNULL, NULL, NULL\n\t},\n\n\t/*\n\t * We sometimes multiply the number of shared buffers by two without\n\t * checking for overflow, so we mustn't allow more than INT_MAX / 2.\n\t */\n\t{\n\t\t{\"shared_buffers\", PGC_POSTMASTER, RESOURCES_MEM,\n\t\t\tgettext_noop(\"Sets the number of shared memory buffers used by the server.\"),\n\t\t\tNULL,\n\t\t\tGUC_UNIT_BLOCKS\n\t\t},\n\t\t&NBuffers,\n\t\t1024, 16, INT_MAX / 2,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"temp_buffers\", PGC_USERSET, RESOURCES_MEM,\n\t\t\tgettext_noop(\"Sets the maximum number of temporary buffers used by each session.\"),\n\t\t\tNULL,\n\t\t\tGUC_UNIT_BLOCKS\n\t\t},\n\t\t&num_temp_buffers,\n\t\t1024, 100, INT_MAX / 2,\n\t\tcheck_temp_buffers, NULL, NULL\n\t},\n\n\t{\n\t\t{\"port\", PGC_POSTMASTER, CONN_AUTH_SETTINGS,\n\t\t\tgettext_noop(\"Sets the TCP port the server listens on.\"),\n\t\t\tNULL\n\t\t},\n\t\t&PostPortNumber,\n\t\tDEF_PGPORT, 1, 65535,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"unix_socket_permissions\", PGC_POSTMASTER, CONN_AUTH_SETTINGS,\n\t\t\tgettext_noop(\"Sets the access permissions of the Unix-domain socket.\"),\n\t\t\tgettext_noop(\"Unix-domain sockets use the usual Unix file system \"\n\t\t\t\t\t\t \"permission set. The parameter value is expected \"\n\t\t\t\t\t\t \"to be a numeric mode specification in the form \"\n\t\t\t\t\t\t \"accepted by the chmod and umask system calls. \"\n\t\t\t\t\t\t \"(To use the customary octal format the number must \"\n\t\t\t\t\t\t \"start with a 0 (zero).)\")\n\t\t},\n\t\t&Unix_socket_permissions,\n\t\t0777, 0000, 0777,\n\t\tNULL, NULL, show_unix_socket_permissions\n\t},\n\n\t{\n\t\t{\"log_file_mode\", PGC_SIGHUP, LOGGING_WHERE,\n\t\t\tgettext_noop(\"Sets the file permissions for log files.\"),\n\t\t\tgettext_noop(\"The parameter value is expected \"\n\t\t\t\t\t\t \"to be a numeric mode specification in the form \"\n\t\t\t\t\t\t \"accepted by the chmod and umask system calls. \"\n\t\t\t\t\t\t \"(To use the customary octal format the number must \"\n\t\t\t\t\t\t \"start with a 0 (zero).)\")\n\t\t},\n\t\t&Log_file_mode,\n\t\t0600, 0000, 0777,\n\t\tNULL, NULL, show_log_file_mode\n\t},\n\n\n\t{\n\t\t{\"data_directory_mode\", PGC_INTERNAL, PRESET_OPTIONS,\n\t\t\tgettext_noop(\"Mode of the data directory.\"),\n\t\t\tgettext_noop(\"The parameter value is a numeric mode specification \"\n\t\t\t\t\t\t \"in the form accepted by the chmod and umask system \"\n\t\t\t\t\t\t \"calls. (To use the customary octal format the number \"\n\t\t\t\t\t\t \"must start with a 0 (zero).)\"),\n\t\t\tGUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE\n\t\t},\n\t\t&data_directory_mode,\n\t\t0700, 0000, 0777,\n\t\tNULL, NULL, show_data_directory_mode\n\t},\n\n\t{\n\t\t{\"work_mem\", PGC_USERSET, RESOURCES_MEM,\n\t\t\tgettext_noop(\"Sets the maximum memory to be used for query workspaces.\"),\n\t\t\tgettext_noop(\"This much memory can be used by each internal \"\n\t\t\t\t\t\t \"sort operation and hash table before switching to \"\n\t\t\t\t\t\t \"temporary disk files.\"),\n\t\t\tGUC_UNIT_KB\n\t\t},\n\t\t&work_mem,\n\t\t4096, 64, MAX_KILOBYTES,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"maintenance_work_mem\", PGC_USERSET, RESOURCES_MEM,\n\t\t\tgettext_noop(\"Sets the maximum memory to be used for maintenance operations.\"),\n\t\t\tgettext_noop(\"This includes operations such as VACUUM and CREATE INDEX.\"),\n\t\t\tGUC_UNIT_KB\n\t\t},\n\t\t&maintenance_work_mem,\n\t\t65536, 1024, MAX_KILOBYTES,\n\t\tNULL, NULL, NULL\n\t},\n\n\t/*\n\t * We use the hopefully-safely-small value of 100kB as the compiled-in\n\t * default for max_stack_depth.  InitializeGUCOptions will increase it if\n\t * possible, depending on the actual platform-specific stack limit.\n\t */\n\t{\n\t\t{\"max_stack_depth\", PGC_SUSET, RESOURCES_MEM,\n\t\t\tgettext_noop(\"Sets the maximum stack depth, in kilobytes.\"),\n\t\t\tNULL,\n\t\t\tGUC_UNIT_KB\n\t\t},\n\t\t&max_stack_depth,\n\t\t100, 100, MAX_KILOBYTES,\n\t\tcheck_max_stack_depth, assign_max_stack_depth, NULL\n\t},\n\n\t{\n\t\t{\"temp_file_limit\", PGC_SUSET, RESOURCES_DISK,\n\t\t\tgettext_noop(\"Limits the total size of all temporary files used by each process.\"),\n\t\t\tgettext_noop(\"-1 means no limit.\"),\n\t\t\tGUC_UNIT_KB\n\t\t},\n\t\t&temp_file_limit,\n\t\t-1, -1, INT_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"vacuum_cost_page_hit\", PGC_USERSET, RESOURCES_VACUUM_DELAY,\n\t\t\tgettext_noop(\"Vacuum cost for a page found in the buffer cache.\"),\n\t\t\tNULL\n\t\t},\n\t\t&VacuumCostPageHit,\n\t\t1, 0, 10000,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"vacuum_cost_page_miss\", PGC_USERSET, RESOURCES_VACUUM_DELAY,\n\t\t\tgettext_noop(\"Vacuum cost for a page not found in the buffer cache.\"),\n\t\t\tNULL\n\t\t},\n\t\t&VacuumCostPageMiss,\n\t\t10, 0, 10000,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"vacuum_cost_page_dirty\", PGC_USERSET, RESOURCES_VACUUM_DELAY,\n\t\t\tgettext_noop(\"Vacuum cost for a page dirtied by vacuum.\"),\n\t\t\tNULL\n\t\t},\n\t\t&VacuumCostPageDirty,\n\t\t20, 0, 10000,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"vacuum_cost_limit\", PGC_USERSET, RESOURCES_VACUUM_DELAY,\n\t\t\tgettext_noop(\"Vacuum cost amount available before napping.\"),\n\t\t\tNULL\n\t\t},\n\t\t&VacuumCostLimit,\n\t\t200, 1, 10000,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"vacuum_cost_delay\", PGC_USERSET, RESOURCES_VACUUM_DELAY,\n\t\t\tgettext_noop(\"Vacuum cost delay in milliseconds.\"),\n\t\t\tNULL,\n\t\t\tGUC_UNIT_MS\n\t\t},\n\t\t&VacuumCostDelay,\n\t\t0, 0, 100,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"autovacuum_vacuum_cost_delay\", PGC_SIGHUP, AUTOVACUUM,\n\t\t\tgettext_noop(\"Vacuum cost delay in milliseconds, for autovacuum.\"),\n\t\t\tNULL,\n\t\t\tGUC_UNIT_MS\n\t\t},\n\t\t&autovacuum_vac_cost_delay,\n\t\t20, -1, 100,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"autovacuum_vacuum_cost_limit\", PGC_SIGHUP, AUTOVACUUM,\n\t\t\tgettext_noop(\"Vacuum cost amount available before napping, for autovacuum.\"),\n\t\t\tNULL\n\t\t},\n\t\t&autovacuum_vac_cost_limit,\n\t\t-1, -1, 10000,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"max_files_per_process\", PGC_POSTMASTER, RESOURCES_KERNEL,\n\t\t\tgettext_noop(\"Sets the maximum number of simultaneously open files for each server process.\"),\n\t\t\tNULL\n\t\t},\n\t\t&max_files_per_process,\n\t\t1000, 25, INT_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\n\t/*\n\t * See also CheckRequiredParameterValues() if this parameter changes\n\t */\n\t{\n\t\t{\"max_prepared_transactions\", PGC_POSTMASTER, RESOURCES_MEM,\n\t\t\tgettext_noop(\"Sets the maximum number of simultaneously prepared transactions.\"),\n\t\t\tNULL\n\t\t},\n\t\t&max_prepared_xacts,\n\t\t0, 0, MAX_BACKENDS,\n\t\tNULL, NULL, NULL\n\t},\n\n#ifdef LOCK_DEBUG\n\t{\n\t\t{\"trace_lock_oidmin\", PGC_SUSET, DEVELOPER_OPTIONS,\n\t\t\tgettext_noop(\"Sets the minimum OID of tables for tracking locks.\"),\n\t\t\tgettext_noop(\"Is used to avoid output on system tables.\"),\n\t\t\tGUC_NOT_IN_SAMPLE\n\t\t},\n\t\t&Trace_lock_oidmin,\n\t\tFirstNormalObjectId, 0, INT_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"trace_lock_table\", PGC_SUSET, DEVELOPER_OPTIONS,\n\t\t\tgettext_noop(\"Sets the OID of the table with unconditionally lock tracing.\"),\n\t\t\tNULL,\n\t\t\tGUC_NOT_IN_SAMPLE\n\t\t},\n\t\t&Trace_lock_table,\n\t\t0, 0, INT_MAX,\n\t\tNULL, NULL, NULL\n\t},\n#endif\n\n\t{\n\t\t{\"statement_timeout\", PGC_USERSET, CLIENT_CONN_STATEMENT,\n\t\t\tgettext_noop(\"Sets the maximum allowed duration of any statement.\"),\n\t\t\tgettext_noop(\"A value of 0 turns off the timeout.\"),\n\t\t\tGUC_UNIT_MS\n\t\t},\n\t\t&StatementTimeout,\n\t\t0, 0, INT_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"lock_timeout\", PGC_USERSET, CLIENT_CONN_STATEMENT,\n\t\t\tgettext_noop(\"Sets the maximum allowed duration of any wait for a lock.\"),\n\t\t\tgettext_noop(\"A value of 0 turns off the timeout.\"),\n\t\t\tGUC_UNIT_MS\n\t\t},\n\t\t&LockTimeout,\n\t\t0, 0, INT_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"idle_in_transaction_session_timeout\", PGC_USERSET, CLIENT_CONN_STATEMENT,\n\t\t\tgettext_noop(\"Sets the maximum allowed duration of any idling transaction.\"),\n\t\t\tgettext_noop(\"A value of 0 turns off the timeout.\"),\n\t\t\tGUC_UNIT_MS\n\t\t},\n\t\t&IdleInTransactionSessionTimeout,\n\t\t0, 0, INT_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"vacuum_freeze_min_age\", PGC_USERSET, CLIENT_CONN_STATEMENT,\n\t\t\tgettext_noop(\"Minimum age at which VACUUM should freeze a table row.\"),\n\t\t\tNULL\n\t\t},\n\t\t&vacuum_freeze_min_age,\n\t\t50000000, 0, 1000000000,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"vacuum_freeze_table_age\", PGC_USERSET, CLIENT_CONN_STATEMENT,\n\t\t\tgettext_noop(\"Age at which VACUUM should scan whole table to freeze tuples.\"),\n\t\t\tNULL\n\t\t},\n\t\t&vacuum_freeze_table_age,\n\t\t150000000, 0, 2000000000,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"vacuum_multixact_freeze_min_age\", PGC_USERSET, CLIENT_CONN_STATEMENT,\n\t\t\tgettext_noop(\"Minimum age at which VACUUM should freeze a MultiXactId in a table row.\"),\n\t\t\tNULL\n\t\t},\n\t\t&vacuum_multixact_freeze_min_age,\n\t\t5000000, 0, 1000000000,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"vacuum_multixact_freeze_table_age\", PGC_USERSET, CLIENT_CONN_STATEMENT,\n\t\t\tgettext_noop(\"Multixact age at which VACUUM should scan whole table to freeze tuples.\"),\n\t\t\tNULL\n\t\t},\n\t\t&vacuum_multixact_freeze_table_age,\n\t\t150000000, 0, 2000000000,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"vacuum_defer_cleanup_age\", PGC_SIGHUP, REPLICATION_MASTER,\n\t\t\tgettext_noop(\"Number of transactions by which VACUUM and HOT cleanup should be deferred, if any.\"),\n\t\t\tNULL\n\t\t},\n\t\t&vacuum_defer_cleanup_age,\n\t\t0, 0, 1000000,\n\t\tNULL, NULL, NULL\n\t},\n\n\t/*\n\t * See also CheckRequiredParameterValues() if this parameter changes\n\t */\n\t{\n\t\t{\"max_locks_per_transaction\", PGC_POSTMASTER, LOCK_MANAGEMENT,\n\t\t\tgettext_noop(\"Sets the maximum number of locks per transaction.\"),\n\t\t\tgettext_noop(\"The shared lock table is sized on the assumption that \"\n\t\t\t\t\t\t \"at most max_locks_per_transaction * max_connections distinct \"\n\t\t\t\t\t\t \"objects will need to be locked at any one time.\")\n\t\t},\n\t\t&max_locks_per_xact,\n\t\t64, 10, INT_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"max_pred_locks_per_transaction\", PGC_POSTMASTER, LOCK_MANAGEMENT,\n\t\t\tgettext_noop(\"Sets the maximum number of predicate locks per transaction.\"),\n\t\t\tgettext_noop(\"The shared predicate lock table is sized on the assumption that \"\n\t\t\t\t\t\t \"at most max_pred_locks_per_transaction * max_connections distinct \"\n\t\t\t\t\t\t \"objects will need to be locked at any one time.\")\n\t\t},\n\t\t&max_predicate_locks_per_xact,\n\t\t64, 10, INT_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"max_pred_locks_per_relation\", PGC_SIGHUP, LOCK_MANAGEMENT,\n\t\t\tgettext_noop(\"Sets the maximum number of predicate-locked pages and tuples per relation.\"),\n\t\t\tgettext_noop(\"If more than this total of pages and tuples in the same relation are locked \"\n\t\t\t\t\t\t \"by a connection, those locks are replaced by a relation-level lock.\")\n\t\t},\n\t\t&max_predicate_locks_per_relation,\n\t\t-2, INT_MIN, INT_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"max_pred_locks_per_page\", PGC_SIGHUP, LOCK_MANAGEMENT,\n\t\t\tgettext_noop(\"Sets the maximum number of predicate-locked tuples per page.\"),\n\t\t\tgettext_noop(\"If more than this number of tuples on the same page are locked \"\n\t\t\t\t\t\t \"by a connection, those locks are replaced by a page-level lock.\")\n\t\t},\n\t\t&max_predicate_locks_per_page,\n\t\t2, 0, INT_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"authentication_timeout\", PGC_SIGHUP, CONN_AUTH_AUTH,\n\t\t\tgettext_noop(\"Sets the maximum allowed time to complete client authentication.\"),\n\t\t\tNULL,\n\t\t\tGUC_UNIT_S\n\t\t},\n\t\t&AuthenticationTimeout,\n\t\t60, 1, 600,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t/* Not for general use */\n\t\t{\"pre_auth_delay\", PGC_SIGHUP, DEVELOPER_OPTIONS,\n\t\t\tgettext_noop(\"Waits N seconds on connection startup before authentication.\"),\n\t\t\tgettext_noop(\"This allows attaching a debugger to the process.\"),\n\t\t\tGUC_NOT_IN_SAMPLE | GUC_UNIT_S\n\t\t},\n\t\t&PreAuthDelay,\n\t\t0, 0, 60,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"wal_keep_segments\", PGC_SIGHUP, REPLICATION_SENDING,\n\t\t\tgettext_noop(\"Sets the number of WAL files held for standby servers.\"),\n\t\t\tNULL\n\t\t},\n\t\t&wal_keep_segments,\n\t\t0, 0, INT_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"min_wal_size\", PGC_SIGHUP, WAL_CHECKPOINTS,\n\t\t\tgettext_noop(\"Sets the minimum size to shrink the WAL to.\"),\n\t\t\tNULL,\n\t\t\tGUC_UNIT_MB\n\t\t},\n\t\t&min_wal_size_mb,\n\t\tDEFAULT_MIN_WAL_SEGS * (DEFAULT_XLOG_SEG_SIZE / (1024 * 1024)),\n\t\t2, MAX_KILOBYTES,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"max_wal_size\", PGC_SIGHUP, WAL_CHECKPOINTS,\n\t\t\tgettext_noop(\"Sets the WAL size that triggers a checkpoint.\"),\n\t\t\tNULL,\n\t\t\tGUC_UNIT_MB\n\t\t},\n\t\t&max_wal_size_mb,\n\t\tDEFAULT_MAX_WAL_SEGS * (DEFAULT_XLOG_SEG_SIZE / (1024 * 1024)),\n\t\t2, MAX_KILOBYTES,\n\t\tNULL, assign_max_wal_size, NULL\n\t},\n\n\t{\n\t\t{\"checkpoint_timeout\", PGC_SIGHUP, WAL_CHECKPOINTS,\n\t\t\tgettext_noop(\"Sets the maximum time between automatic WAL checkpoints.\"),\n\t\t\tNULL,\n\t\t\tGUC_UNIT_S\n\t\t},\n\t\t&CheckPointTimeout,\n\t\t300, 30, 86400,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"checkpoint_warning\", PGC_SIGHUP, WAL_CHECKPOINTS,\n\t\t\tgettext_noop(\"Enables warnings if checkpoint segments are filled more \"\n\t\t\t\t\t\t \"frequently than this.\"),\n\t\t\tgettext_noop(\"Write a message to the server log if checkpoints \"\n\t\t\t\t\t\t \"caused by the filling of checkpoint segment files happens more \"\n\t\t\t\t\t\t \"frequently than this number of seconds. Zero turns off the warning.\"),\n\t\t\tGUC_UNIT_S\n\t\t},\n\t\t&CheckPointWarning,\n\t\t30, 0, INT_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"checkpoint_flush_after\", PGC_SIGHUP, WAL_CHECKPOINTS,\n\t\t\tgettext_noop(\"Number of pages after which previously performed writes are flushed to disk.\"),\n\t\t\tNULL,\n\t\t\tGUC_UNIT_BLOCKS\n\t\t},\n\t\t&checkpoint_flush_after,\n\t\tDEFAULT_CHECKPOINT_FLUSH_AFTER, 0, WRITEBACK_MAX_PENDING_FLUSHES,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"wal_buffers\", PGC_POSTMASTER, WAL_SETTINGS,\n\t\t\tgettext_noop(\"Sets the number of disk-page buffers in shared memory for WAL.\"),\n\t\t\tNULL,\n\t\t\tGUC_UNIT_XBLOCKS\n\t\t},\n\t\t&XLOGbuffers,\n\t\t-1, -1, (INT_MAX / XLOG_BLCKSZ),\n\t\tcheck_wal_buffers, NULL, NULL\n\t},\n\n\t{\n\t\t{\"wal_writer_delay\", PGC_SIGHUP, WAL_SETTINGS,\n\t\t\tgettext_noop(\"Time between WAL flushes performed in the WAL writer.\"),\n\t\t\tNULL,\n\t\t\tGUC_UNIT_MS\n\t\t},\n\t\t&WalWriterDelay,\n\t\t200, 1, 10000,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"wal_writer_flush_after\", PGC_SIGHUP, WAL_SETTINGS,\n\t\t\tgettext_noop(\"Amount of WAL written out by WAL writer that triggers a flush.\"),\n\t\t\tNULL,\n\t\t\tGUC_UNIT_XBLOCKS\n\t\t},\n\t\t&WalWriterFlushAfter,\n\t\t(1024 * 1024) / XLOG_BLCKSZ, 0, INT_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t/* see max_connections and superuser_reserved_connections */\n\t\t{\"max_wal_senders\", PGC_POSTMASTER, REPLICATION_SENDING,\n\t\t\tgettext_noop(\"Sets the maximum number of simultaneously running WAL sender processes.\"),\n\t\t\tNULL\n\t\t},\n\t\t&max_wal_senders,\n\t\t10, 0, MAX_BACKENDS,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t/* see max_wal_senders */\n\t\t{\"max_replication_slots\", PGC_POSTMASTER, REPLICATION_SENDING,\n\t\t\tgettext_noop(\"Sets the maximum number of simultaneously defined replication slots.\"),\n\t\t\tNULL\n\t\t},\n\t\t&max_replication_slots,\n\t\t10, 0, MAX_BACKENDS /* XXX? */ ,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"wal_sender_timeout\", PGC_SIGHUP, REPLICATION_SENDING,\n\t\t\tgettext_noop(\"Sets the maximum time to wait for WAL replication.\"),\n\t\t\tNULL,\n\t\t\tGUC_UNIT_MS\n\t\t},\n\t\t&wal_sender_timeout,\n\t\t60 * 1000, 0, INT_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"commit_delay\", PGC_SUSET, WAL_SETTINGS,\n\t\t\tgettext_noop(\"Sets the delay in microseconds between transaction commit and \"\n\t\t\t\t\t\t \"flushing WAL to disk.\"),\n\t\t\tNULL\n\t\t\t/* we have no microseconds designation, so can't supply units here */\n\t\t},\n\t\t&CommitDelay,\n\t\t0, 0, 100000,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"commit_siblings\", PGC_USERSET, WAL_SETTINGS,\n\t\t\tgettext_noop(\"Sets the minimum concurrent open transactions before performing \"\n\t\t\t\t\t\t \"commit_delay.\"),\n\t\t\tNULL\n\t\t},\n\t\t&CommitSiblings,\n\t\t5, 0, 1000,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"extra_float_digits\", PGC_USERSET, CLIENT_CONN_LOCALE,\n\t\t\tgettext_noop(\"Sets the number of digits displayed for floating-point values.\"),\n\t\t\tgettext_noop(\"This affects real, double precision, and geometric data types. \"\n\t\t\t\t\t\t \"The parameter value is added to the standard number of digits \"\n\t\t\t\t\t\t \"(FLT_DIG or DBL_DIG as appropriate).\")\n\t\t},\n\t\t&extra_float_digits,\n\t\t0, -15, 3,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"log_min_duration_statement\", PGC_SUSET, LOGGING_WHEN,\n\t\t\tgettext_noop(\"Sets the minimum execution time above which \"\n\t\t\t\t\t\t \"statements will be logged.\"),\n\t\t\tgettext_noop(\"Zero prints all queries. -1 turns this feature off.\"),\n\t\t\tGUC_UNIT_MS\n\t\t},\n\t\t&log_min_duration_statement,\n\t\t-1, -1, INT_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"log_autovacuum_min_duration\", PGC_SIGHUP, LOGGING_WHAT,\n\t\t\tgettext_noop(\"Sets the minimum execution time above which \"\n\t\t\t\t\t\t \"autovacuum actions will be logged.\"),\n\t\t\tgettext_noop(\"Zero prints all actions. -1 turns autovacuum logging off.\"),\n\t\t\tGUC_UNIT_MS\n\t\t},\n\t\t&Log_autovacuum_min_duration,\n\t\t-1, -1, INT_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"bgwriter_delay\", PGC_SIGHUP, RESOURCES_BGWRITER,\n\t\t\tgettext_noop(\"Background writer sleep time between rounds.\"),\n\t\t\tNULL,\n\t\t\tGUC_UNIT_MS\n\t\t},\n\t\t&BgWriterDelay,\n\t\t200, 10, 10000,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"bgwriter_lru_maxpages\", PGC_SIGHUP, RESOURCES_BGWRITER,\n\t\t\tgettext_noop(\"Background writer maximum number of LRU pages to flush per round.\"),\n\t\t\tNULL\n\t\t},\n\t\t&bgwriter_lru_maxpages,\n\t\t100, 0, INT_MAX / 2,\t/* Same upper limit as shared_buffers */\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"bgwriter_flush_after\", PGC_SIGHUP, RESOURCES_BGWRITER,\n\t\t\tgettext_noop(\"Number of pages after which previously performed writes are flushed to disk.\"),\n\t\t\tNULL,\n\t\t\tGUC_UNIT_BLOCKS\n\t\t},\n\t\t&bgwriter_flush_after,\n\t\tDEFAULT_BGWRITER_FLUSH_AFTER, 0, WRITEBACK_MAX_PENDING_FLUSHES,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"effective_io_concurrency\",\n\t\t\tPGC_USERSET,\n\t\t\tRESOURCES_ASYNCHRONOUS,\n\t\t\tgettext_noop(\"Number of simultaneous requests that can be handled efficiently by the disk subsystem.\"),\n\t\t\tgettext_noop(\"For RAID arrays, this should be approximately the number of drive spindles in the array.\")\n\t\t},\n\t\t&effective_io_concurrency,\n#ifdef USE_PREFETCH\n\t\t1,\n#else\n\t\t0,\n#endif\n\t\t0, MAX_IO_CONCURRENCY,\n\t\tcheck_effective_io_concurrency, assign_effective_io_concurrency, NULL\n\t},\n\n\t{\n\t\t{\"backend_flush_after\", PGC_USERSET, RESOURCES_ASYNCHRONOUS,\n\t\t\tgettext_noop(\"Number of pages after which previously performed writes are flushed to disk.\"),\n\t\t\tNULL,\n\t\t\tGUC_UNIT_BLOCKS\n\t\t},\n\t\t&backend_flush_after,\n\t\tDEFAULT_BACKEND_FLUSH_AFTER, 0, WRITEBACK_MAX_PENDING_FLUSHES,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"max_worker_processes\",\n\t\t\tPGC_POSTMASTER,\n\t\t\tRESOURCES_ASYNCHRONOUS,\n\t\t\tgettext_noop(\"Maximum number of concurrent worker processes.\"),\n\t\t\tNULL,\n\t\t},\n\t\t&max_worker_processes,\n\t\t8, 0, MAX_BACKENDS,\n\t\tcheck_max_worker_processes, NULL, NULL\n\t},\n\n\t{\n\t\t{\"max_logical_replication_workers\",\n\t\t\tPGC_POSTMASTER,\n\t\t\tREPLICATION_SUBSCRIBERS,\n\t\t\tgettext_noop(\"Maximum number of logical replication worker processes.\"),\n\t\t\tNULL,\n\t\t},\n\t\t&max_logical_replication_workers,\n\t\t4, 0, MAX_BACKENDS,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"max_sync_workers_per_subscription\",\n\t\t\tPGC_SIGHUP,\n\t\t\tREPLICATION_SUBSCRIBERS,\n\t\t\tgettext_noop(\"Maximum number of table synchronization workers per subscription.\"),\n\t\t\tNULL,\n\t\t},\n\t\t&max_sync_workers_per_subscription,\n\t\t2, 0, MAX_BACKENDS,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"log_rotation_age\", PGC_SIGHUP, LOGGING_WHERE,\n\t\t\tgettext_noop(\"Automatic log file rotation will occur after N minutes.\"),\n\t\t\tNULL,\n\t\t\tGUC_UNIT_MIN\n\t\t},\n\t\t&Log_RotationAge,\n\t\tHOURS_PER_DAY * MINS_PER_HOUR, 0, INT_MAX / SECS_PER_MINUTE,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"log_rotation_size\", PGC_SIGHUP, LOGGING_WHERE,\n\t\t\tgettext_noop(\"Automatic log file rotation will occur after N kilobytes.\"),\n\t\t\tNULL,\n\t\t\tGUC_UNIT_KB\n\t\t},\n\t\t&Log_RotationSize,\n\t\t10 * 1024, 0, INT_MAX / 1024,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"max_function_args\", PGC_INTERNAL, PRESET_OPTIONS,\n\t\t\tgettext_noop(\"Shows the maximum number of function arguments.\"),\n\t\t\tNULL,\n\t\t\tGUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE\n\t\t},\n\t\t&max_function_args,\n\t\tFUNC_MAX_ARGS, FUNC_MAX_ARGS, FUNC_MAX_ARGS,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"max_index_keys\", PGC_INTERNAL, PRESET_OPTIONS,\n\t\t\tgettext_noop(\"Shows the maximum number of index keys.\"),\n\t\t\tNULL,\n\t\t\tGUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE\n\t\t},\n\t\t&max_index_keys,\n\t\tINDEX_MAX_KEYS, INDEX_MAX_KEYS, INDEX_MAX_KEYS,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"max_identifier_length\", PGC_INTERNAL, PRESET_OPTIONS,\n\t\t\tgettext_noop(\"Shows the maximum identifier length.\"),\n\t\t\tNULL,\n\t\t\tGUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE\n\t\t},\n\t\t&max_identifier_length,\n\t\tNAMEDATALEN - 1, NAMEDATALEN - 1, NAMEDATALEN - 1,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"block_size\", PGC_INTERNAL, PRESET_OPTIONS,\n\t\t\tgettext_noop(\"Shows the size of a disk block.\"),\n\t\t\tNULL,\n\t\t\tGUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE\n\t\t},\n\t\t&block_size,\n\t\tBLCKSZ, BLCKSZ, BLCKSZ,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"segment_size\", PGC_INTERNAL, PRESET_OPTIONS,\n\t\t\tgettext_noop(\"Shows the number of pages per disk file.\"),\n\t\t\tNULL,\n\t\t\tGUC_UNIT_BLOCKS | GUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE\n\t\t},\n\t\t&segment_size,\n\t\tRELSEG_SIZE, RELSEG_SIZE, RELSEG_SIZE,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"wal_block_size\", PGC_INTERNAL, PRESET_OPTIONS,\n\t\t\tgettext_noop(\"Shows the block size in the write ahead log.\"),\n\t\t\tNULL,\n\t\t\tGUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE\n\t\t},\n\t\t&wal_block_size,\n\t\tXLOG_BLCKSZ, XLOG_BLCKSZ, XLOG_BLCKSZ,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"wal_retrieve_retry_interval\", PGC_SIGHUP, REPLICATION_STANDBY,\n\t\t\tgettext_noop(\"Sets the time to wait before retrying to retrieve WAL \"\n\t\t\t\t\t\t \"after a failed attempt.\"),\n\t\t\tNULL,\n\t\t\tGUC_UNIT_MS\n\t\t},\n\t\t&wal_retrieve_retry_interval,\n\t\t5000, 1, INT_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"wal_segment_size\", PGC_INTERNAL, PRESET_OPTIONS,\n\t\t\tgettext_noop(\"Shows the size of write ahead log segments.\"),\n\t\t\tNULL,\n\t\t\tGUC_UNIT_BYTE | GUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE\n\t\t},\n\t\t&wal_segment_size,\n\t\tDEFAULT_XLOG_SEG_SIZE,\n\t\tWalSegMinSize,\n\t\tWalSegMaxSize,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"autovacuum_naptime\", PGC_SIGHUP, AUTOVACUUM,\n\t\t\tgettext_noop(\"Time to sleep between autovacuum runs.\"),\n\t\t\tNULL,\n\t\t\tGUC_UNIT_S\n\t\t},\n\t\t&autovacuum_naptime,\n\t\t60, 1, INT_MAX / 1000,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"autovacuum_vacuum_threshold\", PGC_SIGHUP, AUTOVACUUM,\n\t\t\tgettext_noop(\"Minimum number of tuple updates or deletes prior to vacuum.\"),\n\t\t\tNULL\n\t\t},\n\t\t&autovacuum_vac_thresh,\n\t\t50, 0, INT_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"autovacuum_analyze_threshold\", PGC_SIGHUP, AUTOVACUUM,\n\t\t\tgettext_noop(\"Minimum number of tuple inserts, updates, or deletes prior to analyze.\"),\n\t\t\tNULL\n\t\t},\n\t\t&autovacuum_anl_thresh,\n\t\t50, 0, INT_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t/* see varsup.c for why this is PGC_POSTMASTER not PGC_SIGHUP */\n\t\t{\"autovacuum_freeze_max_age\", PGC_POSTMASTER, AUTOVACUUM,\n\t\t\tgettext_noop(\"Age at which to autovacuum a table to prevent transaction ID wraparound.\"),\n\t\t\tNULL\n\t\t},\n\t\t&autovacuum_freeze_max_age,\n\t\t/* see pg_resetwal if you change the upper-limit value */\n\t\t200000000, 100000, 2000000000,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t/* see multixact.c for why this is PGC_POSTMASTER not PGC_SIGHUP */\n\t\t{\"autovacuum_multixact_freeze_max_age\", PGC_POSTMASTER, AUTOVACUUM,\n\t\t\tgettext_noop(\"Multixact age at which to autovacuum a table to prevent multixact wraparound.\"),\n\t\t\tNULL\n\t\t},\n\t\t&autovacuum_multixact_freeze_max_age,\n\t\t400000000, 10000, 2000000000,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t/* see max_connections */\n\t\t{\"autovacuum_max_workers\", PGC_POSTMASTER, AUTOVACUUM,\n\t\t\tgettext_noop(\"Sets the maximum number of simultaneously running autovacuum worker processes.\"),\n\t\t\tNULL\n\t\t},\n\t\t&autovacuum_max_workers,\n\t\t3, 1, MAX_BACKENDS,\n\t\tcheck_autovacuum_max_workers, NULL, NULL\n\t},\n\n\t{\n\t\t{\"max_parallel_maintenance_workers\", PGC_USERSET, RESOURCES_ASYNCHRONOUS,\n\t\t\tgettext_noop(\"Sets the maximum number of parallel processes per maintenance operation.\"),\n\t\t\tNULL\n\t\t},\n\t\t&max_parallel_maintenance_workers,\n\t\t2, 0, 1024,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"max_parallel_workers_per_gather\", PGC_USERSET, RESOURCES_ASYNCHRONOUS,\n\t\t\tgettext_noop(\"Sets the maximum number of parallel processes per executor node.\"),\n\t\t\tNULL\n\t\t},\n\t\t&max_parallel_workers_per_gather,\n\t\t2, 0, MAX_PARALLEL_WORKER_LIMIT,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"max_parallel_workers\", PGC_USERSET, RESOURCES_ASYNCHRONOUS,\n\t\t\tgettext_noop(\"Sets the maximum number of parallel workers that can be active at one time.\"),\n\t\t\tNULL\n\t\t},\n\t\t&max_parallel_workers,\n\t\t8, 0, MAX_PARALLEL_WORKER_LIMIT,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"autovacuum_work_mem\", PGC_SIGHUP, RESOURCES_MEM,\n\t\t\tgettext_noop(\"Sets the maximum memory to be used by each autovacuum worker process.\"),\n\t\t\tNULL,\n\t\t\tGUC_UNIT_KB\n\t\t},\n\t\t&autovacuum_work_mem,\n\t\t-1, -1, MAX_KILOBYTES,\n\t\tcheck_autovacuum_work_mem, NULL, NULL\n\t},\n\n\t{\n\t\t{\"old_snapshot_threshold\", PGC_POSTMASTER, RESOURCES_ASYNCHRONOUS,\n\t\t\tgettext_noop(\"Time before a snapshot is too old to read pages changed after the snapshot was taken.\"),\n\t\t\tgettext_noop(\"A value of -1 disables this feature.\"),\n\t\t\tGUC_UNIT_MIN\n\t\t},\n\t\t&old_snapshot_threshold,\n\t\t-1, -1, MINS_PER_HOUR * HOURS_PER_DAY * 60,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"tcp_keepalives_idle\", PGC_USERSET, CLIENT_CONN_OTHER,\n\t\t\tgettext_noop(\"Time between issuing TCP keepalives.\"),\n\t\t\tgettext_noop(\"A value of 0 uses the system default.\"),\n\t\t\tGUC_UNIT_S\n\t\t},\n\t\t&tcp_keepalives_idle,\n\t\t0, 0, INT_MAX,\n\t\tNULL, assign_tcp_keepalives_idle, show_tcp_keepalives_idle\n\t},\n\n\t{\n\t\t{\"tcp_keepalives_interval\", PGC_USERSET, CLIENT_CONN_OTHER,\n\t\t\tgettext_noop(\"Time between TCP keepalive retransmits.\"),\n\t\t\tgettext_noop(\"A value of 0 uses the system default.\"),\n\t\t\tGUC_UNIT_S\n\t\t},\n\t\t&tcp_keepalives_interval,\n\t\t0, 0, INT_MAX,\n\t\tNULL, assign_tcp_keepalives_interval, show_tcp_keepalives_interval\n\t},\n\n\t{\n\t\t{\"ssl_renegotiation_limit\", PGC_USERSET, CONN_AUTH_SSL,\n\t\t\tgettext_noop(\"SSL renegotiation is no longer supported; this can only be 0.\"),\n\t\t\tNULL,\n\t\t\tGUC_NO_SHOW_ALL | GUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE,\n\t\t},\n\t\t&ssl_renegotiation_limit,\n\t\t0, 0, 0,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"tcp_keepalives_count\", PGC_USERSET, CLIENT_CONN_OTHER,\n\t\t\tgettext_noop(\"Maximum number of TCP keepalive retransmits.\"),\n\t\t\tgettext_noop(\"This controls the number of consecutive keepalive retransmits that can be \"\n\t\t\t\t\t\t \"lost before a connection is considered dead. A value of 0 uses the \"\n\t\t\t\t\t\t \"system default.\"),\n\t\t},\n\t\t&tcp_keepalives_count,\n\t\t0, 0, INT_MAX,\n\t\tNULL, assign_tcp_keepalives_count, show_tcp_keepalives_count\n\t},\n\n\t{\n\t\t{\"gin_fuzzy_search_limit\", PGC_USERSET, CLIENT_CONN_OTHER,\n\t\t\tgettext_noop(\"Sets the maximum allowed result for exact search by GIN.\"),\n\t\t\tNULL,\n\t\t\t0\n\t\t},\n\t\t&GinFuzzySearchLimit,\n\t\t0, 0, INT_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"effective_cache_size\", PGC_USERSET, QUERY_TUNING_COST,\n\t\t\tgettext_noop(\"Sets the planner's assumption about the total size of the data caches.\"),\n\t\t\tgettext_noop(\"That is, the total size of the caches (kernel cache and shared buffers) used for PostgreSQL data files. \"\n\t\t\t\t\t\t \"This is measured in disk pages, which are normally 8 kB each.\"),\n\t\t\tGUC_UNIT_BLOCKS,\n\t\t},\n\t\t&effective_cache_size,\n\t\tDEFAULT_EFFECTIVE_CACHE_SIZE, 1, INT_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"min_parallel_table_scan_size\", PGC_USERSET, QUERY_TUNING_COST,\n\t\t\tgettext_noop(\"Sets the minimum amount of table data for a parallel scan.\"),\n\t\t\tgettext_noop(\"If the planner estimates that it will read a number of table pages too small to reach this limit, a parallel scan will not be considered.\"),\n\t\t\tGUC_UNIT_BLOCKS,\n\t\t},\n\t\t&min_parallel_table_scan_size,\n\t\t(8 * 1024 * 1024) / BLCKSZ, 0, INT_MAX / 3,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"min_parallel_index_scan_size\", PGC_USERSET, QUERY_TUNING_COST,\n\t\t\tgettext_noop(\"Sets the minimum amount of index data for a parallel scan.\"),\n\t\t\tgettext_noop(\"If the planner estimates that it will read a number of index pages too small to reach this limit, a parallel scan will not be considered.\"),\n\t\t\tGUC_UNIT_BLOCKS,\n\t\t},\n\t\t&min_parallel_index_scan_size,\n\t\t(512 * 1024) / BLCKSZ, 0, INT_MAX / 3,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t/* Can't be set in postgresql.conf */\n\t\t{\"server_version_num\", PGC_INTERNAL, PRESET_OPTIONS,\n\t\t\tgettext_noop(\"Shows the server version as an integer.\"),\n\t\t\tNULL,\n\t\t\tGUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE\n\t\t},\n\t\t&server_version_num,\n\t\tPG_VERSION_NUM, PG_VERSION_NUM, PG_VERSION_NUM,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"log_temp_files\", PGC_SUSET, LOGGING_WHAT,\n\t\t\tgettext_noop(\"Log the use of temporary files larger than this number of kilobytes.\"),\n\t\t\tgettext_noop(\"Zero logs all files. The default is -1 (turning this feature off).\"),\n\t\t\tGUC_UNIT_KB\n\t\t},\n\t\t&log_temp_files,\n\t\t-1, -1, INT_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"track_activity_query_size\", PGC_POSTMASTER, RESOURCES_MEM,\n\t\t\tgettext_noop(\"Sets the size reserved for pg_stat_activity.query, in bytes.\"),\n\t\t\tNULL,\n\t\t\tGUC_UNIT_BYTE\n\t\t},\n\t\t&pgstat_track_activity_query_size,\n\t\t1024, 100, 102400,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"gin_pending_list_limit\", PGC_USERSET, CLIENT_CONN_STATEMENT,\n\t\t\tgettext_noop(\"Sets the maximum size of the pending list for GIN index.\"),\n\t\t\tNULL,\n\t\t\tGUC_UNIT_KB\n\t\t},\n\t\t&gin_pending_list_limit,\n\t\t4096, 64, MAX_KILOBYTES,\n\t\tNULL, NULL, NULL\n\t},\n\n\t/* End-of-list marker */\n\t{\n\t\t{NULL, 0, 0, NULL, NULL}, NULL, 0, 0, 0, NULL, NULL, NULL\n\t}\n};\nstatic struct config_real ConfigureNamesReal[] =\n{\n\t{\n\t\t{\"seq_page_cost\", PGC_USERSET, QUERY_TUNING_COST,\n\t\t\tgettext_noop(\"Sets the planner's estimate of the cost of a \"\n\t\t\t\t\t\t \"sequentially fetched disk page.\"),\n\t\t\tNULL\n\t\t},\n\t\t&seq_page_cost,\n\t\tDEFAULT_SEQ_PAGE_COST, 0, DBL_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"random_page_cost\", PGC_USERSET, QUERY_TUNING_COST,\n\t\t\tgettext_noop(\"Sets the planner's estimate of the cost of a \"\n\t\t\t\t\t\t \"nonsequentially fetched disk page.\"),\n\t\t\tNULL\n\t\t},\n\t\t&random_page_cost,\n\t\tDEFAULT_RANDOM_PAGE_COST, 0, DBL_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"cpu_tuple_cost\", PGC_USERSET, QUERY_TUNING_COST,\n\t\t\tgettext_noop(\"Sets the planner's estimate of the cost of \"\n\t\t\t\t\t\t \"processing each tuple (row).\"),\n\t\t\tNULL\n\t\t},\n\t\t&cpu_tuple_cost,\n\t\tDEFAULT_CPU_TUPLE_COST, 0, DBL_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"cpu_index_tuple_cost\", PGC_USERSET, QUERY_TUNING_COST,\n\t\t\tgettext_noop(\"Sets the planner's estimate of the cost of \"\n\t\t\t\t\t\t \"processing each index entry during an index scan.\"),\n\t\t\tNULL\n\t\t},\n\t\t&cpu_index_tuple_cost,\n\t\tDEFAULT_CPU_INDEX_TUPLE_COST, 0, DBL_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"cpu_operator_cost\", PGC_USERSET, QUERY_TUNING_COST,\n\t\t\tgettext_noop(\"Sets the planner's estimate of the cost of \"\n\t\t\t\t\t\t \"processing each operator or function call.\"),\n\t\t\tNULL\n\t\t},\n\t\t&cpu_operator_cost,\n\t\tDEFAULT_CPU_OPERATOR_COST, 0, DBL_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"parallel_tuple_cost\", PGC_USERSET, QUERY_TUNING_COST,\n\t\t\tgettext_noop(\"Sets the planner's estimate of the cost of \"\n\t\t\t\t\t\t \"passing each tuple (row) from worker to master backend.\"),\n\t\t\tNULL\n\t\t},\n\t\t&parallel_tuple_cost,\n\t\tDEFAULT_PARALLEL_TUPLE_COST, 0, DBL_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"parallel_setup_cost\", PGC_USERSET, QUERY_TUNING_COST,\n\t\t\tgettext_noop(\"Sets the planner's estimate of the cost of \"\n\t\t\t\t\t\t \"starting up worker processes for parallel query.\"),\n\t\t\tNULL\n\t\t},\n\t\t&parallel_setup_cost,\n\t\tDEFAULT_PARALLEL_SETUP_COST, 0, DBL_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"jit_above_cost\", PGC_USERSET, QUERY_TUNING_COST,\n\t\t\tgettext_noop(\"Perform JIT compilation if query is more expensive.\"),\n\t\t\tgettext_noop(\"-1 disables JIT compilation.\")\n\t\t},\n\t\t&jit_above_cost,\n\t\t100000, -1, DBL_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"jit_optimize_above_cost\", PGC_USERSET, QUERY_TUNING_COST,\n\t\t\tgettext_noop(\"Optimize JITed functions if query is more expensive.\"),\n\t\t\tgettext_noop(\"-1 disables optimization.\")\n\t\t},\n\t\t&jit_optimize_above_cost,\n\t\t500000, -1, DBL_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"jit_inline_above_cost\", PGC_USERSET, QUERY_TUNING_COST,\n\t\t\tgettext_noop(\"Perform JIT inlining if query is more expensive.\"),\n\t\t\tgettext_noop(\"-1 disables inlining.\")\n\t\t},\n\t\t&jit_inline_above_cost,\n\t\t500000, -1, DBL_MAX,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"cursor_tuple_fraction\", PGC_USERSET, QUERY_TUNING_OTHER,\n\t\t\tgettext_noop(\"Sets the planner's estimate of the fraction of \"\n\t\t\t\t\t\t \"a cursor's rows that will be retrieved.\"),\n\t\t\tNULL\n\t\t},\n\t\t&cursor_tuple_fraction,\n\t\tDEFAULT_CURSOR_TUPLE_FRACTION, 0.0, 1.0,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"geqo_selection_bias\", PGC_USERSET, QUERY_TUNING_GEQO,\n\t\t\tgettext_noop(\"GEQO: selective pressure within the population.\"),\n\t\t\tNULL\n\t\t},\n\t\t&Geqo_selection_bias,\n\t\tDEFAULT_GEQO_SELECTION_BIAS,\n\t\tMIN_GEQO_SELECTION_BIAS, MAX_GEQO_SELECTION_BIAS,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"geqo_seed\", PGC_USERSET, QUERY_TUNING_GEQO,\n\t\t\tgettext_noop(\"GEQO: seed for random path selection.\"),\n\t\t\tNULL\n\t\t},\n\t\t&Geqo_seed,\n\t\t0.0, 0.0, 1.0,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"bgwriter_lru_multiplier\", PGC_SIGHUP, RESOURCES_BGWRITER,\n\t\t\tgettext_noop(\"Multiple of the average buffer usage to free per round.\"),\n\t\t\tNULL\n\t\t},\n\t\t&bgwriter_lru_multiplier,\n\t\t2.0, 0.0, 10.0,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"seed\", PGC_USERSET, UNGROUPED,\n\t\t\tgettext_noop(\"Sets the seed for random-number generation.\"),\n\t\t\tNULL,\n\t\t\tGUC_NO_SHOW_ALL | GUC_NO_RESET_ALL | GUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE\n\t\t},\n\t\t&phony_random_seed,\n\t\t0.0, -1.0, 1.0,\n\t\tcheck_random_seed, assign_random_seed, show_random_seed\n\t},\n\n\t{\n\t\t{\"autovacuum_vacuum_scale_factor\", PGC_SIGHUP, AUTOVACUUM,\n\t\t\tgettext_noop(\"Number of tuple updates or deletes prior to vacuum as a fraction of reltuples.\"),\n\t\t\tNULL\n\t\t},\n\t\t&autovacuum_vac_scale,\n\t\t0.2, 0.0, 100.0,\n\t\tNULL, NULL, NULL\n\t},\n\t{\n\t\t{\"autovacuum_analyze_scale_factor\", PGC_SIGHUP, AUTOVACUUM,\n\t\t\tgettext_noop(\"Number of tuple inserts, updates, or deletes prior to analyze as a fraction of reltuples.\"),\n\t\t\tNULL\n\t\t},\n\t\t&autovacuum_anl_scale,\n\t\t0.1, 0.0, 100.0,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"checkpoint_completion_target\", PGC_SIGHUP, WAL_CHECKPOINTS,\n\t\t\tgettext_noop(\"Time spent flushing dirty buffers during checkpoint, as fraction of checkpoint interval.\"),\n\t\t\tNULL\n\t\t},\n\t\t&CheckPointCompletionTarget,\n\t\t0.5, 0.0, 1.0,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"vacuum_cleanup_index_scale_factor\", PGC_USERSET, CLIENT_CONN_STATEMENT,\n\t\t\tgettext_noop(\"Number of tuple inserts prior to index cleanup as a fraction of reltuples.\"),\n\t\t\tNULL\n\t\t},\n\t\t&vacuum_cleanup_index_scale_factor,\n\t\t0.1, 0.0, 1e10,\n\t\tNULL, NULL, NULL\n\t},\n\n\t/* End-of-list marker */\n\t{\n\t\t{NULL, 0, 0, NULL, NULL}, NULL, 0.0, 0.0, 0.0, NULL, NULL, NULL\n\t}\n};\nstatic struct config_string ConfigureNamesString[] =\n{\n\t{\n\t\t{\"archive_command\", PGC_SIGHUP, WAL_ARCHIVING,\n\t\t\tgettext_noop(\"Sets the shell command that will be called to archive a WAL file.\"),\n\t\t\tNULL\n\t\t},\n\t\t&XLogArchiveCommand,\n\t\t\"\",\n\t\tNULL, NULL, show_archive_command\n\t},\n\n\t{\n\t\t{\"client_encoding\", PGC_USERSET, CLIENT_CONN_LOCALE,\n\t\t\tgettext_noop(\"Sets the client's character set encoding.\"),\n\t\t\tNULL,\n\t\t\tGUC_IS_NAME | GUC_REPORT\n\t\t},\n\t\t&client_encoding_string,\n\t\t\"SQL_ASCII\",\n\t\tcheck_client_encoding, assign_client_encoding, NULL\n\t},\n\n\t{\n\t\t{\"log_line_prefix\", PGC_SIGHUP, LOGGING_WHAT,\n\t\t\tgettext_noop(\"Controls information prefixed to each log line.\"),\n\t\t\tgettext_noop(\"If blank, no prefix is used.\")\n\t\t},\n\t\t&Log_line_prefix,\n\t\t\"%m [%p] \",\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"log_timezone\", PGC_SIGHUP, LOGGING_WHAT,\n\t\t\tgettext_noop(\"Sets the time zone to use in log messages.\"),\n\t\t\tNULL\n\t\t},\n\t\t&log_timezone_string,\n\t\t\"GMT\",\n\t\tcheck_log_timezone, assign_log_timezone, show_log_timezone\n\t},\n\n\t{\n\t\t{\"DateStyle\", PGC_USERSET, CLIENT_CONN_LOCALE,\n\t\t\tgettext_noop(\"Sets the display format for date and time values.\"),\n\t\t\tgettext_noop(\"Also controls interpretation of ambiguous \"\n\t\t\t\t\t\t \"date inputs.\"),\n\t\t\tGUC_LIST_INPUT | GUC_REPORT\n\t\t},\n\t\t&datestyle_string,\n\t\t\"ISO, MDY\",\n\t\tcheck_datestyle, assign_datestyle, NULL\n\t},\n\n\t{\n\t\t{\"default_tablespace\", PGC_USERSET, CLIENT_CONN_STATEMENT,\n\t\t\tgettext_noop(\"Sets the default tablespace to create tables and indexes in.\"),\n\t\t\tgettext_noop(\"An empty string selects the database's default tablespace.\"),\n\t\t\tGUC_IS_NAME\n\t\t},\n\t\t&default_tablespace,\n\t\t\"\",\n\t\tcheck_default_tablespace, NULL, NULL\n\t},\n\n\t{\n\t\t{\"temp_tablespaces\", PGC_USERSET, CLIENT_CONN_STATEMENT,\n\t\t\tgettext_noop(\"Sets the tablespace(s) to use for temporary tables and sort files.\"),\n\t\t\tNULL,\n\t\t\tGUC_LIST_INPUT | GUC_LIST_QUOTE\n\t\t},\n\t\t&temp_tablespaces,\n\t\t\"\",\n\t\tcheck_temp_tablespaces, assign_temp_tablespaces, NULL\n\t},\n\n\t{\n\t\t{\"dynamic_library_path\", PGC_SUSET, CLIENT_CONN_OTHER,\n\t\t\tgettext_noop(\"Sets the path for dynamically loadable modules.\"),\n\t\t\tgettext_noop(\"If a dynamically loadable module needs to be opened and \"\n\t\t\t\t\t\t \"the specified name does not have a directory component (i.e., the \"\n\t\t\t\t\t\t \"name does not contain a slash), the system will search this path for \"\n\t\t\t\t\t\t \"the specified file.\"),\n\t\t\tGUC_SUPERUSER_ONLY\n\t\t},\n\t\t&Dynamic_library_path,\n\t\t\"$libdir\",\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"krb_server_keyfile\", PGC_SIGHUP, CONN_AUTH_AUTH,\n\t\t\tgettext_noop(\"Sets the location of the Kerberos server key file.\"),\n\t\t\tNULL,\n\t\t\tGUC_SUPERUSER_ONLY\n\t\t},\n\t\t&pg_krb_server_keyfile,\n\t\tPG_KRB_SRVTAB,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"bonjour_name\", PGC_POSTMASTER, CONN_AUTH_SETTINGS,\n\t\t\tgettext_noop(\"Sets the Bonjour service name.\"),\n\t\t\tNULL\n\t\t},\n\t\t&bonjour_name,\n\t\t\"\",\n\t\tNULL, NULL, NULL\n\t},\n\n\t/* See main.c about why defaults for LC_foo are not all alike */\n\n\t{\n\t\t{\"lc_collate\", PGC_INTERNAL, CLIENT_CONN_LOCALE,\n\t\t\tgettext_noop(\"Shows the collation order locale.\"),\n\t\t\tNULL,\n\t\t\tGUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE\n\t\t},\n\t\t&locale_collate,\n\t\t\"C\",\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"lc_ctype\", PGC_INTERNAL, CLIENT_CONN_LOCALE,\n\t\t\tgettext_noop(\"Shows the character classification and case conversion locale.\"),\n\t\t\tNULL,\n\t\t\tGUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE\n\t\t},\n\t\t&locale_ctype,\n\t\t\"C\",\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"lc_messages\", PGC_SUSET, CLIENT_CONN_LOCALE,\n\t\t\tgettext_noop(\"Sets the language in which messages are displayed.\"),\n\t\t\tNULL\n\t\t},\n\t\t&locale_messages,\n\t\t\"\",\n\t\tcheck_locale_messages, assign_locale_messages, NULL\n\t},\n\n\t{\n\t\t{\"lc_monetary\", PGC_USERSET, CLIENT_CONN_LOCALE,\n\t\t\tgettext_noop(\"Sets the locale for formatting monetary amounts.\"),\n\t\t\tNULL\n\t\t},\n\t\t&locale_monetary,\n\t\t\"C\",\n\t\tcheck_locale_monetary, assign_locale_monetary, NULL\n\t},\n\n\t{\n\t\t{\"lc_numeric\", PGC_USERSET, CLIENT_CONN_LOCALE,\n\t\t\tgettext_noop(\"Sets the locale for formatting numbers.\"),\n\t\t\tNULL\n\t\t},\n\t\t&locale_numeric,\n\t\t\"C\",\n\t\tcheck_locale_numeric, assign_locale_numeric, NULL\n\t},\n\n\t{\n\t\t{\"lc_time\", PGC_USERSET, CLIENT_CONN_LOCALE,\n\t\t\tgettext_noop(\"Sets the locale for formatting date and time values.\"),\n\t\t\tNULL\n\t\t},\n\t\t&locale_time,\n\t\t\"C\",\n\t\tcheck_locale_time, assign_locale_time, NULL\n\t},\n\n\t{\n\t\t{\"session_preload_libraries\", PGC_SUSET, CLIENT_CONN_PRELOAD,\n\t\t\tgettext_noop(\"Lists shared libraries to preload into each backend.\"),\n\t\t\tNULL,\n\t\t\tGUC_LIST_INPUT | GUC_LIST_QUOTE | GUC_SUPERUSER_ONLY\n\t\t},\n\t\t&session_preload_libraries_string,\n\t\t\"\",\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"shared_preload_libraries\", PGC_POSTMASTER, CLIENT_CONN_PRELOAD,\n\t\t\tgettext_noop(\"Lists shared libraries to preload into server.\"),\n\t\t\tNULL,\n\t\t\tGUC_LIST_INPUT | GUC_LIST_QUOTE | GUC_SUPERUSER_ONLY\n\t\t},\n\t\t&shared_preload_libraries_string,\n\t\t\"\",\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"local_preload_libraries\", PGC_USERSET, CLIENT_CONN_PRELOAD,\n\t\t\tgettext_noop(\"Lists unprivileged shared libraries to preload into each backend.\"),\n\t\t\tNULL,\n\t\t\tGUC_LIST_INPUT | GUC_LIST_QUOTE\n\t\t},\n\t\t&local_preload_libraries_string,\n\t\t\"\",\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"search_path\", PGC_USERSET, CLIENT_CONN_STATEMENT,\n\t\t\tgettext_noop(\"Sets the schema search order for names that are not schema-qualified.\"),\n\t\t\tNULL,\n\t\t\tGUC_LIST_INPUT | GUC_LIST_QUOTE\n\t\t},\n\t\t&namespace_search_path,\n\t\t\"\\\"$user\\\", public\",\n\t\tcheck_search_path, assign_search_path, NULL\n\t},\n\n\t{\n\t\t/* Can't be set in postgresql.conf */\n\t\t{\"server_encoding\", PGC_INTERNAL, CLIENT_CONN_LOCALE,\n\t\t\tgettext_noop(\"Sets the server (database) character set encoding.\"),\n\t\t\tNULL,\n\t\t\tGUC_IS_NAME | GUC_REPORT | GUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE\n\t\t},\n\t\t&server_encoding_string,\n\t\t\"SQL_ASCII\",\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t/* Can't be set in postgresql.conf */\n\t\t{\"server_version\", PGC_INTERNAL, PRESET_OPTIONS,\n\t\t\tgettext_noop(\"Shows the server version.\"),\n\t\t\tNULL,\n\t\t\tGUC_REPORT | GUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE\n\t\t},\n\t\t&server_version_string,\n\t\tPG_VERSION,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t/* Not for general use --- used by SET ROLE */\n\t\t{\"role\", PGC_USERSET, UNGROUPED,\n\t\t\tgettext_noop(\"Sets the current role.\"),\n\t\t\tNULL,\n\t\t\tGUC_IS_NAME | GUC_NO_SHOW_ALL | GUC_NO_RESET_ALL | GUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE | GUC_NOT_WHILE_SEC_REST\n\t\t},\n\t\t&role_string,\n\t\t\"none\",\n\t\tcheck_role, assign_role, show_role\n\t},\n\n\t{\n\t\t/* Not for general use --- used by SET SESSION AUTHORIZATION */\n\t\t{\"session_authorization\", PGC_USERSET, UNGROUPED,\n\t\t\tgettext_noop(\"Sets the session user name.\"),\n\t\t\tNULL,\n\t\t\tGUC_IS_NAME | GUC_REPORT | GUC_NO_SHOW_ALL | GUC_NO_RESET_ALL | GUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE | GUC_NOT_WHILE_SEC_REST\n\t\t},\n\t\t&session_authorization_string,\n\t\tNULL,\n\t\tcheck_session_authorization, assign_session_authorization, NULL\n\t},\n\n\t{\n\t\t{\"log_destination\", PGC_SIGHUP, LOGGING_WHERE,\n\t\t\tgettext_noop(\"Sets the destination for server log output.\"),\n\t\t\tgettext_noop(\"Valid values are combinations of \\\"stderr\\\", \"\n\t\t\t\t\t\t \"\\\"syslog\\\", \\\"csvlog\\\", and \\\"eventlog\\\", \"\n\t\t\t\t\t\t \"depending on the platform.\"),\n\t\t\tGUC_LIST_INPUT\n\t\t},\n\t\t&Log_destination_string,\n\t\t\"stderr\",\n\t\tcheck_log_destination, assign_log_destination, NULL\n\t},\n\t{\n\t\t{\"log_directory\", PGC_SIGHUP, LOGGING_WHERE,\n\t\t\tgettext_noop(\"Sets the destination directory for log files.\"),\n\t\t\tgettext_noop(\"Can be specified as relative to the data directory \"\n\t\t\t\t\t\t \"or as absolute path.\"),\n\t\t\tGUC_SUPERUSER_ONLY\n\t\t},\n\t\t&Log_directory,\n\t\t\"log\",\n\t\tcheck_canonical_path, NULL, NULL\n\t},\n\t{\n\t\t{\"log_filename\", PGC_SIGHUP, LOGGING_WHERE,\n\t\t\tgettext_noop(\"Sets the file name pattern for log files.\"),\n\t\t\tNULL,\n\t\t\tGUC_SUPERUSER_ONLY\n\t\t},\n\t\t&Log_filename,\n\t\t\"postgresql-%Y-%m-%d_%H%M%S.log\",\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"syslog_ident\", PGC_SIGHUP, LOGGING_WHERE,\n\t\t\tgettext_noop(\"Sets the program name used to identify PostgreSQL \"\n\t\t\t\t\t\t \"messages in syslog.\"),\n\t\t\tNULL\n\t\t},\n\t\t&syslog_ident_str,\n\t\t\"postgres\",\n\t\tNULL, assign_syslog_ident, NULL\n\t},\n\n\t{\n\t\t{\"event_source\", PGC_POSTMASTER, LOGGING_WHERE,\n\t\t\tgettext_noop(\"Sets the application name used to identify \"\n\t\t\t\t\t\t \"PostgreSQL messages in the event log.\"),\n\t\t\tNULL\n\t\t},\n\t\t&event_source,\n\t\tDEFAULT_EVENT_SOURCE,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"TimeZone\", PGC_USERSET, CLIENT_CONN_LOCALE,\n\t\t\tgettext_noop(\"Sets the time zone for displaying and interpreting time stamps.\"),\n\t\t\tNULL,\n\t\t\tGUC_REPORT\n\t\t},\n\t\t&timezone_string,\n\t\t\"GMT\",\n\t\tcheck_timezone, assign_timezone, show_timezone\n\t},\n\t{\n\t\t{\"timezone_abbreviations\", PGC_USERSET, CLIENT_CONN_LOCALE,\n\t\t\tgettext_noop(\"Selects a file of time zone abbreviations.\"),\n\t\t\tNULL\n\t\t},\n\t\t&timezone_abbreviations_string,\n\t\tNULL,\n\t\tcheck_timezone_abbreviations, assign_timezone_abbreviations, NULL\n\t},\n\n\t{\n\t\t{\"transaction_isolation\", PGC_USERSET, CLIENT_CONN_STATEMENT,\n\t\t\tgettext_noop(\"Sets the current transaction's isolation level.\"),\n\t\t\tNULL,\n\t\t\tGUC_NO_RESET_ALL | GUC_NOT_IN_SAMPLE | GUC_DISALLOW_IN_FILE\n\t\t},\n\t\t&XactIsoLevel_string,\n\t\t\"default\",\n\t\tcheck_XactIsoLevel, assign_XactIsoLevel, show_XactIsoLevel\n\t},\n\n\t{\n\t\t{\"unix_socket_group\", PGC_POSTMASTER, CONN_AUTH_SETTINGS,\n\t\t\tgettext_noop(\"Sets the owning group of the Unix-domain socket.\"),\n\t\t\tgettext_noop(\"The owning user of the socket is always the user \"\n\t\t\t\t\t\t \"that starts the server.\")\n\t\t},\n\t\t&Unix_socket_group,\n\t\t\"\",\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"unix_socket_directories\", PGC_POSTMASTER, CONN_AUTH_SETTINGS,\n\t\t\tgettext_noop(\"Sets the directories where Unix-domain sockets will be created.\"),\n\t\t\tNULL,\n\t\t\tGUC_SUPERUSER_ONLY\n\t\t},\n\t\t&Unix_socket_directories,\n#ifdef HAVE_UNIX_SOCKETS\n\t\tDEFAULT_PGSOCKET_DIR,\n#else\n\t\t\"\",\n#endif\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"listen_addresses\", PGC_POSTMASTER, CONN_AUTH_SETTINGS,\n\t\t\tgettext_noop(\"Sets the host name or IP address(es) to listen to.\"),\n\t\t\tNULL,\n\t\t\tGUC_LIST_INPUT\n\t\t},\n\t\t&ListenAddresses,\n\t\t\"localhost\",\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t/*\n\t\t * Can't be set by ALTER SYSTEM as it can lead to recursive definition\n\t\t * of data_directory.\n\t\t */\n\t\t{\"data_directory\", PGC_POSTMASTER, FILE_LOCATIONS,\n\t\t\tgettext_noop(\"Sets the server's data directory.\"),\n\t\t\tNULL,\n\t\t\tGUC_SUPERUSER_ONLY | GUC_DISALLOW_IN_AUTO_FILE\n\t\t},\n\t\t&data_directory,\n\t\tNULL,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"config_file\", PGC_POSTMASTER, FILE_LOCATIONS,\n\t\t\tgettext_noop(\"Sets the server's main configuration file.\"),\n\t\t\tNULL,\n\t\t\tGUC_DISALLOW_IN_FILE | GUC_SUPERUSER_ONLY\n\t\t},\n\t\t&ConfigFileName,\n\t\tNULL,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"hba_file\", PGC_POSTMASTER, FILE_LOCATIONS,\n\t\t\tgettext_noop(\"Sets the server's \\\"hba\\\" configuration file.\"),\n\t\t\tNULL,\n\t\t\tGUC_SUPERUSER_ONLY\n\t\t},\n\t\t&HbaFileName,\n\t\tNULL,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"ident_file\", PGC_POSTMASTER, FILE_LOCATIONS,\n\t\t\tgettext_noop(\"Sets the server's \\\"ident\\\" configuration file.\"),\n\t\t\tNULL,\n\t\t\tGUC_SUPERUSER_ONLY\n\t\t},\n\t\t&IdentFileName,\n\t\tNULL,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"external_pid_file\", PGC_POSTMASTER, FILE_LOCATIONS,\n\t\t\tgettext_noop(\"Writes the postmaster PID to the specified file.\"),\n\t\t\tNULL,\n\t\t\tGUC_SUPERUSER_ONLY\n\t\t},\n\t\t&external_pid_file,\n\t\tNULL,\n\t\tcheck_canonical_path, NULL, NULL\n\t},\n\n\t{\n\t\t{\"ssl_cert_file\", PGC_SIGHUP, CONN_AUTH_SSL,\n\t\t\tgettext_noop(\"Location of the SSL server certificate file.\"),\n\t\t\tNULL\n\t\t},\n\t\t&ssl_cert_file,\n\t\t\"server.crt\",\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"ssl_key_file\", PGC_SIGHUP, CONN_AUTH_SSL,\n\t\t\tgettext_noop(\"Location of the SSL server private key file.\"),\n\t\t\tNULL\n\t\t},\n\t\t&ssl_key_file,\n\t\t\"server.key\",\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"ssl_ca_file\", PGC_SIGHUP, CONN_AUTH_SSL,\n\t\t\tgettext_noop(\"Location of the SSL certificate authority file.\"),\n\t\t\tNULL\n\t\t},\n\t\t&ssl_ca_file,\n\t\t\"\",\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"ssl_crl_file\", PGC_SIGHUP, CONN_AUTH_SSL,\n\t\t\tgettext_noop(\"Location of the SSL certificate revocation list file.\"),\n\t\t\tNULL\n\t\t},\n\t\t&ssl_crl_file,\n\t\t\"\",\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"stats_temp_directory\", PGC_SIGHUP, STATS_COLLECTOR,\n\t\t\tgettext_noop(\"Writes temporary statistics files to the specified directory.\"),\n\t\t\tNULL,\n\t\t\tGUC_SUPERUSER_ONLY\n\t\t},\n\t\t&pgstat_temp_directory,\n\t\tPG_STAT_TMP_DIR,\n\t\tcheck_canonical_path, assign_pgstat_temp_directory, NULL\n\t},\n\n\t{\n\t\t{\"synchronous_standby_names\", PGC_SIGHUP, REPLICATION_MASTER,\n\t\t\tgettext_noop(\"Number of synchronous standbys and list of names of potential synchronous ones.\"),\n\t\t\tNULL,\n\t\t\tGUC_LIST_INPUT\n\t\t},\n\t\t&SyncRepStandbyNames,\n\t\t\"\",\n\t\tcheck_synchronous_standby_names, assign_synchronous_standby_names, NULL\n\t},\n\n\t{\n\t\t{\"default_text_search_config\", PGC_USERSET, CLIENT_CONN_LOCALE,\n\t\t\tgettext_noop(\"Sets default text search configuration.\"),\n\t\t\tNULL\n\t\t},\n\t\t&TSCurrentConfig,\n\t\t\"pg_catalog.simple\",\n\t\tcheck_TSCurrentConfig, assign_TSCurrentConfig, NULL\n\t},\n\n\t{\n\t\t{\"ssl_ciphers\", PGC_SIGHUP, CONN_AUTH_SSL,\n\t\t\tgettext_noop(\"Sets the list of allowed SSL ciphers.\"),\n\t\t\tNULL,\n\t\t\tGUC_SUPERUSER_ONLY\n\t\t},\n\t\t&SSLCipherSuites,\n#ifdef USE_SSL\n\t\t\"HIGH:MEDIUM:+3DES:!aNULL\",\n#else\n\t\t\"none\",\n#endif\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"ssl_ecdh_curve\", PGC_SIGHUP, CONN_AUTH_SSL,\n\t\t\tgettext_noop(\"Sets the curve to use for ECDH.\"),\n\t\t\tNULL,\n\t\t\tGUC_SUPERUSER_ONLY\n\t\t},\n\t\t&SSLECDHCurve,\n#ifdef USE_SSL\n\t\t\"prime256v1\",\n#else\n\t\t\"none\",\n#endif\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"ssl_dh_params_file\", PGC_SIGHUP, CONN_AUTH_SSL,\n\t\t\tgettext_noop(\"Location of the SSL DH parameters file.\"),\n\t\t\tNULL,\n\t\t\tGUC_SUPERUSER_ONLY\n\t\t},\n\t\t&ssl_dh_params_file,\n\t\t\"\",\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"ssl_passphrase_command\", PGC_SIGHUP, CONN_AUTH_SSL,\n\t\t\tgettext_noop(\"Command to obtain passphrases for SSL.\"),\n\t\t\tNULL\n\t\t},\n\t\t&ssl_passphrase_command,\n\t\t\"\",\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"application_name\", PGC_USERSET, LOGGING_WHAT,\n\t\t\tgettext_noop(\"Sets the application name to be reported in statistics and logs.\"),\n\t\t\tNULL,\n\t\t\tGUC_IS_NAME | GUC_REPORT | GUC_NOT_IN_SAMPLE\n\t\t},\n\t\t&application_name,\n\t\t\"\",\n\t\tcheck_application_name, assign_application_name, NULL\n\t},\n\n\t{\n\t\t{\"cluster_name\", PGC_POSTMASTER, PROCESS_TITLE,\n\t\t\tgettext_noop(\"Sets the name of the cluster, which is included in the process title.\"),\n\t\t\tNULL,\n\t\t\tGUC_IS_NAME\n\t\t},\n\t\t&cluster_name,\n\t\t\"\",\n\t\tcheck_cluster_name, NULL, NULL\n\t},\n\n\t{\n\t\t{\"wal_consistency_checking\", PGC_SUSET, DEVELOPER_OPTIONS,\n\t\t\tgettext_noop(\"Sets the WAL resource managers for which WAL consistency checks are done.\"),\n\t\t\tgettext_noop(\"Full-page images will be logged for all data blocks and cross-checked against the results of WAL replay.\"),\n\t\t\tGUC_LIST_INPUT | GUC_NOT_IN_SAMPLE\n\t\t},\n\t\t&wal_consistency_checking_string,\n\t\t\"\",\n\t\tcheck_wal_consistency_checking, assign_wal_consistency_checking, NULL\n\t},\n\n\t{\n\t\t{\"jit_provider\", PGC_POSTMASTER, CLIENT_CONN_PRELOAD,\n\t\t\tgettext_noop(\"JIT provider to use.\"),\n\t\t\tNULL,\n\t\t\tGUC_SUPERUSER_ONLY\n\t\t},\n\t\t&jit_provider,\n\t\t\"llvmjit\",\n\t\tNULL, NULL, NULL\n\t},\n\n\t/* End-of-list marker */\n\t{\n\t\t{NULL, 0, 0, NULL, NULL}, NULL, NULL, NULL, NULL, NULL\n\t}\n};\nstatic struct config_enum ConfigureNamesEnum[] =\n{\n\t{\n\t\t{\"backslash_quote\", PGC_USERSET, COMPAT_OPTIONS_PREVIOUS,\n\t\t\tgettext_noop(\"Sets whether \\\"\\\\'\\\" is allowed in string literals.\"),\n\t\t\tNULL\n\t\t},\n\t\t&backslash_quote,\n\t\tBACKSLASH_QUOTE_SAFE_ENCODING, backslash_quote_options,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"bytea_output\", PGC_USERSET, CLIENT_CONN_STATEMENT,\n\t\t\tgettext_noop(\"Sets the output format for bytea.\"),\n\t\t\tNULL\n\t\t},\n\t\t&bytea_output,\n\t\tBYTEA_OUTPUT_HEX, bytea_output_options,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"client_min_messages\", PGC_USERSET, CLIENT_CONN_STATEMENT,\n\t\t\tgettext_noop(\"Sets the message levels that are sent to the client.\"),\n\t\t\tgettext_noop(\"Each level includes all the levels that follow it. The later\"\n\t\t\t\t\t\t \" the level, the fewer messages are sent.\")\n\t\t},\n\t\t&client_min_messages,\n\t\tNOTICE, client_message_level_options,\n\t\tcheck_client_min_messages, NULL, NULL\n\t},\n\n\t{\n\t\t{\"constraint_exclusion\", PGC_USERSET, QUERY_TUNING_OTHER,\n\t\t\tgettext_noop(\"Enables the planner to use constraints to optimize queries.\"),\n\t\t\tgettext_noop(\"Table scans will be skipped if their constraints\"\n\t\t\t\t\t\t \" guarantee that no rows match the query.\")\n\t\t},\n\t\t&constraint_exclusion,\n\t\tCONSTRAINT_EXCLUSION_PARTITION, constraint_exclusion_options,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"default_transaction_isolation\", PGC_USERSET, CLIENT_CONN_STATEMENT,\n\t\t\tgettext_noop(\"Sets the transaction isolation level of each new transaction.\"),\n\t\t\tNULL\n\t\t},\n\t\t&DefaultXactIsoLevel,\n\t\tXACT_READ_COMMITTED, isolation_level_options,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"IntervalStyle\", PGC_USERSET, CLIENT_CONN_LOCALE,\n\t\t\tgettext_noop(\"Sets the display format for interval values.\"),\n\t\t\tNULL,\n\t\t\tGUC_REPORT\n\t\t},\n\t\t&IntervalStyle,\n\t\tINTSTYLE_POSTGRES, intervalstyle_options,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"log_error_verbosity\", PGC_SUSET, LOGGING_WHAT,\n\t\t\tgettext_noop(\"Sets the verbosity of logged messages.\"),\n\t\t\tNULL\n\t\t},\n\t\t&Log_error_verbosity,\n\t\tPGERROR_DEFAULT, log_error_verbosity_options,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"log_min_messages\", PGC_SUSET, LOGGING_WHEN,\n\t\t\tgettext_noop(\"Sets the message levels that are logged.\"),\n\t\t\tgettext_noop(\"Each level includes all the levels that follow it. The later\"\n\t\t\t\t\t\t \" the level, the fewer messages are sent.\")\n\t\t},\n\t\t&log_min_messages,\n\t\tWARNING, server_message_level_options,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"log_min_error_statement\", PGC_SUSET, LOGGING_WHEN,\n\t\t\tgettext_noop(\"Causes all statements generating error at or above this level to be logged.\"),\n\t\t\tgettext_noop(\"Each level includes all the levels that follow it. The later\"\n\t\t\t\t\t\t \" the level, the fewer messages are sent.\")\n\t\t},\n\t\t&log_min_error_statement,\n\t\tERROR, server_message_level_options,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"log_statement\", PGC_SUSET, LOGGING_WHAT,\n\t\t\tgettext_noop(\"Sets the type of statements logged.\"),\n\t\t\tNULL\n\t\t},\n\t\t&log_statement,\n\t\tLOGSTMT_NONE, log_statement_options,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"syslog_facility\", PGC_SIGHUP, LOGGING_WHERE,\n\t\t\tgettext_noop(\"Sets the syslog \\\"facility\\\" to be used when syslog enabled.\"),\n\t\t\tNULL\n\t\t},\n\t\t&syslog_facility,\n#ifdef HAVE_SYSLOG\n\t\tLOG_LOCAL0,\n#else\n\t\t0,\n#endif\n\t\tsyslog_facility_options,\n\t\tNULL, assign_syslog_facility, NULL\n\t},\n\n\t{\n\t\t{\"session_replication_role\", PGC_SUSET, CLIENT_CONN_STATEMENT,\n\t\t\tgettext_noop(\"Sets the session's behavior for triggers and rewrite rules.\"),\n\t\t\tNULL\n\t\t},\n\t\t&SessionReplicationRole,\n\t\tSESSION_REPLICATION_ROLE_ORIGIN, session_replication_role_options,\n\t\tNULL, assign_session_replication_role, NULL\n\t},\n\n\t{\n\t\t{\"synchronous_commit\", PGC_USERSET, WAL_SETTINGS,\n\t\t\tgettext_noop(\"Sets the current transaction's synchronization level.\"),\n\t\t\tNULL\n\t\t},\n\t\t&synchronous_commit,\n\t\tSYNCHRONOUS_COMMIT_ON, synchronous_commit_options,\n\t\tNULL, assign_synchronous_commit, NULL\n\t},\n\n\t{\n\t\t{\"archive_mode\", PGC_POSTMASTER, WAL_ARCHIVING,\n\t\t\tgettext_noop(\"Allows archiving of WAL files using archive_command.\"),\n\t\t\tNULL\n\t\t},\n\t\t&XLogArchiveMode,\n\t\tARCHIVE_MODE_OFF, archive_mode_options,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"trace_recovery_messages\", PGC_SIGHUP, DEVELOPER_OPTIONS,\n\t\t\tgettext_noop(\"Enables logging of recovery-related debugging information.\"),\n\t\t\tgettext_noop(\"Each level includes all the levels that follow it. The later\"\n\t\t\t\t\t\t \" the level, the fewer messages are sent.\")\n\t\t},\n\t\t&trace_recovery_messages,\n\n\t\t/*\n\t\t * client_message_level_options allows too many values, really, but\n\t\t * it's not worth having a separate options array for this.\n\t\t */\n\t\tLOG, client_message_level_options,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"track_functions\", PGC_SUSET, STATS_COLLECTOR,\n\t\t\tgettext_noop(\"Collects function-level statistics on database activity.\"),\n\t\t\tNULL\n\t\t},\n\t\t&pgstat_track_functions,\n\t\tTRACK_FUNC_OFF, track_function_options,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"wal_level\", PGC_POSTMASTER, WAL_SETTINGS,\n\t\t\tgettext_noop(\"Set the level of information written to the WAL.\"),\n\t\t\tNULL\n\t\t},\n\t\t&wal_level,\n\t\tWAL_LEVEL_REPLICA, wal_level_options,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"dynamic_shared_memory_type\", PGC_POSTMASTER, RESOURCES_MEM,\n\t\t\tgettext_noop(\"Selects the dynamic shared memory implementation used.\"),\n\t\t\tNULL\n\t\t},\n\t\t&dynamic_shared_memory_type,\n\t\tDEFAULT_DYNAMIC_SHARED_MEMORY_TYPE, dynamic_shared_memory_options,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"wal_sync_method\", PGC_SIGHUP, WAL_SETTINGS,\n\t\t\tgettext_noop(\"Selects the method used for forcing WAL updates to disk.\"),\n\t\t\tNULL\n\t\t},\n\t\t&sync_method,\n\t\tDEFAULT_SYNC_METHOD, sync_method_options,\n\t\tNULL, assign_xlog_sync_method, NULL\n\t},\n\n\t{\n\t\t{\"xmlbinary\", PGC_USERSET, CLIENT_CONN_STATEMENT,\n\t\t\tgettext_noop(\"Sets how binary values are to be encoded in XML.\"),\n\t\t\tNULL\n\t\t},\n\t\t&xmlbinary,\n\t\tXMLBINARY_BASE64, xmlbinary_options,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"xmloption\", PGC_USERSET, CLIENT_CONN_STATEMENT,\n\t\t\tgettext_noop(\"Sets whether XML data in implicit parsing and serialization \"\n\t\t\t\t\t\t \"operations is to be considered as documents or content fragments.\"),\n\t\t\tNULL\n\t\t},\n\t\t&xmloption,\n\t\tXMLOPTION_CONTENT, xmloption_options,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"huge_pages\", PGC_POSTMASTER, RESOURCES_MEM,\n\t\t\tgettext_noop(\"Use of huge pages on Linux or Windows.\"),\n\t\t\tNULL\n\t\t},\n\t\t&huge_pages,\n\t\tHUGE_PAGES_TRY, huge_pages_options,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"force_parallel_mode\", PGC_USERSET, QUERY_TUNING_OTHER,\n\t\t\tgettext_noop(\"Forces use of parallel query facilities.\"),\n\t\t\tgettext_noop(\"If possible, run query using a parallel worker and with parallel restrictions.\")\n\t\t},\n\t\t&force_parallel_mode,\n\t\tFORCE_PARALLEL_OFF, force_parallel_mode_options,\n\t\tNULL, NULL, NULL\n\t},\n\n\t{\n\t\t{\"password_encryption\", PGC_USERSET, CONN_AUTH_AUTH,\n\t\t\tgettext_noop(\"Encrypt passwords.\"),\n\t\t\tgettext_noop(\"When a password is specified in CREATE USER or \"\n\t\t\t\t\t\t \"ALTER USER without writing either ENCRYPTED or UNENCRYPTED, \"\n\t\t\t\t\t\t \"this parameter determines whether the password is to be encrypted.\")\n\t\t},\n\t\t&Password_encryption,\n\t\tPASSWORD_TYPE_MD5, password_encryption_options,\n\t\tNULL, NULL, NULL\n\t},\n\n\t/* End-of-list marker */\n\t{\n\t\t{NULL, 0, 0, NULL, NULL}, NULL, 0, NULL, NULL, NULL, NULL\n\t}\n};\nstatic struct config_generic **guc_variables;\nstatic int\tnum_guc_variables;\nstatic int\tsize_guc_variables;\n\nvoid\nbuild_guc_variables(void)\n{\n\tint\t\t\tsize_vars;\n\tint\t\t\tnum_vars = 0;\n\tstruct config_generic **guc_vars;\n\tint\t\t\ti;\n\n\tfor (i = 0; ConfigureNamesBool[i].gen.name; i++)\n\t{\n\t\tstruct config_bool *conf = &ConfigureNamesBool[i];\n\n\t\t/* Rather than requiring vartype to be filled in by hand, do this: */\n\t\tconf->gen.vartype = PGC_BOOL;\n\t\tnum_vars++;\n\t}\n\n\tfor (i = 0; ConfigureNamesInt[i].gen.name; i++)\n\t{\n\t\tstruct config_int *conf = &ConfigureNamesInt[i];\n\n\t\tconf->gen.vartype = PGC_INT;\n\t\tnum_vars++;\n\t}\n\n\tfor (i = 0; ConfigureNamesReal[i].gen.name; i++)\n\t{\n\t\tstruct config_real *conf = &ConfigureNamesReal[i];\n\n\t\tconf->gen.vartype = PGC_REAL;\n\t\tnum_vars++;\n\t}\n\n\tfor (i = 0; ConfigureNamesString[i].gen.name; i++)\n\t{\n\t\tstruct config_string *conf = &ConfigureNamesString[i];\n\n\t\tconf->gen.vartype = PGC_STRING;\n\t\tnum_vars++;\n\t}\n\n\tfor (i = 0; ConfigureNamesEnum[i].gen.name; i++)\n\t{\n\t\tstruct config_enum *conf = &ConfigureNamesEnum[i];\n\n\t\tconf->gen.vartype = PGC_ENUM;\n\t\tnum_vars++;\n\t}\n\n\t/*\n\t * Create table with 20% slack\n\t */\n\tsize_vars = num_vars + num_vars / 4;\n\n\tguc_vars = (struct config_generic **)\n\t\tguc_malloc(FATAL, size_vars * sizeof(struct config_generic *));\n\n\tnum_vars = 0;\n\n\tfor (i = 0; ConfigureNamesBool[i].gen.name; i++)\n\t\tguc_vars[num_vars++] = &ConfigureNamesBool[i].gen;\n\n\tfor (i = 0; ConfigureNamesInt[i].gen.name; i++)\n\t\tguc_vars[num_vars++] = &ConfigureNamesInt[i].gen;\n\n\tfor (i = 0; ConfigureNamesReal[i].gen.name; i++)\n\t\tguc_vars[num_vars++] = &ConfigureNamesReal[i].gen;\n\n\tfor (i = 0; ConfigureNamesString[i].gen.name; i++)\n\t\tguc_vars[num_vars++] = &ConfigureNamesString[i].gen;\n\n\tfor (i = 0; ConfigureNamesEnum[i].gen.name; i++)\n\t\tguc_vars[num_vars++] = &ConfigureNamesEnum[i].gen;\n\n\tif (guc_variables)\n\t\tfree(guc_variables);\n\tguc_variables = guc_vars;\n\tnum_guc_variables = num_vars;\n\tsize_guc_variables = size_vars;\n\tqsort((void *) guc_variables, num_guc_variables,\n\t\t  sizeof(struct config_generic *), guc_var_compare);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/help_config.h\"\n#include \"utils/guc_tables.h\"\n#include <unistd.h>\n#include <limits.h>\n#include <float.h>\n#include \"postgres.h\"\n\nvoid\nGucInfoMain(void)\n{\n\tstruct config_generic **guc_vars;\n\tint\t\t\tnumOpts,\n\t\t\t\ti;\n\n\t/* Initialize the guc_variables[] array */\n\tbuild_guc_variables();\n\n\tguc_vars = get_guc_variables();\n\tnumOpts = GetNumConfigOptions();\n\n\tfor (i = 0; i < numOpts; i++)\n\t{\n\t\tmixedStruct *var = (mixedStruct *) guc_vars[i];\n\n\t\tif (displayStruct(var))\n\t\t\tprintMixedStruct(var);\n\t}\n\n\texit(0);\n}"
  }
]