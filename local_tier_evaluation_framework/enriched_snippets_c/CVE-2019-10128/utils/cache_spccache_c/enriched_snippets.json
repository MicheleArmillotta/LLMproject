[
  {
    "function_name": "get_tablespace_io_concurrency",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/spccache.c",
    "lines": "214-223",
    "snippet": "int\nget_tablespace_io_concurrency(Oid spcid)\n{\n\tTableSpaceCacheEntry *spc = get_tablespace(spcid);\n\n\tif (!spc->opts || spc->opts->effective_io_concurrency < 0)\n\t\treturn effective_io_concurrency;\n\telse\n\t\treturn spc->opts->effective_io_concurrency;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_tablespace",
          "args": [
            "spcid"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "get_tablespace_io_concurrency",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/spccache.c",
          "lines": "214-223",
          "snippet": "int\nget_tablespace_io_concurrency(Oid spcid)\n{\n\tTableSpaceCacheEntry *spc = get_tablespace(spcid);\n\n\tif (!spc->opts || spc->opts->effective_io_concurrency < 0)\n\t\treturn effective_io_concurrency;\n\telse\n\t\treturn spc->opts->effective_io_concurrency;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/inval.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/catcache.h\"\n#include \"storage/bufmgr.h\"\n#include \"optimizer/cost.h\"\n#include \"miscadmin.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"access/reloptions.h\"\n#include \"postgres.h\"\n\nint\nget_tablespace_io_concurrency(Oid spcid)\n{\n\tTableSpaceCacheEntry *spc = get_tablespace(spcid);\n\n\tif (!spc->opts || spc->opts->effective_io_concurrency < 0)\n\t\treturn effective_io_concurrency;\n\telse\n\t\treturn spc->opts->effective_io_concurrency;\n}"
  },
  {
    "function_name": "get_tablespace_page_costs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/spccache.c",
    "lines": "181-205",
    "snippet": "void\nget_tablespace_page_costs(Oid spcid,\n\t\t\t\t\t\t  double *spc_random_page_cost,\n\t\t\t\t\t\t  double *spc_seq_page_cost)\n{\n\tTableSpaceCacheEntry *spc = get_tablespace(spcid);\n\n\tAssert(spc != NULL);\n\n\tif (spc_random_page_cost)\n\t{\n\t\tif (!spc->opts || spc->opts->random_page_cost < 0)\n\t\t\t*spc_random_page_cost = random_page_cost;\n\t\telse\n\t\t\t*spc_random_page_cost = spc->opts->random_page_cost;\n\t}\n\n\tif (spc_seq_page_cost)\n\t{\n\t\tif (!spc->opts || spc->opts->seq_page_cost < 0)\n\t\t\t*spc_seq_page_cost = seq_page_cost;\n\t\telse\n\t\t\t*spc_seq_page_cost = spc->opts->seq_page_cost;\n\t}\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "spc != NULL"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_tablespace",
          "args": [
            "spcid"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "get_tablespace_io_concurrency",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/spccache.c",
          "lines": "214-223",
          "snippet": "int\nget_tablespace_io_concurrency(Oid spcid)\n{\n\tTableSpaceCacheEntry *spc = get_tablespace(spcid);\n\n\tif (!spc->opts || spc->opts->effective_io_concurrency < 0)\n\t\treturn effective_io_concurrency;\n\telse\n\t\treturn spc->opts->effective_io_concurrency;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/inval.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/catcache.h\"\n#include \"storage/bufmgr.h\"\n#include \"optimizer/cost.h\"\n#include \"miscadmin.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"access/reloptions.h\"\n#include \"postgres.h\"\n\nint\nget_tablespace_io_concurrency(Oid spcid)\n{\n\tTableSpaceCacheEntry *spc = get_tablespace(spcid);\n\n\tif (!spc->opts || spc->opts->effective_io_concurrency < 0)\n\t\treturn effective_io_concurrency;\n\telse\n\t\treturn spc->opts->effective_io_concurrency;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/inval.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/catcache.h\"\n#include \"storage/bufmgr.h\"\n#include \"optimizer/cost.h\"\n#include \"miscadmin.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"access/reloptions.h\"\n#include \"postgres.h\"\n\nvoid\nget_tablespace_page_costs(Oid spcid,\n\t\t\t\t\t\t  double *spc_random_page_cost,\n\t\t\t\t\t\t  double *spc_seq_page_cost)\n{\n\tTableSpaceCacheEntry *spc = get_tablespace(spcid);\n\n\tAssert(spc != NULL);\n\n\tif (spc_random_page_cost)\n\t{\n\t\tif (!spc->opts || spc->opts->random_page_cost < 0)\n\t\t\t*spc_random_page_cost = random_page_cost;\n\t\telse\n\t\t\t*spc_random_page_cost = spc->opts->random_page_cost;\n\t}\n\n\tif (spc_seq_page_cost)\n\t{\n\t\tif (!spc->opts || spc->opts->seq_page_cost < 0)\n\t\t\t*spc_seq_page_cost = seq_page_cost;\n\t\telse\n\t\t\t*spc_seq_page_cost = spc->opts->seq_page_cost;\n\t}\n}"
  },
  {
    "function_name": "get_tablespace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/spccache.c",
    "lines": "106-171",
    "snippet": "static TableSpaceCacheEntry *\nget_tablespace(Oid spcid)\n{\n\tTableSpaceCacheEntry *spc;\n\tHeapTuple\ttp;\n\tTableSpaceOpts *opts;\n\n\t/*\n\t * Since spcid is always from a pg_class tuple, InvalidOid implies the\n\t * default.\n\t */\n\tif (spcid == InvalidOid)\n\t\tspcid = MyDatabaseTableSpace;\n\n\t/* Find existing cache entry, if any. */\n\tif (!TableSpaceCacheHash)\n\t\tInitializeTableSpaceCache();\n\tspc = (TableSpaceCacheEntry *) hash_search(TableSpaceCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t   (void *) &spcid,\n\t\t\t\t\t\t\t\t\t\t\t   HASH_FIND,\n\t\t\t\t\t\t\t\t\t\t\t   NULL);\n\tif (spc)\n\t\treturn spc;\n\n\t/*\n\t * Not found in TableSpace cache.  Check catcache.  If we don't find a\n\t * valid HeapTuple, it must mean someone has managed to request tablespace\n\t * details for a non-existent tablespace.  We'll just treat that case as\n\t * if no options were specified.\n\t */\n\ttp = SearchSysCache1(TABLESPACEOID, ObjectIdGetDatum(spcid));\n\tif (!HeapTupleIsValid(tp))\n\t\topts = NULL;\n\telse\n\t{\n\t\tDatum\t\tdatum;\n\t\tbool\t\tisNull;\n\n\t\tdatum = SysCacheGetAttr(TABLESPACEOID,\n\t\t\t\t\t\t\t\ttp,\n\t\t\t\t\t\t\t\tAnum_pg_tablespace_spcoptions,\n\t\t\t\t\t\t\t\t&isNull);\n\t\tif (isNull)\n\t\t\topts = NULL;\n\t\telse\n\t\t{\n\t\t\tbytea\t   *bytea_opts = tablespace_reloptions(datum, false);\n\n\t\t\topts = MemoryContextAlloc(CacheMemoryContext, VARSIZE(bytea_opts));\n\t\t\tmemcpy(opts, bytea_opts, VARSIZE(bytea_opts));\n\t\t}\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Now create the cache entry.  It's important to do this only after\n\t * reading the pg_tablespace entry, since doing so could cause a cache\n\t * flush.\n\t */\n\tspc = (TableSpaceCacheEntry *) hash_search(TableSpaceCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t   (void *) &spcid,\n\t\t\t\t\t\t\t\t\t\t\t   HASH_ENTER,\n\t\t\t\t\t\t\t\t\t\t\t   NULL);\n\tspc->opts = opts;\n\treturn spc;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static HTAB *TableSpaceCacheHash = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash_search",
          "args": [
            "TableSpaceCacheHash",
            "(void *) &spcid",
            "HASH_ENTER",
            "NULL"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "hash_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "905-916",
          "snippet": "void *\nhash_search(HTAB *hashp,\n\t\t\tconst void *keyPtr,\n\t\t\tHASHACTION action,\n\t\t\tbool *foundPtr)\n{\n\treturn hash_search_with_hash_value(hashp,\n\t\t\t\t\t\t\t\t\t   keyPtr,\n\t\t\t\t\t\t\t\t\t   hashp->hash(keyPtr, hashp->keysize),\n\t\t\t\t\t\t\t\t\t   action,\n\t\t\t\t\t\t\t\t\t   foundPtr);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid *\nhash_search(HTAB *hashp,\n\t\t\tconst void *keyPtr,\n\t\t\tHASHACTION action,\n\t\t\tbool *foundPtr)\n{\n\treturn hash_search_with_hash_value(hashp,\n\t\t\t\t\t\t\t\t\t   keyPtr,\n\t\t\t\t\t\t\t\t\t   hashp->hash(keyPtr, hashp->keysize),\n\t\t\t\t\t\t\t\t\t   action,\n\t\t\t\t\t\t\t\t\t   foundPtr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ReleaseSysCache",
          "args": [
            "tp"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "ReleaseSysCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1159-1163",
          "snippet": "void\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "opts",
            "bytea_opts",
            "VARSIZE(bytea_opts)"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "bytea_opts"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextAlloc",
          "args": [
            "CacheMemoryContext",
            "VARSIZE(bytea_opts)"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1079-1106",
          "snippet": "void *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "bytea_opts"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tablespace_reloptions",
          "args": [
            "datum",
            "false"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SysCacheGetAttr",
          "args": [
            "TABLESPACEOID",
            "tp",
            "Anum_pg_tablespace_spcoptions",
            "&isNull"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "SysCacheGetAttr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1367-1390",
          "snippet": "Datum\nSysCacheGetAttr(int cacheId, HeapTuple tup,\n\t\t\t\tAttrNumber attributeNumber,\n\t\t\t\tbool *isNull)\n{\n\t/*\n\t * We just need to get the TupleDesc out of the cache entry, and then we\n\t * can apply heap_getattr().  Normally the cache control data is already\n\t * valid (because the caller recently fetched the tuple via this same\n\t * cache), but there are cases where we have to initialize the cache here.\n\t */\n\tif (cacheId < 0 || cacheId >= SysCacheSize ||\n\t\t!PointerIsValid(SysCache[cacheId]))\n\t\telog(ERROR, \"invalid cache ID: %d\", cacheId);\n\tif (!PointerIsValid(SysCache[cacheId]->cc_tupdesc))\n\t{\n\t\tInitCatCachePhase2(SysCache[cacheId], false);\n\t\tAssert(PointerIsValid(SysCache[cacheId]->cc_tupdesc));\n\t}\n\n\treturn heap_getattr(tup, attributeNumber,\n\t\t\t\t\t\tSysCache[cacheId]->cc_tupdesc,\n\t\t\t\t\t\tisNull);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nDatum\nSysCacheGetAttr(int cacheId, HeapTuple tup,\n\t\t\t\tAttrNumber attributeNumber,\n\t\t\t\tbool *isNull)\n{\n\t/*\n\t * We just need to get the TupleDesc out of the cache entry, and then we\n\t * can apply heap_getattr().  Normally the cache control data is already\n\t * valid (because the caller recently fetched the tuple via this same\n\t * cache), but there are cases where we have to initialize the cache here.\n\t */\n\tif (cacheId < 0 || cacheId >= SysCacheSize ||\n\t\t!PointerIsValid(SysCache[cacheId]))\n\t\telog(ERROR, \"invalid cache ID: %d\", cacheId);\n\tif (!PointerIsValid(SysCache[cacheId]->cc_tupdesc))\n\t{\n\t\tInitCatCachePhase2(SysCache[cacheId], false);\n\t\tAssert(PointerIsValid(SysCache[cacheId]->cc_tupdesc));\n\t}\n\n\treturn heap_getattr(tup, attributeNumber,\n\t\t\t\t\t\tSysCache[cacheId]->cc_tupdesc,\n\t\t\t\t\t\tisNull);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "tp"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SearchSysCache1",
          "args": [
            "TABLESPACEOID",
            "ObjectIdGetDatum(spcid)"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "SearchSysCache1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1111-1120",
          "snippet": "HeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nHeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "spcid"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InitializeTableSpaceCache",
          "args": [],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "InitializeTableSpaceCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/spccache.c",
          "lines": "76-97",
          "snippet": "static void\nInitializeTableSpaceCache(void)\n{\n\tHASHCTL\t\tctl;\n\n\t/* Initialize the hash table. */\n\tMemSet(&ctl, 0, sizeof(ctl));\n\tctl.keysize = sizeof(Oid);\n\tctl.entrysize = sizeof(TableSpaceCacheEntry);\n\tTableSpaceCacheHash =\n\t\thash_create(\"TableSpace cache\", 16, &ctl,\n\t\t\t\t\tHASH_ELEM | HASH_BLOBS);\n\n\t/* Make sure we've initialized CacheMemoryContext. */\n\tif (!CacheMemoryContext)\n\t\tCreateCacheMemoryContext();\n\n\t/* Watch for invalidation events. */\n\tCacheRegisterSyscacheCallback(TABLESPACEOID,\n\t\t\t\t\t\t\t\t  InvalidateTableSpaceCacheCallback,\n\t\t\t\t\t\t\t\t  (Datum) 0);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HTAB *TableSpaceCacheHash = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/inval.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/catcache.h\"\n#include \"storage/bufmgr.h\"\n#include \"optimizer/cost.h\"\n#include \"miscadmin.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"access/reloptions.h\"\n#include \"postgres.h\"\n\nstatic HTAB *TableSpaceCacheHash = NULL;\n\nstatic void\nInitializeTableSpaceCache(void)\n{\n\tHASHCTL\t\tctl;\n\n\t/* Initialize the hash table. */\n\tMemSet(&ctl, 0, sizeof(ctl));\n\tctl.keysize = sizeof(Oid);\n\tctl.entrysize = sizeof(TableSpaceCacheEntry);\n\tTableSpaceCacheHash =\n\t\thash_create(\"TableSpace cache\", 16, &ctl,\n\t\t\t\t\tHASH_ELEM | HASH_BLOBS);\n\n\t/* Make sure we've initialized CacheMemoryContext. */\n\tif (!CacheMemoryContext)\n\t\tCreateCacheMemoryContext();\n\n\t/* Watch for invalidation events. */\n\tCacheRegisterSyscacheCallback(TABLESPACEOID,\n\t\t\t\t\t\t\t\t  InvalidateTableSpaceCacheCallback,\n\t\t\t\t\t\t\t\t  (Datum) 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/inval.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/catcache.h\"\n#include \"storage/bufmgr.h\"\n#include \"optimizer/cost.h\"\n#include \"miscadmin.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"access/reloptions.h\"\n#include \"postgres.h\"\n\nstatic HTAB *TableSpaceCacheHash = NULL;\n\nstatic TableSpaceCacheEntry *\nget_tablespace(Oid spcid)\n{\n\tTableSpaceCacheEntry *spc;\n\tHeapTuple\ttp;\n\tTableSpaceOpts *opts;\n\n\t/*\n\t * Since spcid is always from a pg_class tuple, InvalidOid implies the\n\t * default.\n\t */\n\tif (spcid == InvalidOid)\n\t\tspcid = MyDatabaseTableSpace;\n\n\t/* Find existing cache entry, if any. */\n\tif (!TableSpaceCacheHash)\n\t\tInitializeTableSpaceCache();\n\tspc = (TableSpaceCacheEntry *) hash_search(TableSpaceCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t   (void *) &spcid,\n\t\t\t\t\t\t\t\t\t\t\t   HASH_FIND,\n\t\t\t\t\t\t\t\t\t\t\t   NULL);\n\tif (spc)\n\t\treturn spc;\n\n\t/*\n\t * Not found in TableSpace cache.  Check catcache.  If we don't find a\n\t * valid HeapTuple, it must mean someone has managed to request tablespace\n\t * details for a non-existent tablespace.  We'll just treat that case as\n\t * if no options were specified.\n\t */\n\ttp = SearchSysCache1(TABLESPACEOID, ObjectIdGetDatum(spcid));\n\tif (!HeapTupleIsValid(tp))\n\t\topts = NULL;\n\telse\n\t{\n\t\tDatum\t\tdatum;\n\t\tbool\t\tisNull;\n\n\t\tdatum = SysCacheGetAttr(TABLESPACEOID,\n\t\t\t\t\t\t\t\ttp,\n\t\t\t\t\t\t\t\tAnum_pg_tablespace_spcoptions,\n\t\t\t\t\t\t\t\t&isNull);\n\t\tif (isNull)\n\t\t\topts = NULL;\n\t\telse\n\t\t{\n\t\t\tbytea\t   *bytea_opts = tablespace_reloptions(datum, false);\n\n\t\t\topts = MemoryContextAlloc(CacheMemoryContext, VARSIZE(bytea_opts));\n\t\t\tmemcpy(opts, bytea_opts, VARSIZE(bytea_opts));\n\t\t}\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Now create the cache entry.  It's important to do this only after\n\t * reading the pg_tablespace entry, since doing so could cause a cache\n\t * flush.\n\t */\n\tspc = (TableSpaceCacheEntry *) hash_search(TableSpaceCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t   (void *) &spcid,\n\t\t\t\t\t\t\t\t\t\t\t   HASH_ENTER,\n\t\t\t\t\t\t\t\t\t\t\t   NULL);\n\tspc->opts = opts;\n\treturn spc;\n}"
  },
  {
    "function_name": "InitializeTableSpaceCache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/spccache.c",
    "lines": "76-97",
    "snippet": "static void\nInitializeTableSpaceCache(void)\n{\n\tHASHCTL\t\tctl;\n\n\t/* Initialize the hash table. */\n\tMemSet(&ctl, 0, sizeof(ctl));\n\tctl.keysize = sizeof(Oid);\n\tctl.entrysize = sizeof(TableSpaceCacheEntry);\n\tTableSpaceCacheHash =\n\t\thash_create(\"TableSpace cache\", 16, &ctl,\n\t\t\t\t\tHASH_ELEM | HASH_BLOBS);\n\n\t/* Make sure we've initialized CacheMemoryContext. */\n\tif (!CacheMemoryContext)\n\t\tCreateCacheMemoryContext();\n\n\t/* Watch for invalidation events. */\n\tCacheRegisterSyscacheCallback(TABLESPACEOID,\n\t\t\t\t\t\t\t\t  InvalidateTableSpaceCacheCallback,\n\t\t\t\t\t\t\t\t  (Datum) 0);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static HTAB *TableSpaceCacheHash = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CacheRegisterSyscacheCallback",
          "args": [
            "TABLESPACEOID",
            "InvalidateTableSpaceCacheCallback",
            "(Datum) 0"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "CacheRegisterSyscacheCallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
          "lines": "1425-1456",
          "snippet": "void\nCacheRegisterSyscacheCallback(int cacheid,\n\t\t\t\t\t\t\t  SyscacheCallbackFunction func,\n\t\t\t\t\t\t\t  Datum arg)\n{\n\tif (cacheid < 0 || cacheid >= SysCacheSize)\n\t\telog(FATAL, \"invalid cache ID: %d\", cacheid);\n\tif (syscache_callback_count >= MAX_SYSCACHE_CALLBACKS)\n\t\telog(FATAL, \"out of syscache_callback_list slots\");\n\n\tif (syscache_callback_links[cacheid] == 0)\n\t{\n\t\t/* first callback for this cache */\n\t\tsyscache_callback_links[cacheid] = syscache_callback_count + 1;\n\t}\n\telse\n\t{\n\t\t/* add to end of chain, so that older callbacks are called first */\n\t\tint\t\t\ti = syscache_callback_links[cacheid] - 1;\n\n\t\twhile (syscache_callback_list[i].link > 0)\n\t\t\ti = syscache_callback_list[i].link - 1;\n\t\tsyscache_callback_list[i].link = syscache_callback_count + 1;\n\t}\n\n\tsyscache_callback_list[syscache_callback_count].id = cacheid;\n\tsyscache_callback_list[syscache_callback_count].link = 0;\n\tsyscache_callback_list[syscache_callback_count].function = func;\n\tsyscache_callback_list[syscache_callback_count].arg = arg;\n\n\t++syscache_callback_count;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MAX_SYSCACHE_CALLBACKS 64"
          ],
          "globals_used": [
            "static struct SYSCACHECALLBACK\n{\n\tint16\t\tid;\t\t\t\t/* cache number */\n\tint16\t\tlink;\t\t\t/* next callback index+1 for same cache */\n\tSyscacheCallbackFunction function;\n\tDatum\t\targ;\n}\t\t\tsyscache_callback_list[MAX_SYSCACHE_CALLBACKS];",
            "static int16 syscache_callback_links[SysCacheSize];",
            "static int\tsyscache_callback_count = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define MAX_SYSCACHE_CALLBACKS 64\n\nstatic struct SYSCACHECALLBACK\n{\n\tint16\t\tid;\t\t\t\t/* cache number */\n\tint16\t\tlink;\t\t\t/* next callback index+1 for same cache */\n\tSyscacheCallbackFunction function;\n\tDatum\t\targ;\n}\t\t\tsyscache_callback_list[MAX_SYSCACHE_CALLBACKS];\nstatic int16 syscache_callback_links[SysCacheSize];\nstatic int\tsyscache_callback_count = 0;\n\nvoid\nCacheRegisterSyscacheCallback(int cacheid,\n\t\t\t\t\t\t\t  SyscacheCallbackFunction func,\n\t\t\t\t\t\t\t  Datum arg)\n{\n\tif (cacheid < 0 || cacheid >= SysCacheSize)\n\t\telog(FATAL, \"invalid cache ID: %d\", cacheid);\n\tif (syscache_callback_count >= MAX_SYSCACHE_CALLBACKS)\n\t\telog(FATAL, \"out of syscache_callback_list slots\");\n\n\tif (syscache_callback_links[cacheid] == 0)\n\t{\n\t\t/* first callback for this cache */\n\t\tsyscache_callback_links[cacheid] = syscache_callback_count + 1;\n\t}\n\telse\n\t{\n\t\t/* add to end of chain, so that older callbacks are called first */\n\t\tint\t\t\ti = syscache_callback_links[cacheid] - 1;\n\n\t\twhile (syscache_callback_list[i].link > 0)\n\t\t\ti = syscache_callback_list[i].link - 1;\n\t\tsyscache_callback_list[i].link = syscache_callback_count + 1;\n\t}\n\n\tsyscache_callback_list[syscache_callback_count].id = cacheid;\n\tsyscache_callback_list[syscache_callback_count].link = 0;\n\tsyscache_callback_list[syscache_callback_count].function = func;\n\tsyscache_callback_list[syscache_callback_count].arg = arg;\n\n\t++syscache_callback_count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CreateCacheMemoryContext",
          "args": [],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "CreateCacheMemoryContext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "635-646",
          "snippet": "void\nCreateCacheMemoryContext(void)\n{\n\t/*\n\t * Purely for paranoia, check that context doesn't exist; caller probably\n\t * did so already.\n\t */\n\tif (!CacheMemoryContext)\n\t\tCacheMemoryContext = AllocSetContextCreate(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t   \"CacheMemoryContext\",\n\t\t\t\t\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nvoid\nCreateCacheMemoryContext(void)\n{\n\t/*\n\t * Purely for paranoia, check that context doesn't exist; caller probably\n\t * did so already.\n\t */\n\tif (!CacheMemoryContext)\n\t\tCacheMemoryContext = AllocSetContextCreate(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t   \"CacheMemoryContext\",\n\t\t\t\t\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_create",
          "args": [
            "\"TableSpace cache\"",
            "16",
            "&ctl",
            "HASH_ELEM | HASH_BLOBS"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "hash_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "315-564",
          "snippet": "HTAB *\nhash_create(const char *tabname, long nelem, HASHCTL *info, int flags)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\n\t/*\n\t * For shared hash tables, we have a local hash header (HTAB struct) that\n\t * we allocate in TopMemoryContext; all else is in shared memory.\n\t *\n\t * For non-shared hash tables, everything including the hash header is in\n\t * a memory context created specially for the hash table --- this makes\n\t * hash_destroy very simple.  The memory context is made a child of either\n\t * a context specified by the caller, or TopMemoryContext if nothing is\n\t * specified.\n\t */\n\tif (flags & HASH_SHARED_MEM)\n\t{\n\t\t/* Set up to allocate the hash header */\n\t\tCurrentDynaHashCxt = TopMemoryContext;\n\t}\n\telse\n\t{\n\t\t/* Create the hash table's private memory context */\n\t\tif (flags & HASH_CONTEXT)\n\t\t\tCurrentDynaHashCxt = info->hcxt;\n\t\telse\n\t\t\tCurrentDynaHashCxt = TopMemoryContext;\n\t\tCurrentDynaHashCxt = AllocSetContextCreate(CurrentDynaHashCxt,\n\t\t\t\t\t\t\t\t\t\t\t\t   \"dynahash\",\n\t\t\t\t\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n\t}\n\n\t/* Initialize the hash header, plus a copy of the table name */\n\thashp = (HTAB *) DynaHashAlloc(sizeof(HTAB) + strlen(tabname) + 1);\n\tMemSet(hashp, 0, sizeof(HTAB));\n\n\thashp->tabname = (char *) (hashp + 1);\n\tstrcpy(hashp->tabname, tabname);\n\n\t/* If we have a private context, label it with hashtable's name */\n\tif (!(flags & HASH_SHARED_MEM))\n\t\tMemoryContextSetIdentifier(CurrentDynaHashCxt, hashp->tabname);\n\n\t/*\n\t * Select the appropriate hash function (see comments at head of file).\n\t */\n\tif (flags & HASH_FUNCTION)\n\t\thashp->hash = info->hash;\n\telse if (flags & HASH_BLOBS)\n\t{\n\t\t/* We can optimize hashing for common key sizes */\n\t\tAssert(flags & HASH_ELEM);\n\t\tif (info->keysize == sizeof(uint32))\n\t\t\thashp->hash = uint32_hash;\n\t\telse\n\t\t\thashp->hash = tag_hash;\n\t}\n\telse\n\t\thashp->hash = string_hash;\t/* default hash function */\n\n\t/*\n\t * If you don't specify a match function, it defaults to string_compare if\n\t * you used string_hash (either explicitly or by default) and to memcmp\n\t * otherwise.\n\t *\n\t * Note: explicitly specifying string_hash is deprecated, because this\n\t * might not work for callers in loadable modules on some platforms due to\n\t * referencing a trampoline instead of the string_hash function proper.\n\t * Just let it default, eh?\n\t */\n\tif (flags & HASH_COMPARE)\n\t\thashp->match = info->match;\n\telse if (hashp->hash == string_hash)\n\t\thashp->match = (HashCompareFunc) string_compare;\n\telse\n\t\thashp->match = memcmp;\n\n\t/*\n\t * Similarly, the key-copying function defaults to strlcpy or memcpy.\n\t */\n\tif (flags & HASH_KEYCOPY)\n\t\thashp->keycopy = info->keycopy;\n\telse if (hashp->hash == string_hash)\n\t\thashp->keycopy = (HashCopyFunc) strlcpy;\n\telse\n\t\thashp->keycopy = memcpy;\n\n\t/* And select the entry allocation function, too. */\n\tif (flags & HASH_ALLOC)\n\t\thashp->alloc = info->alloc;\n\telse\n\t\thashp->alloc = DynaHashAlloc;\n\n\tif (flags & HASH_SHARED_MEM)\n\t{\n\t\t/*\n\t\t * ctl structure and directory are preallocated for shared memory\n\t\t * tables.  Note that HASH_DIRSIZE and HASH_ALLOC had better be set as\n\t\t * well.\n\t\t */\n\t\thashp->hctl = info->hctl;\n\t\thashp->dir = (HASHSEGMENT *) (((char *) info->hctl) + sizeof(HASHHDR));\n\t\thashp->hcxt = NULL;\n\t\thashp->isshared = true;\n\n\t\t/* hash table already exists, we're just attaching to it */\n\t\tif (flags & HASH_ATTACH)\n\t\t{\n\t\t\t/* make local copies of some heavily-used values */\n\t\t\thctl = hashp->hctl;\n\t\t\thashp->keysize = hctl->keysize;\n\t\t\thashp->ssize = hctl->ssize;\n\t\t\thashp->sshift = hctl->sshift;\n\n\t\t\treturn hashp;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* setup hash table defaults */\n\t\thashp->hctl = NULL;\n\t\thashp->dir = NULL;\n\t\thashp->hcxt = CurrentDynaHashCxt;\n\t\thashp->isshared = false;\n\t}\n\n\tif (!hashp->hctl)\n\t{\n\t\thashp->hctl = (HASHHDR *) hashp->alloc(sizeof(HASHHDR));\n\t\tif (!hashp->hctl)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t errmsg(\"out of memory\")));\n\t}\n\n\thashp->frozen = false;\n\n\thdefault(hashp);\n\n\thctl = hashp->hctl;\n\n\tif (flags & HASH_PARTITION)\n\t{\n\t\t/* Doesn't make sense to partition a local hash table */\n\t\tAssert(flags & HASH_SHARED_MEM);\n\n\t\t/*\n\t\t * The number of partitions had better be a power of 2. Also, it must\n\t\t * be less than INT_MAX (see init_htab()), so call the int version of\n\t\t * next_pow2.\n\t\t */\n\t\tAssert(info->num_partitions == next_pow2_int(info->num_partitions));\n\n\t\thctl->num_partitions = info->num_partitions;\n\t}\n\n\tif (flags & HASH_SEGMENT)\n\t{\n\t\thctl->ssize = info->ssize;\n\t\thctl->sshift = my_log2(info->ssize);\n\t\t/* ssize had better be a power of 2 */\n\t\tAssert(hctl->ssize == (1L << hctl->sshift));\n\t}\n\tif (flags & HASH_FFACTOR)\n\t\thctl->ffactor = info->ffactor;\n\n\t/*\n\t * SHM hash tables have fixed directory size passed by the caller.\n\t */\n\tif (flags & HASH_DIRSIZE)\n\t{\n\t\thctl->max_dsize = info->max_dsize;\n\t\thctl->dsize = info->dsize;\n\t}\n\n\t/*\n\t * hash table now allocates space for key and data but you have to say how\n\t * much space to allocate\n\t */\n\tif (flags & HASH_ELEM)\n\t{\n\t\tAssert(info->entrysize >= info->keysize);\n\t\thctl->keysize = info->keysize;\n\t\thctl->entrysize = info->entrysize;\n\t}\n\n\t/* make local copies of heavily-used constant fields */\n\thashp->keysize = hctl->keysize;\n\thashp->ssize = hctl->ssize;\n\thashp->sshift = hctl->sshift;\n\n\t/* Build the hash directory structure */\n\tif (!init_htab(hashp, nelem))\n\t\telog(ERROR, \"failed to initialize hash table \\\"%s\\\"\", hashp->tabname);\n\n\t/*\n\t * For a shared hash table, preallocate the requested number of elements.\n\t * This reduces problems with run-time out-of-shared-memory conditions.\n\t *\n\t * For a non-shared hash table, preallocate the requested number of\n\t * elements if it's less than our chosen nelem_alloc.  This avoids wasting\n\t * space if the caller correctly estimates a small table size.\n\t */\n\tif ((flags & HASH_SHARED_MEM) ||\n\t\tnelem < hctl->nelem_alloc)\n\t{\n\t\tint\t\t\ti,\n\t\t\t\t\tfreelist_partitions,\n\t\t\t\t\tnelem_alloc,\n\t\t\t\t\tnelem_alloc_first;\n\n\t\t/*\n\t\t * If hash table is partitioned, give each freelist an equal share of\n\t\t * the initial allocation.  Otherwise only freeList[0] is used.\n\t\t */\n\t\tif (IS_PARTITIONED(hashp->hctl))\n\t\t\tfreelist_partitions = NUM_FREELISTS;\n\t\telse\n\t\t\tfreelist_partitions = 1;\n\n\t\tnelem_alloc = nelem / freelist_partitions;\n\t\tif (nelem_alloc <= 0)\n\t\t\tnelem_alloc = 1;\n\n\t\t/*\n\t\t * Make sure we'll allocate all the requested elements; freeList[0]\n\t\t * gets the excess if the request isn't divisible by NUM_FREELISTS.\n\t\t */\n\t\tif (nelem_alloc * freelist_partitions < nelem)\n\t\t\tnelem_alloc_first =\n\t\t\t\tnelem - nelem_alloc * (freelist_partitions - 1);\n\t\telse\n\t\t\tnelem_alloc_first = nelem_alloc;\n\n\t\tfor (i = 0; i < freelist_partitions; i++)\n\t\t{\n\t\t\tint\t\t\ttemp = (i == 0) ? nelem_alloc_first : nelem_alloc;\n\n\t\t\tif (!element_alloc(hashp, temp, i))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t\t errmsg(\"out of memory\")));\n\t\t}\n\t}\n\n\tif (flags & HASH_FIXED_SIZE)\n\t\thashp->isfixed = true;\n\treturn hashp;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NUM_FREELISTS\t\t\t32"
          ],
          "globals_used": [
            "static void *DynaHashAlloc(Size size);",
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static int\tchoose_nelem_alloc(Size entrysize);",
            "static bool init_htab(HTAB *hashp, long nelem);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);",
            "static MemoryContext CurrentDynaHashCxt = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define NUM_FREELISTS\t\t\t32\n\nstatic void *DynaHashAlloc(Size size);\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic int\tchoose_nelem_alloc(Size entrysize);\nstatic bool init_htab(HTAB *hashp, long nelem);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\nstatic MemoryContext CurrentDynaHashCxt = NULL;\n\nHTAB *\nhash_create(const char *tabname, long nelem, HASHCTL *info, int flags)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\n\t/*\n\t * For shared hash tables, we have a local hash header (HTAB struct) that\n\t * we allocate in TopMemoryContext; all else is in shared memory.\n\t *\n\t * For non-shared hash tables, everything including the hash header is in\n\t * a memory context created specially for the hash table --- this makes\n\t * hash_destroy very simple.  The memory context is made a child of either\n\t * a context specified by the caller, or TopMemoryContext if nothing is\n\t * specified.\n\t */\n\tif (flags & HASH_SHARED_MEM)\n\t{\n\t\t/* Set up to allocate the hash header */\n\t\tCurrentDynaHashCxt = TopMemoryContext;\n\t}\n\telse\n\t{\n\t\t/* Create the hash table's private memory context */\n\t\tif (flags & HASH_CONTEXT)\n\t\t\tCurrentDynaHashCxt = info->hcxt;\n\t\telse\n\t\t\tCurrentDynaHashCxt = TopMemoryContext;\n\t\tCurrentDynaHashCxt = AllocSetContextCreate(CurrentDynaHashCxt,\n\t\t\t\t\t\t\t\t\t\t\t\t   \"dynahash\",\n\t\t\t\t\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n\t}\n\n\t/* Initialize the hash header, plus a copy of the table name */\n\thashp = (HTAB *) DynaHashAlloc(sizeof(HTAB) + strlen(tabname) + 1);\n\tMemSet(hashp, 0, sizeof(HTAB));\n\n\thashp->tabname = (char *) (hashp + 1);\n\tstrcpy(hashp->tabname, tabname);\n\n\t/* If we have a private context, label it with hashtable's name */\n\tif (!(flags & HASH_SHARED_MEM))\n\t\tMemoryContextSetIdentifier(CurrentDynaHashCxt, hashp->tabname);\n\n\t/*\n\t * Select the appropriate hash function (see comments at head of file).\n\t */\n\tif (flags & HASH_FUNCTION)\n\t\thashp->hash = info->hash;\n\telse if (flags & HASH_BLOBS)\n\t{\n\t\t/* We can optimize hashing for common key sizes */\n\t\tAssert(flags & HASH_ELEM);\n\t\tif (info->keysize == sizeof(uint32))\n\t\t\thashp->hash = uint32_hash;\n\t\telse\n\t\t\thashp->hash = tag_hash;\n\t}\n\telse\n\t\thashp->hash = string_hash;\t/* default hash function */\n\n\t/*\n\t * If you don't specify a match function, it defaults to string_compare if\n\t * you used string_hash (either explicitly or by default) and to memcmp\n\t * otherwise.\n\t *\n\t * Note: explicitly specifying string_hash is deprecated, because this\n\t * might not work for callers in loadable modules on some platforms due to\n\t * referencing a trampoline instead of the string_hash function proper.\n\t * Just let it default, eh?\n\t */\n\tif (flags & HASH_COMPARE)\n\t\thashp->match = info->match;\n\telse if (hashp->hash == string_hash)\n\t\thashp->match = (HashCompareFunc) string_compare;\n\telse\n\t\thashp->match = memcmp;\n\n\t/*\n\t * Similarly, the key-copying function defaults to strlcpy or memcpy.\n\t */\n\tif (flags & HASH_KEYCOPY)\n\t\thashp->keycopy = info->keycopy;\n\telse if (hashp->hash == string_hash)\n\t\thashp->keycopy = (HashCopyFunc) strlcpy;\n\telse\n\t\thashp->keycopy = memcpy;\n\n\t/* And select the entry allocation function, too. */\n\tif (flags & HASH_ALLOC)\n\t\thashp->alloc = info->alloc;\n\telse\n\t\thashp->alloc = DynaHashAlloc;\n\n\tif (flags & HASH_SHARED_MEM)\n\t{\n\t\t/*\n\t\t * ctl structure and directory are preallocated for shared memory\n\t\t * tables.  Note that HASH_DIRSIZE and HASH_ALLOC had better be set as\n\t\t * well.\n\t\t */\n\t\thashp->hctl = info->hctl;\n\t\thashp->dir = (HASHSEGMENT *) (((char *) info->hctl) + sizeof(HASHHDR));\n\t\thashp->hcxt = NULL;\n\t\thashp->isshared = true;\n\n\t\t/* hash table already exists, we're just attaching to it */\n\t\tif (flags & HASH_ATTACH)\n\t\t{\n\t\t\t/* make local copies of some heavily-used values */\n\t\t\thctl = hashp->hctl;\n\t\t\thashp->keysize = hctl->keysize;\n\t\t\thashp->ssize = hctl->ssize;\n\t\t\thashp->sshift = hctl->sshift;\n\n\t\t\treturn hashp;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* setup hash table defaults */\n\t\thashp->hctl = NULL;\n\t\thashp->dir = NULL;\n\t\thashp->hcxt = CurrentDynaHashCxt;\n\t\thashp->isshared = false;\n\t}\n\n\tif (!hashp->hctl)\n\t{\n\t\thashp->hctl = (HASHHDR *) hashp->alloc(sizeof(HASHHDR));\n\t\tif (!hashp->hctl)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t errmsg(\"out of memory\")));\n\t}\n\n\thashp->frozen = false;\n\n\thdefault(hashp);\n\n\thctl = hashp->hctl;\n\n\tif (flags & HASH_PARTITION)\n\t{\n\t\t/* Doesn't make sense to partition a local hash table */\n\t\tAssert(flags & HASH_SHARED_MEM);\n\n\t\t/*\n\t\t * The number of partitions had better be a power of 2. Also, it must\n\t\t * be less than INT_MAX (see init_htab()), so call the int version of\n\t\t * next_pow2.\n\t\t */\n\t\tAssert(info->num_partitions == next_pow2_int(info->num_partitions));\n\n\t\thctl->num_partitions = info->num_partitions;\n\t}\n\n\tif (flags & HASH_SEGMENT)\n\t{\n\t\thctl->ssize = info->ssize;\n\t\thctl->sshift = my_log2(info->ssize);\n\t\t/* ssize had better be a power of 2 */\n\t\tAssert(hctl->ssize == (1L << hctl->sshift));\n\t}\n\tif (flags & HASH_FFACTOR)\n\t\thctl->ffactor = info->ffactor;\n\n\t/*\n\t * SHM hash tables have fixed directory size passed by the caller.\n\t */\n\tif (flags & HASH_DIRSIZE)\n\t{\n\t\thctl->max_dsize = info->max_dsize;\n\t\thctl->dsize = info->dsize;\n\t}\n\n\t/*\n\t * hash table now allocates space for key and data but you have to say how\n\t * much space to allocate\n\t */\n\tif (flags & HASH_ELEM)\n\t{\n\t\tAssert(info->entrysize >= info->keysize);\n\t\thctl->keysize = info->keysize;\n\t\thctl->entrysize = info->entrysize;\n\t}\n\n\t/* make local copies of heavily-used constant fields */\n\thashp->keysize = hctl->keysize;\n\thashp->ssize = hctl->ssize;\n\thashp->sshift = hctl->sshift;\n\n\t/* Build the hash directory structure */\n\tif (!init_htab(hashp, nelem))\n\t\telog(ERROR, \"failed to initialize hash table \\\"%s\\\"\", hashp->tabname);\n\n\t/*\n\t * For a shared hash table, preallocate the requested number of elements.\n\t * This reduces problems with run-time out-of-shared-memory conditions.\n\t *\n\t * For a non-shared hash table, preallocate the requested number of\n\t * elements if it's less than our chosen nelem_alloc.  This avoids wasting\n\t * space if the caller correctly estimates a small table size.\n\t */\n\tif ((flags & HASH_SHARED_MEM) ||\n\t\tnelem < hctl->nelem_alloc)\n\t{\n\t\tint\t\t\ti,\n\t\t\t\t\tfreelist_partitions,\n\t\t\t\t\tnelem_alloc,\n\t\t\t\t\tnelem_alloc_first;\n\n\t\t/*\n\t\t * If hash table is partitioned, give each freelist an equal share of\n\t\t * the initial allocation.  Otherwise only freeList[0] is used.\n\t\t */\n\t\tif (IS_PARTITIONED(hashp->hctl))\n\t\t\tfreelist_partitions = NUM_FREELISTS;\n\t\telse\n\t\t\tfreelist_partitions = 1;\n\n\t\tnelem_alloc = nelem / freelist_partitions;\n\t\tif (nelem_alloc <= 0)\n\t\t\tnelem_alloc = 1;\n\n\t\t/*\n\t\t * Make sure we'll allocate all the requested elements; freeList[0]\n\t\t * gets the excess if the request isn't divisible by NUM_FREELISTS.\n\t\t */\n\t\tif (nelem_alloc * freelist_partitions < nelem)\n\t\t\tnelem_alloc_first =\n\t\t\t\tnelem - nelem_alloc * (freelist_partitions - 1);\n\t\telse\n\t\t\tnelem_alloc_first = nelem_alloc;\n\n\t\tfor (i = 0; i < freelist_partitions; i++)\n\t\t{\n\t\t\tint\t\t\ttemp = (i == 0) ? nelem_alloc_first : nelem_alloc;\n\n\t\t\tif (!element_alloc(hashp, temp, i))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t\t errmsg(\"out of memory\")));\n\t\t}\n\t}\n\n\tif (flags & HASH_FIXED_SIZE)\n\t\thashp->isfixed = true;\n\treturn hashp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemSet",
          "args": [
            "&ctl",
            "0",
            "sizeof(ctl)"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/inval.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/catcache.h\"\n#include \"storage/bufmgr.h\"\n#include \"optimizer/cost.h\"\n#include \"miscadmin.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"access/reloptions.h\"\n#include \"postgres.h\"\n\nstatic HTAB *TableSpaceCacheHash = NULL;\n\nstatic void\nInitializeTableSpaceCache(void)\n{\n\tHASHCTL\t\tctl;\n\n\t/* Initialize the hash table. */\n\tMemSet(&ctl, 0, sizeof(ctl));\n\tctl.keysize = sizeof(Oid);\n\tctl.entrysize = sizeof(TableSpaceCacheEntry);\n\tTableSpaceCacheHash =\n\t\thash_create(\"TableSpace cache\", 16, &ctl,\n\t\t\t\t\tHASH_ELEM | HASH_BLOBS);\n\n\t/* Make sure we've initialized CacheMemoryContext. */\n\tif (!CacheMemoryContext)\n\t\tCreateCacheMemoryContext();\n\n\t/* Watch for invalidation events. */\n\tCacheRegisterSyscacheCallback(TABLESPACEOID,\n\t\t\t\t\t\t\t\t  InvalidateTableSpaceCacheCallback,\n\t\t\t\t\t\t\t\t  (Datum) 0);\n}"
  },
  {
    "function_name": "InvalidateTableSpaceCacheCallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/spccache.c",
    "lines": "53-70",
    "snippet": "static void\nInvalidateTableSpaceCacheCallback(Datum arg, int cacheid, uint32 hashvalue)\n{\n\tHASH_SEQ_STATUS status;\n\tTableSpaceCacheEntry *spc;\n\n\thash_seq_init(&status, TableSpaceCacheHash);\n\twhile ((spc = (TableSpaceCacheEntry *) hash_seq_search(&status)) != NULL)\n\t{\n\t\tif (spc->opts)\n\t\t\tpfree(spc->opts);\n\t\tif (hash_search(TableSpaceCacheHash,\n\t\t\t\t\t\t(void *) &spc->oid,\n\t\t\t\t\t\tHASH_REMOVE,\n\t\t\t\t\t\tNULL) == NULL)\n\t\t\telog(ERROR, \"hash table corrupted\");\n\t}\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static HTAB *TableSpaceCacheHash = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"hash table corrupted\""
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_search",
          "args": [
            "TableSpaceCacheHash",
            "(void *) &spc->oid",
            "HASH_REMOVE",
            "NULL"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "hash_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "905-916",
          "snippet": "void *\nhash_search(HTAB *hashp,\n\t\t\tconst void *keyPtr,\n\t\t\tHASHACTION action,\n\t\t\tbool *foundPtr)\n{\n\treturn hash_search_with_hash_value(hashp,\n\t\t\t\t\t\t\t\t\t   keyPtr,\n\t\t\t\t\t\t\t\t\t   hashp->hash(keyPtr, hashp->keysize),\n\t\t\t\t\t\t\t\t\t   action,\n\t\t\t\t\t\t\t\t\t   foundPtr);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid *\nhash_search(HTAB *hashp,\n\t\t\tconst void *keyPtr,\n\t\t\tHASHACTION action,\n\t\t\tbool *foundPtr)\n{\n\treturn hash_search_with_hash_value(hashp,\n\t\t\t\t\t\t\t\t\t   keyPtr,\n\t\t\t\t\t\t\t\t\t   hashp->hash(keyPtr, hashp->keysize),\n\t\t\t\t\t\t\t\t\t   action,\n\t\t\t\t\t\t\t\t\t   foundPtr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "spc->opts"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_seq_search",
          "args": [
            "&status"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "hash_seq_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "1388-1462",
          "snippet": "void *\nhash_seq_search(HASH_SEQ_STATUS *status)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\tuint32\t\tmax_bucket;\n\tlong\t\tssize;\n\tlong\t\tsegment_num;\n\tlong\t\tsegment_ndx;\n\tHASHSEGMENT segp;\n\tuint32\t\tcurBucket;\n\tHASHELEMENT *curElem;\n\n\tif ((curElem = status->curEntry) != NULL)\n\t{\n\t\t/* Continuing scan of curBucket... */\n\t\tstatus->curEntry = curElem->link;\n\t\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t\t++status->curBucket;\n\t\treturn (void *) ELEMENTKEY(curElem);\n\t}\n\n\t/*\n\t * Search for next nonempty bucket starting at curBucket.\n\t */\n\tcurBucket = status->curBucket;\n\thashp = status->hashp;\n\thctl = hashp->hctl;\n\tssize = hashp->ssize;\n\tmax_bucket = hctl->max_bucket;\n\n\tif (curBucket > max_bucket)\n\t{\n\t\thash_seq_term(status);\n\t\treturn NULL;\t\t\t/* search is done */\n\t}\n\n\t/*\n\t * first find the right segment in the table directory.\n\t */\n\tsegment_num = curBucket >> hashp->sshift;\n\tsegment_ndx = MOD(curBucket, ssize);\n\n\tsegp = hashp->dir[segment_num];\n\n\t/*\n\t * Pick up the first item in this bucket's chain.  If chain is not empty\n\t * we can begin searching it.  Otherwise we have to advance to find the\n\t * next nonempty bucket.  We try to optimize that case since searching a\n\t * near-empty hashtable has to iterate this loop a lot.\n\t */\n\twhile ((curElem = segp[segment_ndx]) == NULL)\n\t{\n\t\t/* empty bucket, advance to next */\n\t\tif (++curBucket > max_bucket)\n\t\t{\n\t\t\tstatus->curBucket = curBucket;\n\t\t\thash_seq_term(status);\n\t\t\treturn NULL;\t\t/* search is done */\n\t\t}\n\t\tif (++segment_ndx >= ssize)\n\t\t{\n\t\t\tsegment_num++;\n\t\t\tsegment_ndx = 0;\n\t\t\tsegp = hashp->dir[segment_num];\n\t\t}\n\t}\n\n\t/* Begin scan of curBucket... */\n\tstatus->curEntry = curElem->link;\n\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t++curBucket;\n\tstatus->curBucket = curBucket;\n\treturn (void *) ELEMENTKEY(curElem);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid *\nhash_seq_search(HASH_SEQ_STATUS *status)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\tuint32\t\tmax_bucket;\n\tlong\t\tssize;\n\tlong\t\tsegment_num;\n\tlong\t\tsegment_ndx;\n\tHASHSEGMENT segp;\n\tuint32\t\tcurBucket;\n\tHASHELEMENT *curElem;\n\n\tif ((curElem = status->curEntry) != NULL)\n\t{\n\t\t/* Continuing scan of curBucket... */\n\t\tstatus->curEntry = curElem->link;\n\t\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t\t++status->curBucket;\n\t\treturn (void *) ELEMENTKEY(curElem);\n\t}\n\n\t/*\n\t * Search for next nonempty bucket starting at curBucket.\n\t */\n\tcurBucket = status->curBucket;\n\thashp = status->hashp;\n\thctl = hashp->hctl;\n\tssize = hashp->ssize;\n\tmax_bucket = hctl->max_bucket;\n\n\tif (curBucket > max_bucket)\n\t{\n\t\thash_seq_term(status);\n\t\treturn NULL;\t\t\t/* search is done */\n\t}\n\n\t/*\n\t * first find the right segment in the table directory.\n\t */\n\tsegment_num = curBucket >> hashp->sshift;\n\tsegment_ndx = MOD(curBucket, ssize);\n\n\tsegp = hashp->dir[segment_num];\n\n\t/*\n\t * Pick up the first item in this bucket's chain.  If chain is not empty\n\t * we can begin searching it.  Otherwise we have to advance to find the\n\t * next nonempty bucket.  We try to optimize that case since searching a\n\t * near-empty hashtable has to iterate this loop a lot.\n\t */\n\twhile ((curElem = segp[segment_ndx]) == NULL)\n\t{\n\t\t/* empty bucket, advance to next */\n\t\tif (++curBucket > max_bucket)\n\t\t{\n\t\t\tstatus->curBucket = curBucket;\n\t\t\thash_seq_term(status);\n\t\t\treturn NULL;\t\t/* search is done */\n\t\t}\n\t\tif (++segment_ndx >= ssize)\n\t\t{\n\t\t\tsegment_num++;\n\t\t\tsegment_ndx = 0;\n\t\t\tsegp = hashp->dir[segment_num];\n\t\t}\n\t}\n\n\t/* Begin scan of curBucket... */\n\tstatus->curEntry = curElem->link;\n\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t++curBucket;\n\tstatus->curBucket = curBucket;\n\treturn (void *) ELEMENTKEY(curElem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_seq_init",
          "args": [
            "&status",
            "TableSpaceCacheHash"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "hash_seq_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "1378-1386",
          "snippet": "void\nhash_seq_init(HASH_SEQ_STATUS *status, HTAB *hashp)\n{\n\tstatus->hashp = hashp;\n\tstatus->curBucket = 0;\n\tstatus->curEntry = NULL;\n\tif (!hashp->frozen)\n\t\tregister_seq_scan(hashp);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid\nhash_seq_init(HASH_SEQ_STATUS *status, HTAB *hashp)\n{\n\tstatus->hashp = hashp;\n\tstatus->curBucket = 0;\n\tstatus->curEntry = NULL;\n\tif (!hashp->frozen)\n\t\tregister_seq_scan(hashp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/inval.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/catcache.h\"\n#include \"storage/bufmgr.h\"\n#include \"optimizer/cost.h\"\n#include \"miscadmin.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"access/reloptions.h\"\n#include \"postgres.h\"\n\nstatic HTAB *TableSpaceCacheHash = NULL;\n\nstatic void\nInvalidateTableSpaceCacheCallback(Datum arg, int cacheid, uint32 hashvalue)\n{\n\tHASH_SEQ_STATUS status;\n\tTableSpaceCacheEntry *spc;\n\n\thash_seq_init(&status, TableSpaceCacheHash);\n\twhile ((spc = (TableSpaceCacheEntry *) hash_seq_search(&status)) != NULL)\n\t{\n\t\tif (spc->opts)\n\t\t\tpfree(spc->opts);\n\t\tif (hash_search(TableSpaceCacheHash,\n\t\t\t\t\t\t(void *) &spc->oid,\n\t\t\t\t\t\tHASH_REMOVE,\n\t\t\t\t\t\tNULL) == NULL)\n\t\t\telog(ERROR, \"hash table corrupted\");\n\t}\n}"
  }
]