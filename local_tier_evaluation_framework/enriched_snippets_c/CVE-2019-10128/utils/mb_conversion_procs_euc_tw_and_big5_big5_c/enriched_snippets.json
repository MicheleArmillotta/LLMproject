[
  {
    "function_name": "CNStoBIG5",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/conversion_procs/euc_tw_and_big5/big5.c",
    "lines": "344-377",
    "snippet": "unsigned short\nCNStoBIG5(unsigned short cns, unsigned char lc)\n{\n\tint\t\t\ti;\n\tunsigned int big5 = 0;\n\n\tcns &= 0x7f7f;\n\n\tswitch (lc)\n\t{\n\t\tcase LC_CNS11643_1:\n\t\t\tbig5 = BinarySearchRange(cnsPlane1ToBig5Level1, 24, cns);\n\t\t\tbreak;\n\t\tcase LC_CNS11643_2:\n\t\t\tbig5 = BinarySearchRange(cnsPlane2ToBig5Level2, 47, cns);\n\t\t\tbreak;\n\t\tcase LC_CNS11643_3:\n\t\t\tfor (i = 0; i < sizeof(b2c3) / (sizeof(unsigned short) * 2); i++)\n\t\t\t{\n\t\t\t\tif (b2c3[i][1] == cns)\n\t\t\t\t\treturn b2c3[i][0];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_CNS11643_4:\n\t\t\tfor (i = 0; i < sizeof(b1c4) / (sizeof(unsigned short) * 2); i++)\n\t\t\t{\n\t\t\t\tif (b1c4[i][1] == cns)\n\t\t\t\t\treturn b1c4[i][0];\n\t\t\t}\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\treturn big5;\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"postgres_fe.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const codes_t cnsPlane1ToBig5Level1[26] = {\t/* range */\n\t{0x2121, 0xA140},\n\t{0x2257, 0xA1F7},\n\t{0x2258, 0xA1F6},\n\t{0x2259, 0xA1F8},\n\t{0x234f, 0x0000},\n\t{0x2421, 0xA2AF},\n\t{0x2571, 0x0000},\n\t{0x4221, 0xA3C0},\n\t{0x4242, 0x0000},\n\t{0x4421, 0xA440},\n\t{0x5323, 0xAD40},\n\t{0x5753, 0xACFE},\n\t{0x5754, 0xAFD0},\n\t{0x6B50, 0xBE52},\n\t{0x6B51, 0xBBC8},\n\t{0x6F5C, 0xBE53},\n\t{0x7535, 0xC2CB},\n\t{0x7536, 0xC1AB},\n\t{0x7737, 0xC2CC},\n\t{0x782D, 0xC456},\n\t{0x782E, 0xC361},\n\t{0x7864, 0xC3BA},\n\t{0x7865, 0xC3B9},\n\t{0x7866, 0xC3BB},\n\t{0x7962, 0xC457},\n\t{0x7d4c, 0x0000}\n};",
      "static const codes_t cnsPlane2ToBig5Level2[49] = {\t/* range */\n\t{0x2121, 0xC940},\n\t{0x212B, 0xC94B},\n\t{0x214C, 0xC9BE},\n\t{0x214D, 0xC96C},\n\t{0x217D, 0xC9BF},\n\t{0x224D, 0xCAF7},\n\t{0x224E, 0xC9ED},\n\t{0x2439, 0xCAF8},\n\t{0x387E, 0xD77B},\n\t{0x3F6A, 0xD77A},\n\t{0x3F6B, 0xDBA7},\n\t{0x4424, 0x0000},\n\t{0x4176, 0xDDFC},\n\t{0x4177, 0x0000},\n\t{0x4424, 0xDDFD},\n\t{0x554B, 0xEBF1},\n\t{0x554C, 0xE8A3},\n\t{0x5722, 0xECDE},\n\t{0x5723, 0xE976},\n\t{0x5A28, 0xF0CB},\n\t{0x5A29, 0xEB5B},\n\t{0x5B3F, 0xEBF2},\n\t{0x5C6A, 0xECDF},\n\t{0x5D74, 0xF056},\n\t{0x5D75, 0xEDAA},\n\t{0x6039, 0xEEEC},\n\t{0x6243, 0xF057},\n\t{0x6337, 0xF0CC},\n\t{0x642F, 0xEEEB},\n\t{0x6430, 0xF163},\n\t{0x6438, 0xF16C},\n\t{0x6573, 0xF269},\n\t{0x664D, 0xF4B5},\n\t{0x664E, 0xF2C3},\n\t{0x6761, 0xF16B},\n\t{0x6762, 0xF375},\n\t{0x6934, 0xF268},\n\t{0x6935, 0xF466},\n\t{0x6962, 0xF4B6},\n\t{0x6A4B, 0xF663},\n\t{0x6A4C, 0xF4FD},\n\t{0x6C52, 0xF664},\n\t{0x7166, 0xF9C4},\n\t{0x7167, 0xF977},\n\t{0x7234, 0xF9C5},\n\t{0x7235, 0xF9C7},\n\t{0x7240, 0xF9C6},\n\t{0x7241, 0xF9D2},\n\t{0x7245, 0x0000}\n};",
      "static const unsigned short b1c4[][2] = {\n\t{0xC879, 0x2123},\n\t{0xC87B, 0x2124},\n\t{0xC87D, 0x212A},\n\t{0xC8A2, 0x2152}\n};",
      "static const unsigned short b2c3[][2] = {\n\t{0xF9D6, 0x4337},\n\t{0xF9D7, 0x4F50},\n\t{0xF9D8, 0x444E},\n\t{0xF9D9, 0x504A},\n\t{0xF9DA, 0x2C5D},\n\t{0xF9DB, 0x3D7E},\n\t{0xF9DC, 0x4B5C}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BinarySearchRange",
          "args": [
            "cnsPlane2ToBig5Level2",
            "47",
            "cns"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "BinarySearchRange",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/conversion_procs/euc_tw_and_big5/big5.c",
          "lines": "207-288",
          "snippet": "static unsigned short BinarySearchRange\n\t\t\t(const codes_t *array, int high, unsigned short code)\n{\n\tint\t\t\tlow,\n\t\t\t\tmid,\n\t\t\t\tdistance,\n\t\t\t\ttmp;\n\n\tlow = 0;\n\tmid = high >> 1;\n\n\tfor (; low <= high; mid = (low + high) >> 1)\n\t{\n\t\tif ((array[mid].code <= code) && (array[mid + 1].code > code))\n\t\t{\n\t\t\tif (0 == array[mid].peer)\n\t\t\t\treturn 0;\n\t\t\tif (code >= 0xa140U)\n\t\t\t{\n\t\t\t\t/* big5 to cns */\n\t\t\t\ttmp = ((code & 0xff00) - (array[mid].code & 0xff00)) >> 8;\n\t\t\t\thigh = code & 0x00ff;\n\t\t\t\tlow = array[mid].code & 0x00ff;\n\n\t\t\t\t/*\n\t\t\t\t * NOTE: big5 high_byte: 0xa1-0xfe, low_byte: 0x40-0x7e,\n\t\t\t\t * 0xa1-0xfe (radicals: 0x00-0x3e, 0x3f-0x9c) big5 radix is\n\t\t\t\t * 0x9d.                     [region_low, region_high] We\n\t\t\t\t * should remember big5 has two different regions (above).\n\t\t\t\t * There is a bias for the distance between these regions.\n\t\t\t\t * 0xa1 - 0x7e + bias = 1 (Distance between 0xa1 and 0x7e is\n\t\t\t\t * 1.) bias = - 0x22.\n\t\t\t\t */\n\t\t\t\tdistance = tmp * 0x9d + high - low +\n\t\t\t\t\t(high >= 0xa1 ? (low >= 0xa1 ? 0 : -0x22)\n\t\t\t\t\t : (low >= 0xa1 ? +0x22 : 0));\n\n\t\t\t\t/*\n\t\t\t\t * NOTE: we have to convert the distance into a code point.\n\t\t\t\t * The code point's low_byte is 0x21 plus mod_0x5e. In the\n\t\t\t\t * first, we extract the mod_0x5e of the starting code point,\n\t\t\t\t * subtracting 0x21, and add distance to it. Then we calculate\n\t\t\t\t * again mod_0x5e of them, and restore the final codepoint,\n\t\t\t\t * adding 0x21.\n\t\t\t\t */\n\t\t\t\ttmp = (array[mid].peer & 0x00ff) + distance - 0x21;\n\t\t\t\ttmp = (array[mid].peer & 0xff00) + ((tmp / 0x5e) << 8)\n\t\t\t\t\t+ 0x21 + tmp % 0x5e;\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* cns to big5 */\n\t\t\t\ttmp = ((code & 0xff00) - (array[mid].code & 0xff00)) >> 8;\n\n\t\t\t\t/*\n\t\t\t\t * NOTE: ISO charsets ranges between 0x21-0xfe (94charset).\n\t\t\t\t * Its radix is 0x5e. But there is no distance bias like big5.\n\t\t\t\t */\n\t\t\t\tdistance = tmp * 0x5e\n\t\t\t\t\t+ ((int) (code & 0x00ff) - (int) (array[mid].code & 0x00ff));\n\n\t\t\t\t/*\n\t\t\t\t * NOTE: Similar to big5 to cns conversion, we extract\n\t\t\t\t * mod_0x9d and restore mod_0x9d into a code point.\n\t\t\t\t */\n\t\t\t\tlow = array[mid].peer & 0x00ff;\n\t\t\t\ttmp = low + distance - (low >= 0xa1 ? 0x62 : 0x40);\n\t\t\t\tlow = tmp % 0x9d;\n\t\t\t\ttmp = (array[mid].peer & 0xff00) + ((tmp / 0x9d) << 8)\n\t\t\t\t\t+ (low > 0x3e ? 0x62 : 0x40) + low;\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t}\n\t\telse if (array[mid].code > code)\n\t\t\thigh = mid - 1;\n\t\telse\n\t\t\tlow = mid + 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres_fe.h\"\n\nstatic unsigned short BinarySearchRange\n\t\t\t(const codes_t *array, int high, unsigned short code)\n{\n\tint\t\t\tlow,\n\t\t\t\tmid,\n\t\t\t\tdistance,\n\t\t\t\ttmp;\n\n\tlow = 0;\n\tmid = high >> 1;\n\n\tfor (; low <= high; mid = (low + high) >> 1)\n\t{\n\t\tif ((array[mid].code <= code) && (array[mid + 1].code > code))\n\t\t{\n\t\t\tif (0 == array[mid].peer)\n\t\t\t\treturn 0;\n\t\t\tif (code >= 0xa140U)\n\t\t\t{\n\t\t\t\t/* big5 to cns */\n\t\t\t\ttmp = ((code & 0xff00) - (array[mid].code & 0xff00)) >> 8;\n\t\t\t\thigh = code & 0x00ff;\n\t\t\t\tlow = array[mid].code & 0x00ff;\n\n\t\t\t\t/*\n\t\t\t\t * NOTE: big5 high_byte: 0xa1-0xfe, low_byte: 0x40-0x7e,\n\t\t\t\t * 0xa1-0xfe (radicals: 0x00-0x3e, 0x3f-0x9c) big5 radix is\n\t\t\t\t * 0x9d.                     [region_low, region_high] We\n\t\t\t\t * should remember big5 has two different regions (above).\n\t\t\t\t * There is a bias for the distance between these regions.\n\t\t\t\t * 0xa1 - 0x7e + bias = 1 (Distance between 0xa1 and 0x7e is\n\t\t\t\t * 1.) bias = - 0x22.\n\t\t\t\t */\n\t\t\t\tdistance = tmp * 0x9d + high - low +\n\t\t\t\t\t(high >= 0xa1 ? (low >= 0xa1 ? 0 : -0x22)\n\t\t\t\t\t : (low >= 0xa1 ? +0x22 : 0));\n\n\t\t\t\t/*\n\t\t\t\t * NOTE: we have to convert the distance into a code point.\n\t\t\t\t * The code point's low_byte is 0x21 plus mod_0x5e. In the\n\t\t\t\t * first, we extract the mod_0x5e of the starting code point,\n\t\t\t\t * subtracting 0x21, and add distance to it. Then we calculate\n\t\t\t\t * again mod_0x5e of them, and restore the final codepoint,\n\t\t\t\t * adding 0x21.\n\t\t\t\t */\n\t\t\t\ttmp = (array[mid].peer & 0x00ff) + distance - 0x21;\n\t\t\t\ttmp = (array[mid].peer & 0xff00) + ((tmp / 0x5e) << 8)\n\t\t\t\t\t+ 0x21 + tmp % 0x5e;\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* cns to big5 */\n\t\t\t\ttmp = ((code & 0xff00) - (array[mid].code & 0xff00)) >> 8;\n\n\t\t\t\t/*\n\t\t\t\t * NOTE: ISO charsets ranges between 0x21-0xfe (94charset).\n\t\t\t\t * Its radix is 0x5e. But there is no distance bias like big5.\n\t\t\t\t */\n\t\t\t\tdistance = tmp * 0x5e\n\t\t\t\t\t+ ((int) (code & 0x00ff) - (int) (array[mid].code & 0x00ff));\n\n\t\t\t\t/*\n\t\t\t\t * NOTE: Similar to big5 to cns conversion, we extract\n\t\t\t\t * mod_0x9d and restore mod_0x9d into a code point.\n\t\t\t\t */\n\t\t\t\tlow = array[mid].peer & 0x00ff;\n\t\t\t\ttmp = low + distance - (low >= 0xa1 ? 0x62 : 0x40);\n\t\t\t\tlow = tmp % 0x9d;\n\t\t\t\ttmp = (array[mid].peer & 0xff00) + ((tmp / 0x9d) << 8)\n\t\t\t\t\t+ (low > 0x3e ? 0x62 : 0x40) + low;\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t}\n\t\telse if (array[mid].code > code)\n\t\t\thigh = mid - 1;\n\t\telse\n\t\t\tlow = mid + 1;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres_fe.h\"\n\nstatic const codes_t cnsPlane1ToBig5Level1[26] = {\t/* range */\n\t{0x2121, 0xA140},\n\t{0x2257, 0xA1F7},\n\t{0x2258, 0xA1F6},\n\t{0x2259, 0xA1F8},\n\t{0x234f, 0x0000},\n\t{0x2421, 0xA2AF},\n\t{0x2571, 0x0000},\n\t{0x4221, 0xA3C0},\n\t{0x4242, 0x0000},\n\t{0x4421, 0xA440},\n\t{0x5323, 0xAD40},\n\t{0x5753, 0xACFE},\n\t{0x5754, 0xAFD0},\n\t{0x6B50, 0xBE52},\n\t{0x6B51, 0xBBC8},\n\t{0x6F5C, 0xBE53},\n\t{0x7535, 0xC2CB},\n\t{0x7536, 0xC1AB},\n\t{0x7737, 0xC2CC},\n\t{0x782D, 0xC456},\n\t{0x782E, 0xC361},\n\t{0x7864, 0xC3BA},\n\t{0x7865, 0xC3B9},\n\t{0x7866, 0xC3BB},\n\t{0x7962, 0xC457},\n\t{0x7d4c, 0x0000}\n};\nstatic const codes_t cnsPlane2ToBig5Level2[49] = {\t/* range */\n\t{0x2121, 0xC940},\n\t{0x212B, 0xC94B},\n\t{0x214C, 0xC9BE},\n\t{0x214D, 0xC96C},\n\t{0x217D, 0xC9BF},\n\t{0x224D, 0xCAF7},\n\t{0x224E, 0xC9ED},\n\t{0x2439, 0xCAF8},\n\t{0x387E, 0xD77B},\n\t{0x3F6A, 0xD77A},\n\t{0x3F6B, 0xDBA7},\n\t{0x4424, 0x0000},\n\t{0x4176, 0xDDFC},\n\t{0x4177, 0x0000},\n\t{0x4424, 0xDDFD},\n\t{0x554B, 0xEBF1},\n\t{0x554C, 0xE8A3},\n\t{0x5722, 0xECDE},\n\t{0x5723, 0xE976},\n\t{0x5A28, 0xF0CB},\n\t{0x5A29, 0xEB5B},\n\t{0x5B3F, 0xEBF2},\n\t{0x5C6A, 0xECDF},\n\t{0x5D74, 0xF056},\n\t{0x5D75, 0xEDAA},\n\t{0x6039, 0xEEEC},\n\t{0x6243, 0xF057},\n\t{0x6337, 0xF0CC},\n\t{0x642F, 0xEEEB},\n\t{0x6430, 0xF163},\n\t{0x6438, 0xF16C},\n\t{0x6573, 0xF269},\n\t{0x664D, 0xF4B5},\n\t{0x664E, 0xF2C3},\n\t{0x6761, 0xF16B},\n\t{0x6762, 0xF375},\n\t{0x6934, 0xF268},\n\t{0x6935, 0xF466},\n\t{0x6962, 0xF4B6},\n\t{0x6A4B, 0xF663},\n\t{0x6A4C, 0xF4FD},\n\t{0x6C52, 0xF664},\n\t{0x7166, 0xF9C4},\n\t{0x7167, 0xF977},\n\t{0x7234, 0xF9C5},\n\t{0x7235, 0xF9C7},\n\t{0x7240, 0xF9C6},\n\t{0x7241, 0xF9D2},\n\t{0x7245, 0x0000}\n};\nstatic const unsigned short b1c4[][2] = {\n\t{0xC879, 0x2123},\n\t{0xC87B, 0x2124},\n\t{0xC87D, 0x212A},\n\t{0xC8A2, 0x2152}\n};\nstatic const unsigned short b2c3[][2] = {\n\t{0xF9D6, 0x4337},\n\t{0xF9D7, 0x4F50},\n\t{0xF9D8, 0x444E},\n\t{0xF9D9, 0x504A},\n\t{0xF9DA, 0x2C5D},\n\t{0xF9DB, 0x3D7E},\n\t{0xF9DC, 0x4B5C}\n};\n\nunsigned short\nCNStoBIG5(unsigned short cns, unsigned char lc)\n{\n\tint\t\t\ti;\n\tunsigned int big5 = 0;\n\n\tcns &= 0x7f7f;\n\n\tswitch (lc)\n\t{\n\t\tcase LC_CNS11643_1:\n\t\t\tbig5 = BinarySearchRange(cnsPlane1ToBig5Level1, 24, cns);\n\t\t\tbreak;\n\t\tcase LC_CNS11643_2:\n\t\t\tbig5 = BinarySearchRange(cnsPlane2ToBig5Level2, 47, cns);\n\t\t\tbreak;\n\t\tcase LC_CNS11643_3:\n\t\t\tfor (i = 0; i < sizeof(b2c3) / (sizeof(unsigned short) * 2); i++)\n\t\t\t{\n\t\t\t\tif (b2c3[i][1] == cns)\n\t\t\t\t\treturn b2c3[i][0];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_CNS11643_4:\n\t\t\tfor (i = 0; i < sizeof(b1c4) / (sizeof(unsigned short) * 2); i++)\n\t\t\t{\n\t\t\t\tif (b1c4[i][1] == cns)\n\t\t\t\t\treturn b1c4[i][0];\n\t\t\t}\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\treturn big5;\n}"
  },
  {
    "function_name": "BIG5toCNS",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/conversion_procs/euc_tw_and_big5/big5.c",
    "lines": "291-342",
    "snippet": "unsigned short\nBIG5toCNS(unsigned short big5, unsigned char *lc)\n{\n\tunsigned short cns = 0;\n\tint\t\t\ti;\n\n\tif (big5 < 0xc940U)\n\t{\n\t\t/* level 1 */\n\n\t\tfor (i = 0; i < sizeof(b1c4) / (sizeof(unsigned short) * 2); i++)\n\t\t{\n\t\t\tif (b1c4[i][0] == big5)\n\t\t\t{\n\t\t\t\t*lc = LC_CNS11643_4;\n\t\t\t\treturn (b1c4[i][1] | 0x8080U);\n\t\t\t}\n\t\t}\n\n\t\tif (0 < (cns = BinarySearchRange(big5Level1ToCnsPlane1, 23, big5)))\n\t\t\t*lc = LC_CNS11643_1;\n\t}\n\telse if (big5 == 0xc94aU)\n\t{\n\t\t/* level 2 */\n\t\t*lc = LC_CNS11643_1;\n\t\tcns = 0x4442;\n\t}\n\telse\n\t{\n\t\t/* level 2 */\n\t\tfor (i = 0; i < sizeof(b2c3) / (sizeof(unsigned short) * 2); i++)\n\t\t{\n\t\t\tif (b2c3[i][0] == big5)\n\t\t\t{\n\t\t\t\t*lc = LC_CNS11643_3;\n\t\t\t\treturn (b2c3[i][1] | 0x8080U);\n\t\t\t}\n\t\t}\n\n\t\tif (0 < (cns = BinarySearchRange(big5Level2ToCnsPlane2, 46, big5)))\n\t\t\t*lc = LC_CNS11643_2;\n\t}\n\n\tif (0 == cns)\n\t{\t\t\t\t\t\t\t/* no mapping Big5 to CNS 11643-1992 */\n\t\t*lc = 0;\n\t\treturn (unsigned short) '?';\n\t}\n\n\treturn cns | 0x8080;\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"postgres_fe.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const codes_t big5Level1ToCnsPlane1[25] = {\t/* range */\n\t{0xA140, 0x2121},\n\t{0xA1F6, 0x2258},\n\t{0xA1F7, 0x2257},\n\t{0xA1F8, 0x2259},\n\t{0xA2AF, 0x2421},\n\t{0xA3C0, 0x4221},\n\t{0xa3e1, 0x0000},\n\t{0xA440, 0x4421},\n\t{0xACFE, 0x5753},\n\t{0xacff, 0x0000},\n\t{0xAD40, 0x5323},\n\t{0xAFD0, 0x5754},\n\t{0xBBC8, 0x6B51},\n\t{0xBE52, 0x6B50},\n\t{0xBE53, 0x6F5C},\n\t{0xC1AB, 0x7536},\n\t{0xC2CB, 0x7535},\n\t{0xC2CC, 0x7737},\n\t{0xC361, 0x782E},\n\t{0xC3B9, 0x7865},\n\t{0xC3BA, 0x7864},\n\t{0xC3BB, 0x7866},\n\t{0xC456, 0x782D},\n\t{0xC457, 0x7962},\n\t{0xc67f, 0x0000}\n};",
      "static const codes_t big5Level2ToCnsPlane2[48] = {\t/* range */\n\t{0xC940, 0x2121},\n\t{0xc94a, 0x0000},\n\t{0xC94B, 0x212B},\n\t{0xC96C, 0x214D},\n\t{0xC9BE, 0x214C},\n\t{0xC9BF, 0x217D},\n\t{0xC9ED, 0x224E},\n\t{0xCAF7, 0x224D},\n\t{0xCAF8, 0x2439},\n\t{0xD77A, 0x3F6A},\n\t{0xD77B, 0x387E},\n\t{0xDBA7, 0x3F6B},\n\t{0xDDFC, 0x4176},\n\t{0xDDFD, 0x4424},\n\t{0xE8A3, 0x554C},\n\t{0xE976, 0x5723},\n\t{0xEB5B, 0x5A29},\n\t{0xEBF1, 0x554B},\n\t{0xEBF2, 0x5B3F},\n\t{0xECDE, 0x5722},\n\t{0xECDF, 0x5C6A},\n\t{0xEDAA, 0x5D75},\n\t{0xEEEB, 0x642F},\n\t{0xEEEC, 0x6039},\n\t{0xF056, 0x5D74},\n\t{0xF057, 0x6243},\n\t{0xF0CB, 0x5A28},\n\t{0xF0CC, 0x6337},\n\t{0xF163, 0x6430},\n\t{0xF16B, 0x6761},\n\t{0xF16C, 0x6438},\n\t{0xF268, 0x6934},\n\t{0xF269, 0x6573},\n\t{0xF2C3, 0x664E},\n\t{0xF375, 0x6762},\n\t{0xF466, 0x6935},\n\t{0xF4B5, 0x664D},\n\t{0xF4B6, 0x6962},\n\t{0xF4FD, 0x6A4C},\n\t{0xF663, 0x6A4B},\n\t{0xF664, 0x6C52},\n\t{0xF977, 0x7167},\n\t{0xF9C4, 0x7166},\n\t{0xF9C5, 0x7234},\n\t{0xF9C6, 0x7240},\n\t{0xF9C7, 0x7235},\n\t{0xF9D2, 0x7241},\n\t{0xf9d6, 0x0000}\n};",
      "static const unsigned short b1c4[][2] = {\n\t{0xC879, 0x2123},\n\t{0xC87B, 0x2124},\n\t{0xC87D, 0x212A},\n\t{0xC8A2, 0x2152}\n};",
      "static const unsigned short b2c3[][2] = {\n\t{0xF9D6, 0x4337},\n\t{0xF9D7, 0x4F50},\n\t{0xF9D8, 0x444E},\n\t{0xF9D9, 0x504A},\n\t{0xF9DA, 0x2C5D},\n\t{0xF9DB, 0x3D7E},\n\t{0xF9DC, 0x4B5C}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BinarySearchRange",
          "args": [
            "big5Level2ToCnsPlane2",
            "46",
            "big5"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "BinarySearchRange",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/conversion_procs/euc_tw_and_big5/big5.c",
          "lines": "207-288",
          "snippet": "static unsigned short BinarySearchRange\n\t\t\t(const codes_t *array, int high, unsigned short code)\n{\n\tint\t\t\tlow,\n\t\t\t\tmid,\n\t\t\t\tdistance,\n\t\t\t\ttmp;\n\n\tlow = 0;\n\tmid = high >> 1;\n\n\tfor (; low <= high; mid = (low + high) >> 1)\n\t{\n\t\tif ((array[mid].code <= code) && (array[mid + 1].code > code))\n\t\t{\n\t\t\tif (0 == array[mid].peer)\n\t\t\t\treturn 0;\n\t\t\tif (code >= 0xa140U)\n\t\t\t{\n\t\t\t\t/* big5 to cns */\n\t\t\t\ttmp = ((code & 0xff00) - (array[mid].code & 0xff00)) >> 8;\n\t\t\t\thigh = code & 0x00ff;\n\t\t\t\tlow = array[mid].code & 0x00ff;\n\n\t\t\t\t/*\n\t\t\t\t * NOTE: big5 high_byte: 0xa1-0xfe, low_byte: 0x40-0x7e,\n\t\t\t\t * 0xa1-0xfe (radicals: 0x00-0x3e, 0x3f-0x9c) big5 radix is\n\t\t\t\t * 0x9d.                     [region_low, region_high] We\n\t\t\t\t * should remember big5 has two different regions (above).\n\t\t\t\t * There is a bias for the distance between these regions.\n\t\t\t\t * 0xa1 - 0x7e + bias = 1 (Distance between 0xa1 and 0x7e is\n\t\t\t\t * 1.) bias = - 0x22.\n\t\t\t\t */\n\t\t\t\tdistance = tmp * 0x9d + high - low +\n\t\t\t\t\t(high >= 0xa1 ? (low >= 0xa1 ? 0 : -0x22)\n\t\t\t\t\t : (low >= 0xa1 ? +0x22 : 0));\n\n\t\t\t\t/*\n\t\t\t\t * NOTE: we have to convert the distance into a code point.\n\t\t\t\t * The code point's low_byte is 0x21 plus mod_0x5e. In the\n\t\t\t\t * first, we extract the mod_0x5e of the starting code point,\n\t\t\t\t * subtracting 0x21, and add distance to it. Then we calculate\n\t\t\t\t * again mod_0x5e of them, and restore the final codepoint,\n\t\t\t\t * adding 0x21.\n\t\t\t\t */\n\t\t\t\ttmp = (array[mid].peer & 0x00ff) + distance - 0x21;\n\t\t\t\ttmp = (array[mid].peer & 0xff00) + ((tmp / 0x5e) << 8)\n\t\t\t\t\t+ 0x21 + tmp % 0x5e;\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* cns to big5 */\n\t\t\t\ttmp = ((code & 0xff00) - (array[mid].code & 0xff00)) >> 8;\n\n\t\t\t\t/*\n\t\t\t\t * NOTE: ISO charsets ranges between 0x21-0xfe (94charset).\n\t\t\t\t * Its radix is 0x5e. But there is no distance bias like big5.\n\t\t\t\t */\n\t\t\t\tdistance = tmp * 0x5e\n\t\t\t\t\t+ ((int) (code & 0x00ff) - (int) (array[mid].code & 0x00ff));\n\n\t\t\t\t/*\n\t\t\t\t * NOTE: Similar to big5 to cns conversion, we extract\n\t\t\t\t * mod_0x9d and restore mod_0x9d into a code point.\n\t\t\t\t */\n\t\t\t\tlow = array[mid].peer & 0x00ff;\n\t\t\t\ttmp = low + distance - (low >= 0xa1 ? 0x62 : 0x40);\n\t\t\t\tlow = tmp % 0x9d;\n\t\t\t\ttmp = (array[mid].peer & 0xff00) + ((tmp / 0x9d) << 8)\n\t\t\t\t\t+ (low > 0x3e ? 0x62 : 0x40) + low;\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t}\n\t\telse if (array[mid].code > code)\n\t\t\thigh = mid - 1;\n\t\telse\n\t\t\tlow = mid + 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres_fe.h\"\n\nstatic unsigned short BinarySearchRange\n\t\t\t(const codes_t *array, int high, unsigned short code)\n{\n\tint\t\t\tlow,\n\t\t\t\tmid,\n\t\t\t\tdistance,\n\t\t\t\ttmp;\n\n\tlow = 0;\n\tmid = high >> 1;\n\n\tfor (; low <= high; mid = (low + high) >> 1)\n\t{\n\t\tif ((array[mid].code <= code) && (array[mid + 1].code > code))\n\t\t{\n\t\t\tif (0 == array[mid].peer)\n\t\t\t\treturn 0;\n\t\t\tif (code >= 0xa140U)\n\t\t\t{\n\t\t\t\t/* big5 to cns */\n\t\t\t\ttmp = ((code & 0xff00) - (array[mid].code & 0xff00)) >> 8;\n\t\t\t\thigh = code & 0x00ff;\n\t\t\t\tlow = array[mid].code & 0x00ff;\n\n\t\t\t\t/*\n\t\t\t\t * NOTE: big5 high_byte: 0xa1-0xfe, low_byte: 0x40-0x7e,\n\t\t\t\t * 0xa1-0xfe (radicals: 0x00-0x3e, 0x3f-0x9c) big5 radix is\n\t\t\t\t * 0x9d.                     [region_low, region_high] We\n\t\t\t\t * should remember big5 has two different regions (above).\n\t\t\t\t * There is a bias for the distance between these regions.\n\t\t\t\t * 0xa1 - 0x7e + bias = 1 (Distance between 0xa1 and 0x7e is\n\t\t\t\t * 1.) bias = - 0x22.\n\t\t\t\t */\n\t\t\t\tdistance = tmp * 0x9d + high - low +\n\t\t\t\t\t(high >= 0xa1 ? (low >= 0xa1 ? 0 : -0x22)\n\t\t\t\t\t : (low >= 0xa1 ? +0x22 : 0));\n\n\t\t\t\t/*\n\t\t\t\t * NOTE: we have to convert the distance into a code point.\n\t\t\t\t * The code point's low_byte is 0x21 plus mod_0x5e. In the\n\t\t\t\t * first, we extract the mod_0x5e of the starting code point,\n\t\t\t\t * subtracting 0x21, and add distance to it. Then we calculate\n\t\t\t\t * again mod_0x5e of them, and restore the final codepoint,\n\t\t\t\t * adding 0x21.\n\t\t\t\t */\n\t\t\t\ttmp = (array[mid].peer & 0x00ff) + distance - 0x21;\n\t\t\t\ttmp = (array[mid].peer & 0xff00) + ((tmp / 0x5e) << 8)\n\t\t\t\t\t+ 0x21 + tmp % 0x5e;\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* cns to big5 */\n\t\t\t\ttmp = ((code & 0xff00) - (array[mid].code & 0xff00)) >> 8;\n\n\t\t\t\t/*\n\t\t\t\t * NOTE: ISO charsets ranges between 0x21-0xfe (94charset).\n\t\t\t\t * Its radix is 0x5e. But there is no distance bias like big5.\n\t\t\t\t */\n\t\t\t\tdistance = tmp * 0x5e\n\t\t\t\t\t+ ((int) (code & 0x00ff) - (int) (array[mid].code & 0x00ff));\n\n\t\t\t\t/*\n\t\t\t\t * NOTE: Similar to big5 to cns conversion, we extract\n\t\t\t\t * mod_0x9d and restore mod_0x9d into a code point.\n\t\t\t\t */\n\t\t\t\tlow = array[mid].peer & 0x00ff;\n\t\t\t\ttmp = low + distance - (low >= 0xa1 ? 0x62 : 0x40);\n\t\t\t\tlow = tmp % 0x9d;\n\t\t\t\ttmp = (array[mid].peer & 0xff00) + ((tmp / 0x9d) << 8)\n\t\t\t\t\t+ (low > 0x3e ? 0x62 : 0x40) + low;\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t}\n\t\telse if (array[mid].code > code)\n\t\t\thigh = mid - 1;\n\t\telse\n\t\t\tlow = mid + 1;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres_fe.h\"\n\nstatic const codes_t big5Level1ToCnsPlane1[25] = {\t/* range */\n\t{0xA140, 0x2121},\n\t{0xA1F6, 0x2258},\n\t{0xA1F7, 0x2257},\n\t{0xA1F8, 0x2259},\n\t{0xA2AF, 0x2421},\n\t{0xA3C0, 0x4221},\n\t{0xa3e1, 0x0000},\n\t{0xA440, 0x4421},\n\t{0xACFE, 0x5753},\n\t{0xacff, 0x0000},\n\t{0xAD40, 0x5323},\n\t{0xAFD0, 0x5754},\n\t{0xBBC8, 0x6B51},\n\t{0xBE52, 0x6B50},\n\t{0xBE53, 0x6F5C},\n\t{0xC1AB, 0x7536},\n\t{0xC2CB, 0x7535},\n\t{0xC2CC, 0x7737},\n\t{0xC361, 0x782E},\n\t{0xC3B9, 0x7865},\n\t{0xC3BA, 0x7864},\n\t{0xC3BB, 0x7866},\n\t{0xC456, 0x782D},\n\t{0xC457, 0x7962},\n\t{0xc67f, 0x0000}\n};\nstatic const codes_t big5Level2ToCnsPlane2[48] = {\t/* range */\n\t{0xC940, 0x2121},\n\t{0xc94a, 0x0000},\n\t{0xC94B, 0x212B},\n\t{0xC96C, 0x214D},\n\t{0xC9BE, 0x214C},\n\t{0xC9BF, 0x217D},\n\t{0xC9ED, 0x224E},\n\t{0xCAF7, 0x224D},\n\t{0xCAF8, 0x2439},\n\t{0xD77A, 0x3F6A},\n\t{0xD77B, 0x387E},\n\t{0xDBA7, 0x3F6B},\n\t{0xDDFC, 0x4176},\n\t{0xDDFD, 0x4424},\n\t{0xE8A3, 0x554C},\n\t{0xE976, 0x5723},\n\t{0xEB5B, 0x5A29},\n\t{0xEBF1, 0x554B},\n\t{0xEBF2, 0x5B3F},\n\t{0xECDE, 0x5722},\n\t{0xECDF, 0x5C6A},\n\t{0xEDAA, 0x5D75},\n\t{0xEEEB, 0x642F},\n\t{0xEEEC, 0x6039},\n\t{0xF056, 0x5D74},\n\t{0xF057, 0x6243},\n\t{0xF0CB, 0x5A28},\n\t{0xF0CC, 0x6337},\n\t{0xF163, 0x6430},\n\t{0xF16B, 0x6761},\n\t{0xF16C, 0x6438},\n\t{0xF268, 0x6934},\n\t{0xF269, 0x6573},\n\t{0xF2C3, 0x664E},\n\t{0xF375, 0x6762},\n\t{0xF466, 0x6935},\n\t{0xF4B5, 0x664D},\n\t{0xF4B6, 0x6962},\n\t{0xF4FD, 0x6A4C},\n\t{0xF663, 0x6A4B},\n\t{0xF664, 0x6C52},\n\t{0xF977, 0x7167},\n\t{0xF9C4, 0x7166},\n\t{0xF9C5, 0x7234},\n\t{0xF9C6, 0x7240},\n\t{0xF9C7, 0x7235},\n\t{0xF9D2, 0x7241},\n\t{0xf9d6, 0x0000}\n};\nstatic const unsigned short b1c4[][2] = {\n\t{0xC879, 0x2123},\n\t{0xC87B, 0x2124},\n\t{0xC87D, 0x212A},\n\t{0xC8A2, 0x2152}\n};\nstatic const unsigned short b2c3[][2] = {\n\t{0xF9D6, 0x4337},\n\t{0xF9D7, 0x4F50},\n\t{0xF9D8, 0x444E},\n\t{0xF9D9, 0x504A},\n\t{0xF9DA, 0x2C5D},\n\t{0xF9DB, 0x3D7E},\n\t{0xF9DC, 0x4B5C}\n};\n\nunsigned short\nBIG5toCNS(unsigned short big5, unsigned char *lc)\n{\n\tunsigned short cns = 0;\n\tint\t\t\ti;\n\n\tif (big5 < 0xc940U)\n\t{\n\t\t/* level 1 */\n\n\t\tfor (i = 0; i < sizeof(b1c4) / (sizeof(unsigned short) * 2); i++)\n\t\t{\n\t\t\tif (b1c4[i][0] == big5)\n\t\t\t{\n\t\t\t\t*lc = LC_CNS11643_4;\n\t\t\t\treturn (b1c4[i][1] | 0x8080U);\n\t\t\t}\n\t\t}\n\n\t\tif (0 < (cns = BinarySearchRange(big5Level1ToCnsPlane1, 23, big5)))\n\t\t\t*lc = LC_CNS11643_1;\n\t}\n\telse if (big5 == 0xc94aU)\n\t{\n\t\t/* level 2 */\n\t\t*lc = LC_CNS11643_1;\n\t\tcns = 0x4442;\n\t}\n\telse\n\t{\n\t\t/* level 2 */\n\t\tfor (i = 0; i < sizeof(b2c3) / (sizeof(unsigned short) * 2); i++)\n\t\t{\n\t\t\tif (b2c3[i][0] == big5)\n\t\t\t{\n\t\t\t\t*lc = LC_CNS11643_3;\n\t\t\t\treturn (b2c3[i][1] | 0x8080U);\n\t\t\t}\n\t\t}\n\n\t\tif (0 < (cns = BinarySearchRange(big5Level2ToCnsPlane2, 46, big5)))\n\t\t\t*lc = LC_CNS11643_2;\n\t}\n\n\tif (0 == cns)\n\t{\t\t\t\t\t\t\t/* no mapping Big5 to CNS 11643-1992 */\n\t\t*lc = 0;\n\t\treturn (unsigned short) '?';\n\t}\n\n\treturn cns | 0x8080;\n}"
  },
  {
    "function_name": "BinarySearchRange",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/conversion_procs/euc_tw_and_big5/big5.c",
    "lines": "207-288",
    "snippet": "static unsigned short BinarySearchRange\n\t\t\t(const codes_t *array, int high, unsigned short code)\n{\n\tint\t\t\tlow,\n\t\t\t\tmid,\n\t\t\t\tdistance,\n\t\t\t\ttmp;\n\n\tlow = 0;\n\tmid = high >> 1;\n\n\tfor (; low <= high; mid = (low + high) >> 1)\n\t{\n\t\tif ((array[mid].code <= code) && (array[mid + 1].code > code))\n\t\t{\n\t\t\tif (0 == array[mid].peer)\n\t\t\t\treturn 0;\n\t\t\tif (code >= 0xa140U)\n\t\t\t{\n\t\t\t\t/* big5 to cns */\n\t\t\t\ttmp = ((code & 0xff00) - (array[mid].code & 0xff00)) >> 8;\n\t\t\t\thigh = code & 0x00ff;\n\t\t\t\tlow = array[mid].code & 0x00ff;\n\n\t\t\t\t/*\n\t\t\t\t * NOTE: big5 high_byte: 0xa1-0xfe, low_byte: 0x40-0x7e,\n\t\t\t\t * 0xa1-0xfe (radicals: 0x00-0x3e, 0x3f-0x9c) big5 radix is\n\t\t\t\t * 0x9d.                     [region_low, region_high] We\n\t\t\t\t * should remember big5 has two different regions (above).\n\t\t\t\t * There is a bias for the distance between these regions.\n\t\t\t\t * 0xa1 - 0x7e + bias = 1 (Distance between 0xa1 and 0x7e is\n\t\t\t\t * 1.) bias = - 0x22.\n\t\t\t\t */\n\t\t\t\tdistance = tmp * 0x9d + high - low +\n\t\t\t\t\t(high >= 0xa1 ? (low >= 0xa1 ? 0 : -0x22)\n\t\t\t\t\t : (low >= 0xa1 ? +0x22 : 0));\n\n\t\t\t\t/*\n\t\t\t\t * NOTE: we have to convert the distance into a code point.\n\t\t\t\t * The code point's low_byte is 0x21 plus mod_0x5e. In the\n\t\t\t\t * first, we extract the mod_0x5e of the starting code point,\n\t\t\t\t * subtracting 0x21, and add distance to it. Then we calculate\n\t\t\t\t * again mod_0x5e of them, and restore the final codepoint,\n\t\t\t\t * adding 0x21.\n\t\t\t\t */\n\t\t\t\ttmp = (array[mid].peer & 0x00ff) + distance - 0x21;\n\t\t\t\ttmp = (array[mid].peer & 0xff00) + ((tmp / 0x5e) << 8)\n\t\t\t\t\t+ 0x21 + tmp % 0x5e;\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* cns to big5 */\n\t\t\t\ttmp = ((code & 0xff00) - (array[mid].code & 0xff00)) >> 8;\n\n\t\t\t\t/*\n\t\t\t\t * NOTE: ISO charsets ranges between 0x21-0xfe (94charset).\n\t\t\t\t * Its radix is 0x5e. But there is no distance bias like big5.\n\t\t\t\t */\n\t\t\t\tdistance = tmp * 0x5e\n\t\t\t\t\t+ ((int) (code & 0x00ff) - (int) (array[mid].code & 0x00ff));\n\n\t\t\t\t/*\n\t\t\t\t * NOTE: Similar to big5 to cns conversion, we extract\n\t\t\t\t * mod_0x9d and restore mod_0x9d into a code point.\n\t\t\t\t */\n\t\t\t\tlow = array[mid].peer & 0x00ff;\n\t\t\t\ttmp = low + distance - (low >= 0xa1 ? 0x62 : 0x40);\n\t\t\t\tlow = tmp % 0x9d;\n\t\t\t\ttmp = (array[mid].peer & 0xff00) + ((tmp / 0x9d) << 8)\n\t\t\t\t\t+ (low > 0x3e ? 0x62 : 0x40) + low;\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t}\n\t\telse if (array[mid].code > code)\n\t\t\thigh = mid - 1;\n\t\telse\n\t\t\tlow = mid + 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"postgres_fe.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres_fe.h\"\n\nstatic unsigned short BinarySearchRange\n\t\t\t(const codes_t *array, int high, unsigned short code)\n{\n\tint\t\t\tlow,\n\t\t\t\tmid,\n\t\t\t\tdistance,\n\t\t\t\ttmp;\n\n\tlow = 0;\n\tmid = high >> 1;\n\n\tfor (; low <= high; mid = (low + high) >> 1)\n\t{\n\t\tif ((array[mid].code <= code) && (array[mid + 1].code > code))\n\t\t{\n\t\t\tif (0 == array[mid].peer)\n\t\t\t\treturn 0;\n\t\t\tif (code >= 0xa140U)\n\t\t\t{\n\t\t\t\t/* big5 to cns */\n\t\t\t\ttmp = ((code & 0xff00) - (array[mid].code & 0xff00)) >> 8;\n\t\t\t\thigh = code & 0x00ff;\n\t\t\t\tlow = array[mid].code & 0x00ff;\n\n\t\t\t\t/*\n\t\t\t\t * NOTE: big5 high_byte: 0xa1-0xfe, low_byte: 0x40-0x7e,\n\t\t\t\t * 0xa1-0xfe (radicals: 0x00-0x3e, 0x3f-0x9c) big5 radix is\n\t\t\t\t * 0x9d.                     [region_low, region_high] We\n\t\t\t\t * should remember big5 has two different regions (above).\n\t\t\t\t * There is a bias for the distance between these regions.\n\t\t\t\t * 0xa1 - 0x7e + bias = 1 (Distance between 0xa1 and 0x7e is\n\t\t\t\t * 1.) bias = - 0x22.\n\t\t\t\t */\n\t\t\t\tdistance = tmp * 0x9d + high - low +\n\t\t\t\t\t(high >= 0xa1 ? (low >= 0xa1 ? 0 : -0x22)\n\t\t\t\t\t : (low >= 0xa1 ? +0x22 : 0));\n\n\t\t\t\t/*\n\t\t\t\t * NOTE: we have to convert the distance into a code point.\n\t\t\t\t * The code point's low_byte is 0x21 plus mod_0x5e. In the\n\t\t\t\t * first, we extract the mod_0x5e of the starting code point,\n\t\t\t\t * subtracting 0x21, and add distance to it. Then we calculate\n\t\t\t\t * again mod_0x5e of them, and restore the final codepoint,\n\t\t\t\t * adding 0x21.\n\t\t\t\t */\n\t\t\t\ttmp = (array[mid].peer & 0x00ff) + distance - 0x21;\n\t\t\t\ttmp = (array[mid].peer & 0xff00) + ((tmp / 0x5e) << 8)\n\t\t\t\t\t+ 0x21 + tmp % 0x5e;\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* cns to big5 */\n\t\t\t\ttmp = ((code & 0xff00) - (array[mid].code & 0xff00)) >> 8;\n\n\t\t\t\t/*\n\t\t\t\t * NOTE: ISO charsets ranges between 0x21-0xfe (94charset).\n\t\t\t\t * Its radix is 0x5e. But there is no distance bias like big5.\n\t\t\t\t */\n\t\t\t\tdistance = tmp * 0x5e\n\t\t\t\t\t+ ((int) (code & 0x00ff) - (int) (array[mid].code & 0x00ff));\n\n\t\t\t\t/*\n\t\t\t\t * NOTE: Similar to big5 to cns conversion, we extract\n\t\t\t\t * mod_0x9d and restore mod_0x9d into a code point.\n\t\t\t\t */\n\t\t\t\tlow = array[mid].peer & 0x00ff;\n\t\t\t\ttmp = low + distance - (low >= 0xa1 ? 0x62 : 0x40);\n\t\t\t\tlow = tmp % 0x9d;\n\t\t\t\ttmp = (array[mid].peer & 0xff00) + ((tmp / 0x9d) << 8)\n\t\t\t\t\t+ (low > 0x3e ? 0x62 : 0x40) + low;\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t}\n\t\telse if (array[mid].code > code)\n\t\t\thigh = mid - 1;\n\t\telse\n\t\t\tlow = mid + 1;\n\t}\n\n\treturn 0;\n}"
  }
]