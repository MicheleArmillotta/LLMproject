[
  {
    "function_name": "RestoreTransactionSnapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
    "lines": "2190-2194",
    "snippet": "void\nRestoreTransactionSnapshot(Snapshot snapshot, void *master_pgproc)\n{\n\tSetTransactionSnapshot(snapshot, NULL, InvalidPid, master_pgproc);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/spin.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/pairingheap.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Snapshot CopySnapshot(Snapshot snapshot);",
      "static void FreeSnapshot(Snapshot snapshot);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetTransactionSnapshot",
          "args": [
            "snapshot",
            "NULL",
            "InvalidPid",
            "master_pgproc"
          ],
          "line": 2193
        },
        "resolved": true,
        "details": {
          "function_name": "SetTransactionSnapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "564-650",
          "snippet": "static void\nSetTransactionSnapshot(Snapshot sourcesnap, VirtualTransactionId *sourcevxid,\n\t\t\t\t\t   int sourcepid, PGPROC *sourceproc)\n{\n\t/* Caller should have checked this already */\n\tAssert(!FirstSnapshotSet);\n\n\t/* Better do this to ensure following Assert succeeds. */\n\tInvalidateCatalogSnapshot();\n\n\tAssert(pairingheap_is_empty(&RegisteredSnapshots));\n\tAssert(FirstXactSnapshot == NULL);\n\tAssert(!HistoricSnapshotActive());\n\n\t/*\n\t * Even though we are not going to use the snapshot it computes, we must\n\t * call GetSnapshotData, for two reasons: (1) to be sure that\n\t * CurrentSnapshotData's XID arrays have been allocated, and (2) to update\n\t * RecentXmin and RecentGlobalXmin.  (We could alternatively include those\n\t * two variables in exported snapshot files, but it seems better to have\n\t * snapshot importers compute reasonably up-to-date values for them.)\n\t */\n\tCurrentSnapshot = GetSnapshotData(&CurrentSnapshotData);\n\n\t/*\n\t * Now copy appropriate fields from the source snapshot.\n\t */\n\tCurrentSnapshot->xmin = sourcesnap->xmin;\n\tCurrentSnapshot->xmax = sourcesnap->xmax;\n\tCurrentSnapshot->xcnt = sourcesnap->xcnt;\n\tAssert(sourcesnap->xcnt <= GetMaxSnapshotXidCount());\n\tmemcpy(CurrentSnapshot->xip, sourcesnap->xip,\n\t\t   sourcesnap->xcnt * sizeof(TransactionId));\n\tCurrentSnapshot->subxcnt = sourcesnap->subxcnt;\n\tAssert(sourcesnap->subxcnt <= GetMaxSnapshotSubxidCount());\n\tmemcpy(CurrentSnapshot->subxip, sourcesnap->subxip,\n\t\t   sourcesnap->subxcnt * sizeof(TransactionId));\n\tCurrentSnapshot->suboverflowed = sourcesnap->suboverflowed;\n\tCurrentSnapshot->takenDuringRecovery = sourcesnap->takenDuringRecovery;\n\t/* NB: curcid should NOT be copied, it's a local matter */\n\n\t/*\n\t * Now we have to fix what GetSnapshotData did with MyPgXact->xmin and\n\t * TransactionXmin.  There is a race condition: to make sure we are not\n\t * causing the global xmin to go backwards, we have to test that the\n\t * source transaction is still running, and that has to be done\n\t * atomically. So let procarray.c do it.\n\t *\n\t * Note: in serializable mode, predicate.c will do this a second time. It\n\t * doesn't seem worth contorting the logic here to avoid two calls,\n\t * especially since it's not clear that predicate.c *must* do this.\n\t */\n\tif (sourceproc != NULL)\n\t{\n\t\tif (!ProcArrayInstallRestoredXmin(CurrentSnapshot->xmin, sourceproc))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\n\t\t\t\t\t errmsg(\"could not import the requested snapshot\"),\n\t\t\t\t\t errdetail(\"The source transaction is not running anymore.\")));\n\t}\n\telse if (!ProcArrayInstallImportedXmin(CurrentSnapshot->xmin, sourcevxid))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\n\t\t\t\t errmsg(\"could not import the requested snapshot\"),\n\t\t\t\t errdetail(\"The source process with PID %d is not running anymore.\",\n\t\t\t\t\t\t   sourcepid)));\n\n\t/*\n\t * In transaction-snapshot mode, the first snapshot must live until end of\n\t * xact, so we must make a copy of it.  Furthermore, if we're running in\n\t * serializable mode, predicate.c needs to do its own processing.\n\t */\n\tif (IsolationUsesXactSnapshot())\n\t{\n\t\tif (IsolationIsSerializable())\n\t\t\tSetSerializableTransactionSnapshot(CurrentSnapshot, sourcevxid,\n\t\t\t\t\t\t\t\t\t\t\t   sourcepid);\n\t\t/* Make a saved copy */\n\t\tCurrentSnapshot = CopySnapshot(CurrentSnapshot);\n\t\tFirstXactSnapshot = CurrentSnapshot;\n\t\t/* Mark it as \"registered\" in FirstXactSnapshot */\n\t\tFirstXactSnapshot->regd_count++;\n\t\tpairingheap_add(&RegisteredSnapshots, &FirstXactSnapshot->ph_node);\n\t}\n\n\tFirstSnapshotSet = true;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static SnapshotData CurrentSnapshotData = {HeapTupleSatisfiesMVCC};",
            "static Snapshot CurrentSnapshot = NULL;",
            "TransactionId TransactionXmin = FirstNormalTransactionId;",
            "TransactionId RecentXmin = FirstNormalTransactionId;",
            "TransactionId RecentGlobalXmin = InvalidTransactionId;",
            "static pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};",
            "bool\t\tFirstSnapshotSet = false;",
            "static Snapshot FirstXactSnapshot = NULL;",
            "static Snapshot CopySnapshot(Snapshot snapshot);",
            "static void FreeSnapshot(Snapshot snapshot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic SnapshotData CurrentSnapshotData = {HeapTupleSatisfiesMVCC};\nstatic Snapshot CurrentSnapshot = NULL;\nTransactionId TransactionXmin = FirstNormalTransactionId;\nTransactionId RecentXmin = FirstNormalTransactionId;\nTransactionId RecentGlobalXmin = InvalidTransactionId;\nstatic pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};\nbool\t\tFirstSnapshotSet = false;\nstatic Snapshot FirstXactSnapshot = NULL;\nstatic Snapshot CopySnapshot(Snapshot snapshot);\nstatic void FreeSnapshot(Snapshot snapshot);\n\nstatic void\nSetTransactionSnapshot(Snapshot sourcesnap, VirtualTransactionId *sourcevxid,\n\t\t\t\t\t   int sourcepid, PGPROC *sourceproc)\n{\n\t/* Caller should have checked this already */\n\tAssert(!FirstSnapshotSet);\n\n\t/* Better do this to ensure following Assert succeeds. */\n\tInvalidateCatalogSnapshot();\n\n\tAssert(pairingheap_is_empty(&RegisteredSnapshots));\n\tAssert(FirstXactSnapshot == NULL);\n\tAssert(!HistoricSnapshotActive());\n\n\t/*\n\t * Even though we are not going to use the snapshot it computes, we must\n\t * call GetSnapshotData, for two reasons: (1) to be sure that\n\t * CurrentSnapshotData's XID arrays have been allocated, and (2) to update\n\t * RecentXmin and RecentGlobalXmin.  (We could alternatively include those\n\t * two variables in exported snapshot files, but it seems better to have\n\t * snapshot importers compute reasonably up-to-date values for them.)\n\t */\n\tCurrentSnapshot = GetSnapshotData(&CurrentSnapshotData);\n\n\t/*\n\t * Now copy appropriate fields from the source snapshot.\n\t */\n\tCurrentSnapshot->xmin = sourcesnap->xmin;\n\tCurrentSnapshot->xmax = sourcesnap->xmax;\n\tCurrentSnapshot->xcnt = sourcesnap->xcnt;\n\tAssert(sourcesnap->xcnt <= GetMaxSnapshotXidCount());\n\tmemcpy(CurrentSnapshot->xip, sourcesnap->xip,\n\t\t   sourcesnap->xcnt * sizeof(TransactionId));\n\tCurrentSnapshot->subxcnt = sourcesnap->subxcnt;\n\tAssert(sourcesnap->subxcnt <= GetMaxSnapshotSubxidCount());\n\tmemcpy(CurrentSnapshot->subxip, sourcesnap->subxip,\n\t\t   sourcesnap->subxcnt * sizeof(TransactionId));\n\tCurrentSnapshot->suboverflowed = sourcesnap->suboverflowed;\n\tCurrentSnapshot->takenDuringRecovery = sourcesnap->takenDuringRecovery;\n\t/* NB: curcid should NOT be copied, it's a local matter */\n\n\t/*\n\t * Now we have to fix what GetSnapshotData did with MyPgXact->xmin and\n\t * TransactionXmin.  There is a race condition: to make sure we are not\n\t * causing the global xmin to go backwards, we have to test that the\n\t * source transaction is still running, and that has to be done\n\t * atomically. So let procarray.c do it.\n\t *\n\t * Note: in serializable mode, predicate.c will do this a second time. It\n\t * doesn't seem worth contorting the logic here to avoid two calls,\n\t * especially since it's not clear that predicate.c *must* do this.\n\t */\n\tif (sourceproc != NULL)\n\t{\n\t\tif (!ProcArrayInstallRestoredXmin(CurrentSnapshot->xmin, sourceproc))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\n\t\t\t\t\t errmsg(\"could not import the requested snapshot\"),\n\t\t\t\t\t errdetail(\"The source transaction is not running anymore.\")));\n\t}\n\telse if (!ProcArrayInstallImportedXmin(CurrentSnapshot->xmin, sourcevxid))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\n\t\t\t\t errmsg(\"could not import the requested snapshot\"),\n\t\t\t\t errdetail(\"The source process with PID %d is not running anymore.\",\n\t\t\t\t\t\t   sourcepid)));\n\n\t/*\n\t * In transaction-snapshot mode, the first snapshot must live until end of\n\t * xact, so we must make a copy of it.  Furthermore, if we're running in\n\t * serializable mode, predicate.c needs to do its own processing.\n\t */\n\tif (IsolationUsesXactSnapshot())\n\t{\n\t\tif (IsolationIsSerializable())\n\t\t\tSetSerializableTransactionSnapshot(CurrentSnapshot, sourcevxid,\n\t\t\t\t\t\t\t\t\t\t\t   sourcepid);\n\t\t/* Make a saved copy */\n\t\tCurrentSnapshot = CopySnapshot(CurrentSnapshot);\n\t\tFirstXactSnapshot = CurrentSnapshot;\n\t\t/* Mark it as \"registered\" in FirstXactSnapshot */\n\t\tFirstXactSnapshot->regd_count++;\n\t\tpairingheap_add(&RegisteredSnapshots, &FirstXactSnapshot->ph_node);\n\t}\n\n\tFirstSnapshotSet = true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic Snapshot CopySnapshot(Snapshot snapshot);\nstatic void FreeSnapshot(Snapshot snapshot);\n\nvoid\nRestoreTransactionSnapshot(Snapshot snapshot, void *master_pgproc)\n{\n\tSetTransactionSnapshot(snapshot, NULL, InvalidPid, master_pgproc);\n}"
  },
  {
    "function_name": "RestoreSnapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
    "lines": "2126-2182",
    "snippet": "Snapshot\nRestoreSnapshot(char *start_address)\n{\n\tSerializedSnapshotData serialized_snapshot;\n\tSize\t\tsize;\n\tSnapshot\tsnapshot;\n\tTransactionId *serialized_xids;\n\n\tmemcpy(&serialized_snapshot, start_address,\n\t\t   sizeof(SerializedSnapshotData));\n\tserialized_xids = (TransactionId *)\n\t\t(start_address + sizeof(SerializedSnapshotData));\n\n\t/* We allocate any XID arrays needed in the same palloc block. */\n\tsize = sizeof(SnapshotData)\n\t\t+ serialized_snapshot.xcnt * sizeof(TransactionId)\n\t\t+ serialized_snapshot.subxcnt * sizeof(TransactionId);\n\n\t/* Copy all required fields */\n\tsnapshot = (Snapshot) MemoryContextAlloc(TopTransactionContext, size);\n\tsnapshot->satisfies = HeapTupleSatisfiesMVCC;\n\tsnapshot->xmin = serialized_snapshot.xmin;\n\tsnapshot->xmax = serialized_snapshot.xmax;\n\tsnapshot->xip = NULL;\n\tsnapshot->xcnt = serialized_snapshot.xcnt;\n\tsnapshot->subxip = NULL;\n\tsnapshot->subxcnt = serialized_snapshot.subxcnt;\n\tsnapshot->suboverflowed = serialized_snapshot.suboverflowed;\n\tsnapshot->takenDuringRecovery = serialized_snapshot.takenDuringRecovery;\n\tsnapshot->curcid = serialized_snapshot.curcid;\n\tsnapshot->whenTaken = serialized_snapshot.whenTaken;\n\tsnapshot->lsn = serialized_snapshot.lsn;\n\n\t/* Copy XIDs, if present. */\n\tif (serialized_snapshot.xcnt > 0)\n\t{\n\t\tsnapshot->xip = (TransactionId *) (snapshot + 1);\n\t\tmemcpy(snapshot->xip, serialized_xids,\n\t\t\t   serialized_snapshot.xcnt * sizeof(TransactionId));\n\t}\n\n\t/* Copy SubXIDs, if present. */\n\tif (serialized_snapshot.subxcnt > 0)\n\t{\n\t\tsnapshot->subxip = ((TransactionId *) (snapshot + 1)) +\n\t\t\tserialized_snapshot.xcnt;\n\t\tmemcpy(snapshot->subxip, serialized_xids + serialized_snapshot.xcnt,\n\t\t\t   serialized_snapshot.subxcnt * sizeof(TransactionId));\n\t}\n\n\t/* Set the copied flag so that the caller will set refcounts correctly. */\n\tsnapshot->regd_count = 0;\n\tsnapshot->active_count = 0;\n\tsnapshot->copied = true;\n\n\treturn snapshot;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/spin.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/pairingheap.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Snapshot CopySnapshot(Snapshot snapshot);",
      "static void FreeSnapshot(Snapshot snapshot);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "snapshot->subxip",
            "serialized_xids + serialized_snapshot.xcnt",
            "serialized_snapshot.subxcnt * sizeof(TransactionId)"
          ],
          "line": 2172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "snapshot->xip",
            "serialized_xids",
            "serialized_snapshot.xcnt * sizeof(TransactionId)"
          ],
          "line": 2163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextAlloc",
          "args": [
            "TopTransactionContext",
            "size"
          ],
          "line": 2145
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1079-1106",
          "snippet": "void *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&serialized_snapshot",
            "start_address",
            "sizeof(SerializedSnapshotData)"
          ],
          "line": 2134
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic Snapshot CopySnapshot(Snapshot snapshot);\nstatic void FreeSnapshot(Snapshot snapshot);\n\nSnapshot\nRestoreSnapshot(char *start_address)\n{\n\tSerializedSnapshotData serialized_snapshot;\n\tSize\t\tsize;\n\tSnapshot\tsnapshot;\n\tTransactionId *serialized_xids;\n\n\tmemcpy(&serialized_snapshot, start_address,\n\t\t   sizeof(SerializedSnapshotData));\n\tserialized_xids = (TransactionId *)\n\t\t(start_address + sizeof(SerializedSnapshotData));\n\n\t/* We allocate any XID arrays needed in the same palloc block. */\n\tsize = sizeof(SnapshotData)\n\t\t+ serialized_snapshot.xcnt * sizeof(TransactionId)\n\t\t+ serialized_snapshot.subxcnt * sizeof(TransactionId);\n\n\t/* Copy all required fields */\n\tsnapshot = (Snapshot) MemoryContextAlloc(TopTransactionContext, size);\n\tsnapshot->satisfies = HeapTupleSatisfiesMVCC;\n\tsnapshot->xmin = serialized_snapshot.xmin;\n\tsnapshot->xmax = serialized_snapshot.xmax;\n\tsnapshot->xip = NULL;\n\tsnapshot->xcnt = serialized_snapshot.xcnt;\n\tsnapshot->subxip = NULL;\n\tsnapshot->subxcnt = serialized_snapshot.subxcnt;\n\tsnapshot->suboverflowed = serialized_snapshot.suboverflowed;\n\tsnapshot->takenDuringRecovery = serialized_snapshot.takenDuringRecovery;\n\tsnapshot->curcid = serialized_snapshot.curcid;\n\tsnapshot->whenTaken = serialized_snapshot.whenTaken;\n\tsnapshot->lsn = serialized_snapshot.lsn;\n\n\t/* Copy XIDs, if present. */\n\tif (serialized_snapshot.xcnt > 0)\n\t{\n\t\tsnapshot->xip = (TransactionId *) (snapshot + 1);\n\t\tmemcpy(snapshot->xip, serialized_xids,\n\t\t\t   serialized_snapshot.xcnt * sizeof(TransactionId));\n\t}\n\n\t/* Copy SubXIDs, if present. */\n\tif (serialized_snapshot.subxcnt > 0)\n\t{\n\t\tsnapshot->subxip = ((TransactionId *) (snapshot + 1)) +\n\t\t\tserialized_snapshot.xcnt;\n\t\tmemcpy(snapshot->subxip, serialized_xids + serialized_snapshot.xcnt,\n\t\t\t   serialized_snapshot.subxcnt * sizeof(TransactionId));\n\t}\n\n\t/* Set the copied flag so that the caller will set refcounts correctly. */\n\tsnapshot->regd_count = 0;\n\tsnapshot->active_count = 0;\n\tsnapshot->copied = true;\n\n\treturn snapshot;\n}"
  },
  {
    "function_name": "SerializeSnapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
    "lines": "2067-2117",
    "snippet": "void\nSerializeSnapshot(Snapshot snapshot, char *start_address)\n{\n\tSerializedSnapshotData serialized_snapshot;\n\n\tAssert(snapshot->subxcnt >= 0);\n\n\t/* Copy all required fields */\n\tserialized_snapshot.xmin = snapshot->xmin;\n\tserialized_snapshot.xmax = snapshot->xmax;\n\tserialized_snapshot.xcnt = snapshot->xcnt;\n\tserialized_snapshot.subxcnt = snapshot->subxcnt;\n\tserialized_snapshot.suboverflowed = snapshot->suboverflowed;\n\tserialized_snapshot.takenDuringRecovery = snapshot->takenDuringRecovery;\n\tserialized_snapshot.curcid = snapshot->curcid;\n\tserialized_snapshot.whenTaken = snapshot->whenTaken;\n\tserialized_snapshot.lsn = snapshot->lsn;\n\n\t/*\n\t * Ignore the SubXID array if it has overflowed, unless the snapshot was\n\t * taken during recovery - in that case, top-level XIDs are in subxip as\n\t * well, and we mustn't lose them.\n\t */\n\tif (serialized_snapshot.suboverflowed && !snapshot->takenDuringRecovery)\n\t\tserialized_snapshot.subxcnt = 0;\n\n\t/* Copy struct to possibly-unaligned buffer */\n\tmemcpy(start_address,\n\t\t   &serialized_snapshot, sizeof(SerializedSnapshotData));\n\n\t/* Copy XID array */\n\tif (snapshot->xcnt > 0)\n\t\tmemcpy((TransactionId *) (start_address +\n\t\t\t\t\t\t\t\t  sizeof(SerializedSnapshotData)),\n\t\t\t   snapshot->xip, snapshot->xcnt * sizeof(TransactionId));\n\n\t/*\n\t * Copy SubXID array. Don't bother to copy it if it had overflowed,\n\t * though, because it's not used anywhere in that case. Except if it's a\n\t * snapshot taken during recovery; all the top-level XIDs are in subxip as\n\t * well in that case, so we mustn't lose them.\n\t */\n\tif (serialized_snapshot.subxcnt > 0)\n\t{\n\t\tSize\t\tsubxipoff = sizeof(SerializedSnapshotData) +\n\t\tsnapshot->xcnt * sizeof(TransactionId);\n\n\t\tmemcpy((TransactionId *) (start_address + subxipoff),\n\t\t\t   snapshot->subxip, snapshot->subxcnt * sizeof(TransactionId));\n\t}\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/spin.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/pairingheap.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Snapshot CopySnapshot(Snapshot snapshot);",
      "static void FreeSnapshot(Snapshot snapshot);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(TransactionId *) (start_address + subxipoff)",
            "snapshot->subxip",
            "snapshot->subxcnt * sizeof(TransactionId)"
          ],
          "line": 2114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(TransactionId *) (start_address +\n\t\t\t\t\t\t\t\t  sizeof(SerializedSnapshotData))",
            "snapshot->xip",
            "snapshot->xcnt * sizeof(TransactionId)"
          ],
          "line": 2099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "start_address",
            "&serialized_snapshot",
            "sizeof(SerializedSnapshotData)"
          ],
          "line": 2094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "snapshot->subxcnt >= 0"
          ],
          "line": 2072
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic Snapshot CopySnapshot(Snapshot snapshot);\nstatic void FreeSnapshot(Snapshot snapshot);\n\nvoid\nSerializeSnapshot(Snapshot snapshot, char *start_address)\n{\n\tSerializedSnapshotData serialized_snapshot;\n\n\tAssert(snapshot->subxcnt >= 0);\n\n\t/* Copy all required fields */\n\tserialized_snapshot.xmin = snapshot->xmin;\n\tserialized_snapshot.xmax = snapshot->xmax;\n\tserialized_snapshot.xcnt = snapshot->xcnt;\n\tserialized_snapshot.subxcnt = snapshot->subxcnt;\n\tserialized_snapshot.suboverflowed = snapshot->suboverflowed;\n\tserialized_snapshot.takenDuringRecovery = snapshot->takenDuringRecovery;\n\tserialized_snapshot.curcid = snapshot->curcid;\n\tserialized_snapshot.whenTaken = snapshot->whenTaken;\n\tserialized_snapshot.lsn = snapshot->lsn;\n\n\t/*\n\t * Ignore the SubXID array if it has overflowed, unless the snapshot was\n\t * taken during recovery - in that case, top-level XIDs are in subxip as\n\t * well, and we mustn't lose them.\n\t */\n\tif (serialized_snapshot.suboverflowed && !snapshot->takenDuringRecovery)\n\t\tserialized_snapshot.subxcnt = 0;\n\n\t/* Copy struct to possibly-unaligned buffer */\n\tmemcpy(start_address,\n\t\t   &serialized_snapshot, sizeof(SerializedSnapshotData));\n\n\t/* Copy XID array */\n\tif (snapshot->xcnt > 0)\n\t\tmemcpy((TransactionId *) (start_address +\n\t\t\t\t\t\t\t\t  sizeof(SerializedSnapshotData)),\n\t\t\t   snapshot->xip, snapshot->xcnt * sizeof(TransactionId));\n\n\t/*\n\t * Copy SubXID array. Don't bother to copy it if it had overflowed,\n\t * though, because it's not used anywhere in that case. Except if it's a\n\t * snapshot taken during recovery; all the top-level XIDs are in subxip as\n\t * well in that case, so we mustn't lose them.\n\t */\n\tif (serialized_snapshot.subxcnt > 0)\n\t{\n\t\tSize\t\tsubxipoff = sizeof(SerializedSnapshotData) +\n\t\tsnapshot->xcnt * sizeof(TransactionId);\n\n\t\tmemcpy((TransactionId *) (start_address + subxipoff),\n\t\t\t   snapshot->subxip, snapshot->subxcnt * sizeof(TransactionId));\n\t}\n}"
  },
  {
    "function_name": "EstimateSnapshotSpace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
    "lines": "2043-2060",
    "snippet": "Size\nEstimateSnapshotSpace(Snapshot snap)\n{\n\tSize\t\tsize;\n\n\tAssert(snap != InvalidSnapshot);\n\tAssert(snap->satisfies == HeapTupleSatisfiesMVCC);\n\n\t/* We allocate any XID arrays needed in the same palloc block. */\n\tsize = add_size(sizeof(SerializedSnapshotData),\n\t\t\t\t\tmul_size(snap->xcnt, sizeof(TransactionId)));\n\tif (snap->subxcnt > 0 &&\n\t\t(!snap->suboverflowed || snap->takenDuringRecovery))\n\t\tsize = add_size(size,\n\t\t\t\t\t\tmul_size(snap->subxcnt, sizeof(TransactionId)));\n\n\treturn size;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/spin.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/pairingheap.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_size",
          "args": [
            "size",
            "mul_size(snap->subxcnt, sizeof(TransactionId))"
          ],
          "line": 2056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mul_size",
          "args": [
            "snap->subxcnt",
            "sizeof(TransactionId)"
          ],
          "line": 2057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_size",
          "args": [
            "sizeof(SerializedSnapshotData)",
            "mul_size(snap->xcnt, sizeof(TransactionId))"
          ],
          "line": 2052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mul_size",
          "args": [
            "snap->xcnt",
            "sizeof(TransactionId)"
          ],
          "line": 2053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "snap->satisfies == HeapTupleSatisfiesMVCC"
          ],
          "line": 2049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "snap != InvalidSnapshot"
          ],
          "line": 2048
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nSize\nEstimateSnapshotSpace(Snapshot snap)\n{\n\tSize\t\tsize;\n\n\tAssert(snap != InvalidSnapshot);\n\tAssert(snap->satisfies == HeapTupleSatisfiesMVCC);\n\n\t/* We allocate any XID arrays needed in the same palloc block. */\n\tsize = add_size(sizeof(SerializedSnapshotData),\n\t\t\t\t\tmul_size(snap->xcnt, sizeof(TransactionId)));\n\tif (snap->subxcnt > 0 &&\n\t\t(!snap->suboverflowed || snap->takenDuringRecovery))\n\t\tsize = add_size(size,\n\t\t\t\t\t\tmul_size(snap->subxcnt, sizeof(TransactionId)));\n\n\treturn size;\n}"
  },
  {
    "function_name": "HistoricSnapshotGetTupleCids",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
    "lines": "2029-2034",
    "snippet": "HTAB *\nHistoricSnapshotGetTupleCids(void)\n{\n\tAssert(HistoricSnapshotActive());\n\treturn tuplecid_data;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/spin.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/pairingheap.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static HTAB *tuplecid_data = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "HistoricSnapshotActive()"
          ],
          "line": 2032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HistoricSnapshotActive",
          "args": [],
          "line": 2032
        },
        "resolved": true,
        "details": {
          "function_name": "HistoricSnapshotActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "2023-2027",
          "snippet": "bool\nHistoricSnapshotActive(void)\n{\n\treturn HistoricSnapshot != NULL;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Snapshot HistoricSnapshot = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic Snapshot HistoricSnapshot = NULL;\n\nbool\nHistoricSnapshotActive(void)\n{\n\treturn HistoricSnapshot != NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic HTAB *tuplecid_data = NULL;\n\nHTAB *\nHistoricSnapshotGetTupleCids(void)\n{\n\tAssert(HistoricSnapshotActive());\n\treturn tuplecid_data;\n}"
  },
  {
    "function_name": "HistoricSnapshotActive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
    "lines": "2023-2027",
    "snippet": "bool\nHistoricSnapshotActive(void)\n{\n\treturn HistoricSnapshot != NULL;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/spin.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/pairingheap.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Snapshot HistoricSnapshot = NULL;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic Snapshot HistoricSnapshot = NULL;\n\nbool\nHistoricSnapshotActive(void)\n{\n\treturn HistoricSnapshot != NULL;\n}"
  },
  {
    "function_name": "TeardownHistoricSnapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
    "lines": "2016-2021",
    "snippet": "void\nTeardownHistoricSnapshot(bool is_error)\n{\n\tHistoricSnapshot = NULL;\n\ttuplecid_data = NULL;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/spin.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/pairingheap.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Snapshot HistoricSnapshot = NULL;",
      "static HTAB *tuplecid_data = NULL;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic Snapshot HistoricSnapshot = NULL;\nstatic HTAB *tuplecid_data = NULL;\n\nvoid\nTeardownHistoricSnapshot(bool is_error)\n{\n\tHistoricSnapshot = NULL;\n\ttuplecid_data = NULL;\n}"
  },
  {
    "function_name": "SetupHistoricSnapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
    "lines": "2000-2010",
    "snippet": "void\nSetupHistoricSnapshot(Snapshot historic_snapshot, HTAB *tuplecids)\n{\n\tAssert(historic_snapshot != NULL);\n\n\t/* setup the timetravel snapshot */\n\tHistoricSnapshot = historic_snapshot;\n\n\t/* setup (cmin, cmax) lookup hash */\n\ttuplecid_data = tuplecids;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/spin.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/pairingheap.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Snapshot HistoricSnapshot = NULL;",
      "static HTAB *tuplecid_data = NULL;",
      "static Snapshot CopySnapshot(Snapshot snapshot);",
      "static void FreeSnapshot(Snapshot snapshot);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "historic_snapshot != NULL"
          ],
          "line": 2003
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic Snapshot HistoricSnapshot = NULL;\nstatic HTAB *tuplecid_data = NULL;\nstatic Snapshot CopySnapshot(Snapshot snapshot);\nstatic void FreeSnapshot(Snapshot snapshot);\n\nvoid\nSetupHistoricSnapshot(Snapshot historic_snapshot, HTAB *tuplecids)\n{\n\tAssert(historic_snapshot != NULL);\n\n\t/* setup the timetravel snapshot */\n\tHistoricSnapshot = historic_snapshot;\n\n\t/* setup (cmin, cmax) lookup hash */\n\ttuplecid_data = tuplecids;\n}"
  },
  {
    "function_name": "MaintainOldSnapshotTimeMapping",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
    "lines": "1847-1991",
    "snippet": "void\nMaintainOldSnapshotTimeMapping(TimestampTz whenTaken, TransactionId xmin)\n{\n\tTimestampTz ts;\n\tTransactionId latest_xmin;\n\tTimestampTz update_ts;\n\tbool\t\tmap_update_required = false;\n\n\t/* Never call this function when old snapshot checking is disabled. */\n\tAssert(old_snapshot_threshold >= 0);\n\n\tts = AlignTimestampToMinuteBoundary(whenTaken);\n\n\t/*\n\t * Keep track of the latest xmin seen by any process. Update mapping with\n\t * a new value when we have crossed a bucket boundary.\n\t */\n\tSpinLockAcquire(&oldSnapshotControl->mutex_latest_xmin);\n\tlatest_xmin = oldSnapshotControl->latest_xmin;\n\tupdate_ts = oldSnapshotControl->next_map_update;\n\tif (ts > update_ts)\n\t{\n\t\toldSnapshotControl->next_map_update = ts;\n\t\tmap_update_required = true;\n\t}\n\tif (TransactionIdFollows(xmin, latest_xmin))\n\t\toldSnapshotControl->latest_xmin = xmin;\n\tSpinLockRelease(&oldSnapshotControl->mutex_latest_xmin);\n\n\t/* We only needed to update the most recent xmin value. */\n\tif (!map_update_required)\n\t\treturn;\n\n\t/* No further tracking needed for 0 (used for testing). */\n\tif (old_snapshot_threshold == 0)\n\t\treturn;\n\n\t/*\n\t * We don't want to do something stupid with unusual values, but we don't\n\t * want to litter the log with warnings or break otherwise normal\n\t * processing for this feature; so if something seems unreasonable, just\n\t * log at DEBUG level and return without doing anything.\n\t */\n\tif (whenTaken < 0)\n\t{\n\t\telog(DEBUG1,\n\t\t\t \"MaintainOldSnapshotTimeMapping called with negative whenTaken = %ld\",\n\t\t\t (long) whenTaken);\n\t\treturn;\n\t}\n\tif (!TransactionIdIsNormal(xmin))\n\t{\n\t\telog(DEBUG1,\n\t\t\t \"MaintainOldSnapshotTimeMapping called with xmin = %lu\",\n\t\t\t (unsigned long) xmin);\n\t\treturn;\n\t}\n\n\tLWLockAcquire(OldSnapshotTimeMapLock, LW_EXCLUSIVE);\n\n\tAssert(oldSnapshotControl->head_offset >= 0);\n\tAssert(oldSnapshotControl->head_offset < OLD_SNAPSHOT_TIME_MAP_ENTRIES);\n\tAssert((oldSnapshotControl->head_timestamp % USECS_PER_MINUTE) == 0);\n\tAssert(oldSnapshotControl->count_used >= 0);\n\tAssert(oldSnapshotControl->count_used <= OLD_SNAPSHOT_TIME_MAP_ENTRIES);\n\n\tif (oldSnapshotControl->count_used == 0)\n\t{\n\t\t/* set up first entry for empty mapping */\n\t\toldSnapshotControl->head_offset = 0;\n\t\toldSnapshotControl->head_timestamp = ts;\n\t\toldSnapshotControl->count_used = 1;\n\t\toldSnapshotControl->xid_by_minute[0] = xmin;\n\t}\n\telse if (ts < oldSnapshotControl->head_timestamp)\n\t{\n\t\t/* old ts; log it at DEBUG */\n\t\tLWLockRelease(OldSnapshotTimeMapLock);\n\t\telog(DEBUG1,\n\t\t\t \"MaintainOldSnapshotTimeMapping called with old whenTaken = %ld\",\n\t\t\t (long) whenTaken);\n\t\treturn;\n\t}\n\telse if (ts <= (oldSnapshotControl->head_timestamp +\n\t\t\t\t\t((oldSnapshotControl->count_used - 1)\n\t\t\t\t\t * USECS_PER_MINUTE)))\n\t{\n\t\t/* existing mapping; advance xid if possible */\n\t\tint\t\t\tbucket = (oldSnapshotControl->head_offset\n\t\t\t\t\t\t\t  + ((ts - oldSnapshotControl->head_timestamp)\n\t\t\t\t\t\t\t\t / USECS_PER_MINUTE))\n\t\t% OLD_SNAPSHOT_TIME_MAP_ENTRIES;\n\n\t\tif (TransactionIdPrecedes(oldSnapshotControl->xid_by_minute[bucket], xmin))\n\t\t\toldSnapshotControl->xid_by_minute[bucket] = xmin;\n\t}\n\telse\n\t{\n\t\t/* We need a new bucket, but it might not be the very next one. */\n\t\tint\t\t\tadvance = ((ts - oldSnapshotControl->head_timestamp)\n\t\t\t\t\t\t\t   / USECS_PER_MINUTE);\n\n\t\toldSnapshotControl->head_timestamp = ts;\n\n\t\tif (advance >= OLD_SNAPSHOT_TIME_MAP_ENTRIES)\n\t\t{\n\t\t\t/* Advance is so far that all old data is junk; start over. */\n\t\t\toldSnapshotControl->head_offset = 0;\n\t\t\toldSnapshotControl->count_used = 1;\n\t\t\toldSnapshotControl->xid_by_minute[0] = xmin;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Store the new value in one or more buckets. */\n\t\t\tint\t\t\ti;\n\n\t\t\tfor (i = 0; i < advance; i++)\n\t\t\t{\n\t\t\t\tif (oldSnapshotControl->count_used == OLD_SNAPSHOT_TIME_MAP_ENTRIES)\n\t\t\t\t{\n\t\t\t\t\t/* Map full and new value replaces old head. */\n\t\t\t\t\tint\t\t\told_head = oldSnapshotControl->head_offset;\n\n\t\t\t\t\tif (old_head == (OLD_SNAPSHOT_TIME_MAP_ENTRIES - 1))\n\t\t\t\t\t\toldSnapshotControl->head_offset = 0;\n\t\t\t\t\telse\n\t\t\t\t\t\toldSnapshotControl->head_offset = old_head + 1;\n\t\t\t\t\toldSnapshotControl->xid_by_minute[old_head] = xmin;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* Extend map to unused entry. */\n\t\t\t\t\tint\t\t\tnew_tail = (oldSnapshotControl->head_offset\n\t\t\t\t\t\t\t\t\t\t\t+ oldSnapshotControl->count_used)\n\t\t\t\t\t% OLD_SNAPSHOT_TIME_MAP_ENTRIES;\n\n\t\t\t\t\toldSnapshotControl->count_used++;\n\t\t\t\t\toldSnapshotControl->xid_by_minute[new_tail] = xmin;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tLWLockRelease(OldSnapshotTimeMapLock);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/spin.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/pairingheap.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\t\t\told_snapshot_threshold;",
      "static volatile OldSnapshotControlData *oldSnapshotControl;",
      "static TimestampTz AlignTimestampToMinuteBoundary(TimestampTz ts);",
      "static Snapshot CopySnapshot(Snapshot snapshot);",
      "static void FreeSnapshot(Snapshot snapshot);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LWLockRelease",
          "args": [
            "OldSnapshotTimeMapLock"
          ],
          "line": 1990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdPrecedes",
          "args": [
            "oldSnapshotControl->xid_by_minute[bucket]",
            "xmin"
          ],
          "line": 1940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "DEBUG1",
            "\"MaintainOldSnapshotTimeMapping called with old whenTaken = %ld\"",
            "(long) whenTaken"
          ],
          "line": 1925
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LWLockRelease",
          "args": [
            "OldSnapshotTimeMapLock"
          ],
          "line": 1924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "oldSnapshotControl->count_used <= OLD_SNAPSHOT_TIME_MAP_ENTRIES"
          ],
          "line": 1911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "oldSnapshotControl->count_used >= 0"
          ],
          "line": 1910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "(oldSnapshotControl->head_timestamp % USECS_PER_MINUTE) == 0"
          ],
          "line": 1909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "oldSnapshotControl->head_offset < OLD_SNAPSHOT_TIME_MAP_ENTRIES"
          ],
          "line": 1908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "oldSnapshotControl->head_offset >= 0"
          ],
          "line": 1907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LWLockAcquire",
          "args": [
            "OldSnapshotTimeMapLock",
            "LW_EXCLUSIVE"
          ],
          "line": 1905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsNormal",
          "args": [
            "xmin"
          ],
          "line": 1897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SpinLockRelease",
          "args": [
            "&oldSnapshotControl->mutex_latest_xmin"
          ],
          "line": 1874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdFollows",
          "args": [
            "xmin",
            "latest_xmin"
          ],
          "line": 1872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SpinLockAcquire",
          "args": [
            "&oldSnapshotControl->mutex_latest_xmin"
          ],
          "line": 1864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AlignTimestampToMinuteBoundary",
          "args": [
            "whenTaken"
          ],
          "line": 1858
        },
        "resolved": true,
        "details": {
          "function_name": "AlignTimestampToMinuteBoundary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "1671-1677",
          "snippet": "static TimestampTz\nAlignTimestampToMinuteBoundary(TimestampTz ts)\n{\n\tTimestampTz retval = ts + (USECS_PER_MINUTE - 1);\n\n\treturn retval - (retval % USECS_PER_MINUTE);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimestampTz AlignTimestampToMinuteBoundary(TimestampTz ts);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic TimestampTz AlignTimestampToMinuteBoundary(TimestampTz ts);\n\nstatic TimestampTz\nAlignTimestampToMinuteBoundary(TimestampTz ts)\n{\n\tTimestampTz retval = ts + (USECS_PER_MINUTE - 1);\n\n\treturn retval - (retval % USECS_PER_MINUTE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "old_snapshot_threshold >= 0"
          ],
          "line": 1856
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nint\t\t\told_snapshot_threshold;\nstatic volatile OldSnapshotControlData *oldSnapshotControl;\nstatic TimestampTz AlignTimestampToMinuteBoundary(TimestampTz ts);\nstatic Snapshot CopySnapshot(Snapshot snapshot);\nstatic void FreeSnapshot(Snapshot snapshot);\n\nvoid\nMaintainOldSnapshotTimeMapping(TimestampTz whenTaken, TransactionId xmin)\n{\n\tTimestampTz ts;\n\tTransactionId latest_xmin;\n\tTimestampTz update_ts;\n\tbool\t\tmap_update_required = false;\n\n\t/* Never call this function when old snapshot checking is disabled. */\n\tAssert(old_snapshot_threshold >= 0);\n\n\tts = AlignTimestampToMinuteBoundary(whenTaken);\n\n\t/*\n\t * Keep track of the latest xmin seen by any process. Update mapping with\n\t * a new value when we have crossed a bucket boundary.\n\t */\n\tSpinLockAcquire(&oldSnapshotControl->mutex_latest_xmin);\n\tlatest_xmin = oldSnapshotControl->latest_xmin;\n\tupdate_ts = oldSnapshotControl->next_map_update;\n\tif (ts > update_ts)\n\t{\n\t\toldSnapshotControl->next_map_update = ts;\n\t\tmap_update_required = true;\n\t}\n\tif (TransactionIdFollows(xmin, latest_xmin))\n\t\toldSnapshotControl->latest_xmin = xmin;\n\tSpinLockRelease(&oldSnapshotControl->mutex_latest_xmin);\n\n\t/* We only needed to update the most recent xmin value. */\n\tif (!map_update_required)\n\t\treturn;\n\n\t/* No further tracking needed for 0 (used for testing). */\n\tif (old_snapshot_threshold == 0)\n\t\treturn;\n\n\t/*\n\t * We don't want to do something stupid with unusual values, but we don't\n\t * want to litter the log with warnings or break otherwise normal\n\t * processing for this feature; so if something seems unreasonable, just\n\t * log at DEBUG level and return without doing anything.\n\t */\n\tif (whenTaken < 0)\n\t{\n\t\telog(DEBUG1,\n\t\t\t \"MaintainOldSnapshotTimeMapping called with negative whenTaken = %ld\",\n\t\t\t (long) whenTaken);\n\t\treturn;\n\t}\n\tif (!TransactionIdIsNormal(xmin))\n\t{\n\t\telog(DEBUG1,\n\t\t\t \"MaintainOldSnapshotTimeMapping called with xmin = %lu\",\n\t\t\t (unsigned long) xmin);\n\t\treturn;\n\t}\n\n\tLWLockAcquire(OldSnapshotTimeMapLock, LW_EXCLUSIVE);\n\n\tAssert(oldSnapshotControl->head_offset >= 0);\n\tAssert(oldSnapshotControl->head_offset < OLD_SNAPSHOT_TIME_MAP_ENTRIES);\n\tAssert((oldSnapshotControl->head_timestamp % USECS_PER_MINUTE) == 0);\n\tAssert(oldSnapshotControl->count_used >= 0);\n\tAssert(oldSnapshotControl->count_used <= OLD_SNAPSHOT_TIME_MAP_ENTRIES);\n\n\tif (oldSnapshotControl->count_used == 0)\n\t{\n\t\t/* set up first entry for empty mapping */\n\t\toldSnapshotControl->head_offset = 0;\n\t\toldSnapshotControl->head_timestamp = ts;\n\t\toldSnapshotControl->count_used = 1;\n\t\toldSnapshotControl->xid_by_minute[0] = xmin;\n\t}\n\telse if (ts < oldSnapshotControl->head_timestamp)\n\t{\n\t\t/* old ts; log it at DEBUG */\n\t\tLWLockRelease(OldSnapshotTimeMapLock);\n\t\telog(DEBUG1,\n\t\t\t \"MaintainOldSnapshotTimeMapping called with old whenTaken = %ld\",\n\t\t\t (long) whenTaken);\n\t\treturn;\n\t}\n\telse if (ts <= (oldSnapshotControl->head_timestamp +\n\t\t\t\t\t((oldSnapshotControl->count_used - 1)\n\t\t\t\t\t * USECS_PER_MINUTE)))\n\t{\n\t\t/* existing mapping; advance xid if possible */\n\t\tint\t\t\tbucket = (oldSnapshotControl->head_offset\n\t\t\t\t\t\t\t  + ((ts - oldSnapshotControl->head_timestamp)\n\t\t\t\t\t\t\t\t / USECS_PER_MINUTE))\n\t\t% OLD_SNAPSHOT_TIME_MAP_ENTRIES;\n\n\t\tif (TransactionIdPrecedes(oldSnapshotControl->xid_by_minute[bucket], xmin))\n\t\t\toldSnapshotControl->xid_by_minute[bucket] = xmin;\n\t}\n\telse\n\t{\n\t\t/* We need a new bucket, but it might not be the very next one. */\n\t\tint\t\t\tadvance = ((ts - oldSnapshotControl->head_timestamp)\n\t\t\t\t\t\t\t   / USECS_PER_MINUTE);\n\n\t\toldSnapshotControl->head_timestamp = ts;\n\n\t\tif (advance >= OLD_SNAPSHOT_TIME_MAP_ENTRIES)\n\t\t{\n\t\t\t/* Advance is so far that all old data is junk; start over. */\n\t\t\toldSnapshotControl->head_offset = 0;\n\t\t\toldSnapshotControl->count_used = 1;\n\t\t\toldSnapshotControl->xid_by_minute[0] = xmin;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Store the new value in one or more buckets. */\n\t\t\tint\t\t\ti;\n\n\t\t\tfor (i = 0; i < advance; i++)\n\t\t\t{\n\t\t\t\tif (oldSnapshotControl->count_used == OLD_SNAPSHOT_TIME_MAP_ENTRIES)\n\t\t\t\t{\n\t\t\t\t\t/* Map full and new value replaces old head. */\n\t\t\t\t\tint\t\t\told_head = oldSnapshotControl->head_offset;\n\n\t\t\t\t\tif (old_head == (OLD_SNAPSHOT_TIME_MAP_ENTRIES - 1))\n\t\t\t\t\t\toldSnapshotControl->head_offset = 0;\n\t\t\t\t\telse\n\t\t\t\t\t\toldSnapshotControl->head_offset = old_head + 1;\n\t\t\t\t\toldSnapshotControl->xid_by_minute[old_head] = xmin;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* Extend map to unused entry. */\n\t\t\t\t\tint\t\t\tnew_tail = (oldSnapshotControl->head_offset\n\t\t\t\t\t\t\t\t\t\t\t+ oldSnapshotControl->count_used)\n\t\t\t\t\t% OLD_SNAPSHOT_TIME_MAP_ENTRIES;\n\n\t\t\t\t\toldSnapshotControl->count_used++;\n\t\t\t\t\toldSnapshotControl->xid_by_minute[new_tail] = xmin;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tLWLockRelease(OldSnapshotTimeMapLock);\n}"
  },
  {
    "function_name": "TransactionIdLimitedForOldSnapshots",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
    "lines": "1740-1842",
    "snippet": "TransactionId\nTransactionIdLimitedForOldSnapshots(TransactionId recentXmin,\n\t\t\t\t\t\t\t\t\tRelation relation)\n{\n\tif (TransactionIdIsNormal(recentXmin)\n\t\t&& old_snapshot_threshold >= 0\n\t\t&& RelationAllowsEarlyPruning(relation))\n\t{\n\t\tTimestampTz ts = GetSnapshotCurrentTimestamp();\n\t\tTransactionId xlimit = recentXmin;\n\t\tTransactionId latest_xmin;\n\t\tTimestampTz update_ts;\n\t\tbool\t\tsame_ts_as_threshold = false;\n\n\t\tSpinLockAcquire(&oldSnapshotControl->mutex_latest_xmin);\n\t\tlatest_xmin = oldSnapshotControl->latest_xmin;\n\t\tupdate_ts = oldSnapshotControl->next_map_update;\n\t\tSpinLockRelease(&oldSnapshotControl->mutex_latest_xmin);\n\n\t\t/*\n\t\t * Zero threshold always overrides to latest xmin, if valid.  Without\n\t\t * some heuristic it will find its own snapshot too old on, for\n\t\t * example, a simple UPDATE -- which would make it useless for most\n\t\t * testing, but there is no principled way to ensure that it doesn't\n\t\t * fail in this way.  Use a five-second delay to try to get useful\n\t\t * testing behavior, but this may need adjustment.\n\t\t */\n\t\tif (old_snapshot_threshold == 0)\n\t\t{\n\t\t\tif (TransactionIdPrecedes(latest_xmin, MyPgXact->xmin)\n\t\t\t\t&& TransactionIdFollows(latest_xmin, xlimit))\n\t\t\t\txlimit = latest_xmin;\n\n\t\t\tts -= 5 * USECS_PER_SEC;\n\t\t\tSetOldSnapshotThresholdTimestamp(ts, xlimit);\n\n\t\t\treturn xlimit;\n\t\t}\n\n\t\tts = AlignTimestampToMinuteBoundary(ts)\n\t\t\t- (old_snapshot_threshold * USECS_PER_MINUTE);\n\n\t\t/* Check for fast exit without LW locking. */\n\t\tSpinLockAcquire(&oldSnapshotControl->mutex_threshold);\n\t\tif (ts == oldSnapshotControl->threshold_timestamp)\n\t\t{\n\t\t\txlimit = oldSnapshotControl->threshold_xid;\n\t\t\tsame_ts_as_threshold = true;\n\t\t}\n\t\tSpinLockRelease(&oldSnapshotControl->mutex_threshold);\n\n\t\tif (!same_ts_as_threshold)\n\t\t{\n\t\t\tif (ts == update_ts)\n\t\t\t{\n\t\t\t\txlimit = latest_xmin;\n\t\t\t\tif (NormalTransactionIdFollows(xlimit, recentXmin))\n\t\t\t\t\tSetOldSnapshotThresholdTimestamp(ts, xlimit);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tLWLockAcquire(OldSnapshotTimeMapLock, LW_SHARED);\n\n\t\t\t\tif (oldSnapshotControl->count_used > 0\n\t\t\t\t\t&& ts >= oldSnapshotControl->head_timestamp)\n\t\t\t\t{\n\t\t\t\t\tint\t\t\toffset;\n\n\t\t\t\t\toffset = ((ts - oldSnapshotControl->head_timestamp)\n\t\t\t\t\t\t\t  / USECS_PER_MINUTE);\n\t\t\t\t\tif (offset > oldSnapshotControl->count_used - 1)\n\t\t\t\t\t\toffset = oldSnapshotControl->count_used - 1;\n\t\t\t\t\toffset = (oldSnapshotControl->head_offset + offset)\n\t\t\t\t\t\t% OLD_SNAPSHOT_TIME_MAP_ENTRIES;\n\t\t\t\t\txlimit = oldSnapshotControl->xid_by_minute[offset];\n\n\t\t\t\t\tif (NormalTransactionIdFollows(xlimit, recentXmin))\n\t\t\t\t\t\tSetOldSnapshotThresholdTimestamp(ts, xlimit);\n\t\t\t\t}\n\n\t\t\t\tLWLockRelease(OldSnapshotTimeMapLock);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Failsafe protection against vacuuming work of active transaction.\n\t\t *\n\t\t * This is not an assertion because we avoid the spinlock for\n\t\t * performance, leaving open the possibility that xlimit could advance\n\t\t * and be more current; but it seems prudent to apply this limit.  It\n\t\t * might make pruning a tiny bit less aggressive than it could be, but\n\t\t * protects against data loss bugs.\n\t\t */\n\t\tif (TransactionIdIsNormal(latest_xmin)\n\t\t\t&& TransactionIdPrecedes(latest_xmin, xlimit))\n\t\t\txlimit = latest_xmin;\n\n\t\tif (NormalTransactionIdFollows(xlimit, recentXmin))\n\t\t\treturn xlimit;\n\t}\n\n\treturn recentXmin;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/spin.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/pairingheap.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\t\t\told_snapshot_threshold;",
      "static volatile OldSnapshotControlData *oldSnapshotControl;",
      "static TimestampTz AlignTimestampToMinuteBoundary(TimestampTz ts);",
      "static Snapshot CopySnapshot(Snapshot snapshot);",
      "static void FreeSnapshot(Snapshot snapshot);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "NormalTransactionIdFollows",
          "args": [
            "xlimit",
            "recentXmin"
          ],
          "line": 1837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdPrecedes",
          "args": [
            "latest_xmin",
            "xlimit"
          ],
          "line": 1834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsNormal",
          "args": [
            "latest_xmin"
          ],
          "line": 1833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LWLockRelease",
          "args": [
            "OldSnapshotTimeMapLock"
          ],
          "line": 1820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetOldSnapshotThresholdTimestamp",
          "args": [
            "ts",
            "xlimit"
          ],
          "line": 1817
        },
        "resolved": true,
        "details": {
          "function_name": "SetOldSnapshotThresholdTimestamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "1722-1729",
          "snippet": "static void\nSetOldSnapshotThresholdTimestamp(TimestampTz ts, TransactionId xlimit)\n{\n\tSpinLockAcquire(&oldSnapshotControl->mutex_threshold);\n\toldSnapshotControl->threshold_timestamp = ts;\n\toldSnapshotControl->threshold_xid = xlimit;\n\tSpinLockRelease(&oldSnapshotControl->mutex_threshold);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static volatile OldSnapshotControlData *oldSnapshotControl;",
            "static TimestampTz AlignTimestampToMinuteBoundary(TimestampTz ts);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic volatile OldSnapshotControlData *oldSnapshotControl;\nstatic TimestampTz AlignTimestampToMinuteBoundary(TimestampTz ts);\n\nstatic void\nSetOldSnapshotThresholdTimestamp(TimestampTz ts, TransactionId xlimit)\n{\n\tSpinLockAcquire(&oldSnapshotControl->mutex_threshold);\n\toldSnapshotControl->threshold_timestamp = ts;\n\toldSnapshotControl->threshold_xid = xlimit;\n\tSpinLockRelease(&oldSnapshotControl->mutex_threshold);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NormalTransactionIdFollows",
          "args": [
            "xlimit",
            "recentXmin"
          ],
          "line": 1816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LWLockAcquire",
          "args": [
            "OldSnapshotTimeMapLock",
            "LW_SHARED"
          ],
          "line": 1801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NormalTransactionIdFollows",
          "args": [
            "xlimit",
            "recentXmin"
          ],
          "line": 1796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SpinLockRelease",
          "args": [
            "&oldSnapshotControl->mutex_threshold"
          ],
          "line": 1789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SpinLockAcquire",
          "args": [
            "&oldSnapshotControl->mutex_threshold"
          ],
          "line": 1783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AlignTimestampToMinuteBoundary",
          "args": [
            "ts"
          ],
          "line": 1779
        },
        "resolved": true,
        "details": {
          "function_name": "AlignTimestampToMinuteBoundary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "1671-1677",
          "snippet": "static TimestampTz\nAlignTimestampToMinuteBoundary(TimestampTz ts)\n{\n\tTimestampTz retval = ts + (USECS_PER_MINUTE - 1);\n\n\treturn retval - (retval % USECS_PER_MINUTE);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimestampTz AlignTimestampToMinuteBoundary(TimestampTz ts);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic TimestampTz AlignTimestampToMinuteBoundary(TimestampTz ts);\n\nstatic TimestampTz\nAlignTimestampToMinuteBoundary(TimestampTz ts)\n{\n\tTimestampTz retval = ts + (USECS_PER_MINUTE - 1);\n\n\treturn retval - (retval % USECS_PER_MINUTE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TransactionIdFollows",
          "args": [
            "latest_xmin",
            "xlimit"
          ],
          "line": 1770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdPrecedes",
          "args": [
            "latest_xmin",
            "MyPgXact->xmin"
          ],
          "line": 1769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SpinLockRelease",
          "args": [
            "&oldSnapshotControl->mutex_latest_xmin"
          ],
          "line": 1757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SpinLockAcquire",
          "args": [
            "&oldSnapshotControl->mutex_latest_xmin"
          ],
          "line": 1754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetSnapshotCurrentTimestamp",
          "args": [],
          "line": 1748
        },
        "resolved": true,
        "details": {
          "function_name": "GetSnapshotCurrentTimestamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "1685-1701",
          "snippet": "TimestampTz\nGetSnapshotCurrentTimestamp(void)\n{\n\tTimestampTz now = GetCurrentTimestamp();\n\n\t/*\n\t * Don't let time move backward; if it hasn't advanced, use the old value.\n\t */\n\tSpinLockAcquire(&oldSnapshotControl->mutex_current);\n\tif (now <= oldSnapshotControl->current_timestamp)\n\t\tnow = oldSnapshotControl->current_timestamp;\n\telse\n\t\toldSnapshotControl->current_timestamp = now;\n\tSpinLockRelease(&oldSnapshotControl->mutex_current);\n\n\treturn now;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static volatile OldSnapshotControlData *oldSnapshotControl;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic volatile OldSnapshotControlData *oldSnapshotControl;\n\nTimestampTz\nGetSnapshotCurrentTimestamp(void)\n{\n\tTimestampTz now = GetCurrentTimestamp();\n\n\t/*\n\t * Don't let time move backward; if it hasn't advanced, use the old value.\n\t */\n\tSpinLockAcquire(&oldSnapshotControl->mutex_current);\n\tif (now <= oldSnapshotControl->current_timestamp)\n\t\tnow = oldSnapshotControl->current_timestamp;\n\telse\n\t\toldSnapshotControl->current_timestamp = now;\n\tSpinLockRelease(&oldSnapshotControl->mutex_current);\n\n\treturn now;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationAllowsEarlyPruning",
          "args": [
            "relation"
          ],
          "line": 1746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsNormal",
          "args": [
            "recentXmin"
          ],
          "line": 1744
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nint\t\t\told_snapshot_threshold;\nstatic volatile OldSnapshotControlData *oldSnapshotControl;\nstatic TimestampTz AlignTimestampToMinuteBoundary(TimestampTz ts);\nstatic Snapshot CopySnapshot(Snapshot snapshot);\nstatic void FreeSnapshot(Snapshot snapshot);\n\nTransactionId\nTransactionIdLimitedForOldSnapshots(TransactionId recentXmin,\n\t\t\t\t\t\t\t\t\tRelation relation)\n{\n\tif (TransactionIdIsNormal(recentXmin)\n\t\t&& old_snapshot_threshold >= 0\n\t\t&& RelationAllowsEarlyPruning(relation))\n\t{\n\t\tTimestampTz ts = GetSnapshotCurrentTimestamp();\n\t\tTransactionId xlimit = recentXmin;\n\t\tTransactionId latest_xmin;\n\t\tTimestampTz update_ts;\n\t\tbool\t\tsame_ts_as_threshold = false;\n\n\t\tSpinLockAcquire(&oldSnapshotControl->mutex_latest_xmin);\n\t\tlatest_xmin = oldSnapshotControl->latest_xmin;\n\t\tupdate_ts = oldSnapshotControl->next_map_update;\n\t\tSpinLockRelease(&oldSnapshotControl->mutex_latest_xmin);\n\n\t\t/*\n\t\t * Zero threshold always overrides to latest xmin, if valid.  Without\n\t\t * some heuristic it will find its own snapshot too old on, for\n\t\t * example, a simple UPDATE -- which would make it useless for most\n\t\t * testing, but there is no principled way to ensure that it doesn't\n\t\t * fail in this way.  Use a five-second delay to try to get useful\n\t\t * testing behavior, but this may need adjustment.\n\t\t */\n\t\tif (old_snapshot_threshold == 0)\n\t\t{\n\t\t\tif (TransactionIdPrecedes(latest_xmin, MyPgXact->xmin)\n\t\t\t\t&& TransactionIdFollows(latest_xmin, xlimit))\n\t\t\t\txlimit = latest_xmin;\n\n\t\t\tts -= 5 * USECS_PER_SEC;\n\t\t\tSetOldSnapshotThresholdTimestamp(ts, xlimit);\n\n\t\t\treturn xlimit;\n\t\t}\n\n\t\tts = AlignTimestampToMinuteBoundary(ts)\n\t\t\t- (old_snapshot_threshold * USECS_PER_MINUTE);\n\n\t\t/* Check for fast exit without LW locking. */\n\t\tSpinLockAcquire(&oldSnapshotControl->mutex_threshold);\n\t\tif (ts == oldSnapshotControl->threshold_timestamp)\n\t\t{\n\t\t\txlimit = oldSnapshotControl->threshold_xid;\n\t\t\tsame_ts_as_threshold = true;\n\t\t}\n\t\tSpinLockRelease(&oldSnapshotControl->mutex_threshold);\n\n\t\tif (!same_ts_as_threshold)\n\t\t{\n\t\t\tif (ts == update_ts)\n\t\t\t{\n\t\t\t\txlimit = latest_xmin;\n\t\t\t\tif (NormalTransactionIdFollows(xlimit, recentXmin))\n\t\t\t\t\tSetOldSnapshotThresholdTimestamp(ts, xlimit);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tLWLockAcquire(OldSnapshotTimeMapLock, LW_SHARED);\n\n\t\t\t\tif (oldSnapshotControl->count_used > 0\n\t\t\t\t\t&& ts >= oldSnapshotControl->head_timestamp)\n\t\t\t\t{\n\t\t\t\t\tint\t\t\toffset;\n\n\t\t\t\t\toffset = ((ts - oldSnapshotControl->head_timestamp)\n\t\t\t\t\t\t\t  / USECS_PER_MINUTE);\n\t\t\t\t\tif (offset > oldSnapshotControl->count_used - 1)\n\t\t\t\t\t\toffset = oldSnapshotControl->count_used - 1;\n\t\t\t\t\toffset = (oldSnapshotControl->head_offset + offset)\n\t\t\t\t\t\t% OLD_SNAPSHOT_TIME_MAP_ENTRIES;\n\t\t\t\t\txlimit = oldSnapshotControl->xid_by_minute[offset];\n\n\t\t\t\t\tif (NormalTransactionIdFollows(xlimit, recentXmin))\n\t\t\t\t\t\tSetOldSnapshotThresholdTimestamp(ts, xlimit);\n\t\t\t\t}\n\n\t\t\t\tLWLockRelease(OldSnapshotTimeMapLock);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Failsafe protection against vacuuming work of active transaction.\n\t\t *\n\t\t * This is not an assertion because we avoid the spinlock for\n\t\t * performance, leaving open the possibility that xlimit could advance\n\t\t * and be more current; but it seems prudent to apply this limit.  It\n\t\t * might make pruning a tiny bit less aggressive than it could be, but\n\t\t * protects against data loss bugs.\n\t\t */\n\t\tif (TransactionIdIsNormal(latest_xmin)\n\t\t\t&& TransactionIdPrecedes(latest_xmin, xlimit))\n\t\t\txlimit = latest_xmin;\n\n\t\tif (NormalTransactionIdFollows(xlimit, recentXmin))\n\t\t\treturn xlimit;\n\t}\n\n\treturn recentXmin;\n}"
  },
  {
    "function_name": "SetOldSnapshotThresholdTimestamp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
    "lines": "1722-1729",
    "snippet": "static void\nSetOldSnapshotThresholdTimestamp(TimestampTz ts, TransactionId xlimit)\n{\n\tSpinLockAcquire(&oldSnapshotControl->mutex_threshold);\n\toldSnapshotControl->threshold_timestamp = ts;\n\toldSnapshotControl->threshold_xid = xlimit;\n\tSpinLockRelease(&oldSnapshotControl->mutex_threshold);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/spin.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/pairingheap.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static volatile OldSnapshotControlData *oldSnapshotControl;",
      "static TimestampTz AlignTimestampToMinuteBoundary(TimestampTz ts);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SpinLockRelease",
          "args": [
            "&oldSnapshotControl->mutex_threshold"
          ],
          "line": 1728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SpinLockAcquire",
          "args": [
            "&oldSnapshotControl->mutex_threshold"
          ],
          "line": 1725
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic volatile OldSnapshotControlData *oldSnapshotControl;\nstatic TimestampTz AlignTimestampToMinuteBoundary(TimestampTz ts);\n\nstatic void\nSetOldSnapshotThresholdTimestamp(TimestampTz ts, TransactionId xlimit)\n{\n\tSpinLockAcquire(&oldSnapshotControl->mutex_threshold);\n\toldSnapshotControl->threshold_timestamp = ts;\n\toldSnapshotControl->threshold_xid = xlimit;\n\tSpinLockRelease(&oldSnapshotControl->mutex_threshold);\n}"
  },
  {
    "function_name": "GetOldSnapshotThresholdTimestamp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
    "lines": "1710-1720",
    "snippet": "TimestampTz\nGetOldSnapshotThresholdTimestamp(void)\n{\n\tTimestampTz threshold_timestamp;\n\n\tSpinLockAcquire(&oldSnapshotControl->mutex_threshold);\n\tthreshold_timestamp = oldSnapshotControl->threshold_timestamp;\n\tSpinLockRelease(&oldSnapshotControl->mutex_threshold);\n\n\treturn threshold_timestamp;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/spin.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/pairingheap.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static volatile OldSnapshotControlData *oldSnapshotControl;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SpinLockRelease",
          "args": [
            "&oldSnapshotControl->mutex_threshold"
          ],
          "line": 1717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SpinLockAcquire",
          "args": [
            "&oldSnapshotControl->mutex_threshold"
          ],
          "line": 1715
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic volatile OldSnapshotControlData *oldSnapshotControl;\n\nTimestampTz\nGetOldSnapshotThresholdTimestamp(void)\n{\n\tTimestampTz threshold_timestamp;\n\n\tSpinLockAcquire(&oldSnapshotControl->mutex_threshold);\n\tthreshold_timestamp = oldSnapshotControl->threshold_timestamp;\n\tSpinLockRelease(&oldSnapshotControl->mutex_threshold);\n\n\treturn threshold_timestamp;\n}"
  },
  {
    "function_name": "GetSnapshotCurrentTimestamp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
    "lines": "1685-1701",
    "snippet": "TimestampTz\nGetSnapshotCurrentTimestamp(void)\n{\n\tTimestampTz now = GetCurrentTimestamp();\n\n\t/*\n\t * Don't let time move backward; if it hasn't advanced, use the old value.\n\t */\n\tSpinLockAcquire(&oldSnapshotControl->mutex_current);\n\tif (now <= oldSnapshotControl->current_timestamp)\n\t\tnow = oldSnapshotControl->current_timestamp;\n\telse\n\t\toldSnapshotControl->current_timestamp = now;\n\tSpinLockRelease(&oldSnapshotControl->mutex_current);\n\n\treturn now;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/spin.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/pairingheap.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static volatile OldSnapshotControlData *oldSnapshotControl;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SpinLockRelease",
          "args": [
            "&oldSnapshotControl->mutex_current"
          ],
          "line": 1698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SpinLockAcquire",
          "args": [
            "&oldSnapshotControl->mutex_current"
          ],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetCurrentTimestamp",
          "args": [],
          "line": 1688
        },
        "resolved": true,
        "details": {
          "function_name": "GetCurrentTimestamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1569-1582",
          "snippet": "TimestampTz\nGetCurrentTimestamp(void)\n{\n\tTimestampTz result;\n\tstruct timeval tp;\n\n\tgettimeofday(&tp, NULL);\n\n\tresult = (TimestampTz) tp.tv_sec -\n\t\t((POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY);\n\tresult = (result * USECS_PER_SEC) + tp.tv_usec;\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nTimestampTz\nGetCurrentTimestamp(void)\n{\n\tTimestampTz result;\n\tstruct timeval tp;\n\n\tgettimeofday(&tp, NULL);\n\n\tresult = (TimestampTz) tp.tv_sec -\n\t\t((POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY);\n\tresult = (result * USECS_PER_SEC) + tp.tv_usec;\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic volatile OldSnapshotControlData *oldSnapshotControl;\n\nTimestampTz\nGetSnapshotCurrentTimestamp(void)\n{\n\tTimestampTz now = GetCurrentTimestamp();\n\n\t/*\n\t * Don't let time move backward; if it hasn't advanced, use the old value.\n\t */\n\tSpinLockAcquire(&oldSnapshotControl->mutex_current);\n\tif (now <= oldSnapshotControl->current_timestamp)\n\t\tnow = oldSnapshotControl->current_timestamp;\n\telse\n\t\toldSnapshotControl->current_timestamp = now;\n\tSpinLockRelease(&oldSnapshotControl->mutex_current);\n\n\treturn now;\n}"
  },
  {
    "function_name": "AlignTimestampToMinuteBoundary",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
    "lines": "1671-1677",
    "snippet": "static TimestampTz\nAlignTimestampToMinuteBoundary(TimestampTz ts)\n{\n\tTimestampTz retval = ts + (USECS_PER_MINUTE - 1);\n\n\treturn retval - (retval % USECS_PER_MINUTE);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/spin.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/pairingheap.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TimestampTz AlignTimestampToMinuteBoundary(TimestampTz ts);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic TimestampTz AlignTimestampToMinuteBoundary(TimestampTz ts);\n\nstatic TimestampTz\nAlignTimestampToMinuteBoundary(TimestampTz ts)\n{\n\tTimestampTz retval = ts + (USECS_PER_MINUTE - 1);\n\n\treturn retval - (retval % USECS_PER_MINUTE);\n}"
  },
  {
    "function_name": "ThereAreNoPriorRegisteredSnapshots",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
    "lines": "1654-1662",
    "snippet": "bool\nThereAreNoPriorRegisteredSnapshots(void)\n{\n\tif (pairingheap_is_empty(&RegisteredSnapshots) ||\n\t\tpairingheap_is_singular(&RegisteredSnapshots))\n\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/spin.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/pairingheap.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pairingheap_is_singular",
          "args": [
            "&RegisteredSnapshots"
          ],
          "line": 1658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pairingheap_is_empty",
          "args": [
            "&RegisteredSnapshots"
          ],
          "line": 1657
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};\n\nbool\nThereAreNoPriorRegisteredSnapshots(void)\n{\n\tif (pairingheap_is_empty(&RegisteredSnapshots) ||\n\t\tpairingheap_is_singular(&RegisteredSnapshots))\n\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "DeleteAllExportedSnapshotFiles",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
    "lines": "1615-1644",
    "snippet": "void\nDeleteAllExportedSnapshotFiles(void)\n{\n\tchar\t\tbuf[MAXPGPATH + sizeof(SNAPSHOT_EXPORT_DIR)];\n\tDIR\t\t   *s_dir;\n\tstruct dirent *s_de;\n\n\t/*\n\t * Problems in reading the directory, or unlinking files, are reported at\n\t * LOG level.  Since we're running in the startup process, ERROR level\n\t * would prevent database start, and it's not important enough for that.\n\t */\n\ts_dir = AllocateDir(SNAPSHOT_EXPORT_DIR);\n\n\twhile ((s_de = ReadDirExtended(s_dir, SNAPSHOT_EXPORT_DIR, LOG)) != NULL)\n\t{\n\t\tif (strcmp(s_de->d_name, \".\") == 0 ||\n\t\t\tstrcmp(s_de->d_name, \"..\") == 0)\n\t\t\tcontinue;\n\n\t\tsnprintf(buf, sizeof(buf), SNAPSHOT_EXPORT_DIR \"/%s\", s_de->d_name);\n\n\t\tif (unlink(buf) != 0)\n\t\t\tereport(LOG,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not remove file \\\"%s\\\": %m\", buf)));\n\t}\n\n\tFreeDir(s_dir);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/spin.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/pairingheap.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define SNAPSHOT_EXPORT_DIR \"pg_snapshots\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "FreeDir",
          "args": [
            "s_dir"
          ],
          "line": 1643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "LOG",
            "(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not remove file \\\"%s\\\": %m\", buf))"
          ],
          "line": 1638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not remove file \\\"%s\\\": %m\"",
            "buf"
          ],
          "line": 1640
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode_for_file_access",
          "args": [],
          "line": 1639
        },
        "resolved": true,
        "details": {
          "function_name": "errcode_for_file_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "595-655",
          "snippet": "int\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "buf"
          ],
          "line": 1637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof(buf)",
            "SNAPSHOT_EXPORT_DIR \"/%s\"",
            "s_de->d_name"
          ],
          "line": 1635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s_de->d_name",
            "\"..\""
          ],
          "line": 1632
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "246-256",
          "snippet": "int\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ReadDirExtended",
          "args": [
            "s_dir",
            "SNAPSHOT_EXPORT_DIR",
            "LOG"
          ],
          "line": 1629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocateDir",
          "args": [
            "SNAPSHOT_EXPORT_DIR"
          ],
          "line": 1627
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\n#define SNAPSHOT_EXPORT_DIR \"pg_snapshots\"\n\nvoid\nDeleteAllExportedSnapshotFiles(void)\n{\n\tchar\t\tbuf[MAXPGPATH + sizeof(SNAPSHOT_EXPORT_DIR)];\n\tDIR\t\t   *s_dir;\n\tstruct dirent *s_de;\n\n\t/*\n\t * Problems in reading the directory, or unlinking files, are reported at\n\t * LOG level.  Since we're running in the startup process, ERROR level\n\t * would prevent database start, and it's not important enough for that.\n\t */\n\ts_dir = AllocateDir(SNAPSHOT_EXPORT_DIR);\n\n\twhile ((s_de = ReadDirExtended(s_dir, SNAPSHOT_EXPORT_DIR, LOG)) != NULL)\n\t{\n\t\tif (strcmp(s_de->d_name, \".\") == 0 ||\n\t\t\tstrcmp(s_de->d_name, \"..\") == 0)\n\t\t\tcontinue;\n\n\t\tsnprintf(buf, sizeof(buf), SNAPSHOT_EXPORT_DIR \"/%s\", s_de->d_name);\n\n\t\tif (unlink(buf) != 0)\n\t\t\tereport(LOG,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not remove file \\\"%s\\\": %m\", buf)));\n\t}\n\n\tFreeDir(s_dir);\n}"
  },
  {
    "function_name": "XactHasExportedSnapshots",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
    "lines": "1602-1606",
    "snippet": "bool\nXactHasExportedSnapshots(void)\n{\n\treturn (exportedSnapshots != NIL);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/spin.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/pairingheap.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static List *exportedSnapshots = NIL;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic List *exportedSnapshots = NIL;\n\nbool\nXactHasExportedSnapshots(void)\n{\n\treturn (exportedSnapshots != NIL);\n}"
  },
  {
    "function_name": "ImportSnapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
    "lines": "1429-1596",
    "snippet": "void\nImportSnapshot(const char *idstr)\n{\n\tchar\t\tpath[MAXPGPATH];\n\tFILE\t   *f;\n\tstruct stat stat_buf;\n\tchar\t   *filebuf;\n\tint\t\t\txcnt;\n\tint\t\t\ti;\n\tVirtualTransactionId src_vxid;\n\tint\t\t\tsrc_pid;\n\tOid\t\t\tsrc_dbid;\n\tint\t\t\tsrc_isolevel;\n\tbool\t\tsrc_readonly;\n\tSnapshotData snapshot;\n\n\t/*\n\t * Must be at top level of a fresh transaction.  Note in particular that\n\t * we check we haven't acquired an XID --- if we have, it's conceivable\n\t * that the snapshot would show it as not running, making for very screwy\n\t * behavior.\n\t */\n\tif (FirstSnapshotSet ||\n\t\tGetTopTransactionIdIfAny() != InvalidTransactionId ||\n\t\tIsSubTransaction())\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ACTIVE_SQL_TRANSACTION),\n\t\t\t\t errmsg(\"SET TRANSACTION SNAPSHOT must be called before any query\")));\n\n\t/*\n\t * If we are in read committed mode then the next query would execute with\n\t * a new snapshot thus making this function call quite useless.\n\t */\n\tif (!IsolationUsesXactSnapshot())\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"a snapshot-importing transaction must have isolation level SERIALIZABLE or REPEATABLE READ\")));\n\n\t/*\n\t * Verify the identifier: only 0-9, A-F and hyphens are allowed.  We do\n\t * this mainly to prevent reading arbitrary files.\n\t */\n\tif (strspn(idstr, \"0123456789ABCDEF-\") != strlen(idstr))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid snapshot identifier: \\\"%s\\\"\", idstr)));\n\n\t/* OK, read the file */\n\tsnprintf(path, MAXPGPATH, SNAPSHOT_EXPORT_DIR \"/%s\", idstr);\n\n\tf = AllocateFile(path, PG_BINARY_R);\n\tif (!f)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid snapshot identifier: \\\"%s\\\"\", idstr)));\n\n\t/* get the size of the file so that we know how much memory we need */\n\tif (fstat(fileno(f), &stat_buf))\n\t\telog(ERROR, \"could not stat file \\\"%s\\\": %m\", path);\n\n\t/* and read the file into a palloc'd string */\n\tfilebuf = (char *) palloc(stat_buf.st_size + 1);\n\tif (fread(filebuf, stat_buf.st_size, 1, f) != 1)\n\t\telog(ERROR, \"could not read file \\\"%s\\\": %m\", path);\n\n\tfilebuf[stat_buf.st_size] = '\\0';\n\n\tFreeFile(f);\n\n\t/*\n\t * Construct a snapshot struct by parsing the file content.\n\t */\n\tmemset(&snapshot, 0, sizeof(snapshot));\n\n\tparseVxidFromText(\"vxid:\", &filebuf, path, &src_vxid);\n\tsrc_pid = parseIntFromText(\"pid:\", &filebuf, path);\n\t/* we abuse parseXidFromText a bit here ... */\n\tsrc_dbid = parseXidFromText(\"dbid:\", &filebuf, path);\n\tsrc_isolevel = parseIntFromText(\"iso:\", &filebuf, path);\n\tsrc_readonly = parseIntFromText(\"ro:\", &filebuf, path);\n\n\tsnapshot.xmin = parseXidFromText(\"xmin:\", &filebuf, path);\n\tsnapshot.xmax = parseXidFromText(\"xmax:\", &filebuf, path);\n\n\tsnapshot.xcnt = xcnt = parseIntFromText(\"xcnt:\", &filebuf, path);\n\n\t/* sanity-check the xid count before palloc */\n\tif (xcnt < 0 || xcnt > GetMaxSnapshotXidCount())\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid snapshot data in file \\\"%s\\\"\", path)));\n\n\tsnapshot.xip = (TransactionId *) palloc(xcnt * sizeof(TransactionId));\n\tfor (i = 0; i < xcnt; i++)\n\t\tsnapshot.xip[i] = parseXidFromText(\"xip:\", &filebuf, path);\n\n\tsnapshot.suboverflowed = parseIntFromText(\"sof:\", &filebuf, path);\n\n\tif (!snapshot.suboverflowed)\n\t{\n\t\tsnapshot.subxcnt = xcnt = parseIntFromText(\"sxcnt:\", &filebuf, path);\n\n\t\t/* sanity-check the xid count before palloc */\n\t\tif (xcnt < 0 || xcnt > GetMaxSnapshotSubxidCount())\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid snapshot data in file \\\"%s\\\"\", path)));\n\n\t\tsnapshot.subxip = (TransactionId *) palloc(xcnt * sizeof(TransactionId));\n\t\tfor (i = 0; i < xcnt; i++)\n\t\t\tsnapshot.subxip[i] = parseXidFromText(\"sxp:\", &filebuf, path);\n\t}\n\telse\n\t{\n\t\tsnapshot.subxcnt = 0;\n\t\tsnapshot.subxip = NULL;\n\t}\n\n\tsnapshot.takenDuringRecovery = parseIntFromText(\"rec:\", &filebuf, path);\n\n\t/*\n\t * Do some additional sanity checking, just to protect ourselves.  We\n\t * don't trouble to check the array elements, just the most critical\n\t * fields.\n\t */\n\tif (!VirtualTransactionIdIsValid(src_vxid) ||\n\t\t!OidIsValid(src_dbid) ||\n\t\t!TransactionIdIsNormal(snapshot.xmin) ||\n\t\t!TransactionIdIsNormal(snapshot.xmax))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid snapshot data in file \\\"%s\\\"\", path)));\n\n\t/*\n\t * If we're serializable, the source transaction must be too, otherwise\n\t * predicate.c has problems (SxactGlobalXmin could go backwards).  Also, a\n\t * non-read-only transaction can't adopt a snapshot from a read-only\n\t * transaction, as predicate.c handles the cases very differently.\n\t */\n\tif (IsolationIsSerializable())\n\t{\n\t\tif (src_isolevel != XACT_SERIALIZABLE)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"a serializable transaction cannot import a snapshot from a non-serializable transaction\")));\n\t\tif (src_readonly && !XactReadOnly)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"a non-read-only serializable transaction cannot import a snapshot from a read-only transaction\")));\n\t}\n\n\t/*\n\t * We cannot import a snapshot that was taken in a different database,\n\t * because vacuum calculates OldestXmin on a per-database basis; so the\n\t * source transaction's xmin doesn't protect us from data loss.  This\n\t * restriction could be removed if the source transaction were to mark its\n\t * xmin as being globally applicable.  But that would require some\n\t * additional syntax, since that has to be known when the snapshot is\n\t * initially taken.  (See pgsql-hackers discussion of 2011-10-21.)\n\t */\n\tif (src_dbid != MyDatabaseId)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"cannot import a snapshot from a different database\")));\n\n\t/* OK, install the snapshot */\n\tSetTransactionSnapshot(&snapshot, &src_vxid, src_pid, NULL);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/spin.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/pairingheap.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define SNAPSHOT_EXPORT_DIR \"pg_snapshots\""
    ],
    "globals_used": [
      "bool\t\tFirstSnapshotSet = false;",
      "static Snapshot CopySnapshot(Snapshot snapshot);",
      "static void FreeSnapshot(Snapshot snapshot);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetTransactionSnapshot",
          "args": [
            "&snapshot",
            "&src_vxid",
            "src_pid",
            "NULL"
          ],
          "line": 1595
        },
        "resolved": true,
        "details": {
          "function_name": "SetTransactionSnapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "564-650",
          "snippet": "static void\nSetTransactionSnapshot(Snapshot sourcesnap, VirtualTransactionId *sourcevxid,\n\t\t\t\t\t   int sourcepid, PGPROC *sourceproc)\n{\n\t/* Caller should have checked this already */\n\tAssert(!FirstSnapshotSet);\n\n\t/* Better do this to ensure following Assert succeeds. */\n\tInvalidateCatalogSnapshot();\n\n\tAssert(pairingheap_is_empty(&RegisteredSnapshots));\n\tAssert(FirstXactSnapshot == NULL);\n\tAssert(!HistoricSnapshotActive());\n\n\t/*\n\t * Even though we are not going to use the snapshot it computes, we must\n\t * call GetSnapshotData, for two reasons: (1) to be sure that\n\t * CurrentSnapshotData's XID arrays have been allocated, and (2) to update\n\t * RecentXmin and RecentGlobalXmin.  (We could alternatively include those\n\t * two variables in exported snapshot files, but it seems better to have\n\t * snapshot importers compute reasonably up-to-date values for them.)\n\t */\n\tCurrentSnapshot = GetSnapshotData(&CurrentSnapshotData);\n\n\t/*\n\t * Now copy appropriate fields from the source snapshot.\n\t */\n\tCurrentSnapshot->xmin = sourcesnap->xmin;\n\tCurrentSnapshot->xmax = sourcesnap->xmax;\n\tCurrentSnapshot->xcnt = sourcesnap->xcnt;\n\tAssert(sourcesnap->xcnt <= GetMaxSnapshotXidCount());\n\tmemcpy(CurrentSnapshot->xip, sourcesnap->xip,\n\t\t   sourcesnap->xcnt * sizeof(TransactionId));\n\tCurrentSnapshot->subxcnt = sourcesnap->subxcnt;\n\tAssert(sourcesnap->subxcnt <= GetMaxSnapshotSubxidCount());\n\tmemcpy(CurrentSnapshot->subxip, sourcesnap->subxip,\n\t\t   sourcesnap->subxcnt * sizeof(TransactionId));\n\tCurrentSnapshot->suboverflowed = sourcesnap->suboverflowed;\n\tCurrentSnapshot->takenDuringRecovery = sourcesnap->takenDuringRecovery;\n\t/* NB: curcid should NOT be copied, it's a local matter */\n\n\t/*\n\t * Now we have to fix what GetSnapshotData did with MyPgXact->xmin and\n\t * TransactionXmin.  There is a race condition: to make sure we are not\n\t * causing the global xmin to go backwards, we have to test that the\n\t * source transaction is still running, and that has to be done\n\t * atomically. So let procarray.c do it.\n\t *\n\t * Note: in serializable mode, predicate.c will do this a second time. It\n\t * doesn't seem worth contorting the logic here to avoid two calls,\n\t * especially since it's not clear that predicate.c *must* do this.\n\t */\n\tif (sourceproc != NULL)\n\t{\n\t\tif (!ProcArrayInstallRestoredXmin(CurrentSnapshot->xmin, sourceproc))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\n\t\t\t\t\t errmsg(\"could not import the requested snapshot\"),\n\t\t\t\t\t errdetail(\"The source transaction is not running anymore.\")));\n\t}\n\telse if (!ProcArrayInstallImportedXmin(CurrentSnapshot->xmin, sourcevxid))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\n\t\t\t\t errmsg(\"could not import the requested snapshot\"),\n\t\t\t\t errdetail(\"The source process with PID %d is not running anymore.\",\n\t\t\t\t\t\t   sourcepid)));\n\n\t/*\n\t * In transaction-snapshot mode, the first snapshot must live until end of\n\t * xact, so we must make a copy of it.  Furthermore, if we're running in\n\t * serializable mode, predicate.c needs to do its own processing.\n\t */\n\tif (IsolationUsesXactSnapshot())\n\t{\n\t\tif (IsolationIsSerializable())\n\t\t\tSetSerializableTransactionSnapshot(CurrentSnapshot, sourcevxid,\n\t\t\t\t\t\t\t\t\t\t\t   sourcepid);\n\t\t/* Make a saved copy */\n\t\tCurrentSnapshot = CopySnapshot(CurrentSnapshot);\n\t\tFirstXactSnapshot = CurrentSnapshot;\n\t\t/* Mark it as \"registered\" in FirstXactSnapshot */\n\t\tFirstXactSnapshot->regd_count++;\n\t\tpairingheap_add(&RegisteredSnapshots, &FirstXactSnapshot->ph_node);\n\t}\n\n\tFirstSnapshotSet = true;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static SnapshotData CurrentSnapshotData = {HeapTupleSatisfiesMVCC};",
            "static Snapshot CurrentSnapshot = NULL;",
            "TransactionId TransactionXmin = FirstNormalTransactionId;",
            "TransactionId RecentXmin = FirstNormalTransactionId;",
            "TransactionId RecentGlobalXmin = InvalidTransactionId;",
            "static pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};",
            "bool\t\tFirstSnapshotSet = false;",
            "static Snapshot FirstXactSnapshot = NULL;",
            "static Snapshot CopySnapshot(Snapshot snapshot);",
            "static void FreeSnapshot(Snapshot snapshot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic SnapshotData CurrentSnapshotData = {HeapTupleSatisfiesMVCC};\nstatic Snapshot CurrentSnapshot = NULL;\nTransactionId TransactionXmin = FirstNormalTransactionId;\nTransactionId RecentXmin = FirstNormalTransactionId;\nTransactionId RecentGlobalXmin = InvalidTransactionId;\nstatic pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};\nbool\t\tFirstSnapshotSet = false;\nstatic Snapshot FirstXactSnapshot = NULL;\nstatic Snapshot CopySnapshot(Snapshot snapshot);\nstatic void FreeSnapshot(Snapshot snapshot);\n\nstatic void\nSetTransactionSnapshot(Snapshot sourcesnap, VirtualTransactionId *sourcevxid,\n\t\t\t\t\t   int sourcepid, PGPROC *sourceproc)\n{\n\t/* Caller should have checked this already */\n\tAssert(!FirstSnapshotSet);\n\n\t/* Better do this to ensure following Assert succeeds. */\n\tInvalidateCatalogSnapshot();\n\n\tAssert(pairingheap_is_empty(&RegisteredSnapshots));\n\tAssert(FirstXactSnapshot == NULL);\n\tAssert(!HistoricSnapshotActive());\n\n\t/*\n\t * Even though we are not going to use the snapshot it computes, we must\n\t * call GetSnapshotData, for two reasons: (1) to be sure that\n\t * CurrentSnapshotData's XID arrays have been allocated, and (2) to update\n\t * RecentXmin and RecentGlobalXmin.  (We could alternatively include those\n\t * two variables in exported snapshot files, but it seems better to have\n\t * snapshot importers compute reasonably up-to-date values for them.)\n\t */\n\tCurrentSnapshot = GetSnapshotData(&CurrentSnapshotData);\n\n\t/*\n\t * Now copy appropriate fields from the source snapshot.\n\t */\n\tCurrentSnapshot->xmin = sourcesnap->xmin;\n\tCurrentSnapshot->xmax = sourcesnap->xmax;\n\tCurrentSnapshot->xcnt = sourcesnap->xcnt;\n\tAssert(sourcesnap->xcnt <= GetMaxSnapshotXidCount());\n\tmemcpy(CurrentSnapshot->xip, sourcesnap->xip,\n\t\t   sourcesnap->xcnt * sizeof(TransactionId));\n\tCurrentSnapshot->subxcnt = sourcesnap->subxcnt;\n\tAssert(sourcesnap->subxcnt <= GetMaxSnapshotSubxidCount());\n\tmemcpy(CurrentSnapshot->subxip, sourcesnap->subxip,\n\t\t   sourcesnap->subxcnt * sizeof(TransactionId));\n\tCurrentSnapshot->suboverflowed = sourcesnap->suboverflowed;\n\tCurrentSnapshot->takenDuringRecovery = sourcesnap->takenDuringRecovery;\n\t/* NB: curcid should NOT be copied, it's a local matter */\n\n\t/*\n\t * Now we have to fix what GetSnapshotData did with MyPgXact->xmin and\n\t * TransactionXmin.  There is a race condition: to make sure we are not\n\t * causing the global xmin to go backwards, we have to test that the\n\t * source transaction is still running, and that has to be done\n\t * atomically. So let procarray.c do it.\n\t *\n\t * Note: in serializable mode, predicate.c will do this a second time. It\n\t * doesn't seem worth contorting the logic here to avoid two calls,\n\t * especially since it's not clear that predicate.c *must* do this.\n\t */\n\tif (sourceproc != NULL)\n\t{\n\t\tif (!ProcArrayInstallRestoredXmin(CurrentSnapshot->xmin, sourceproc))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\n\t\t\t\t\t errmsg(\"could not import the requested snapshot\"),\n\t\t\t\t\t errdetail(\"The source transaction is not running anymore.\")));\n\t}\n\telse if (!ProcArrayInstallImportedXmin(CurrentSnapshot->xmin, sourcevxid))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\n\t\t\t\t errmsg(\"could not import the requested snapshot\"),\n\t\t\t\t errdetail(\"The source process with PID %d is not running anymore.\",\n\t\t\t\t\t\t   sourcepid)));\n\n\t/*\n\t * In transaction-snapshot mode, the first snapshot must live until end of\n\t * xact, so we must make a copy of it.  Furthermore, if we're running in\n\t * serializable mode, predicate.c needs to do its own processing.\n\t */\n\tif (IsolationUsesXactSnapshot())\n\t{\n\t\tif (IsolationIsSerializable())\n\t\t\tSetSerializableTransactionSnapshot(CurrentSnapshot, sourcevxid,\n\t\t\t\t\t\t\t\t\t\t\t   sourcepid);\n\t\t/* Make a saved copy */\n\t\tCurrentSnapshot = CopySnapshot(CurrentSnapshot);\n\t\tFirstXactSnapshot = CurrentSnapshot;\n\t\t/* Mark it as \"registered\" in FirstXactSnapshot */\n\t\tFirstXactSnapshot->regd_count++;\n\t\tpairingheap_add(&RegisteredSnapshots, &FirstXactSnapshot->ph_node);\n\t}\n\n\tFirstSnapshotSet = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"cannot import a snapshot from a different database\"))"
          ],
          "line": 1590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"cannot import a snapshot from a different database\""
          ],
          "line": 1592
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_FEATURE_NOT_SUPPORTED"
          ],
          "line": 1591
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"a non-read-only serializable transaction cannot import a snapshot from a read-only transaction\"))"
          ],
          "line": 1575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"a serializable transaction cannot import a snapshot from a non-serializable transaction\"))"
          ],
          "line": 1571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsolationIsSerializable",
          "args": [],
          "line": 1568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid snapshot data in file \\\"%s\\\"\", path))"
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsNormal",
          "args": [
            "snapshot.xmax"
          ],
          "line": 1557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsNormal",
          "args": [
            "snapshot.xmin"
          ],
          "line": 1556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "src_dbid"
          ],
          "line": 1555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VirtualTransactionIdIsValid",
          "args": [
            "src_vxid"
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parseIntFromText",
          "args": [
            "\"rec:\"",
            "&filebuf",
            "path"
          ],
          "line": 1547
        },
        "resolved": true,
        "details": {
          "function_name": "parseIntFromText",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "1349-1372",
          "snippet": "static int\nparseIntFromText(const char *prefix, char **s, const char *filename)\n{\n\tchar\t   *ptr = *s;\n\tint\t\t\tprefixlen = strlen(prefix);\n\tint\t\t\tval;\n\n\tif (strncmp(ptr, prefix, prefixlen) != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid snapshot data in file \\\"%s\\\"\", filename)));\n\tptr += prefixlen;\n\tif (sscanf(ptr, \"%d\", &val) != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid snapshot data in file \\\"%s\\\"\", filename)));\n\tptr = strchr(ptr, '\\n');\n\tif (!ptr)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid snapshot data in file \\\"%s\\\"\", filename)));\n\t*s = ptr + 1;\n\treturn val;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Snapshot CopySnapshot(Snapshot snapshot);",
            "static void FreeSnapshot(Snapshot snapshot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic Snapshot CopySnapshot(Snapshot snapshot);\nstatic void FreeSnapshot(Snapshot snapshot);\n\nstatic int\nparseIntFromText(const char *prefix, char **s, const char *filename)\n{\n\tchar\t   *ptr = *s;\n\tint\t\t\tprefixlen = strlen(prefix);\n\tint\t\t\tval;\n\n\tif (strncmp(ptr, prefix, prefixlen) != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid snapshot data in file \\\"%s\\\"\", filename)));\n\tptr += prefixlen;\n\tif (sscanf(ptr, \"%d\", &val) != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid snapshot data in file \\\"%s\\\"\", filename)));\n\tptr = strchr(ptr, '\\n');\n\tif (!ptr)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid snapshot data in file \\\"%s\\\"\", filename)));\n\t*s = ptr + 1;\n\treturn val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parseXidFromText",
          "args": [
            "\"sxp:\"",
            "&filebuf",
            "path"
          ],
          "line": 1539
        },
        "resolved": true,
        "details": {
          "function_name": "parseXidFromText",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "1374-1397",
          "snippet": "static TransactionId\nparseXidFromText(const char *prefix, char **s, const char *filename)\n{\n\tchar\t   *ptr = *s;\n\tint\t\t\tprefixlen = strlen(prefix);\n\tTransactionId val;\n\n\tif (strncmp(ptr, prefix, prefixlen) != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid snapshot data in file \\\"%s\\\"\", filename)));\n\tptr += prefixlen;\n\tif (sscanf(ptr, \"%u\", &val) != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid snapshot data in file \\\"%s\\\"\", filename)));\n\tptr = strchr(ptr, '\\n');\n\tif (!ptr)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid snapshot data in file \\\"%s\\\"\", filename)));\n\t*s = ptr + 1;\n\treturn val;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Snapshot CopySnapshot(Snapshot snapshot);",
            "static void FreeSnapshot(Snapshot snapshot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic Snapshot CopySnapshot(Snapshot snapshot);\nstatic void FreeSnapshot(Snapshot snapshot);\n\nstatic TransactionId\nparseXidFromText(const char *prefix, char **s, const char *filename)\n{\n\tchar\t   *ptr = *s;\n\tint\t\t\tprefixlen = strlen(prefix);\n\tTransactionId val;\n\n\tif (strncmp(ptr, prefix, prefixlen) != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid snapshot data in file \\\"%s\\\"\", filename)));\n\tptr += prefixlen;\n\tif (sscanf(ptr, \"%u\", &val) != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid snapshot data in file \\\"%s\\\"\", filename)));\n\tptr = strchr(ptr, '\\n');\n\tif (!ptr)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid snapshot data in file \\\"%s\\\"\", filename)));\n\t*s = ptr + 1;\n\treturn val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "xcnt * sizeof(TransactionId)"
          ],
          "line": 1537
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid snapshot data in file \\\"%s\\\"\", path))"
          ],
          "line": 1533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetMaxSnapshotSubxidCount",
          "args": [],
          "line": 1532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid snapshot data in file \\\"%s\\\"\", path))"
          ],
          "line": 1517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetMaxSnapshotXidCount",
          "args": [],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parseVxidFromText",
          "args": [
            "\"vxid:\"",
            "&filebuf",
            "path",
            "&src_vxid"
          ],
          "line": 1503
        },
        "resolved": true,
        "details": {
          "function_name": "parseVxidFromText",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "1399-1421",
          "snippet": "static void\nparseVxidFromText(const char *prefix, char **s, const char *filename,\n\t\t\t\t  VirtualTransactionId *vxid)\n{\n\tchar\t   *ptr = *s;\n\tint\t\t\tprefixlen = strlen(prefix);\n\n\tif (strncmp(ptr, prefix, prefixlen) != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid snapshot data in file \\\"%s\\\"\", filename)));\n\tptr += prefixlen;\n\tif (sscanf(ptr, \"%d/%u\", &vxid->backendId, &vxid->localTransactionId) != 2)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid snapshot data in file \\\"%s\\\"\", filename)));\n\tptr = strchr(ptr, '\\n');\n\tif (!ptr)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid snapshot data in file \\\"%s\\\"\", filename)));\n\t*s = ptr + 1;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Snapshot CopySnapshot(Snapshot snapshot);",
            "static void FreeSnapshot(Snapshot snapshot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic Snapshot CopySnapshot(Snapshot snapshot);\nstatic void FreeSnapshot(Snapshot snapshot);\n\nstatic void\nparseVxidFromText(const char *prefix, char **s, const char *filename,\n\t\t\t\t  VirtualTransactionId *vxid)\n{\n\tchar\t   *ptr = *s;\n\tint\t\t\tprefixlen = strlen(prefix);\n\n\tif (strncmp(ptr, prefix, prefixlen) != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid snapshot data in file \\\"%s\\\"\", filename)));\n\tptr += prefixlen;\n\tif (sscanf(ptr, \"%d/%u\", &vxid->backendId, &vxid->localTransactionId) != 2)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid snapshot data in file \\\"%s\\\"\", filename)));\n\tptr = strchr(ptr, '\\n');\n\tif (!ptr)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid snapshot data in file \\\"%s\\\"\", filename)));\n\t*s = ptr + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&snapshot",
            "0",
            "sizeof(snapshot)"
          ],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FreeFile",
          "args": [
            "f"
          ],
          "line": 1496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"could not read file \\\"%s\\\": %m\"",
            "path"
          ],
          "line": 1492
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fread",
          "args": [
            "filebuf",
            "stat_buf.st_size",
            "1",
            "f"
          ],
          "line": 1491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "fileno(f)",
            "&stat_buf"
          ],
          "line": 1486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileno",
          "args": [
            "f"
          ],
          "line": 1486
        },
        "resolved": true,
        "details": {
          "function_name": "pg_filenode_relation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/dbsize.c",
          "lines": "919-932",
          "snippet": "Datum\npg_filenode_relation(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\treltablespace = PG_GETARG_OID(0);\n\tOid\t\t\trelfilenode = PG_GETARG_OID(1);\n\tOid\t\t\theaprel = InvalidOid;\n\n\theaprel = RelidByRelfilenode(reltablespace, relfilenode);\n\n\tif (!OidIsValid(heaprel))\n\t\tPG_RETURN_NULL();\n\telse\n\t\tPG_RETURN_OID(heaprel);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/relfilenodemap.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/fd.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/relfilenodemap.h\"\n#include \"utils/rel.h\"\n#include \"utils/numeric.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/fd.h\"\n#include \"miscadmin.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nDatum\npg_filenode_relation(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\treltablespace = PG_GETARG_OID(0);\n\tOid\t\t\trelfilenode = PG_GETARG_OID(1);\n\tOid\t\t\theaprel = InvalidOid;\n\n\theaprel = RelidByRelfilenode(reltablespace, relfilenode);\n\n\tif (!OidIsValid(heaprel))\n\t\tPG_RETURN_NULL();\n\telse\n\t\tPG_RETURN_OID(heaprel);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid snapshot identifier: \\\"%s\\\"\", idstr))"
          ],
          "line": 1481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocateFile",
          "args": [
            "path",
            "PG_BINARY_R"
          ],
          "line": 1479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "MAXPGPATH",
            "SNAPSHOT_EXPORT_DIR \"/%s\"",
            "idstr"
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid snapshot identifier: \\\"%s\\\"\", idstr))"
          ],
          "line": 1472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "idstr"
          ],
          "line": 1471
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strspn",
          "args": [
            "idstr",
            "\"0123456789ABCDEF-\""
          ],
          "line": 1471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"a snapshot-importing transaction must have isolation level SERIALIZABLE or REPEATABLE READ\"))"
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsolationUsesXactSnapshot",
          "args": [],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_ACTIVE_SQL_TRANSACTION),\n\t\t\t\t errmsg(\"SET TRANSACTION SNAPSHOT must be called before any query\"))"
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsSubTransaction",
          "args": [],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetTopTransactionIdIfAny",
          "args": [],
          "line": 1452
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\n#define SNAPSHOT_EXPORT_DIR \"pg_snapshots\"\n\nbool\t\tFirstSnapshotSet = false;\nstatic Snapshot CopySnapshot(Snapshot snapshot);\nstatic void FreeSnapshot(Snapshot snapshot);\n\nvoid\nImportSnapshot(const char *idstr)\n{\n\tchar\t\tpath[MAXPGPATH];\n\tFILE\t   *f;\n\tstruct stat stat_buf;\n\tchar\t   *filebuf;\n\tint\t\t\txcnt;\n\tint\t\t\ti;\n\tVirtualTransactionId src_vxid;\n\tint\t\t\tsrc_pid;\n\tOid\t\t\tsrc_dbid;\n\tint\t\t\tsrc_isolevel;\n\tbool\t\tsrc_readonly;\n\tSnapshotData snapshot;\n\n\t/*\n\t * Must be at top level of a fresh transaction.  Note in particular that\n\t * we check we haven't acquired an XID --- if we have, it's conceivable\n\t * that the snapshot would show it as not running, making for very screwy\n\t * behavior.\n\t */\n\tif (FirstSnapshotSet ||\n\t\tGetTopTransactionIdIfAny() != InvalidTransactionId ||\n\t\tIsSubTransaction())\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ACTIVE_SQL_TRANSACTION),\n\t\t\t\t errmsg(\"SET TRANSACTION SNAPSHOT must be called before any query\")));\n\n\t/*\n\t * If we are in read committed mode then the next query would execute with\n\t * a new snapshot thus making this function call quite useless.\n\t */\n\tif (!IsolationUsesXactSnapshot())\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"a snapshot-importing transaction must have isolation level SERIALIZABLE or REPEATABLE READ\")));\n\n\t/*\n\t * Verify the identifier: only 0-9, A-F and hyphens are allowed.  We do\n\t * this mainly to prevent reading arbitrary files.\n\t */\n\tif (strspn(idstr, \"0123456789ABCDEF-\") != strlen(idstr))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid snapshot identifier: \\\"%s\\\"\", idstr)));\n\n\t/* OK, read the file */\n\tsnprintf(path, MAXPGPATH, SNAPSHOT_EXPORT_DIR \"/%s\", idstr);\n\n\tf = AllocateFile(path, PG_BINARY_R);\n\tif (!f)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid snapshot identifier: \\\"%s\\\"\", idstr)));\n\n\t/* get the size of the file so that we know how much memory we need */\n\tif (fstat(fileno(f), &stat_buf))\n\t\telog(ERROR, \"could not stat file \\\"%s\\\": %m\", path);\n\n\t/* and read the file into a palloc'd string */\n\tfilebuf = (char *) palloc(stat_buf.st_size + 1);\n\tif (fread(filebuf, stat_buf.st_size, 1, f) != 1)\n\t\telog(ERROR, \"could not read file \\\"%s\\\": %m\", path);\n\n\tfilebuf[stat_buf.st_size] = '\\0';\n\n\tFreeFile(f);\n\n\t/*\n\t * Construct a snapshot struct by parsing the file content.\n\t */\n\tmemset(&snapshot, 0, sizeof(snapshot));\n\n\tparseVxidFromText(\"vxid:\", &filebuf, path, &src_vxid);\n\tsrc_pid = parseIntFromText(\"pid:\", &filebuf, path);\n\t/* we abuse parseXidFromText a bit here ... */\n\tsrc_dbid = parseXidFromText(\"dbid:\", &filebuf, path);\n\tsrc_isolevel = parseIntFromText(\"iso:\", &filebuf, path);\n\tsrc_readonly = parseIntFromText(\"ro:\", &filebuf, path);\n\n\tsnapshot.xmin = parseXidFromText(\"xmin:\", &filebuf, path);\n\tsnapshot.xmax = parseXidFromText(\"xmax:\", &filebuf, path);\n\n\tsnapshot.xcnt = xcnt = parseIntFromText(\"xcnt:\", &filebuf, path);\n\n\t/* sanity-check the xid count before palloc */\n\tif (xcnt < 0 || xcnt > GetMaxSnapshotXidCount())\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid snapshot data in file \\\"%s\\\"\", path)));\n\n\tsnapshot.xip = (TransactionId *) palloc(xcnt * sizeof(TransactionId));\n\tfor (i = 0; i < xcnt; i++)\n\t\tsnapshot.xip[i] = parseXidFromText(\"xip:\", &filebuf, path);\n\n\tsnapshot.suboverflowed = parseIntFromText(\"sof:\", &filebuf, path);\n\n\tif (!snapshot.suboverflowed)\n\t{\n\t\tsnapshot.subxcnt = xcnt = parseIntFromText(\"sxcnt:\", &filebuf, path);\n\n\t\t/* sanity-check the xid count before palloc */\n\t\tif (xcnt < 0 || xcnt > GetMaxSnapshotSubxidCount())\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid snapshot data in file \\\"%s\\\"\", path)));\n\n\t\tsnapshot.subxip = (TransactionId *) palloc(xcnt * sizeof(TransactionId));\n\t\tfor (i = 0; i < xcnt; i++)\n\t\t\tsnapshot.subxip[i] = parseXidFromText(\"sxp:\", &filebuf, path);\n\t}\n\telse\n\t{\n\t\tsnapshot.subxcnt = 0;\n\t\tsnapshot.subxip = NULL;\n\t}\n\n\tsnapshot.takenDuringRecovery = parseIntFromText(\"rec:\", &filebuf, path);\n\n\t/*\n\t * Do some additional sanity checking, just to protect ourselves.  We\n\t * don't trouble to check the array elements, just the most critical\n\t * fields.\n\t */\n\tif (!VirtualTransactionIdIsValid(src_vxid) ||\n\t\t!OidIsValid(src_dbid) ||\n\t\t!TransactionIdIsNormal(snapshot.xmin) ||\n\t\t!TransactionIdIsNormal(snapshot.xmax))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid snapshot data in file \\\"%s\\\"\", path)));\n\n\t/*\n\t * If we're serializable, the source transaction must be too, otherwise\n\t * predicate.c has problems (SxactGlobalXmin could go backwards).  Also, a\n\t * non-read-only transaction can't adopt a snapshot from a read-only\n\t * transaction, as predicate.c handles the cases very differently.\n\t */\n\tif (IsolationIsSerializable())\n\t{\n\t\tif (src_isolevel != XACT_SERIALIZABLE)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"a serializable transaction cannot import a snapshot from a non-serializable transaction\")));\n\t\tif (src_readonly && !XactReadOnly)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"a non-read-only serializable transaction cannot import a snapshot from a read-only transaction\")));\n\t}\n\n\t/*\n\t * We cannot import a snapshot that was taken in a different database,\n\t * because vacuum calculates OldestXmin on a per-database basis; so the\n\t * source transaction's xmin doesn't protect us from data loss.  This\n\t * restriction could be removed if the source transaction were to mark its\n\t * xmin as being globally applicable.  But that would require some\n\t * additional syntax, since that has to be known when the snapshot is\n\t * initially taken.  (See pgsql-hackers discussion of 2011-10-21.)\n\t */\n\tif (src_dbid != MyDatabaseId)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"cannot import a snapshot from a different database\")));\n\n\t/* OK, install the snapshot */\n\tSetTransactionSnapshot(&snapshot, &src_vxid, src_pid, NULL);\n}"
  },
  {
    "function_name": "parseVxidFromText",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
    "lines": "1399-1421",
    "snippet": "static void\nparseVxidFromText(const char *prefix, char **s, const char *filename,\n\t\t\t\t  VirtualTransactionId *vxid)\n{\n\tchar\t   *ptr = *s;\n\tint\t\t\tprefixlen = strlen(prefix);\n\n\tif (strncmp(ptr, prefix, prefixlen) != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid snapshot data in file \\\"%s\\\"\", filename)));\n\tptr += prefixlen;\n\tif (sscanf(ptr, \"%d/%u\", &vxid->backendId, &vxid->localTransactionId) != 2)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid snapshot data in file \\\"%s\\\"\", filename)));\n\tptr = strchr(ptr, '\\n');\n\tif (!ptr)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid snapshot data in file \\\"%s\\\"\", filename)));\n\t*s = ptr + 1;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/spin.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/pairingheap.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Snapshot CopySnapshot(Snapshot snapshot);",
      "static void FreeSnapshot(Snapshot snapshot);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid snapshot data in file \\\"%s\\\"\", filename))"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid snapshot data in file \\\"%s\\\"\"",
            "filename"
          ],
          "line": 1419
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_TEXT_REPRESENTATION"
          ],
          "line": 1418
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "ptr",
            "'\\n'"
          ],
          "line": 1415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid snapshot data in file \\\"%s\\\"\", filename))"
          ],
          "line": 1412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "ptr",
            "\"%d/%u\"",
            "&vxid->backendId",
            "&vxid->localTransactionId"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid snapshot data in file \\\"%s\\\"\", filename))"
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "prefix",
            "prefixlen"
          ],
          "line": 1406
        },
        "resolved": true,
        "details": {
          "function_name": "pg_char_and_wchar_strncmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wstrncmp.c",
          "lines": "54-67",
          "snippet": "int\npg_char_and_wchar_strncmp(const char *s1, const pg_wchar *s2, size_t n)\n{\n\tif (n == 0)\n\t\treturn 0;\n\tdo\n\t{\n\t\tif ((pg_wchar) ((unsigned char) *s1) != *s2++)\n\t\t\treturn ((pg_wchar) ((unsigned char) *s1) - *(s2 - 1));\n\t\tif (*s1++ == 0)\n\t\t\tbreak;\n\t} while (--n != 0);\n\treturn 0;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres_fe.h\"\n\nint\npg_char_and_wchar_strncmp(const char *s1, const pg_wchar *s2, size_t n)\n{\n\tif (n == 0)\n\t\treturn 0;\n\tdo\n\t{\n\t\tif ((pg_wchar) ((unsigned char) *s1) != *s2++)\n\t\t\treturn ((pg_wchar) ((unsigned char) *s1) - *(s2 - 1));\n\t\tif (*s1++ == 0)\n\t\t\tbreak;\n\t} while (--n != 0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "prefix"
          ],
          "line": 1404
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic Snapshot CopySnapshot(Snapshot snapshot);\nstatic void FreeSnapshot(Snapshot snapshot);\n\nstatic void\nparseVxidFromText(const char *prefix, char **s, const char *filename,\n\t\t\t\t  VirtualTransactionId *vxid)\n{\n\tchar\t   *ptr = *s;\n\tint\t\t\tprefixlen = strlen(prefix);\n\n\tif (strncmp(ptr, prefix, prefixlen) != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid snapshot data in file \\\"%s\\\"\", filename)));\n\tptr += prefixlen;\n\tif (sscanf(ptr, \"%d/%u\", &vxid->backendId, &vxid->localTransactionId) != 2)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid snapshot data in file \\\"%s\\\"\", filename)));\n\tptr = strchr(ptr, '\\n');\n\tif (!ptr)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid snapshot data in file \\\"%s\\\"\", filename)));\n\t*s = ptr + 1;\n}"
  },
  {
    "function_name": "parseXidFromText",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
    "lines": "1374-1397",
    "snippet": "static TransactionId\nparseXidFromText(const char *prefix, char **s, const char *filename)\n{\n\tchar\t   *ptr = *s;\n\tint\t\t\tprefixlen = strlen(prefix);\n\tTransactionId val;\n\n\tif (strncmp(ptr, prefix, prefixlen) != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid snapshot data in file \\\"%s\\\"\", filename)));\n\tptr += prefixlen;\n\tif (sscanf(ptr, \"%u\", &val) != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid snapshot data in file \\\"%s\\\"\", filename)));\n\tptr = strchr(ptr, '\\n');\n\tif (!ptr)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid snapshot data in file \\\"%s\\\"\", filename)));\n\t*s = ptr + 1;\n\treturn val;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/spin.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/pairingheap.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Snapshot CopySnapshot(Snapshot snapshot);",
      "static void FreeSnapshot(Snapshot snapshot);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid snapshot data in file \\\"%s\\\"\", filename))"
          ],
          "line": 1392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid snapshot data in file \\\"%s\\\"\"",
            "filename"
          ],
          "line": 1394
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_TEXT_REPRESENTATION"
          ],
          "line": 1393
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "ptr",
            "'\\n'"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid snapshot data in file \\\"%s\\\"\", filename))"
          ],
          "line": 1387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "ptr",
            "\"%u\"",
            "&val"
          ],
          "line": 1386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid snapshot data in file \\\"%s\\\"\", filename))"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "prefix",
            "prefixlen"
          ],
          "line": 1381
        },
        "resolved": true,
        "details": {
          "function_name": "pg_char_and_wchar_strncmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wstrncmp.c",
          "lines": "54-67",
          "snippet": "int\npg_char_and_wchar_strncmp(const char *s1, const pg_wchar *s2, size_t n)\n{\n\tif (n == 0)\n\t\treturn 0;\n\tdo\n\t{\n\t\tif ((pg_wchar) ((unsigned char) *s1) != *s2++)\n\t\t\treturn ((pg_wchar) ((unsigned char) *s1) - *(s2 - 1));\n\t\tif (*s1++ == 0)\n\t\t\tbreak;\n\t} while (--n != 0);\n\treturn 0;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres_fe.h\"\n\nint\npg_char_and_wchar_strncmp(const char *s1, const pg_wchar *s2, size_t n)\n{\n\tif (n == 0)\n\t\treturn 0;\n\tdo\n\t{\n\t\tif ((pg_wchar) ((unsigned char) *s1) != *s2++)\n\t\t\treturn ((pg_wchar) ((unsigned char) *s1) - *(s2 - 1));\n\t\tif (*s1++ == 0)\n\t\t\tbreak;\n\t} while (--n != 0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "prefix"
          ],
          "line": 1378
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic Snapshot CopySnapshot(Snapshot snapshot);\nstatic void FreeSnapshot(Snapshot snapshot);\n\nstatic TransactionId\nparseXidFromText(const char *prefix, char **s, const char *filename)\n{\n\tchar\t   *ptr = *s;\n\tint\t\t\tprefixlen = strlen(prefix);\n\tTransactionId val;\n\n\tif (strncmp(ptr, prefix, prefixlen) != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid snapshot data in file \\\"%s\\\"\", filename)));\n\tptr += prefixlen;\n\tif (sscanf(ptr, \"%u\", &val) != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid snapshot data in file \\\"%s\\\"\", filename)));\n\tptr = strchr(ptr, '\\n');\n\tif (!ptr)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid snapshot data in file \\\"%s\\\"\", filename)));\n\t*s = ptr + 1;\n\treturn val;\n}"
  },
  {
    "function_name": "parseIntFromText",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
    "lines": "1349-1372",
    "snippet": "static int\nparseIntFromText(const char *prefix, char **s, const char *filename)\n{\n\tchar\t   *ptr = *s;\n\tint\t\t\tprefixlen = strlen(prefix);\n\tint\t\t\tval;\n\n\tif (strncmp(ptr, prefix, prefixlen) != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid snapshot data in file \\\"%s\\\"\", filename)));\n\tptr += prefixlen;\n\tif (sscanf(ptr, \"%d\", &val) != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid snapshot data in file \\\"%s\\\"\", filename)));\n\tptr = strchr(ptr, '\\n');\n\tif (!ptr)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid snapshot data in file \\\"%s\\\"\", filename)));\n\t*s = ptr + 1;\n\treturn val;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/spin.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/pairingheap.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Snapshot CopySnapshot(Snapshot snapshot);",
      "static void FreeSnapshot(Snapshot snapshot);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid snapshot data in file \\\"%s\\\"\", filename))"
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid snapshot data in file \\\"%s\\\"\"",
            "filename"
          ],
          "line": 1369
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_TEXT_REPRESENTATION"
          ],
          "line": 1368
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "ptr",
            "'\\n'"
          ],
          "line": 1365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid snapshot data in file \\\"%s\\\"\", filename))"
          ],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "ptr",
            "\"%d\"",
            "&val"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid snapshot data in file \\\"%s\\\"\", filename))"
          ],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "prefix",
            "prefixlen"
          ],
          "line": 1356
        },
        "resolved": true,
        "details": {
          "function_name": "pg_char_and_wchar_strncmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wstrncmp.c",
          "lines": "54-67",
          "snippet": "int\npg_char_and_wchar_strncmp(const char *s1, const pg_wchar *s2, size_t n)\n{\n\tif (n == 0)\n\t\treturn 0;\n\tdo\n\t{\n\t\tif ((pg_wchar) ((unsigned char) *s1) != *s2++)\n\t\t\treturn ((pg_wchar) ((unsigned char) *s1) - *(s2 - 1));\n\t\tif (*s1++ == 0)\n\t\t\tbreak;\n\t} while (--n != 0);\n\treturn 0;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres_fe.h\"\n\nint\npg_char_and_wchar_strncmp(const char *s1, const pg_wchar *s2, size_t n)\n{\n\tif (n == 0)\n\t\treturn 0;\n\tdo\n\t{\n\t\tif ((pg_wchar) ((unsigned char) *s1) != *s2++)\n\t\t\treturn ((pg_wchar) ((unsigned char) *s1) - *(s2 - 1));\n\t\tif (*s1++ == 0)\n\t\t\tbreak;\n\t} while (--n != 0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "prefix"
          ],
          "line": 1353
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic Snapshot CopySnapshot(Snapshot snapshot);\nstatic void FreeSnapshot(Snapshot snapshot);\n\nstatic int\nparseIntFromText(const char *prefix, char **s, const char *filename)\n{\n\tchar\t   *ptr = *s;\n\tint\t\t\tprefixlen = strlen(prefix);\n\tint\t\t\tval;\n\n\tif (strncmp(ptr, prefix, prefixlen) != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid snapshot data in file \\\"%s\\\"\", filename)));\n\tptr += prefixlen;\n\tif (sscanf(ptr, \"%d\", &val) != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid snapshot data in file \\\"%s\\\"\", filename)));\n\tptr = strchr(ptr, '\\n');\n\tif (!ptr)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid snapshot data in file \\\"%s\\\"\", filename)));\n\t*s = ptr + 1;\n\treturn val;\n}"
  },
  {
    "function_name": "pg_export_snapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
    "lines": "1334-1341",
    "snippet": "Datum\npg_export_snapshot(PG_FUNCTION_ARGS)\n{\n\tchar\t   *snapshotName;\n\n\tsnapshotName = ExportSnapshot(GetActiveSnapshot());\n\tPG_RETURN_TEXT_P(cstring_to_text(snapshotName));\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/spin.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/pairingheap.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "cstring_to_text(snapshotName)"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cstring_to_text",
          "args": [
            "snapshotName"
          ],
          "line": 1340
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "148-152",
          "snippet": "text *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ExportSnapshot",
          "args": [
            "GetActiveSnapshot()"
          ],
          "line": 1339
        },
        "resolved": true,
        "details": {
          "function_name": "ExportSnapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "1158-1328",
          "snippet": "char *\nExportSnapshot(Snapshot snapshot)\n{\n\tTransactionId topXid;\n\tTransactionId *children;\n\tExportedSnapshot *esnap;\n\tint\t\t\tnchildren;\n\tint\t\t\taddTopXid;\n\tStringInfoData buf;\n\tFILE\t   *f;\n\tint\t\t\ti;\n\tMemoryContext oldcxt;\n\tchar\t\tpath[MAXPGPATH];\n\tchar\t\tpathtmp[MAXPGPATH];\n\n\t/*\n\t * It's tempting to call RequireTransactionBlock here, since it's not very\n\t * useful to export a snapshot that will disappear immediately afterwards.\n\t * However, we haven't got enough information to do that, since we don't\n\t * know if we're at top level or not.  For example, we could be inside a\n\t * plpgsql function that is going to fire off other transactions via\n\t * dblink.  Rather than disallow perfectly legitimate usages, don't make a\n\t * check.\n\t *\n\t * Also note that we don't make any restriction on the transaction's\n\t * isolation level; however, importers must check the level if they are\n\t * serializable.\n\t */\n\n\t/*\n\t * Get our transaction ID if there is one, to include in the snapshot.\n\t */\n\ttopXid = GetTopTransactionIdIfAny();\n\n\t/*\n\t * We cannot export a snapshot from a subtransaction because there's no\n\t * easy way for importers to verify that the same subtransaction is still\n\t * running.\n\t */\n\tif (IsSubTransaction())\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ACTIVE_SQL_TRANSACTION),\n\t\t\t\t errmsg(\"cannot export a snapshot from a subtransaction\")));\n\n\t/*\n\t * We do however allow previous committed subtransactions to exist.\n\t * Importers of the snapshot must see them as still running, so get their\n\t * XIDs to add them to the snapshot.\n\t */\n\tnchildren = xactGetCommittedChildren(&children);\n\n\t/*\n\t * Generate file path for the snapshot.  We start numbering of snapshots\n\t * inside the transaction from 1.\n\t */\n\tsnprintf(path, sizeof(path), SNAPSHOT_EXPORT_DIR \"/%08X-%08X-%d\",\n\t\t\t MyProc->backendId, MyProc->lxid, list_length(exportedSnapshots) + 1);\n\n\t/*\n\t * Copy the snapshot into TopTransactionContext, add it to the\n\t * exportedSnapshots list, and mark it pseudo-registered.  We do this to\n\t * ensure that the snapshot's xmin is honored for the rest of the\n\t * transaction.\n\t */\n\tsnapshot = CopySnapshot(snapshot);\n\n\toldcxt = MemoryContextSwitchTo(TopTransactionContext);\n\tesnap = (ExportedSnapshot *) palloc(sizeof(ExportedSnapshot));\n\tesnap->snapfile = pstrdup(path);\n\tesnap->snapshot = snapshot;\n\texportedSnapshots = lappend(exportedSnapshots, esnap);\n\tMemoryContextSwitchTo(oldcxt);\n\n\tsnapshot->regd_count++;\n\tpairingheap_add(&RegisteredSnapshots, &snapshot->ph_node);\n\n\t/*\n\t * Fill buf with a text serialization of the snapshot, plus identification\n\t * data about this transaction.  The format expected by ImportSnapshot is\n\t * pretty rigid: each line must be fieldname:value.\n\t */\n\tinitStringInfo(&buf);\n\n\tappendStringInfo(&buf, \"vxid:%d/%u\\n\", MyProc->backendId, MyProc->lxid);\n\tappendStringInfo(&buf, \"pid:%d\\n\", MyProcPid);\n\tappendStringInfo(&buf, \"dbid:%u\\n\", MyDatabaseId);\n\tappendStringInfo(&buf, \"iso:%d\\n\", XactIsoLevel);\n\tappendStringInfo(&buf, \"ro:%d\\n\", XactReadOnly);\n\n\tappendStringInfo(&buf, \"xmin:%u\\n\", snapshot->xmin);\n\tappendStringInfo(&buf, \"xmax:%u\\n\", snapshot->xmax);\n\n\t/*\n\t * We must include our own top transaction ID in the top-xid data, since\n\t * by definition we will still be running when the importing transaction\n\t * adopts the snapshot, but GetSnapshotData never includes our own XID in\n\t * the snapshot.  (There must, therefore, be enough room to add it.)\n\t *\n\t * However, it could be that our topXid is after the xmax, in which case\n\t * we shouldn't include it because xip[] members are expected to be before\n\t * xmax.  (We need not make the same check for subxip[] members, see\n\t * snapshot.h.)\n\t */\n\taddTopXid = (TransactionIdIsValid(topXid) &&\n\t\t\t\t TransactionIdPrecedes(topXid, snapshot->xmax)) ? 1 : 0;\n\tappendStringInfo(&buf, \"xcnt:%d\\n\", snapshot->xcnt + addTopXid);\n\tfor (i = 0; i < snapshot->xcnt; i++)\n\t\tappendStringInfo(&buf, \"xip:%u\\n\", snapshot->xip[i]);\n\tif (addTopXid)\n\t\tappendStringInfo(&buf, \"xip:%u\\n\", topXid);\n\n\t/*\n\t * Similarly, we add our subcommitted child XIDs to the subxid data. Here,\n\t * we have to cope with possible overflow.\n\t */\n\tif (snapshot->suboverflowed ||\n\t\tsnapshot->subxcnt + nchildren > GetMaxSnapshotSubxidCount())\n\t\tappendStringInfoString(&buf, \"sof:1\\n\");\n\telse\n\t{\n\t\tappendStringInfoString(&buf, \"sof:0\\n\");\n\t\tappendStringInfo(&buf, \"sxcnt:%d\\n\", snapshot->subxcnt + nchildren);\n\t\tfor (i = 0; i < snapshot->subxcnt; i++)\n\t\t\tappendStringInfo(&buf, \"sxp:%u\\n\", snapshot->subxip[i]);\n\t\tfor (i = 0; i < nchildren; i++)\n\t\t\tappendStringInfo(&buf, \"sxp:%u\\n\", children[i]);\n\t}\n\tappendStringInfo(&buf, \"rec:%u\\n\", snapshot->takenDuringRecovery);\n\n\t/*\n\t * Now write the text representation into a file.  We first write to a\n\t * \".tmp\" filename, and rename to final filename if no error.  This\n\t * ensures that no other backend can read an incomplete file\n\t * (ImportSnapshot won't allow it because of its valid-characters check).\n\t */\n\tsnprintf(pathtmp, sizeof(pathtmp), \"%s.tmp\", path);\n\tif (!(f = AllocateFile(pathtmp, PG_BINARY_W)))\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not create file \\\"%s\\\": %m\", pathtmp)));\n\n\tif (fwrite(buf.data, buf.len, 1, f) != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write to file \\\"%s\\\": %m\", pathtmp)));\n\n\t/* no fsync() since file need not survive a system crash */\n\n\tif (FreeFile(f))\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write to file \\\"%s\\\": %m\", pathtmp)));\n\n\t/*\n\t * Now that we have written everything into a .tmp file, rename the file\n\t * to remove the .tmp suffix.\n\t */\n\tif (rename(pathtmp, path) < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not rename file \\\"%s\\\" to \\\"%s\\\": %m\",\n\t\t\t\t\t\tpathtmp, path)));\n\n\t/*\n\t * The basename of the file is what we return from pg_export_snapshot().\n\t * It's already in path in a textual format and we know that the path\n\t * starts with SNAPSHOT_EXPORT_DIR.  Skip over the prefix and the slash\n\t * and pstrdup it so as not to return the address of a local variable.\n\t */\n\treturn pstrdup(path + strlen(SNAPSHOT_EXPORT_DIR) + 1);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define SNAPSHOT_EXPORT_DIR \"pg_snapshots\""
          ],
          "globals_used": [
            "static pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};",
            "static List *exportedSnapshots = NIL;",
            "static Snapshot CopySnapshot(Snapshot snapshot);",
            "static void FreeSnapshot(Snapshot snapshot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\n#define SNAPSHOT_EXPORT_DIR \"pg_snapshots\"\n\nstatic pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};\nstatic List *exportedSnapshots = NIL;\nstatic Snapshot CopySnapshot(Snapshot snapshot);\nstatic void FreeSnapshot(Snapshot snapshot);\n\nchar *\nExportSnapshot(Snapshot snapshot)\n{\n\tTransactionId topXid;\n\tTransactionId *children;\n\tExportedSnapshot *esnap;\n\tint\t\t\tnchildren;\n\tint\t\t\taddTopXid;\n\tStringInfoData buf;\n\tFILE\t   *f;\n\tint\t\t\ti;\n\tMemoryContext oldcxt;\n\tchar\t\tpath[MAXPGPATH];\n\tchar\t\tpathtmp[MAXPGPATH];\n\n\t/*\n\t * It's tempting to call RequireTransactionBlock here, since it's not very\n\t * useful to export a snapshot that will disappear immediately afterwards.\n\t * However, we haven't got enough information to do that, since we don't\n\t * know if we're at top level or not.  For example, we could be inside a\n\t * plpgsql function that is going to fire off other transactions via\n\t * dblink.  Rather than disallow perfectly legitimate usages, don't make a\n\t * check.\n\t *\n\t * Also note that we don't make any restriction on the transaction's\n\t * isolation level; however, importers must check the level if they are\n\t * serializable.\n\t */\n\n\t/*\n\t * Get our transaction ID if there is one, to include in the snapshot.\n\t */\n\ttopXid = GetTopTransactionIdIfAny();\n\n\t/*\n\t * We cannot export a snapshot from a subtransaction because there's no\n\t * easy way for importers to verify that the same subtransaction is still\n\t * running.\n\t */\n\tif (IsSubTransaction())\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ACTIVE_SQL_TRANSACTION),\n\t\t\t\t errmsg(\"cannot export a snapshot from a subtransaction\")));\n\n\t/*\n\t * We do however allow previous committed subtransactions to exist.\n\t * Importers of the snapshot must see them as still running, so get their\n\t * XIDs to add them to the snapshot.\n\t */\n\tnchildren = xactGetCommittedChildren(&children);\n\n\t/*\n\t * Generate file path for the snapshot.  We start numbering of snapshots\n\t * inside the transaction from 1.\n\t */\n\tsnprintf(path, sizeof(path), SNAPSHOT_EXPORT_DIR \"/%08X-%08X-%d\",\n\t\t\t MyProc->backendId, MyProc->lxid, list_length(exportedSnapshots) + 1);\n\n\t/*\n\t * Copy the snapshot into TopTransactionContext, add it to the\n\t * exportedSnapshots list, and mark it pseudo-registered.  We do this to\n\t * ensure that the snapshot's xmin is honored for the rest of the\n\t * transaction.\n\t */\n\tsnapshot = CopySnapshot(snapshot);\n\n\toldcxt = MemoryContextSwitchTo(TopTransactionContext);\n\tesnap = (ExportedSnapshot *) palloc(sizeof(ExportedSnapshot));\n\tesnap->snapfile = pstrdup(path);\n\tesnap->snapshot = snapshot;\n\texportedSnapshots = lappend(exportedSnapshots, esnap);\n\tMemoryContextSwitchTo(oldcxt);\n\n\tsnapshot->regd_count++;\n\tpairingheap_add(&RegisteredSnapshots, &snapshot->ph_node);\n\n\t/*\n\t * Fill buf with a text serialization of the snapshot, plus identification\n\t * data about this transaction.  The format expected by ImportSnapshot is\n\t * pretty rigid: each line must be fieldname:value.\n\t */\n\tinitStringInfo(&buf);\n\n\tappendStringInfo(&buf, \"vxid:%d/%u\\n\", MyProc->backendId, MyProc->lxid);\n\tappendStringInfo(&buf, \"pid:%d\\n\", MyProcPid);\n\tappendStringInfo(&buf, \"dbid:%u\\n\", MyDatabaseId);\n\tappendStringInfo(&buf, \"iso:%d\\n\", XactIsoLevel);\n\tappendStringInfo(&buf, \"ro:%d\\n\", XactReadOnly);\n\n\tappendStringInfo(&buf, \"xmin:%u\\n\", snapshot->xmin);\n\tappendStringInfo(&buf, \"xmax:%u\\n\", snapshot->xmax);\n\n\t/*\n\t * We must include our own top transaction ID in the top-xid data, since\n\t * by definition we will still be running when the importing transaction\n\t * adopts the snapshot, but GetSnapshotData never includes our own XID in\n\t * the snapshot.  (There must, therefore, be enough room to add it.)\n\t *\n\t * However, it could be that our topXid is after the xmax, in which case\n\t * we shouldn't include it because xip[] members are expected to be before\n\t * xmax.  (We need not make the same check for subxip[] members, see\n\t * snapshot.h.)\n\t */\n\taddTopXid = (TransactionIdIsValid(topXid) &&\n\t\t\t\t TransactionIdPrecedes(topXid, snapshot->xmax)) ? 1 : 0;\n\tappendStringInfo(&buf, \"xcnt:%d\\n\", snapshot->xcnt + addTopXid);\n\tfor (i = 0; i < snapshot->xcnt; i++)\n\t\tappendStringInfo(&buf, \"xip:%u\\n\", snapshot->xip[i]);\n\tif (addTopXid)\n\t\tappendStringInfo(&buf, \"xip:%u\\n\", topXid);\n\n\t/*\n\t * Similarly, we add our subcommitted child XIDs to the subxid data. Here,\n\t * we have to cope with possible overflow.\n\t */\n\tif (snapshot->suboverflowed ||\n\t\tsnapshot->subxcnt + nchildren > GetMaxSnapshotSubxidCount())\n\t\tappendStringInfoString(&buf, \"sof:1\\n\");\n\telse\n\t{\n\t\tappendStringInfoString(&buf, \"sof:0\\n\");\n\t\tappendStringInfo(&buf, \"sxcnt:%d\\n\", snapshot->subxcnt + nchildren);\n\t\tfor (i = 0; i < snapshot->subxcnt; i++)\n\t\t\tappendStringInfo(&buf, \"sxp:%u\\n\", snapshot->subxip[i]);\n\t\tfor (i = 0; i < nchildren; i++)\n\t\t\tappendStringInfo(&buf, \"sxp:%u\\n\", children[i]);\n\t}\n\tappendStringInfo(&buf, \"rec:%u\\n\", snapshot->takenDuringRecovery);\n\n\t/*\n\t * Now write the text representation into a file.  We first write to a\n\t * \".tmp\" filename, and rename to final filename if no error.  This\n\t * ensures that no other backend can read an incomplete file\n\t * (ImportSnapshot won't allow it because of its valid-characters check).\n\t */\n\tsnprintf(pathtmp, sizeof(pathtmp), \"%s.tmp\", path);\n\tif (!(f = AllocateFile(pathtmp, PG_BINARY_W)))\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not create file \\\"%s\\\": %m\", pathtmp)));\n\n\tif (fwrite(buf.data, buf.len, 1, f) != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write to file \\\"%s\\\": %m\", pathtmp)));\n\n\t/* no fsync() since file need not survive a system crash */\n\n\tif (FreeFile(f))\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write to file \\\"%s\\\": %m\", pathtmp)));\n\n\t/*\n\t * Now that we have written everything into a .tmp file, rename the file\n\t * to remove the .tmp suffix.\n\t */\n\tif (rename(pathtmp, path) < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not rename file \\\"%s\\\" to \\\"%s\\\": %m\",\n\t\t\t\t\t\tpathtmp, path)));\n\n\t/*\n\t * The basename of the file is what we return from pg_export_snapshot().\n\t * It's already in path in a textual format and we know that the path\n\t * starts with SNAPSHOT_EXPORT_DIR.  Skip over the prefix and the slash\n\t * and pstrdup it so as not to return the address of a local variable.\n\t */\n\treturn pstrdup(path + strlen(SNAPSHOT_EXPORT_DIR) + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetActiveSnapshot",
          "args": [],
          "line": 1339
        },
        "resolved": true,
        "details": {
          "function_name": "GetActiveSnapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "838-844",
          "snippet": "Snapshot\nGetActiveSnapshot(void)\n{\n\tAssert(ActiveSnapshot != NULL);\n\n\treturn ActiveSnapshot->as_snap;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ActiveSnapshotElt *ActiveSnapshot = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic ActiveSnapshotElt *ActiveSnapshot = NULL;\n\nSnapshot\nGetActiveSnapshot(void)\n{\n\tAssert(ActiveSnapshot != NULL);\n\n\treturn ActiveSnapshot->as_snap;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nDatum\npg_export_snapshot(PG_FUNCTION_ARGS)\n{\n\tchar\t   *snapshotName;\n\n\tsnapshotName = ExportSnapshot(GetActiveSnapshot());\n\tPG_RETURN_TEXT_P(cstring_to_text(snapshotName));\n}"
  },
  {
    "function_name": "ExportSnapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
    "lines": "1158-1328",
    "snippet": "char *\nExportSnapshot(Snapshot snapshot)\n{\n\tTransactionId topXid;\n\tTransactionId *children;\n\tExportedSnapshot *esnap;\n\tint\t\t\tnchildren;\n\tint\t\t\taddTopXid;\n\tStringInfoData buf;\n\tFILE\t   *f;\n\tint\t\t\ti;\n\tMemoryContext oldcxt;\n\tchar\t\tpath[MAXPGPATH];\n\tchar\t\tpathtmp[MAXPGPATH];\n\n\t/*\n\t * It's tempting to call RequireTransactionBlock here, since it's not very\n\t * useful to export a snapshot that will disappear immediately afterwards.\n\t * However, we haven't got enough information to do that, since we don't\n\t * know if we're at top level or not.  For example, we could be inside a\n\t * plpgsql function that is going to fire off other transactions via\n\t * dblink.  Rather than disallow perfectly legitimate usages, don't make a\n\t * check.\n\t *\n\t * Also note that we don't make any restriction on the transaction's\n\t * isolation level; however, importers must check the level if they are\n\t * serializable.\n\t */\n\n\t/*\n\t * Get our transaction ID if there is one, to include in the snapshot.\n\t */\n\ttopXid = GetTopTransactionIdIfAny();\n\n\t/*\n\t * We cannot export a snapshot from a subtransaction because there's no\n\t * easy way for importers to verify that the same subtransaction is still\n\t * running.\n\t */\n\tif (IsSubTransaction())\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ACTIVE_SQL_TRANSACTION),\n\t\t\t\t errmsg(\"cannot export a snapshot from a subtransaction\")));\n\n\t/*\n\t * We do however allow previous committed subtransactions to exist.\n\t * Importers of the snapshot must see them as still running, so get their\n\t * XIDs to add them to the snapshot.\n\t */\n\tnchildren = xactGetCommittedChildren(&children);\n\n\t/*\n\t * Generate file path for the snapshot.  We start numbering of snapshots\n\t * inside the transaction from 1.\n\t */\n\tsnprintf(path, sizeof(path), SNAPSHOT_EXPORT_DIR \"/%08X-%08X-%d\",\n\t\t\t MyProc->backendId, MyProc->lxid, list_length(exportedSnapshots) + 1);\n\n\t/*\n\t * Copy the snapshot into TopTransactionContext, add it to the\n\t * exportedSnapshots list, and mark it pseudo-registered.  We do this to\n\t * ensure that the snapshot's xmin is honored for the rest of the\n\t * transaction.\n\t */\n\tsnapshot = CopySnapshot(snapshot);\n\n\toldcxt = MemoryContextSwitchTo(TopTransactionContext);\n\tesnap = (ExportedSnapshot *) palloc(sizeof(ExportedSnapshot));\n\tesnap->snapfile = pstrdup(path);\n\tesnap->snapshot = snapshot;\n\texportedSnapshots = lappend(exportedSnapshots, esnap);\n\tMemoryContextSwitchTo(oldcxt);\n\n\tsnapshot->regd_count++;\n\tpairingheap_add(&RegisteredSnapshots, &snapshot->ph_node);\n\n\t/*\n\t * Fill buf with a text serialization of the snapshot, plus identification\n\t * data about this transaction.  The format expected by ImportSnapshot is\n\t * pretty rigid: each line must be fieldname:value.\n\t */\n\tinitStringInfo(&buf);\n\n\tappendStringInfo(&buf, \"vxid:%d/%u\\n\", MyProc->backendId, MyProc->lxid);\n\tappendStringInfo(&buf, \"pid:%d\\n\", MyProcPid);\n\tappendStringInfo(&buf, \"dbid:%u\\n\", MyDatabaseId);\n\tappendStringInfo(&buf, \"iso:%d\\n\", XactIsoLevel);\n\tappendStringInfo(&buf, \"ro:%d\\n\", XactReadOnly);\n\n\tappendStringInfo(&buf, \"xmin:%u\\n\", snapshot->xmin);\n\tappendStringInfo(&buf, \"xmax:%u\\n\", snapshot->xmax);\n\n\t/*\n\t * We must include our own top transaction ID in the top-xid data, since\n\t * by definition we will still be running when the importing transaction\n\t * adopts the snapshot, but GetSnapshotData never includes our own XID in\n\t * the snapshot.  (There must, therefore, be enough room to add it.)\n\t *\n\t * However, it could be that our topXid is after the xmax, in which case\n\t * we shouldn't include it because xip[] members are expected to be before\n\t * xmax.  (We need not make the same check for subxip[] members, see\n\t * snapshot.h.)\n\t */\n\taddTopXid = (TransactionIdIsValid(topXid) &&\n\t\t\t\t TransactionIdPrecedes(topXid, snapshot->xmax)) ? 1 : 0;\n\tappendStringInfo(&buf, \"xcnt:%d\\n\", snapshot->xcnt + addTopXid);\n\tfor (i = 0; i < snapshot->xcnt; i++)\n\t\tappendStringInfo(&buf, \"xip:%u\\n\", snapshot->xip[i]);\n\tif (addTopXid)\n\t\tappendStringInfo(&buf, \"xip:%u\\n\", topXid);\n\n\t/*\n\t * Similarly, we add our subcommitted child XIDs to the subxid data. Here,\n\t * we have to cope with possible overflow.\n\t */\n\tif (snapshot->suboverflowed ||\n\t\tsnapshot->subxcnt + nchildren > GetMaxSnapshotSubxidCount())\n\t\tappendStringInfoString(&buf, \"sof:1\\n\");\n\telse\n\t{\n\t\tappendStringInfoString(&buf, \"sof:0\\n\");\n\t\tappendStringInfo(&buf, \"sxcnt:%d\\n\", snapshot->subxcnt + nchildren);\n\t\tfor (i = 0; i < snapshot->subxcnt; i++)\n\t\t\tappendStringInfo(&buf, \"sxp:%u\\n\", snapshot->subxip[i]);\n\t\tfor (i = 0; i < nchildren; i++)\n\t\t\tappendStringInfo(&buf, \"sxp:%u\\n\", children[i]);\n\t}\n\tappendStringInfo(&buf, \"rec:%u\\n\", snapshot->takenDuringRecovery);\n\n\t/*\n\t * Now write the text representation into a file.  We first write to a\n\t * \".tmp\" filename, and rename to final filename if no error.  This\n\t * ensures that no other backend can read an incomplete file\n\t * (ImportSnapshot won't allow it because of its valid-characters check).\n\t */\n\tsnprintf(pathtmp, sizeof(pathtmp), \"%s.tmp\", path);\n\tif (!(f = AllocateFile(pathtmp, PG_BINARY_W)))\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not create file \\\"%s\\\": %m\", pathtmp)));\n\n\tif (fwrite(buf.data, buf.len, 1, f) != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write to file \\\"%s\\\": %m\", pathtmp)));\n\n\t/* no fsync() since file need not survive a system crash */\n\n\tif (FreeFile(f))\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write to file \\\"%s\\\": %m\", pathtmp)));\n\n\t/*\n\t * Now that we have written everything into a .tmp file, rename the file\n\t * to remove the .tmp suffix.\n\t */\n\tif (rename(pathtmp, path) < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not rename file \\\"%s\\\" to \\\"%s\\\": %m\",\n\t\t\t\t\t\tpathtmp, path)));\n\n\t/*\n\t * The basename of the file is what we return from pg_export_snapshot().\n\t * It's already in path in a textual format and we know that the path\n\t * starts with SNAPSHOT_EXPORT_DIR.  Skip over the prefix and the slash\n\t * and pstrdup it so as not to return the address of a local variable.\n\t */\n\treturn pstrdup(path + strlen(SNAPSHOT_EXPORT_DIR) + 1);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/spin.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/pairingheap.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define SNAPSHOT_EXPORT_DIR \"pg_snapshots\""
    ],
    "globals_used": [
      "static pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};",
      "static List *exportedSnapshots = NIL;",
      "static Snapshot CopySnapshot(Snapshot snapshot);",
      "static void FreeSnapshot(Snapshot snapshot);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pstrdup",
          "args": [
            "path + strlen(SNAPSHOT_EXPORT_DIR) + 1"
          ],
          "line": 1327
        },
        "resolved": true,
        "details": {
          "function_name": "pstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1160-1164",
          "snippet": "char *\npstrdup(const char *in)\n{\n\treturn MemoryContextStrdup(CurrentMemoryContext, in);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\n\nchar *\npstrdup(const char *in)\n{\n\treturn MemoryContextStrdup(CurrentMemoryContext, in);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "SNAPSHOT_EXPORT_DIR"
          ],
          "line": 1327
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not rename file \\\"%s\\\" to \\\"%s\\\": %m\",\n\t\t\t\t\t\tpathtmp, path))"
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not rename file \\\"%s\\\" to \\\"%s\\\": %m\"",
            "pathtmp",
            "path"
          ],
          "line": 1318
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode_for_file_access",
          "args": [],
          "line": 1317
        },
        "resolved": true,
        "details": {
          "function_name": "errcode_for_file_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "595-655",
          "snippet": "int\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rename",
          "args": [
            "pathtmp",
            "path"
          ],
          "line": 1315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write to file \\\"%s\\\": %m\", pathtmp))"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FreeFile",
          "args": [
            "f"
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write to file \\\"%s\\\": %m\", pathtmp))"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fwrite",
          "args": [
            "buf.data",
            "buf.len",
            "1",
            "f"
          ],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not create file \\\"%s\\\": %m\", pathtmp))"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocateFile",
          "args": [
            "pathtmp",
            "PG_BINARY_W"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "pathtmp",
            "sizeof(pathtmp)",
            "\"%s.tmp\"",
            "path"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&buf",
            "\"rec:%u\\n\"",
            "snapshot->takenDuringRecovery"
          ],
          "line": 1285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&buf",
            "\"sxp:%u\\n\"",
            "children[i]"
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&buf",
            "\"sxp:%u\\n\"",
            "snapshot->subxip[i]"
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&buf",
            "\"sxcnt:%d\\n\"",
            "snapshot->subxcnt + nchildren"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&buf",
            "\"sof:0\\n\""
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&buf",
            "\"sof:1\\n\""
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetMaxSnapshotSubxidCount",
          "args": [],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&buf",
            "\"xip:%u\\n\"",
            "topXid"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&buf",
            "\"xip:%u\\n\"",
            "snapshot->xip[i]"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&buf",
            "\"xcnt:%d\\n\"",
            "snapshot->xcnt + addTopXid"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdPrecedes",
          "args": [
            "topXid",
            "snapshot->xmax"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsValid",
          "args": [
            "topXid"
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&buf",
            "\"xmax:%u\\n\"",
            "snapshot->xmax"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&buf",
            "\"xmin:%u\\n\"",
            "snapshot->xmin"
          ],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&buf",
            "\"ro:%d\\n\"",
            "XactReadOnly"
          ],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&buf",
            "\"iso:%d\\n\"",
            "XactIsoLevel"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&buf",
            "\"dbid:%u\\n\"",
            "MyDatabaseId"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&buf",
            "\"pid:%d\\n\"",
            "MyProcPid"
          ],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&buf",
            "\"vxid:%d/%u\\n\"",
            "MyProc->backendId",
            "MyProc->lxid"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initStringInfo",
          "args": [
            "&buf"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pairingheap_add",
          "args": [
            "&RegisteredSnapshots",
            "&snapshot->ph_node"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcxt"
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lappend",
          "args": [
            "exportedSnapshots",
            "esnap"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(ExportedSnapshot)"
          ],
          "line": 1225
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "TopTransactionContext"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CopySnapshot",
          "args": [
            "snapshot"
          ],
          "line": 1222
        },
        "resolved": true,
        "details": {
          "function_name": "CopySnapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "659-708",
          "snippet": "static Snapshot\nCopySnapshot(Snapshot snapshot)\n{\n\tSnapshot\tnewsnap;\n\tSize\t\tsubxipoff;\n\tSize\t\tsize;\n\n\tAssert(snapshot != InvalidSnapshot);\n\n\t/* We allocate any XID arrays needed in the same palloc block. */\n\tsize = subxipoff = sizeof(SnapshotData) +\n\t\tsnapshot->xcnt * sizeof(TransactionId);\n\tif (snapshot->subxcnt > 0)\n\t\tsize += snapshot->subxcnt * sizeof(TransactionId);\n\n\tnewsnap = (Snapshot) MemoryContextAlloc(TopTransactionContext, size);\n\tmemcpy(newsnap, snapshot, sizeof(SnapshotData));\n\n\tnewsnap->regd_count = 0;\n\tnewsnap->active_count = 0;\n\tnewsnap->copied = true;\n\n\t/* setup XID array */\n\tif (snapshot->xcnt > 0)\n\t{\n\t\tnewsnap->xip = (TransactionId *) (newsnap + 1);\n\t\tmemcpy(newsnap->xip, snapshot->xip,\n\t\t\t   snapshot->xcnt * sizeof(TransactionId));\n\t}\n\telse\n\t\tnewsnap->xip = NULL;\n\n\t/*\n\t * Setup subXID array. Don't bother to copy it if it had overflowed,\n\t * though, because it's not used anywhere in that case. Except if it's a\n\t * snapshot taken during recovery; all the top-level XIDs are in subxip as\n\t * well in that case, so we mustn't lose them.\n\t */\n\tif (snapshot->subxcnt > 0 &&\n\t\t(!snapshot->suboverflowed || snapshot->takenDuringRecovery))\n\t{\n\t\tnewsnap->subxip = (TransactionId *) ((char *) newsnap + subxipoff);\n\t\tmemcpy(newsnap->subxip, snapshot->subxip,\n\t\t\t   snapshot->subxcnt * sizeof(TransactionId));\n\t}\n\telse\n\t\tnewsnap->subxip = NULL;\n\n\treturn newsnap;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Snapshot CopySnapshot(Snapshot snapshot);",
            "static void FreeSnapshot(Snapshot snapshot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic Snapshot CopySnapshot(Snapshot snapshot);\nstatic void FreeSnapshot(Snapshot snapshot);\n\nstatic Snapshot\nCopySnapshot(Snapshot snapshot)\n{\n\tSnapshot\tnewsnap;\n\tSize\t\tsubxipoff;\n\tSize\t\tsize;\n\n\tAssert(snapshot != InvalidSnapshot);\n\n\t/* We allocate any XID arrays needed in the same palloc block. */\n\tsize = subxipoff = sizeof(SnapshotData) +\n\t\tsnapshot->xcnt * sizeof(TransactionId);\n\tif (snapshot->subxcnt > 0)\n\t\tsize += snapshot->subxcnt * sizeof(TransactionId);\n\n\tnewsnap = (Snapshot) MemoryContextAlloc(TopTransactionContext, size);\n\tmemcpy(newsnap, snapshot, sizeof(SnapshotData));\n\n\tnewsnap->regd_count = 0;\n\tnewsnap->active_count = 0;\n\tnewsnap->copied = true;\n\n\t/* setup XID array */\n\tif (snapshot->xcnt > 0)\n\t{\n\t\tnewsnap->xip = (TransactionId *) (newsnap + 1);\n\t\tmemcpy(newsnap->xip, snapshot->xip,\n\t\t\t   snapshot->xcnt * sizeof(TransactionId));\n\t}\n\telse\n\t\tnewsnap->xip = NULL;\n\n\t/*\n\t * Setup subXID array. Don't bother to copy it if it had overflowed,\n\t * though, because it's not used anywhere in that case. Except if it's a\n\t * snapshot taken during recovery; all the top-level XIDs are in subxip as\n\t * well in that case, so we mustn't lose them.\n\t */\n\tif (snapshot->subxcnt > 0 &&\n\t\t(!snapshot->suboverflowed || snapshot->takenDuringRecovery))\n\t{\n\t\tnewsnap->subxip = (TransactionId *) ((char *) newsnap + subxipoff);\n\t\tmemcpy(newsnap->subxip, snapshot->subxip,\n\t\t\t   snapshot->subxcnt * sizeof(TransactionId));\n\t}\n\telse\n\t\tnewsnap->subxip = NULL;\n\n\treturn newsnap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "sizeof(path)",
            "SNAPSHOT_EXPORT_DIR \"/%08X-%08X-%d\"",
            "MyProc->backendId",
            "MyProc->lxid",
            "list_length(exportedSnapshots) + 1"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_length",
          "args": [
            "exportedSnapshots"
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xactGetCommittedChildren",
          "args": [
            "&children"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_ACTIVE_SQL_TRANSACTION),\n\t\t\t\t errmsg(\"cannot export a snapshot from a subtransaction\"))"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_ACTIVE_SQL_TRANSACTION"
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsSubTransaction",
          "args": [],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetTopTransactionIdIfAny",
          "args": [],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\n#define SNAPSHOT_EXPORT_DIR \"pg_snapshots\"\n\nstatic pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};\nstatic List *exportedSnapshots = NIL;\nstatic Snapshot CopySnapshot(Snapshot snapshot);\nstatic void FreeSnapshot(Snapshot snapshot);\n\nchar *\nExportSnapshot(Snapshot snapshot)\n{\n\tTransactionId topXid;\n\tTransactionId *children;\n\tExportedSnapshot *esnap;\n\tint\t\t\tnchildren;\n\tint\t\t\taddTopXid;\n\tStringInfoData buf;\n\tFILE\t   *f;\n\tint\t\t\ti;\n\tMemoryContext oldcxt;\n\tchar\t\tpath[MAXPGPATH];\n\tchar\t\tpathtmp[MAXPGPATH];\n\n\t/*\n\t * It's tempting to call RequireTransactionBlock here, since it's not very\n\t * useful to export a snapshot that will disappear immediately afterwards.\n\t * However, we haven't got enough information to do that, since we don't\n\t * know if we're at top level or not.  For example, we could be inside a\n\t * plpgsql function that is going to fire off other transactions via\n\t * dblink.  Rather than disallow perfectly legitimate usages, don't make a\n\t * check.\n\t *\n\t * Also note that we don't make any restriction on the transaction's\n\t * isolation level; however, importers must check the level if they are\n\t * serializable.\n\t */\n\n\t/*\n\t * Get our transaction ID if there is one, to include in the snapshot.\n\t */\n\ttopXid = GetTopTransactionIdIfAny();\n\n\t/*\n\t * We cannot export a snapshot from a subtransaction because there's no\n\t * easy way for importers to verify that the same subtransaction is still\n\t * running.\n\t */\n\tif (IsSubTransaction())\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ACTIVE_SQL_TRANSACTION),\n\t\t\t\t errmsg(\"cannot export a snapshot from a subtransaction\")));\n\n\t/*\n\t * We do however allow previous committed subtransactions to exist.\n\t * Importers of the snapshot must see them as still running, so get their\n\t * XIDs to add them to the snapshot.\n\t */\n\tnchildren = xactGetCommittedChildren(&children);\n\n\t/*\n\t * Generate file path for the snapshot.  We start numbering of snapshots\n\t * inside the transaction from 1.\n\t */\n\tsnprintf(path, sizeof(path), SNAPSHOT_EXPORT_DIR \"/%08X-%08X-%d\",\n\t\t\t MyProc->backendId, MyProc->lxid, list_length(exportedSnapshots) + 1);\n\n\t/*\n\t * Copy the snapshot into TopTransactionContext, add it to the\n\t * exportedSnapshots list, and mark it pseudo-registered.  We do this to\n\t * ensure that the snapshot's xmin is honored for the rest of the\n\t * transaction.\n\t */\n\tsnapshot = CopySnapshot(snapshot);\n\n\toldcxt = MemoryContextSwitchTo(TopTransactionContext);\n\tesnap = (ExportedSnapshot *) palloc(sizeof(ExportedSnapshot));\n\tesnap->snapfile = pstrdup(path);\n\tesnap->snapshot = snapshot;\n\texportedSnapshots = lappend(exportedSnapshots, esnap);\n\tMemoryContextSwitchTo(oldcxt);\n\n\tsnapshot->regd_count++;\n\tpairingheap_add(&RegisteredSnapshots, &snapshot->ph_node);\n\n\t/*\n\t * Fill buf with a text serialization of the snapshot, plus identification\n\t * data about this transaction.  The format expected by ImportSnapshot is\n\t * pretty rigid: each line must be fieldname:value.\n\t */\n\tinitStringInfo(&buf);\n\n\tappendStringInfo(&buf, \"vxid:%d/%u\\n\", MyProc->backendId, MyProc->lxid);\n\tappendStringInfo(&buf, \"pid:%d\\n\", MyProcPid);\n\tappendStringInfo(&buf, \"dbid:%u\\n\", MyDatabaseId);\n\tappendStringInfo(&buf, \"iso:%d\\n\", XactIsoLevel);\n\tappendStringInfo(&buf, \"ro:%d\\n\", XactReadOnly);\n\n\tappendStringInfo(&buf, \"xmin:%u\\n\", snapshot->xmin);\n\tappendStringInfo(&buf, \"xmax:%u\\n\", snapshot->xmax);\n\n\t/*\n\t * We must include our own top transaction ID in the top-xid data, since\n\t * by definition we will still be running when the importing transaction\n\t * adopts the snapshot, but GetSnapshotData never includes our own XID in\n\t * the snapshot.  (There must, therefore, be enough room to add it.)\n\t *\n\t * However, it could be that our topXid is after the xmax, in which case\n\t * we shouldn't include it because xip[] members are expected to be before\n\t * xmax.  (We need not make the same check for subxip[] members, see\n\t * snapshot.h.)\n\t */\n\taddTopXid = (TransactionIdIsValid(topXid) &&\n\t\t\t\t TransactionIdPrecedes(topXid, snapshot->xmax)) ? 1 : 0;\n\tappendStringInfo(&buf, \"xcnt:%d\\n\", snapshot->xcnt + addTopXid);\n\tfor (i = 0; i < snapshot->xcnt; i++)\n\t\tappendStringInfo(&buf, \"xip:%u\\n\", snapshot->xip[i]);\n\tif (addTopXid)\n\t\tappendStringInfo(&buf, \"xip:%u\\n\", topXid);\n\n\t/*\n\t * Similarly, we add our subcommitted child XIDs to the subxid data. Here,\n\t * we have to cope with possible overflow.\n\t */\n\tif (snapshot->suboverflowed ||\n\t\tsnapshot->subxcnt + nchildren > GetMaxSnapshotSubxidCount())\n\t\tappendStringInfoString(&buf, \"sof:1\\n\");\n\telse\n\t{\n\t\tappendStringInfoString(&buf, \"sof:0\\n\");\n\t\tappendStringInfo(&buf, \"sxcnt:%d\\n\", snapshot->subxcnt + nchildren);\n\t\tfor (i = 0; i < snapshot->subxcnt; i++)\n\t\t\tappendStringInfo(&buf, \"sxp:%u\\n\", snapshot->subxip[i]);\n\t\tfor (i = 0; i < nchildren; i++)\n\t\t\tappendStringInfo(&buf, \"sxp:%u\\n\", children[i]);\n\t}\n\tappendStringInfo(&buf, \"rec:%u\\n\", snapshot->takenDuringRecovery);\n\n\t/*\n\t * Now write the text representation into a file.  We first write to a\n\t * \".tmp\" filename, and rename to final filename if no error.  This\n\t * ensures that no other backend can read an incomplete file\n\t * (ImportSnapshot won't allow it because of its valid-characters check).\n\t */\n\tsnprintf(pathtmp, sizeof(pathtmp), \"%s.tmp\", path);\n\tif (!(f = AllocateFile(pathtmp, PG_BINARY_W)))\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not create file \\\"%s\\\": %m\", pathtmp)));\n\n\tif (fwrite(buf.data, buf.len, 1, f) != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write to file \\\"%s\\\": %m\", pathtmp)));\n\n\t/* no fsync() since file need not survive a system crash */\n\n\tif (FreeFile(f))\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write to file \\\"%s\\\": %m\", pathtmp)));\n\n\t/*\n\t * Now that we have written everything into a .tmp file, rename the file\n\t * to remove the .tmp suffix.\n\t */\n\tif (rename(pathtmp, path) < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not rename file \\\"%s\\\" to \\\"%s\\\": %m\",\n\t\t\t\t\t\tpathtmp, path)));\n\n\t/*\n\t * The basename of the file is what we return from pg_export_snapshot().\n\t * It's already in path in a textual format and we know that the path\n\t * starts with SNAPSHOT_EXPORT_DIR.  Skip over the prefix and the slash\n\t * and pstrdup it so as not to return the address of a local variable.\n\t */\n\treturn pstrdup(path + strlen(SNAPSHOT_EXPORT_DIR) + 1);\n}"
  },
  {
    "function_name": "AtEOXact_Snapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
    "lines": "1058-1149",
    "snippet": "void\nAtEOXact_Snapshot(bool isCommit, bool resetXmin)\n{\n\t/*\n\t * In transaction-snapshot mode we must release our privately-managed\n\t * reference to the transaction snapshot.  We must remove it from\n\t * RegisteredSnapshots to keep the check below happy.  But we don't bother\n\t * to do FreeSnapshot, for two reasons: the memory will go away with\n\t * TopTransactionContext anyway, and if someone has left the snapshot\n\t * stacked as active, we don't want the code below to be chasing through a\n\t * dangling pointer.\n\t */\n\tif (FirstXactSnapshot != NULL)\n\t{\n\t\tAssert(FirstXactSnapshot->regd_count > 0);\n\t\tAssert(!pairingheap_is_empty(&RegisteredSnapshots));\n\t\tpairingheap_remove(&RegisteredSnapshots, &FirstXactSnapshot->ph_node);\n\t}\n\tFirstXactSnapshot = NULL;\n\n\t/*\n\t * If we exported any snapshots, clean them up.\n\t */\n\tif (exportedSnapshots != NIL)\n\t{\n\t\tListCell   *lc;\n\n\t\t/*\n\t\t * Get rid of the files.  Unlink failure is only a WARNING because (1)\n\t\t * it's too late to abort the transaction, and (2) leaving a leaked\n\t\t * file around has little real consequence anyway.\n\t\t *\n\t\t * We also need to remove the snapshots from RegisteredSnapshots to\n\t\t * prevent a warning below.\n\t\t *\n\t\t * As with the FirstXactSnapshot, we don't need to free resources of\n\t\t * the snapshot iself as it will go away with the memory context.\n\t\t */\n\t\tforeach(lc, exportedSnapshots)\n\t\t{\n\t\t\tExportedSnapshot *esnap = (ExportedSnapshot *) lfirst(lc);\n\n\t\t\tif (unlink(esnap->snapfile))\n\t\t\t\telog(WARNING, \"could not unlink file \\\"%s\\\": %m\",\n\t\t\t\t\t esnap->snapfile);\n\n\t\t\tpairingheap_remove(&RegisteredSnapshots,\n\t\t\t\t\t\t\t   &esnap->snapshot->ph_node);\n\t\t}\n\n\t\texportedSnapshots = NIL;\n\t}\n\n\t/* Drop catalog snapshot if any */\n\tInvalidateCatalogSnapshot();\n\n\t/* On commit, complain about leftover snapshots */\n\tif (isCommit)\n\t{\n\t\tActiveSnapshotElt *active;\n\n\t\tif (!pairingheap_is_empty(&RegisteredSnapshots))\n\t\t\telog(WARNING, \"registered snapshots seem to remain after cleanup\");\n\n\t\t/* complain about unpopped active snapshots */\n\t\tfor (active = ActiveSnapshot; active != NULL; active = active->as_next)\n\t\t\telog(WARNING, \"snapshot %p still active\", active);\n\t}\n\n\t/*\n\t * And reset our state.  We don't need to free the memory explicitly --\n\t * it'll go away with TopTransactionContext.\n\t */\n\tActiveSnapshot = NULL;\n\tOldestActiveSnapshot = NULL;\n\tpairingheap_reset(&RegisteredSnapshots);\n\n\tCurrentSnapshot = NULL;\n\tSecondarySnapshot = NULL;\n\n\tFirstSnapshotSet = false;\n\n\t/*\n\t * During normal commit processing, we call ProcArrayEndTransaction() to\n\t * reset the PgXact->xmin. That call happens prior to the call to\n\t * AtEOXact_Snapshot(), so we need not touch xmin here at all.\n\t */\n\tif (resetXmin)\n\t\tSnapshotResetXmin();\n\n\tAssert(resetXmin || MyPgXact->xmin == 0);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/spin.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/pairingheap.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Snapshot CurrentSnapshot = NULL;",
      "static Snapshot SecondarySnapshot = NULL;",
      "static ActiveSnapshotElt *ActiveSnapshot = NULL;",
      "static ActiveSnapshotElt *OldestActiveSnapshot = NULL;",
      "static pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};",
      "bool\t\tFirstSnapshotSet = false;",
      "static Snapshot FirstXactSnapshot = NULL;",
      "static List *exportedSnapshots = NIL;",
      "static Snapshot CopySnapshot(Snapshot snapshot);",
      "static void FreeSnapshot(Snapshot snapshot);",
      "static void SnapshotResetXmin(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "resetXmin || MyPgXact->xmin == 0"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SnapshotResetXmin",
          "args": [],
          "line": 1146
        },
        "resolved": true,
        "details": {
          "function_name": "SnapshotResetXmin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "977-996",
          "snippet": "static void\nSnapshotResetXmin(void)\n{\n\tSnapshot\tminSnapshot;\n\n\tif (ActiveSnapshot != NULL)\n\t\treturn;\n\n\tif (pairingheap_is_empty(&RegisteredSnapshots))\n\t{\n\t\tMyPgXact->xmin = InvalidTransactionId;\n\t\treturn;\n\t}\n\n\tminSnapshot = pairingheap_container(SnapshotData, ph_node,\n\t\t\t\t\t\t\t\t\t\tpairingheap_first(&RegisteredSnapshots));\n\n\tif (TransactionIdPrecedes(MyPgXact->xmin, minSnapshot->xmin))\n\t\tMyPgXact->xmin = minSnapshot->xmin;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ActiveSnapshotElt *ActiveSnapshot = NULL;",
            "static pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};",
            "static void SnapshotResetXmin(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic ActiveSnapshotElt *ActiveSnapshot = NULL;\nstatic pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};\nstatic void SnapshotResetXmin(void);\n\nstatic void\nSnapshotResetXmin(void)\n{\n\tSnapshot\tminSnapshot;\n\n\tif (ActiveSnapshot != NULL)\n\t\treturn;\n\n\tif (pairingheap_is_empty(&RegisteredSnapshots))\n\t{\n\t\tMyPgXact->xmin = InvalidTransactionId;\n\t\treturn;\n\t}\n\n\tminSnapshot = pairingheap_container(SnapshotData, ph_node,\n\t\t\t\t\t\t\t\t\t\tpairingheap_first(&RegisteredSnapshots));\n\n\tif (TransactionIdPrecedes(MyPgXact->xmin, minSnapshot->xmin))\n\t\tMyPgXact->xmin = minSnapshot->xmin;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pairingheap_reset",
          "args": [
            "&RegisteredSnapshots"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "WARNING",
            "\"snapshot %p still active\"",
            "active"
          ],
          "line": 1124
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pairingheap_is_empty",
          "args": [
            "&RegisteredSnapshots"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InvalidateCatalogSnapshot",
          "args": [],
          "line": 1112
        },
        "resolved": true,
        "details": {
          "function_name": "InvalidateCatalogSnapshotConditionally",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "530-537",
          "snippet": "void\nInvalidateCatalogSnapshotConditionally(void)\n{\n\tif (CatalogSnapshot &&\n\t\tActiveSnapshot == NULL &&\n\t\tpairingheap_is_singular(&RegisteredSnapshots))\n\t\tInvalidateCatalogSnapshot();\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Snapshot CatalogSnapshot = NULL;",
            "static ActiveSnapshotElt *ActiveSnapshot = NULL;",
            "static pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic Snapshot CatalogSnapshot = NULL;\nstatic ActiveSnapshotElt *ActiveSnapshot = NULL;\nstatic pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};\n\nvoid\nInvalidateCatalogSnapshotConditionally(void)\n{\n\tif (CatalogSnapshot &&\n\t\tActiveSnapshot == NULL &&\n\t\tpairingheap_is_singular(&RegisteredSnapshots))\n\t\tInvalidateCatalogSnapshot();\n}"
        }
      },
      {
        "call_info": {
          "callee": "pairingheap_remove",
          "args": [
            "&RegisteredSnapshots",
            "&esnap->snapshot->ph_node"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "esnap->snapfile"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst",
          "args": [
            "lc"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "lc",
            "exportedSnapshots"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pairingheap_remove",
          "args": [
            "&RegisteredSnapshots",
            "&FirstXactSnapshot->ph_node"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!pairingheap_is_empty(&RegisteredSnapshots)"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pairingheap_is_empty",
          "args": [
            "&RegisteredSnapshots"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "FirstXactSnapshot->regd_count > 0"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic Snapshot CurrentSnapshot = NULL;\nstatic Snapshot SecondarySnapshot = NULL;\nstatic ActiveSnapshotElt *ActiveSnapshot = NULL;\nstatic ActiveSnapshotElt *OldestActiveSnapshot = NULL;\nstatic pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};\nbool\t\tFirstSnapshotSet = false;\nstatic Snapshot FirstXactSnapshot = NULL;\nstatic List *exportedSnapshots = NIL;\nstatic Snapshot CopySnapshot(Snapshot snapshot);\nstatic void FreeSnapshot(Snapshot snapshot);\nstatic void SnapshotResetXmin(void);\n\nvoid\nAtEOXact_Snapshot(bool isCommit, bool resetXmin)\n{\n\t/*\n\t * In transaction-snapshot mode we must release our privately-managed\n\t * reference to the transaction snapshot.  We must remove it from\n\t * RegisteredSnapshots to keep the check below happy.  But we don't bother\n\t * to do FreeSnapshot, for two reasons: the memory will go away with\n\t * TopTransactionContext anyway, and if someone has left the snapshot\n\t * stacked as active, we don't want the code below to be chasing through a\n\t * dangling pointer.\n\t */\n\tif (FirstXactSnapshot != NULL)\n\t{\n\t\tAssert(FirstXactSnapshot->regd_count > 0);\n\t\tAssert(!pairingheap_is_empty(&RegisteredSnapshots));\n\t\tpairingheap_remove(&RegisteredSnapshots, &FirstXactSnapshot->ph_node);\n\t}\n\tFirstXactSnapshot = NULL;\n\n\t/*\n\t * If we exported any snapshots, clean them up.\n\t */\n\tif (exportedSnapshots != NIL)\n\t{\n\t\tListCell   *lc;\n\n\t\t/*\n\t\t * Get rid of the files.  Unlink failure is only a WARNING because (1)\n\t\t * it's too late to abort the transaction, and (2) leaving a leaked\n\t\t * file around has little real consequence anyway.\n\t\t *\n\t\t * We also need to remove the snapshots from RegisteredSnapshots to\n\t\t * prevent a warning below.\n\t\t *\n\t\t * As with the FirstXactSnapshot, we don't need to free resources of\n\t\t * the snapshot iself as it will go away with the memory context.\n\t\t */\n\t\tforeach(lc, exportedSnapshots)\n\t\t{\n\t\t\tExportedSnapshot *esnap = (ExportedSnapshot *) lfirst(lc);\n\n\t\t\tif (unlink(esnap->snapfile))\n\t\t\t\telog(WARNING, \"could not unlink file \\\"%s\\\": %m\",\n\t\t\t\t\t esnap->snapfile);\n\n\t\t\tpairingheap_remove(&RegisteredSnapshots,\n\t\t\t\t\t\t\t   &esnap->snapshot->ph_node);\n\t\t}\n\n\t\texportedSnapshots = NIL;\n\t}\n\n\t/* Drop catalog snapshot if any */\n\tInvalidateCatalogSnapshot();\n\n\t/* On commit, complain about leftover snapshots */\n\tif (isCommit)\n\t{\n\t\tActiveSnapshotElt *active;\n\n\t\tif (!pairingheap_is_empty(&RegisteredSnapshots))\n\t\t\telog(WARNING, \"registered snapshots seem to remain after cleanup\");\n\n\t\t/* complain about unpopped active snapshots */\n\t\tfor (active = ActiveSnapshot; active != NULL; active = active->as_next)\n\t\t\telog(WARNING, \"snapshot %p still active\", active);\n\t}\n\n\t/*\n\t * And reset our state.  We don't need to free the memory explicitly --\n\t * it'll go away with TopTransactionContext.\n\t */\n\tActiveSnapshot = NULL;\n\tOldestActiveSnapshot = NULL;\n\tpairingheap_reset(&RegisteredSnapshots);\n\n\tCurrentSnapshot = NULL;\n\tSecondarySnapshot = NULL;\n\n\tFirstSnapshotSet = false;\n\n\t/*\n\t * During normal commit processing, we call ProcArrayEndTransaction() to\n\t * reset the PgXact->xmin. That call happens prior to the call to\n\t * AtEOXact_Snapshot(), so we need not touch xmin here at all.\n\t */\n\tif (resetXmin)\n\t\tSnapshotResetXmin();\n\n\tAssert(resetXmin || MyPgXact->xmin == 0);\n}"
  },
  {
    "function_name": "AtSubAbort_Snapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
    "lines": "1022-1052",
    "snippet": "void\nAtSubAbort_Snapshot(int level)\n{\n\t/* Forget the active snapshots set by this subtransaction */\n\twhile (ActiveSnapshot && ActiveSnapshot->as_level >= level)\n\t{\n\t\tActiveSnapshotElt *next;\n\n\t\tnext = ActiveSnapshot->as_next;\n\n\t\t/*\n\t\t * Decrement the snapshot's active count.  If it's still registered or\n\t\t * marked as active by an outer subtransaction, we can't free it yet.\n\t\t */\n\t\tAssert(ActiveSnapshot->as_snap->active_count >= 1);\n\t\tActiveSnapshot->as_snap->active_count -= 1;\n\n\t\tif (ActiveSnapshot->as_snap->active_count == 0 &&\n\t\t\tActiveSnapshot->as_snap->regd_count == 0)\n\t\t\tFreeSnapshot(ActiveSnapshot->as_snap);\n\n\t\t/* and free the stack element */\n\t\tpfree(ActiveSnapshot);\n\n\t\tActiveSnapshot = next;\n\t\tif (ActiveSnapshot == NULL)\n\t\t\tOldestActiveSnapshot = NULL;\n\t}\n\n\tSnapshotResetXmin();\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/spin.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/pairingheap.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static ActiveSnapshotElt *ActiveSnapshot = NULL;",
      "static ActiveSnapshotElt *OldestActiveSnapshot = NULL;",
      "static Snapshot CopySnapshot(Snapshot snapshot);",
      "static void FreeSnapshot(Snapshot snapshot);",
      "static void SnapshotResetXmin(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SnapshotResetXmin",
          "args": [],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "SnapshotResetXmin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "977-996",
          "snippet": "static void\nSnapshotResetXmin(void)\n{\n\tSnapshot\tminSnapshot;\n\n\tif (ActiveSnapshot != NULL)\n\t\treturn;\n\n\tif (pairingheap_is_empty(&RegisteredSnapshots))\n\t{\n\t\tMyPgXact->xmin = InvalidTransactionId;\n\t\treturn;\n\t}\n\n\tminSnapshot = pairingheap_container(SnapshotData, ph_node,\n\t\t\t\t\t\t\t\t\t\tpairingheap_first(&RegisteredSnapshots));\n\n\tif (TransactionIdPrecedes(MyPgXact->xmin, minSnapshot->xmin))\n\t\tMyPgXact->xmin = minSnapshot->xmin;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ActiveSnapshotElt *ActiveSnapshot = NULL;",
            "static pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};",
            "static void SnapshotResetXmin(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic ActiveSnapshotElt *ActiveSnapshot = NULL;\nstatic pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};\nstatic void SnapshotResetXmin(void);\n\nstatic void\nSnapshotResetXmin(void)\n{\n\tSnapshot\tminSnapshot;\n\n\tif (ActiveSnapshot != NULL)\n\t\treturn;\n\n\tif (pairingheap_is_empty(&RegisteredSnapshots))\n\t{\n\t\tMyPgXact->xmin = InvalidTransactionId;\n\t\treturn;\n\t}\n\n\tminSnapshot = pairingheap_container(SnapshotData, ph_node,\n\t\t\t\t\t\t\t\t\t\tpairingheap_first(&RegisteredSnapshots));\n\n\tif (TransactionIdPrecedes(MyPgXact->xmin, minSnapshot->xmin))\n\t\tMyPgXact->xmin = minSnapshot->xmin;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "ActiveSnapshot"
          ],
          "line": 1044
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "FreeSnapshot",
          "args": [
            "ActiveSnapshot->as_snap"
          ],
          "line": 1041
        },
        "resolved": true,
        "details": {
          "function_name": "FreeSnapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "714-722",
          "snippet": "static void\nFreeSnapshot(Snapshot snapshot)\n{\n\tAssert(snapshot->regd_count == 0);\n\tAssert(snapshot->active_count == 0);\n\tAssert(snapshot->copied);\n\n\tpfree(snapshot);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Snapshot CopySnapshot(Snapshot snapshot);",
            "static void FreeSnapshot(Snapshot snapshot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic Snapshot CopySnapshot(Snapshot snapshot);\nstatic void FreeSnapshot(Snapshot snapshot);\n\nstatic void\nFreeSnapshot(Snapshot snapshot)\n{\n\tAssert(snapshot->regd_count == 0);\n\tAssert(snapshot->active_count == 0);\n\tAssert(snapshot->copied);\n\n\tpfree(snapshot);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "ActiveSnapshot->as_snap->active_count >= 1"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic ActiveSnapshotElt *ActiveSnapshot = NULL;\nstatic ActiveSnapshotElt *OldestActiveSnapshot = NULL;\nstatic Snapshot CopySnapshot(Snapshot snapshot);\nstatic void FreeSnapshot(Snapshot snapshot);\nstatic void SnapshotResetXmin(void);\n\nvoid\nAtSubAbort_Snapshot(int level)\n{\n\t/* Forget the active snapshots set by this subtransaction */\n\twhile (ActiveSnapshot && ActiveSnapshot->as_level >= level)\n\t{\n\t\tActiveSnapshotElt *next;\n\n\t\tnext = ActiveSnapshot->as_next;\n\n\t\t/*\n\t\t * Decrement the snapshot's active count.  If it's still registered or\n\t\t * marked as active by an outer subtransaction, we can't free it yet.\n\t\t */\n\t\tAssert(ActiveSnapshot->as_snap->active_count >= 1);\n\t\tActiveSnapshot->as_snap->active_count -= 1;\n\n\t\tif (ActiveSnapshot->as_snap->active_count == 0 &&\n\t\t\tActiveSnapshot->as_snap->regd_count == 0)\n\t\t\tFreeSnapshot(ActiveSnapshot->as_snap);\n\n\t\t/* and free the stack element */\n\t\tpfree(ActiveSnapshot);\n\n\t\tActiveSnapshot = next;\n\t\tif (ActiveSnapshot == NULL)\n\t\t\tOldestActiveSnapshot = NULL;\n\t}\n\n\tSnapshotResetXmin();\n}"
  },
  {
    "function_name": "AtSubCommit_Snapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
    "lines": "1001-1016",
    "snippet": "void\nAtSubCommit_Snapshot(int level)\n{\n\tActiveSnapshotElt *active;\n\n\t/*\n\t * Relabel the active snapshots set in this subtransaction as though they\n\t * are owned by the parent subxact.\n\t */\n\tfor (active = ActiveSnapshot; active != NULL; active = active->as_next)\n\t{\n\t\tif (active->as_level < level)\n\t\t\tbreak;\n\t\tactive->as_level = level - 1;\n\t}\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/spin.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/pairingheap.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static ActiveSnapshotElt *ActiveSnapshot = NULL;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic ActiveSnapshotElt *ActiveSnapshot = NULL;\n\nvoid\nAtSubCommit_Snapshot(int level)\n{\n\tActiveSnapshotElt *active;\n\n\t/*\n\t * Relabel the active snapshots set in this subtransaction as though they\n\t * are owned by the parent subxact.\n\t */\n\tfor (active = ActiveSnapshot; active != NULL; active = active->as_next)\n\t{\n\t\tif (active->as_level < level)\n\t\t\tbreak;\n\t\tactive->as_level = level - 1;\n\t}\n}"
  },
  {
    "function_name": "SnapshotResetXmin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
    "lines": "977-996",
    "snippet": "static void\nSnapshotResetXmin(void)\n{\n\tSnapshot\tminSnapshot;\n\n\tif (ActiveSnapshot != NULL)\n\t\treturn;\n\n\tif (pairingheap_is_empty(&RegisteredSnapshots))\n\t{\n\t\tMyPgXact->xmin = InvalidTransactionId;\n\t\treturn;\n\t}\n\n\tminSnapshot = pairingheap_container(SnapshotData, ph_node,\n\t\t\t\t\t\t\t\t\t\tpairingheap_first(&RegisteredSnapshots));\n\n\tif (TransactionIdPrecedes(MyPgXact->xmin, minSnapshot->xmin))\n\t\tMyPgXact->xmin = minSnapshot->xmin;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/spin.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/pairingheap.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static ActiveSnapshotElt *ActiveSnapshot = NULL;",
      "static pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};",
      "static void SnapshotResetXmin(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TransactionIdPrecedes",
          "args": [
            "MyPgXact->xmin",
            "minSnapshot->xmin"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pairingheap_container",
          "args": [
            "SnapshotData",
            "ph_node",
            "pairingheap_first(&RegisteredSnapshots)"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pairingheap_first",
          "args": [
            "&RegisteredSnapshots"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pairingheap_is_empty",
          "args": [
            "&RegisteredSnapshots"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic ActiveSnapshotElt *ActiveSnapshot = NULL;\nstatic pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};\nstatic void SnapshotResetXmin(void);\n\nstatic void\nSnapshotResetXmin(void)\n{\n\tSnapshot\tminSnapshot;\n\n\tif (ActiveSnapshot != NULL)\n\t\treturn;\n\n\tif (pairingheap_is_empty(&RegisteredSnapshots))\n\t{\n\t\tMyPgXact->xmin = InvalidTransactionId;\n\t\treturn;\n\t}\n\n\tminSnapshot = pairingheap_container(SnapshotData, ph_node,\n\t\t\t\t\t\t\t\t\t\tpairingheap_first(&RegisteredSnapshots));\n\n\tif (TransactionIdPrecedes(MyPgXact->xmin, minSnapshot->xmin))\n\t\tMyPgXact->xmin = minSnapshot->xmin;\n}"
  },
  {
    "function_name": "xmin_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
    "lines": "943-955",
    "snippet": "static int\nxmin_cmp(const pairingheap_node *a, const pairingheap_node *b, void *arg)\n{\n\tconst SnapshotData *asnap = pairingheap_const_container(SnapshotData, ph_node, a);\n\tconst SnapshotData *bsnap = pairingheap_const_container(SnapshotData, ph_node, b);\n\n\tif (TransactionIdPrecedes(asnap->xmin, bsnap->xmin))\n\t\treturn 1;\n\telse if (TransactionIdFollows(asnap->xmin, bsnap->xmin))\n\t\treturn -1;\n\telse\n\t\treturn 0;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/spin.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/pairingheap.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int xmin_cmp(const pairingheap_node *a, const pairingheap_node *b,\n\t\t void *arg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TransactionIdFollows",
          "args": [
            "asnap->xmin",
            "bsnap->xmin"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdPrecedes",
          "args": [
            "asnap->xmin",
            "bsnap->xmin"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pairingheap_const_container",
          "args": [
            "SnapshotData",
            "ph_node",
            "b"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pairingheap_const_container",
          "args": [
            "SnapshotData",
            "ph_node",
            "a"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic int xmin_cmp(const pairingheap_node *a, const pairingheap_node *b,\n\t\t void *arg);\n\nstatic int\nxmin_cmp(const pairingheap_node *a, const pairingheap_node *b, void *arg)\n{\n\tconst SnapshotData *asnap = pairingheap_const_container(SnapshotData, ph_node, a);\n\tconst SnapshotData *bsnap = pairingheap_const_container(SnapshotData, ph_node, b);\n\n\tif (TransactionIdPrecedes(asnap->xmin, bsnap->xmin))\n\t\treturn 1;\n\telse if (TransactionIdFollows(asnap->xmin, bsnap->xmin))\n\t\treturn -1;\n\telse\n\t\treturn 0;\n}"
  },
  {
    "function_name": "UnregisterSnapshotFromOwner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
    "lines": "917-937",
    "snippet": "void\nUnregisterSnapshotFromOwner(Snapshot snapshot, ResourceOwner owner)\n{\n\tif (snapshot == NULL)\n\t\treturn;\n\n\tAssert(snapshot->regd_count > 0);\n\tAssert(!pairingheap_is_empty(&RegisteredSnapshots));\n\n\tResourceOwnerForgetSnapshot(owner, snapshot);\n\n\tsnapshot->regd_count--;\n\tif (snapshot->regd_count == 0)\n\t\tpairingheap_remove(&RegisteredSnapshots, &snapshot->ph_node);\n\n\tif (snapshot->regd_count == 0 && snapshot->active_count == 0)\n\t{\n\t\tFreeSnapshot(snapshot);\n\t\tSnapshotResetXmin();\n\t}\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/spin.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/pairingheap.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};",
      "static Snapshot CopySnapshot(Snapshot snapshot);",
      "static void FreeSnapshot(Snapshot snapshot);",
      "static void SnapshotResetXmin(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SnapshotResetXmin",
          "args": [],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "SnapshotResetXmin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "977-996",
          "snippet": "static void\nSnapshotResetXmin(void)\n{\n\tSnapshot\tminSnapshot;\n\n\tif (ActiveSnapshot != NULL)\n\t\treturn;\n\n\tif (pairingheap_is_empty(&RegisteredSnapshots))\n\t{\n\t\tMyPgXact->xmin = InvalidTransactionId;\n\t\treturn;\n\t}\n\n\tminSnapshot = pairingheap_container(SnapshotData, ph_node,\n\t\t\t\t\t\t\t\t\t\tpairingheap_first(&RegisteredSnapshots));\n\n\tif (TransactionIdPrecedes(MyPgXact->xmin, minSnapshot->xmin))\n\t\tMyPgXact->xmin = minSnapshot->xmin;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ActiveSnapshotElt *ActiveSnapshot = NULL;",
            "static pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};",
            "static void SnapshotResetXmin(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic ActiveSnapshotElt *ActiveSnapshot = NULL;\nstatic pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};\nstatic void SnapshotResetXmin(void);\n\nstatic void\nSnapshotResetXmin(void)\n{\n\tSnapshot\tminSnapshot;\n\n\tif (ActiveSnapshot != NULL)\n\t\treturn;\n\n\tif (pairingheap_is_empty(&RegisteredSnapshots))\n\t{\n\t\tMyPgXact->xmin = InvalidTransactionId;\n\t\treturn;\n\t}\n\n\tminSnapshot = pairingheap_container(SnapshotData, ph_node,\n\t\t\t\t\t\t\t\t\t\tpairingheap_first(&RegisteredSnapshots));\n\n\tif (TransactionIdPrecedes(MyPgXact->xmin, minSnapshot->xmin))\n\t\tMyPgXact->xmin = minSnapshot->xmin;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FreeSnapshot",
          "args": [
            "snapshot"
          ],
          "line": 934
        },
        "resolved": true,
        "details": {
          "function_name": "FreeSnapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "714-722",
          "snippet": "static void\nFreeSnapshot(Snapshot snapshot)\n{\n\tAssert(snapshot->regd_count == 0);\n\tAssert(snapshot->active_count == 0);\n\tAssert(snapshot->copied);\n\n\tpfree(snapshot);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Snapshot CopySnapshot(Snapshot snapshot);",
            "static void FreeSnapshot(Snapshot snapshot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic Snapshot CopySnapshot(Snapshot snapshot);\nstatic void FreeSnapshot(Snapshot snapshot);\n\nstatic void\nFreeSnapshot(Snapshot snapshot)\n{\n\tAssert(snapshot->regd_count == 0);\n\tAssert(snapshot->active_count == 0);\n\tAssert(snapshot->copied);\n\n\tpfree(snapshot);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pairingheap_remove",
          "args": [
            "&RegisteredSnapshots",
            "&snapshot->ph_node"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ResourceOwnerForgetSnapshot",
          "args": [
            "owner",
            "snapshot"
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "ResourceOwnerForgetSnapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "1161-1167",
          "snippet": "void\nResourceOwnerForgetSnapshot(ResourceOwner owner, Snapshot snapshot)\n{\n\tif (!ResourceArrayRemove(&(owner->snapshotarr), PointerGetDatum(snapshot)))\n\t\telog(ERROR, \"snapshot reference %p is not owned by resource owner %s\",\n\t\t\t snapshot, owner->name);\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"jit/jit.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void PrintSnapshotLeakWarning(Snapshot snapshot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void PrintSnapshotLeakWarning(Snapshot snapshot);\n\nvoid\nResourceOwnerForgetSnapshot(ResourceOwner owner, Snapshot snapshot)\n{\n\tif (!ResourceArrayRemove(&(owner->snapshotarr), PointerGetDatum(snapshot)))\n\t\telog(ERROR, \"snapshot reference %p is not owned by resource owner %s\",\n\t\t\t snapshot, owner->name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!pairingheap_is_empty(&RegisteredSnapshots)"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pairingheap_is_empty",
          "args": [
            "&RegisteredSnapshots"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "snapshot->regd_count > 0"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};\nstatic Snapshot CopySnapshot(Snapshot snapshot);\nstatic void FreeSnapshot(Snapshot snapshot);\nstatic void SnapshotResetXmin(void);\n\nvoid\nUnregisterSnapshotFromOwner(Snapshot snapshot, ResourceOwner owner)\n{\n\tif (snapshot == NULL)\n\t\treturn;\n\n\tAssert(snapshot->regd_count > 0);\n\tAssert(!pairingheap_is_empty(&RegisteredSnapshots));\n\n\tResourceOwnerForgetSnapshot(owner, snapshot);\n\n\tsnapshot->regd_count--;\n\tif (snapshot->regd_count == 0)\n\t\tpairingheap_remove(&RegisteredSnapshots, &snapshot->ph_node);\n\n\tif (snapshot->regd_count == 0 && snapshot->active_count == 0)\n\t{\n\t\tFreeSnapshot(snapshot);\n\t\tSnapshotResetXmin();\n\t}\n}"
  },
  {
    "function_name": "UnregisterSnapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
    "lines": "904-911",
    "snippet": "void\nUnregisterSnapshot(Snapshot snapshot)\n{\n\tif (snapshot == NULL)\n\t\treturn;\n\n\tUnregisterSnapshotFromOwner(snapshot, CurrentResourceOwner);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/spin.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/pairingheap.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Snapshot CopySnapshot(Snapshot snapshot);",
      "static void FreeSnapshot(Snapshot snapshot);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "UnregisterSnapshotFromOwner",
          "args": [
            "snapshot",
            "CurrentResourceOwner"
          ],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "UnregisterSnapshotFromOwner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "917-937",
          "snippet": "void\nUnregisterSnapshotFromOwner(Snapshot snapshot, ResourceOwner owner)\n{\n\tif (snapshot == NULL)\n\t\treturn;\n\n\tAssert(snapshot->regd_count > 0);\n\tAssert(!pairingheap_is_empty(&RegisteredSnapshots));\n\n\tResourceOwnerForgetSnapshot(owner, snapshot);\n\n\tsnapshot->regd_count--;\n\tif (snapshot->regd_count == 0)\n\t\tpairingheap_remove(&RegisteredSnapshots, &snapshot->ph_node);\n\n\tif (snapshot->regd_count == 0 && snapshot->active_count == 0)\n\t{\n\t\tFreeSnapshot(snapshot);\n\t\tSnapshotResetXmin();\n\t}\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};",
            "static Snapshot CopySnapshot(Snapshot snapshot);",
            "static void FreeSnapshot(Snapshot snapshot);",
            "static void SnapshotResetXmin(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};\nstatic Snapshot CopySnapshot(Snapshot snapshot);\nstatic void FreeSnapshot(Snapshot snapshot);\nstatic void SnapshotResetXmin(void);\n\nvoid\nUnregisterSnapshotFromOwner(Snapshot snapshot, ResourceOwner owner)\n{\n\tif (snapshot == NULL)\n\t\treturn;\n\n\tAssert(snapshot->regd_count > 0);\n\tAssert(!pairingheap_is_empty(&RegisteredSnapshots));\n\n\tResourceOwnerForgetSnapshot(owner, snapshot);\n\n\tsnapshot->regd_count--;\n\tif (snapshot->regd_count == 0)\n\t\tpairingheap_remove(&RegisteredSnapshots, &snapshot->ph_node);\n\n\tif (snapshot->regd_count == 0 && snapshot->active_count == 0)\n\t{\n\t\tFreeSnapshot(snapshot);\n\t\tSnapshotResetXmin();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic Snapshot CopySnapshot(Snapshot snapshot);\nstatic void FreeSnapshot(Snapshot snapshot);\n\nvoid\nUnregisterSnapshot(Snapshot snapshot)\n{\n\tif (snapshot == NULL)\n\t\treturn;\n\n\tUnregisterSnapshotFromOwner(snapshot, CurrentResourceOwner);\n}"
  },
  {
    "function_name": "RegisterSnapshotOnOwner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
    "lines": "875-895",
    "snippet": "Snapshot\nRegisterSnapshotOnOwner(Snapshot snapshot, ResourceOwner owner)\n{\n\tSnapshot\tsnap;\n\n\tif (snapshot == InvalidSnapshot)\n\t\treturn InvalidSnapshot;\n\n\t/* Static snapshot?  Create a persistent copy */\n\tsnap = snapshot->copied ? snapshot : CopySnapshot(snapshot);\n\n\t/* and tell resowner.c about it */\n\tResourceOwnerEnlargeSnapshots(owner);\n\tsnap->regd_count++;\n\tResourceOwnerRememberSnapshot(owner, snap);\n\n\tif (snap->regd_count == 1)\n\t\tpairingheap_add(&RegisteredSnapshots, &snap->ph_node);\n\n\treturn snap;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/spin.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/pairingheap.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};",
      "static Snapshot CopySnapshot(Snapshot snapshot);",
      "static void FreeSnapshot(Snapshot snapshot);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pairingheap_add",
          "args": [
            "&RegisteredSnapshots",
            "&snap->ph_node"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ResourceOwnerRememberSnapshot",
          "args": [
            "owner",
            "snap"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "ResourceOwnerRememberSnapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "1152-1156",
          "snippet": "void\nResourceOwnerRememberSnapshot(ResourceOwner owner, Snapshot snapshot)\n{\n\tResourceArrayAdd(&(owner->snapshotarr), PointerGetDatum(snapshot));\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"jit/jit.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void PrintSnapshotLeakWarning(Snapshot snapshot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void PrintSnapshotLeakWarning(Snapshot snapshot);\n\nvoid\nResourceOwnerRememberSnapshot(ResourceOwner owner, Snapshot snapshot)\n{\n\tResourceArrayAdd(&(owner->snapshotarr), PointerGetDatum(snapshot));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ResourceOwnerEnlargeSnapshots",
          "args": [
            "owner"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "ResourceOwnerEnlargeSnapshots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "1141-1145",
          "snippet": "void\nResourceOwnerEnlargeSnapshots(ResourceOwner owner)\n{\n\tResourceArrayEnlarge(&(owner->snapshotarr));\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"jit/jit.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nResourceOwnerEnlargeSnapshots(ResourceOwner owner)\n{\n\tResourceArrayEnlarge(&(owner->snapshotarr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "CopySnapshot",
          "args": [
            "snapshot"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "CopySnapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "659-708",
          "snippet": "static Snapshot\nCopySnapshot(Snapshot snapshot)\n{\n\tSnapshot\tnewsnap;\n\tSize\t\tsubxipoff;\n\tSize\t\tsize;\n\n\tAssert(snapshot != InvalidSnapshot);\n\n\t/* We allocate any XID arrays needed in the same palloc block. */\n\tsize = subxipoff = sizeof(SnapshotData) +\n\t\tsnapshot->xcnt * sizeof(TransactionId);\n\tif (snapshot->subxcnt > 0)\n\t\tsize += snapshot->subxcnt * sizeof(TransactionId);\n\n\tnewsnap = (Snapshot) MemoryContextAlloc(TopTransactionContext, size);\n\tmemcpy(newsnap, snapshot, sizeof(SnapshotData));\n\n\tnewsnap->regd_count = 0;\n\tnewsnap->active_count = 0;\n\tnewsnap->copied = true;\n\n\t/* setup XID array */\n\tif (snapshot->xcnt > 0)\n\t{\n\t\tnewsnap->xip = (TransactionId *) (newsnap + 1);\n\t\tmemcpy(newsnap->xip, snapshot->xip,\n\t\t\t   snapshot->xcnt * sizeof(TransactionId));\n\t}\n\telse\n\t\tnewsnap->xip = NULL;\n\n\t/*\n\t * Setup subXID array. Don't bother to copy it if it had overflowed,\n\t * though, because it's not used anywhere in that case. Except if it's a\n\t * snapshot taken during recovery; all the top-level XIDs are in subxip as\n\t * well in that case, so we mustn't lose them.\n\t */\n\tif (snapshot->subxcnt > 0 &&\n\t\t(!snapshot->suboverflowed || snapshot->takenDuringRecovery))\n\t{\n\t\tnewsnap->subxip = (TransactionId *) ((char *) newsnap + subxipoff);\n\t\tmemcpy(newsnap->subxip, snapshot->subxip,\n\t\t\t   snapshot->subxcnt * sizeof(TransactionId));\n\t}\n\telse\n\t\tnewsnap->subxip = NULL;\n\n\treturn newsnap;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Snapshot CopySnapshot(Snapshot snapshot);",
            "static void FreeSnapshot(Snapshot snapshot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic Snapshot CopySnapshot(Snapshot snapshot);\nstatic void FreeSnapshot(Snapshot snapshot);\n\nstatic Snapshot\nCopySnapshot(Snapshot snapshot)\n{\n\tSnapshot\tnewsnap;\n\tSize\t\tsubxipoff;\n\tSize\t\tsize;\n\n\tAssert(snapshot != InvalidSnapshot);\n\n\t/* We allocate any XID arrays needed in the same palloc block. */\n\tsize = subxipoff = sizeof(SnapshotData) +\n\t\tsnapshot->xcnt * sizeof(TransactionId);\n\tif (snapshot->subxcnt > 0)\n\t\tsize += snapshot->subxcnt * sizeof(TransactionId);\n\n\tnewsnap = (Snapshot) MemoryContextAlloc(TopTransactionContext, size);\n\tmemcpy(newsnap, snapshot, sizeof(SnapshotData));\n\n\tnewsnap->regd_count = 0;\n\tnewsnap->active_count = 0;\n\tnewsnap->copied = true;\n\n\t/* setup XID array */\n\tif (snapshot->xcnt > 0)\n\t{\n\t\tnewsnap->xip = (TransactionId *) (newsnap + 1);\n\t\tmemcpy(newsnap->xip, snapshot->xip,\n\t\t\t   snapshot->xcnt * sizeof(TransactionId));\n\t}\n\telse\n\t\tnewsnap->xip = NULL;\n\n\t/*\n\t * Setup subXID array. Don't bother to copy it if it had overflowed,\n\t * though, because it's not used anywhere in that case. Except if it's a\n\t * snapshot taken during recovery; all the top-level XIDs are in subxip as\n\t * well in that case, so we mustn't lose them.\n\t */\n\tif (snapshot->subxcnt > 0 &&\n\t\t(!snapshot->suboverflowed || snapshot->takenDuringRecovery))\n\t{\n\t\tnewsnap->subxip = (TransactionId *) ((char *) newsnap + subxipoff);\n\t\tmemcpy(newsnap->subxip, snapshot->subxip,\n\t\t\t   snapshot->subxcnt * sizeof(TransactionId));\n\t}\n\telse\n\t\tnewsnap->subxip = NULL;\n\n\treturn newsnap;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};\nstatic Snapshot CopySnapshot(Snapshot snapshot);\nstatic void FreeSnapshot(Snapshot snapshot);\n\nSnapshot\nRegisterSnapshotOnOwner(Snapshot snapshot, ResourceOwner owner)\n{\n\tSnapshot\tsnap;\n\n\tif (snapshot == InvalidSnapshot)\n\t\treturn InvalidSnapshot;\n\n\t/* Static snapshot?  Create a persistent copy */\n\tsnap = snapshot->copied ? snapshot : CopySnapshot(snapshot);\n\n\t/* and tell resowner.c about it */\n\tResourceOwnerEnlargeSnapshots(owner);\n\tsnap->regd_count++;\n\tResourceOwnerRememberSnapshot(owner, snap);\n\n\tif (snap->regd_count == 1)\n\t\tpairingheap_add(&RegisteredSnapshots, &snap->ph_node);\n\n\treturn snap;\n}"
  },
  {
    "function_name": "RegisterSnapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
    "lines": "862-869",
    "snippet": "Snapshot\nRegisterSnapshot(Snapshot snapshot)\n{\n\tif (snapshot == InvalidSnapshot)\n\t\treturn InvalidSnapshot;\n\n\treturn RegisterSnapshotOnOwner(snapshot, CurrentResourceOwner);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/spin.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/pairingheap.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Snapshot CopySnapshot(Snapshot snapshot);",
      "static void FreeSnapshot(Snapshot snapshot);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RegisterSnapshotOnOwner",
          "args": [
            "snapshot",
            "CurrentResourceOwner"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "RegisterSnapshotOnOwner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "875-895",
          "snippet": "Snapshot\nRegisterSnapshotOnOwner(Snapshot snapshot, ResourceOwner owner)\n{\n\tSnapshot\tsnap;\n\n\tif (snapshot == InvalidSnapshot)\n\t\treturn InvalidSnapshot;\n\n\t/* Static snapshot?  Create a persistent copy */\n\tsnap = snapshot->copied ? snapshot : CopySnapshot(snapshot);\n\n\t/* and tell resowner.c about it */\n\tResourceOwnerEnlargeSnapshots(owner);\n\tsnap->regd_count++;\n\tResourceOwnerRememberSnapshot(owner, snap);\n\n\tif (snap->regd_count == 1)\n\t\tpairingheap_add(&RegisteredSnapshots, &snap->ph_node);\n\n\treturn snap;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};",
            "static Snapshot CopySnapshot(Snapshot snapshot);",
            "static void FreeSnapshot(Snapshot snapshot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};\nstatic Snapshot CopySnapshot(Snapshot snapshot);\nstatic void FreeSnapshot(Snapshot snapshot);\n\nSnapshot\nRegisterSnapshotOnOwner(Snapshot snapshot, ResourceOwner owner)\n{\n\tSnapshot\tsnap;\n\n\tif (snapshot == InvalidSnapshot)\n\t\treturn InvalidSnapshot;\n\n\t/* Static snapshot?  Create a persistent copy */\n\tsnap = snapshot->copied ? snapshot : CopySnapshot(snapshot);\n\n\t/* and tell resowner.c about it */\n\tResourceOwnerEnlargeSnapshots(owner);\n\tsnap->regd_count++;\n\tResourceOwnerRememberSnapshot(owner, snap);\n\n\tif (snap->regd_count == 1)\n\t\tpairingheap_add(&RegisteredSnapshots, &snap->ph_node);\n\n\treturn snap;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic Snapshot CopySnapshot(Snapshot snapshot);\nstatic void FreeSnapshot(Snapshot snapshot);\n\nSnapshot\nRegisterSnapshot(Snapshot snapshot)\n{\n\tif (snapshot == InvalidSnapshot)\n\t\treturn InvalidSnapshot;\n\n\treturn RegisterSnapshotOnOwner(snapshot, CurrentResourceOwner);\n}"
  },
  {
    "function_name": "ActiveSnapshotSet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
    "lines": "850-854",
    "snippet": "bool\nActiveSnapshotSet(void)\n{\n\treturn ActiveSnapshot != NULL;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/spin.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/pairingheap.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static ActiveSnapshotElt *ActiveSnapshot = NULL;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic ActiveSnapshotElt *ActiveSnapshot = NULL;\n\nbool\nActiveSnapshotSet(void)\n{\n\treturn ActiveSnapshot != NULL;\n}"
  },
  {
    "function_name": "GetActiveSnapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
    "lines": "838-844",
    "snippet": "Snapshot\nGetActiveSnapshot(void)\n{\n\tAssert(ActiveSnapshot != NULL);\n\n\treturn ActiveSnapshot->as_snap;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/spin.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/pairingheap.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static ActiveSnapshotElt *ActiveSnapshot = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "ActiveSnapshot != NULL"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic ActiveSnapshotElt *ActiveSnapshot = NULL;\n\nSnapshot\nGetActiveSnapshot(void)\n{\n\tAssert(ActiveSnapshot != NULL);\n\n\treturn ActiveSnapshot->as_snap;\n}"
  },
  {
    "function_name": "PopActiveSnapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
    "lines": "811-832",
    "snippet": "void\nPopActiveSnapshot(void)\n{\n\tActiveSnapshotElt *newstack;\n\n\tnewstack = ActiveSnapshot->as_next;\n\n\tAssert(ActiveSnapshot->as_snap->active_count > 0);\n\n\tActiveSnapshot->as_snap->active_count--;\n\n\tif (ActiveSnapshot->as_snap->active_count == 0 &&\n\t\tActiveSnapshot->as_snap->regd_count == 0)\n\t\tFreeSnapshot(ActiveSnapshot->as_snap);\n\n\tpfree(ActiveSnapshot);\n\tActiveSnapshot = newstack;\n\tif (ActiveSnapshot == NULL)\n\t\tOldestActiveSnapshot = NULL;\n\n\tSnapshotResetXmin();\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/spin.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/pairingheap.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static ActiveSnapshotElt *ActiveSnapshot = NULL;",
      "static ActiveSnapshotElt *OldestActiveSnapshot = NULL;",
      "static void SnapshotResetXmin(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SnapshotResetXmin",
          "args": [],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "SnapshotResetXmin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "977-996",
          "snippet": "static void\nSnapshotResetXmin(void)\n{\n\tSnapshot\tminSnapshot;\n\n\tif (ActiveSnapshot != NULL)\n\t\treturn;\n\n\tif (pairingheap_is_empty(&RegisteredSnapshots))\n\t{\n\t\tMyPgXact->xmin = InvalidTransactionId;\n\t\treturn;\n\t}\n\n\tminSnapshot = pairingheap_container(SnapshotData, ph_node,\n\t\t\t\t\t\t\t\t\t\tpairingheap_first(&RegisteredSnapshots));\n\n\tif (TransactionIdPrecedes(MyPgXact->xmin, minSnapshot->xmin))\n\t\tMyPgXact->xmin = minSnapshot->xmin;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ActiveSnapshotElt *ActiveSnapshot = NULL;",
            "static pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};",
            "static void SnapshotResetXmin(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic ActiveSnapshotElt *ActiveSnapshot = NULL;\nstatic pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};\nstatic void SnapshotResetXmin(void);\n\nstatic void\nSnapshotResetXmin(void)\n{\n\tSnapshot\tminSnapshot;\n\n\tif (ActiveSnapshot != NULL)\n\t\treturn;\n\n\tif (pairingheap_is_empty(&RegisteredSnapshots))\n\t{\n\t\tMyPgXact->xmin = InvalidTransactionId;\n\t\treturn;\n\t}\n\n\tminSnapshot = pairingheap_container(SnapshotData, ph_node,\n\t\t\t\t\t\t\t\t\t\tpairingheap_first(&RegisteredSnapshots));\n\n\tif (TransactionIdPrecedes(MyPgXact->xmin, minSnapshot->xmin))\n\t\tMyPgXact->xmin = minSnapshot->xmin;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "ActiveSnapshot"
          ],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "FreeSnapshot",
          "args": [
            "ActiveSnapshot->as_snap"
          ],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "FreeSnapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "714-722",
          "snippet": "static void\nFreeSnapshot(Snapshot snapshot)\n{\n\tAssert(snapshot->regd_count == 0);\n\tAssert(snapshot->active_count == 0);\n\tAssert(snapshot->copied);\n\n\tpfree(snapshot);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Snapshot CopySnapshot(Snapshot snapshot);",
            "static void FreeSnapshot(Snapshot snapshot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic Snapshot CopySnapshot(Snapshot snapshot);\nstatic void FreeSnapshot(Snapshot snapshot);\n\nstatic void\nFreeSnapshot(Snapshot snapshot)\n{\n\tAssert(snapshot->regd_count == 0);\n\tAssert(snapshot->active_count == 0);\n\tAssert(snapshot->copied);\n\n\tpfree(snapshot);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "ActiveSnapshot->as_snap->active_count > 0"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic ActiveSnapshotElt *ActiveSnapshot = NULL;\nstatic ActiveSnapshotElt *OldestActiveSnapshot = NULL;\nstatic void SnapshotResetXmin(void);\n\nvoid\nPopActiveSnapshot(void)\n{\n\tActiveSnapshotElt *newstack;\n\n\tnewstack = ActiveSnapshot->as_next;\n\n\tAssert(ActiveSnapshot->as_snap->active_count > 0);\n\n\tActiveSnapshot->as_snap->active_count--;\n\n\tif (ActiveSnapshot->as_snap->active_count == 0 &&\n\t\tActiveSnapshot->as_snap->regd_count == 0)\n\t\tFreeSnapshot(ActiveSnapshot->as_snap);\n\n\tpfree(ActiveSnapshot);\n\tActiveSnapshot = newstack;\n\tif (ActiveSnapshot == NULL)\n\t\tOldestActiveSnapshot = NULL;\n\n\tSnapshotResetXmin();\n}"
  },
  {
    "function_name": "UpdateActiveSnapshotCommandId",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
    "lines": "780-803",
    "snippet": "void\nUpdateActiveSnapshotCommandId(void)\n{\n\tCommandId\tsave_curcid,\n\t\t\t\tcurcid;\n\n\tAssert(ActiveSnapshot != NULL);\n\tAssert(ActiveSnapshot->as_snap->active_count == 1);\n\tAssert(ActiveSnapshot->as_snap->regd_count == 0);\n\n\t/*\n\t * Don't allow modification of the active snapshot during parallel\n\t * operation.  We share the snapshot to worker backends at the beginning\n\t * of parallel operation, so any change to the snapshot can lead to\n\t * inconsistencies.  We have other defenses against\n\t * CommandCounterIncrement, but there are a few places that call this\n\t * directly, so we put an additional guard here.\n\t */\n\tsave_curcid = ActiveSnapshot->as_snap->curcid;\n\tcurcid = GetCurrentCommandId(false);\n\tif (IsInParallelMode() && save_curcid != curcid)\n\t\telog(ERROR, \"cannot modify commandid in active snapshot during a parallel operation\");\n\tActiveSnapshot->as_snap->curcid = curcid;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/spin.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/pairingheap.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static ActiveSnapshotElt *ActiveSnapshot = NULL;",
      "static Snapshot CopySnapshot(Snapshot snapshot);",
      "static void FreeSnapshot(Snapshot snapshot);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"cannot modify commandid in active snapshot during a parallel operation\""
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsInParallelMode",
          "args": [],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetCurrentCommandId",
          "args": [
            "false"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "ActiveSnapshot->as_snap->regd_count == 0"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "ActiveSnapshot->as_snap->active_count == 1"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "ActiveSnapshot != NULL"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic ActiveSnapshotElt *ActiveSnapshot = NULL;\nstatic Snapshot CopySnapshot(Snapshot snapshot);\nstatic void FreeSnapshot(Snapshot snapshot);\n\nvoid\nUpdateActiveSnapshotCommandId(void)\n{\n\tCommandId\tsave_curcid,\n\t\t\t\tcurcid;\n\n\tAssert(ActiveSnapshot != NULL);\n\tAssert(ActiveSnapshot->as_snap->active_count == 1);\n\tAssert(ActiveSnapshot->as_snap->regd_count == 0);\n\n\t/*\n\t * Don't allow modification of the active snapshot during parallel\n\t * operation.  We share the snapshot to worker backends at the beginning\n\t * of parallel operation, so any change to the snapshot can lead to\n\t * inconsistencies.  We have other defenses against\n\t * CommandCounterIncrement, but there are a few places that call this\n\t * directly, so we put an additional guard here.\n\t */\n\tsave_curcid = ActiveSnapshot->as_snap->curcid;\n\tcurcid = GetCurrentCommandId(false);\n\tif (IsInParallelMode() && save_curcid != curcid)\n\t\telog(ERROR, \"cannot modify commandid in active snapshot during a parallel operation\");\n\tActiveSnapshot->as_snap->curcid = curcid;\n}"
  },
  {
    "function_name": "PushCopiedSnapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
    "lines": "768-772",
    "snippet": "void\nPushCopiedSnapshot(Snapshot snapshot)\n{\n\tPushActiveSnapshot(CopySnapshot(snapshot));\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/spin.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/pairingheap.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Snapshot CopySnapshot(Snapshot snapshot);",
      "static void FreeSnapshot(Snapshot snapshot);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PushActiveSnapshot",
          "args": [
            "CopySnapshot(snapshot)"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "PushActiveSnapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "732-758",
          "snippet": "void\nPushActiveSnapshot(Snapshot snap)\n{\n\tActiveSnapshotElt *newactive;\n\n\tAssert(snap != InvalidSnapshot);\n\n\tnewactive = MemoryContextAlloc(TopTransactionContext, sizeof(ActiveSnapshotElt));\n\n\t/*\n\t * Checking SecondarySnapshot is probably useless here, but it seems\n\t * better to be sure.\n\t */\n\tif (snap == CurrentSnapshot || snap == SecondarySnapshot || !snap->copied)\n\t\tnewactive->as_snap = CopySnapshot(snap);\n\telse\n\t\tnewactive->as_snap = snap;\n\n\tnewactive->as_next = ActiveSnapshot;\n\tnewactive->as_level = GetCurrentTransactionNestLevel();\n\n\tnewactive->as_snap->active_count++;\n\n\tActiveSnapshot = newactive;\n\tif (OldestActiveSnapshot == NULL)\n\t\tOldestActiveSnapshot = ActiveSnapshot;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Snapshot CurrentSnapshot = NULL;",
            "static Snapshot SecondarySnapshot = NULL;",
            "static ActiveSnapshotElt *ActiveSnapshot = NULL;",
            "static ActiveSnapshotElt *OldestActiveSnapshot = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic Snapshot CurrentSnapshot = NULL;\nstatic Snapshot SecondarySnapshot = NULL;\nstatic ActiveSnapshotElt *ActiveSnapshot = NULL;\nstatic ActiveSnapshotElt *OldestActiveSnapshot = NULL;\n\nvoid\nPushActiveSnapshot(Snapshot snap)\n{\n\tActiveSnapshotElt *newactive;\n\n\tAssert(snap != InvalidSnapshot);\n\n\tnewactive = MemoryContextAlloc(TopTransactionContext, sizeof(ActiveSnapshotElt));\n\n\t/*\n\t * Checking SecondarySnapshot is probably useless here, but it seems\n\t * better to be sure.\n\t */\n\tif (snap == CurrentSnapshot || snap == SecondarySnapshot || !snap->copied)\n\t\tnewactive->as_snap = CopySnapshot(snap);\n\telse\n\t\tnewactive->as_snap = snap;\n\n\tnewactive->as_next = ActiveSnapshot;\n\tnewactive->as_level = GetCurrentTransactionNestLevel();\n\n\tnewactive->as_snap->active_count++;\n\n\tActiveSnapshot = newactive;\n\tif (OldestActiveSnapshot == NULL)\n\t\tOldestActiveSnapshot = ActiveSnapshot;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CopySnapshot",
          "args": [
            "snapshot"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "CopySnapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "659-708",
          "snippet": "static Snapshot\nCopySnapshot(Snapshot snapshot)\n{\n\tSnapshot\tnewsnap;\n\tSize\t\tsubxipoff;\n\tSize\t\tsize;\n\n\tAssert(snapshot != InvalidSnapshot);\n\n\t/* We allocate any XID arrays needed in the same palloc block. */\n\tsize = subxipoff = sizeof(SnapshotData) +\n\t\tsnapshot->xcnt * sizeof(TransactionId);\n\tif (snapshot->subxcnt > 0)\n\t\tsize += snapshot->subxcnt * sizeof(TransactionId);\n\n\tnewsnap = (Snapshot) MemoryContextAlloc(TopTransactionContext, size);\n\tmemcpy(newsnap, snapshot, sizeof(SnapshotData));\n\n\tnewsnap->regd_count = 0;\n\tnewsnap->active_count = 0;\n\tnewsnap->copied = true;\n\n\t/* setup XID array */\n\tif (snapshot->xcnt > 0)\n\t{\n\t\tnewsnap->xip = (TransactionId *) (newsnap + 1);\n\t\tmemcpy(newsnap->xip, snapshot->xip,\n\t\t\t   snapshot->xcnt * sizeof(TransactionId));\n\t}\n\telse\n\t\tnewsnap->xip = NULL;\n\n\t/*\n\t * Setup subXID array. Don't bother to copy it if it had overflowed,\n\t * though, because it's not used anywhere in that case. Except if it's a\n\t * snapshot taken during recovery; all the top-level XIDs are in subxip as\n\t * well in that case, so we mustn't lose them.\n\t */\n\tif (snapshot->subxcnt > 0 &&\n\t\t(!snapshot->suboverflowed || snapshot->takenDuringRecovery))\n\t{\n\t\tnewsnap->subxip = (TransactionId *) ((char *) newsnap + subxipoff);\n\t\tmemcpy(newsnap->subxip, snapshot->subxip,\n\t\t\t   snapshot->subxcnt * sizeof(TransactionId));\n\t}\n\telse\n\t\tnewsnap->subxip = NULL;\n\n\treturn newsnap;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Snapshot CopySnapshot(Snapshot snapshot);",
            "static void FreeSnapshot(Snapshot snapshot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic Snapshot CopySnapshot(Snapshot snapshot);\nstatic void FreeSnapshot(Snapshot snapshot);\n\nstatic Snapshot\nCopySnapshot(Snapshot snapshot)\n{\n\tSnapshot\tnewsnap;\n\tSize\t\tsubxipoff;\n\tSize\t\tsize;\n\n\tAssert(snapshot != InvalidSnapshot);\n\n\t/* We allocate any XID arrays needed in the same palloc block. */\n\tsize = subxipoff = sizeof(SnapshotData) +\n\t\tsnapshot->xcnt * sizeof(TransactionId);\n\tif (snapshot->subxcnt > 0)\n\t\tsize += snapshot->subxcnt * sizeof(TransactionId);\n\n\tnewsnap = (Snapshot) MemoryContextAlloc(TopTransactionContext, size);\n\tmemcpy(newsnap, snapshot, sizeof(SnapshotData));\n\n\tnewsnap->regd_count = 0;\n\tnewsnap->active_count = 0;\n\tnewsnap->copied = true;\n\n\t/* setup XID array */\n\tif (snapshot->xcnt > 0)\n\t{\n\t\tnewsnap->xip = (TransactionId *) (newsnap + 1);\n\t\tmemcpy(newsnap->xip, snapshot->xip,\n\t\t\t   snapshot->xcnt * sizeof(TransactionId));\n\t}\n\telse\n\t\tnewsnap->xip = NULL;\n\n\t/*\n\t * Setup subXID array. Don't bother to copy it if it had overflowed,\n\t * though, because it's not used anywhere in that case. Except if it's a\n\t * snapshot taken during recovery; all the top-level XIDs are in subxip as\n\t * well in that case, so we mustn't lose them.\n\t */\n\tif (snapshot->subxcnt > 0 &&\n\t\t(!snapshot->suboverflowed || snapshot->takenDuringRecovery))\n\t{\n\t\tnewsnap->subxip = (TransactionId *) ((char *) newsnap + subxipoff);\n\t\tmemcpy(newsnap->subxip, snapshot->subxip,\n\t\t\t   snapshot->subxcnt * sizeof(TransactionId));\n\t}\n\telse\n\t\tnewsnap->subxip = NULL;\n\n\treturn newsnap;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic Snapshot CopySnapshot(Snapshot snapshot);\nstatic void FreeSnapshot(Snapshot snapshot);\n\nvoid\nPushCopiedSnapshot(Snapshot snapshot)\n{\n\tPushActiveSnapshot(CopySnapshot(snapshot));\n}"
  },
  {
    "function_name": "PushActiveSnapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
    "lines": "732-758",
    "snippet": "void\nPushActiveSnapshot(Snapshot snap)\n{\n\tActiveSnapshotElt *newactive;\n\n\tAssert(snap != InvalidSnapshot);\n\n\tnewactive = MemoryContextAlloc(TopTransactionContext, sizeof(ActiveSnapshotElt));\n\n\t/*\n\t * Checking SecondarySnapshot is probably useless here, but it seems\n\t * better to be sure.\n\t */\n\tif (snap == CurrentSnapshot || snap == SecondarySnapshot || !snap->copied)\n\t\tnewactive->as_snap = CopySnapshot(snap);\n\telse\n\t\tnewactive->as_snap = snap;\n\n\tnewactive->as_next = ActiveSnapshot;\n\tnewactive->as_level = GetCurrentTransactionNestLevel();\n\n\tnewactive->as_snap->active_count++;\n\n\tActiveSnapshot = newactive;\n\tif (OldestActiveSnapshot == NULL)\n\t\tOldestActiveSnapshot = ActiveSnapshot;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/spin.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/pairingheap.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Snapshot CurrentSnapshot = NULL;",
      "static Snapshot SecondarySnapshot = NULL;",
      "static ActiveSnapshotElt *ActiveSnapshot = NULL;",
      "static ActiveSnapshotElt *OldestActiveSnapshot = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetCurrentTransactionNestLevel",
          "args": [],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CopySnapshot",
          "args": [
            "snap"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "CopySnapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "659-708",
          "snippet": "static Snapshot\nCopySnapshot(Snapshot snapshot)\n{\n\tSnapshot\tnewsnap;\n\tSize\t\tsubxipoff;\n\tSize\t\tsize;\n\n\tAssert(snapshot != InvalidSnapshot);\n\n\t/* We allocate any XID arrays needed in the same palloc block. */\n\tsize = subxipoff = sizeof(SnapshotData) +\n\t\tsnapshot->xcnt * sizeof(TransactionId);\n\tif (snapshot->subxcnt > 0)\n\t\tsize += snapshot->subxcnt * sizeof(TransactionId);\n\n\tnewsnap = (Snapshot) MemoryContextAlloc(TopTransactionContext, size);\n\tmemcpy(newsnap, snapshot, sizeof(SnapshotData));\n\n\tnewsnap->regd_count = 0;\n\tnewsnap->active_count = 0;\n\tnewsnap->copied = true;\n\n\t/* setup XID array */\n\tif (snapshot->xcnt > 0)\n\t{\n\t\tnewsnap->xip = (TransactionId *) (newsnap + 1);\n\t\tmemcpy(newsnap->xip, snapshot->xip,\n\t\t\t   snapshot->xcnt * sizeof(TransactionId));\n\t}\n\telse\n\t\tnewsnap->xip = NULL;\n\n\t/*\n\t * Setup subXID array. Don't bother to copy it if it had overflowed,\n\t * though, because it's not used anywhere in that case. Except if it's a\n\t * snapshot taken during recovery; all the top-level XIDs are in subxip as\n\t * well in that case, so we mustn't lose them.\n\t */\n\tif (snapshot->subxcnt > 0 &&\n\t\t(!snapshot->suboverflowed || snapshot->takenDuringRecovery))\n\t{\n\t\tnewsnap->subxip = (TransactionId *) ((char *) newsnap + subxipoff);\n\t\tmemcpy(newsnap->subxip, snapshot->subxip,\n\t\t\t   snapshot->subxcnt * sizeof(TransactionId));\n\t}\n\telse\n\t\tnewsnap->subxip = NULL;\n\n\treturn newsnap;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Snapshot CopySnapshot(Snapshot snapshot);",
            "static void FreeSnapshot(Snapshot snapshot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic Snapshot CopySnapshot(Snapshot snapshot);\nstatic void FreeSnapshot(Snapshot snapshot);\n\nstatic Snapshot\nCopySnapshot(Snapshot snapshot)\n{\n\tSnapshot\tnewsnap;\n\tSize\t\tsubxipoff;\n\tSize\t\tsize;\n\n\tAssert(snapshot != InvalidSnapshot);\n\n\t/* We allocate any XID arrays needed in the same palloc block. */\n\tsize = subxipoff = sizeof(SnapshotData) +\n\t\tsnapshot->xcnt * sizeof(TransactionId);\n\tif (snapshot->subxcnt > 0)\n\t\tsize += snapshot->subxcnt * sizeof(TransactionId);\n\n\tnewsnap = (Snapshot) MemoryContextAlloc(TopTransactionContext, size);\n\tmemcpy(newsnap, snapshot, sizeof(SnapshotData));\n\n\tnewsnap->regd_count = 0;\n\tnewsnap->active_count = 0;\n\tnewsnap->copied = true;\n\n\t/* setup XID array */\n\tif (snapshot->xcnt > 0)\n\t{\n\t\tnewsnap->xip = (TransactionId *) (newsnap + 1);\n\t\tmemcpy(newsnap->xip, snapshot->xip,\n\t\t\t   snapshot->xcnt * sizeof(TransactionId));\n\t}\n\telse\n\t\tnewsnap->xip = NULL;\n\n\t/*\n\t * Setup subXID array. Don't bother to copy it if it had overflowed,\n\t * though, because it's not used anywhere in that case. Except if it's a\n\t * snapshot taken during recovery; all the top-level XIDs are in subxip as\n\t * well in that case, so we mustn't lose them.\n\t */\n\tif (snapshot->subxcnt > 0 &&\n\t\t(!snapshot->suboverflowed || snapshot->takenDuringRecovery))\n\t{\n\t\tnewsnap->subxip = (TransactionId *) ((char *) newsnap + subxipoff);\n\t\tmemcpy(newsnap->subxip, snapshot->subxip,\n\t\t\t   snapshot->subxcnt * sizeof(TransactionId));\n\t}\n\telse\n\t\tnewsnap->subxip = NULL;\n\n\treturn newsnap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextAlloc",
          "args": [
            "TopTransactionContext",
            "sizeof(ActiveSnapshotElt)"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1079-1106",
          "snippet": "void *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "snap != InvalidSnapshot"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic Snapshot CurrentSnapshot = NULL;\nstatic Snapshot SecondarySnapshot = NULL;\nstatic ActiveSnapshotElt *ActiveSnapshot = NULL;\nstatic ActiveSnapshotElt *OldestActiveSnapshot = NULL;\n\nvoid\nPushActiveSnapshot(Snapshot snap)\n{\n\tActiveSnapshotElt *newactive;\n\n\tAssert(snap != InvalidSnapshot);\n\n\tnewactive = MemoryContextAlloc(TopTransactionContext, sizeof(ActiveSnapshotElt));\n\n\t/*\n\t * Checking SecondarySnapshot is probably useless here, but it seems\n\t * better to be sure.\n\t */\n\tif (snap == CurrentSnapshot || snap == SecondarySnapshot || !snap->copied)\n\t\tnewactive->as_snap = CopySnapshot(snap);\n\telse\n\t\tnewactive->as_snap = snap;\n\n\tnewactive->as_next = ActiveSnapshot;\n\tnewactive->as_level = GetCurrentTransactionNestLevel();\n\n\tnewactive->as_snap->active_count++;\n\n\tActiveSnapshot = newactive;\n\tif (OldestActiveSnapshot == NULL)\n\t\tOldestActiveSnapshot = ActiveSnapshot;\n}"
  },
  {
    "function_name": "FreeSnapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
    "lines": "714-722",
    "snippet": "static void\nFreeSnapshot(Snapshot snapshot)\n{\n\tAssert(snapshot->regd_count == 0);\n\tAssert(snapshot->active_count == 0);\n\tAssert(snapshot->copied);\n\n\tpfree(snapshot);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/spin.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/pairingheap.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Snapshot CopySnapshot(Snapshot snapshot);",
      "static void FreeSnapshot(Snapshot snapshot);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "snapshot"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "snapshot->copied"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "snapshot->active_count == 0"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "snapshot->regd_count == 0"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic Snapshot CopySnapshot(Snapshot snapshot);\nstatic void FreeSnapshot(Snapshot snapshot);\n\nstatic void\nFreeSnapshot(Snapshot snapshot)\n{\n\tAssert(snapshot->regd_count == 0);\n\tAssert(snapshot->active_count == 0);\n\tAssert(snapshot->copied);\n\n\tpfree(snapshot);\n}"
  },
  {
    "function_name": "CopySnapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
    "lines": "659-708",
    "snippet": "static Snapshot\nCopySnapshot(Snapshot snapshot)\n{\n\tSnapshot\tnewsnap;\n\tSize\t\tsubxipoff;\n\tSize\t\tsize;\n\n\tAssert(snapshot != InvalidSnapshot);\n\n\t/* We allocate any XID arrays needed in the same palloc block. */\n\tsize = subxipoff = sizeof(SnapshotData) +\n\t\tsnapshot->xcnt * sizeof(TransactionId);\n\tif (snapshot->subxcnt > 0)\n\t\tsize += snapshot->subxcnt * sizeof(TransactionId);\n\n\tnewsnap = (Snapshot) MemoryContextAlloc(TopTransactionContext, size);\n\tmemcpy(newsnap, snapshot, sizeof(SnapshotData));\n\n\tnewsnap->regd_count = 0;\n\tnewsnap->active_count = 0;\n\tnewsnap->copied = true;\n\n\t/* setup XID array */\n\tif (snapshot->xcnt > 0)\n\t{\n\t\tnewsnap->xip = (TransactionId *) (newsnap + 1);\n\t\tmemcpy(newsnap->xip, snapshot->xip,\n\t\t\t   snapshot->xcnt * sizeof(TransactionId));\n\t}\n\telse\n\t\tnewsnap->xip = NULL;\n\n\t/*\n\t * Setup subXID array. Don't bother to copy it if it had overflowed,\n\t * though, because it's not used anywhere in that case. Except if it's a\n\t * snapshot taken during recovery; all the top-level XIDs are in subxip as\n\t * well in that case, so we mustn't lose them.\n\t */\n\tif (snapshot->subxcnt > 0 &&\n\t\t(!snapshot->suboverflowed || snapshot->takenDuringRecovery))\n\t{\n\t\tnewsnap->subxip = (TransactionId *) ((char *) newsnap + subxipoff);\n\t\tmemcpy(newsnap->subxip, snapshot->subxip,\n\t\t\t   snapshot->subxcnt * sizeof(TransactionId));\n\t}\n\telse\n\t\tnewsnap->subxip = NULL;\n\n\treturn newsnap;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/spin.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/pairingheap.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Snapshot CopySnapshot(Snapshot snapshot);",
      "static void FreeSnapshot(Snapshot snapshot);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "newsnap->subxip",
            "snapshot->subxip",
            "snapshot->subxcnt * sizeof(TransactionId)"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "newsnap->xip",
            "snapshot->xip",
            "snapshot->xcnt * sizeof(TransactionId)"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "newsnap",
            "snapshot",
            "sizeof(SnapshotData)"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextAlloc",
          "args": [
            "TopTransactionContext",
            "size"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1079-1106",
          "snippet": "void *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "snapshot != InvalidSnapshot"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic Snapshot CopySnapshot(Snapshot snapshot);\nstatic void FreeSnapshot(Snapshot snapshot);\n\nstatic Snapshot\nCopySnapshot(Snapshot snapshot)\n{\n\tSnapshot\tnewsnap;\n\tSize\t\tsubxipoff;\n\tSize\t\tsize;\n\n\tAssert(snapshot != InvalidSnapshot);\n\n\t/* We allocate any XID arrays needed in the same palloc block. */\n\tsize = subxipoff = sizeof(SnapshotData) +\n\t\tsnapshot->xcnt * sizeof(TransactionId);\n\tif (snapshot->subxcnt > 0)\n\t\tsize += snapshot->subxcnt * sizeof(TransactionId);\n\n\tnewsnap = (Snapshot) MemoryContextAlloc(TopTransactionContext, size);\n\tmemcpy(newsnap, snapshot, sizeof(SnapshotData));\n\n\tnewsnap->regd_count = 0;\n\tnewsnap->active_count = 0;\n\tnewsnap->copied = true;\n\n\t/* setup XID array */\n\tif (snapshot->xcnt > 0)\n\t{\n\t\tnewsnap->xip = (TransactionId *) (newsnap + 1);\n\t\tmemcpy(newsnap->xip, snapshot->xip,\n\t\t\t   snapshot->xcnt * sizeof(TransactionId));\n\t}\n\telse\n\t\tnewsnap->xip = NULL;\n\n\t/*\n\t * Setup subXID array. Don't bother to copy it if it had overflowed,\n\t * though, because it's not used anywhere in that case. Except if it's a\n\t * snapshot taken during recovery; all the top-level XIDs are in subxip as\n\t * well in that case, so we mustn't lose them.\n\t */\n\tif (snapshot->subxcnt > 0 &&\n\t\t(!snapshot->suboverflowed || snapshot->takenDuringRecovery))\n\t{\n\t\tnewsnap->subxip = (TransactionId *) ((char *) newsnap + subxipoff);\n\t\tmemcpy(newsnap->subxip, snapshot->subxip,\n\t\t\t   snapshot->subxcnt * sizeof(TransactionId));\n\t}\n\telse\n\t\tnewsnap->subxip = NULL;\n\n\treturn newsnap;\n}"
  },
  {
    "function_name": "SetTransactionSnapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
    "lines": "564-650",
    "snippet": "static void\nSetTransactionSnapshot(Snapshot sourcesnap, VirtualTransactionId *sourcevxid,\n\t\t\t\t\t   int sourcepid, PGPROC *sourceproc)\n{\n\t/* Caller should have checked this already */\n\tAssert(!FirstSnapshotSet);\n\n\t/* Better do this to ensure following Assert succeeds. */\n\tInvalidateCatalogSnapshot();\n\n\tAssert(pairingheap_is_empty(&RegisteredSnapshots));\n\tAssert(FirstXactSnapshot == NULL);\n\tAssert(!HistoricSnapshotActive());\n\n\t/*\n\t * Even though we are not going to use the snapshot it computes, we must\n\t * call GetSnapshotData, for two reasons: (1) to be sure that\n\t * CurrentSnapshotData's XID arrays have been allocated, and (2) to update\n\t * RecentXmin and RecentGlobalXmin.  (We could alternatively include those\n\t * two variables in exported snapshot files, but it seems better to have\n\t * snapshot importers compute reasonably up-to-date values for them.)\n\t */\n\tCurrentSnapshot = GetSnapshotData(&CurrentSnapshotData);\n\n\t/*\n\t * Now copy appropriate fields from the source snapshot.\n\t */\n\tCurrentSnapshot->xmin = sourcesnap->xmin;\n\tCurrentSnapshot->xmax = sourcesnap->xmax;\n\tCurrentSnapshot->xcnt = sourcesnap->xcnt;\n\tAssert(sourcesnap->xcnt <= GetMaxSnapshotXidCount());\n\tmemcpy(CurrentSnapshot->xip, sourcesnap->xip,\n\t\t   sourcesnap->xcnt * sizeof(TransactionId));\n\tCurrentSnapshot->subxcnt = sourcesnap->subxcnt;\n\tAssert(sourcesnap->subxcnt <= GetMaxSnapshotSubxidCount());\n\tmemcpy(CurrentSnapshot->subxip, sourcesnap->subxip,\n\t\t   sourcesnap->subxcnt * sizeof(TransactionId));\n\tCurrentSnapshot->suboverflowed = sourcesnap->suboverflowed;\n\tCurrentSnapshot->takenDuringRecovery = sourcesnap->takenDuringRecovery;\n\t/* NB: curcid should NOT be copied, it's a local matter */\n\n\t/*\n\t * Now we have to fix what GetSnapshotData did with MyPgXact->xmin and\n\t * TransactionXmin.  There is a race condition: to make sure we are not\n\t * causing the global xmin to go backwards, we have to test that the\n\t * source transaction is still running, and that has to be done\n\t * atomically. So let procarray.c do it.\n\t *\n\t * Note: in serializable mode, predicate.c will do this a second time. It\n\t * doesn't seem worth contorting the logic here to avoid two calls,\n\t * especially since it's not clear that predicate.c *must* do this.\n\t */\n\tif (sourceproc != NULL)\n\t{\n\t\tif (!ProcArrayInstallRestoredXmin(CurrentSnapshot->xmin, sourceproc))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\n\t\t\t\t\t errmsg(\"could not import the requested snapshot\"),\n\t\t\t\t\t errdetail(\"The source transaction is not running anymore.\")));\n\t}\n\telse if (!ProcArrayInstallImportedXmin(CurrentSnapshot->xmin, sourcevxid))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\n\t\t\t\t errmsg(\"could not import the requested snapshot\"),\n\t\t\t\t errdetail(\"The source process with PID %d is not running anymore.\",\n\t\t\t\t\t\t   sourcepid)));\n\n\t/*\n\t * In transaction-snapshot mode, the first snapshot must live until end of\n\t * xact, so we must make a copy of it.  Furthermore, if we're running in\n\t * serializable mode, predicate.c needs to do its own processing.\n\t */\n\tif (IsolationUsesXactSnapshot())\n\t{\n\t\tif (IsolationIsSerializable())\n\t\t\tSetSerializableTransactionSnapshot(CurrentSnapshot, sourcevxid,\n\t\t\t\t\t\t\t\t\t\t\t   sourcepid);\n\t\t/* Make a saved copy */\n\t\tCurrentSnapshot = CopySnapshot(CurrentSnapshot);\n\t\tFirstXactSnapshot = CurrentSnapshot;\n\t\t/* Mark it as \"registered\" in FirstXactSnapshot */\n\t\tFirstXactSnapshot->regd_count++;\n\t\tpairingheap_add(&RegisteredSnapshots, &FirstXactSnapshot->ph_node);\n\t}\n\n\tFirstSnapshotSet = true;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/spin.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/pairingheap.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static SnapshotData CurrentSnapshotData = {HeapTupleSatisfiesMVCC};",
      "static Snapshot CurrentSnapshot = NULL;",
      "TransactionId TransactionXmin = FirstNormalTransactionId;",
      "TransactionId RecentXmin = FirstNormalTransactionId;",
      "TransactionId RecentGlobalXmin = InvalidTransactionId;",
      "static pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};",
      "bool\t\tFirstSnapshotSet = false;",
      "static Snapshot FirstXactSnapshot = NULL;",
      "static Snapshot CopySnapshot(Snapshot snapshot);",
      "static void FreeSnapshot(Snapshot snapshot);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pairingheap_add",
          "args": [
            "&RegisteredSnapshots",
            "&FirstXactSnapshot->ph_node"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CopySnapshot",
          "args": [
            "CurrentSnapshot"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "CopySnapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "659-708",
          "snippet": "static Snapshot\nCopySnapshot(Snapshot snapshot)\n{\n\tSnapshot\tnewsnap;\n\tSize\t\tsubxipoff;\n\tSize\t\tsize;\n\n\tAssert(snapshot != InvalidSnapshot);\n\n\t/* We allocate any XID arrays needed in the same palloc block. */\n\tsize = subxipoff = sizeof(SnapshotData) +\n\t\tsnapshot->xcnt * sizeof(TransactionId);\n\tif (snapshot->subxcnt > 0)\n\t\tsize += snapshot->subxcnt * sizeof(TransactionId);\n\n\tnewsnap = (Snapshot) MemoryContextAlloc(TopTransactionContext, size);\n\tmemcpy(newsnap, snapshot, sizeof(SnapshotData));\n\n\tnewsnap->regd_count = 0;\n\tnewsnap->active_count = 0;\n\tnewsnap->copied = true;\n\n\t/* setup XID array */\n\tif (snapshot->xcnt > 0)\n\t{\n\t\tnewsnap->xip = (TransactionId *) (newsnap + 1);\n\t\tmemcpy(newsnap->xip, snapshot->xip,\n\t\t\t   snapshot->xcnt * sizeof(TransactionId));\n\t}\n\telse\n\t\tnewsnap->xip = NULL;\n\n\t/*\n\t * Setup subXID array. Don't bother to copy it if it had overflowed,\n\t * though, because it's not used anywhere in that case. Except if it's a\n\t * snapshot taken during recovery; all the top-level XIDs are in subxip as\n\t * well in that case, so we mustn't lose them.\n\t */\n\tif (snapshot->subxcnt > 0 &&\n\t\t(!snapshot->suboverflowed || snapshot->takenDuringRecovery))\n\t{\n\t\tnewsnap->subxip = (TransactionId *) ((char *) newsnap + subxipoff);\n\t\tmemcpy(newsnap->subxip, snapshot->subxip,\n\t\t\t   snapshot->subxcnt * sizeof(TransactionId));\n\t}\n\telse\n\t\tnewsnap->subxip = NULL;\n\n\treturn newsnap;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Snapshot CopySnapshot(Snapshot snapshot);",
            "static void FreeSnapshot(Snapshot snapshot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic Snapshot CopySnapshot(Snapshot snapshot);\nstatic void FreeSnapshot(Snapshot snapshot);\n\nstatic Snapshot\nCopySnapshot(Snapshot snapshot)\n{\n\tSnapshot\tnewsnap;\n\tSize\t\tsubxipoff;\n\tSize\t\tsize;\n\n\tAssert(snapshot != InvalidSnapshot);\n\n\t/* We allocate any XID arrays needed in the same palloc block. */\n\tsize = subxipoff = sizeof(SnapshotData) +\n\t\tsnapshot->xcnt * sizeof(TransactionId);\n\tif (snapshot->subxcnt > 0)\n\t\tsize += snapshot->subxcnt * sizeof(TransactionId);\n\n\tnewsnap = (Snapshot) MemoryContextAlloc(TopTransactionContext, size);\n\tmemcpy(newsnap, snapshot, sizeof(SnapshotData));\n\n\tnewsnap->regd_count = 0;\n\tnewsnap->active_count = 0;\n\tnewsnap->copied = true;\n\n\t/* setup XID array */\n\tif (snapshot->xcnt > 0)\n\t{\n\t\tnewsnap->xip = (TransactionId *) (newsnap + 1);\n\t\tmemcpy(newsnap->xip, snapshot->xip,\n\t\t\t   snapshot->xcnt * sizeof(TransactionId));\n\t}\n\telse\n\t\tnewsnap->xip = NULL;\n\n\t/*\n\t * Setup subXID array. Don't bother to copy it if it had overflowed,\n\t * though, because it's not used anywhere in that case. Except if it's a\n\t * snapshot taken during recovery; all the top-level XIDs are in subxip as\n\t * well in that case, so we mustn't lose them.\n\t */\n\tif (snapshot->subxcnt > 0 &&\n\t\t(!snapshot->suboverflowed || snapshot->takenDuringRecovery))\n\t{\n\t\tnewsnap->subxip = (TransactionId *) ((char *) newsnap + subxipoff);\n\t\tmemcpy(newsnap->subxip, snapshot->subxip,\n\t\t\t   snapshot->subxcnt * sizeof(TransactionId));\n\t}\n\telse\n\t\tnewsnap->subxip = NULL;\n\n\treturn newsnap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetSerializableTransactionSnapshot",
          "args": [
            "CurrentSnapshot",
            "sourcevxid",
            "sourcepid"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsolationIsSerializable",
          "args": [],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsolationUsesXactSnapshot",
          "args": [],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\n\t\t\t\t errmsg(\"could not import the requested snapshot\"),\n\t\t\t\t errdetail(\"The source process with PID %d is not running anymore.\",\n\t\t\t\t\t\t   sourcepid))"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errdetail",
          "args": [
            "\"The source process with PID %d is not running anymore.\"",
            "sourcepid"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "errdetail_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "918-933",
          "snippet": "int\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not import the requested snapshot\""
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ProcArrayInstallImportedXmin",
          "args": [
            "CurrentSnapshot->xmin",
            "sourcevxid"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\n\t\t\t\t\t errmsg(\"could not import the requested snapshot\"),\n\t\t\t\t\t errdetail(\"The source transaction is not running anymore.\"))"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ProcArrayInstallRestoredXmin",
          "args": [
            "CurrentSnapshot->xmin",
            "sourceproc"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "CurrentSnapshot->subxip",
            "sourcesnap->subxip",
            "sourcesnap->subxcnt * sizeof(TransactionId)"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "sourcesnap->subxcnt <= GetMaxSnapshotSubxidCount()"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetMaxSnapshotSubxidCount",
          "args": [],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "CurrentSnapshot->xip",
            "sourcesnap->xip",
            "sourcesnap->xcnt * sizeof(TransactionId)"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "sourcesnap->xcnt <= GetMaxSnapshotXidCount()"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetMaxSnapshotXidCount",
          "args": [],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetSnapshotData",
          "args": [
            "&CurrentSnapshotData"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!HistoricSnapshotActive()"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HistoricSnapshotActive",
          "args": [],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "HistoricSnapshotActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "2023-2027",
          "snippet": "bool\nHistoricSnapshotActive(void)\n{\n\treturn HistoricSnapshot != NULL;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Snapshot HistoricSnapshot = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic Snapshot HistoricSnapshot = NULL;\n\nbool\nHistoricSnapshotActive(void)\n{\n\treturn HistoricSnapshot != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "FirstXactSnapshot == NULL"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "pairingheap_is_empty(&RegisteredSnapshots)"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pairingheap_is_empty",
          "args": [
            "&RegisteredSnapshots"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InvalidateCatalogSnapshot",
          "args": [],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "InvalidateCatalogSnapshotConditionally",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "530-537",
          "snippet": "void\nInvalidateCatalogSnapshotConditionally(void)\n{\n\tif (CatalogSnapshot &&\n\t\tActiveSnapshot == NULL &&\n\t\tpairingheap_is_singular(&RegisteredSnapshots))\n\t\tInvalidateCatalogSnapshot();\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Snapshot CatalogSnapshot = NULL;",
            "static ActiveSnapshotElt *ActiveSnapshot = NULL;",
            "static pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic Snapshot CatalogSnapshot = NULL;\nstatic ActiveSnapshotElt *ActiveSnapshot = NULL;\nstatic pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};\n\nvoid\nInvalidateCatalogSnapshotConditionally(void)\n{\n\tif (CatalogSnapshot &&\n\t\tActiveSnapshot == NULL &&\n\t\tpairingheap_is_singular(&RegisteredSnapshots))\n\t\tInvalidateCatalogSnapshot();\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!FirstSnapshotSet"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic SnapshotData CurrentSnapshotData = {HeapTupleSatisfiesMVCC};\nstatic Snapshot CurrentSnapshot = NULL;\nTransactionId TransactionXmin = FirstNormalTransactionId;\nTransactionId RecentXmin = FirstNormalTransactionId;\nTransactionId RecentGlobalXmin = InvalidTransactionId;\nstatic pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};\nbool\t\tFirstSnapshotSet = false;\nstatic Snapshot FirstXactSnapshot = NULL;\nstatic Snapshot CopySnapshot(Snapshot snapshot);\nstatic void FreeSnapshot(Snapshot snapshot);\n\nstatic void\nSetTransactionSnapshot(Snapshot sourcesnap, VirtualTransactionId *sourcevxid,\n\t\t\t\t\t   int sourcepid, PGPROC *sourceproc)\n{\n\t/* Caller should have checked this already */\n\tAssert(!FirstSnapshotSet);\n\n\t/* Better do this to ensure following Assert succeeds. */\n\tInvalidateCatalogSnapshot();\n\n\tAssert(pairingheap_is_empty(&RegisteredSnapshots));\n\tAssert(FirstXactSnapshot == NULL);\n\tAssert(!HistoricSnapshotActive());\n\n\t/*\n\t * Even though we are not going to use the snapshot it computes, we must\n\t * call GetSnapshotData, for two reasons: (1) to be sure that\n\t * CurrentSnapshotData's XID arrays have been allocated, and (2) to update\n\t * RecentXmin and RecentGlobalXmin.  (We could alternatively include those\n\t * two variables in exported snapshot files, but it seems better to have\n\t * snapshot importers compute reasonably up-to-date values for them.)\n\t */\n\tCurrentSnapshot = GetSnapshotData(&CurrentSnapshotData);\n\n\t/*\n\t * Now copy appropriate fields from the source snapshot.\n\t */\n\tCurrentSnapshot->xmin = sourcesnap->xmin;\n\tCurrentSnapshot->xmax = sourcesnap->xmax;\n\tCurrentSnapshot->xcnt = sourcesnap->xcnt;\n\tAssert(sourcesnap->xcnt <= GetMaxSnapshotXidCount());\n\tmemcpy(CurrentSnapshot->xip, sourcesnap->xip,\n\t\t   sourcesnap->xcnt * sizeof(TransactionId));\n\tCurrentSnapshot->subxcnt = sourcesnap->subxcnt;\n\tAssert(sourcesnap->subxcnt <= GetMaxSnapshotSubxidCount());\n\tmemcpy(CurrentSnapshot->subxip, sourcesnap->subxip,\n\t\t   sourcesnap->subxcnt * sizeof(TransactionId));\n\tCurrentSnapshot->suboverflowed = sourcesnap->suboverflowed;\n\tCurrentSnapshot->takenDuringRecovery = sourcesnap->takenDuringRecovery;\n\t/* NB: curcid should NOT be copied, it's a local matter */\n\n\t/*\n\t * Now we have to fix what GetSnapshotData did with MyPgXact->xmin and\n\t * TransactionXmin.  There is a race condition: to make sure we are not\n\t * causing the global xmin to go backwards, we have to test that the\n\t * source transaction is still running, and that has to be done\n\t * atomically. So let procarray.c do it.\n\t *\n\t * Note: in serializable mode, predicate.c will do this a second time. It\n\t * doesn't seem worth contorting the logic here to avoid two calls,\n\t * especially since it's not clear that predicate.c *must* do this.\n\t */\n\tif (sourceproc != NULL)\n\t{\n\t\tif (!ProcArrayInstallRestoredXmin(CurrentSnapshot->xmin, sourceproc))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\n\t\t\t\t\t errmsg(\"could not import the requested snapshot\"),\n\t\t\t\t\t errdetail(\"The source transaction is not running anymore.\")));\n\t}\n\telse if (!ProcArrayInstallImportedXmin(CurrentSnapshot->xmin, sourcevxid))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\n\t\t\t\t errmsg(\"could not import the requested snapshot\"),\n\t\t\t\t errdetail(\"The source process with PID %d is not running anymore.\",\n\t\t\t\t\t\t   sourcepid)));\n\n\t/*\n\t * In transaction-snapshot mode, the first snapshot must live until end of\n\t * xact, so we must make a copy of it.  Furthermore, if we're running in\n\t * serializable mode, predicate.c needs to do its own processing.\n\t */\n\tif (IsolationUsesXactSnapshot())\n\t{\n\t\tif (IsolationIsSerializable())\n\t\t\tSetSerializableTransactionSnapshot(CurrentSnapshot, sourcevxid,\n\t\t\t\t\t\t\t\t\t\t\t   sourcepid);\n\t\t/* Make a saved copy */\n\t\tCurrentSnapshot = CopySnapshot(CurrentSnapshot);\n\t\tFirstXactSnapshot = CurrentSnapshot;\n\t\t/* Mark it as \"registered\" in FirstXactSnapshot */\n\t\tFirstXactSnapshot->regd_count++;\n\t\tpairingheap_add(&RegisteredSnapshots, &FirstXactSnapshot->ph_node);\n\t}\n\n\tFirstSnapshotSet = true;\n}"
  },
  {
    "function_name": "SnapshotSetCommandId",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
    "lines": "543-554",
    "snippet": "void\nSnapshotSetCommandId(CommandId curcid)\n{\n\tif (!FirstSnapshotSet)\n\t\treturn;\n\n\tif (CurrentSnapshot)\n\t\tCurrentSnapshot->curcid = curcid;\n\tif (SecondarySnapshot)\n\t\tSecondarySnapshot->curcid = curcid;\n\t/* Should we do the same with CatalogSnapshot? */\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/spin.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/pairingheap.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Snapshot CurrentSnapshot = NULL;",
      "static Snapshot SecondarySnapshot = NULL;",
      "static Snapshot CatalogSnapshot = NULL;",
      "bool\t\tFirstSnapshotSet = false;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic Snapshot CurrentSnapshot = NULL;\nstatic Snapshot SecondarySnapshot = NULL;\nstatic Snapshot CatalogSnapshot = NULL;\nbool\t\tFirstSnapshotSet = false;\n\nvoid\nSnapshotSetCommandId(CommandId curcid)\n{\n\tif (!FirstSnapshotSet)\n\t\treturn;\n\n\tif (CurrentSnapshot)\n\t\tCurrentSnapshot->curcid = curcid;\n\tif (SecondarySnapshot)\n\t\tSecondarySnapshot->curcid = curcid;\n\t/* Should we do the same with CatalogSnapshot? */\n}"
  },
  {
    "function_name": "InvalidateCatalogSnapshotConditionally",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
    "lines": "530-537",
    "snippet": "void\nInvalidateCatalogSnapshotConditionally(void)\n{\n\tif (CatalogSnapshot &&\n\t\tActiveSnapshot == NULL &&\n\t\tpairingheap_is_singular(&RegisteredSnapshots))\n\t\tInvalidateCatalogSnapshot();\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/spin.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/pairingheap.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Snapshot CatalogSnapshot = NULL;",
      "static ActiveSnapshotElt *ActiveSnapshot = NULL;",
      "static pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "InvalidateCatalogSnapshot",
          "args": [],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "InvalidateCatalogSnapshotConditionally",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "530-537",
          "snippet": "void\nInvalidateCatalogSnapshotConditionally(void)\n{\n\tif (CatalogSnapshot &&\n\t\tActiveSnapshot == NULL &&\n\t\tpairingheap_is_singular(&RegisteredSnapshots))\n\t\tInvalidateCatalogSnapshot();\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "pairingheap_is_singular",
          "args": [
            "&RegisteredSnapshots"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic Snapshot CatalogSnapshot = NULL;\nstatic ActiveSnapshotElt *ActiveSnapshot = NULL;\nstatic pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};\n\nvoid\nInvalidateCatalogSnapshotConditionally(void)\n{\n\tif (CatalogSnapshot &&\n\t\tActiveSnapshot == NULL &&\n\t\tpairingheap_is_singular(&RegisteredSnapshots))\n\t\tInvalidateCatalogSnapshot();\n}"
  },
  {
    "function_name": "InvalidateCatalogSnapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
    "lines": "509-518",
    "snippet": "void\nInvalidateCatalogSnapshot(void)\n{\n\tif (CatalogSnapshot)\n\t{\n\t\tpairingheap_remove(&RegisteredSnapshots, &CatalogSnapshot->ph_node);\n\t\tCatalogSnapshot = NULL;\n\t\tSnapshotResetXmin();\n\t}\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/spin.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/pairingheap.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Snapshot CatalogSnapshot = NULL;",
      "static pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};",
      "static void SnapshotResetXmin(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SnapshotResetXmin",
          "args": [],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "SnapshotResetXmin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "977-996",
          "snippet": "static void\nSnapshotResetXmin(void)\n{\n\tSnapshot\tminSnapshot;\n\n\tif (ActiveSnapshot != NULL)\n\t\treturn;\n\n\tif (pairingheap_is_empty(&RegisteredSnapshots))\n\t{\n\t\tMyPgXact->xmin = InvalidTransactionId;\n\t\treturn;\n\t}\n\n\tminSnapshot = pairingheap_container(SnapshotData, ph_node,\n\t\t\t\t\t\t\t\t\t\tpairingheap_first(&RegisteredSnapshots));\n\n\tif (TransactionIdPrecedes(MyPgXact->xmin, minSnapshot->xmin))\n\t\tMyPgXact->xmin = minSnapshot->xmin;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ActiveSnapshotElt *ActiveSnapshot = NULL;",
            "static pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};",
            "static void SnapshotResetXmin(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic ActiveSnapshotElt *ActiveSnapshot = NULL;\nstatic pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};\nstatic void SnapshotResetXmin(void);\n\nstatic void\nSnapshotResetXmin(void)\n{\n\tSnapshot\tminSnapshot;\n\n\tif (ActiveSnapshot != NULL)\n\t\treturn;\n\n\tif (pairingheap_is_empty(&RegisteredSnapshots))\n\t{\n\t\tMyPgXact->xmin = InvalidTransactionId;\n\t\treturn;\n\t}\n\n\tminSnapshot = pairingheap_container(SnapshotData, ph_node,\n\t\t\t\t\t\t\t\t\t\tpairingheap_first(&RegisteredSnapshots));\n\n\tif (TransactionIdPrecedes(MyPgXact->xmin, minSnapshot->xmin))\n\t\tMyPgXact->xmin = minSnapshot->xmin;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pairingheap_remove",
          "args": [
            "&RegisteredSnapshots",
            "&CatalogSnapshot->ph_node"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic Snapshot CatalogSnapshot = NULL;\nstatic pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};\nstatic void SnapshotResetXmin(void);\n\nvoid\nInvalidateCatalogSnapshot(void)\n{\n\tif (CatalogSnapshot)\n\t{\n\t\tpairingheap_remove(&RegisteredSnapshots, &CatalogSnapshot->ph_node);\n\t\tCatalogSnapshot = NULL;\n\t\tSnapshotResetXmin();\n\t}\n}"
  },
  {
    "function_name": "GetNonHistoricCatalogSnapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
    "lines": "461-497",
    "snippet": "Snapshot\nGetNonHistoricCatalogSnapshot(Oid relid)\n{\n\t/*\n\t * If the caller is trying to scan a relation that has no syscache, no\n\t * catcache invalidations will be sent when it is updated.  For a few key\n\t * relations, snapshot invalidations are sent instead.  If we're trying to\n\t * scan a relation for which neither catcache nor snapshot invalidations\n\t * are sent, we must refresh the snapshot every time.\n\t */\n\tif (CatalogSnapshot &&\n\t\t!RelationInvalidatesSnapshotsOnly(relid) &&\n\t\t!RelationHasSysCache(relid))\n\t\tInvalidateCatalogSnapshot();\n\n\tif (CatalogSnapshot == NULL)\n\t{\n\t\t/* Get new snapshot. */\n\t\tCatalogSnapshot = GetSnapshotData(&CatalogSnapshotData);\n\n\t\t/*\n\t\t * Make sure the catalog snapshot will be accounted for in decisions\n\t\t * about advancing PGXACT->xmin.  We could apply RegisterSnapshot, but\n\t\t * that would result in making a physical copy, which is overkill; and\n\t\t * it would also create a dependency on some resource owner, which we\n\t\t * do not want for reasons explained at the head of this file. Instead\n\t\t * just shove the CatalogSnapshot into the pairing heap manually. This\n\t\t * has to be reversed in InvalidateCatalogSnapshot, of course.\n\t\t *\n\t\t * NB: it had better be impossible for this to throw error, since the\n\t\t * CatalogSnapshot pointer is already valid.\n\t\t */\n\t\tpairingheap_add(&RegisteredSnapshots, &CatalogSnapshot->ph_node);\n\t}\n\n\treturn CatalogSnapshot;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/spin.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/pairingheap.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "SnapshotData CatalogSnapshotData = {HeapTupleSatisfiesMVCC};",
      "static Snapshot CatalogSnapshot = NULL;",
      "static pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};",
      "static Snapshot CopySnapshot(Snapshot snapshot);",
      "static void FreeSnapshot(Snapshot snapshot);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pairingheap_add",
          "args": [
            "&RegisteredSnapshots",
            "&CatalogSnapshot->ph_node"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetSnapshotData",
          "args": [
            "&CatalogSnapshotData"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InvalidateCatalogSnapshot",
          "args": [],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "InvalidateCatalogSnapshotConditionally",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "530-537",
          "snippet": "void\nInvalidateCatalogSnapshotConditionally(void)\n{\n\tif (CatalogSnapshot &&\n\t\tActiveSnapshot == NULL &&\n\t\tpairingheap_is_singular(&RegisteredSnapshots))\n\t\tInvalidateCatalogSnapshot();\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Snapshot CatalogSnapshot = NULL;",
            "static ActiveSnapshotElt *ActiveSnapshot = NULL;",
            "static pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic Snapshot CatalogSnapshot = NULL;\nstatic ActiveSnapshotElt *ActiveSnapshot = NULL;\nstatic pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};\n\nvoid\nInvalidateCatalogSnapshotConditionally(void)\n{\n\tif (CatalogSnapshot &&\n\t\tActiveSnapshot == NULL &&\n\t\tpairingheap_is_singular(&RegisteredSnapshots))\n\t\tInvalidateCatalogSnapshot();\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationHasSysCache",
          "args": [
            "relid"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "RelationHasSysCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1486-1505",
          "snippet": "bool\nRelationHasSysCache(Oid relid)\n{\n\tint\t\t\tlow = 0,\n\t\t\t\thigh = SysCacheRelationOidSize - 1;\n\n\twhile (low <= high)\n\t{\n\t\tint\t\t\tmiddle = low + (high - low) / 2;\n\n\t\tif (SysCacheRelationOid[middle] == relid)\n\t\t\treturn true;\n\t\tif (SysCacheRelationOid[middle] < relid)\n\t\t\tlow = middle + 1;\n\t\telse\n\t\t\thigh = middle - 1;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Oid\tSysCacheRelationOid[SysCacheSize];",
            "static int\tSysCacheRelationOidSize;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic Oid\tSysCacheRelationOid[SysCacheSize];\nstatic int\tSysCacheRelationOidSize;\n\nbool\nRelationHasSysCache(Oid relid)\n{\n\tint\t\t\tlow = 0,\n\t\t\t\thigh = SysCacheRelationOidSize - 1;\n\n\twhile (low <= high)\n\t{\n\t\tint\t\t\tmiddle = low + (high - low) / 2;\n\n\t\tif (SysCacheRelationOid[middle] == relid)\n\t\t\treturn true;\n\t\tif (SysCacheRelationOid[middle] < relid)\n\t\t\tlow = middle + 1;\n\t\telse\n\t\t\thigh = middle - 1;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationInvalidatesSnapshotsOnly",
          "args": [
            "relid"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "RelationInvalidatesSnapshotsOnly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1463-1481",
          "snippet": "bool\nRelationInvalidatesSnapshotsOnly(Oid relid)\n{\n\tswitch (relid)\n\t{\n\t\tcase DbRoleSettingRelationId:\n\t\tcase DependRelationId:\n\t\tcase SharedDependRelationId:\n\t\tcase DescriptionRelationId:\n\t\tcase SharedDescriptionRelationId:\n\t\tcase SecLabelRelationId:\n\t\tcase SharedSecLabelRelationId:\n\t\t\treturn true;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nbool\nRelationInvalidatesSnapshotsOnly(Oid relid)\n{\n\tswitch (relid)\n\t{\n\t\tcase DbRoleSettingRelationId:\n\t\tcase DependRelationId:\n\t\tcase SharedDependRelationId:\n\t\tcase DescriptionRelationId:\n\t\tcase SharedDescriptionRelationId:\n\t\tcase SecLabelRelationId:\n\t\tcase SharedSecLabelRelationId:\n\t\t\treturn true;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nSnapshotData CatalogSnapshotData = {HeapTupleSatisfiesMVCC};\nstatic Snapshot CatalogSnapshot = NULL;\nstatic pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};\nstatic Snapshot CopySnapshot(Snapshot snapshot);\nstatic void FreeSnapshot(Snapshot snapshot);\n\nSnapshot\nGetNonHistoricCatalogSnapshot(Oid relid)\n{\n\t/*\n\t * If the caller is trying to scan a relation that has no syscache, no\n\t * catcache invalidations will be sent when it is updated.  For a few key\n\t * relations, snapshot invalidations are sent instead.  If we're trying to\n\t * scan a relation for which neither catcache nor snapshot invalidations\n\t * are sent, we must refresh the snapshot every time.\n\t */\n\tif (CatalogSnapshot &&\n\t\t!RelationInvalidatesSnapshotsOnly(relid) &&\n\t\t!RelationHasSysCache(relid))\n\t\tInvalidateCatalogSnapshot();\n\n\tif (CatalogSnapshot == NULL)\n\t{\n\t\t/* Get new snapshot. */\n\t\tCatalogSnapshot = GetSnapshotData(&CatalogSnapshotData);\n\n\t\t/*\n\t\t * Make sure the catalog snapshot will be accounted for in decisions\n\t\t * about advancing PGXACT->xmin.  We could apply RegisterSnapshot, but\n\t\t * that would result in making a physical copy, which is overkill; and\n\t\t * it would also create a dependency on some resource owner, which we\n\t\t * do not want for reasons explained at the head of this file. Instead\n\t\t * just shove the CatalogSnapshot into the pairing heap manually. This\n\t\t * has to be reversed in InvalidateCatalogSnapshot, of course.\n\t\t *\n\t\t * NB: it had better be impossible for this to throw error, since the\n\t\t * CatalogSnapshot pointer is already valid.\n\t\t */\n\t\tpairingheap_add(&RegisteredSnapshots, &CatalogSnapshot->ph_node);\n\t}\n\n\treturn CatalogSnapshot;\n}"
  },
  {
    "function_name": "GetCatalogSnapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
    "lines": "439-453",
    "snippet": "Snapshot\nGetCatalogSnapshot(Oid relid)\n{\n\t/*\n\t * Return historic snapshot while we're doing logical decoding, so we can\n\t * see the appropriate state of the catalog.\n\t *\n\t * This is the primary reason for needing to reset the system caches after\n\t * finishing decoding.\n\t */\n\tif (HistoricSnapshotActive())\n\t\treturn HistoricSnapshot;\n\n\treturn GetNonHistoricCatalogSnapshot(relid);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/spin.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/pairingheap.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Snapshot HistoricSnapshot = NULL;",
      "static Snapshot CopySnapshot(Snapshot snapshot);",
      "static void FreeSnapshot(Snapshot snapshot);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetNonHistoricCatalogSnapshot",
          "args": [
            "relid"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "GetNonHistoricCatalogSnapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "461-497",
          "snippet": "Snapshot\nGetNonHistoricCatalogSnapshot(Oid relid)\n{\n\t/*\n\t * If the caller is trying to scan a relation that has no syscache, no\n\t * catcache invalidations will be sent when it is updated.  For a few key\n\t * relations, snapshot invalidations are sent instead.  If we're trying to\n\t * scan a relation for which neither catcache nor snapshot invalidations\n\t * are sent, we must refresh the snapshot every time.\n\t */\n\tif (CatalogSnapshot &&\n\t\t!RelationInvalidatesSnapshotsOnly(relid) &&\n\t\t!RelationHasSysCache(relid))\n\t\tInvalidateCatalogSnapshot();\n\n\tif (CatalogSnapshot == NULL)\n\t{\n\t\t/* Get new snapshot. */\n\t\tCatalogSnapshot = GetSnapshotData(&CatalogSnapshotData);\n\n\t\t/*\n\t\t * Make sure the catalog snapshot will be accounted for in decisions\n\t\t * about advancing PGXACT->xmin.  We could apply RegisterSnapshot, but\n\t\t * that would result in making a physical copy, which is overkill; and\n\t\t * it would also create a dependency on some resource owner, which we\n\t\t * do not want for reasons explained at the head of this file. Instead\n\t\t * just shove the CatalogSnapshot into the pairing heap manually. This\n\t\t * has to be reversed in InvalidateCatalogSnapshot, of course.\n\t\t *\n\t\t * NB: it had better be impossible for this to throw error, since the\n\t\t * CatalogSnapshot pointer is already valid.\n\t\t */\n\t\tpairingheap_add(&RegisteredSnapshots, &CatalogSnapshot->ph_node);\n\t}\n\n\treturn CatalogSnapshot;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "SnapshotData CatalogSnapshotData = {HeapTupleSatisfiesMVCC};",
            "static Snapshot CatalogSnapshot = NULL;",
            "static pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};",
            "static Snapshot CopySnapshot(Snapshot snapshot);",
            "static void FreeSnapshot(Snapshot snapshot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nSnapshotData CatalogSnapshotData = {HeapTupleSatisfiesMVCC};\nstatic Snapshot CatalogSnapshot = NULL;\nstatic pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};\nstatic Snapshot CopySnapshot(Snapshot snapshot);\nstatic void FreeSnapshot(Snapshot snapshot);\n\nSnapshot\nGetNonHistoricCatalogSnapshot(Oid relid)\n{\n\t/*\n\t * If the caller is trying to scan a relation that has no syscache, no\n\t * catcache invalidations will be sent when it is updated.  For a few key\n\t * relations, snapshot invalidations are sent instead.  If we're trying to\n\t * scan a relation for which neither catcache nor snapshot invalidations\n\t * are sent, we must refresh the snapshot every time.\n\t */\n\tif (CatalogSnapshot &&\n\t\t!RelationInvalidatesSnapshotsOnly(relid) &&\n\t\t!RelationHasSysCache(relid))\n\t\tInvalidateCatalogSnapshot();\n\n\tif (CatalogSnapshot == NULL)\n\t{\n\t\t/* Get new snapshot. */\n\t\tCatalogSnapshot = GetSnapshotData(&CatalogSnapshotData);\n\n\t\t/*\n\t\t * Make sure the catalog snapshot will be accounted for in decisions\n\t\t * about advancing PGXACT->xmin.  We could apply RegisterSnapshot, but\n\t\t * that would result in making a physical copy, which is overkill; and\n\t\t * it would also create a dependency on some resource owner, which we\n\t\t * do not want for reasons explained at the head of this file. Instead\n\t\t * just shove the CatalogSnapshot into the pairing heap manually. This\n\t\t * has to be reversed in InvalidateCatalogSnapshot, of course.\n\t\t *\n\t\t * NB: it had better be impossible for this to throw error, since the\n\t\t * CatalogSnapshot pointer is already valid.\n\t\t */\n\t\tpairingheap_add(&RegisteredSnapshots, &CatalogSnapshot->ph_node);\n\t}\n\n\treturn CatalogSnapshot;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HistoricSnapshotActive",
          "args": [],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "HistoricSnapshotActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "2023-2027",
          "snippet": "bool\nHistoricSnapshotActive(void)\n{\n\treturn HistoricSnapshot != NULL;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Snapshot HistoricSnapshot = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic Snapshot HistoricSnapshot = NULL;\n\nbool\nHistoricSnapshotActive(void)\n{\n\treturn HistoricSnapshot != NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic Snapshot HistoricSnapshot = NULL;\nstatic Snapshot CopySnapshot(Snapshot snapshot);\nstatic void FreeSnapshot(Snapshot snapshot);\n\nSnapshot\nGetCatalogSnapshot(Oid relid)\n{\n\t/*\n\t * Return historic snapshot while we're doing logical decoding, so we can\n\t * see the appropriate state of the catalog.\n\t *\n\t * This is the primary reason for needing to reset the system caches after\n\t * finishing decoding.\n\t */\n\tif (HistoricSnapshotActive())\n\t\treturn HistoricSnapshot;\n\n\treturn GetNonHistoricCatalogSnapshot(relid);\n}"
  },
  {
    "function_name": "GetOldestSnapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
    "lines": "410-432",
    "snippet": "Snapshot\nGetOldestSnapshot(void)\n{\n\tSnapshot\tOldestRegisteredSnapshot = NULL;\n\tXLogRecPtr\tRegisteredLSN = InvalidXLogRecPtr;\n\n\tif (!pairingheap_is_empty(&RegisteredSnapshots))\n\t{\n\t\tOldestRegisteredSnapshot = pairingheap_container(SnapshotData, ph_node,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t pairingheap_first(&RegisteredSnapshots));\n\t\tRegisteredLSN = OldestRegisteredSnapshot->lsn;\n\t}\n\n\tif (OldestActiveSnapshot != NULL)\n\t{\n\t\tXLogRecPtr\tActiveLSN = OldestActiveSnapshot->as_snap->lsn;\n\n\t\tif (XLogRecPtrIsInvalid(RegisteredLSN) || RegisteredLSN > ActiveLSN)\n\t\t\treturn OldestActiveSnapshot->as_snap;\n\t}\n\n\treturn OldestRegisteredSnapshot;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/spin.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/pairingheap.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static ActiveSnapshotElt *OldestActiveSnapshot = NULL;",
      "static pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XLogRecPtrIsInvalid",
          "args": [
            "RegisteredLSN"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pairingheap_container",
          "args": [
            "SnapshotData",
            "ph_node",
            "pairingheap_first(&RegisteredSnapshots)"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pairingheap_first",
          "args": [
            "&RegisteredSnapshots"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pairingheap_is_empty",
          "args": [
            "&RegisteredSnapshots"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic ActiveSnapshotElt *OldestActiveSnapshot = NULL;\nstatic pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};\n\nSnapshot\nGetOldestSnapshot(void)\n{\n\tSnapshot\tOldestRegisteredSnapshot = NULL;\n\tXLogRecPtr\tRegisteredLSN = InvalidXLogRecPtr;\n\n\tif (!pairingheap_is_empty(&RegisteredSnapshots))\n\t{\n\t\tOldestRegisteredSnapshot = pairingheap_container(SnapshotData, ph_node,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t pairingheap_first(&RegisteredSnapshots));\n\t\tRegisteredLSN = OldestRegisteredSnapshot->lsn;\n\t}\n\n\tif (OldestActiveSnapshot != NULL)\n\t{\n\t\tXLogRecPtr\tActiveLSN = OldestActiveSnapshot->as_snap->lsn;\n\n\t\tif (XLogRecPtrIsInvalid(RegisteredLSN) || RegisteredLSN > ActiveLSN)\n\t\t\treturn OldestActiveSnapshot->as_snap;\n\t}\n\n\treturn OldestRegisteredSnapshot;\n}"
  },
  {
    "function_name": "GetLatestSnapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
    "lines": "378-402",
    "snippet": "Snapshot\nGetLatestSnapshot(void)\n{\n\t/*\n\t * We might be able to relax this, but nothing that could otherwise work\n\t * needs it.\n\t */\n\tif (IsInParallelMode())\n\t\telog(ERROR,\n\t\t\t \"cannot update SecondarySnapshot during a parallel operation\");\n\n\t/*\n\t * So far there are no cases requiring support for GetLatestSnapshot()\n\t * during logical decoding, but it wouldn't be hard to add if required.\n\t */\n\tAssert(!HistoricSnapshotActive());\n\n\t/* If first call in transaction, go ahead and set the xact snapshot */\n\tif (!FirstSnapshotSet)\n\t\treturn GetTransactionSnapshot();\n\n\tSecondarySnapshot = GetSnapshotData(&SecondarySnapshotData);\n\n\treturn SecondarySnapshot;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/spin.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/pairingheap.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static SnapshotData SecondarySnapshotData = {HeapTupleSatisfiesMVCC};",
      "static Snapshot SecondarySnapshot = NULL;",
      "bool\t\tFirstSnapshotSet = false;",
      "static Snapshot CopySnapshot(Snapshot snapshot);",
      "static void FreeSnapshot(Snapshot snapshot);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetSnapshotData",
          "args": [
            "&SecondarySnapshotData"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetTransactionSnapshot",
          "args": [],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "GetTransactionSnapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "303-371",
          "snippet": "Snapshot\nGetTransactionSnapshot(void)\n{\n\t/*\n\t * Return historic snapshot if doing logical decoding. We'll never need a\n\t * non-historic transaction snapshot in this (sub-)transaction, so there's\n\t * no need to be careful to set one up for later calls to\n\t * GetTransactionSnapshot().\n\t */\n\tif (HistoricSnapshotActive())\n\t{\n\t\tAssert(!FirstSnapshotSet);\n\t\treturn HistoricSnapshot;\n\t}\n\n\t/* First call in transaction? */\n\tif (!FirstSnapshotSet)\n\t{\n\t\t/*\n\t\t * Don't allow catalog snapshot to be older than xact snapshot.  Must\n\t\t * do this first to allow the empty-heap Assert to succeed.\n\t\t */\n\t\tInvalidateCatalogSnapshot();\n\n\t\tAssert(pairingheap_is_empty(&RegisteredSnapshots));\n\t\tAssert(FirstXactSnapshot == NULL);\n\n\t\tif (IsInParallelMode())\n\t\t\telog(ERROR,\n\t\t\t\t \"cannot take query snapshot during a parallel operation\");\n\n\t\t/*\n\t\t * In transaction-snapshot mode, the first snapshot must live until\n\t\t * end of xact regardless of what the caller does with it, so we must\n\t\t * make a copy of it rather than returning CurrentSnapshotData\n\t\t * directly.  Furthermore, if we're running in serializable mode,\n\t\t * predicate.c needs to wrap the snapshot fetch in its own processing.\n\t\t */\n\t\tif (IsolationUsesXactSnapshot())\n\t\t{\n\t\t\t/* First, create the snapshot in CurrentSnapshotData */\n\t\t\tif (IsolationIsSerializable())\n\t\t\t\tCurrentSnapshot = GetSerializableTransactionSnapshot(&CurrentSnapshotData);\n\t\t\telse\n\t\t\t\tCurrentSnapshot = GetSnapshotData(&CurrentSnapshotData);\n\t\t\t/* Make a saved copy */\n\t\t\tCurrentSnapshot = CopySnapshot(CurrentSnapshot);\n\t\t\tFirstXactSnapshot = CurrentSnapshot;\n\t\t\t/* Mark it as \"registered\" in FirstXactSnapshot */\n\t\t\tFirstXactSnapshot->regd_count++;\n\t\t\tpairingheap_add(&RegisteredSnapshots, &FirstXactSnapshot->ph_node);\n\t\t}\n\t\telse\n\t\t\tCurrentSnapshot = GetSnapshotData(&CurrentSnapshotData);\n\n\t\tFirstSnapshotSet = true;\n\t\treturn CurrentSnapshot;\n\t}\n\n\tif (IsolationUsesXactSnapshot())\n\t\treturn CurrentSnapshot;\n\n\t/* Don't allow catalog snapshot to be older than xact snapshot. */\n\tInvalidateCatalogSnapshot();\n\n\tCurrentSnapshot = GetSnapshotData(&CurrentSnapshotData);\n\n\treturn CurrentSnapshot;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static SnapshotData CurrentSnapshotData = {HeapTupleSatisfiesMVCC};",
            "static Snapshot CurrentSnapshot = NULL;",
            "static Snapshot HistoricSnapshot = NULL;",
            "static pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};",
            "bool\t\tFirstSnapshotSet = false;",
            "static Snapshot FirstXactSnapshot = NULL;",
            "static Snapshot CopySnapshot(Snapshot snapshot);",
            "static void FreeSnapshot(Snapshot snapshot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic SnapshotData CurrentSnapshotData = {HeapTupleSatisfiesMVCC};\nstatic Snapshot CurrentSnapshot = NULL;\nstatic Snapshot HistoricSnapshot = NULL;\nstatic pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};\nbool\t\tFirstSnapshotSet = false;\nstatic Snapshot FirstXactSnapshot = NULL;\nstatic Snapshot CopySnapshot(Snapshot snapshot);\nstatic void FreeSnapshot(Snapshot snapshot);\n\nSnapshot\nGetTransactionSnapshot(void)\n{\n\t/*\n\t * Return historic snapshot if doing logical decoding. We'll never need a\n\t * non-historic transaction snapshot in this (sub-)transaction, so there's\n\t * no need to be careful to set one up for later calls to\n\t * GetTransactionSnapshot().\n\t */\n\tif (HistoricSnapshotActive())\n\t{\n\t\tAssert(!FirstSnapshotSet);\n\t\treturn HistoricSnapshot;\n\t}\n\n\t/* First call in transaction? */\n\tif (!FirstSnapshotSet)\n\t{\n\t\t/*\n\t\t * Don't allow catalog snapshot to be older than xact snapshot.  Must\n\t\t * do this first to allow the empty-heap Assert to succeed.\n\t\t */\n\t\tInvalidateCatalogSnapshot();\n\n\t\tAssert(pairingheap_is_empty(&RegisteredSnapshots));\n\t\tAssert(FirstXactSnapshot == NULL);\n\n\t\tif (IsInParallelMode())\n\t\t\telog(ERROR,\n\t\t\t\t \"cannot take query snapshot during a parallel operation\");\n\n\t\t/*\n\t\t * In transaction-snapshot mode, the first snapshot must live until\n\t\t * end of xact regardless of what the caller does with it, so we must\n\t\t * make a copy of it rather than returning CurrentSnapshotData\n\t\t * directly.  Furthermore, if we're running in serializable mode,\n\t\t * predicate.c needs to wrap the snapshot fetch in its own processing.\n\t\t */\n\t\tif (IsolationUsesXactSnapshot())\n\t\t{\n\t\t\t/* First, create the snapshot in CurrentSnapshotData */\n\t\t\tif (IsolationIsSerializable())\n\t\t\t\tCurrentSnapshot = GetSerializableTransactionSnapshot(&CurrentSnapshotData);\n\t\t\telse\n\t\t\t\tCurrentSnapshot = GetSnapshotData(&CurrentSnapshotData);\n\t\t\t/* Make a saved copy */\n\t\t\tCurrentSnapshot = CopySnapshot(CurrentSnapshot);\n\t\t\tFirstXactSnapshot = CurrentSnapshot;\n\t\t\t/* Mark it as \"registered\" in FirstXactSnapshot */\n\t\t\tFirstXactSnapshot->regd_count++;\n\t\t\tpairingheap_add(&RegisteredSnapshots, &FirstXactSnapshot->ph_node);\n\t\t}\n\t\telse\n\t\t\tCurrentSnapshot = GetSnapshotData(&CurrentSnapshotData);\n\n\t\tFirstSnapshotSet = true;\n\t\treturn CurrentSnapshot;\n\t}\n\n\tif (IsolationUsesXactSnapshot())\n\t\treturn CurrentSnapshot;\n\n\t/* Don't allow catalog snapshot to be older than xact snapshot. */\n\tInvalidateCatalogSnapshot();\n\n\tCurrentSnapshot = GetSnapshotData(&CurrentSnapshotData);\n\n\treturn CurrentSnapshot;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!HistoricSnapshotActive()"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HistoricSnapshotActive",
          "args": [],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "HistoricSnapshotActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "2023-2027",
          "snippet": "bool\nHistoricSnapshotActive(void)\n{\n\treturn HistoricSnapshot != NULL;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Snapshot HistoricSnapshot = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic Snapshot HistoricSnapshot = NULL;\n\nbool\nHistoricSnapshotActive(void)\n{\n\treturn HistoricSnapshot != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"cannot update SecondarySnapshot during a parallel operation\""
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsInParallelMode",
          "args": [],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic SnapshotData SecondarySnapshotData = {HeapTupleSatisfiesMVCC};\nstatic Snapshot SecondarySnapshot = NULL;\nbool\t\tFirstSnapshotSet = false;\nstatic Snapshot CopySnapshot(Snapshot snapshot);\nstatic void FreeSnapshot(Snapshot snapshot);\n\nSnapshot\nGetLatestSnapshot(void)\n{\n\t/*\n\t * We might be able to relax this, but nothing that could otherwise work\n\t * needs it.\n\t */\n\tif (IsInParallelMode())\n\t\telog(ERROR,\n\t\t\t \"cannot update SecondarySnapshot during a parallel operation\");\n\n\t/*\n\t * So far there are no cases requiring support for GetLatestSnapshot()\n\t * during logical decoding, but it wouldn't be hard to add if required.\n\t */\n\tAssert(!HistoricSnapshotActive());\n\n\t/* If first call in transaction, go ahead and set the xact snapshot */\n\tif (!FirstSnapshotSet)\n\t\treturn GetTransactionSnapshot();\n\n\tSecondarySnapshot = GetSnapshotData(&SecondarySnapshotData);\n\n\treturn SecondarySnapshot;\n}"
  },
  {
    "function_name": "GetTransactionSnapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
    "lines": "303-371",
    "snippet": "Snapshot\nGetTransactionSnapshot(void)\n{\n\t/*\n\t * Return historic snapshot if doing logical decoding. We'll never need a\n\t * non-historic transaction snapshot in this (sub-)transaction, so there's\n\t * no need to be careful to set one up for later calls to\n\t * GetTransactionSnapshot().\n\t */\n\tif (HistoricSnapshotActive())\n\t{\n\t\tAssert(!FirstSnapshotSet);\n\t\treturn HistoricSnapshot;\n\t}\n\n\t/* First call in transaction? */\n\tif (!FirstSnapshotSet)\n\t{\n\t\t/*\n\t\t * Don't allow catalog snapshot to be older than xact snapshot.  Must\n\t\t * do this first to allow the empty-heap Assert to succeed.\n\t\t */\n\t\tInvalidateCatalogSnapshot();\n\n\t\tAssert(pairingheap_is_empty(&RegisteredSnapshots));\n\t\tAssert(FirstXactSnapshot == NULL);\n\n\t\tif (IsInParallelMode())\n\t\t\telog(ERROR,\n\t\t\t\t \"cannot take query snapshot during a parallel operation\");\n\n\t\t/*\n\t\t * In transaction-snapshot mode, the first snapshot must live until\n\t\t * end of xact regardless of what the caller does with it, so we must\n\t\t * make a copy of it rather than returning CurrentSnapshotData\n\t\t * directly.  Furthermore, if we're running in serializable mode,\n\t\t * predicate.c needs to wrap the snapshot fetch in its own processing.\n\t\t */\n\t\tif (IsolationUsesXactSnapshot())\n\t\t{\n\t\t\t/* First, create the snapshot in CurrentSnapshotData */\n\t\t\tif (IsolationIsSerializable())\n\t\t\t\tCurrentSnapshot = GetSerializableTransactionSnapshot(&CurrentSnapshotData);\n\t\t\telse\n\t\t\t\tCurrentSnapshot = GetSnapshotData(&CurrentSnapshotData);\n\t\t\t/* Make a saved copy */\n\t\t\tCurrentSnapshot = CopySnapshot(CurrentSnapshot);\n\t\t\tFirstXactSnapshot = CurrentSnapshot;\n\t\t\t/* Mark it as \"registered\" in FirstXactSnapshot */\n\t\t\tFirstXactSnapshot->regd_count++;\n\t\t\tpairingheap_add(&RegisteredSnapshots, &FirstXactSnapshot->ph_node);\n\t\t}\n\t\telse\n\t\t\tCurrentSnapshot = GetSnapshotData(&CurrentSnapshotData);\n\n\t\tFirstSnapshotSet = true;\n\t\treturn CurrentSnapshot;\n\t}\n\n\tif (IsolationUsesXactSnapshot())\n\t\treturn CurrentSnapshot;\n\n\t/* Don't allow catalog snapshot to be older than xact snapshot. */\n\tInvalidateCatalogSnapshot();\n\n\tCurrentSnapshot = GetSnapshotData(&CurrentSnapshotData);\n\n\treturn CurrentSnapshot;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/spin.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/pairingheap.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static SnapshotData CurrentSnapshotData = {HeapTupleSatisfiesMVCC};",
      "static Snapshot CurrentSnapshot = NULL;",
      "static Snapshot HistoricSnapshot = NULL;",
      "static pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};",
      "bool\t\tFirstSnapshotSet = false;",
      "static Snapshot FirstXactSnapshot = NULL;",
      "static Snapshot CopySnapshot(Snapshot snapshot);",
      "static void FreeSnapshot(Snapshot snapshot);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetSnapshotData",
          "args": [
            "&CurrentSnapshotData"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InvalidateCatalogSnapshot",
          "args": [],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "InvalidateCatalogSnapshotConditionally",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "530-537",
          "snippet": "void\nInvalidateCatalogSnapshotConditionally(void)\n{\n\tif (CatalogSnapshot &&\n\t\tActiveSnapshot == NULL &&\n\t\tpairingheap_is_singular(&RegisteredSnapshots))\n\t\tInvalidateCatalogSnapshot();\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Snapshot CatalogSnapshot = NULL;",
            "static ActiveSnapshotElt *ActiveSnapshot = NULL;",
            "static pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic Snapshot CatalogSnapshot = NULL;\nstatic ActiveSnapshotElt *ActiveSnapshot = NULL;\nstatic pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};\n\nvoid\nInvalidateCatalogSnapshotConditionally(void)\n{\n\tif (CatalogSnapshot &&\n\t\tActiveSnapshot == NULL &&\n\t\tpairingheap_is_singular(&RegisteredSnapshots))\n\t\tInvalidateCatalogSnapshot();\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsolationUsesXactSnapshot",
          "args": [],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetSnapshotData",
          "args": [
            "&CurrentSnapshotData"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pairingheap_add",
          "args": [
            "&RegisteredSnapshots",
            "&FirstXactSnapshot->ph_node"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CopySnapshot",
          "args": [
            "CurrentSnapshot"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "CopySnapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "659-708",
          "snippet": "static Snapshot\nCopySnapshot(Snapshot snapshot)\n{\n\tSnapshot\tnewsnap;\n\tSize\t\tsubxipoff;\n\tSize\t\tsize;\n\n\tAssert(snapshot != InvalidSnapshot);\n\n\t/* We allocate any XID arrays needed in the same palloc block. */\n\tsize = subxipoff = sizeof(SnapshotData) +\n\t\tsnapshot->xcnt * sizeof(TransactionId);\n\tif (snapshot->subxcnt > 0)\n\t\tsize += snapshot->subxcnt * sizeof(TransactionId);\n\n\tnewsnap = (Snapshot) MemoryContextAlloc(TopTransactionContext, size);\n\tmemcpy(newsnap, snapshot, sizeof(SnapshotData));\n\n\tnewsnap->regd_count = 0;\n\tnewsnap->active_count = 0;\n\tnewsnap->copied = true;\n\n\t/* setup XID array */\n\tif (snapshot->xcnt > 0)\n\t{\n\t\tnewsnap->xip = (TransactionId *) (newsnap + 1);\n\t\tmemcpy(newsnap->xip, snapshot->xip,\n\t\t\t   snapshot->xcnt * sizeof(TransactionId));\n\t}\n\telse\n\t\tnewsnap->xip = NULL;\n\n\t/*\n\t * Setup subXID array. Don't bother to copy it if it had overflowed,\n\t * though, because it's not used anywhere in that case. Except if it's a\n\t * snapshot taken during recovery; all the top-level XIDs are in subxip as\n\t * well in that case, so we mustn't lose them.\n\t */\n\tif (snapshot->subxcnt > 0 &&\n\t\t(!snapshot->suboverflowed || snapshot->takenDuringRecovery))\n\t{\n\t\tnewsnap->subxip = (TransactionId *) ((char *) newsnap + subxipoff);\n\t\tmemcpy(newsnap->subxip, snapshot->subxip,\n\t\t\t   snapshot->subxcnt * sizeof(TransactionId));\n\t}\n\telse\n\t\tnewsnap->subxip = NULL;\n\n\treturn newsnap;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Snapshot CopySnapshot(Snapshot snapshot);",
            "static void FreeSnapshot(Snapshot snapshot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic Snapshot CopySnapshot(Snapshot snapshot);\nstatic void FreeSnapshot(Snapshot snapshot);\n\nstatic Snapshot\nCopySnapshot(Snapshot snapshot)\n{\n\tSnapshot\tnewsnap;\n\tSize\t\tsubxipoff;\n\tSize\t\tsize;\n\n\tAssert(snapshot != InvalidSnapshot);\n\n\t/* We allocate any XID arrays needed in the same palloc block. */\n\tsize = subxipoff = sizeof(SnapshotData) +\n\t\tsnapshot->xcnt * sizeof(TransactionId);\n\tif (snapshot->subxcnt > 0)\n\t\tsize += snapshot->subxcnt * sizeof(TransactionId);\n\n\tnewsnap = (Snapshot) MemoryContextAlloc(TopTransactionContext, size);\n\tmemcpy(newsnap, snapshot, sizeof(SnapshotData));\n\n\tnewsnap->regd_count = 0;\n\tnewsnap->active_count = 0;\n\tnewsnap->copied = true;\n\n\t/* setup XID array */\n\tif (snapshot->xcnt > 0)\n\t{\n\t\tnewsnap->xip = (TransactionId *) (newsnap + 1);\n\t\tmemcpy(newsnap->xip, snapshot->xip,\n\t\t\t   snapshot->xcnt * sizeof(TransactionId));\n\t}\n\telse\n\t\tnewsnap->xip = NULL;\n\n\t/*\n\t * Setup subXID array. Don't bother to copy it if it had overflowed,\n\t * though, because it's not used anywhere in that case. Except if it's a\n\t * snapshot taken during recovery; all the top-level XIDs are in subxip as\n\t * well in that case, so we mustn't lose them.\n\t */\n\tif (snapshot->subxcnt > 0 &&\n\t\t(!snapshot->suboverflowed || snapshot->takenDuringRecovery))\n\t{\n\t\tnewsnap->subxip = (TransactionId *) ((char *) newsnap + subxipoff);\n\t\tmemcpy(newsnap->subxip, snapshot->subxip,\n\t\t\t   snapshot->subxcnt * sizeof(TransactionId));\n\t}\n\telse\n\t\tnewsnap->subxip = NULL;\n\n\treturn newsnap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetSnapshotData",
          "args": [
            "&CurrentSnapshotData"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetSerializableTransactionSnapshot",
          "args": [
            "&CurrentSnapshotData"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsolationIsSerializable",
          "args": [],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsolationUsesXactSnapshot",
          "args": [],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"cannot take query snapshot during a parallel operation\""
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsInParallelMode",
          "args": [],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "FirstXactSnapshot == NULL"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "pairingheap_is_empty(&RegisteredSnapshots)"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pairingheap_is_empty",
          "args": [
            "&RegisteredSnapshots"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!FirstSnapshotSet"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HistoricSnapshotActive",
          "args": [],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "HistoricSnapshotActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "2023-2027",
          "snippet": "bool\nHistoricSnapshotActive(void)\n{\n\treturn HistoricSnapshot != NULL;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Snapshot HistoricSnapshot = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic Snapshot HistoricSnapshot = NULL;\n\nbool\nHistoricSnapshotActive(void)\n{\n\treturn HistoricSnapshot != NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic SnapshotData CurrentSnapshotData = {HeapTupleSatisfiesMVCC};\nstatic Snapshot CurrentSnapshot = NULL;\nstatic Snapshot HistoricSnapshot = NULL;\nstatic pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};\nbool\t\tFirstSnapshotSet = false;\nstatic Snapshot FirstXactSnapshot = NULL;\nstatic Snapshot CopySnapshot(Snapshot snapshot);\nstatic void FreeSnapshot(Snapshot snapshot);\n\nSnapshot\nGetTransactionSnapshot(void)\n{\n\t/*\n\t * Return historic snapshot if doing logical decoding. We'll never need a\n\t * non-historic transaction snapshot in this (sub-)transaction, so there's\n\t * no need to be careful to set one up for later calls to\n\t * GetTransactionSnapshot().\n\t */\n\tif (HistoricSnapshotActive())\n\t{\n\t\tAssert(!FirstSnapshotSet);\n\t\treturn HistoricSnapshot;\n\t}\n\n\t/* First call in transaction? */\n\tif (!FirstSnapshotSet)\n\t{\n\t\t/*\n\t\t * Don't allow catalog snapshot to be older than xact snapshot.  Must\n\t\t * do this first to allow the empty-heap Assert to succeed.\n\t\t */\n\t\tInvalidateCatalogSnapshot();\n\n\t\tAssert(pairingheap_is_empty(&RegisteredSnapshots));\n\t\tAssert(FirstXactSnapshot == NULL);\n\n\t\tif (IsInParallelMode())\n\t\t\telog(ERROR,\n\t\t\t\t \"cannot take query snapshot during a parallel operation\");\n\n\t\t/*\n\t\t * In transaction-snapshot mode, the first snapshot must live until\n\t\t * end of xact regardless of what the caller does with it, so we must\n\t\t * make a copy of it rather than returning CurrentSnapshotData\n\t\t * directly.  Furthermore, if we're running in serializable mode,\n\t\t * predicate.c needs to wrap the snapshot fetch in its own processing.\n\t\t */\n\t\tif (IsolationUsesXactSnapshot())\n\t\t{\n\t\t\t/* First, create the snapshot in CurrentSnapshotData */\n\t\t\tif (IsolationIsSerializable())\n\t\t\t\tCurrentSnapshot = GetSerializableTransactionSnapshot(&CurrentSnapshotData);\n\t\t\telse\n\t\t\t\tCurrentSnapshot = GetSnapshotData(&CurrentSnapshotData);\n\t\t\t/* Make a saved copy */\n\t\t\tCurrentSnapshot = CopySnapshot(CurrentSnapshot);\n\t\t\tFirstXactSnapshot = CurrentSnapshot;\n\t\t\t/* Mark it as \"registered\" in FirstXactSnapshot */\n\t\t\tFirstXactSnapshot->regd_count++;\n\t\t\tpairingheap_add(&RegisteredSnapshots, &FirstXactSnapshot->ph_node);\n\t\t}\n\t\telse\n\t\t\tCurrentSnapshot = GetSnapshotData(&CurrentSnapshotData);\n\n\t\tFirstSnapshotSet = true;\n\t\treturn CurrentSnapshot;\n\t}\n\n\tif (IsolationUsesXactSnapshot())\n\t\treturn CurrentSnapshot;\n\n\t/* Don't allow catalog snapshot to be older than xact snapshot. */\n\tInvalidateCatalogSnapshot();\n\n\tCurrentSnapshot = GetSnapshotData(&CurrentSnapshotData);\n\n\treturn CurrentSnapshot;\n}"
  },
  {
    "function_name": "SnapMgrInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
    "lines": "266-292",
    "snippet": "void\nSnapMgrInit(void)\n{\n\tbool\t\tfound;\n\n\t/*\n\t * Create or attach to the OldSnapshotControlData structure.\n\t */\n\toldSnapshotControl = (volatile OldSnapshotControlData *)\n\t\tShmemInitStruct(\"OldSnapshotControlData\",\n\t\t\t\t\t\tSnapMgrShmemSize(), &found);\n\n\tif (!found)\n\t{\n\t\tSpinLockInit(&oldSnapshotControl->mutex_current);\n\t\toldSnapshotControl->current_timestamp = 0;\n\t\tSpinLockInit(&oldSnapshotControl->mutex_latest_xmin);\n\t\toldSnapshotControl->latest_xmin = InvalidTransactionId;\n\t\toldSnapshotControl->next_map_update = 0;\n\t\tSpinLockInit(&oldSnapshotControl->mutex_threshold);\n\t\toldSnapshotControl->threshold_timestamp = 0;\n\t\toldSnapshotControl->threshold_xid = InvalidTransactionId;\n\t\toldSnapshotControl->head_offset = 0;\n\t\toldSnapshotControl->head_timestamp = 0;\n\t\toldSnapshotControl->count_used = 0;\n\t}\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/spin.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/pairingheap.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static volatile OldSnapshotControlData *oldSnapshotControl;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SpinLockInit",
          "args": [
            "&oldSnapshotControl->mutex_threshold"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SpinLockInit",
          "args": [
            "&oldSnapshotControl->mutex_latest_xmin"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SpinLockInit",
          "args": [
            "&oldSnapshotControl->mutex_current"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ShmemInitStruct",
          "args": [
            "\"OldSnapshotControlData\"",
            "SnapMgrShmemSize()",
            "&found"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SnapMgrShmemSize",
          "args": [],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "SnapMgrShmemSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "250-261",
          "snippet": "Size\nSnapMgrShmemSize(void)\n{\n\tSize\t\tsize;\n\n\tsize = offsetof(OldSnapshotControlData, xid_by_minute);\n\tif (old_snapshot_threshold > 0)\n\t\tsize = add_size(size, mul_size(sizeof(TransactionId),\n\t\t\t\t\t\t\t\t\t   OLD_SNAPSHOT_TIME_MAP_ENTRIES));\n\n\treturn size;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\t\t\told_snapshot_threshold;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nint\t\t\told_snapshot_threshold;\n\nSize\nSnapMgrShmemSize(void)\n{\n\tSize\t\tsize;\n\n\tsize = offsetof(OldSnapshotControlData, xid_by_minute);\n\tif (old_snapshot_threshold > 0)\n\t\tsize = add_size(size, mul_size(sizeof(TransactionId),\n\t\t\t\t\t\t\t\t\t   OLD_SNAPSHOT_TIME_MAP_ENTRIES));\n\n\treturn size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic volatile OldSnapshotControlData *oldSnapshotControl;\n\nvoid\nSnapMgrInit(void)\n{\n\tbool\t\tfound;\n\n\t/*\n\t * Create or attach to the OldSnapshotControlData structure.\n\t */\n\toldSnapshotControl = (volatile OldSnapshotControlData *)\n\t\tShmemInitStruct(\"OldSnapshotControlData\",\n\t\t\t\t\t\tSnapMgrShmemSize(), &found);\n\n\tif (!found)\n\t{\n\t\tSpinLockInit(&oldSnapshotControl->mutex_current);\n\t\toldSnapshotControl->current_timestamp = 0;\n\t\tSpinLockInit(&oldSnapshotControl->mutex_latest_xmin);\n\t\toldSnapshotControl->latest_xmin = InvalidTransactionId;\n\t\toldSnapshotControl->next_map_update = 0;\n\t\tSpinLockInit(&oldSnapshotControl->mutex_threshold);\n\t\toldSnapshotControl->threshold_timestamp = 0;\n\t\toldSnapshotControl->threshold_xid = InvalidTransactionId;\n\t\toldSnapshotControl->head_offset = 0;\n\t\toldSnapshotControl->head_timestamp = 0;\n\t\toldSnapshotControl->count_used = 0;\n\t}\n}"
  },
  {
    "function_name": "SnapMgrShmemSize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
    "lines": "250-261",
    "snippet": "Size\nSnapMgrShmemSize(void)\n{\n\tSize\t\tsize;\n\n\tsize = offsetof(OldSnapshotControlData, xid_by_minute);\n\tif (old_snapshot_threshold > 0)\n\t\tsize = add_size(size, mul_size(sizeof(TransactionId),\n\t\t\t\t\t\t\t\t\t   OLD_SNAPSHOT_TIME_MAP_ENTRIES));\n\n\treturn size;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/spin.h\"",
      "#include \"storage/sinvaladt.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/predicate.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/pairingheap.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\t\t\told_snapshot_threshold;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_size",
          "args": [
            "size",
            "mul_size(sizeof(TransactionId),\n\t\t\t\t\t\t\t\t\t   OLD_SNAPSHOT_TIME_MAP_ENTRIES)"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mul_size",
          "args": [
            "sizeof(TransactionId)",
            "OLD_SNAPSHOT_TIME_MAP_ENTRIES"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nint\t\t\told_snapshot_threshold;\n\nSize\nSnapMgrShmemSize(void)\n{\n\tSize\t\tsize;\n\n\tsize = offsetof(OldSnapshotControlData, xid_by_minute);\n\tif (old_snapshot_threshold > 0)\n\t\tsize = add_size(size, mul_size(sizeof(TransactionId),\n\t\t\t\t\t\t\t\t\t   OLD_SNAPSHOT_TIME_MAP_ENTRIES));\n\n\treturn size;\n}"
  }
]