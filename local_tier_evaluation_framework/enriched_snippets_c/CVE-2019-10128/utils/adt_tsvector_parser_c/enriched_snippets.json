[
  {
    "function_name": "gettoken_tsvector",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_parser.c",
    "lines": "154-367",
    "snippet": "bool\ngettoken_tsvector(TSVectorParseState state,\n\t\t\t\t  char **strval, int *lenval,\n\t\t\t\t  WordEntryPos **pos_ptr, int *poslen,\n\t\t\t\t  char **endptr)\n{\n\tint\t\t\toldstate = 0;\n\tchar\t   *curpos = state->word;\n\tint\t\t\tstatecode = WAITWORD;\n\n\t/*\n\t * pos is for collecting the comma delimited list of positions followed by\n\t * the actual token.\n\t */\n\tWordEntryPos *pos = NULL;\n\tint\t\t\tnpos = 0;\t\t/* elements of pos used */\n\tint\t\t\tposalen = 0;\t/* allocated size of pos */\n\n\twhile (1)\n\t{\n\t\tif (statecode == WAITWORD)\n\t\t{\n\t\t\tif (*(state->prsbuf) == '\\0')\n\t\t\t\treturn false;\n\t\t\telse if (!state->is_web && t_iseq(state->prsbuf, '\\''))\n\t\t\t\tstatecode = WAITENDCMPLX;\n\t\t\telse if (!state->is_web && t_iseq(state->prsbuf, '\\\\'))\n\t\t\t{\n\t\t\t\tstatecode = WAITNEXTCHAR;\n\t\t\t\toldstate = WAITENDWORD;\n\t\t\t}\n\t\t\telse if ((state->oprisdelim && ISOPERATOR(state->prsbuf)) ||\n\t\t\t\t\t (state->is_web && t_iseq(state->prsbuf, '\"')))\n\t\t\t\tPRSSYNTAXERROR;\n\t\t\telse if (!t_isspace(state->prsbuf))\n\t\t\t{\n\t\t\t\tCOPYCHAR(curpos, state->prsbuf);\n\t\t\t\tcurpos += pg_mblen(state->prsbuf);\n\t\t\t\tstatecode = WAITENDWORD;\n\t\t\t}\n\t\t}\n\t\telse if (statecode == WAITNEXTCHAR)\n\t\t{\n\t\t\tif (*(state->prsbuf) == '\\0')\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"there is no escaped character: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\tstate->bufstart)));\n\t\t\telse\n\t\t\t{\n\t\t\t\tRESIZEPRSBUF;\n\t\t\t\tCOPYCHAR(curpos, state->prsbuf);\n\t\t\t\tcurpos += pg_mblen(state->prsbuf);\n\t\t\t\tAssert(oldstate != 0);\n\t\t\t\tstatecode = oldstate;\n\t\t\t}\n\t\t}\n\t\telse if (statecode == WAITENDWORD)\n\t\t{\n\t\t\tif (!state->is_web && t_iseq(state->prsbuf, '\\\\'))\n\t\t\t{\n\t\t\t\tstatecode = WAITNEXTCHAR;\n\t\t\t\toldstate = WAITENDWORD;\n\t\t\t}\n\t\t\telse if (t_isspace(state->prsbuf) || *(state->prsbuf) == '\\0' ||\n\t\t\t\t\t (state->oprisdelim && ISOPERATOR(state->prsbuf)) ||\n\t\t\t\t\t (state->is_web && t_iseq(state->prsbuf, '\"')))\n\t\t\t{\n\t\t\t\tRESIZEPRSBUF;\n\t\t\t\tif (curpos == state->word)\n\t\t\t\t\tPRSSYNTAXERROR;\n\t\t\t\t*(curpos) = '\\0';\n\t\t\t\tRETURN_TOKEN;\n\t\t\t}\n\t\t\telse if (t_iseq(state->prsbuf, ':'))\n\t\t\t{\n\t\t\t\tif (curpos == state->word)\n\t\t\t\t\tPRSSYNTAXERROR;\n\t\t\t\t*(curpos) = '\\0';\n\t\t\t\tif (state->oprisdelim)\n\t\t\t\t\tRETURN_TOKEN;\n\t\t\t\telse\n\t\t\t\t\tstatecode = INPOSINFO;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tRESIZEPRSBUF;\n\t\t\t\tCOPYCHAR(curpos, state->prsbuf);\n\t\t\t\tcurpos += pg_mblen(state->prsbuf);\n\t\t\t}\n\t\t}\n\t\telse if (statecode == WAITENDCMPLX)\n\t\t{\n\t\t\tif (!state->is_web && t_iseq(state->prsbuf, '\\''))\n\t\t\t{\n\t\t\t\tstatecode = WAITCHARCMPLX;\n\t\t\t}\n\t\t\telse if (!state->is_web && t_iseq(state->prsbuf, '\\\\'))\n\t\t\t{\n\t\t\t\tstatecode = WAITNEXTCHAR;\n\t\t\t\toldstate = WAITENDCMPLX;\n\t\t\t}\n\t\t\telse if (*(state->prsbuf) == '\\0')\n\t\t\t\tPRSSYNTAXERROR;\n\t\t\telse\n\t\t\t{\n\t\t\t\tRESIZEPRSBUF;\n\t\t\t\tCOPYCHAR(curpos, state->prsbuf);\n\t\t\t\tcurpos += pg_mblen(state->prsbuf);\n\t\t\t}\n\t\t}\n\t\telse if (statecode == WAITCHARCMPLX)\n\t\t{\n\t\t\tif (!state->is_web && t_iseq(state->prsbuf, '\\''))\n\t\t\t{\n\t\t\t\tRESIZEPRSBUF;\n\t\t\t\tCOPYCHAR(curpos, state->prsbuf);\n\t\t\t\tcurpos += pg_mblen(state->prsbuf);\n\t\t\t\tstatecode = WAITENDCMPLX;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tRESIZEPRSBUF;\n\t\t\t\t*(curpos) = '\\0';\n\t\t\t\tif (curpos == state->word)\n\t\t\t\t\tPRSSYNTAXERROR;\n\t\t\t\tif (state->oprisdelim)\n\t\t\t\t{\n\t\t\t\t\t/* state->prsbuf+=pg_mblen(state->prsbuf); */\n\t\t\t\t\tRETURN_TOKEN;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstatecode = WAITPOSINFO;\n\t\t\t\tcontinue;\t\t/* recheck current character */\n\t\t\t}\n\t\t}\n\t\telse if (statecode == WAITPOSINFO)\n\t\t{\n\t\t\tif (t_iseq(state->prsbuf, ':'))\n\t\t\t\tstatecode = INPOSINFO;\n\t\t\telse\n\t\t\t\tRETURN_TOKEN;\n\t\t}\n\t\telse if (statecode == INPOSINFO)\n\t\t{\n\t\t\tif (t_isdigit(state->prsbuf))\n\t\t\t{\n\t\t\t\tif (posalen == 0)\n\t\t\t\t{\n\t\t\t\t\tposalen = 4;\n\t\t\t\t\tpos = (WordEntryPos *) palloc(sizeof(WordEntryPos) * posalen);\n\t\t\t\t\tnpos = 0;\n\t\t\t\t}\n\t\t\t\telse if (npos + 1 >= posalen)\n\t\t\t\t{\n\t\t\t\t\tposalen *= 2;\n\t\t\t\t\tpos = (WordEntryPos *) repalloc(pos, sizeof(WordEntryPos) * posalen);\n\t\t\t\t}\n\t\t\t\tnpos++;\n\t\t\t\tWEP_SETPOS(pos[npos - 1], LIMITPOS(atoi(state->prsbuf)));\n\t\t\t\t/* we cannot get here in tsquery, so no need for 2 errmsgs */\n\t\t\t\tif (WEP_GETPOS(pos[npos - 1]) == 0)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t\t errmsg(\"wrong position info in tsvector: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\tstate->bufstart)));\n\t\t\t\tWEP_SETWEIGHT(pos[npos - 1], 0);\n\t\t\t\tstatecode = WAITPOSDELIM;\n\t\t\t}\n\t\t\telse\n\t\t\t\tPRSSYNTAXERROR;\n\t\t}\n\t\telse if (statecode == WAITPOSDELIM)\n\t\t{\n\t\t\tif (t_iseq(state->prsbuf, ','))\n\t\t\t\tstatecode = INPOSINFO;\n\t\t\telse if (t_iseq(state->prsbuf, 'a') || t_iseq(state->prsbuf, 'A') || t_iseq(state->prsbuf, '*'))\n\t\t\t{\n\t\t\t\tif (WEP_GETWEIGHT(pos[npos - 1]))\n\t\t\t\t\tPRSSYNTAXERROR;\n\t\t\t\tWEP_SETWEIGHT(pos[npos - 1], 3);\n\t\t\t}\n\t\t\telse if (t_iseq(state->prsbuf, 'b') || t_iseq(state->prsbuf, 'B'))\n\t\t\t{\n\t\t\t\tif (WEP_GETWEIGHT(pos[npos - 1]))\n\t\t\t\t\tPRSSYNTAXERROR;\n\t\t\t\tWEP_SETWEIGHT(pos[npos - 1], 2);\n\t\t\t}\n\t\t\telse if (t_iseq(state->prsbuf, 'c') || t_iseq(state->prsbuf, 'C'))\n\t\t\t{\n\t\t\t\tif (WEP_GETWEIGHT(pos[npos - 1]))\n\t\t\t\t\tPRSSYNTAXERROR;\n\t\t\t\tWEP_SETWEIGHT(pos[npos - 1], 1);\n\t\t\t}\n\t\t\telse if (t_iseq(state->prsbuf, 'd') || t_iseq(state->prsbuf, 'D'))\n\t\t\t{\n\t\t\t\tif (WEP_GETWEIGHT(pos[npos - 1]))\n\t\t\t\t\tPRSSYNTAXERROR;\n\t\t\t\tWEP_SETWEIGHT(pos[npos - 1], 0);\n\t\t\t}\n\t\t\telse if (t_isspace(state->prsbuf) ||\n\t\t\t\t\t *(state->prsbuf) == '\\0')\n\t\t\t\tRETURN_TOKEN;\n\t\t\telse if (!t_isdigit(state->prsbuf))\n\t\t\t\tPRSSYNTAXERROR;\n\t\t}\n\t\telse\t\t\t\t\t/* internal error */\n\t\t\telog(ERROR, \"unrecognized state in gettoken_tsvector: %d\",\n\t\t\t\t statecode);\n\n\t\t/* get next char */\n\t\tstate->prsbuf += pg_mblen(state->prsbuf);\n\t}\n}",
    "includes": [
      "#include \"tsearch/ts_utils.h\"",
      "#include \"tsearch/ts_locale.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define PRSSYNTAXERROR prssyntaxerror(state)",
      "#define WAITCHARCMPLX\t8",
      "#define WAITPOSDELIM\t7",
      "#define INPOSINFO\t\t6",
      "#define WAITPOSINFO\t\t5",
      "#define WAITENDCMPLX\t4",
      "#define WAITNEXTCHAR\t3",
      "#define WAITENDWORD\t\t2",
      "#define WAITWORD\t\t1",
      "#define RETURN_TOKEN \\\ndo { \\\n\tif (pos_ptr != NULL) \\\n\t{ \\\n\t\t*pos_ptr = pos; \\\n\t\t*poslen = npos; \\\n\t} \\\n\telse if (pos != NULL) \\\n\t\tpfree(pos); \\\n\t\\\n\tif (strval != NULL) \\\n\t\t*strval = state->word; \\\n\tif (lenval != NULL) \\\n\t\t*lenval = curpos - state->word; \\\n\tif (endptr != NULL) \\\n\t\t*endptr = state->prsbuf; \\\n\treturn true; \\\n} while(0)",
      "#define RESIZEPRSBUF \\\ndo { \\\n\tint clen = curpos - state->word; \\\n\tif ( clen + state->eml >= state->len ) \\\n\t{ \\\n\t\tstate->len *= 2; \\\n\t\tstate->word = (char *) repalloc(state->word, state->len); \\\n\t\tcurpos = state->word + clen; \\\n\t} \\\n} while (0)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pg_mblen",
          "args": [
            "state->prsbuf"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mblen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "759-763",
          "snippet": "int\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nint\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unrecognized state in gettoken_tsvector: %d\"",
            "statecode"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "t_isdigit",
          "args": [
            "state->prsbuf"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t_isspace",
          "args": [
            "state->prsbuf"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEP_SETWEIGHT",
          "args": [
            "pos[npos - 1]",
            "0"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEP_GETWEIGHT",
          "args": [
            "pos[npos - 1]"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t_iseq",
          "args": [
            "state->prsbuf",
            "'D'"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "text_isequal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "4281-4287",
          "snippet": "static bool\ntext_isequal(text *txt1, text *txt2)\n{\n\treturn DatumGetBool(DirectFunctionCall2(texteq,\n\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(txt1),\n\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(txt2)));\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool\ntext_isequal(text *txt1, text *txt2)\n{\n\treturn DatumGetBool(DirectFunctionCall2(texteq,\n\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(txt1),\n\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(txt2)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "WEP_SETWEIGHT",
          "args": [
            "pos[npos - 1]",
            "1"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEP_GETWEIGHT",
          "args": [
            "pos[npos - 1]"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEP_SETWEIGHT",
          "args": [
            "pos[npos - 1]",
            "2"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEP_GETWEIGHT",
          "args": [
            "pos[npos - 1]"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEP_SETWEIGHT",
          "args": [
            "pos[npos - 1]",
            "3"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEP_GETWEIGHT",
          "args": [
            "pos[npos - 1]"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEP_SETWEIGHT",
          "args": [
            "pos[npos - 1]",
            "0"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t\t errmsg(\"wrong position info in tsvector: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\tstate->bufstart))"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"wrong position info in tsvector: \\\"%s\\\"\"",
            "state->bufstart"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_SYNTAX_ERROR"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "WEP_GETPOS",
          "args": [
            "pos[npos - 1]"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEP_SETPOS",
          "args": [
            "pos[npos - 1]",
            "LIMITPOS(atoi(state->prsbuf))"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIMITPOS",
          "args": [
            "atoi(state->prsbuf)"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "state->prsbuf"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "repalloc",
          "args": [
            "pos",
            "sizeof(WordEntryPos) * posalen"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "xml_repalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1642-1646",
          "snippet": "static void *\nxml_repalloc(void *ptr, size_t size)\n{\n\treturn repalloc(ptr, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_repalloc(void *ptr, size_t size)\n{\n\treturn repalloc(ptr, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(WordEntryPos) * posalen"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "t_isdigit",
          "args": [
            "state->prsbuf"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPYCHAR",
          "args": [
            "curpos",
            "state->prsbuf"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPYCHAR",
          "args": [
            "curpos",
            "state->prsbuf"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPYCHAR",
          "args": [
            "curpos",
            "state->prsbuf"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISOPERATOR",
          "args": [
            "state->prsbuf"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t_isspace",
          "args": [
            "state->prsbuf"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "oldstate != 0"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPYCHAR",
          "args": [
            "curpos",
            "state->prsbuf"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"there is no escaped character: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\tstate->bufstart))"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPYCHAR",
          "args": [
            "curpos",
            "state->prsbuf"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t_isspace",
          "args": [
            "state->prsbuf"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISOPERATOR",
          "args": [
            "state->prsbuf"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"postgres.h\"\n\n#define PRSSYNTAXERROR prssyntaxerror(state)\n#define WAITCHARCMPLX\t8\n#define WAITPOSDELIM\t7\n#define INPOSINFO\t\t6\n#define WAITPOSINFO\t\t5\n#define WAITENDCMPLX\t4\n#define WAITNEXTCHAR\t3\n#define WAITENDWORD\t\t2\n#define WAITWORD\t\t1\n#define RETURN_TOKEN \\\ndo { \\\n\tif (pos_ptr != NULL) \\\n\t{ \\\n\t\t*pos_ptr = pos; \\\n\t\t*poslen = npos; \\\n\t} \\\n\telse if (pos != NULL) \\\n\t\tpfree(pos); \\\n\t\\\n\tif (strval != NULL) \\\n\t\t*strval = state->word; \\\n\tif (lenval != NULL) \\\n\t\t*lenval = curpos - state->word; \\\n\tif (endptr != NULL) \\\n\t\t*endptr = state->prsbuf; \\\n\treturn true; \\\n} while(0)\n#define RESIZEPRSBUF \\\ndo { \\\n\tint clen = curpos - state->word; \\\n\tif ( clen + state->eml >= state->len ) \\\n\t{ \\\n\t\tstate->len *= 2; \\\n\t\tstate->word = (char *) repalloc(state->word, state->len); \\\n\t\tcurpos = state->word + clen; \\\n\t} \\\n} while (0)\n\nbool\ngettoken_tsvector(TSVectorParseState state,\n\t\t\t\t  char **strval, int *lenval,\n\t\t\t\t  WordEntryPos **pos_ptr, int *poslen,\n\t\t\t\t  char **endptr)\n{\n\tint\t\t\toldstate = 0;\n\tchar\t   *curpos = state->word;\n\tint\t\t\tstatecode = WAITWORD;\n\n\t/*\n\t * pos is for collecting the comma delimited list of positions followed by\n\t * the actual token.\n\t */\n\tWordEntryPos *pos = NULL;\n\tint\t\t\tnpos = 0;\t\t/* elements of pos used */\n\tint\t\t\tposalen = 0;\t/* allocated size of pos */\n\n\twhile (1)\n\t{\n\t\tif (statecode == WAITWORD)\n\t\t{\n\t\t\tif (*(state->prsbuf) == '\\0')\n\t\t\t\treturn false;\n\t\t\telse if (!state->is_web && t_iseq(state->prsbuf, '\\''))\n\t\t\t\tstatecode = WAITENDCMPLX;\n\t\t\telse if (!state->is_web && t_iseq(state->prsbuf, '\\\\'))\n\t\t\t{\n\t\t\t\tstatecode = WAITNEXTCHAR;\n\t\t\t\toldstate = WAITENDWORD;\n\t\t\t}\n\t\t\telse if ((state->oprisdelim && ISOPERATOR(state->prsbuf)) ||\n\t\t\t\t\t (state->is_web && t_iseq(state->prsbuf, '\"')))\n\t\t\t\tPRSSYNTAXERROR;\n\t\t\telse if (!t_isspace(state->prsbuf))\n\t\t\t{\n\t\t\t\tCOPYCHAR(curpos, state->prsbuf);\n\t\t\t\tcurpos += pg_mblen(state->prsbuf);\n\t\t\t\tstatecode = WAITENDWORD;\n\t\t\t}\n\t\t}\n\t\telse if (statecode == WAITNEXTCHAR)\n\t\t{\n\t\t\tif (*(state->prsbuf) == '\\0')\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"there is no escaped character: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\tstate->bufstart)));\n\t\t\telse\n\t\t\t{\n\t\t\t\tRESIZEPRSBUF;\n\t\t\t\tCOPYCHAR(curpos, state->prsbuf);\n\t\t\t\tcurpos += pg_mblen(state->prsbuf);\n\t\t\t\tAssert(oldstate != 0);\n\t\t\t\tstatecode = oldstate;\n\t\t\t}\n\t\t}\n\t\telse if (statecode == WAITENDWORD)\n\t\t{\n\t\t\tif (!state->is_web && t_iseq(state->prsbuf, '\\\\'))\n\t\t\t{\n\t\t\t\tstatecode = WAITNEXTCHAR;\n\t\t\t\toldstate = WAITENDWORD;\n\t\t\t}\n\t\t\telse if (t_isspace(state->prsbuf) || *(state->prsbuf) == '\\0' ||\n\t\t\t\t\t (state->oprisdelim && ISOPERATOR(state->prsbuf)) ||\n\t\t\t\t\t (state->is_web && t_iseq(state->prsbuf, '\"')))\n\t\t\t{\n\t\t\t\tRESIZEPRSBUF;\n\t\t\t\tif (curpos == state->word)\n\t\t\t\t\tPRSSYNTAXERROR;\n\t\t\t\t*(curpos) = '\\0';\n\t\t\t\tRETURN_TOKEN;\n\t\t\t}\n\t\t\telse if (t_iseq(state->prsbuf, ':'))\n\t\t\t{\n\t\t\t\tif (curpos == state->word)\n\t\t\t\t\tPRSSYNTAXERROR;\n\t\t\t\t*(curpos) = '\\0';\n\t\t\t\tif (state->oprisdelim)\n\t\t\t\t\tRETURN_TOKEN;\n\t\t\t\telse\n\t\t\t\t\tstatecode = INPOSINFO;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tRESIZEPRSBUF;\n\t\t\t\tCOPYCHAR(curpos, state->prsbuf);\n\t\t\t\tcurpos += pg_mblen(state->prsbuf);\n\t\t\t}\n\t\t}\n\t\telse if (statecode == WAITENDCMPLX)\n\t\t{\n\t\t\tif (!state->is_web && t_iseq(state->prsbuf, '\\''))\n\t\t\t{\n\t\t\t\tstatecode = WAITCHARCMPLX;\n\t\t\t}\n\t\t\telse if (!state->is_web && t_iseq(state->prsbuf, '\\\\'))\n\t\t\t{\n\t\t\t\tstatecode = WAITNEXTCHAR;\n\t\t\t\toldstate = WAITENDCMPLX;\n\t\t\t}\n\t\t\telse if (*(state->prsbuf) == '\\0')\n\t\t\t\tPRSSYNTAXERROR;\n\t\t\telse\n\t\t\t{\n\t\t\t\tRESIZEPRSBUF;\n\t\t\t\tCOPYCHAR(curpos, state->prsbuf);\n\t\t\t\tcurpos += pg_mblen(state->prsbuf);\n\t\t\t}\n\t\t}\n\t\telse if (statecode == WAITCHARCMPLX)\n\t\t{\n\t\t\tif (!state->is_web && t_iseq(state->prsbuf, '\\''))\n\t\t\t{\n\t\t\t\tRESIZEPRSBUF;\n\t\t\t\tCOPYCHAR(curpos, state->prsbuf);\n\t\t\t\tcurpos += pg_mblen(state->prsbuf);\n\t\t\t\tstatecode = WAITENDCMPLX;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tRESIZEPRSBUF;\n\t\t\t\t*(curpos) = '\\0';\n\t\t\t\tif (curpos == state->word)\n\t\t\t\t\tPRSSYNTAXERROR;\n\t\t\t\tif (state->oprisdelim)\n\t\t\t\t{\n\t\t\t\t\t/* state->prsbuf+=pg_mblen(state->prsbuf); */\n\t\t\t\t\tRETURN_TOKEN;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstatecode = WAITPOSINFO;\n\t\t\t\tcontinue;\t\t/* recheck current character */\n\t\t\t}\n\t\t}\n\t\telse if (statecode == WAITPOSINFO)\n\t\t{\n\t\t\tif (t_iseq(state->prsbuf, ':'))\n\t\t\t\tstatecode = INPOSINFO;\n\t\t\telse\n\t\t\t\tRETURN_TOKEN;\n\t\t}\n\t\telse if (statecode == INPOSINFO)\n\t\t{\n\t\t\tif (t_isdigit(state->prsbuf))\n\t\t\t{\n\t\t\t\tif (posalen == 0)\n\t\t\t\t{\n\t\t\t\t\tposalen = 4;\n\t\t\t\t\tpos = (WordEntryPos *) palloc(sizeof(WordEntryPos) * posalen);\n\t\t\t\t\tnpos = 0;\n\t\t\t\t}\n\t\t\t\telse if (npos + 1 >= posalen)\n\t\t\t\t{\n\t\t\t\t\tposalen *= 2;\n\t\t\t\t\tpos = (WordEntryPos *) repalloc(pos, sizeof(WordEntryPos) * posalen);\n\t\t\t\t}\n\t\t\t\tnpos++;\n\t\t\t\tWEP_SETPOS(pos[npos - 1], LIMITPOS(atoi(state->prsbuf)));\n\t\t\t\t/* we cannot get here in tsquery, so no need for 2 errmsgs */\n\t\t\t\tif (WEP_GETPOS(pos[npos - 1]) == 0)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t\t errmsg(\"wrong position info in tsvector: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\tstate->bufstart)));\n\t\t\t\tWEP_SETWEIGHT(pos[npos - 1], 0);\n\t\t\t\tstatecode = WAITPOSDELIM;\n\t\t\t}\n\t\t\telse\n\t\t\t\tPRSSYNTAXERROR;\n\t\t}\n\t\telse if (statecode == WAITPOSDELIM)\n\t\t{\n\t\t\tif (t_iseq(state->prsbuf, ','))\n\t\t\t\tstatecode = INPOSINFO;\n\t\t\telse if (t_iseq(state->prsbuf, 'a') || t_iseq(state->prsbuf, 'A') || t_iseq(state->prsbuf, '*'))\n\t\t\t{\n\t\t\t\tif (WEP_GETWEIGHT(pos[npos - 1]))\n\t\t\t\t\tPRSSYNTAXERROR;\n\t\t\t\tWEP_SETWEIGHT(pos[npos - 1], 3);\n\t\t\t}\n\t\t\telse if (t_iseq(state->prsbuf, 'b') || t_iseq(state->prsbuf, 'B'))\n\t\t\t{\n\t\t\t\tif (WEP_GETWEIGHT(pos[npos - 1]))\n\t\t\t\t\tPRSSYNTAXERROR;\n\t\t\t\tWEP_SETWEIGHT(pos[npos - 1], 2);\n\t\t\t}\n\t\t\telse if (t_iseq(state->prsbuf, 'c') || t_iseq(state->prsbuf, 'C'))\n\t\t\t{\n\t\t\t\tif (WEP_GETWEIGHT(pos[npos - 1]))\n\t\t\t\t\tPRSSYNTAXERROR;\n\t\t\t\tWEP_SETWEIGHT(pos[npos - 1], 1);\n\t\t\t}\n\t\t\telse if (t_iseq(state->prsbuf, 'd') || t_iseq(state->prsbuf, 'D'))\n\t\t\t{\n\t\t\t\tif (WEP_GETWEIGHT(pos[npos - 1]))\n\t\t\t\t\tPRSSYNTAXERROR;\n\t\t\t\tWEP_SETWEIGHT(pos[npos - 1], 0);\n\t\t\t}\n\t\t\telse if (t_isspace(state->prsbuf) ||\n\t\t\t\t\t *(state->prsbuf) == '\\0')\n\t\t\t\tRETURN_TOKEN;\n\t\t\telse if (!t_isdigit(state->prsbuf))\n\t\t\t\tPRSSYNTAXERROR;\n\t\t}\n\t\telse\t\t\t\t\t/* internal error */\n\t\t\telog(ERROR, \"unrecognized state in gettoken_tsvector: %d\",\n\t\t\t\t statecode);\n\n\t\t/* get next char */\n\t\tstate->prsbuf += pg_mblen(state->prsbuf);\n\t}\n}"
  },
  {
    "function_name": "prssyntaxerror",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_parser.c",
    "lines": "127-135",
    "snippet": "static void\nprssyntaxerror(TSVectorParseState state)\n{\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t state->is_tsquery ?\n\t\t\t errmsg(\"syntax error in tsquery: \\\"%s\\\"\", state->bufstart) :\n\t\t\t errmsg(\"syntax error in tsvector: \\\"%s\\\"\", state->bufstart)));\n}",
    "includes": [
      "#include \"tsearch/ts_utils.h\"",
      "#include \"tsearch/ts_locale.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t state->is_tsquery ?\n\t\t\t errmsg(\"syntax error in tsquery: \\\"%s\\\"\", state->bufstart) :\n\t\t\t errmsg(\"syntax error in tsvector: \\\"%s\\\"\", state->bufstart))"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"syntax error in tsvector: \\\"%s\\\"\"",
            "state->bufstart"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_SYNTAX_ERROR"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"postgres.h\"\n\nstatic void\nprssyntaxerror(TSVectorParseState state)\n{\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t state->is_tsquery ?\n\t\t\t errmsg(\"syntax error in tsquery: \\\"%s\\\"\", state->bufstart) :\n\t\t\t errmsg(\"syntax error in tsvector: \\\"%s\\\"\", state->bufstart)));\n}"
  },
  {
    "function_name": "close_tsvector_parser",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_parser.c",
    "lines": "75-80",
    "snippet": "void\nclose_tsvector_parser(TSVectorParseState state)\n{\n\tpfree(state->word);\n\tpfree(state);\n}",
    "includes": [
      "#include \"tsearch/ts_utils.h\"",
      "#include \"tsearch/ts_locale.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "state"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"postgres.h\"\n\nvoid\nclose_tsvector_parser(TSVectorParseState state)\n{\n\tpfree(state->word);\n\tpfree(state);\n}"
  },
  {
    "function_name": "reset_tsvector_parser",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_parser.c",
    "lines": "66-70",
    "snippet": "void\nreset_tsvector_parser(TSVectorParseState state, char *input)\n{\n\tstate->prsbuf = input;\n}",
    "includes": [
      "#include \"tsearch/ts_utils.h\"",
      "#include \"tsearch/ts_locale.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"postgres.h\"\n\nvoid\nreset_tsvector_parser(TSVectorParseState state, char *input)\n{\n\tstate->prsbuf = input;\n}"
  },
  {
    "function_name": "init_tsvector_parser",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_parser.c",
    "lines": "45-61",
    "snippet": "TSVectorParseState\ninit_tsvector_parser(char *input, int flags)\n{\n\tTSVectorParseState state;\n\n\tstate = (TSVectorParseState) palloc(sizeof(struct TSVectorParseStateData));\n\tstate->prsbuf = input;\n\tstate->bufstart = input;\n\tstate->len = 32;\n\tstate->word = (char *) palloc(state->len);\n\tstate->eml = pg_database_encoding_max_length();\n\tstate->oprisdelim = (flags & P_TSV_OPR_IS_DELIM) != 0;\n\tstate->is_tsquery = (flags & P_TSV_IS_TSQUERY) != 0;\n\tstate->is_web = (flags & P_TSV_IS_WEB) != 0;\n\n\treturn state;\n}",
    "includes": [
      "#include \"tsearch/ts_utils.h\"",
      "#include \"tsearch/ts_locale.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pg_database_encoding_max_length",
          "args": [],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "pg_database_encoding_max_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "1832-1836",
          "snippet": "int\npg_database_encoding_max_length(void)\n{\n\treturn pg_wchar_table[GetDatabaseEncoding()].maxmblen;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nconst pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};\n\nint\npg_database_encoding_max_length(void)\n{\n\treturn pg_wchar_table[GetDatabaseEncoding()].maxmblen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "state->len"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"postgres.h\"\n\nTSVectorParseState\ninit_tsvector_parser(char *input, int flags)\n{\n\tTSVectorParseState state;\n\n\tstate = (TSVectorParseState) palloc(sizeof(struct TSVectorParseStateData));\n\tstate->prsbuf = input;\n\tstate->bufstart = input;\n\tstate->len = 32;\n\tstate->word = (char *) palloc(state->len);\n\tstate->eml = pg_database_encoding_max_length();\n\tstate->oprisdelim = (flags & P_TSV_OPR_IS_DELIM) != 0;\n\tstate->is_tsquery = (flags & P_TSV_IS_TSQUERY) != 0;\n\tstate->is_web = (flags & P_TSV_IS_WEB) != 0;\n\n\treturn state;\n}"
  }
]