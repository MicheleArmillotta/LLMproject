[
  {
    "function_name": "LocalToUtf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/conv.c",
    "lines": "665-780",
    "snippet": "void\nLocalToUtf(const unsigned char *iso, int len,\n\t\t   unsigned char *utf,\n\t\t   const pg_mb_radix_tree *map,\n\t\t   const pg_local_to_utf_combined *cmap, int cmapsize,\n\t\t   utf_local_conversion_func conv_func,\n\t\t   int encoding)\n{\n\tuint32\t\tiiso;\n\tint\t\t\tl;\n\tconst pg_local_to_utf_combined *cp;\n\n\tif (!PG_VALID_ENCODING(encoding))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid encoding number: %d\", encoding)));\n\n\tfor (; len > 0; len -= l)\n\t{\n\t\tunsigned char b1 = 0;\n\t\tunsigned char b2 = 0;\n\t\tunsigned char b3 = 0;\n\t\tunsigned char b4 = 0;\n\n\t\t/* \"break\" cases all represent errors */\n\t\tif (*iso == '\\0')\n\t\t\tbreak;\n\n\t\tif (!IS_HIGHBIT_SET(*iso))\n\t\t{\n\t\t\t/* ASCII case is easy, assume it's one-to-one conversion */\n\t\t\t*utf++ = *iso++;\n\t\t\tl = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tl = pg_encoding_verifymb(encoding, (const char *) iso, len);\n\t\tif (l < 0)\n\t\t\tbreak;\n\n\t\t/* collect coded char of length l */\n\t\tif (l == 1)\n\t\t\tb4 = *iso++;\n\t\telse if (l == 2)\n\t\t{\n\t\t\tb3 = *iso++;\n\t\t\tb4 = *iso++;\n\t\t}\n\t\telse if (l == 3)\n\t\t{\n\t\t\tb2 = *iso++;\n\t\t\tb3 = *iso++;\n\t\t\tb4 = *iso++;\n\t\t}\n\t\telse if (l == 4)\n\t\t{\n\t\t\tb1 = *iso++;\n\t\t\tb2 = *iso++;\n\t\t\tb3 = *iso++;\n\t\t\tb4 = *iso++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\telog(ERROR, \"unsupported character length %d\", l);\n\t\t\tiiso = 0;\t\t\t/* keep compiler quiet */\n\t\t}\n\t\tiiso = (b1 << 24 | b2 << 16 | b3 << 8 | b4);\n\n\t\tif (map)\n\t\t{\n\t\t\tuint32\t\tconverted = pg_mb_radix_conv(map, l, b1, b2, b3, b4);\n\n\t\t\tif (converted)\n\t\t\t{\n\t\t\t\tutf = store_coded_char(utf, converted);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* If there's a combined character map, try that */\n\t\t\tif (cmap)\n\t\t\t{\n\t\t\t\tcp = bsearch(&iiso, cmap, cmapsize,\n\t\t\t\t\t\t\t sizeof(pg_local_to_utf_combined), compare4);\n\n\t\t\t\tif (cp)\n\t\t\t\t{\n\t\t\t\t\tutf = store_coded_char(utf, cp->utf1);\n\t\t\t\t\tutf = store_coded_char(utf, cp->utf2);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* if there's a conversion function, try that */\n\t\tif (conv_func)\n\t\t{\n\t\t\tuint32\t\tconverted = (*conv_func) (iiso);\n\n\t\t\tif (converted)\n\t\t\t{\n\t\t\t\tutf = store_coded_char(utf, converted);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/* failed to translate this character */\n\t\treport_untranslatable_char(encoding, PG_UTF8,\n\t\t\t\t\t\t\t\t   (const char *) (iso - l), len);\n\t}\n\n\t/* if we broke out of loop early, must be invalid input */\n\tif (len > 0)\n\t\treport_invalid_encoding(encoding, (const char *) iso, len);\n\n\t*utf = '\\0';\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "report_invalid_encoding",
          "args": [
            "encoding",
            "(const char *) iso",
            "len"
          ],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "report_invalid_encoding",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "1994-2018",
          "snippet": "void\nreport_invalid_encoding(int encoding, const char *mbstr, int len)\n{\n\tint\t\t\tl = pg_encoding_mblen(encoding, mbstr);\n\tchar\t\tbuf[8 * 5 + 1];\n\tchar\t   *p = buf;\n\tint\t\t\tj,\n\t\t\t\tjlimit;\n\n\tjlimit = Min(l, len);\n\tjlimit = Min(jlimit, 8);\t/* prevent buffer overrun */\n\n\tfor (j = 0; j < jlimit; j++)\n\t{\n\t\tp += sprintf(p, \"0x%02x\", (unsigned char) mbstr[j]);\n\t\tif (j < jlimit - 1)\n\t\t\tp += sprintf(p, \" \");\n\t}\n\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_CHARACTER_NOT_IN_REPERTOIRE),\n\t\t\t errmsg(\"invalid byte sequence for encoding \\\"%s\\\": %s\",\n\t\t\t\t\tpg_enc2name_tbl[encoding].name,\n\t\t\t\t\tbuf)));\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nvoid\nreport_invalid_encoding(int encoding, const char *mbstr, int len)\n{\n\tint\t\t\tl = pg_encoding_mblen(encoding, mbstr);\n\tchar\t\tbuf[8 * 5 + 1];\n\tchar\t   *p = buf;\n\tint\t\t\tj,\n\t\t\t\tjlimit;\n\n\tjlimit = Min(l, len);\n\tjlimit = Min(jlimit, 8);\t/* prevent buffer overrun */\n\n\tfor (j = 0; j < jlimit; j++)\n\t{\n\t\tp += sprintf(p, \"0x%02x\", (unsigned char) mbstr[j]);\n\t\tif (j < jlimit - 1)\n\t\t\tp += sprintf(p, \" \");\n\t}\n\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_CHARACTER_NOT_IN_REPERTOIRE),\n\t\t\t errmsg(\"invalid byte sequence for encoding \\\"%s\\\": %s\",\n\t\t\t\t\tpg_enc2name_tbl[encoding].name,\n\t\t\t\t\tbuf)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "report_untranslatable_char",
          "args": [
            "encoding",
            "PG_UTF8",
            "(const char *) (iso - l)",
            "len"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "report_untranslatable_char",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "2026-2052",
          "snippet": "void\nreport_untranslatable_char(int src_encoding, int dest_encoding,\n\t\t\t\t\t\t   const char *mbstr, int len)\n{\n\tint\t\t\tl = pg_encoding_mblen(src_encoding, mbstr);\n\tchar\t\tbuf[8 * 5 + 1];\n\tchar\t   *p = buf;\n\tint\t\t\tj,\n\t\t\t\tjlimit;\n\n\tjlimit = Min(l, len);\n\tjlimit = Min(jlimit, 8);\t/* prevent buffer overrun */\n\n\tfor (j = 0; j < jlimit; j++)\n\t{\n\t\tp += sprintf(p, \"0x%02x\", (unsigned char) mbstr[j]);\n\t\tif (j < jlimit - 1)\n\t\t\tp += sprintf(p, \" \");\n\t}\n\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_UNTRANSLATABLE_CHARACTER),\n\t\t\t errmsg(\"character with byte sequence %s in encoding \\\"%s\\\" has no equivalent in encoding \\\"%s\\\"\",\n\t\t\t\t\tbuf,\n\t\t\t\t\tpg_enc2name_tbl[src_encoding].name,\n\t\t\t\t\tpg_enc2name_tbl[dest_encoding].name)));\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nvoid\nreport_untranslatable_char(int src_encoding, int dest_encoding,\n\t\t\t\t\t\t   const char *mbstr, int len)\n{\n\tint\t\t\tl = pg_encoding_mblen(src_encoding, mbstr);\n\tchar\t\tbuf[8 * 5 + 1];\n\tchar\t   *p = buf;\n\tint\t\t\tj,\n\t\t\t\tjlimit;\n\n\tjlimit = Min(l, len);\n\tjlimit = Min(jlimit, 8);\t/* prevent buffer overrun */\n\n\tfor (j = 0; j < jlimit; j++)\n\t{\n\t\tp += sprintf(p, \"0x%02x\", (unsigned char) mbstr[j]);\n\t\tif (j < jlimit - 1)\n\t\t\tp += sprintf(p, \" \");\n\t}\n\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_UNTRANSLATABLE_CHARACTER),\n\t\t\t errmsg(\"character with byte sequence %s in encoding \\\"%s\\\" has no equivalent in encoding \\\"%s\\\"\",\n\t\t\t\t\tbuf,\n\t\t\t\t\tpg_enc2name_tbl[src_encoding].name,\n\t\t\t\t\tpg_enc2name_tbl[dest_encoding].name)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "store_coded_char",
          "args": [
            "utf",
            "converted"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "store_coded_char",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/conv.c",
          "lines": "322-334",
          "snippet": "static inline unsigned char *\nstore_coded_char(unsigned char *dest, uint32 code)\n{\n\tif (code & 0xff000000)\n\t\t*dest++ = code >> 24;\n\tif (code & 0x00ff0000)\n\t\t*dest++ = code >> 16;\n\tif (code & 0x0000ff00)\n\t\t*dest++ = code >> 8;\n\tif (code & 0x000000ff)\n\t\t*dest++ = code;\n\treturn dest;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic inline unsigned char *\nstore_coded_char(unsigned char *dest, uint32 code)\n{\n\tif (code & 0xff000000)\n\t\t*dest++ = code >> 24;\n\tif (code & 0x00ff0000)\n\t\t*dest++ = code >> 16;\n\tif (code & 0x0000ff00)\n\t\t*dest++ = code >> 8;\n\tif (code & 0x000000ff)\n\t\t*dest++ = code;\n\treturn dest;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "iiso"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bsearch",
          "args": [
            "&iiso",
            "cmap",
            "cmapsize",
            "sizeof(pg_local_to_utf_combined)",
            "compare4"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "rbound_bsearch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_selfuncs.c",
          "lines": "617-637",
          "snippet": "static int\nrbound_bsearch(TypeCacheEntry *typcache, RangeBound *value, RangeBound *hist,\n\t\t\t   int hist_length, bool equal)\n{\n\tint\t\t\tlower = -1,\n\t\t\t\tupper = hist_length - 1,\n\t\t\t\tcmp,\n\t\t\t\tmiddle;\n\n\twhile (lower < upper)\n\t{\n\t\tmiddle = (lower + upper + 1) / 2;\n\t\tcmp = range_cmp_bounds(typcache, &hist[middle], value);\n\n\t\tif (cmp < 0 || (equal && cmp == 0))\n\t\t\tlower = middle;\n\t\telse\n\t\t\tupper = middle - 1;\n\t}\n\treturn lower;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double calc_hist_selectivity_scalar(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t RangeBound *constbound,\n\t\t\t\t\t\t\t RangeBound *hist, int hist_nvalues,\n\t\t\t\t\t\t\t bool equal);",
            "static int rbound_bsearch(TypeCacheEntry *typcache, RangeBound *value,\n\t\t\t   RangeBound *hist, int hist_length, bool equal);",
            "static int length_hist_bsearch(Datum *length_hist_values,\n\t\t\t\t\tint length_hist_nvalues, double value, bool equal);",
            "static double calc_length_hist_frac(Datum *length_hist_values,\n\t\t\t\t\t  int length_hist_nvalues, double length1, double length2, bool equal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic double calc_hist_selectivity_scalar(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t RangeBound *constbound,\n\t\t\t\t\t\t\t RangeBound *hist, int hist_nvalues,\n\t\t\t\t\t\t\t bool equal);\nstatic int rbound_bsearch(TypeCacheEntry *typcache, RangeBound *value,\n\t\t\t   RangeBound *hist, int hist_length, bool equal);\nstatic int length_hist_bsearch(Datum *length_hist_values,\n\t\t\t\t\tint length_hist_nvalues, double value, bool equal);\nstatic double calc_length_hist_frac(Datum *length_hist_values,\n\t\t\t\t\t  int length_hist_nvalues, double length1, double length2, bool equal);\n\nstatic int\nrbound_bsearch(TypeCacheEntry *typcache, RangeBound *value, RangeBound *hist,\n\t\t\t   int hist_length, bool equal)\n{\n\tint\t\t\tlower = -1,\n\t\t\t\tupper = hist_length - 1,\n\t\t\t\tcmp,\n\t\t\t\tmiddle;\n\n\twhile (lower < upper)\n\t{\n\t\tmiddle = (lower + upper + 1) / 2;\n\t\tcmp = range_cmp_bounds(typcache, &hist[middle], value);\n\n\t\tif (cmp < 0 || (equal && cmp == 0))\n\t\t\tlower = middle;\n\t\telse\n\t\t\tupper = middle - 1;\n\t}\n\treturn lower;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_mb_radix_conv",
          "args": [
            "map",
            "l",
            "b1",
            "b2",
            "b3",
            "b4"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mb_radix_conv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/conv.c",
          "lines": "342-449",
          "snippet": "static inline uint32\npg_mb_radix_conv(const pg_mb_radix_tree *rt,\n\t\t\t\t int l,\n\t\t\t\t unsigned char b1,\n\t\t\t\t unsigned char b2,\n\t\t\t\t unsigned char b3,\n\t\t\t\t unsigned char b4)\n{\n\tif (l == 4)\n\t{\n\t\t/* 4-byte code */\n\n\t\t/* check code validity */\n\t\tif (b1 < rt->b4_1_lower || b1 > rt->b4_1_upper ||\n\t\t\tb2 < rt->b4_2_lower || b2 > rt->b4_2_upper ||\n\t\t\tb3 < rt->b4_3_lower || b3 > rt->b4_3_upper ||\n\t\t\tb4 < rt->b4_4_lower || b4 > rt->b4_4_upper)\n\t\t\treturn 0;\n\n\t\t/* perform lookup */\n\t\tif (rt->chars32)\n\t\t{\n\t\t\tuint32\t\tidx = rt->b4root;\n\n\t\t\tidx = rt->chars32[b1 + idx - rt->b4_1_lower];\n\t\t\tidx = rt->chars32[b2 + idx - rt->b4_2_lower];\n\t\t\tidx = rt->chars32[b3 + idx - rt->b4_3_lower];\n\t\t\treturn rt->chars32[b4 + idx - rt->b4_4_lower];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tuint16\t\tidx = rt->b4root;\n\n\t\t\tidx = rt->chars16[b1 + idx - rt->b4_1_lower];\n\t\t\tidx = rt->chars16[b2 + idx - rt->b4_2_lower];\n\t\t\tidx = rt->chars16[b3 + idx - rt->b4_3_lower];\n\t\t\treturn rt->chars16[b4 + idx - rt->b4_4_lower];\n\t\t}\n\t}\n\telse if (l == 3)\n\t{\n\t\t/* 3-byte code */\n\n\t\t/* check code validity */\n\t\tif (b2 < rt->b3_1_lower || b2 > rt->b3_1_upper ||\n\t\t\tb3 < rt->b3_2_lower || b3 > rt->b3_2_upper ||\n\t\t\tb4 < rt->b3_3_lower || b4 > rt->b3_3_upper)\n\t\t\treturn 0;\n\n\t\t/* perform lookup */\n\t\tif (rt->chars32)\n\t\t{\n\t\t\tuint32\t\tidx = rt->b3root;\n\n\t\t\tidx = rt->chars32[b2 + idx - rt->b3_1_lower];\n\t\t\tidx = rt->chars32[b3 + idx - rt->b3_2_lower];\n\t\t\treturn rt->chars32[b4 + idx - rt->b3_3_lower];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tuint16\t\tidx = rt->b3root;\n\n\t\t\tidx = rt->chars16[b2 + idx - rt->b3_1_lower];\n\t\t\tidx = rt->chars16[b3 + idx - rt->b3_2_lower];\n\t\t\treturn rt->chars16[b4 + idx - rt->b3_3_lower];\n\t\t}\n\t}\n\telse if (l == 2)\n\t{\n\t\t/* 2-byte code */\n\n\t\t/* check code validity - first byte */\n\t\tif (b3 < rt->b2_1_lower || b3 > rt->b2_1_upper ||\n\t\t\tb4 < rt->b2_2_lower || b4 > rt->b2_2_upper)\n\t\t\treturn 0;\n\n\t\t/* perform lookup */\n\t\tif (rt->chars32)\n\t\t{\n\t\t\tuint32\t\tidx = rt->b2root;\n\n\t\t\tidx = rt->chars32[b3 + idx - rt->b2_1_lower];\n\t\t\treturn rt->chars32[b4 + idx - rt->b2_2_lower];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tuint16\t\tidx = rt->b2root;\n\n\t\t\tidx = rt->chars16[b3 + idx - rt->b2_1_lower];\n\t\t\treturn rt->chars16[b4 + idx - rt->b2_2_lower];\n\t\t}\n\t}\n\telse if (l == 1)\n\t{\n\t\t/* 1-byte code */\n\n\t\t/* check code validity - first byte */\n\t\tif (b4 < rt->b1_lower || b4 > rt->b1_upper)\n\t\t\treturn 0;\n\n\t\t/* perform lookup */\n\t\tif (rt->chars32)\n\t\t\treturn rt->chars32[b4 + rt->b1root - rt->b1_lower];\n\t\telse\n\t\t\treturn rt->chars16[b4 + rt->b1root - rt->b1_lower];\n\t}\n\treturn 0;\t\t\t\t\t/* shouldn't happen */\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic inline uint32\npg_mb_radix_conv(const pg_mb_radix_tree *rt,\n\t\t\t\t int l,\n\t\t\t\t unsigned char b1,\n\t\t\t\t unsigned char b2,\n\t\t\t\t unsigned char b3,\n\t\t\t\t unsigned char b4)\n{\n\tif (l == 4)\n\t{\n\t\t/* 4-byte code */\n\n\t\t/* check code validity */\n\t\tif (b1 < rt->b4_1_lower || b1 > rt->b4_1_upper ||\n\t\t\tb2 < rt->b4_2_lower || b2 > rt->b4_2_upper ||\n\t\t\tb3 < rt->b4_3_lower || b3 > rt->b4_3_upper ||\n\t\t\tb4 < rt->b4_4_lower || b4 > rt->b4_4_upper)\n\t\t\treturn 0;\n\n\t\t/* perform lookup */\n\t\tif (rt->chars32)\n\t\t{\n\t\t\tuint32\t\tidx = rt->b4root;\n\n\t\t\tidx = rt->chars32[b1 + idx - rt->b4_1_lower];\n\t\t\tidx = rt->chars32[b2 + idx - rt->b4_2_lower];\n\t\t\tidx = rt->chars32[b3 + idx - rt->b4_3_lower];\n\t\t\treturn rt->chars32[b4 + idx - rt->b4_4_lower];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tuint16\t\tidx = rt->b4root;\n\n\t\t\tidx = rt->chars16[b1 + idx - rt->b4_1_lower];\n\t\t\tidx = rt->chars16[b2 + idx - rt->b4_2_lower];\n\t\t\tidx = rt->chars16[b3 + idx - rt->b4_3_lower];\n\t\t\treturn rt->chars16[b4 + idx - rt->b4_4_lower];\n\t\t}\n\t}\n\telse if (l == 3)\n\t{\n\t\t/* 3-byte code */\n\n\t\t/* check code validity */\n\t\tif (b2 < rt->b3_1_lower || b2 > rt->b3_1_upper ||\n\t\t\tb3 < rt->b3_2_lower || b3 > rt->b3_2_upper ||\n\t\t\tb4 < rt->b3_3_lower || b4 > rt->b3_3_upper)\n\t\t\treturn 0;\n\n\t\t/* perform lookup */\n\t\tif (rt->chars32)\n\t\t{\n\t\t\tuint32\t\tidx = rt->b3root;\n\n\t\t\tidx = rt->chars32[b2 + idx - rt->b3_1_lower];\n\t\t\tidx = rt->chars32[b3 + idx - rt->b3_2_lower];\n\t\t\treturn rt->chars32[b4 + idx - rt->b3_3_lower];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tuint16\t\tidx = rt->b3root;\n\n\t\t\tidx = rt->chars16[b2 + idx - rt->b3_1_lower];\n\t\t\tidx = rt->chars16[b3 + idx - rt->b3_2_lower];\n\t\t\treturn rt->chars16[b4 + idx - rt->b3_3_lower];\n\t\t}\n\t}\n\telse if (l == 2)\n\t{\n\t\t/* 2-byte code */\n\n\t\t/* check code validity - first byte */\n\t\tif (b3 < rt->b2_1_lower || b3 > rt->b2_1_upper ||\n\t\t\tb4 < rt->b2_2_lower || b4 > rt->b2_2_upper)\n\t\t\treturn 0;\n\n\t\t/* perform lookup */\n\t\tif (rt->chars32)\n\t\t{\n\t\t\tuint32\t\tidx = rt->b2root;\n\n\t\t\tidx = rt->chars32[b3 + idx - rt->b2_1_lower];\n\t\t\treturn rt->chars32[b4 + idx - rt->b2_2_lower];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tuint16\t\tidx = rt->b2root;\n\n\t\t\tidx = rt->chars16[b3 + idx - rt->b2_1_lower];\n\t\t\treturn rt->chars16[b4 + idx - rt->b2_2_lower];\n\t\t}\n\t}\n\telse if (l == 1)\n\t{\n\t\t/* 1-byte code */\n\n\t\t/* check code validity - first byte */\n\t\tif (b4 < rt->b1_lower || b4 > rt->b1_upper)\n\t\t\treturn 0;\n\n\t\t/* perform lookup */\n\t\tif (rt->chars32)\n\t\t\treturn rt->chars32[b4 + rt->b1root - rt->b1_lower];\n\t\telse\n\t\t\treturn rt->chars16[b4 + rt->b1root - rt->b1_lower];\n\t}\n\treturn 0;\t\t\t\t\t/* shouldn't happen */\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unsupported character length %d\"",
            "l"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_encoding_verifymb",
          "args": [
            "encoding",
            "(const char *) iso",
            "len"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "pg_encoding_verifymb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "1808-1814",
          "snippet": "int\npg_encoding_verifymb(int encoding, const char *mbstr, int len)\n{\n\treturn (PG_VALID_ENCODING(encoding) ?\n\t\t\tpg_wchar_table[encoding].mbverify((const unsigned char *) mbstr, len) :\n\t\t\tpg_wchar_table[PG_SQL_ASCII].mbverify((const unsigned char *) mbstr, len));\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nconst pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};\n\nint\npg_encoding_verifymb(int encoding, const char *mbstr, int len)\n{\n\treturn (PG_VALID_ENCODING(encoding) ?\n\t\t\tpg_wchar_table[encoding].mbverify((const unsigned char *) mbstr, len) :\n\t\t\tpg_wchar_table[PG_SQL_ASCII].mbverify((const unsigned char *) mbstr, len));\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_HIGHBIT_SET",
          "args": [
            "*iso"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid encoding number: %d\", encoding))"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid encoding number: %d\"",
            "encoding"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_VALID_ENCODING",
          "args": [
            "encoding"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nvoid\nLocalToUtf(const unsigned char *iso, int len,\n\t\t   unsigned char *utf,\n\t\t   const pg_mb_radix_tree *map,\n\t\t   const pg_local_to_utf_combined *cmap, int cmapsize,\n\t\t   utf_local_conversion_func conv_func,\n\t\t   int encoding)\n{\n\tuint32\t\tiiso;\n\tint\t\t\tl;\n\tconst pg_local_to_utf_combined *cp;\n\n\tif (!PG_VALID_ENCODING(encoding))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid encoding number: %d\", encoding)));\n\n\tfor (; len > 0; len -= l)\n\t{\n\t\tunsigned char b1 = 0;\n\t\tunsigned char b2 = 0;\n\t\tunsigned char b3 = 0;\n\t\tunsigned char b4 = 0;\n\n\t\t/* \"break\" cases all represent errors */\n\t\tif (*iso == '\\0')\n\t\t\tbreak;\n\n\t\tif (!IS_HIGHBIT_SET(*iso))\n\t\t{\n\t\t\t/* ASCII case is easy, assume it's one-to-one conversion */\n\t\t\t*utf++ = *iso++;\n\t\t\tl = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tl = pg_encoding_verifymb(encoding, (const char *) iso, len);\n\t\tif (l < 0)\n\t\t\tbreak;\n\n\t\t/* collect coded char of length l */\n\t\tif (l == 1)\n\t\t\tb4 = *iso++;\n\t\telse if (l == 2)\n\t\t{\n\t\t\tb3 = *iso++;\n\t\t\tb4 = *iso++;\n\t\t}\n\t\telse if (l == 3)\n\t\t{\n\t\t\tb2 = *iso++;\n\t\t\tb3 = *iso++;\n\t\t\tb4 = *iso++;\n\t\t}\n\t\telse if (l == 4)\n\t\t{\n\t\t\tb1 = *iso++;\n\t\t\tb2 = *iso++;\n\t\t\tb3 = *iso++;\n\t\t\tb4 = *iso++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\telog(ERROR, \"unsupported character length %d\", l);\n\t\t\tiiso = 0;\t\t\t/* keep compiler quiet */\n\t\t}\n\t\tiiso = (b1 << 24 | b2 << 16 | b3 << 8 | b4);\n\n\t\tif (map)\n\t\t{\n\t\t\tuint32\t\tconverted = pg_mb_radix_conv(map, l, b1, b2, b3, b4);\n\n\t\t\tif (converted)\n\t\t\t{\n\t\t\t\tutf = store_coded_char(utf, converted);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* If there's a combined character map, try that */\n\t\t\tif (cmap)\n\t\t\t{\n\t\t\t\tcp = bsearch(&iiso, cmap, cmapsize,\n\t\t\t\t\t\t\t sizeof(pg_local_to_utf_combined), compare4);\n\n\t\t\t\tif (cp)\n\t\t\t\t{\n\t\t\t\t\tutf = store_coded_char(utf, cp->utf1);\n\t\t\t\t\tutf = store_coded_char(utf, cp->utf2);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* if there's a conversion function, try that */\n\t\tif (conv_func)\n\t\t{\n\t\t\tuint32\t\tconverted = (*conv_func) (iiso);\n\n\t\t\tif (converted)\n\t\t\t{\n\t\t\t\tutf = store_coded_char(utf, converted);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/* failed to translate this character */\n\t\treport_untranslatable_char(encoding, PG_UTF8,\n\t\t\t\t\t\t\t\t   (const char *) (iso - l), len);\n\t}\n\n\t/* if we broke out of loop early, must be invalid input */\n\tif (len > 0)\n\t\treport_invalid_encoding(encoding, (const char *) iso, len);\n\n\t*utf = '\\0';\n}"
  },
  {
    "function_name": "UtfToLocal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/conv.c",
    "lines": "473-641",
    "snippet": "void\nUtfToLocal(const unsigned char *utf, int len,\n\t\t   unsigned char *iso,\n\t\t   const pg_mb_radix_tree *map,\n\t\t   const pg_utf_to_local_combined *cmap, int cmapsize,\n\t\t   utf_local_conversion_func conv_func,\n\t\t   int encoding)\n{\n\tuint32\t\tiutf;\n\tint\t\t\tl;\n\tconst pg_utf_to_local_combined *cp;\n\n\tif (!PG_VALID_ENCODING(encoding))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid encoding number: %d\", encoding)));\n\n\tfor (; len > 0; len -= l)\n\t{\n\t\tunsigned char b1 = 0;\n\t\tunsigned char b2 = 0;\n\t\tunsigned char b3 = 0;\n\t\tunsigned char b4 = 0;\n\n\t\t/* \"break\" cases all represent errors */\n\t\tif (*utf == '\\0')\n\t\t\tbreak;\n\n\t\tl = pg_utf_mblen(utf);\n\t\tif (len < l)\n\t\t\tbreak;\n\n\t\tif (!pg_utf8_islegal(utf, l))\n\t\t\tbreak;\n\n\t\tif (l == 1)\n\t\t{\n\t\t\t/* ASCII case is easy, assume it's one-to-one conversion */\n\t\t\t*iso++ = *utf++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* collect coded char of length l */\n\t\tif (l == 2)\n\t\t{\n\t\t\tb3 = *utf++;\n\t\t\tb4 = *utf++;\n\t\t}\n\t\telse if (l == 3)\n\t\t{\n\t\t\tb2 = *utf++;\n\t\t\tb3 = *utf++;\n\t\t\tb4 = *utf++;\n\t\t}\n\t\telse if (l == 4)\n\t\t{\n\t\t\tb1 = *utf++;\n\t\t\tb2 = *utf++;\n\t\t\tb3 = *utf++;\n\t\t\tb4 = *utf++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\telog(ERROR, \"unsupported character length %d\", l);\n\t\t\tiutf = 0;\t\t\t/* keep compiler quiet */\n\t\t}\n\t\tiutf = (b1 << 24 | b2 << 16 | b3 << 8 | b4);\n\n\t\t/* First, try with combined map if possible */\n\t\tif (cmap && len > l)\n\t\t{\n\t\t\tconst unsigned char *utf_save = utf;\n\t\t\tint\t\t\tlen_save = len;\n\t\t\tint\t\t\tl_save = l;\n\n\t\t\t/* collect next character, same as above */\n\t\t\tlen -= l;\n\n\t\t\tl = pg_utf_mblen(utf);\n\t\t\tif (len < l)\n\t\t\t\tbreak;\n\n\t\t\tif (!pg_utf8_islegal(utf, l))\n\t\t\t\tbreak;\n\n\t\t\t/* We assume ASCII character cannot be in combined map */\n\t\t\tif (l > 1)\n\t\t\t{\n\t\t\t\tuint32\t\tiutf2;\n\t\t\t\tuint32\t\tcutf[2];\n\n\t\t\t\tif (l == 2)\n\t\t\t\t{\n\t\t\t\t\tiutf2 = *utf++ << 8;\n\t\t\t\t\tiutf2 |= *utf++;\n\t\t\t\t}\n\t\t\t\telse if (l == 3)\n\t\t\t\t{\n\t\t\t\t\tiutf2 = *utf++ << 16;\n\t\t\t\t\tiutf2 |= *utf++ << 8;\n\t\t\t\t\tiutf2 |= *utf++;\n\t\t\t\t}\n\t\t\t\telse if (l == 4)\n\t\t\t\t{\n\t\t\t\t\tiutf2 = *utf++ << 24;\n\t\t\t\t\tiutf2 |= *utf++ << 16;\n\t\t\t\t\tiutf2 |= *utf++ << 8;\n\t\t\t\t\tiutf2 |= *utf++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\telog(ERROR, \"unsupported character length %d\", l);\n\t\t\t\t\tiutf2 = 0;\t/* keep compiler quiet */\n\t\t\t\t}\n\n\t\t\t\tcutf[0] = iutf;\n\t\t\t\tcutf[1] = iutf2;\n\n\t\t\t\tcp = bsearch(cutf, cmap, cmapsize,\n\t\t\t\t\t\t\t sizeof(pg_utf_to_local_combined), compare3);\n\n\t\t\t\tif (cp)\n\t\t\t\t{\n\t\t\t\t\tiso = store_coded_char(iso, cp->code);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* fail, so back up to reprocess second character next time */\n\t\t\tutf = utf_save;\n\t\t\tlen = len_save;\n\t\t\tl = l_save;\n\t\t}\n\n\t\t/* Now check ordinary map */\n\t\tif (map)\n\t\t{\n\t\t\tuint32\t\tconverted = pg_mb_radix_conv(map, l, b1, b2, b3, b4);\n\n\t\t\tif (converted)\n\t\t\t{\n\t\t\t\tiso = store_coded_char(iso, converted);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/* if there's a conversion function, try that */\n\t\tif (conv_func)\n\t\t{\n\t\t\tuint32\t\tconverted = (*conv_func) (iutf);\n\n\t\t\tif (converted)\n\t\t\t{\n\t\t\t\tiso = store_coded_char(iso, converted);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/* failed to translate this character */\n\t\treport_untranslatable_char(PG_UTF8, encoding,\n\t\t\t\t\t\t\t\t   (const char *) (utf - l), len);\n\t}\n\n\t/* if we broke out of loop early, must be invalid input */\n\tif (len > 0)\n\t\treport_invalid_encoding(PG_UTF8, (const char *) utf, len);\n\n\t*iso = '\\0';\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "report_invalid_encoding",
          "args": [
            "PG_UTF8",
            "(const char *) utf",
            "len"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "report_invalid_encoding",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "1994-2018",
          "snippet": "void\nreport_invalid_encoding(int encoding, const char *mbstr, int len)\n{\n\tint\t\t\tl = pg_encoding_mblen(encoding, mbstr);\n\tchar\t\tbuf[8 * 5 + 1];\n\tchar\t   *p = buf;\n\tint\t\t\tj,\n\t\t\t\tjlimit;\n\n\tjlimit = Min(l, len);\n\tjlimit = Min(jlimit, 8);\t/* prevent buffer overrun */\n\n\tfor (j = 0; j < jlimit; j++)\n\t{\n\t\tp += sprintf(p, \"0x%02x\", (unsigned char) mbstr[j]);\n\t\tif (j < jlimit - 1)\n\t\t\tp += sprintf(p, \" \");\n\t}\n\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_CHARACTER_NOT_IN_REPERTOIRE),\n\t\t\t errmsg(\"invalid byte sequence for encoding \\\"%s\\\": %s\",\n\t\t\t\t\tpg_enc2name_tbl[encoding].name,\n\t\t\t\t\tbuf)));\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nvoid\nreport_invalid_encoding(int encoding, const char *mbstr, int len)\n{\n\tint\t\t\tl = pg_encoding_mblen(encoding, mbstr);\n\tchar\t\tbuf[8 * 5 + 1];\n\tchar\t   *p = buf;\n\tint\t\t\tj,\n\t\t\t\tjlimit;\n\n\tjlimit = Min(l, len);\n\tjlimit = Min(jlimit, 8);\t/* prevent buffer overrun */\n\n\tfor (j = 0; j < jlimit; j++)\n\t{\n\t\tp += sprintf(p, \"0x%02x\", (unsigned char) mbstr[j]);\n\t\tif (j < jlimit - 1)\n\t\t\tp += sprintf(p, \" \");\n\t}\n\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_CHARACTER_NOT_IN_REPERTOIRE),\n\t\t\t errmsg(\"invalid byte sequence for encoding \\\"%s\\\": %s\",\n\t\t\t\t\tpg_enc2name_tbl[encoding].name,\n\t\t\t\t\tbuf)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "report_untranslatable_char",
          "args": [
            "PG_UTF8",
            "encoding",
            "(const char *) (utf - l)",
            "len"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "report_untranslatable_char",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "2026-2052",
          "snippet": "void\nreport_untranslatable_char(int src_encoding, int dest_encoding,\n\t\t\t\t\t\t   const char *mbstr, int len)\n{\n\tint\t\t\tl = pg_encoding_mblen(src_encoding, mbstr);\n\tchar\t\tbuf[8 * 5 + 1];\n\tchar\t   *p = buf;\n\tint\t\t\tj,\n\t\t\t\tjlimit;\n\n\tjlimit = Min(l, len);\n\tjlimit = Min(jlimit, 8);\t/* prevent buffer overrun */\n\n\tfor (j = 0; j < jlimit; j++)\n\t{\n\t\tp += sprintf(p, \"0x%02x\", (unsigned char) mbstr[j]);\n\t\tif (j < jlimit - 1)\n\t\t\tp += sprintf(p, \" \");\n\t}\n\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_UNTRANSLATABLE_CHARACTER),\n\t\t\t errmsg(\"character with byte sequence %s in encoding \\\"%s\\\" has no equivalent in encoding \\\"%s\\\"\",\n\t\t\t\t\tbuf,\n\t\t\t\t\tpg_enc2name_tbl[src_encoding].name,\n\t\t\t\t\tpg_enc2name_tbl[dest_encoding].name)));\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nvoid\nreport_untranslatable_char(int src_encoding, int dest_encoding,\n\t\t\t\t\t\t   const char *mbstr, int len)\n{\n\tint\t\t\tl = pg_encoding_mblen(src_encoding, mbstr);\n\tchar\t\tbuf[8 * 5 + 1];\n\tchar\t   *p = buf;\n\tint\t\t\tj,\n\t\t\t\tjlimit;\n\n\tjlimit = Min(l, len);\n\tjlimit = Min(jlimit, 8);\t/* prevent buffer overrun */\n\n\tfor (j = 0; j < jlimit; j++)\n\t{\n\t\tp += sprintf(p, \"0x%02x\", (unsigned char) mbstr[j]);\n\t\tif (j < jlimit - 1)\n\t\t\tp += sprintf(p, \" \");\n\t}\n\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_UNTRANSLATABLE_CHARACTER),\n\t\t\t errmsg(\"character with byte sequence %s in encoding \\\"%s\\\" has no equivalent in encoding \\\"%s\\\"\",\n\t\t\t\t\tbuf,\n\t\t\t\t\tpg_enc2name_tbl[src_encoding].name,\n\t\t\t\t\tpg_enc2name_tbl[dest_encoding].name)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "store_coded_char",
          "args": [
            "iso",
            "converted"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "store_coded_char",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/conv.c",
          "lines": "322-334",
          "snippet": "static inline unsigned char *\nstore_coded_char(unsigned char *dest, uint32 code)\n{\n\tif (code & 0xff000000)\n\t\t*dest++ = code >> 24;\n\tif (code & 0x00ff0000)\n\t\t*dest++ = code >> 16;\n\tif (code & 0x0000ff00)\n\t\t*dest++ = code >> 8;\n\tif (code & 0x000000ff)\n\t\t*dest++ = code;\n\treturn dest;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic inline unsigned char *\nstore_coded_char(unsigned char *dest, uint32 code)\n{\n\tif (code & 0xff000000)\n\t\t*dest++ = code >> 24;\n\tif (code & 0x00ff0000)\n\t\t*dest++ = code >> 16;\n\tif (code & 0x0000ff00)\n\t\t*dest++ = code >> 8;\n\tif (code & 0x000000ff)\n\t\t*dest++ = code;\n\treturn dest;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "iutf"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_mb_radix_conv",
          "args": [
            "map",
            "l",
            "b1",
            "b2",
            "b3",
            "b4"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mb_radix_conv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/conv.c",
          "lines": "342-449",
          "snippet": "static inline uint32\npg_mb_radix_conv(const pg_mb_radix_tree *rt,\n\t\t\t\t int l,\n\t\t\t\t unsigned char b1,\n\t\t\t\t unsigned char b2,\n\t\t\t\t unsigned char b3,\n\t\t\t\t unsigned char b4)\n{\n\tif (l == 4)\n\t{\n\t\t/* 4-byte code */\n\n\t\t/* check code validity */\n\t\tif (b1 < rt->b4_1_lower || b1 > rt->b4_1_upper ||\n\t\t\tb2 < rt->b4_2_lower || b2 > rt->b4_2_upper ||\n\t\t\tb3 < rt->b4_3_lower || b3 > rt->b4_3_upper ||\n\t\t\tb4 < rt->b4_4_lower || b4 > rt->b4_4_upper)\n\t\t\treturn 0;\n\n\t\t/* perform lookup */\n\t\tif (rt->chars32)\n\t\t{\n\t\t\tuint32\t\tidx = rt->b4root;\n\n\t\t\tidx = rt->chars32[b1 + idx - rt->b4_1_lower];\n\t\t\tidx = rt->chars32[b2 + idx - rt->b4_2_lower];\n\t\t\tidx = rt->chars32[b3 + idx - rt->b4_3_lower];\n\t\t\treturn rt->chars32[b4 + idx - rt->b4_4_lower];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tuint16\t\tidx = rt->b4root;\n\n\t\t\tidx = rt->chars16[b1 + idx - rt->b4_1_lower];\n\t\t\tidx = rt->chars16[b2 + idx - rt->b4_2_lower];\n\t\t\tidx = rt->chars16[b3 + idx - rt->b4_3_lower];\n\t\t\treturn rt->chars16[b4 + idx - rt->b4_4_lower];\n\t\t}\n\t}\n\telse if (l == 3)\n\t{\n\t\t/* 3-byte code */\n\n\t\t/* check code validity */\n\t\tif (b2 < rt->b3_1_lower || b2 > rt->b3_1_upper ||\n\t\t\tb3 < rt->b3_2_lower || b3 > rt->b3_2_upper ||\n\t\t\tb4 < rt->b3_3_lower || b4 > rt->b3_3_upper)\n\t\t\treturn 0;\n\n\t\t/* perform lookup */\n\t\tif (rt->chars32)\n\t\t{\n\t\t\tuint32\t\tidx = rt->b3root;\n\n\t\t\tidx = rt->chars32[b2 + idx - rt->b3_1_lower];\n\t\t\tidx = rt->chars32[b3 + idx - rt->b3_2_lower];\n\t\t\treturn rt->chars32[b4 + idx - rt->b3_3_lower];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tuint16\t\tidx = rt->b3root;\n\n\t\t\tidx = rt->chars16[b2 + idx - rt->b3_1_lower];\n\t\t\tidx = rt->chars16[b3 + idx - rt->b3_2_lower];\n\t\t\treturn rt->chars16[b4 + idx - rt->b3_3_lower];\n\t\t}\n\t}\n\telse if (l == 2)\n\t{\n\t\t/* 2-byte code */\n\n\t\t/* check code validity - first byte */\n\t\tif (b3 < rt->b2_1_lower || b3 > rt->b2_1_upper ||\n\t\t\tb4 < rt->b2_2_lower || b4 > rt->b2_2_upper)\n\t\t\treturn 0;\n\n\t\t/* perform lookup */\n\t\tif (rt->chars32)\n\t\t{\n\t\t\tuint32\t\tidx = rt->b2root;\n\n\t\t\tidx = rt->chars32[b3 + idx - rt->b2_1_lower];\n\t\t\treturn rt->chars32[b4 + idx - rt->b2_2_lower];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tuint16\t\tidx = rt->b2root;\n\n\t\t\tidx = rt->chars16[b3 + idx - rt->b2_1_lower];\n\t\t\treturn rt->chars16[b4 + idx - rt->b2_2_lower];\n\t\t}\n\t}\n\telse if (l == 1)\n\t{\n\t\t/* 1-byte code */\n\n\t\t/* check code validity - first byte */\n\t\tif (b4 < rt->b1_lower || b4 > rt->b1_upper)\n\t\t\treturn 0;\n\n\t\t/* perform lookup */\n\t\tif (rt->chars32)\n\t\t\treturn rt->chars32[b4 + rt->b1root - rt->b1_lower];\n\t\telse\n\t\t\treturn rt->chars16[b4 + rt->b1root - rt->b1_lower];\n\t}\n\treturn 0;\t\t\t\t\t/* shouldn't happen */\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic inline uint32\npg_mb_radix_conv(const pg_mb_radix_tree *rt,\n\t\t\t\t int l,\n\t\t\t\t unsigned char b1,\n\t\t\t\t unsigned char b2,\n\t\t\t\t unsigned char b3,\n\t\t\t\t unsigned char b4)\n{\n\tif (l == 4)\n\t{\n\t\t/* 4-byte code */\n\n\t\t/* check code validity */\n\t\tif (b1 < rt->b4_1_lower || b1 > rt->b4_1_upper ||\n\t\t\tb2 < rt->b4_2_lower || b2 > rt->b4_2_upper ||\n\t\t\tb3 < rt->b4_3_lower || b3 > rt->b4_3_upper ||\n\t\t\tb4 < rt->b4_4_lower || b4 > rt->b4_4_upper)\n\t\t\treturn 0;\n\n\t\t/* perform lookup */\n\t\tif (rt->chars32)\n\t\t{\n\t\t\tuint32\t\tidx = rt->b4root;\n\n\t\t\tidx = rt->chars32[b1 + idx - rt->b4_1_lower];\n\t\t\tidx = rt->chars32[b2 + idx - rt->b4_2_lower];\n\t\t\tidx = rt->chars32[b3 + idx - rt->b4_3_lower];\n\t\t\treturn rt->chars32[b4 + idx - rt->b4_4_lower];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tuint16\t\tidx = rt->b4root;\n\n\t\t\tidx = rt->chars16[b1 + idx - rt->b4_1_lower];\n\t\t\tidx = rt->chars16[b2 + idx - rt->b4_2_lower];\n\t\t\tidx = rt->chars16[b3 + idx - rt->b4_3_lower];\n\t\t\treturn rt->chars16[b4 + idx - rt->b4_4_lower];\n\t\t}\n\t}\n\telse if (l == 3)\n\t{\n\t\t/* 3-byte code */\n\n\t\t/* check code validity */\n\t\tif (b2 < rt->b3_1_lower || b2 > rt->b3_1_upper ||\n\t\t\tb3 < rt->b3_2_lower || b3 > rt->b3_2_upper ||\n\t\t\tb4 < rt->b3_3_lower || b4 > rt->b3_3_upper)\n\t\t\treturn 0;\n\n\t\t/* perform lookup */\n\t\tif (rt->chars32)\n\t\t{\n\t\t\tuint32\t\tidx = rt->b3root;\n\n\t\t\tidx = rt->chars32[b2 + idx - rt->b3_1_lower];\n\t\t\tidx = rt->chars32[b3 + idx - rt->b3_2_lower];\n\t\t\treturn rt->chars32[b4 + idx - rt->b3_3_lower];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tuint16\t\tidx = rt->b3root;\n\n\t\t\tidx = rt->chars16[b2 + idx - rt->b3_1_lower];\n\t\t\tidx = rt->chars16[b3 + idx - rt->b3_2_lower];\n\t\t\treturn rt->chars16[b4 + idx - rt->b3_3_lower];\n\t\t}\n\t}\n\telse if (l == 2)\n\t{\n\t\t/* 2-byte code */\n\n\t\t/* check code validity - first byte */\n\t\tif (b3 < rt->b2_1_lower || b3 > rt->b2_1_upper ||\n\t\t\tb4 < rt->b2_2_lower || b4 > rt->b2_2_upper)\n\t\t\treturn 0;\n\n\t\t/* perform lookup */\n\t\tif (rt->chars32)\n\t\t{\n\t\t\tuint32\t\tidx = rt->b2root;\n\n\t\t\tidx = rt->chars32[b3 + idx - rt->b2_1_lower];\n\t\t\treturn rt->chars32[b4 + idx - rt->b2_2_lower];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tuint16\t\tidx = rt->b2root;\n\n\t\t\tidx = rt->chars16[b3 + idx - rt->b2_1_lower];\n\t\t\treturn rt->chars16[b4 + idx - rt->b2_2_lower];\n\t\t}\n\t}\n\telse if (l == 1)\n\t{\n\t\t/* 1-byte code */\n\n\t\t/* check code validity - first byte */\n\t\tif (b4 < rt->b1_lower || b4 > rt->b1_upper)\n\t\t\treturn 0;\n\n\t\t/* perform lookup */\n\t\tif (rt->chars32)\n\t\t\treturn rt->chars32[b4 + rt->b1root - rt->b1_lower];\n\t\telse\n\t\t\treturn rt->chars16[b4 + rt->b1root - rt->b1_lower];\n\t}\n\treturn 0;\t\t\t\t\t/* shouldn't happen */\n}"
        }
      },
      {
        "call_info": {
          "callee": "bsearch",
          "args": [
            "cutf",
            "cmap",
            "cmapsize",
            "sizeof(pg_utf_to_local_combined)",
            "compare3"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "rbound_bsearch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_selfuncs.c",
          "lines": "617-637",
          "snippet": "static int\nrbound_bsearch(TypeCacheEntry *typcache, RangeBound *value, RangeBound *hist,\n\t\t\t   int hist_length, bool equal)\n{\n\tint\t\t\tlower = -1,\n\t\t\t\tupper = hist_length - 1,\n\t\t\t\tcmp,\n\t\t\t\tmiddle;\n\n\twhile (lower < upper)\n\t{\n\t\tmiddle = (lower + upper + 1) / 2;\n\t\tcmp = range_cmp_bounds(typcache, &hist[middle], value);\n\n\t\tif (cmp < 0 || (equal && cmp == 0))\n\t\t\tlower = middle;\n\t\telse\n\t\t\tupper = middle - 1;\n\t}\n\treturn lower;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double calc_hist_selectivity_scalar(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t RangeBound *constbound,\n\t\t\t\t\t\t\t RangeBound *hist, int hist_nvalues,\n\t\t\t\t\t\t\t bool equal);",
            "static int rbound_bsearch(TypeCacheEntry *typcache, RangeBound *value,\n\t\t\t   RangeBound *hist, int hist_length, bool equal);",
            "static int length_hist_bsearch(Datum *length_hist_values,\n\t\t\t\t\tint length_hist_nvalues, double value, bool equal);",
            "static double calc_length_hist_frac(Datum *length_hist_values,\n\t\t\t\t\t  int length_hist_nvalues, double length1, double length2, bool equal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic double calc_hist_selectivity_scalar(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t RangeBound *constbound,\n\t\t\t\t\t\t\t RangeBound *hist, int hist_nvalues,\n\t\t\t\t\t\t\t bool equal);\nstatic int rbound_bsearch(TypeCacheEntry *typcache, RangeBound *value,\n\t\t\t   RangeBound *hist, int hist_length, bool equal);\nstatic int length_hist_bsearch(Datum *length_hist_values,\n\t\t\t\t\tint length_hist_nvalues, double value, bool equal);\nstatic double calc_length_hist_frac(Datum *length_hist_values,\n\t\t\t\t\t  int length_hist_nvalues, double length1, double length2, bool equal);\n\nstatic int\nrbound_bsearch(TypeCacheEntry *typcache, RangeBound *value, RangeBound *hist,\n\t\t\t   int hist_length, bool equal)\n{\n\tint\t\t\tlower = -1,\n\t\t\t\tupper = hist_length - 1,\n\t\t\t\tcmp,\n\t\t\t\tmiddle;\n\n\twhile (lower < upper)\n\t{\n\t\tmiddle = (lower + upper + 1) / 2;\n\t\tcmp = range_cmp_bounds(typcache, &hist[middle], value);\n\n\t\tif (cmp < 0 || (equal && cmp == 0))\n\t\t\tlower = middle;\n\t\telse\n\t\t\tupper = middle - 1;\n\t}\n\treturn lower;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unsupported character length %d\"",
            "l"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_utf8_islegal",
          "args": [
            "utf",
            "l"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "pg_utf8_islegal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "1457-1512",
          "snippet": "bool\npg_utf8_islegal(const unsigned char *source, int length)\n{\n\tunsigned char a;\n\n\tswitch (length)\n\t{\n\t\tdefault:\n\t\t\t/* reject lengths 5 and 6 for now */\n\t\t\treturn false;\n\t\tcase 4:\n\t\t\ta = source[3];\n\t\t\tif (a < 0x80 || a > 0xBF)\n\t\t\t\treturn false;\n\t\t\t/* FALL THRU */\n\t\tcase 3:\n\t\t\ta = source[2];\n\t\t\tif (a < 0x80 || a > 0xBF)\n\t\t\t\treturn false;\n\t\t\t/* FALL THRU */\n\t\tcase 2:\n\t\t\ta = source[1];\n\t\t\tswitch (*source)\n\t\t\t{\n\t\t\t\tcase 0xE0:\n\t\t\t\t\tif (a < 0xA0 || a > 0xBF)\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xED:\n\t\t\t\t\tif (a < 0x80 || a > 0x9F)\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xF0:\n\t\t\t\t\tif (a < 0x90 || a > 0xBF)\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xF4:\n\t\t\t\t\tif (a < 0x80 || a > 0x8F)\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (a < 0x80 || a > 0xBF)\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* FALL THRU */\n\t\tcase 1:\n\t\t\ta = *source;\n\t\t\tif (a >= 0x80 && a < 0xC2)\n\t\t\t\treturn false;\n\t\t\tif (a > 0xF4)\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nbool\npg_utf8_islegal(const unsigned char *source, int length)\n{\n\tunsigned char a;\n\n\tswitch (length)\n\t{\n\t\tdefault:\n\t\t\t/* reject lengths 5 and 6 for now */\n\t\t\treturn false;\n\t\tcase 4:\n\t\t\ta = source[3];\n\t\t\tif (a < 0x80 || a > 0xBF)\n\t\t\t\treturn false;\n\t\t\t/* FALL THRU */\n\t\tcase 3:\n\t\t\ta = source[2];\n\t\t\tif (a < 0x80 || a > 0xBF)\n\t\t\t\treturn false;\n\t\t\t/* FALL THRU */\n\t\tcase 2:\n\t\t\ta = source[1];\n\t\t\tswitch (*source)\n\t\t\t{\n\t\t\t\tcase 0xE0:\n\t\t\t\t\tif (a < 0xA0 || a > 0xBF)\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xED:\n\t\t\t\t\tif (a < 0x80 || a > 0x9F)\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xF0:\n\t\t\t\t\tif (a < 0x90 || a > 0xBF)\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xF4:\n\t\t\t\t\tif (a < 0x80 || a > 0x8F)\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (a < 0x80 || a > 0xBF)\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* FALL THRU */\n\t\tcase 1:\n\t\t\ta = *source;\n\t\t\tif (a >= 0x80 && a < 0xC2)\n\t\t\t\treturn false;\n\t\t\tif (a > 0xF4)\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_utf_mblen",
          "args": [
            "utf"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "pg_utf_mblen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "540-562",
          "snippet": "int\npg_utf_mblen(const unsigned char *s)\n{\n\tint\t\t\tlen;\n\n\tif ((*s & 0x80) == 0)\n\t\tlen = 1;\n\telse if ((*s & 0xe0) == 0xc0)\n\t\tlen = 2;\n\telse if ((*s & 0xf0) == 0xe0)\n\t\tlen = 3;\n\telse if ((*s & 0xf8) == 0xf0)\n\t\tlen = 4;\n#ifdef NOT_USED\n\telse if ((*s & 0xfc) == 0xf8)\n\t\tlen = 5;\n\telse if ((*s & 0xfe) == 0xfc)\n\t\tlen = 6;\n#endif\n\telse\n\t\tlen = 1;\n\treturn len;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nint\npg_utf_mblen(const unsigned char *s)\n{\n\tint\t\t\tlen;\n\n\tif ((*s & 0x80) == 0)\n\t\tlen = 1;\n\telse if ((*s & 0xe0) == 0xc0)\n\t\tlen = 2;\n\telse if ((*s & 0xf0) == 0xe0)\n\t\tlen = 3;\n\telse if ((*s & 0xf8) == 0xf0)\n\t\tlen = 4;\n#ifdef NOT_USED\n\telse if ((*s & 0xfc) == 0xf8)\n\t\tlen = 5;\n\telse if ((*s & 0xfe) == 0xfc)\n\t\tlen = 6;\n#endif\n\telse\n\t\tlen = 1;\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid encoding number: %d\", encoding))"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid encoding number: %d\"",
            "encoding"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_VALID_ENCODING",
          "args": [
            "encoding"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nvoid\nUtfToLocal(const unsigned char *utf, int len,\n\t\t   unsigned char *iso,\n\t\t   const pg_mb_radix_tree *map,\n\t\t   const pg_utf_to_local_combined *cmap, int cmapsize,\n\t\t   utf_local_conversion_func conv_func,\n\t\t   int encoding)\n{\n\tuint32\t\tiutf;\n\tint\t\t\tl;\n\tconst pg_utf_to_local_combined *cp;\n\n\tif (!PG_VALID_ENCODING(encoding))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid encoding number: %d\", encoding)));\n\n\tfor (; len > 0; len -= l)\n\t{\n\t\tunsigned char b1 = 0;\n\t\tunsigned char b2 = 0;\n\t\tunsigned char b3 = 0;\n\t\tunsigned char b4 = 0;\n\n\t\t/* \"break\" cases all represent errors */\n\t\tif (*utf == '\\0')\n\t\t\tbreak;\n\n\t\tl = pg_utf_mblen(utf);\n\t\tif (len < l)\n\t\t\tbreak;\n\n\t\tif (!pg_utf8_islegal(utf, l))\n\t\t\tbreak;\n\n\t\tif (l == 1)\n\t\t{\n\t\t\t/* ASCII case is easy, assume it's one-to-one conversion */\n\t\t\t*iso++ = *utf++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* collect coded char of length l */\n\t\tif (l == 2)\n\t\t{\n\t\t\tb3 = *utf++;\n\t\t\tb4 = *utf++;\n\t\t}\n\t\telse if (l == 3)\n\t\t{\n\t\t\tb2 = *utf++;\n\t\t\tb3 = *utf++;\n\t\t\tb4 = *utf++;\n\t\t}\n\t\telse if (l == 4)\n\t\t{\n\t\t\tb1 = *utf++;\n\t\t\tb2 = *utf++;\n\t\t\tb3 = *utf++;\n\t\t\tb4 = *utf++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\telog(ERROR, \"unsupported character length %d\", l);\n\t\t\tiutf = 0;\t\t\t/* keep compiler quiet */\n\t\t}\n\t\tiutf = (b1 << 24 | b2 << 16 | b3 << 8 | b4);\n\n\t\t/* First, try with combined map if possible */\n\t\tif (cmap && len > l)\n\t\t{\n\t\t\tconst unsigned char *utf_save = utf;\n\t\t\tint\t\t\tlen_save = len;\n\t\t\tint\t\t\tl_save = l;\n\n\t\t\t/* collect next character, same as above */\n\t\t\tlen -= l;\n\n\t\t\tl = pg_utf_mblen(utf);\n\t\t\tif (len < l)\n\t\t\t\tbreak;\n\n\t\t\tif (!pg_utf8_islegal(utf, l))\n\t\t\t\tbreak;\n\n\t\t\t/* We assume ASCII character cannot be in combined map */\n\t\t\tif (l > 1)\n\t\t\t{\n\t\t\t\tuint32\t\tiutf2;\n\t\t\t\tuint32\t\tcutf[2];\n\n\t\t\t\tif (l == 2)\n\t\t\t\t{\n\t\t\t\t\tiutf2 = *utf++ << 8;\n\t\t\t\t\tiutf2 |= *utf++;\n\t\t\t\t}\n\t\t\t\telse if (l == 3)\n\t\t\t\t{\n\t\t\t\t\tiutf2 = *utf++ << 16;\n\t\t\t\t\tiutf2 |= *utf++ << 8;\n\t\t\t\t\tiutf2 |= *utf++;\n\t\t\t\t}\n\t\t\t\telse if (l == 4)\n\t\t\t\t{\n\t\t\t\t\tiutf2 = *utf++ << 24;\n\t\t\t\t\tiutf2 |= *utf++ << 16;\n\t\t\t\t\tiutf2 |= *utf++ << 8;\n\t\t\t\t\tiutf2 |= *utf++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\telog(ERROR, \"unsupported character length %d\", l);\n\t\t\t\t\tiutf2 = 0;\t/* keep compiler quiet */\n\t\t\t\t}\n\n\t\t\t\tcutf[0] = iutf;\n\t\t\t\tcutf[1] = iutf2;\n\n\t\t\t\tcp = bsearch(cutf, cmap, cmapsize,\n\t\t\t\t\t\t\t sizeof(pg_utf_to_local_combined), compare3);\n\n\t\t\t\tif (cp)\n\t\t\t\t{\n\t\t\t\t\tiso = store_coded_char(iso, cp->code);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* fail, so back up to reprocess second character next time */\n\t\t\tutf = utf_save;\n\t\t\tlen = len_save;\n\t\t\tl = l_save;\n\t\t}\n\n\t\t/* Now check ordinary map */\n\t\tif (map)\n\t\t{\n\t\t\tuint32\t\tconverted = pg_mb_radix_conv(map, l, b1, b2, b3, b4);\n\n\t\t\tif (converted)\n\t\t\t{\n\t\t\t\tiso = store_coded_char(iso, converted);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/* if there's a conversion function, try that */\n\t\tif (conv_func)\n\t\t{\n\t\t\tuint32\t\tconverted = (*conv_func) (iutf);\n\n\t\t\tif (converted)\n\t\t\t{\n\t\t\t\tiso = store_coded_char(iso, converted);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/* failed to translate this character */\n\t\treport_untranslatable_char(PG_UTF8, encoding,\n\t\t\t\t\t\t\t\t   (const char *) (utf - l), len);\n\t}\n\n\t/* if we broke out of loop early, must be invalid input */\n\tif (len > 0)\n\t\treport_invalid_encoding(PG_UTF8, (const char *) utf, len);\n\n\t*iso = '\\0';\n}"
  },
  {
    "function_name": "pg_mb_radix_conv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/conv.c",
    "lines": "342-449",
    "snippet": "static inline uint32\npg_mb_radix_conv(const pg_mb_radix_tree *rt,\n\t\t\t\t int l,\n\t\t\t\t unsigned char b1,\n\t\t\t\t unsigned char b2,\n\t\t\t\t unsigned char b3,\n\t\t\t\t unsigned char b4)\n{\n\tif (l == 4)\n\t{\n\t\t/* 4-byte code */\n\n\t\t/* check code validity */\n\t\tif (b1 < rt->b4_1_lower || b1 > rt->b4_1_upper ||\n\t\t\tb2 < rt->b4_2_lower || b2 > rt->b4_2_upper ||\n\t\t\tb3 < rt->b4_3_lower || b3 > rt->b4_3_upper ||\n\t\t\tb4 < rt->b4_4_lower || b4 > rt->b4_4_upper)\n\t\t\treturn 0;\n\n\t\t/* perform lookup */\n\t\tif (rt->chars32)\n\t\t{\n\t\t\tuint32\t\tidx = rt->b4root;\n\n\t\t\tidx = rt->chars32[b1 + idx - rt->b4_1_lower];\n\t\t\tidx = rt->chars32[b2 + idx - rt->b4_2_lower];\n\t\t\tidx = rt->chars32[b3 + idx - rt->b4_3_lower];\n\t\t\treturn rt->chars32[b4 + idx - rt->b4_4_lower];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tuint16\t\tidx = rt->b4root;\n\n\t\t\tidx = rt->chars16[b1 + idx - rt->b4_1_lower];\n\t\t\tidx = rt->chars16[b2 + idx - rt->b4_2_lower];\n\t\t\tidx = rt->chars16[b3 + idx - rt->b4_3_lower];\n\t\t\treturn rt->chars16[b4 + idx - rt->b4_4_lower];\n\t\t}\n\t}\n\telse if (l == 3)\n\t{\n\t\t/* 3-byte code */\n\n\t\t/* check code validity */\n\t\tif (b2 < rt->b3_1_lower || b2 > rt->b3_1_upper ||\n\t\t\tb3 < rt->b3_2_lower || b3 > rt->b3_2_upper ||\n\t\t\tb4 < rt->b3_3_lower || b4 > rt->b3_3_upper)\n\t\t\treturn 0;\n\n\t\t/* perform lookup */\n\t\tif (rt->chars32)\n\t\t{\n\t\t\tuint32\t\tidx = rt->b3root;\n\n\t\t\tidx = rt->chars32[b2 + idx - rt->b3_1_lower];\n\t\t\tidx = rt->chars32[b3 + idx - rt->b3_2_lower];\n\t\t\treturn rt->chars32[b4 + idx - rt->b3_3_lower];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tuint16\t\tidx = rt->b3root;\n\n\t\t\tidx = rt->chars16[b2 + idx - rt->b3_1_lower];\n\t\t\tidx = rt->chars16[b3 + idx - rt->b3_2_lower];\n\t\t\treturn rt->chars16[b4 + idx - rt->b3_3_lower];\n\t\t}\n\t}\n\telse if (l == 2)\n\t{\n\t\t/* 2-byte code */\n\n\t\t/* check code validity - first byte */\n\t\tif (b3 < rt->b2_1_lower || b3 > rt->b2_1_upper ||\n\t\t\tb4 < rt->b2_2_lower || b4 > rt->b2_2_upper)\n\t\t\treturn 0;\n\n\t\t/* perform lookup */\n\t\tif (rt->chars32)\n\t\t{\n\t\t\tuint32\t\tidx = rt->b2root;\n\n\t\t\tidx = rt->chars32[b3 + idx - rt->b2_1_lower];\n\t\t\treturn rt->chars32[b4 + idx - rt->b2_2_lower];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tuint16\t\tidx = rt->b2root;\n\n\t\t\tidx = rt->chars16[b3 + idx - rt->b2_1_lower];\n\t\t\treturn rt->chars16[b4 + idx - rt->b2_2_lower];\n\t\t}\n\t}\n\telse if (l == 1)\n\t{\n\t\t/* 1-byte code */\n\n\t\t/* check code validity - first byte */\n\t\tif (b4 < rt->b1_lower || b4 > rt->b1_upper)\n\t\t\treturn 0;\n\n\t\t/* perform lookup */\n\t\tif (rt->chars32)\n\t\t\treturn rt->chars32[b4 + rt->b1root - rt->b1_lower];\n\t\telse\n\t\t\treturn rt->chars16[b4 + rt->b1root - rt->b1_lower];\n\t}\n\treturn 0;\t\t\t\t\t/* shouldn't happen */\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic inline uint32\npg_mb_radix_conv(const pg_mb_radix_tree *rt,\n\t\t\t\t int l,\n\t\t\t\t unsigned char b1,\n\t\t\t\t unsigned char b2,\n\t\t\t\t unsigned char b3,\n\t\t\t\t unsigned char b4)\n{\n\tif (l == 4)\n\t{\n\t\t/* 4-byte code */\n\n\t\t/* check code validity */\n\t\tif (b1 < rt->b4_1_lower || b1 > rt->b4_1_upper ||\n\t\t\tb2 < rt->b4_2_lower || b2 > rt->b4_2_upper ||\n\t\t\tb3 < rt->b4_3_lower || b3 > rt->b4_3_upper ||\n\t\t\tb4 < rt->b4_4_lower || b4 > rt->b4_4_upper)\n\t\t\treturn 0;\n\n\t\t/* perform lookup */\n\t\tif (rt->chars32)\n\t\t{\n\t\t\tuint32\t\tidx = rt->b4root;\n\n\t\t\tidx = rt->chars32[b1 + idx - rt->b4_1_lower];\n\t\t\tidx = rt->chars32[b2 + idx - rt->b4_2_lower];\n\t\t\tidx = rt->chars32[b3 + idx - rt->b4_3_lower];\n\t\t\treturn rt->chars32[b4 + idx - rt->b4_4_lower];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tuint16\t\tidx = rt->b4root;\n\n\t\t\tidx = rt->chars16[b1 + idx - rt->b4_1_lower];\n\t\t\tidx = rt->chars16[b2 + idx - rt->b4_2_lower];\n\t\t\tidx = rt->chars16[b3 + idx - rt->b4_3_lower];\n\t\t\treturn rt->chars16[b4 + idx - rt->b4_4_lower];\n\t\t}\n\t}\n\telse if (l == 3)\n\t{\n\t\t/* 3-byte code */\n\n\t\t/* check code validity */\n\t\tif (b2 < rt->b3_1_lower || b2 > rt->b3_1_upper ||\n\t\t\tb3 < rt->b3_2_lower || b3 > rt->b3_2_upper ||\n\t\t\tb4 < rt->b3_3_lower || b4 > rt->b3_3_upper)\n\t\t\treturn 0;\n\n\t\t/* perform lookup */\n\t\tif (rt->chars32)\n\t\t{\n\t\t\tuint32\t\tidx = rt->b3root;\n\n\t\t\tidx = rt->chars32[b2 + idx - rt->b3_1_lower];\n\t\t\tidx = rt->chars32[b3 + idx - rt->b3_2_lower];\n\t\t\treturn rt->chars32[b4 + idx - rt->b3_3_lower];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tuint16\t\tidx = rt->b3root;\n\n\t\t\tidx = rt->chars16[b2 + idx - rt->b3_1_lower];\n\t\t\tidx = rt->chars16[b3 + idx - rt->b3_2_lower];\n\t\t\treturn rt->chars16[b4 + idx - rt->b3_3_lower];\n\t\t}\n\t}\n\telse if (l == 2)\n\t{\n\t\t/* 2-byte code */\n\n\t\t/* check code validity - first byte */\n\t\tif (b3 < rt->b2_1_lower || b3 > rt->b2_1_upper ||\n\t\t\tb4 < rt->b2_2_lower || b4 > rt->b2_2_upper)\n\t\t\treturn 0;\n\n\t\t/* perform lookup */\n\t\tif (rt->chars32)\n\t\t{\n\t\t\tuint32\t\tidx = rt->b2root;\n\n\t\t\tidx = rt->chars32[b3 + idx - rt->b2_1_lower];\n\t\t\treturn rt->chars32[b4 + idx - rt->b2_2_lower];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tuint16\t\tidx = rt->b2root;\n\n\t\t\tidx = rt->chars16[b3 + idx - rt->b2_1_lower];\n\t\t\treturn rt->chars16[b4 + idx - rt->b2_2_lower];\n\t\t}\n\t}\n\telse if (l == 1)\n\t{\n\t\t/* 1-byte code */\n\n\t\t/* check code validity - first byte */\n\t\tif (b4 < rt->b1_lower || b4 > rt->b1_upper)\n\t\t\treturn 0;\n\n\t\t/* perform lookup */\n\t\tif (rt->chars32)\n\t\t\treturn rt->chars32[b4 + rt->b1root - rt->b1_lower];\n\t\telse\n\t\t\treturn rt->chars16[b4 + rt->b1root - rt->b1_lower];\n\t}\n\treturn 0;\t\t\t\t\t/* shouldn't happen */\n}"
  },
  {
    "function_name": "store_coded_char",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/conv.c",
    "lines": "322-334",
    "snippet": "static inline unsigned char *\nstore_coded_char(unsigned char *dest, uint32 code)\n{\n\tif (code & 0xff000000)\n\t\t*dest++ = code >> 24;\n\tif (code & 0x00ff0000)\n\t\t*dest++ = code >> 16;\n\tif (code & 0x0000ff00)\n\t\t*dest++ = code >> 8;\n\tif (code & 0x000000ff)\n\t\t*dest++ = code;\n\treturn dest;\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic inline unsigned char *\nstore_coded_char(unsigned char *dest, uint32 code)\n{\n\tif (code & 0xff000000)\n\t\t*dest++ = code >> 24;\n\tif (code & 0x00ff0000)\n\t\t*dest++ = code >> 16;\n\tif (code & 0x0000ff00)\n\t\t*dest++ = code >> 8;\n\tif (code & 0x000000ff)\n\t\t*dest++ = code;\n\treturn dest;\n}"
  },
  {
    "function_name": "compare4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/conv.c",
    "lines": "308-317",
    "snippet": "static int\ncompare4(const void *p1, const void *p2)\n{\n\tuint32\t\tv1,\n\t\t\t\tv2;\n\n\tv1 = *(const uint32 *) p1;\n\tv2 = ((const pg_local_to_utf_combined *) p2)->code;\n\treturn (v1 > v2) ? 1 : ((v1 == v2) ? 0 : -1);\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic int\ncompare4(const void *p1, const void *p2)\n{\n\tuint32\t\tv1,\n\t\t\t\tv2;\n\n\tv1 = *(const uint32 *) p1;\n\tv2 = ((const pg_local_to_utf_combined *) p2)->code;\n\treturn (v1 > v2) ? 1 : ((v1 == v2) ? 0 : -1);\n}"
  },
  {
    "function_name": "compare3",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/conv.c",
    "lines": "289-302",
    "snippet": "static int\ncompare3(const void *p1, const void *p2)\n{\n\tuint32\t\ts1,\n\t\t\t\ts2,\n\t\t\t\td1,\n\t\t\t\td2;\n\n\ts1 = *(const uint32 *) p1;\n\ts2 = *((const uint32 *) p1 + 1);\n\td1 = ((const pg_utf_to_local_combined *) p2)->utf1;\n\td2 = ((const pg_utf_to_local_combined *) p2)->utf2;\n\treturn (s1 > d1 || (s1 == d1 && s2 > d2)) ? 1 : ((s1 == d1 && s2 == d2) ? 0 : -1);\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic int\ncompare3(const void *p1, const void *p2)\n{\n\tuint32\t\ts1,\n\t\t\t\ts2,\n\t\t\t\td1,\n\t\t\t\td2;\n\n\ts1 = *(const uint32 *) p1;\n\ts2 = *((const uint32 *) p1 + 1);\n\td1 = ((const pg_utf_to_local_combined *) p2)->utf1;\n\td2 = ((const pg_utf_to_local_combined *) p2)->utf2;\n\treturn (s1 > d1 || (s1 == d1 && s2 > d2)) ? 1 : ((s1 == d1 && s2 == d2) ? 0 : -1);\n}"
  },
  {
    "function_name": "mic2latin_with_table",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/conv.c",
    "lines": "240-283",
    "snippet": "void\nmic2latin_with_table(const unsigned char *mic,\n\t\t\t\t\t unsigned char *p,\n\t\t\t\t\t int len,\n\t\t\t\t\t int lc,\n\t\t\t\t\t int encoding,\n\t\t\t\t\t const unsigned char *tab)\n{\n\tunsigned char c1,\n\t\t\t\tc2;\n\n\twhile (len > 0)\n\t{\n\t\tc1 = *mic;\n\t\tif (c1 == 0)\n\t\t\treport_invalid_encoding(PG_MULE_INTERNAL, (const char *) mic, len);\n\t\tif (!IS_HIGHBIT_SET(c1))\n\t\t{\n\t\t\t/* easy for ASCII */\n\t\t\t*p++ = c1;\n\t\t\tmic++;\n\t\t\tlen--;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint\t\t\tl = pg_mic_mblen(mic);\n\n\t\t\tif (len < l)\n\t\t\t\treport_invalid_encoding(PG_MULE_INTERNAL, (const char *) mic,\n\t\t\t\t\t\t\t\t\t\tlen);\n\t\t\tif (l != 2 || c1 != lc || !IS_HIGHBIT_SET(mic[1]) ||\n\t\t\t\t(c2 = tab[mic[1] - HIGHBIT]) == 0)\n\t\t\t{\n\t\t\t\treport_untranslatable_char(PG_MULE_INTERNAL, encoding,\n\t\t\t\t\t\t\t\t\t\t   (const char *) mic, len);\n\t\t\t\tbreak;\t\t\t/* keep compiler quiet */\n\t\t\t}\n\t\t\t*p++ = c2;\n\t\t\tmic += 2;\n\t\t\tlen -= 2;\n\t\t}\n\t}\n\t*p = '\\0';\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "report_untranslatable_char",
          "args": [
            "PG_MULE_INTERNAL",
            "encoding",
            "(const char *) mic",
            "len"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "report_untranslatable_char",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "2026-2052",
          "snippet": "void\nreport_untranslatable_char(int src_encoding, int dest_encoding,\n\t\t\t\t\t\t   const char *mbstr, int len)\n{\n\tint\t\t\tl = pg_encoding_mblen(src_encoding, mbstr);\n\tchar\t\tbuf[8 * 5 + 1];\n\tchar\t   *p = buf;\n\tint\t\t\tj,\n\t\t\t\tjlimit;\n\n\tjlimit = Min(l, len);\n\tjlimit = Min(jlimit, 8);\t/* prevent buffer overrun */\n\n\tfor (j = 0; j < jlimit; j++)\n\t{\n\t\tp += sprintf(p, \"0x%02x\", (unsigned char) mbstr[j]);\n\t\tif (j < jlimit - 1)\n\t\t\tp += sprintf(p, \" \");\n\t}\n\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_UNTRANSLATABLE_CHARACTER),\n\t\t\t errmsg(\"character with byte sequence %s in encoding \\\"%s\\\" has no equivalent in encoding \\\"%s\\\"\",\n\t\t\t\t\tbuf,\n\t\t\t\t\tpg_enc2name_tbl[src_encoding].name,\n\t\t\t\t\tpg_enc2name_tbl[dest_encoding].name)));\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nvoid\nreport_untranslatable_char(int src_encoding, int dest_encoding,\n\t\t\t\t\t\t   const char *mbstr, int len)\n{\n\tint\t\t\tl = pg_encoding_mblen(src_encoding, mbstr);\n\tchar\t\tbuf[8 * 5 + 1];\n\tchar\t   *p = buf;\n\tint\t\t\tj,\n\t\t\t\tjlimit;\n\n\tjlimit = Min(l, len);\n\tjlimit = Min(jlimit, 8);\t/* prevent buffer overrun */\n\n\tfor (j = 0; j < jlimit; j++)\n\t{\n\t\tp += sprintf(p, \"0x%02x\", (unsigned char) mbstr[j]);\n\t\tif (j < jlimit - 1)\n\t\t\tp += sprintf(p, \" \");\n\t}\n\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_UNTRANSLATABLE_CHARACTER),\n\t\t\t errmsg(\"character with byte sequence %s in encoding \\\"%s\\\" has no equivalent in encoding \\\"%s\\\"\",\n\t\t\t\t\tbuf,\n\t\t\t\t\tpg_enc2name_tbl[src_encoding].name,\n\t\t\t\t\tpg_enc2name_tbl[dest_encoding].name)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_HIGHBIT_SET",
          "args": [
            "mic[1]"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "report_invalid_encoding",
          "args": [
            "PG_MULE_INTERNAL",
            "(const char *) mic",
            "len"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "report_invalid_encoding",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "1994-2018",
          "snippet": "void\nreport_invalid_encoding(int encoding, const char *mbstr, int len)\n{\n\tint\t\t\tl = pg_encoding_mblen(encoding, mbstr);\n\tchar\t\tbuf[8 * 5 + 1];\n\tchar\t   *p = buf;\n\tint\t\t\tj,\n\t\t\t\tjlimit;\n\n\tjlimit = Min(l, len);\n\tjlimit = Min(jlimit, 8);\t/* prevent buffer overrun */\n\n\tfor (j = 0; j < jlimit; j++)\n\t{\n\t\tp += sprintf(p, \"0x%02x\", (unsigned char) mbstr[j]);\n\t\tif (j < jlimit - 1)\n\t\t\tp += sprintf(p, \" \");\n\t}\n\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_CHARACTER_NOT_IN_REPERTOIRE),\n\t\t\t errmsg(\"invalid byte sequence for encoding \\\"%s\\\": %s\",\n\t\t\t\t\tpg_enc2name_tbl[encoding].name,\n\t\t\t\t\tbuf)));\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nvoid\nreport_invalid_encoding(int encoding, const char *mbstr, int len)\n{\n\tint\t\t\tl = pg_encoding_mblen(encoding, mbstr);\n\tchar\t\tbuf[8 * 5 + 1];\n\tchar\t   *p = buf;\n\tint\t\t\tj,\n\t\t\t\tjlimit;\n\n\tjlimit = Min(l, len);\n\tjlimit = Min(jlimit, 8);\t/* prevent buffer overrun */\n\n\tfor (j = 0; j < jlimit; j++)\n\t{\n\t\tp += sprintf(p, \"0x%02x\", (unsigned char) mbstr[j]);\n\t\tif (j < jlimit - 1)\n\t\t\tp += sprintf(p, \" \");\n\t}\n\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_CHARACTER_NOT_IN_REPERTOIRE),\n\t\t\t errmsg(\"invalid byte sequence for encoding \\\"%s\\\": %s\",\n\t\t\t\t\tpg_enc2name_tbl[encoding].name,\n\t\t\t\t\tbuf)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_mic_mblen",
          "args": [
            "mic"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mic_mblen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "1775-1779",
          "snippet": "int\npg_mic_mblen(const unsigned char *mbstr)\n{\n\treturn pg_mule_mblen(mbstr);\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nint\npg_mic_mblen(const unsigned char *mbstr)\n{\n\treturn pg_mule_mblen(mbstr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_HIGHBIT_SET",
          "args": [
            "c1"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nvoid\nmic2latin_with_table(const unsigned char *mic,\n\t\t\t\t\t unsigned char *p,\n\t\t\t\t\t int len,\n\t\t\t\t\t int lc,\n\t\t\t\t\t int encoding,\n\t\t\t\t\t const unsigned char *tab)\n{\n\tunsigned char c1,\n\t\t\t\tc2;\n\n\twhile (len > 0)\n\t{\n\t\tc1 = *mic;\n\t\tif (c1 == 0)\n\t\t\treport_invalid_encoding(PG_MULE_INTERNAL, (const char *) mic, len);\n\t\tif (!IS_HIGHBIT_SET(c1))\n\t\t{\n\t\t\t/* easy for ASCII */\n\t\t\t*p++ = c1;\n\t\t\tmic++;\n\t\t\tlen--;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint\t\t\tl = pg_mic_mblen(mic);\n\n\t\t\tif (len < l)\n\t\t\t\treport_invalid_encoding(PG_MULE_INTERNAL, (const char *) mic,\n\t\t\t\t\t\t\t\t\t\tlen);\n\t\t\tif (l != 2 || c1 != lc || !IS_HIGHBIT_SET(mic[1]) ||\n\t\t\t\t(c2 = tab[mic[1] - HIGHBIT]) == 0)\n\t\t\t{\n\t\t\t\treport_untranslatable_char(PG_MULE_INTERNAL, encoding,\n\t\t\t\t\t\t\t\t\t\t   (const char *) mic, len);\n\t\t\t\tbreak;\t\t\t/* keep compiler quiet */\n\t\t\t}\n\t\t\t*p++ = c2;\n\t\t\tmic += 2;\n\t\t\tlen -= 2;\n\t\t}\n\t}\n\t*p = '\\0';\n}"
  },
  {
    "function_name": "latin2mic_with_table",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/conv.c",
    "lines": "192-226",
    "snippet": "void\nlatin2mic_with_table(const unsigned char *l,\n\t\t\t\t\t unsigned char *p,\n\t\t\t\t\t int len,\n\t\t\t\t\t int lc,\n\t\t\t\t\t int encoding,\n\t\t\t\t\t const unsigned char *tab)\n{\n\tunsigned char c1,\n\t\t\t\tc2;\n\n\twhile (len > 0)\n\t{\n\t\tc1 = *l;\n\t\tif (c1 == 0)\n\t\t\treport_invalid_encoding(encoding, (const char *) l, len);\n\t\tif (!IS_HIGHBIT_SET(c1))\n\t\t\t*p++ = c1;\n\t\telse\n\t\t{\n\t\t\tc2 = tab[c1 - HIGHBIT];\n\t\t\tif (c2)\n\t\t\t{\n\t\t\t\t*p++ = lc;\n\t\t\t\t*p++ = c2;\n\t\t\t}\n\t\t\telse\n\t\t\t\treport_untranslatable_char(encoding, PG_MULE_INTERNAL,\n\t\t\t\t\t\t\t\t\t\t   (const char *) l, len);\n\t\t}\n\t\tl++;\n\t\tlen--;\n\t}\n\t*p = '\\0';\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "report_untranslatable_char",
          "args": [
            "encoding",
            "PG_MULE_INTERNAL",
            "(const char *) l",
            "len"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "report_untranslatable_char",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "2026-2052",
          "snippet": "void\nreport_untranslatable_char(int src_encoding, int dest_encoding,\n\t\t\t\t\t\t   const char *mbstr, int len)\n{\n\tint\t\t\tl = pg_encoding_mblen(src_encoding, mbstr);\n\tchar\t\tbuf[8 * 5 + 1];\n\tchar\t   *p = buf;\n\tint\t\t\tj,\n\t\t\t\tjlimit;\n\n\tjlimit = Min(l, len);\n\tjlimit = Min(jlimit, 8);\t/* prevent buffer overrun */\n\n\tfor (j = 0; j < jlimit; j++)\n\t{\n\t\tp += sprintf(p, \"0x%02x\", (unsigned char) mbstr[j]);\n\t\tif (j < jlimit - 1)\n\t\t\tp += sprintf(p, \" \");\n\t}\n\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_UNTRANSLATABLE_CHARACTER),\n\t\t\t errmsg(\"character with byte sequence %s in encoding \\\"%s\\\" has no equivalent in encoding \\\"%s\\\"\",\n\t\t\t\t\tbuf,\n\t\t\t\t\tpg_enc2name_tbl[src_encoding].name,\n\t\t\t\t\tpg_enc2name_tbl[dest_encoding].name)));\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nvoid\nreport_untranslatable_char(int src_encoding, int dest_encoding,\n\t\t\t\t\t\t   const char *mbstr, int len)\n{\n\tint\t\t\tl = pg_encoding_mblen(src_encoding, mbstr);\n\tchar\t\tbuf[8 * 5 + 1];\n\tchar\t   *p = buf;\n\tint\t\t\tj,\n\t\t\t\tjlimit;\n\n\tjlimit = Min(l, len);\n\tjlimit = Min(jlimit, 8);\t/* prevent buffer overrun */\n\n\tfor (j = 0; j < jlimit; j++)\n\t{\n\t\tp += sprintf(p, \"0x%02x\", (unsigned char) mbstr[j]);\n\t\tif (j < jlimit - 1)\n\t\t\tp += sprintf(p, \" \");\n\t}\n\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_UNTRANSLATABLE_CHARACTER),\n\t\t\t errmsg(\"character with byte sequence %s in encoding \\\"%s\\\" has no equivalent in encoding \\\"%s\\\"\",\n\t\t\t\t\tbuf,\n\t\t\t\t\tpg_enc2name_tbl[src_encoding].name,\n\t\t\t\t\tpg_enc2name_tbl[dest_encoding].name)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_HIGHBIT_SET",
          "args": [
            "c1"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "report_invalid_encoding",
          "args": [
            "encoding",
            "(const char *) l",
            "len"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "report_invalid_encoding",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "1994-2018",
          "snippet": "void\nreport_invalid_encoding(int encoding, const char *mbstr, int len)\n{\n\tint\t\t\tl = pg_encoding_mblen(encoding, mbstr);\n\tchar\t\tbuf[8 * 5 + 1];\n\tchar\t   *p = buf;\n\tint\t\t\tj,\n\t\t\t\tjlimit;\n\n\tjlimit = Min(l, len);\n\tjlimit = Min(jlimit, 8);\t/* prevent buffer overrun */\n\n\tfor (j = 0; j < jlimit; j++)\n\t{\n\t\tp += sprintf(p, \"0x%02x\", (unsigned char) mbstr[j]);\n\t\tif (j < jlimit - 1)\n\t\t\tp += sprintf(p, \" \");\n\t}\n\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_CHARACTER_NOT_IN_REPERTOIRE),\n\t\t\t errmsg(\"invalid byte sequence for encoding \\\"%s\\\": %s\",\n\t\t\t\t\tpg_enc2name_tbl[encoding].name,\n\t\t\t\t\tbuf)));\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nvoid\nreport_invalid_encoding(int encoding, const char *mbstr, int len)\n{\n\tint\t\t\tl = pg_encoding_mblen(encoding, mbstr);\n\tchar\t\tbuf[8 * 5 + 1];\n\tchar\t   *p = buf;\n\tint\t\t\tj,\n\t\t\t\tjlimit;\n\n\tjlimit = Min(l, len);\n\tjlimit = Min(jlimit, 8);\t/* prevent buffer overrun */\n\n\tfor (j = 0; j < jlimit; j++)\n\t{\n\t\tp += sprintf(p, \"0x%02x\", (unsigned char) mbstr[j]);\n\t\tif (j < jlimit - 1)\n\t\t\tp += sprintf(p, \" \");\n\t}\n\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_CHARACTER_NOT_IN_REPERTOIRE),\n\t\t\t errmsg(\"invalid byte sequence for encoding \\\"%s\\\": %s\",\n\t\t\t\t\tpg_enc2name_tbl[encoding].name,\n\t\t\t\t\tbuf)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nvoid\nlatin2mic_with_table(const unsigned char *l,\n\t\t\t\t\t unsigned char *p,\n\t\t\t\t\t int len,\n\t\t\t\t\t int lc,\n\t\t\t\t\t int encoding,\n\t\t\t\t\t const unsigned char *tab)\n{\n\tunsigned char c1,\n\t\t\t\tc2;\n\n\twhile (len > 0)\n\t{\n\t\tc1 = *l;\n\t\tif (c1 == 0)\n\t\t\treport_invalid_encoding(encoding, (const char *) l, len);\n\t\tif (!IS_HIGHBIT_SET(c1))\n\t\t\t*p++ = c1;\n\t\telse\n\t\t{\n\t\t\tc2 = tab[c1 - HIGHBIT];\n\t\t\tif (c2)\n\t\t\t{\n\t\t\t\t*p++ = lc;\n\t\t\t\t*p++ = c2;\n\t\t\t}\n\t\t\telse\n\t\t\t\treport_untranslatable_char(encoding, PG_MULE_INTERNAL,\n\t\t\t\t\t\t\t\t\t\t   (const char *) l, len);\n\t\t}\n\t\tl++;\n\t\tlen--;\n\t}\n\t*p = '\\0';\n}"
  },
  {
    "function_name": "pg_mic2ascii",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/conv.c",
    "lines": "162-178",
    "snippet": "void\npg_mic2ascii(const unsigned char *mic, unsigned char *p, int len)\n{\n\tint\t\t\tc1;\n\n\twhile (len > 0)\n\t{\n\t\tc1 = *mic;\n\t\tif (c1 == 0 || IS_HIGHBIT_SET(c1))\n\t\t\treport_untranslatable_char(PG_MULE_INTERNAL, PG_SQL_ASCII,\n\t\t\t\t\t\t\t\t\t   (const char *) mic, len);\n\t\t*p++ = c1;\n\t\tmic++;\n\t\tlen--;\n\t}\n\t*p = '\\0';\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "report_untranslatable_char",
          "args": [
            "PG_MULE_INTERNAL",
            "PG_SQL_ASCII",
            "(const char *) mic",
            "len"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "report_untranslatable_char",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "2026-2052",
          "snippet": "void\nreport_untranslatable_char(int src_encoding, int dest_encoding,\n\t\t\t\t\t\t   const char *mbstr, int len)\n{\n\tint\t\t\tl = pg_encoding_mblen(src_encoding, mbstr);\n\tchar\t\tbuf[8 * 5 + 1];\n\tchar\t   *p = buf;\n\tint\t\t\tj,\n\t\t\t\tjlimit;\n\n\tjlimit = Min(l, len);\n\tjlimit = Min(jlimit, 8);\t/* prevent buffer overrun */\n\n\tfor (j = 0; j < jlimit; j++)\n\t{\n\t\tp += sprintf(p, \"0x%02x\", (unsigned char) mbstr[j]);\n\t\tif (j < jlimit - 1)\n\t\t\tp += sprintf(p, \" \");\n\t}\n\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_UNTRANSLATABLE_CHARACTER),\n\t\t\t errmsg(\"character with byte sequence %s in encoding \\\"%s\\\" has no equivalent in encoding \\\"%s\\\"\",\n\t\t\t\t\tbuf,\n\t\t\t\t\tpg_enc2name_tbl[src_encoding].name,\n\t\t\t\t\tpg_enc2name_tbl[dest_encoding].name)));\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nvoid\nreport_untranslatable_char(int src_encoding, int dest_encoding,\n\t\t\t\t\t\t   const char *mbstr, int len)\n{\n\tint\t\t\tl = pg_encoding_mblen(src_encoding, mbstr);\n\tchar\t\tbuf[8 * 5 + 1];\n\tchar\t   *p = buf;\n\tint\t\t\tj,\n\t\t\t\tjlimit;\n\n\tjlimit = Min(l, len);\n\tjlimit = Min(jlimit, 8);\t/* prevent buffer overrun */\n\n\tfor (j = 0; j < jlimit; j++)\n\t{\n\t\tp += sprintf(p, \"0x%02x\", (unsigned char) mbstr[j]);\n\t\tif (j < jlimit - 1)\n\t\t\tp += sprintf(p, \" \");\n\t}\n\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_UNTRANSLATABLE_CHARACTER),\n\t\t\t errmsg(\"character with byte sequence %s in encoding \\\"%s\\\" has no equivalent in encoding \\\"%s\\\"\",\n\t\t\t\t\tbuf,\n\t\t\t\t\tpg_enc2name_tbl[src_encoding].name,\n\t\t\t\t\tpg_enc2name_tbl[dest_encoding].name)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_HIGHBIT_SET",
          "args": [
            "c1"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nvoid\npg_mic2ascii(const unsigned char *mic, unsigned char *p, int len)\n{\n\tint\t\t\tc1;\n\n\twhile (len > 0)\n\t{\n\t\tc1 = *mic;\n\t\tif (c1 == 0 || IS_HIGHBIT_SET(c1))\n\t\t\treport_untranslatable_char(PG_MULE_INTERNAL, PG_SQL_ASCII,\n\t\t\t\t\t\t\t\t\t   (const char *) mic, len);\n\t\t*p++ = c1;\n\t\tmic++;\n\t\tlen--;\n\t}\n\t*p = '\\0';\n}"
  },
  {
    "function_name": "pg_ascii2mic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/conv.c",
    "lines": "142-157",
    "snippet": "void\npg_ascii2mic(const unsigned char *l, unsigned char *p, int len)\n{\n\tint\t\t\tc1;\n\n\twhile (len > 0)\n\t{\n\t\tc1 = *l;\n\t\tif (c1 == 0 || IS_HIGHBIT_SET(c1))\n\t\t\treport_invalid_encoding(PG_SQL_ASCII, (const char *) l, len);\n\t\t*p++ = c1;\n\t\tl++;\n\t\tlen--;\n\t}\n\t*p = '\\0';\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "report_invalid_encoding",
          "args": [
            "PG_SQL_ASCII",
            "(const char *) l",
            "len"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "report_invalid_encoding",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "1994-2018",
          "snippet": "void\nreport_invalid_encoding(int encoding, const char *mbstr, int len)\n{\n\tint\t\t\tl = pg_encoding_mblen(encoding, mbstr);\n\tchar\t\tbuf[8 * 5 + 1];\n\tchar\t   *p = buf;\n\tint\t\t\tj,\n\t\t\t\tjlimit;\n\n\tjlimit = Min(l, len);\n\tjlimit = Min(jlimit, 8);\t/* prevent buffer overrun */\n\n\tfor (j = 0; j < jlimit; j++)\n\t{\n\t\tp += sprintf(p, \"0x%02x\", (unsigned char) mbstr[j]);\n\t\tif (j < jlimit - 1)\n\t\t\tp += sprintf(p, \" \");\n\t}\n\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_CHARACTER_NOT_IN_REPERTOIRE),\n\t\t\t errmsg(\"invalid byte sequence for encoding \\\"%s\\\": %s\",\n\t\t\t\t\tpg_enc2name_tbl[encoding].name,\n\t\t\t\t\tbuf)));\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nvoid\nreport_invalid_encoding(int encoding, const char *mbstr, int len)\n{\n\tint\t\t\tl = pg_encoding_mblen(encoding, mbstr);\n\tchar\t\tbuf[8 * 5 + 1];\n\tchar\t   *p = buf;\n\tint\t\t\tj,\n\t\t\t\tjlimit;\n\n\tjlimit = Min(l, len);\n\tjlimit = Min(jlimit, 8);\t/* prevent buffer overrun */\n\n\tfor (j = 0; j < jlimit; j++)\n\t{\n\t\tp += sprintf(p, \"0x%02x\", (unsigned char) mbstr[j]);\n\t\tif (j < jlimit - 1)\n\t\t\tp += sprintf(p, \" \");\n\t}\n\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_CHARACTER_NOT_IN_REPERTOIRE),\n\t\t\t errmsg(\"invalid byte sequence for encoding \\\"%s\\\": %s\",\n\t\t\t\t\tpg_enc2name_tbl[encoding].name,\n\t\t\t\t\tbuf)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_HIGHBIT_SET",
          "args": [
            "c1"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nvoid\npg_ascii2mic(const unsigned char *l, unsigned char *p, int len)\n{\n\tint\t\t\tc1;\n\n\twhile (len > 0)\n\t{\n\t\tc1 = *l;\n\t\tif (c1 == 0 || IS_HIGHBIT_SET(c1))\n\t\t\treport_invalid_encoding(PG_SQL_ASCII, (const char *) l, len);\n\t\t*p++ = c1;\n\t\tl++;\n\t\tlen--;\n\t}\n\t*p = '\\0';\n}"
  },
  {
    "function_name": "mic2latin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/conv.c",
    "lines": "98-132",
    "snippet": "void\nmic2latin(const unsigned char *mic, unsigned char *p, int len,\n\t\t  int lc, int encoding)\n{\n\tint\t\t\tc1;\n\n\twhile (len > 0)\n\t{\n\t\tc1 = *mic;\n\t\tif (c1 == 0)\n\t\t\treport_invalid_encoding(PG_MULE_INTERNAL, (const char *) mic, len);\n\t\tif (!IS_HIGHBIT_SET(c1))\n\t\t{\n\t\t\t/* easy for ASCII */\n\t\t\t*p++ = c1;\n\t\t\tmic++;\n\t\t\tlen--;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint\t\t\tl = pg_mic_mblen(mic);\n\n\t\t\tif (len < l)\n\t\t\t\treport_invalid_encoding(PG_MULE_INTERNAL, (const char *) mic,\n\t\t\t\t\t\t\t\t\t\tlen);\n\t\t\tif (l != 2 || c1 != lc || !IS_HIGHBIT_SET(mic[1]))\n\t\t\t\treport_untranslatable_char(PG_MULE_INTERNAL, encoding,\n\t\t\t\t\t\t\t\t\t\t   (const char *) mic, len);\n\t\t\t*p++ = mic[1];\n\t\t\tmic += 2;\n\t\t\tlen -= 2;\n\t\t}\n\t}\n\t*p = '\\0';\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "report_untranslatable_char",
          "args": [
            "PG_MULE_INTERNAL",
            "encoding",
            "(const char *) mic",
            "len"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "report_untranslatable_char",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "2026-2052",
          "snippet": "void\nreport_untranslatable_char(int src_encoding, int dest_encoding,\n\t\t\t\t\t\t   const char *mbstr, int len)\n{\n\tint\t\t\tl = pg_encoding_mblen(src_encoding, mbstr);\n\tchar\t\tbuf[8 * 5 + 1];\n\tchar\t   *p = buf;\n\tint\t\t\tj,\n\t\t\t\tjlimit;\n\n\tjlimit = Min(l, len);\n\tjlimit = Min(jlimit, 8);\t/* prevent buffer overrun */\n\n\tfor (j = 0; j < jlimit; j++)\n\t{\n\t\tp += sprintf(p, \"0x%02x\", (unsigned char) mbstr[j]);\n\t\tif (j < jlimit - 1)\n\t\t\tp += sprintf(p, \" \");\n\t}\n\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_UNTRANSLATABLE_CHARACTER),\n\t\t\t errmsg(\"character with byte sequence %s in encoding \\\"%s\\\" has no equivalent in encoding \\\"%s\\\"\",\n\t\t\t\t\tbuf,\n\t\t\t\t\tpg_enc2name_tbl[src_encoding].name,\n\t\t\t\t\tpg_enc2name_tbl[dest_encoding].name)));\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nvoid\nreport_untranslatable_char(int src_encoding, int dest_encoding,\n\t\t\t\t\t\t   const char *mbstr, int len)\n{\n\tint\t\t\tl = pg_encoding_mblen(src_encoding, mbstr);\n\tchar\t\tbuf[8 * 5 + 1];\n\tchar\t   *p = buf;\n\tint\t\t\tj,\n\t\t\t\tjlimit;\n\n\tjlimit = Min(l, len);\n\tjlimit = Min(jlimit, 8);\t/* prevent buffer overrun */\n\n\tfor (j = 0; j < jlimit; j++)\n\t{\n\t\tp += sprintf(p, \"0x%02x\", (unsigned char) mbstr[j]);\n\t\tif (j < jlimit - 1)\n\t\t\tp += sprintf(p, \" \");\n\t}\n\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_UNTRANSLATABLE_CHARACTER),\n\t\t\t errmsg(\"character with byte sequence %s in encoding \\\"%s\\\" has no equivalent in encoding \\\"%s\\\"\",\n\t\t\t\t\tbuf,\n\t\t\t\t\tpg_enc2name_tbl[src_encoding].name,\n\t\t\t\t\tpg_enc2name_tbl[dest_encoding].name)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_HIGHBIT_SET",
          "args": [
            "mic[1]"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "report_invalid_encoding",
          "args": [
            "PG_MULE_INTERNAL",
            "(const char *) mic",
            "len"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "report_invalid_encoding",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "1994-2018",
          "snippet": "void\nreport_invalid_encoding(int encoding, const char *mbstr, int len)\n{\n\tint\t\t\tl = pg_encoding_mblen(encoding, mbstr);\n\tchar\t\tbuf[8 * 5 + 1];\n\tchar\t   *p = buf;\n\tint\t\t\tj,\n\t\t\t\tjlimit;\n\n\tjlimit = Min(l, len);\n\tjlimit = Min(jlimit, 8);\t/* prevent buffer overrun */\n\n\tfor (j = 0; j < jlimit; j++)\n\t{\n\t\tp += sprintf(p, \"0x%02x\", (unsigned char) mbstr[j]);\n\t\tif (j < jlimit - 1)\n\t\t\tp += sprintf(p, \" \");\n\t}\n\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_CHARACTER_NOT_IN_REPERTOIRE),\n\t\t\t errmsg(\"invalid byte sequence for encoding \\\"%s\\\": %s\",\n\t\t\t\t\tpg_enc2name_tbl[encoding].name,\n\t\t\t\t\tbuf)));\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nvoid\nreport_invalid_encoding(int encoding, const char *mbstr, int len)\n{\n\tint\t\t\tl = pg_encoding_mblen(encoding, mbstr);\n\tchar\t\tbuf[8 * 5 + 1];\n\tchar\t   *p = buf;\n\tint\t\t\tj,\n\t\t\t\tjlimit;\n\n\tjlimit = Min(l, len);\n\tjlimit = Min(jlimit, 8);\t/* prevent buffer overrun */\n\n\tfor (j = 0; j < jlimit; j++)\n\t{\n\t\tp += sprintf(p, \"0x%02x\", (unsigned char) mbstr[j]);\n\t\tif (j < jlimit - 1)\n\t\t\tp += sprintf(p, \" \");\n\t}\n\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_CHARACTER_NOT_IN_REPERTOIRE),\n\t\t\t errmsg(\"invalid byte sequence for encoding \\\"%s\\\": %s\",\n\t\t\t\t\tpg_enc2name_tbl[encoding].name,\n\t\t\t\t\tbuf)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_mic_mblen",
          "args": [
            "mic"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mic_mblen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "1775-1779",
          "snippet": "int\npg_mic_mblen(const unsigned char *mbstr)\n{\n\treturn pg_mule_mblen(mbstr);\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nint\npg_mic_mblen(const unsigned char *mbstr)\n{\n\treturn pg_mule_mblen(mbstr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_HIGHBIT_SET",
          "args": [
            "c1"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nvoid\nmic2latin(const unsigned char *mic, unsigned char *p, int len,\n\t\t  int lc, int encoding)\n{\n\tint\t\t\tc1;\n\n\twhile (len > 0)\n\t{\n\t\tc1 = *mic;\n\t\tif (c1 == 0)\n\t\t\treport_invalid_encoding(PG_MULE_INTERNAL, (const char *) mic, len);\n\t\tif (!IS_HIGHBIT_SET(c1))\n\t\t{\n\t\t\t/* easy for ASCII */\n\t\t\t*p++ = c1;\n\t\t\tmic++;\n\t\t\tlen--;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint\t\t\tl = pg_mic_mblen(mic);\n\n\t\t\tif (len < l)\n\t\t\t\treport_invalid_encoding(PG_MULE_INTERNAL, (const char *) mic,\n\t\t\t\t\t\t\t\t\t\tlen);\n\t\t\tif (l != 2 || c1 != lc || !IS_HIGHBIT_SET(mic[1]))\n\t\t\t\treport_untranslatable_char(PG_MULE_INTERNAL, encoding,\n\t\t\t\t\t\t\t\t\t\t   (const char *) mic, len);\n\t\t\t*p++ = mic[1];\n\t\t\tmic += 2;\n\t\t\tlen -= 2;\n\t\t}\n\t}\n\t*p = '\\0';\n}"
  },
  {
    "function_name": "latin2mic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/conv.c",
    "lines": "70-88",
    "snippet": "void\nlatin2mic(const unsigned char *l, unsigned char *p, int len,\n\t\t  int lc, int encoding)\n{\n\tint\t\t\tc1;\n\n\twhile (len > 0)\n\t{\n\t\tc1 = *l;\n\t\tif (c1 == 0)\n\t\t\treport_invalid_encoding(encoding, (const char *) l, len);\n\t\tif (IS_HIGHBIT_SET(c1))\n\t\t\t*p++ = lc;\n\t\t*p++ = c1;\n\t\tl++;\n\t\tlen--;\n\t}\n\t*p = '\\0';\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_HIGHBIT_SET",
          "args": [
            "c1"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "report_invalid_encoding",
          "args": [
            "encoding",
            "(const char *) l",
            "len"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "report_invalid_encoding",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "1994-2018",
          "snippet": "void\nreport_invalid_encoding(int encoding, const char *mbstr, int len)\n{\n\tint\t\t\tl = pg_encoding_mblen(encoding, mbstr);\n\tchar\t\tbuf[8 * 5 + 1];\n\tchar\t   *p = buf;\n\tint\t\t\tj,\n\t\t\t\tjlimit;\n\n\tjlimit = Min(l, len);\n\tjlimit = Min(jlimit, 8);\t/* prevent buffer overrun */\n\n\tfor (j = 0; j < jlimit; j++)\n\t{\n\t\tp += sprintf(p, \"0x%02x\", (unsigned char) mbstr[j]);\n\t\tif (j < jlimit - 1)\n\t\t\tp += sprintf(p, \" \");\n\t}\n\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_CHARACTER_NOT_IN_REPERTOIRE),\n\t\t\t errmsg(\"invalid byte sequence for encoding \\\"%s\\\": %s\",\n\t\t\t\t\tpg_enc2name_tbl[encoding].name,\n\t\t\t\t\tbuf)));\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nvoid\nreport_invalid_encoding(int encoding, const char *mbstr, int len)\n{\n\tint\t\t\tl = pg_encoding_mblen(encoding, mbstr);\n\tchar\t\tbuf[8 * 5 + 1];\n\tchar\t   *p = buf;\n\tint\t\t\tj,\n\t\t\t\tjlimit;\n\n\tjlimit = Min(l, len);\n\tjlimit = Min(jlimit, 8);\t/* prevent buffer overrun */\n\n\tfor (j = 0; j < jlimit; j++)\n\t{\n\t\tp += sprintf(p, \"0x%02x\", (unsigned char) mbstr[j]);\n\t\tif (j < jlimit - 1)\n\t\t\tp += sprintf(p, \" \");\n\t}\n\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_CHARACTER_NOT_IN_REPERTOIRE),\n\t\t\t errmsg(\"invalid byte sequence for encoding \\\"%s\\\": %s\",\n\t\t\t\t\tpg_enc2name_tbl[encoding].name,\n\t\t\t\t\tbuf)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nvoid\nlatin2mic(const unsigned char *l, unsigned char *p, int len,\n\t\t  int lc, int encoding)\n{\n\tint\t\t\tc1;\n\n\twhile (len > 0)\n\t{\n\t\tc1 = *l;\n\t\tif (c1 == 0)\n\t\t\treport_invalid_encoding(encoding, (const char *) l, len);\n\t\tif (IS_HIGHBIT_SET(c1))\n\t\t\t*p++ = lc;\n\t\t*p++ = c1;\n\t\tl++;\n\t\tlen--;\n\t}\n\t*p = '\\0';\n}"
  },
  {
    "function_name": "local2local",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/conv.c",
    "lines": "29-60",
    "snippet": "void\nlocal2local(const unsigned char *l,\n\t\t\tunsigned char *p,\n\t\t\tint len,\n\t\t\tint src_encoding,\n\t\t\tint dest_encoding,\n\t\t\tconst unsigned char *tab)\n{\n\tunsigned char c1,\n\t\t\t\tc2;\n\n\twhile (len > 0)\n\t{\n\t\tc1 = *l;\n\t\tif (c1 == 0)\n\t\t\treport_invalid_encoding(src_encoding, (const char *) l, len);\n\t\tif (!IS_HIGHBIT_SET(c1))\n\t\t\t*p++ = c1;\n\t\telse\n\t\t{\n\t\t\tc2 = tab[c1 - HIGHBIT];\n\t\t\tif (c2)\n\t\t\t\t*p++ = c2;\n\t\t\telse\n\t\t\t\treport_untranslatable_char(src_encoding, dest_encoding,\n\t\t\t\t\t\t\t\t\t\t   (const char *) l, len);\n\t\t}\n\t\tl++;\n\t\tlen--;\n\t}\n\t*p = '\\0';\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "report_untranslatable_char",
          "args": [
            "src_encoding",
            "dest_encoding",
            "(const char *) l",
            "len"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "report_untranslatable_char",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "2026-2052",
          "snippet": "void\nreport_untranslatable_char(int src_encoding, int dest_encoding,\n\t\t\t\t\t\t   const char *mbstr, int len)\n{\n\tint\t\t\tl = pg_encoding_mblen(src_encoding, mbstr);\n\tchar\t\tbuf[8 * 5 + 1];\n\tchar\t   *p = buf;\n\tint\t\t\tj,\n\t\t\t\tjlimit;\n\n\tjlimit = Min(l, len);\n\tjlimit = Min(jlimit, 8);\t/* prevent buffer overrun */\n\n\tfor (j = 0; j < jlimit; j++)\n\t{\n\t\tp += sprintf(p, \"0x%02x\", (unsigned char) mbstr[j]);\n\t\tif (j < jlimit - 1)\n\t\t\tp += sprintf(p, \" \");\n\t}\n\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_UNTRANSLATABLE_CHARACTER),\n\t\t\t errmsg(\"character with byte sequence %s in encoding \\\"%s\\\" has no equivalent in encoding \\\"%s\\\"\",\n\t\t\t\t\tbuf,\n\t\t\t\t\tpg_enc2name_tbl[src_encoding].name,\n\t\t\t\t\tpg_enc2name_tbl[dest_encoding].name)));\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nvoid\nreport_untranslatable_char(int src_encoding, int dest_encoding,\n\t\t\t\t\t\t   const char *mbstr, int len)\n{\n\tint\t\t\tl = pg_encoding_mblen(src_encoding, mbstr);\n\tchar\t\tbuf[8 * 5 + 1];\n\tchar\t   *p = buf;\n\tint\t\t\tj,\n\t\t\t\tjlimit;\n\n\tjlimit = Min(l, len);\n\tjlimit = Min(jlimit, 8);\t/* prevent buffer overrun */\n\n\tfor (j = 0; j < jlimit; j++)\n\t{\n\t\tp += sprintf(p, \"0x%02x\", (unsigned char) mbstr[j]);\n\t\tif (j < jlimit - 1)\n\t\t\tp += sprintf(p, \" \");\n\t}\n\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_UNTRANSLATABLE_CHARACTER),\n\t\t\t errmsg(\"character with byte sequence %s in encoding \\\"%s\\\" has no equivalent in encoding \\\"%s\\\"\",\n\t\t\t\t\tbuf,\n\t\t\t\t\tpg_enc2name_tbl[src_encoding].name,\n\t\t\t\t\tpg_enc2name_tbl[dest_encoding].name)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_HIGHBIT_SET",
          "args": [
            "c1"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "report_invalid_encoding",
          "args": [
            "src_encoding",
            "(const char *) l",
            "len"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "report_invalid_encoding",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "1994-2018",
          "snippet": "void\nreport_invalid_encoding(int encoding, const char *mbstr, int len)\n{\n\tint\t\t\tl = pg_encoding_mblen(encoding, mbstr);\n\tchar\t\tbuf[8 * 5 + 1];\n\tchar\t   *p = buf;\n\tint\t\t\tj,\n\t\t\t\tjlimit;\n\n\tjlimit = Min(l, len);\n\tjlimit = Min(jlimit, 8);\t/* prevent buffer overrun */\n\n\tfor (j = 0; j < jlimit; j++)\n\t{\n\t\tp += sprintf(p, \"0x%02x\", (unsigned char) mbstr[j]);\n\t\tif (j < jlimit - 1)\n\t\t\tp += sprintf(p, \" \");\n\t}\n\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_CHARACTER_NOT_IN_REPERTOIRE),\n\t\t\t errmsg(\"invalid byte sequence for encoding \\\"%s\\\": %s\",\n\t\t\t\t\tpg_enc2name_tbl[encoding].name,\n\t\t\t\t\tbuf)));\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nvoid\nreport_invalid_encoding(int encoding, const char *mbstr, int len)\n{\n\tint\t\t\tl = pg_encoding_mblen(encoding, mbstr);\n\tchar\t\tbuf[8 * 5 + 1];\n\tchar\t   *p = buf;\n\tint\t\t\tj,\n\t\t\t\tjlimit;\n\n\tjlimit = Min(l, len);\n\tjlimit = Min(jlimit, 8);\t/* prevent buffer overrun */\n\n\tfor (j = 0; j < jlimit; j++)\n\t{\n\t\tp += sprintf(p, \"0x%02x\", (unsigned char) mbstr[j]);\n\t\tif (j < jlimit - 1)\n\t\t\tp += sprintf(p, \" \");\n\t}\n\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_CHARACTER_NOT_IN_REPERTOIRE),\n\t\t\t errmsg(\"invalid byte sequence for encoding \\\"%s\\\": %s\",\n\t\t\t\t\tpg_enc2name_tbl[encoding].name,\n\t\t\t\t\tbuf)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nvoid\nlocal2local(const unsigned char *l,\n\t\t\tunsigned char *p,\n\t\t\tint len,\n\t\t\tint src_encoding,\n\t\t\tint dest_encoding,\n\t\t\tconst unsigned char *tab)\n{\n\tunsigned char c1,\n\t\t\t\tc2;\n\n\twhile (len > 0)\n\t{\n\t\tc1 = *l;\n\t\tif (c1 == 0)\n\t\t\treport_invalid_encoding(src_encoding, (const char *) l, len);\n\t\tif (!IS_HIGHBIT_SET(c1))\n\t\t\t*p++ = c1;\n\t\telse\n\t\t{\n\t\t\tc2 = tab[c1 - HIGHBIT];\n\t\t\tif (c2)\n\t\t\t\t*p++ = c2;\n\t\t\telse\n\t\t\t\treport_untranslatable_char(src_encoding, dest_encoding,\n\t\t\t\t\t\t\t\t\t\t   (const char *) l, len);\n\t\t}\n\t\tl++;\n\t\tlen--;\n\t}\n\t*p = '\\0';\n}"
  }
]