[
  {
    "function_name": "call_subtype_diff",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_gist.c",
    "lines": "1519-1531",
    "snippet": "static float8\ncall_subtype_diff(TypeCacheEntry *typcache, Datum val1, Datum val2)\n{\n\tfloat8\t\tvalue;\n\n\tvalue = DatumGetFloat8(FunctionCall2Coll(&typcache->rng_subdiff_finfo,\n\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t val1, val2));\n\t/* Cope with buggy subtype_diff function by returning zero */\n\tif (value >= 0.0)\n\t\treturn value;\n\treturn 0.0;\n}",
    "includes": [
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"access/stratnum.h\"",
      "#include \"access/gist.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static float8 call_subtype_diff(TypeCacheEntry *typcache,\n\t\t\t\t  Datum val1, Datum val2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DatumGetFloat8",
          "args": [
            "FunctionCall2Coll(&typcache->rng_subdiff_finfo,\n\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t val1, val2)"
          ],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FunctionCall2Coll",
          "args": [
            "&typcache->rng_subdiff_finfo",
            "typcache->rng_collation",
            "val1",
            "val2"
          ],
          "line": 1524
        },
        "resolved": true,
        "details": {
          "function_name": "OidFunctionCall2Coll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1427-1450",
          "snippet": "Datum\nOidFunctionCall2Coll(Oid functionId, Oid collation, Datum arg1, Datum arg2)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 2, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nOidFunctionCall2Coll(Oid functionId, Oid collation, Datum arg1, Datum arg2)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 2, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/rangetypes.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"access/stratnum.h\"\n#include \"access/gist.h\"\n#include \"postgres.h\"\n\nstatic float8 call_subtype_diff(TypeCacheEntry *typcache,\n\t\t\t\t  Datum val1, Datum val2);\n\nstatic float8\ncall_subtype_diff(TypeCacheEntry *typcache, Datum val1, Datum val2)\n{\n\tfloat8\t\tvalue;\n\n\tvalue = DatumGetFloat8(FunctionCall2Coll(&typcache->rng_subdiff_finfo,\n\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t val1, val2));\n\t/* Cope with buggy subtype_diff function by returning zero */\n\tif (value >= 0.0)\n\t\treturn value;\n\treturn 0.0;\n}"
  },
  {
    "function_name": "common_entry_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_gist.c",
    "lines": "1501-1513",
    "snippet": "static int\ncommon_entry_cmp(const void *i1, const void *i2)\n{\n\tdouble\t\tdelta1 = ((CommonEntry *) i1)->delta;\n\tdouble\t\tdelta2 = ((CommonEntry *) i2)->delta;\n\n\tif (delta1 < delta2)\n\t\treturn -1;\n\telse if (delta1 > delta2)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}",
    "includes": [
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"access/stratnum.h\"",
      "#include \"access/gist.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tcommon_entry_cmp(const void *i1, const void *i2);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/rangetypes.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"access/stratnum.h\"\n#include \"access/gist.h\"\n#include \"postgres.h\"\n\nstatic int\tcommon_entry_cmp(const void *i1, const void *i2);\n\nstatic int\ncommon_entry_cmp(const void *i1, const void *i2)\n{\n\tdouble\t\tdelta1 = ((CommonEntry *) i1)->delta;\n\tdouble\t\tdelta2 = ((CommonEntry *) i2)->delta;\n\n\tif (delta1 < delta2)\n\t\treturn -1;\n\telse if (delta1 > delta2)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}"
  },
  {
    "function_name": "interval_cmp_upper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_gist.c",
    "lines": "1488-1496",
    "snippet": "static int\ninterval_cmp_upper(const void *a, const void *b, void *arg)\n{\n\tNonEmptyRange *i1 = (NonEmptyRange *) a;\n\tNonEmptyRange *i2 = (NonEmptyRange *) b;\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) arg;\n\n\treturn range_cmp_bounds(typcache, &i1->upper, &i2->upper);\n}",
    "includes": [
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"access/stratnum.h\"",
      "#include \"access/gist.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tsingle_bound_cmp(const void *a, const void *b, void *arg);",
      "static int\tinterval_cmp_lower(const void *a, const void *b, void *arg);",
      "static int\tinterval_cmp_upper(const void *a, const void *b, void *arg);",
      "static int\tcommon_entry_cmp(const void *i1, const void *i2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "range_cmp_bounds",
          "args": [
            "typcache",
            "&i1->upper",
            "&i2->upper"
          ],
          "line": 1495
        },
        "resolved": true,
        "details": {
          "function_name": "range_cmp_bounds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1831-1894",
          "snippet": "int\nrange_cmp_bounds(TypeCacheEntry *typcache, RangeBound *b1, RangeBound *b2)\n{\n\tint32\t\tresult;\n\n\t/*\n\t * First, handle cases involving infinity, which don't require invoking\n\t * the comparison proc.\n\t */\n\tif (b1->infinite && b2->infinite)\n\t{\n\t\t/*\n\t\t * Both are infinity, so they are equal unless one is lower and the\n\t\t * other not.\n\t\t */\n\t\tif (b1->lower == b2->lower)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn b1->lower ? -1 : 1;\n\t}\n\telse if (b1->infinite)\n\t\treturn b1->lower ? -1 : 1;\n\telse if (b2->infinite)\n\t\treturn b2->lower ? 1 : -1;\n\n\t/*\n\t * Both boundaries are finite, so compare the held values.\n\t */\n\tresult = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t b1->val, b2->val));\n\n\t/*\n\t * If the comparison is anything other than equal, we're done. If they\n\t * compare equal though, we still have to consider whether the boundaries\n\t * are inclusive or exclusive.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (!b1->inclusive && !b2->inclusive)\n\t\t{\n\t\t\t/* both are exclusive */\n\t\t\tif (b1->lower == b2->lower)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn b1->lower ? 1 : -1;\n\t\t}\n\t\telse if (!b1->inclusive)\n\t\t\treturn b1->lower ? 1 : -1;\n\t\telse if (!b2->inclusive)\n\t\t\treturn b2->lower ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Both are inclusive and the values held are equal, so they are\n\t\t\t * equal regardless of whether they are upper or lower boundaries,\n\t\t\t * or a mix.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nint\nrange_cmp_bounds(TypeCacheEntry *typcache, RangeBound *b1, RangeBound *b2)\n{\n\tint32\t\tresult;\n\n\t/*\n\t * First, handle cases involving infinity, which don't require invoking\n\t * the comparison proc.\n\t */\n\tif (b1->infinite && b2->infinite)\n\t{\n\t\t/*\n\t\t * Both are infinity, so they are equal unless one is lower and the\n\t\t * other not.\n\t\t */\n\t\tif (b1->lower == b2->lower)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn b1->lower ? -1 : 1;\n\t}\n\telse if (b1->infinite)\n\t\treturn b1->lower ? -1 : 1;\n\telse if (b2->infinite)\n\t\treturn b2->lower ? 1 : -1;\n\n\t/*\n\t * Both boundaries are finite, so compare the held values.\n\t */\n\tresult = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t b1->val, b2->val));\n\n\t/*\n\t * If the comparison is anything other than equal, we're done. If they\n\t * compare equal though, we still have to consider whether the boundaries\n\t * are inclusive or exclusive.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (!b1->inclusive && !b2->inclusive)\n\t\t{\n\t\t\t/* both are exclusive */\n\t\t\tif (b1->lower == b2->lower)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn b1->lower ? 1 : -1;\n\t\t}\n\t\telse if (!b1->inclusive)\n\t\t\treturn b1->lower ? 1 : -1;\n\t\telse if (!b2->inclusive)\n\t\t\treturn b2->lower ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Both are inclusive and the values held are equal, so they are\n\t\t\t * equal regardless of whether they are upper or lower boundaries,\n\t\t\t * or a mix.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/rangetypes.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"access/stratnum.h\"\n#include \"access/gist.h\"\n#include \"postgres.h\"\n\nstatic int\tsingle_bound_cmp(const void *a, const void *b, void *arg);\nstatic int\tinterval_cmp_lower(const void *a, const void *b, void *arg);\nstatic int\tinterval_cmp_upper(const void *a, const void *b, void *arg);\nstatic int\tcommon_entry_cmp(const void *i1, const void *i2);\n\nstatic int\ninterval_cmp_upper(const void *a, const void *b, void *arg)\n{\n\tNonEmptyRange *i1 = (NonEmptyRange *) a;\n\tNonEmptyRange *i2 = (NonEmptyRange *) b;\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) arg;\n\n\treturn range_cmp_bounds(typcache, &i1->upper, &i2->upper);\n}"
  },
  {
    "function_name": "interval_cmp_lower",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_gist.c",
    "lines": "1475-1483",
    "snippet": "static int\ninterval_cmp_lower(const void *a, const void *b, void *arg)\n{\n\tNonEmptyRange *i1 = (NonEmptyRange *) a;\n\tNonEmptyRange *i2 = (NonEmptyRange *) b;\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) arg;\n\n\treturn range_cmp_bounds(typcache, &i1->lower, &i2->lower);\n}",
    "includes": [
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"access/stratnum.h\"",
      "#include \"access/gist.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tsingle_bound_cmp(const void *a, const void *b, void *arg);",
      "static int\tinterval_cmp_lower(const void *a, const void *b, void *arg);",
      "static int\tinterval_cmp_upper(const void *a, const void *b, void *arg);",
      "static int\tcommon_entry_cmp(const void *i1, const void *i2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "range_cmp_bounds",
          "args": [
            "typcache",
            "&i1->lower",
            "&i2->lower"
          ],
          "line": 1482
        },
        "resolved": true,
        "details": {
          "function_name": "range_cmp_bounds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1831-1894",
          "snippet": "int\nrange_cmp_bounds(TypeCacheEntry *typcache, RangeBound *b1, RangeBound *b2)\n{\n\tint32\t\tresult;\n\n\t/*\n\t * First, handle cases involving infinity, which don't require invoking\n\t * the comparison proc.\n\t */\n\tif (b1->infinite && b2->infinite)\n\t{\n\t\t/*\n\t\t * Both are infinity, so they are equal unless one is lower and the\n\t\t * other not.\n\t\t */\n\t\tif (b1->lower == b2->lower)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn b1->lower ? -1 : 1;\n\t}\n\telse if (b1->infinite)\n\t\treturn b1->lower ? -1 : 1;\n\telse if (b2->infinite)\n\t\treturn b2->lower ? 1 : -1;\n\n\t/*\n\t * Both boundaries are finite, so compare the held values.\n\t */\n\tresult = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t b1->val, b2->val));\n\n\t/*\n\t * If the comparison is anything other than equal, we're done. If they\n\t * compare equal though, we still have to consider whether the boundaries\n\t * are inclusive or exclusive.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (!b1->inclusive && !b2->inclusive)\n\t\t{\n\t\t\t/* both are exclusive */\n\t\t\tif (b1->lower == b2->lower)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn b1->lower ? 1 : -1;\n\t\t}\n\t\telse if (!b1->inclusive)\n\t\t\treturn b1->lower ? 1 : -1;\n\t\telse if (!b2->inclusive)\n\t\t\treturn b2->lower ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Both are inclusive and the values held are equal, so they are\n\t\t\t * equal regardless of whether they are upper or lower boundaries,\n\t\t\t * or a mix.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nint\nrange_cmp_bounds(TypeCacheEntry *typcache, RangeBound *b1, RangeBound *b2)\n{\n\tint32\t\tresult;\n\n\t/*\n\t * First, handle cases involving infinity, which don't require invoking\n\t * the comparison proc.\n\t */\n\tif (b1->infinite && b2->infinite)\n\t{\n\t\t/*\n\t\t * Both are infinity, so they are equal unless one is lower and the\n\t\t * other not.\n\t\t */\n\t\tif (b1->lower == b2->lower)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn b1->lower ? -1 : 1;\n\t}\n\telse if (b1->infinite)\n\t\treturn b1->lower ? -1 : 1;\n\telse if (b2->infinite)\n\t\treturn b2->lower ? 1 : -1;\n\n\t/*\n\t * Both boundaries are finite, so compare the held values.\n\t */\n\tresult = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t b1->val, b2->val));\n\n\t/*\n\t * If the comparison is anything other than equal, we're done. If they\n\t * compare equal though, we still have to consider whether the boundaries\n\t * are inclusive or exclusive.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (!b1->inclusive && !b2->inclusive)\n\t\t{\n\t\t\t/* both are exclusive */\n\t\t\tif (b1->lower == b2->lower)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn b1->lower ? 1 : -1;\n\t\t}\n\t\telse if (!b1->inclusive)\n\t\t\treturn b1->lower ? 1 : -1;\n\t\telse if (!b2->inclusive)\n\t\t\treturn b2->lower ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Both are inclusive and the values held are equal, so they are\n\t\t\t * equal regardless of whether they are upper or lower boundaries,\n\t\t\t * or a mix.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/rangetypes.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"access/stratnum.h\"\n#include \"access/gist.h\"\n#include \"postgres.h\"\n\nstatic int\tsingle_bound_cmp(const void *a, const void *b, void *arg);\nstatic int\tinterval_cmp_lower(const void *a, const void *b, void *arg);\nstatic int\tinterval_cmp_upper(const void *a, const void *b, void *arg);\nstatic int\tcommon_entry_cmp(const void *i1, const void *i2);\n\nstatic int\ninterval_cmp_lower(const void *a, const void *b, void *arg)\n{\n\tNonEmptyRange *i1 = (NonEmptyRange *) a;\n\tNonEmptyRange *i2 = (NonEmptyRange *) b;\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) arg;\n\n\treturn range_cmp_bounds(typcache, &i1->lower, &i2->lower);\n}"
  },
  {
    "function_name": "single_bound_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_gist.c",
    "lines": "1462-1470",
    "snippet": "static int\nsingle_bound_cmp(const void *a, const void *b, void *arg)\n{\n\tSingleBoundSortItem *i1 = (SingleBoundSortItem *) a;\n\tSingleBoundSortItem *i2 = (SingleBoundSortItem *) b;\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) arg;\n\n\treturn range_cmp_bounds(typcache, &i1->bound, &i2->bound);\n}",
    "includes": [
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"access/stratnum.h\"",
      "#include \"access/gist.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tsingle_bound_cmp(const void *a, const void *b, void *arg);",
      "static int\tinterval_cmp_lower(const void *a, const void *b, void *arg);",
      "static int\tinterval_cmp_upper(const void *a, const void *b, void *arg);",
      "static int\tcommon_entry_cmp(const void *i1, const void *i2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "range_cmp_bounds",
          "args": [
            "typcache",
            "&i1->bound",
            "&i2->bound"
          ],
          "line": 1469
        },
        "resolved": true,
        "details": {
          "function_name": "range_cmp_bounds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1831-1894",
          "snippet": "int\nrange_cmp_bounds(TypeCacheEntry *typcache, RangeBound *b1, RangeBound *b2)\n{\n\tint32\t\tresult;\n\n\t/*\n\t * First, handle cases involving infinity, which don't require invoking\n\t * the comparison proc.\n\t */\n\tif (b1->infinite && b2->infinite)\n\t{\n\t\t/*\n\t\t * Both are infinity, so they are equal unless one is lower and the\n\t\t * other not.\n\t\t */\n\t\tif (b1->lower == b2->lower)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn b1->lower ? -1 : 1;\n\t}\n\telse if (b1->infinite)\n\t\treturn b1->lower ? -1 : 1;\n\telse if (b2->infinite)\n\t\treturn b2->lower ? 1 : -1;\n\n\t/*\n\t * Both boundaries are finite, so compare the held values.\n\t */\n\tresult = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t b1->val, b2->val));\n\n\t/*\n\t * If the comparison is anything other than equal, we're done. If they\n\t * compare equal though, we still have to consider whether the boundaries\n\t * are inclusive or exclusive.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (!b1->inclusive && !b2->inclusive)\n\t\t{\n\t\t\t/* both are exclusive */\n\t\t\tif (b1->lower == b2->lower)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn b1->lower ? 1 : -1;\n\t\t}\n\t\telse if (!b1->inclusive)\n\t\t\treturn b1->lower ? 1 : -1;\n\t\telse if (!b2->inclusive)\n\t\t\treturn b2->lower ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Both are inclusive and the values held are equal, so they are\n\t\t\t * equal regardless of whether they are upper or lower boundaries,\n\t\t\t * or a mix.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nint\nrange_cmp_bounds(TypeCacheEntry *typcache, RangeBound *b1, RangeBound *b2)\n{\n\tint32\t\tresult;\n\n\t/*\n\t * First, handle cases involving infinity, which don't require invoking\n\t * the comparison proc.\n\t */\n\tif (b1->infinite && b2->infinite)\n\t{\n\t\t/*\n\t\t * Both are infinity, so they are equal unless one is lower and the\n\t\t * other not.\n\t\t */\n\t\tif (b1->lower == b2->lower)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn b1->lower ? -1 : 1;\n\t}\n\telse if (b1->infinite)\n\t\treturn b1->lower ? -1 : 1;\n\telse if (b2->infinite)\n\t\treturn b2->lower ? 1 : -1;\n\n\t/*\n\t * Both boundaries are finite, so compare the held values.\n\t */\n\tresult = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t b1->val, b2->val));\n\n\t/*\n\t * If the comparison is anything other than equal, we're done. If they\n\t * compare equal though, we still have to consider whether the boundaries\n\t * are inclusive or exclusive.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (!b1->inclusive && !b2->inclusive)\n\t\t{\n\t\t\t/* both are exclusive */\n\t\t\tif (b1->lower == b2->lower)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn b1->lower ? 1 : -1;\n\t\t}\n\t\telse if (!b1->inclusive)\n\t\t\treturn b1->lower ? 1 : -1;\n\t\telse if (!b2->inclusive)\n\t\t\treturn b2->lower ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Both are inclusive and the values held are equal, so they are\n\t\t\t * equal regardless of whether they are upper or lower boundaries,\n\t\t\t * or a mix.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/rangetypes.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"access/stratnum.h\"\n#include \"access/gist.h\"\n#include \"postgres.h\"\n\nstatic int\tsingle_bound_cmp(const void *a, const void *b, void *arg);\nstatic int\tinterval_cmp_lower(const void *a, const void *b, void *arg);\nstatic int\tinterval_cmp_upper(const void *a, const void *b, void *arg);\nstatic int\tcommon_entry_cmp(const void *i1, const void *i2);\n\nstatic int\nsingle_bound_cmp(const void *a, const void *b, void *arg)\n{\n\tSingleBoundSortItem *i1 = (SingleBoundSortItem *) a;\n\tSingleBoundSortItem *i2 = (SingleBoundSortItem *) b;\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) arg;\n\n\treturn range_cmp_bounds(typcache, &i1->bound, &i2->bound);\n}"
  },
  {
    "function_name": "get_gist_range_class",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_gist.c",
    "lines": "1435-1457",
    "snippet": "static int\nget_gist_range_class(RangeType *range)\n{\n\tint\t\t\tclassNumber;\n\tchar\t\tflags;\n\n\tflags = range_get_flags(range);\n\tif (flags & RANGE_EMPTY)\n\t{\n\t\tclassNumber = CLS_EMPTY;\n\t}\n\telse\n\t{\n\t\tclassNumber = 0;\n\t\tif (flags & RANGE_LB_INF)\n\t\t\tclassNumber |= CLS_LOWER_INF;\n\t\tif (flags & RANGE_UB_INF)\n\t\t\tclassNumber |= CLS_UPPER_INF;\n\t\tif (flags & RANGE_CONTAIN_EMPTY)\n\t\t\tclassNumber |= CLS_CONTAIN_EMPTY;\n\t}\n\treturn classNumber;\n}",
    "includes": [
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"access/stratnum.h\"",
      "#include \"access/gist.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define CLS_EMPTY\t\t\t8\t/* Special class for empty ranges */",
      "#define CLS_CONTAIN_EMPTY\t4\t/* Contains underlying empty ranges */",
      "#define CLS_UPPER_INF\t\t2\t/* Upper bound is infinity */",
      "#define CLS_LOWER_INF\t\t1\t/* Lower bound is infinity */"
    ],
    "globals_used": [
      "static int\tget_gist_range_class(RangeType *range);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "range_get_flags",
          "args": [
            "range"
          ],
          "line": 1441
        },
        "resolved": true,
        "details": {
          "function_name": "range_get_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1762-1767",
          "snippet": "char\nrange_get_flags(RangeType *range)\n{\n\t/* fetch the flag byte from datum's last byte */\n\treturn *((char *) range + VARSIZE(range) - 1);\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nchar\nrange_get_flags(RangeType *range)\n{\n\t/* fetch the flag byte from datum's last byte */\n\treturn *((char *) range + VARSIZE(range) - 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/rangetypes.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"access/stratnum.h\"\n#include \"access/gist.h\"\n#include \"postgres.h\"\n\n#define CLS_EMPTY\t\t\t8\t/* Special class for empty ranges */\n#define CLS_CONTAIN_EMPTY\t4\t/* Contains underlying empty ranges */\n#define CLS_UPPER_INF\t\t2\t/* Upper bound is infinity */\n#define CLS_LOWER_INF\t\t1\t/* Lower bound is infinity */\n\nstatic int\tget_gist_range_class(RangeType *range);\n\nstatic int\nget_gist_range_class(RangeType *range)\n{\n\tint\t\t\tclassNumber;\n\tchar\t\tflags;\n\n\tflags = range_get_flags(range);\n\tif (flags & RANGE_EMPTY)\n\t{\n\t\tclassNumber = CLS_EMPTY;\n\t}\n\telse\n\t{\n\t\tclassNumber = 0;\n\t\tif (flags & RANGE_LB_INF)\n\t\t\tclassNumber |= CLS_LOWER_INF;\n\t\tif (flags & RANGE_UB_INF)\n\t\t\tclassNumber |= CLS_UPPER_INF;\n\t\tif (flags & RANGE_CONTAIN_EMPTY)\n\t\t\tclassNumber |= CLS_CONTAIN_EMPTY;\n\t}\n\treturn classNumber;\n}"
  },
  {
    "function_name": "range_gist_consider_split",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_gist.c",
    "lines": "1352-1426",
    "snippet": "static void\nrange_gist_consider_split(ConsiderSplitContext *context,\n\t\t\t\t\t\t  RangeBound *right_lower, int min_left_count,\n\t\t\t\t\t\t  RangeBound *left_upper, int max_left_count)\n{\n\tint\t\t\tleft_count,\n\t\t\t\tright_count;\n\tfloat4\t\tratio,\n\t\t\t\toverlap;\n\n\t/*\n\t * Calculate entries distribution ratio assuming most uniform distribution\n\t * of common entries.\n\t */\n\tif (min_left_count >= (context->entries_count + 1) / 2)\n\t\tleft_count = min_left_count;\n\telse if (max_left_count <= context->entries_count / 2)\n\t\tleft_count = max_left_count;\n\telse\n\t\tleft_count = context->entries_count / 2;\n\tright_count = context->entries_count - left_count;\n\n\t/*\n\t * Ratio of split: quotient between size of smaller group and total\n\t * entries count.  This is necessarily 0.5 or less; if it's less than\n\t * LIMIT_RATIO then we will never accept the new split.\n\t */\n\tratio = ((float4) Min(left_count, right_count)) /\n\t\t((float4) context->entries_count);\n\n\tif (ratio > LIMIT_RATIO)\n\t{\n\t\tbool\t\tselectthis = false;\n\n\t\t/*\n\t\t * The ratio is acceptable, so compare current split with previously\n\t\t * selected one. We search for minimal overlap (allowing negative\n\t\t * values) and minimal ratio secondarily.  If subtype_diff is\n\t\t * available, it's used for overlap measure.  Without subtype_diff we\n\t\t * use number of \"common entries\" as an overlap measure.\n\t\t */\n\t\tif (context->has_subtype_diff)\n\t\t\toverlap = call_subtype_diff(context->typcache,\n\t\t\t\t\t\t\t\t\t\tleft_upper->val,\n\t\t\t\t\t\t\t\t\t\tright_lower->val);\n\t\telse\n\t\t\toverlap = max_left_count - min_left_count;\n\n\t\t/* If there is no previous selection, select this split */\n\t\tif (context->first)\n\t\t\tselectthis = true;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Choose the new split if it has a smaller overlap, or same\n\t\t\t * overlap but better ratio.\n\t\t\t */\n\t\t\tif (overlap < context->overlap ||\n\t\t\t\t(overlap == context->overlap && ratio > context->ratio))\n\t\t\t\tselectthis = true;\n\t\t}\n\n\t\tif (selectthis)\n\t\t{\n\t\t\t/* save information about selected split */\n\t\t\tcontext->first = false;\n\t\t\tcontext->ratio = ratio;\n\t\t\tcontext->overlap = overlap;\n\t\t\tcontext->right_lower = right_lower;\n\t\t\tcontext->left_upper = left_upper;\n\t\t\tcontext->common_left = max_left_count - left_count;\n\t\t\tcontext->common_right = left_count - min_left_count;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"access/stratnum.h\"",
      "#include \"access/gist.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define LIMIT_RATIO  0.3"
    ],
    "globals_used": [
      "static void range_gist_consider_split(ConsiderSplitContext *context,\n\t\t\t\t\t\t  RangeBound *right_lower, int min_left_count,\n\t\t\t\t\t\t  RangeBound *left_upper, int max_left_count);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_subtype_diff",
          "args": [
            "context->typcache",
            "left_upper->val",
            "right_lower->val"
          ],
          "line": 1394
        },
        "resolved": true,
        "details": {
          "function_name": "call_subtype_diff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_gist.c",
          "lines": "1519-1531",
          "snippet": "static float8\ncall_subtype_diff(TypeCacheEntry *typcache, Datum val1, Datum val2)\n{\n\tfloat8\t\tvalue;\n\n\tvalue = DatumGetFloat8(FunctionCall2Coll(&typcache->rng_subdiff_finfo,\n\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t val1, val2));\n\t/* Cope with buggy subtype_diff function by returning zero */\n\tif (value >= 0.0)\n\t\treturn value;\n\treturn 0.0;\n}",
          "includes": [
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"access/stratnum.h\"",
            "#include \"access/gist.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static float8 call_subtype_diff(TypeCacheEntry *typcache,\n\t\t\t\t  Datum val1, Datum val2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/rangetypes.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"access/stratnum.h\"\n#include \"access/gist.h\"\n#include \"postgres.h\"\n\nstatic float8 call_subtype_diff(TypeCacheEntry *typcache,\n\t\t\t\t  Datum val1, Datum val2);\n\nstatic float8\ncall_subtype_diff(TypeCacheEntry *typcache, Datum val1, Datum val2)\n{\n\tfloat8\t\tvalue;\n\n\tvalue = DatumGetFloat8(FunctionCall2Coll(&typcache->rng_subdiff_finfo,\n\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t val1, val2));\n\t/* Cope with buggy subtype_diff function by returning zero */\n\tif (value >= 0.0)\n\t\treturn value;\n\treturn 0.0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "left_count",
            "right_count"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/rangetypes.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"access/stratnum.h\"\n#include \"access/gist.h\"\n#include \"postgres.h\"\n\n#define LIMIT_RATIO  0.3\n\nstatic void range_gist_consider_split(ConsiderSplitContext *context,\n\t\t\t\t\t\t  RangeBound *right_lower, int min_left_count,\n\t\t\t\t\t\t  RangeBound *left_upper, int max_left_count);\n\nstatic void\nrange_gist_consider_split(ConsiderSplitContext *context,\n\t\t\t\t\t\t  RangeBound *right_lower, int min_left_count,\n\t\t\t\t\t\t  RangeBound *left_upper, int max_left_count)\n{\n\tint\t\t\tleft_count,\n\t\t\t\tright_count;\n\tfloat4\t\tratio,\n\t\t\t\toverlap;\n\n\t/*\n\t * Calculate entries distribution ratio assuming most uniform distribution\n\t * of common entries.\n\t */\n\tif (min_left_count >= (context->entries_count + 1) / 2)\n\t\tleft_count = min_left_count;\n\telse if (max_left_count <= context->entries_count / 2)\n\t\tleft_count = max_left_count;\n\telse\n\t\tleft_count = context->entries_count / 2;\n\tright_count = context->entries_count - left_count;\n\n\t/*\n\t * Ratio of split: quotient between size of smaller group and total\n\t * entries count.  This is necessarily 0.5 or less; if it's less than\n\t * LIMIT_RATIO then we will never accept the new split.\n\t */\n\tratio = ((float4) Min(left_count, right_count)) /\n\t\t((float4) context->entries_count);\n\n\tif (ratio > LIMIT_RATIO)\n\t{\n\t\tbool\t\tselectthis = false;\n\n\t\t/*\n\t\t * The ratio is acceptable, so compare current split with previously\n\t\t * selected one. We search for minimal overlap (allowing negative\n\t\t * values) and minimal ratio secondarily.  If subtype_diff is\n\t\t * available, it's used for overlap measure.  Without subtype_diff we\n\t\t * use number of \"common entries\" as an overlap measure.\n\t\t */\n\t\tif (context->has_subtype_diff)\n\t\t\toverlap = call_subtype_diff(context->typcache,\n\t\t\t\t\t\t\t\t\t\tleft_upper->val,\n\t\t\t\t\t\t\t\t\t\tright_lower->val);\n\t\telse\n\t\t\toverlap = max_left_count - min_left_count;\n\n\t\t/* If there is no previous selection, select this split */\n\t\tif (context->first)\n\t\t\tselectthis = true;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Choose the new split if it has a smaller overlap, or same\n\t\t\t * overlap but better ratio.\n\t\t\t */\n\t\t\tif (overlap < context->overlap ||\n\t\t\t\t(overlap == context->overlap && ratio > context->ratio))\n\t\t\t\tselectthis = true;\n\t\t}\n\n\t\tif (selectthis)\n\t\t{\n\t\t\t/* save information about selected split */\n\t\t\tcontext->first = false;\n\t\t\tcontext->ratio = ratio;\n\t\t\tcontext->overlap = overlap;\n\t\t\tcontext->right_lower = right_lower;\n\t\t\tcontext->left_upper = left_upper;\n\t\t\tcontext->common_left = max_left_count - left_count;\n\t\t\tcontext->common_right = left_count - min_left_count;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "range_gist_double_sorting_split",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_gist.c",
    "lines": "1050-1346",
    "snippet": "static void\nrange_gist_double_sorting_split(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t\tGistEntryVector *entryvec,\n\t\t\t\t\t\t\t\tGIST_SPLITVEC *v)\n{\n\tConsiderSplitContext context;\n\tOffsetNumber i,\n\t\t\t\tmaxoff;\n\tRangeType  *range,\n\t\t\t   *left_range = NULL,\n\t\t\t   *right_range = NULL;\n\tint\t\t\tcommon_entries_count;\n\tNonEmptyRange *by_lower,\n\t\t\t   *by_upper;\n\tCommonEntry *common_entries;\n\tint\t\t\tnentries,\n\t\t\t\ti1,\n\t\t\t\ti2;\n\tRangeBound *right_lower,\n\t\t\t   *left_upper;\n\n\tmemset(&context, 0, sizeof(ConsiderSplitContext));\n\tcontext.typcache = typcache;\n\tcontext.has_subtype_diff = OidIsValid(typcache->rng_subdiff_finfo.fn_oid);\n\n\tmaxoff = entryvec->n - 1;\n\tnentries = context.entries_count = maxoff - FirstOffsetNumber + 1;\n\tcontext.first = true;\n\n\t/* Allocate arrays for sorted range bounds */\n\tby_lower = (NonEmptyRange *) palloc(nentries * sizeof(NonEmptyRange));\n\tby_upper = (NonEmptyRange *) palloc(nentries * sizeof(NonEmptyRange));\n\n\t/* Fill arrays of bounds */\n\tfor (i = FirstOffsetNumber; i <= maxoff; i = OffsetNumberNext(i))\n\t{\n\t\tRangeType  *range = DatumGetRangeTypeP(entryvec->vector[i].key);\n\t\tbool\t\tempty;\n\n\t\trange_deserialize(typcache, range,\n\t\t\t\t\t\t  &by_lower[i - FirstOffsetNumber].lower,\n\t\t\t\t\t\t  &by_lower[i - FirstOffsetNumber].upper,\n\t\t\t\t\t\t  &empty);\n\t\tAssert(!empty);\n\t}\n\n\t/*\n\t * Make two arrays of range bounds: one sorted by lower bound and another\n\t * sorted by upper bound.\n\t */\n\tmemcpy(by_upper, by_lower, nentries * sizeof(NonEmptyRange));\n\tqsort_arg(by_lower, nentries, sizeof(NonEmptyRange),\n\t\t\t  interval_cmp_lower, typcache);\n\tqsort_arg(by_upper, nentries, sizeof(NonEmptyRange),\n\t\t\t  interval_cmp_upper, typcache);\n\n\t/*----------\n\t * The goal is to form a left and right range, so that every entry\n\t * range is contained by either left or right interval (or both).\n\t *\n\t * For example, with the ranges (0,1), (1,3), (2,3), (2,4):\n\t *\n\t * 0 1 2 3 4\n\t * +-+\n\t *\t +---+\n\t *\t   +-+\n\t *\t   +---+\n\t *\n\t * The left and right ranges are of the form (0,a) and (b,4).\n\t * We first consider splits where b is the lower bound of an entry.\n\t * We iterate through all entries, and for each b, calculate the\n\t * smallest possible a. Then we consider splits where a is the\n\t * upper bound of an entry, and for each a, calculate the greatest\n\t * possible b.\n\t *\n\t * In the above example, the first loop would consider splits:\n\t * b=0: (0,1)-(0,4)\n\t * b=1: (0,1)-(1,4)\n\t * b=2: (0,3)-(2,4)\n\t *\n\t * And the second loop:\n\t * a=1: (0,1)-(1,4)\n\t * a=3: (0,3)-(2,4)\n\t * a=4: (0,4)-(2,4)\n\t *----------\n\t */\n\n\t/*\n\t * Iterate over lower bound of right group, finding smallest possible\n\t * upper bound of left group.\n\t */\n\ti1 = 0;\n\ti2 = 0;\n\tright_lower = &by_lower[i1].lower;\n\tleft_upper = &by_upper[i2].lower;\n\twhile (true)\n\t{\n\t\t/*\n\t\t * Find next lower bound of right group.\n\t\t */\n\t\twhile (i1 < nentries &&\n\t\t\t   range_cmp_bounds(typcache, right_lower,\n\t\t\t\t\t\t\t\t&by_lower[i1].lower) == 0)\n\t\t{\n\t\t\tif (range_cmp_bounds(typcache, &by_lower[i1].upper,\n\t\t\t\t\t\t\t\t left_upper) > 0)\n\t\t\t\tleft_upper = &by_lower[i1].upper;\n\t\t\ti1++;\n\t\t}\n\t\tif (i1 >= nentries)\n\t\t\tbreak;\n\t\tright_lower = &by_lower[i1].lower;\n\n\t\t/*\n\t\t * Find count of ranges which anyway should be placed to the left\n\t\t * group.\n\t\t */\n\t\twhile (i2 < nentries &&\n\t\t\t   range_cmp_bounds(typcache, &by_upper[i2].upper,\n\t\t\t\t\t\t\t\tleft_upper) <= 0)\n\t\t\ti2++;\n\n\t\t/*\n\t\t * Consider found split to see if it's better than what we had.\n\t\t */\n\t\trange_gist_consider_split(&context, right_lower, i1, left_upper, i2);\n\t}\n\n\t/*\n\t * Iterate over upper bound of left group finding greatest possible lower\n\t * bound of right group.\n\t */\n\ti1 = nentries - 1;\n\ti2 = nentries - 1;\n\tright_lower = &by_lower[i1].upper;\n\tleft_upper = &by_upper[i2].upper;\n\twhile (true)\n\t{\n\t\t/*\n\t\t * Find next upper bound of left group.\n\t\t */\n\t\twhile (i2 >= 0 &&\n\t\t\t   range_cmp_bounds(typcache, left_upper,\n\t\t\t\t\t\t\t\t&by_upper[i2].upper) == 0)\n\t\t{\n\t\t\tif (range_cmp_bounds(typcache, &by_upper[i2].lower,\n\t\t\t\t\t\t\t\t right_lower) < 0)\n\t\t\t\tright_lower = &by_upper[i2].lower;\n\t\t\ti2--;\n\t\t}\n\t\tif (i2 < 0)\n\t\t\tbreak;\n\t\tleft_upper = &by_upper[i2].upper;\n\n\t\t/*\n\t\t * Find count of intervals which anyway should be placed to the right\n\t\t * group.\n\t\t */\n\t\twhile (i1 >= 0 &&\n\t\t\t   range_cmp_bounds(typcache, &by_lower[i1].lower,\n\t\t\t\t\t\t\t\tright_lower) >= 0)\n\t\t\ti1--;\n\n\t\t/*\n\t\t * Consider found split to see if it's better than what we had.\n\t\t */\n\t\trange_gist_consider_split(&context, right_lower, i1 + 1,\n\t\t\t\t\t\t\t\t  left_upper, i2 + 1);\n\t}\n\n\t/*\n\t * If we failed to find any acceptable splits, use trivial split.\n\t */\n\tif (context.first)\n\t{\n\t\trange_gist_fallback_split(typcache, entryvec, v);\n\t\treturn;\n\t}\n\n\t/*\n\t * Ok, we have now selected bounds of the groups. Now we have to\n\t * distribute entries themselves. At first we distribute entries which can\n\t * be placed unambiguously and collect \"common entries\" to array.\n\t */\n\n\t/* Allocate vectors for results */\n\tv->spl_left = (OffsetNumber *) palloc(nentries * sizeof(OffsetNumber));\n\tv->spl_right = (OffsetNumber *) palloc(nentries * sizeof(OffsetNumber));\n\tv->spl_nleft = 0;\n\tv->spl_nright = 0;\n\n\t/*\n\t * Allocate an array for \"common entries\" - entries which can be placed to\n\t * either group without affecting overlap along selected axis.\n\t */\n\tcommon_entries_count = 0;\n\tcommon_entries = (CommonEntry *) palloc(nentries * sizeof(CommonEntry));\n\n\t/*\n\t * Distribute entries which can be distributed unambiguously, and collect\n\t * common entries.\n\t */\n\tfor (i = FirstOffsetNumber; i <= maxoff; i = OffsetNumberNext(i))\n\t{\n\t\tRangeBound\tlower,\n\t\t\t\t\tupper;\n\t\tbool\t\tempty;\n\n\t\t/*\n\t\t * Get upper and lower bounds along selected axis.\n\t\t */\n\t\trange = DatumGetRangeTypeP(entryvec->vector[i].key);\n\n\t\trange_deserialize(typcache, range, &lower, &upper, &empty);\n\n\t\tif (range_cmp_bounds(typcache, &upper, context.left_upper) <= 0)\n\t\t{\n\t\t\t/* Fits in the left group */\n\t\t\tif (range_cmp_bounds(typcache, &lower, context.right_lower) >= 0)\n\t\t\t{\n\t\t\t\t/* Fits also in the right group, so \"common entry\" */\n\t\t\t\tcommon_entries[common_entries_count].index = i;\n\t\t\t\tif (context.has_subtype_diff)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * delta = (lower - context.right_lower) -\n\t\t\t\t\t * (context.left_upper - upper)\n\t\t\t\t\t */\n\t\t\t\t\tcommon_entries[common_entries_count].delta =\n\t\t\t\t\t\tcall_subtype_diff(typcache,\n\t\t\t\t\t\t\t\t\t\t  lower.val,\n\t\t\t\t\t\t\t\t\t\t  context.right_lower->val) -\n\t\t\t\t\t\tcall_subtype_diff(typcache,\n\t\t\t\t\t\t\t\t\t\t  context.left_upper->val,\n\t\t\t\t\t\t\t\t\t\t  upper.val);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* Without subtype_diff, take all deltas as zero */\n\t\t\t\t\tcommon_entries[common_entries_count].delta = 0;\n\t\t\t\t}\n\t\t\t\tcommon_entries_count++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Doesn't fit to the right group, so join to the left group */\n\t\t\t\tPLACE_LEFT(range, i);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Each entry should fit on either left or right group. Since this\n\t\t\t * entry didn't fit in the left group, it better fit in the right\n\t\t\t * group.\n\t\t\t */\n\t\t\tAssert(range_cmp_bounds(typcache, &lower,\n\t\t\t\t\t\t\t\t\tcontext.right_lower) >= 0);\n\t\t\tPLACE_RIGHT(range, i);\n\t\t}\n\t}\n\n\t/*\n\t * Distribute \"common entries\", if any.\n\t */\n\tif (common_entries_count > 0)\n\t{\n\t\t/*\n\t\t * Sort \"common entries\" by calculated deltas in order to distribute\n\t\t * the most ambiguous entries first.\n\t\t */\n\t\tqsort(common_entries, common_entries_count, sizeof(CommonEntry),\n\t\t\t  common_entry_cmp);\n\n\t\t/*\n\t\t * Distribute \"common entries\" between groups according to sorting.\n\t\t */\n\t\tfor (i = 0; i < common_entries_count; i++)\n\t\t{\n\t\t\tint\t\t\tidx = common_entries[i].index;\n\n\t\t\trange = DatumGetRangeTypeP(entryvec->vector[idx].key);\n\n\t\t\t/*\n\t\t\t * Check if we have to place this entry in either group to achieve\n\t\t\t * LIMIT_RATIO.\n\t\t\t */\n\t\t\tif (i < context.common_left)\n\t\t\t\tPLACE_LEFT(range, idx);\n\t\t\telse\n\t\t\t\tPLACE_RIGHT(range, idx);\n\t\t}\n\t}\n\n\tv->spl_ldatum = PointerGetDatum(left_range);\n\tv->spl_rdatum = PointerGetDatum(right_range);\n}",
    "includes": [
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"access/stratnum.h\"",
      "#include \"access/gist.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define LIMIT_RATIO  0.3"
    ],
    "globals_used": [
      "static void range_gist_fallback_split(TypeCacheEntry *typcache,\n\t\t\t\t\t\t  GistEntryVector *entryvec,\n\t\t\t\t\t\t  GIST_SPLITVEC *v);",
      "static void range_gist_double_sorting_split(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t\tGistEntryVector *entryvec,\n\t\t\t\t\t\t\t\tGIST_SPLITVEC *v);",
      "static int\tget_gist_range_class(RangeType *range);",
      "static int\tcommon_entry_cmp(const void *i1, const void *i2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "right_range"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "left_range"
          ],
          "line": 1344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PLACE_RIGHT",
          "args": [
            "range",
            "idx"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PLACE_LEFT",
          "args": [
            "range",
            "idx"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetRangeTypeP",
          "args": [
            "entryvec->vector[idx].key"
          ],
          "line": 1331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qsort",
          "args": [
            "common_entries",
            "common_entries_count",
            "sizeof(CommonEntry)",
            "common_entry_cmp"
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PLACE_RIGHT",
          "args": [
            "range",
            "i"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "range_cmp_bounds(typcache, &lower,\n\t\t\t\t\t\t\t\t\tcontext.right_lower) >= 0"
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_cmp_bounds",
          "args": [
            "typcache",
            "&lower",
            "context.right_lower"
          ],
          "line": 1306
        },
        "resolved": true,
        "details": {
          "function_name": "range_cmp_bounds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1831-1894",
          "snippet": "int\nrange_cmp_bounds(TypeCacheEntry *typcache, RangeBound *b1, RangeBound *b2)\n{\n\tint32\t\tresult;\n\n\t/*\n\t * First, handle cases involving infinity, which don't require invoking\n\t * the comparison proc.\n\t */\n\tif (b1->infinite && b2->infinite)\n\t{\n\t\t/*\n\t\t * Both are infinity, so they are equal unless one is lower and the\n\t\t * other not.\n\t\t */\n\t\tif (b1->lower == b2->lower)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn b1->lower ? -1 : 1;\n\t}\n\telse if (b1->infinite)\n\t\treturn b1->lower ? -1 : 1;\n\telse if (b2->infinite)\n\t\treturn b2->lower ? 1 : -1;\n\n\t/*\n\t * Both boundaries are finite, so compare the held values.\n\t */\n\tresult = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t b1->val, b2->val));\n\n\t/*\n\t * If the comparison is anything other than equal, we're done. If they\n\t * compare equal though, we still have to consider whether the boundaries\n\t * are inclusive or exclusive.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (!b1->inclusive && !b2->inclusive)\n\t\t{\n\t\t\t/* both are exclusive */\n\t\t\tif (b1->lower == b2->lower)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn b1->lower ? 1 : -1;\n\t\t}\n\t\telse if (!b1->inclusive)\n\t\t\treturn b1->lower ? 1 : -1;\n\t\telse if (!b2->inclusive)\n\t\t\treturn b2->lower ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Both are inclusive and the values held are equal, so they are\n\t\t\t * equal regardless of whether they are upper or lower boundaries,\n\t\t\t * or a mix.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nint\nrange_cmp_bounds(TypeCacheEntry *typcache, RangeBound *b1, RangeBound *b2)\n{\n\tint32\t\tresult;\n\n\t/*\n\t * First, handle cases involving infinity, which don't require invoking\n\t * the comparison proc.\n\t */\n\tif (b1->infinite && b2->infinite)\n\t{\n\t\t/*\n\t\t * Both are infinity, so they are equal unless one is lower and the\n\t\t * other not.\n\t\t */\n\t\tif (b1->lower == b2->lower)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn b1->lower ? -1 : 1;\n\t}\n\telse if (b1->infinite)\n\t\treturn b1->lower ? -1 : 1;\n\telse if (b2->infinite)\n\t\treturn b2->lower ? 1 : -1;\n\n\t/*\n\t * Both boundaries are finite, so compare the held values.\n\t */\n\tresult = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t b1->val, b2->val));\n\n\t/*\n\t * If the comparison is anything other than equal, we're done. If they\n\t * compare equal though, we still have to consider whether the boundaries\n\t * are inclusive or exclusive.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (!b1->inclusive && !b2->inclusive)\n\t\t{\n\t\t\t/* both are exclusive */\n\t\t\tif (b1->lower == b2->lower)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn b1->lower ? 1 : -1;\n\t\t}\n\t\telse if (!b1->inclusive)\n\t\t\treturn b1->lower ? 1 : -1;\n\t\telse if (!b2->inclusive)\n\t\t\treturn b2->lower ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Both are inclusive and the values held are equal, so they are\n\t\t\t * equal regardless of whether they are upper or lower boundaries,\n\t\t\t * or a mix.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PLACE_LEFT",
          "args": [
            "range",
            "i"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call_subtype_diff",
          "args": [
            "typcache",
            "context.left_upper->val",
            "upper.val"
          ],
          "line": 1282
        },
        "resolved": true,
        "details": {
          "function_name": "call_subtype_diff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_gist.c",
          "lines": "1519-1531",
          "snippet": "static float8\ncall_subtype_diff(TypeCacheEntry *typcache, Datum val1, Datum val2)\n{\n\tfloat8\t\tvalue;\n\n\tvalue = DatumGetFloat8(FunctionCall2Coll(&typcache->rng_subdiff_finfo,\n\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t val1, val2));\n\t/* Cope with buggy subtype_diff function by returning zero */\n\tif (value >= 0.0)\n\t\treturn value;\n\treturn 0.0;\n}",
          "includes": [
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"access/stratnum.h\"",
            "#include \"access/gist.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static float8 call_subtype_diff(TypeCacheEntry *typcache,\n\t\t\t\t  Datum val1, Datum val2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/rangetypes.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"access/stratnum.h\"\n#include \"access/gist.h\"\n#include \"postgres.h\"\n\nstatic float8 call_subtype_diff(TypeCacheEntry *typcache,\n\t\t\t\t  Datum val1, Datum val2);\n\nstatic float8\ncall_subtype_diff(TypeCacheEntry *typcache, Datum val1, Datum val2)\n{\n\tfloat8\t\tvalue;\n\n\tvalue = DatumGetFloat8(FunctionCall2Coll(&typcache->rng_subdiff_finfo,\n\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t val1, val2));\n\t/* Cope with buggy subtype_diff function by returning zero */\n\tif (value >= 0.0)\n\t\treturn value;\n\treturn 0.0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_deserialize",
          "args": [
            "typcache",
            "range",
            "&lower",
            "&upper",
            "&empty"
          ],
          "line": 1263
        },
        "resolved": true,
        "details": {
          "function_name": "range_deserialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1695-1754",
          "snippet": "void\nrange_deserialize(TypeCacheEntry *typcache, RangeType *range,\n\t\t\t\t  RangeBound *lower, RangeBound *upper, bool *empty)\n{\n\tchar\t\tflags;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tPointer\t\tptr;\n\tDatum\t\tlbound;\n\tDatum\t\tubound;\n\n\t/* assert caller passed the right typcache entry */\n\tAssert(RangeTypeGetOid(range) == typcache->type_id);\n\n\t/* fetch the flag byte from datum's last byte */\n\tflags = *((char *) range + VARSIZE(range) - 1);\n\n\t/* fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\n\t/* initialize data pointer just after the range OID */\n\tptr = (Pointer) (range + 1);\n\n\t/* fetch lower bound, if any */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/* att_align_pointer cannot be necessary here */\n\t\tlbound = fetch_att(ptr, typbyval, typlen);\n\t\tptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);\n\t}\n\telse\n\t\tlbound = (Datum) 0;\n\n\t/* fetch upper bound, if any */\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);\n\t\tubound = fetch_att(ptr, typbyval, typlen);\n\t\t/* no need for att_addlength_pointer */\n\t}\n\telse\n\t\tubound = (Datum) 0;\n\n\t/* emit results */\n\n\t*empty = (flags & RANGE_EMPTY) != 0;\n\n\tlower->val = lbound;\n\tlower->infinite = (flags & RANGE_LB_INF) != 0;\n\tlower->inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower->lower = true;\n\n\tupper->val = ubound;\n\tupper->infinite = (flags & RANGE_UB_INF) != 0;\n\tupper->inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper->lower = false;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nvoid\nrange_deserialize(TypeCacheEntry *typcache, RangeType *range,\n\t\t\t\t  RangeBound *lower, RangeBound *upper, bool *empty)\n{\n\tchar\t\tflags;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tPointer\t\tptr;\n\tDatum\t\tlbound;\n\tDatum\t\tubound;\n\n\t/* assert caller passed the right typcache entry */\n\tAssert(RangeTypeGetOid(range) == typcache->type_id);\n\n\t/* fetch the flag byte from datum's last byte */\n\tflags = *((char *) range + VARSIZE(range) - 1);\n\n\t/* fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\n\t/* initialize data pointer just after the range OID */\n\tptr = (Pointer) (range + 1);\n\n\t/* fetch lower bound, if any */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/* att_align_pointer cannot be necessary here */\n\t\tlbound = fetch_att(ptr, typbyval, typlen);\n\t\tptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);\n\t}\n\telse\n\t\tlbound = (Datum) 0;\n\n\t/* fetch upper bound, if any */\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);\n\t\tubound = fetch_att(ptr, typbyval, typlen);\n\t\t/* no need for att_addlength_pointer */\n\t}\n\telse\n\t\tubound = (Datum) 0;\n\n\t/* emit results */\n\n\t*empty = (flags & RANGE_EMPTY) != 0;\n\n\tlower->val = lbound;\n\tlower->infinite = (flags & RANGE_LB_INF) != 0;\n\tlower->inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower->lower = true;\n\n\tupper->val = ubound;\n\tupper->infinite = (flags & RANGE_UB_INF) != 0;\n\tupper->inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper->lower = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetRangeTypeP",
          "args": [
            "entryvec->vector[i].key"
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OffsetNumberNext",
          "args": [
            "i"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "nentries * sizeof(CommonEntry)"
          ],
          "line": 1246
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_gist_fallback_split",
          "args": [
            "typcache",
            "entryvec",
            "v"
          ],
          "line": 1225
        },
        "resolved": true,
        "details": {
          "function_name": "range_gist_fallback_split",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_gist.c",
          "lines": "880-909",
          "snippet": "static void\nrange_gist_fallback_split(TypeCacheEntry *typcache,\n\t\t\t\t\t\t  GistEntryVector *entryvec,\n\t\t\t\t\t\t  GIST_SPLITVEC *v)\n{\n\tRangeType  *left_range = NULL;\n\tRangeType  *right_range = NULL;\n\tOffsetNumber i,\n\t\t\t\tmaxoff,\n\t\t\t\tsplit_idx;\n\n\tmaxoff = entryvec->n - 1;\n\t/* Split entries before this to left page, after to right: */\n\tsplit_idx = (maxoff - FirstOffsetNumber) / 2 + FirstOffsetNumber;\n\n\tv->spl_nleft = 0;\n\tv->spl_nright = 0;\n\tfor (i = FirstOffsetNumber; i <= maxoff; i++)\n\t{\n\t\tRangeType  *range = DatumGetRangeTypeP(entryvec->vector[i].key);\n\n\t\tif (i < split_idx)\n\t\t\tPLACE_LEFT(range, i);\n\t\telse\n\t\t\tPLACE_RIGHT(range, i);\n\t}\n\n\tv->spl_ldatum = RangeTypePGetDatum(left_range);\n\tv->spl_rdatum = RangeTypePGetDatum(right_range);\n}",
          "includes": [
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"access/stratnum.h\"",
            "#include \"access/gist.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void range_gist_fallback_split(TypeCacheEntry *typcache,\n\t\t\t\t\t\t  GistEntryVector *entryvec,\n\t\t\t\t\t\t  GIST_SPLITVEC *v);",
            "static void range_gist_double_sorting_split(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t\tGistEntryVector *entryvec,\n\t\t\t\t\t\t\t\tGIST_SPLITVEC *v);",
            "static int\tget_gist_range_class(RangeType *range);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/rangetypes.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"access/stratnum.h\"\n#include \"access/gist.h\"\n#include \"postgres.h\"\n\nstatic void range_gist_fallback_split(TypeCacheEntry *typcache,\n\t\t\t\t\t\t  GistEntryVector *entryvec,\n\t\t\t\t\t\t  GIST_SPLITVEC *v);\nstatic void range_gist_double_sorting_split(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t\tGistEntryVector *entryvec,\n\t\t\t\t\t\t\t\tGIST_SPLITVEC *v);\nstatic int\tget_gist_range_class(RangeType *range);\n\nstatic void\nrange_gist_fallback_split(TypeCacheEntry *typcache,\n\t\t\t\t\t\t  GistEntryVector *entryvec,\n\t\t\t\t\t\t  GIST_SPLITVEC *v)\n{\n\tRangeType  *left_range = NULL;\n\tRangeType  *right_range = NULL;\n\tOffsetNumber i,\n\t\t\t\tmaxoff,\n\t\t\t\tsplit_idx;\n\n\tmaxoff = entryvec->n - 1;\n\t/* Split entries before this to left page, after to right: */\n\tsplit_idx = (maxoff - FirstOffsetNumber) / 2 + FirstOffsetNumber;\n\n\tv->spl_nleft = 0;\n\tv->spl_nright = 0;\n\tfor (i = FirstOffsetNumber; i <= maxoff; i++)\n\t{\n\t\tRangeType  *range = DatumGetRangeTypeP(entryvec->vector[i].key);\n\n\t\tif (i < split_idx)\n\t\t\tPLACE_LEFT(range, i);\n\t\telse\n\t\t\tPLACE_RIGHT(range, i);\n\t}\n\n\tv->spl_ldatum = RangeTypePGetDatum(left_range);\n\tv->spl_rdatum = RangeTypePGetDatum(right_range);\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_gist_consider_split",
          "args": [
            "&context",
            "right_lower",
            "i1 + 1",
            "left_upper",
            "i2 + 1"
          ],
          "line": 1216
        },
        "resolved": true,
        "details": {
          "function_name": "range_gist_consider_split",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_gist.c",
          "lines": "1352-1426",
          "snippet": "static void\nrange_gist_consider_split(ConsiderSplitContext *context,\n\t\t\t\t\t\t  RangeBound *right_lower, int min_left_count,\n\t\t\t\t\t\t  RangeBound *left_upper, int max_left_count)\n{\n\tint\t\t\tleft_count,\n\t\t\t\tright_count;\n\tfloat4\t\tratio,\n\t\t\t\toverlap;\n\n\t/*\n\t * Calculate entries distribution ratio assuming most uniform distribution\n\t * of common entries.\n\t */\n\tif (min_left_count >= (context->entries_count + 1) / 2)\n\t\tleft_count = min_left_count;\n\telse if (max_left_count <= context->entries_count / 2)\n\t\tleft_count = max_left_count;\n\telse\n\t\tleft_count = context->entries_count / 2;\n\tright_count = context->entries_count - left_count;\n\n\t/*\n\t * Ratio of split: quotient between size of smaller group and total\n\t * entries count.  This is necessarily 0.5 or less; if it's less than\n\t * LIMIT_RATIO then we will never accept the new split.\n\t */\n\tratio = ((float4) Min(left_count, right_count)) /\n\t\t((float4) context->entries_count);\n\n\tif (ratio > LIMIT_RATIO)\n\t{\n\t\tbool\t\tselectthis = false;\n\n\t\t/*\n\t\t * The ratio is acceptable, so compare current split with previously\n\t\t * selected one. We search for minimal overlap (allowing negative\n\t\t * values) and minimal ratio secondarily.  If subtype_diff is\n\t\t * available, it's used for overlap measure.  Without subtype_diff we\n\t\t * use number of \"common entries\" as an overlap measure.\n\t\t */\n\t\tif (context->has_subtype_diff)\n\t\t\toverlap = call_subtype_diff(context->typcache,\n\t\t\t\t\t\t\t\t\t\tleft_upper->val,\n\t\t\t\t\t\t\t\t\t\tright_lower->val);\n\t\telse\n\t\t\toverlap = max_left_count - min_left_count;\n\n\t\t/* If there is no previous selection, select this split */\n\t\tif (context->first)\n\t\t\tselectthis = true;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Choose the new split if it has a smaller overlap, or same\n\t\t\t * overlap but better ratio.\n\t\t\t */\n\t\t\tif (overlap < context->overlap ||\n\t\t\t\t(overlap == context->overlap && ratio > context->ratio))\n\t\t\t\tselectthis = true;\n\t\t}\n\n\t\tif (selectthis)\n\t\t{\n\t\t\t/* save information about selected split */\n\t\t\tcontext->first = false;\n\t\t\tcontext->ratio = ratio;\n\t\t\tcontext->overlap = overlap;\n\t\t\tcontext->right_lower = right_lower;\n\t\t\tcontext->left_upper = left_upper;\n\t\t\tcontext->common_left = max_left_count - left_count;\n\t\t\tcontext->common_right = left_count - min_left_count;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"access/stratnum.h\"",
            "#include \"access/gist.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define LIMIT_RATIO  0.3"
          ],
          "globals_used": [
            "static void range_gist_consider_split(ConsiderSplitContext *context,\n\t\t\t\t\t\t  RangeBound *right_lower, int min_left_count,\n\t\t\t\t\t\t  RangeBound *left_upper, int max_left_count);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/rangetypes.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"access/stratnum.h\"\n#include \"access/gist.h\"\n#include \"postgres.h\"\n\n#define LIMIT_RATIO  0.3\n\nstatic void range_gist_consider_split(ConsiderSplitContext *context,\n\t\t\t\t\t\t  RangeBound *right_lower, int min_left_count,\n\t\t\t\t\t\t  RangeBound *left_upper, int max_left_count);\n\nstatic void\nrange_gist_consider_split(ConsiderSplitContext *context,\n\t\t\t\t\t\t  RangeBound *right_lower, int min_left_count,\n\t\t\t\t\t\t  RangeBound *left_upper, int max_left_count)\n{\n\tint\t\t\tleft_count,\n\t\t\t\tright_count;\n\tfloat4\t\tratio,\n\t\t\t\toverlap;\n\n\t/*\n\t * Calculate entries distribution ratio assuming most uniform distribution\n\t * of common entries.\n\t */\n\tif (min_left_count >= (context->entries_count + 1) / 2)\n\t\tleft_count = min_left_count;\n\telse if (max_left_count <= context->entries_count / 2)\n\t\tleft_count = max_left_count;\n\telse\n\t\tleft_count = context->entries_count / 2;\n\tright_count = context->entries_count - left_count;\n\n\t/*\n\t * Ratio of split: quotient between size of smaller group and total\n\t * entries count.  This is necessarily 0.5 or less; if it's less than\n\t * LIMIT_RATIO then we will never accept the new split.\n\t */\n\tratio = ((float4) Min(left_count, right_count)) /\n\t\t((float4) context->entries_count);\n\n\tif (ratio > LIMIT_RATIO)\n\t{\n\t\tbool\t\tselectthis = false;\n\n\t\t/*\n\t\t * The ratio is acceptable, so compare current split with previously\n\t\t * selected one. We search for minimal overlap (allowing negative\n\t\t * values) and minimal ratio secondarily.  If subtype_diff is\n\t\t * available, it's used for overlap measure.  Without subtype_diff we\n\t\t * use number of \"common entries\" as an overlap measure.\n\t\t */\n\t\tif (context->has_subtype_diff)\n\t\t\toverlap = call_subtype_diff(context->typcache,\n\t\t\t\t\t\t\t\t\t\tleft_upper->val,\n\t\t\t\t\t\t\t\t\t\tright_lower->val);\n\t\telse\n\t\t\toverlap = max_left_count - min_left_count;\n\n\t\t/* If there is no previous selection, select this split */\n\t\tif (context->first)\n\t\t\tselectthis = true;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Choose the new split if it has a smaller overlap, or same\n\t\t\t * overlap but better ratio.\n\t\t\t */\n\t\t\tif (overlap < context->overlap ||\n\t\t\t\t(overlap == context->overlap && ratio > context->ratio))\n\t\t\t\tselectthis = true;\n\t\t}\n\n\t\tif (selectthis)\n\t\t{\n\t\t\t/* save information about selected split */\n\t\t\tcontext->first = false;\n\t\t\tcontext->ratio = ratio;\n\t\t\tcontext->overlap = overlap;\n\t\t\tcontext->right_lower = right_lower;\n\t\t\tcontext->left_upper = left_upper;\n\t\t\tcontext->common_left = max_left_count - left_count;\n\t\t\tcontext->common_right = left_count - min_left_count;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "qsort_arg",
          "args": [
            "by_upper",
            "nentries",
            "sizeof(NonEmptyRange)",
            "interval_cmp_upper",
            "typcache"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qsort_arg",
          "args": [
            "by_lower",
            "nentries",
            "sizeof(NonEmptyRange)",
            "interval_cmp_lower",
            "typcache"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "by_upper",
            "by_lower",
            "nentries * sizeof(NonEmptyRange)"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!empty"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetRangeTypeP",
          "args": [
            "entryvec->vector[i].key"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OffsetNumberNext",
          "args": [
            "i"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "typcache->rng_subdiff_finfo.fn_oid"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&context",
            "0",
            "sizeof(ConsiderSplitContext)"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/rangetypes.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"access/stratnum.h\"\n#include \"access/gist.h\"\n#include \"postgres.h\"\n\n#define LIMIT_RATIO  0.3\n\nstatic void range_gist_fallback_split(TypeCacheEntry *typcache,\n\t\t\t\t\t\t  GistEntryVector *entryvec,\n\t\t\t\t\t\t  GIST_SPLITVEC *v);\nstatic void range_gist_double_sorting_split(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t\tGistEntryVector *entryvec,\n\t\t\t\t\t\t\t\tGIST_SPLITVEC *v);\nstatic int\tget_gist_range_class(RangeType *range);\nstatic int\tcommon_entry_cmp(const void *i1, const void *i2);\n\nstatic void\nrange_gist_double_sorting_split(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t\tGistEntryVector *entryvec,\n\t\t\t\t\t\t\t\tGIST_SPLITVEC *v)\n{\n\tConsiderSplitContext context;\n\tOffsetNumber i,\n\t\t\t\tmaxoff;\n\tRangeType  *range,\n\t\t\t   *left_range = NULL,\n\t\t\t   *right_range = NULL;\n\tint\t\t\tcommon_entries_count;\n\tNonEmptyRange *by_lower,\n\t\t\t   *by_upper;\n\tCommonEntry *common_entries;\n\tint\t\t\tnentries,\n\t\t\t\ti1,\n\t\t\t\ti2;\n\tRangeBound *right_lower,\n\t\t\t   *left_upper;\n\n\tmemset(&context, 0, sizeof(ConsiderSplitContext));\n\tcontext.typcache = typcache;\n\tcontext.has_subtype_diff = OidIsValid(typcache->rng_subdiff_finfo.fn_oid);\n\n\tmaxoff = entryvec->n - 1;\n\tnentries = context.entries_count = maxoff - FirstOffsetNumber + 1;\n\tcontext.first = true;\n\n\t/* Allocate arrays for sorted range bounds */\n\tby_lower = (NonEmptyRange *) palloc(nentries * sizeof(NonEmptyRange));\n\tby_upper = (NonEmptyRange *) palloc(nentries * sizeof(NonEmptyRange));\n\n\t/* Fill arrays of bounds */\n\tfor (i = FirstOffsetNumber; i <= maxoff; i = OffsetNumberNext(i))\n\t{\n\t\tRangeType  *range = DatumGetRangeTypeP(entryvec->vector[i].key);\n\t\tbool\t\tempty;\n\n\t\trange_deserialize(typcache, range,\n\t\t\t\t\t\t  &by_lower[i - FirstOffsetNumber].lower,\n\t\t\t\t\t\t  &by_lower[i - FirstOffsetNumber].upper,\n\t\t\t\t\t\t  &empty);\n\t\tAssert(!empty);\n\t}\n\n\t/*\n\t * Make two arrays of range bounds: one sorted by lower bound and another\n\t * sorted by upper bound.\n\t */\n\tmemcpy(by_upper, by_lower, nentries * sizeof(NonEmptyRange));\n\tqsort_arg(by_lower, nentries, sizeof(NonEmptyRange),\n\t\t\t  interval_cmp_lower, typcache);\n\tqsort_arg(by_upper, nentries, sizeof(NonEmptyRange),\n\t\t\t  interval_cmp_upper, typcache);\n\n\t/*----------\n\t * The goal is to form a left and right range, so that every entry\n\t * range is contained by either left or right interval (or both).\n\t *\n\t * For example, with the ranges (0,1), (1,3), (2,3), (2,4):\n\t *\n\t * 0 1 2 3 4\n\t * +-+\n\t *\t +---+\n\t *\t   +-+\n\t *\t   +---+\n\t *\n\t * The left and right ranges are of the form (0,a) and (b,4).\n\t * We first consider splits where b is the lower bound of an entry.\n\t * We iterate through all entries, and for each b, calculate the\n\t * smallest possible a. Then we consider splits where a is the\n\t * upper bound of an entry, and for each a, calculate the greatest\n\t * possible b.\n\t *\n\t * In the above example, the first loop would consider splits:\n\t * b=0: (0,1)-(0,4)\n\t * b=1: (0,1)-(1,4)\n\t * b=2: (0,3)-(2,4)\n\t *\n\t * And the second loop:\n\t * a=1: (0,1)-(1,4)\n\t * a=3: (0,3)-(2,4)\n\t * a=4: (0,4)-(2,4)\n\t *----------\n\t */\n\n\t/*\n\t * Iterate over lower bound of right group, finding smallest possible\n\t * upper bound of left group.\n\t */\n\ti1 = 0;\n\ti2 = 0;\n\tright_lower = &by_lower[i1].lower;\n\tleft_upper = &by_upper[i2].lower;\n\twhile (true)\n\t{\n\t\t/*\n\t\t * Find next lower bound of right group.\n\t\t */\n\t\twhile (i1 < nentries &&\n\t\t\t   range_cmp_bounds(typcache, right_lower,\n\t\t\t\t\t\t\t\t&by_lower[i1].lower) == 0)\n\t\t{\n\t\t\tif (range_cmp_bounds(typcache, &by_lower[i1].upper,\n\t\t\t\t\t\t\t\t left_upper) > 0)\n\t\t\t\tleft_upper = &by_lower[i1].upper;\n\t\t\ti1++;\n\t\t}\n\t\tif (i1 >= nentries)\n\t\t\tbreak;\n\t\tright_lower = &by_lower[i1].lower;\n\n\t\t/*\n\t\t * Find count of ranges which anyway should be placed to the left\n\t\t * group.\n\t\t */\n\t\twhile (i2 < nentries &&\n\t\t\t   range_cmp_bounds(typcache, &by_upper[i2].upper,\n\t\t\t\t\t\t\t\tleft_upper) <= 0)\n\t\t\ti2++;\n\n\t\t/*\n\t\t * Consider found split to see if it's better than what we had.\n\t\t */\n\t\trange_gist_consider_split(&context, right_lower, i1, left_upper, i2);\n\t}\n\n\t/*\n\t * Iterate over upper bound of left group finding greatest possible lower\n\t * bound of right group.\n\t */\n\ti1 = nentries - 1;\n\ti2 = nentries - 1;\n\tright_lower = &by_lower[i1].upper;\n\tleft_upper = &by_upper[i2].upper;\n\twhile (true)\n\t{\n\t\t/*\n\t\t * Find next upper bound of left group.\n\t\t */\n\t\twhile (i2 >= 0 &&\n\t\t\t   range_cmp_bounds(typcache, left_upper,\n\t\t\t\t\t\t\t\t&by_upper[i2].upper) == 0)\n\t\t{\n\t\t\tif (range_cmp_bounds(typcache, &by_upper[i2].lower,\n\t\t\t\t\t\t\t\t right_lower) < 0)\n\t\t\t\tright_lower = &by_upper[i2].lower;\n\t\t\ti2--;\n\t\t}\n\t\tif (i2 < 0)\n\t\t\tbreak;\n\t\tleft_upper = &by_upper[i2].upper;\n\n\t\t/*\n\t\t * Find count of intervals which anyway should be placed to the right\n\t\t * group.\n\t\t */\n\t\twhile (i1 >= 0 &&\n\t\t\t   range_cmp_bounds(typcache, &by_lower[i1].lower,\n\t\t\t\t\t\t\t\tright_lower) >= 0)\n\t\t\ti1--;\n\n\t\t/*\n\t\t * Consider found split to see if it's better than what we had.\n\t\t */\n\t\trange_gist_consider_split(&context, right_lower, i1 + 1,\n\t\t\t\t\t\t\t\t  left_upper, i2 + 1);\n\t}\n\n\t/*\n\t * If we failed to find any acceptable splits, use trivial split.\n\t */\n\tif (context.first)\n\t{\n\t\trange_gist_fallback_split(typcache, entryvec, v);\n\t\treturn;\n\t}\n\n\t/*\n\t * Ok, we have now selected bounds of the groups. Now we have to\n\t * distribute entries themselves. At first we distribute entries which can\n\t * be placed unambiguously and collect \"common entries\" to array.\n\t */\n\n\t/* Allocate vectors for results */\n\tv->spl_left = (OffsetNumber *) palloc(nentries * sizeof(OffsetNumber));\n\tv->spl_right = (OffsetNumber *) palloc(nentries * sizeof(OffsetNumber));\n\tv->spl_nleft = 0;\n\tv->spl_nright = 0;\n\n\t/*\n\t * Allocate an array for \"common entries\" - entries which can be placed to\n\t * either group without affecting overlap along selected axis.\n\t */\n\tcommon_entries_count = 0;\n\tcommon_entries = (CommonEntry *) palloc(nentries * sizeof(CommonEntry));\n\n\t/*\n\t * Distribute entries which can be distributed unambiguously, and collect\n\t * common entries.\n\t */\n\tfor (i = FirstOffsetNumber; i <= maxoff; i = OffsetNumberNext(i))\n\t{\n\t\tRangeBound\tlower,\n\t\t\t\t\tupper;\n\t\tbool\t\tempty;\n\n\t\t/*\n\t\t * Get upper and lower bounds along selected axis.\n\t\t */\n\t\trange = DatumGetRangeTypeP(entryvec->vector[i].key);\n\n\t\trange_deserialize(typcache, range, &lower, &upper, &empty);\n\n\t\tif (range_cmp_bounds(typcache, &upper, context.left_upper) <= 0)\n\t\t{\n\t\t\t/* Fits in the left group */\n\t\t\tif (range_cmp_bounds(typcache, &lower, context.right_lower) >= 0)\n\t\t\t{\n\t\t\t\t/* Fits also in the right group, so \"common entry\" */\n\t\t\t\tcommon_entries[common_entries_count].index = i;\n\t\t\t\tif (context.has_subtype_diff)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * delta = (lower - context.right_lower) -\n\t\t\t\t\t * (context.left_upper - upper)\n\t\t\t\t\t */\n\t\t\t\t\tcommon_entries[common_entries_count].delta =\n\t\t\t\t\t\tcall_subtype_diff(typcache,\n\t\t\t\t\t\t\t\t\t\t  lower.val,\n\t\t\t\t\t\t\t\t\t\t  context.right_lower->val) -\n\t\t\t\t\t\tcall_subtype_diff(typcache,\n\t\t\t\t\t\t\t\t\t\t  context.left_upper->val,\n\t\t\t\t\t\t\t\t\t\t  upper.val);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* Without subtype_diff, take all deltas as zero */\n\t\t\t\t\tcommon_entries[common_entries_count].delta = 0;\n\t\t\t\t}\n\t\t\t\tcommon_entries_count++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Doesn't fit to the right group, so join to the left group */\n\t\t\t\tPLACE_LEFT(range, i);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Each entry should fit on either left or right group. Since this\n\t\t\t * entry didn't fit in the left group, it better fit in the right\n\t\t\t * group.\n\t\t\t */\n\t\t\tAssert(range_cmp_bounds(typcache, &lower,\n\t\t\t\t\t\t\t\t\tcontext.right_lower) >= 0);\n\t\t\tPLACE_RIGHT(range, i);\n\t\t}\n\t}\n\n\t/*\n\t * Distribute \"common entries\", if any.\n\t */\n\tif (common_entries_count > 0)\n\t{\n\t\t/*\n\t\t * Sort \"common entries\" by calculated deltas in order to distribute\n\t\t * the most ambiguous entries first.\n\t\t */\n\t\tqsort(common_entries, common_entries_count, sizeof(CommonEntry),\n\t\t\t  common_entry_cmp);\n\n\t\t/*\n\t\t * Distribute \"common entries\" between groups according to sorting.\n\t\t */\n\t\tfor (i = 0; i < common_entries_count; i++)\n\t\t{\n\t\t\tint\t\t\tidx = common_entries[i].index;\n\n\t\t\trange = DatumGetRangeTypeP(entryvec->vector[idx].key);\n\n\t\t\t/*\n\t\t\t * Check if we have to place this entry in either group to achieve\n\t\t\t * LIMIT_RATIO.\n\t\t\t */\n\t\t\tif (i < context.common_left)\n\t\t\t\tPLACE_LEFT(range, idx);\n\t\t\telse\n\t\t\t\tPLACE_RIGHT(range, idx);\n\t\t}\n\t}\n\n\tv->spl_ldatum = PointerGetDatum(left_range);\n\tv->spl_rdatum = PointerGetDatum(right_range);\n}"
  },
  {
    "function_name": "range_gist_single_sorting_split",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_gist.c",
    "lines": "961-1020",
    "snippet": "static void\nrange_gist_single_sorting_split(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t\tGistEntryVector *entryvec,\n\t\t\t\t\t\t\t\tGIST_SPLITVEC *v,\n\t\t\t\t\t\t\t\tbool use_upper_bound)\n{\n\tSingleBoundSortItem *sortItems;\n\tRangeType  *left_range = NULL;\n\tRangeType  *right_range = NULL;\n\tOffsetNumber i,\n\t\t\t\tmaxoff,\n\t\t\t\tsplit_idx;\n\n\tmaxoff = entryvec->n - 1;\n\n\tsortItems = (SingleBoundSortItem *)\n\t\tpalloc(maxoff * sizeof(SingleBoundSortItem));\n\n\t/*\n\t * Prepare auxiliary array and sort the values.\n\t */\n\tfor (i = FirstOffsetNumber; i <= maxoff; i = OffsetNumberNext(i))\n\t{\n\t\tRangeType  *range = DatumGetRangeTypeP(entryvec->vector[i].key);\n\t\tRangeBound\tbound2;\n\t\tbool\t\tempty;\n\n\t\tsortItems[i - 1].index = i;\n\t\t/* Put appropriate bound into array */\n\t\tif (use_upper_bound)\n\t\t\trange_deserialize(typcache, range, &bound2,\n\t\t\t\t\t\t\t  &sortItems[i - 1].bound, &empty);\n\t\telse\n\t\t\trange_deserialize(typcache, range, &sortItems[i - 1].bound,\n\t\t\t\t\t\t\t  &bound2, &empty);\n\t\tAssert(!empty);\n\t}\n\n\tqsort_arg(sortItems, maxoff, sizeof(SingleBoundSortItem),\n\t\t\t  single_bound_cmp, typcache);\n\n\tsplit_idx = maxoff / 2;\n\n\tv->spl_nleft = 0;\n\tv->spl_nright = 0;\n\n\tfor (i = 0; i < maxoff; i++)\n\t{\n\t\tint\t\t\tidx = sortItems[i].index;\n\t\tRangeType  *range = DatumGetRangeTypeP(entryvec->vector[idx].key);\n\n\t\tif (i < split_idx)\n\t\t\tPLACE_LEFT(range, idx);\n\t\telse\n\t\t\tPLACE_RIGHT(range, idx);\n\t}\n\n\tv->spl_ldatum = RangeTypePGetDatum(left_range);\n\tv->spl_rdatum = RangeTypePGetDatum(right_range);\n}",
    "includes": [
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"access/stratnum.h\"",
      "#include \"access/gist.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void range_gist_fallback_split(TypeCacheEntry *typcache,\n\t\t\t\t\t\t  GistEntryVector *entryvec,\n\t\t\t\t\t\t  GIST_SPLITVEC *v);",
      "static void range_gist_single_sorting_split(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t\tGistEntryVector *entryvec,\n\t\t\t\t\t\t\t\tGIST_SPLITVEC *v,\n\t\t\t\t\t\t\t\tbool use_upper_bound);",
      "static void range_gist_double_sorting_split(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t\tGistEntryVector *entryvec,\n\t\t\t\t\t\t\t\tGIST_SPLITVEC *v);",
      "static int\tget_gist_range_class(RangeType *range);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RangeTypePGetDatum",
          "args": [
            "right_range"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RangeTypePGetDatum",
          "args": [
            "left_range"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PLACE_RIGHT",
          "args": [
            "range",
            "idx"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PLACE_LEFT",
          "args": [
            "range",
            "idx"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetRangeTypeP",
          "args": [
            "entryvec->vector[idx].key"
          ],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qsort_arg",
          "args": [
            "sortItems",
            "maxoff",
            "sizeof(SingleBoundSortItem)",
            "single_bound_cmp",
            "typcache"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!empty"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_deserialize",
          "args": [
            "typcache",
            "range",
            "&sortItems[i - 1].bound",
            "&bound2",
            "&empty"
          ],
          "line": 994
        },
        "resolved": true,
        "details": {
          "function_name": "range_deserialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1695-1754",
          "snippet": "void\nrange_deserialize(TypeCacheEntry *typcache, RangeType *range,\n\t\t\t\t  RangeBound *lower, RangeBound *upper, bool *empty)\n{\n\tchar\t\tflags;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tPointer\t\tptr;\n\tDatum\t\tlbound;\n\tDatum\t\tubound;\n\n\t/* assert caller passed the right typcache entry */\n\tAssert(RangeTypeGetOid(range) == typcache->type_id);\n\n\t/* fetch the flag byte from datum's last byte */\n\tflags = *((char *) range + VARSIZE(range) - 1);\n\n\t/* fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\n\t/* initialize data pointer just after the range OID */\n\tptr = (Pointer) (range + 1);\n\n\t/* fetch lower bound, if any */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/* att_align_pointer cannot be necessary here */\n\t\tlbound = fetch_att(ptr, typbyval, typlen);\n\t\tptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);\n\t}\n\telse\n\t\tlbound = (Datum) 0;\n\n\t/* fetch upper bound, if any */\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);\n\t\tubound = fetch_att(ptr, typbyval, typlen);\n\t\t/* no need for att_addlength_pointer */\n\t}\n\telse\n\t\tubound = (Datum) 0;\n\n\t/* emit results */\n\n\t*empty = (flags & RANGE_EMPTY) != 0;\n\n\tlower->val = lbound;\n\tlower->infinite = (flags & RANGE_LB_INF) != 0;\n\tlower->inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower->lower = true;\n\n\tupper->val = ubound;\n\tupper->infinite = (flags & RANGE_UB_INF) != 0;\n\tupper->inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper->lower = false;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nvoid\nrange_deserialize(TypeCacheEntry *typcache, RangeType *range,\n\t\t\t\t  RangeBound *lower, RangeBound *upper, bool *empty)\n{\n\tchar\t\tflags;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tPointer\t\tptr;\n\tDatum\t\tlbound;\n\tDatum\t\tubound;\n\n\t/* assert caller passed the right typcache entry */\n\tAssert(RangeTypeGetOid(range) == typcache->type_id);\n\n\t/* fetch the flag byte from datum's last byte */\n\tflags = *((char *) range + VARSIZE(range) - 1);\n\n\t/* fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\n\t/* initialize data pointer just after the range OID */\n\tptr = (Pointer) (range + 1);\n\n\t/* fetch lower bound, if any */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/* att_align_pointer cannot be necessary here */\n\t\tlbound = fetch_att(ptr, typbyval, typlen);\n\t\tptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);\n\t}\n\telse\n\t\tlbound = (Datum) 0;\n\n\t/* fetch upper bound, if any */\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);\n\t\tubound = fetch_att(ptr, typbyval, typlen);\n\t\t/* no need for att_addlength_pointer */\n\t}\n\telse\n\t\tubound = (Datum) 0;\n\n\t/* emit results */\n\n\t*empty = (flags & RANGE_EMPTY) != 0;\n\n\tlower->val = lbound;\n\tlower->infinite = (flags & RANGE_LB_INF) != 0;\n\tlower->inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower->lower = true;\n\n\tupper->val = ubound;\n\tupper->infinite = (flags & RANGE_UB_INF) != 0;\n\tupper->inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper->lower = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetRangeTypeP",
          "args": [
            "entryvec->vector[i].key"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OffsetNumberNext",
          "args": [
            "i"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "maxoff * sizeof(SingleBoundSortItem)"
          ],
          "line": 977
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/rangetypes.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"access/stratnum.h\"\n#include \"access/gist.h\"\n#include \"postgres.h\"\n\nstatic void range_gist_fallback_split(TypeCacheEntry *typcache,\n\t\t\t\t\t\t  GistEntryVector *entryvec,\n\t\t\t\t\t\t  GIST_SPLITVEC *v);\nstatic void range_gist_single_sorting_split(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t\tGistEntryVector *entryvec,\n\t\t\t\t\t\t\t\tGIST_SPLITVEC *v,\n\t\t\t\t\t\t\t\tbool use_upper_bound);\nstatic void range_gist_double_sorting_split(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t\tGistEntryVector *entryvec,\n\t\t\t\t\t\t\t\tGIST_SPLITVEC *v);\nstatic int\tget_gist_range_class(RangeType *range);\n\nstatic void\nrange_gist_single_sorting_split(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t\tGistEntryVector *entryvec,\n\t\t\t\t\t\t\t\tGIST_SPLITVEC *v,\n\t\t\t\t\t\t\t\tbool use_upper_bound)\n{\n\tSingleBoundSortItem *sortItems;\n\tRangeType  *left_range = NULL;\n\tRangeType  *right_range = NULL;\n\tOffsetNumber i,\n\t\t\t\tmaxoff,\n\t\t\t\tsplit_idx;\n\n\tmaxoff = entryvec->n - 1;\n\n\tsortItems = (SingleBoundSortItem *)\n\t\tpalloc(maxoff * sizeof(SingleBoundSortItem));\n\n\t/*\n\t * Prepare auxiliary array and sort the values.\n\t */\n\tfor (i = FirstOffsetNumber; i <= maxoff; i = OffsetNumberNext(i))\n\t{\n\t\tRangeType  *range = DatumGetRangeTypeP(entryvec->vector[i].key);\n\t\tRangeBound\tbound2;\n\t\tbool\t\tempty;\n\n\t\tsortItems[i - 1].index = i;\n\t\t/* Put appropriate bound into array */\n\t\tif (use_upper_bound)\n\t\t\trange_deserialize(typcache, range, &bound2,\n\t\t\t\t\t\t\t  &sortItems[i - 1].bound, &empty);\n\t\telse\n\t\t\trange_deserialize(typcache, range, &sortItems[i - 1].bound,\n\t\t\t\t\t\t\t  &bound2, &empty);\n\t\tAssert(!empty);\n\t}\n\n\tqsort_arg(sortItems, maxoff, sizeof(SingleBoundSortItem),\n\t\t\t  single_bound_cmp, typcache);\n\n\tsplit_idx = maxoff / 2;\n\n\tv->spl_nleft = 0;\n\tv->spl_nright = 0;\n\n\tfor (i = 0; i < maxoff; i++)\n\t{\n\t\tint\t\t\tidx = sortItems[i].index;\n\t\tRangeType  *range = DatumGetRangeTypeP(entryvec->vector[idx].key);\n\n\t\tif (i < split_idx)\n\t\t\tPLACE_LEFT(range, idx);\n\t\telse\n\t\t\tPLACE_RIGHT(range, idx);\n\t}\n\n\tv->spl_ldatum = RangeTypePGetDatum(left_range);\n\tv->spl_rdatum = RangeTypePGetDatum(right_range);\n}"
  },
  {
    "function_name": "range_gist_class_split",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_gist.c",
    "lines": "918-953",
    "snippet": "static void\nrange_gist_class_split(TypeCacheEntry *typcache,\n\t\t\t\t\t   GistEntryVector *entryvec,\n\t\t\t\t\t   GIST_SPLITVEC *v,\n\t\t\t\t\t   SplitLR *classes_groups)\n{\n\tRangeType  *left_range = NULL;\n\tRangeType  *right_range = NULL;\n\tOffsetNumber i,\n\t\t\t\tmaxoff;\n\n\tmaxoff = entryvec->n - 1;\n\n\tv->spl_nleft = 0;\n\tv->spl_nright = 0;\n\tfor (i = FirstOffsetNumber; i <= maxoff; i = OffsetNumberNext(i))\n\t{\n\t\tRangeType  *range = DatumGetRangeTypeP(entryvec->vector[i].key);\n\t\tint\t\t\tclass;\n\n\t\t/* Get class of range */\n\t\tclass = get_gist_range_class(range);\n\n\t\t/* Place range to appropriate page */\n\t\tif (classes_groups[class] == SPLIT_LEFT)\n\t\t\tPLACE_LEFT(range, i);\n\t\telse\n\t\t{\n\t\t\tAssert(classes_groups[class] == SPLIT_RIGHT);\n\t\t\tPLACE_RIGHT(range, i);\n\t\t}\n\t}\n\n\tv->spl_ldatum = RangeTypePGetDatum(left_range);\n\tv->spl_rdatum = RangeTypePGetDatum(right_range);\n}",
    "includes": [
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"access/stratnum.h\"",
      "#include \"access/gist.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void range_gist_fallback_split(TypeCacheEntry *typcache,\n\t\t\t\t\t\t  GistEntryVector *entryvec,\n\t\t\t\t\t\t  GIST_SPLITVEC *v);",
      "static void range_gist_class_split(TypeCacheEntry *typcache,\n\t\t\t\t\t   GistEntryVector *entryvec,\n\t\t\t\t\t   GIST_SPLITVEC *v,\n\t\t\t\t\t   SplitLR *classes_groups);",
      "static void range_gist_double_sorting_split(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t\tGistEntryVector *entryvec,\n\t\t\t\t\t\t\t\tGIST_SPLITVEC *v);",
      "static int\tget_gist_range_class(RangeType *range);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RangeTypePGetDatum",
          "args": [
            "right_range"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RangeTypePGetDatum",
          "args": [
            "left_range"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PLACE_RIGHT",
          "args": [
            "range",
            "i"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "classes_groups[class] == SPLIT_RIGHT"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PLACE_LEFT",
          "args": [
            "range",
            "i"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_gist_range_class",
          "args": [
            "range"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "get_gist_range_class",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_gist.c",
          "lines": "1435-1457",
          "snippet": "static int\nget_gist_range_class(RangeType *range)\n{\n\tint\t\t\tclassNumber;\n\tchar\t\tflags;\n\n\tflags = range_get_flags(range);\n\tif (flags & RANGE_EMPTY)\n\t{\n\t\tclassNumber = CLS_EMPTY;\n\t}\n\telse\n\t{\n\t\tclassNumber = 0;\n\t\tif (flags & RANGE_LB_INF)\n\t\t\tclassNumber |= CLS_LOWER_INF;\n\t\tif (flags & RANGE_UB_INF)\n\t\t\tclassNumber |= CLS_UPPER_INF;\n\t\tif (flags & RANGE_CONTAIN_EMPTY)\n\t\t\tclassNumber |= CLS_CONTAIN_EMPTY;\n\t}\n\treturn classNumber;\n}",
          "includes": [
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"access/stratnum.h\"",
            "#include \"access/gist.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define CLS_EMPTY\t\t\t8\t/* Special class for empty ranges */",
            "#define CLS_CONTAIN_EMPTY\t4\t/* Contains underlying empty ranges */",
            "#define CLS_UPPER_INF\t\t2\t/* Upper bound is infinity */",
            "#define CLS_LOWER_INF\t\t1\t/* Lower bound is infinity */"
          ],
          "globals_used": [
            "static int\tget_gist_range_class(RangeType *range);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/rangetypes.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"access/stratnum.h\"\n#include \"access/gist.h\"\n#include \"postgres.h\"\n\n#define CLS_EMPTY\t\t\t8\t/* Special class for empty ranges */\n#define CLS_CONTAIN_EMPTY\t4\t/* Contains underlying empty ranges */\n#define CLS_UPPER_INF\t\t2\t/* Upper bound is infinity */\n#define CLS_LOWER_INF\t\t1\t/* Lower bound is infinity */\n\nstatic int\tget_gist_range_class(RangeType *range);\n\nstatic int\nget_gist_range_class(RangeType *range)\n{\n\tint\t\t\tclassNumber;\n\tchar\t\tflags;\n\n\tflags = range_get_flags(range);\n\tif (flags & RANGE_EMPTY)\n\t{\n\t\tclassNumber = CLS_EMPTY;\n\t}\n\telse\n\t{\n\t\tclassNumber = 0;\n\t\tif (flags & RANGE_LB_INF)\n\t\t\tclassNumber |= CLS_LOWER_INF;\n\t\tif (flags & RANGE_UB_INF)\n\t\t\tclassNumber |= CLS_UPPER_INF;\n\t\tif (flags & RANGE_CONTAIN_EMPTY)\n\t\t\tclassNumber |= CLS_CONTAIN_EMPTY;\n\t}\n\treturn classNumber;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetRangeTypeP",
          "args": [
            "entryvec->vector[i].key"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OffsetNumberNext",
          "args": [
            "i"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/rangetypes.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"access/stratnum.h\"\n#include \"access/gist.h\"\n#include \"postgres.h\"\n\nstatic void range_gist_fallback_split(TypeCacheEntry *typcache,\n\t\t\t\t\t\t  GistEntryVector *entryvec,\n\t\t\t\t\t\t  GIST_SPLITVEC *v);\nstatic void range_gist_class_split(TypeCacheEntry *typcache,\n\t\t\t\t\t   GistEntryVector *entryvec,\n\t\t\t\t\t   GIST_SPLITVEC *v,\n\t\t\t\t\t   SplitLR *classes_groups);\nstatic void range_gist_double_sorting_split(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t\tGistEntryVector *entryvec,\n\t\t\t\t\t\t\t\tGIST_SPLITVEC *v);\nstatic int\tget_gist_range_class(RangeType *range);\n\nstatic void\nrange_gist_class_split(TypeCacheEntry *typcache,\n\t\t\t\t\t   GistEntryVector *entryvec,\n\t\t\t\t\t   GIST_SPLITVEC *v,\n\t\t\t\t\t   SplitLR *classes_groups)\n{\n\tRangeType  *left_range = NULL;\n\tRangeType  *right_range = NULL;\n\tOffsetNumber i,\n\t\t\t\tmaxoff;\n\n\tmaxoff = entryvec->n - 1;\n\n\tv->spl_nleft = 0;\n\tv->spl_nright = 0;\n\tfor (i = FirstOffsetNumber; i <= maxoff; i = OffsetNumberNext(i))\n\t{\n\t\tRangeType  *range = DatumGetRangeTypeP(entryvec->vector[i].key);\n\t\tint\t\t\tclass;\n\n\t\t/* Get class of range */\n\t\tclass = get_gist_range_class(range);\n\n\t\t/* Place range to appropriate page */\n\t\tif (classes_groups[class] == SPLIT_LEFT)\n\t\t\tPLACE_LEFT(range, i);\n\t\telse\n\t\t{\n\t\t\tAssert(classes_groups[class] == SPLIT_RIGHT);\n\t\t\tPLACE_RIGHT(range, i);\n\t\t}\n\t}\n\n\tv->spl_ldatum = RangeTypePGetDatum(left_range);\n\tv->spl_rdatum = RangeTypePGetDatum(right_range);\n}"
  },
  {
    "function_name": "range_gist_fallback_split",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_gist.c",
    "lines": "880-909",
    "snippet": "static void\nrange_gist_fallback_split(TypeCacheEntry *typcache,\n\t\t\t\t\t\t  GistEntryVector *entryvec,\n\t\t\t\t\t\t  GIST_SPLITVEC *v)\n{\n\tRangeType  *left_range = NULL;\n\tRangeType  *right_range = NULL;\n\tOffsetNumber i,\n\t\t\t\tmaxoff,\n\t\t\t\tsplit_idx;\n\n\tmaxoff = entryvec->n - 1;\n\t/* Split entries before this to left page, after to right: */\n\tsplit_idx = (maxoff - FirstOffsetNumber) / 2 + FirstOffsetNumber;\n\n\tv->spl_nleft = 0;\n\tv->spl_nright = 0;\n\tfor (i = FirstOffsetNumber; i <= maxoff; i++)\n\t{\n\t\tRangeType  *range = DatumGetRangeTypeP(entryvec->vector[i].key);\n\n\t\tif (i < split_idx)\n\t\t\tPLACE_LEFT(range, i);\n\t\telse\n\t\t\tPLACE_RIGHT(range, i);\n\t}\n\n\tv->spl_ldatum = RangeTypePGetDatum(left_range);\n\tv->spl_rdatum = RangeTypePGetDatum(right_range);\n}",
    "includes": [
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"access/stratnum.h\"",
      "#include \"access/gist.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void range_gist_fallback_split(TypeCacheEntry *typcache,\n\t\t\t\t\t\t  GistEntryVector *entryvec,\n\t\t\t\t\t\t  GIST_SPLITVEC *v);",
      "static void range_gist_double_sorting_split(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t\tGistEntryVector *entryvec,\n\t\t\t\t\t\t\t\tGIST_SPLITVEC *v);",
      "static int\tget_gist_range_class(RangeType *range);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RangeTypePGetDatum",
          "args": [
            "right_range"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RangeTypePGetDatum",
          "args": [
            "left_range"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PLACE_RIGHT",
          "args": [
            "range",
            "i"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PLACE_LEFT",
          "args": [
            "range",
            "i"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetRangeTypeP",
          "args": [
            "entryvec->vector[i].key"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/rangetypes.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"access/stratnum.h\"\n#include \"access/gist.h\"\n#include \"postgres.h\"\n\nstatic void range_gist_fallback_split(TypeCacheEntry *typcache,\n\t\t\t\t\t\t  GistEntryVector *entryvec,\n\t\t\t\t\t\t  GIST_SPLITVEC *v);\nstatic void range_gist_double_sorting_split(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t\tGistEntryVector *entryvec,\n\t\t\t\t\t\t\t\tGIST_SPLITVEC *v);\nstatic int\tget_gist_range_class(RangeType *range);\n\nstatic void\nrange_gist_fallback_split(TypeCacheEntry *typcache,\n\t\t\t\t\t\t  GistEntryVector *entryvec,\n\t\t\t\t\t\t  GIST_SPLITVEC *v)\n{\n\tRangeType  *left_range = NULL;\n\tRangeType  *right_range = NULL;\n\tOffsetNumber i,\n\t\t\t\tmaxoff,\n\t\t\t\tsplit_idx;\n\n\tmaxoff = entryvec->n - 1;\n\t/* Split entries before this to left page, after to right: */\n\tsplit_idx = (maxoff - FirstOffsetNumber) / 2 + FirstOffsetNumber;\n\n\tv->spl_nleft = 0;\n\tv->spl_nright = 0;\n\tfor (i = FirstOffsetNumber; i <= maxoff; i++)\n\t{\n\t\tRangeType  *range = DatumGetRangeTypeP(entryvec->vector[i].key);\n\n\t\tif (i < split_idx)\n\t\t\tPLACE_LEFT(range, i);\n\t\telse\n\t\t\tPLACE_RIGHT(range, i);\n\t}\n\n\tv->spl_ldatum = RangeTypePGetDatum(left_range);\n\tv->spl_rdatum = RangeTypePGetDatum(right_range);\n}"
  },
  {
    "function_name": "range_gist_consistent_leaf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_gist.c",
    "lines": "836-874",
    "snippet": "static bool\nrange_gist_consistent_leaf(TypeCacheEntry *typcache, StrategyNumber strategy,\n\t\t\t\t\t\t   RangeType *key, Datum query)\n{\n\tswitch (strategy)\n\t{\n\t\tcase RANGESTRAT_BEFORE:\n\t\t\treturn range_before_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\t DatumGetRangeTypeP(query));\n\t\tcase RANGESTRAT_OVERLEFT:\n\t\t\treturn range_overleft_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\t   DatumGetRangeTypeP(query));\n\t\tcase RANGESTRAT_OVERLAPS:\n\t\t\treturn range_overlaps_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\t   DatumGetRangeTypeP(query));\n\t\tcase RANGESTRAT_OVERRIGHT:\n\t\t\treturn range_overright_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\t\tDatumGetRangeTypeP(query));\n\t\tcase RANGESTRAT_AFTER:\n\t\t\treturn range_after_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\tDatumGetRangeTypeP(query));\n\t\tcase RANGESTRAT_ADJACENT:\n\t\t\treturn range_adjacent_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\t   DatumGetRangeTypeP(query));\n\t\tcase RANGESTRAT_CONTAINS:\n\t\t\treturn range_contains_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\t   DatumGetRangeTypeP(query));\n\t\tcase RANGESTRAT_CONTAINED_BY:\n\t\t\treturn range_contained_by_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\t\t   DatumGetRangeTypeP(query));\n\t\tcase RANGESTRAT_CONTAINS_ELEM:\n\t\t\treturn range_contains_elem_internal(typcache, key, query);\n\t\tcase RANGESTRAT_EQ:\n\t\t\treturn range_eq_internal(typcache, key, DatumGetRangeTypeP(query));\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized range strategy: %d\", strategy);\n\t\t\treturn false;\t\t/* keep compiler quiet */\n\t}\n}",
    "includes": [
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"access/stratnum.h\"",
      "#include \"access/gist.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool range_gist_consistent_int(TypeCacheEntry *typcache,\n\t\t\t\t\t\t  StrategyNumber strategy, RangeType *key,\n\t\t\t\t\t\t  Datum query);",
      "static bool range_gist_consistent_leaf(TypeCacheEntry *typcache,\n\t\t\t\t\t\t   StrategyNumber strategy, RangeType *key,\n\t\t\t\t\t\t   Datum query);",
      "static int\tget_gist_range_class(RangeType *range);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unrecognized range strategy: %d\"",
            "strategy"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_eq_internal",
          "args": [
            "typcache",
            "key",
            "DatumGetRangeTypeP(query)"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "range_eq_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "555-584",
          "snippet": "bool\nrange_eq_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\tif (empty1 && empty2)\n\t\treturn true;\n\tif (empty1 != empty2)\n\t\treturn false;\n\n\tif (range_cmp_bounds(typcache, &lower1, &lower2) != 0)\n\t\treturn false;\n\n\tif (range_cmp_bounds(typcache, &upper1, &upper2) != 0)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nrange_eq_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\tif (empty1 && empty2)\n\t\treturn true;\n\tif (empty1 != empty2)\n\t\treturn false;\n\n\tif (range_cmp_bounds(typcache, &lower1, &lower2) != 0)\n\t\treturn false;\n\n\tif (range_cmp_bounds(typcache, &upper1, &upper2) != 0)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetRangeTypeP",
          "args": [
            "query"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_contains_elem_internal",
          "args": [
            "typcache",
            "key",
            "query"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "range_contains_elem_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "2340-2376",
          "snippet": "bool\nrange_contains_elem_internal(TypeCacheEntry *typcache, RangeType *r, Datum val)\n{\n\tRangeBound\tlower;\n\tRangeBound\tupper;\n\tbool\t\tempty;\n\tint32\t\tcmp;\n\n\trange_deserialize(typcache, r, &lower, &upper, &empty);\n\n\tif (empty)\n\t\treturn false;\n\n\tif (!lower.infinite)\n\t{\n\t\tcmp = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t  typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t  lower.val, val));\n\t\tif (cmp > 0)\n\t\t\treturn false;\n\t\tif (cmp == 0 && !lower.inclusive)\n\t\t\treturn false;\n\t}\n\n\tif (!upper.infinite)\n\t{\n\t\tcmp = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t  typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t  upper.val, val));\n\t\tif (cmp < 0)\n\t\t\treturn false;\n\t\tif (cmp == 0 && !upper.inclusive)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nbool\nrange_contains_elem_internal(TypeCacheEntry *typcache, RangeType *r, Datum val)\n{\n\tRangeBound\tlower;\n\tRangeBound\tupper;\n\tbool\t\tempty;\n\tint32\t\tcmp;\n\n\trange_deserialize(typcache, r, &lower, &upper, &empty);\n\n\tif (empty)\n\t\treturn false;\n\n\tif (!lower.infinite)\n\t{\n\t\tcmp = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t  typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t  lower.val, val));\n\t\tif (cmp > 0)\n\t\t\treturn false;\n\t\tif (cmp == 0 && !lower.inclusive)\n\t\t\treturn false;\n\t}\n\n\tif (!upper.infinite)\n\t{\n\t\tcmp = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t  typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t  upper.val, val));\n\t\tif (cmp < 0)\n\t\t\treturn false;\n\t\tif (cmp == 0 && !upper.inclusive)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_contained_by_internal",
          "args": [
            "typcache",
            "key",
            "DatumGetRangeTypeP(query)"
          ],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "range_contained_by_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "2331-2335",
          "snippet": "bool\nrange_contained_by_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\treturn range_contains_internal(typcache, r2, r1);\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nrange_contained_by_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\treturn range_contains_internal(typcache, r2, r1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetRangeTypeP",
          "args": [
            "query"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_contains_internal",
          "args": [
            "typcache",
            "key",
            "DatumGetRangeTypeP(query)"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "range_contains_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "2299-2329",
          "snippet": "bool\nrange_contains_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1;\n\tRangeBound\tupper1;\n\tbool\t\tempty1;\n\tRangeBound\tlower2;\n\tRangeBound\tupper2;\n\tbool\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* If either range is empty, the answer is easy */\n\tif (empty2)\n\t\treturn true;\n\telse if (empty1)\n\t\treturn false;\n\n\t/* Else we must have lower1 <= lower2 and upper1 >= upper2 */\n\tif (range_cmp_bounds(typcache, &lower1, &lower2) > 0)\n\t\treturn false;\n\tif (range_cmp_bounds(typcache, &upper1, &upper2) < 0)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nrange_contains_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1;\n\tRangeBound\tupper1;\n\tbool\t\tempty1;\n\tRangeBound\tlower2;\n\tRangeBound\tupper2;\n\tbool\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* If either range is empty, the answer is easy */\n\tif (empty2)\n\t\treturn true;\n\telse if (empty1)\n\t\treturn false;\n\n\t/* Else we must have lower1 <= lower2 and upper1 >= upper2 */\n\tif (range_cmp_bounds(typcache, &lower1, &lower2) > 0)\n\t\treturn false;\n\tif (range_cmp_bounds(typcache, &upper1, &upper2) < 0)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetRangeTypeP",
          "args": [
            "query"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_adjacent_internal",
          "args": [
            "typcache",
            "key",
            "DatumGetRangeTypeP(query)"
          ],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "range_adjacent_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "780-807",
          "snippet": "bool\nrange_adjacent_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* An empty range is not adjacent to any other range */\n\tif (empty1 || empty2)\n\t\treturn false;\n\n\t/*\n\t * Given two ranges A..B and C..D, the ranges are adjacent if and only if\n\t * B is adjacent to C, or D is adjacent to A.\n\t */\n\treturn (bounds_adjacent(typcache, upper1, lower2) ||\n\t\t\tbounds_adjacent(typcache, upper2, lower1));\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nrange_adjacent_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* An empty range is not adjacent to any other range */\n\tif (empty1 || empty2)\n\t\treturn false;\n\n\t/*\n\t * Given two ranges A..B and C..D, the ranges are adjacent if and only if\n\t * B is adjacent to C, or D is adjacent to A.\n\t */\n\treturn (bounds_adjacent(typcache, upper1, lower2) ||\n\t\t\tbounds_adjacent(typcache, upper2, lower1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetRangeTypeP",
          "args": [
            "query"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_after_internal",
          "args": [
            "typcache",
            "key",
            "DatumGetRangeTypeP(query)"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "range_after_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "684-706",
          "snippet": "bool\nrange_after_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* An empty range is neither before nor after any other range */\n\tif (empty1 || empty2)\n\t\treturn false;\n\n\treturn (range_cmp_bounds(typcache, &lower1, &upper2) > 0);\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nrange_after_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* An empty range is neither before nor after any other range */\n\tif (empty1 || empty2)\n\t\treturn false;\n\n\treturn (range_cmp_bounds(typcache, &lower1, &upper2) > 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetRangeTypeP",
          "args": [
            "query"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_overright_internal",
          "args": [
            "typcache",
            "key",
            "DatumGetRangeTypeP(query)"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "range_overright_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "910-935",
          "snippet": "bool\nrange_overright_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* An empty range is neither before nor after any other range */\n\tif (empty1 || empty2)\n\t\treturn false;\n\n\tif (range_cmp_bounds(typcache, &lower1, &lower2) >= 0)\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nrange_overright_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* An empty range is neither before nor after any other range */\n\tif (empty1 || empty2)\n\t\treturn false;\n\n\tif (range_cmp_bounds(typcache, &lower1, &lower2) >= 0)\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetRangeTypeP",
          "args": [
            "query"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_overlaps_internal",
          "args": [
            "typcache",
            "key",
            "DatumGetRangeTypeP(query)"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "range_overlaps_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "823-853",
          "snippet": "bool\nrange_overlaps_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* An empty range does not overlap any other range */\n\tif (empty1 || empty2)\n\t\treturn false;\n\n\tif (range_cmp_bounds(typcache, &lower1, &lower2) >= 0 &&\n\t\trange_cmp_bounds(typcache, &lower1, &upper2) <= 0)\n\t\treturn true;\n\n\tif (range_cmp_bounds(typcache, &lower2, &lower1) >= 0 &&\n\t\trange_cmp_bounds(typcache, &lower2, &upper1) <= 0)\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nrange_overlaps_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* An empty range does not overlap any other range */\n\tif (empty1 || empty2)\n\t\treturn false;\n\n\tif (range_cmp_bounds(typcache, &lower1, &lower2) >= 0 &&\n\t\trange_cmp_bounds(typcache, &lower1, &upper2) <= 0)\n\t\treturn true;\n\n\tif (range_cmp_bounds(typcache, &lower2, &lower1) >= 0 &&\n\t\trange_cmp_bounds(typcache, &lower2, &upper1) <= 0)\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetRangeTypeP",
          "args": [
            "query"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_overleft_internal",
          "args": [
            "typcache",
            "key",
            "DatumGetRangeTypeP(query)"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "range_overleft_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "869-894",
          "snippet": "bool\nrange_overleft_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* An empty range is neither before nor after any other range */\n\tif (empty1 || empty2)\n\t\treturn false;\n\n\tif (range_cmp_bounds(typcache, &upper1, &upper2) <= 0)\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nrange_overleft_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* An empty range is neither before nor after any other range */\n\tif (empty1 || empty2)\n\t\treturn false;\n\n\tif (range_cmp_bounds(typcache, &upper1, &upper2) <= 0)\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetRangeTypeP",
          "args": [
            "query"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_before_internal",
          "args": [
            "typcache",
            "key",
            "DatumGetRangeTypeP(query)"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "range_before_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "646-668",
          "snippet": "bool\nrange_before_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* An empty range is neither before nor after any other range */\n\tif (empty1 || empty2)\n\t\treturn false;\n\n\treturn (range_cmp_bounds(typcache, &upper1, &lower2) < 0);\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nrange_before_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* An empty range is neither before nor after any other range */\n\tif (empty1 || empty2)\n\t\treturn false;\n\n\treturn (range_cmp_bounds(typcache, &upper1, &lower2) < 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetRangeTypeP",
          "args": [
            "query"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/rangetypes.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"access/stratnum.h\"\n#include \"access/gist.h\"\n#include \"postgres.h\"\n\nstatic bool range_gist_consistent_int(TypeCacheEntry *typcache,\n\t\t\t\t\t\t  StrategyNumber strategy, RangeType *key,\n\t\t\t\t\t\t  Datum query);\nstatic bool range_gist_consistent_leaf(TypeCacheEntry *typcache,\n\t\t\t\t\t\t   StrategyNumber strategy, RangeType *key,\n\t\t\t\t\t\t   Datum query);\nstatic int\tget_gist_range_class(RangeType *range);\n\nstatic bool\nrange_gist_consistent_leaf(TypeCacheEntry *typcache, StrategyNumber strategy,\n\t\t\t\t\t\t   RangeType *key, Datum query)\n{\n\tswitch (strategy)\n\t{\n\t\tcase RANGESTRAT_BEFORE:\n\t\t\treturn range_before_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\t DatumGetRangeTypeP(query));\n\t\tcase RANGESTRAT_OVERLEFT:\n\t\t\treturn range_overleft_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\t   DatumGetRangeTypeP(query));\n\t\tcase RANGESTRAT_OVERLAPS:\n\t\t\treturn range_overlaps_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\t   DatumGetRangeTypeP(query));\n\t\tcase RANGESTRAT_OVERRIGHT:\n\t\t\treturn range_overright_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\t\tDatumGetRangeTypeP(query));\n\t\tcase RANGESTRAT_AFTER:\n\t\t\treturn range_after_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\tDatumGetRangeTypeP(query));\n\t\tcase RANGESTRAT_ADJACENT:\n\t\t\treturn range_adjacent_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\t   DatumGetRangeTypeP(query));\n\t\tcase RANGESTRAT_CONTAINS:\n\t\t\treturn range_contains_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\t   DatumGetRangeTypeP(query));\n\t\tcase RANGESTRAT_CONTAINED_BY:\n\t\t\treturn range_contained_by_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\t\t   DatumGetRangeTypeP(query));\n\t\tcase RANGESTRAT_CONTAINS_ELEM:\n\t\t\treturn range_contains_elem_internal(typcache, key, query);\n\t\tcase RANGESTRAT_EQ:\n\t\t\treturn range_eq_internal(typcache, key, DatumGetRangeTypeP(query));\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized range strategy: %d\", strategy);\n\t\t\treturn false;\t\t/* keep compiler quiet */\n\t}\n}"
  },
  {
    "function_name": "range_gist_consistent_int",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_gist.c",
    "lines": "764-831",
    "snippet": "static bool\nrange_gist_consistent_int(TypeCacheEntry *typcache, StrategyNumber strategy,\n\t\t\t\t\t\t  RangeType *key, Datum query)\n{\n\tswitch (strategy)\n\t{\n\t\tcase RANGESTRAT_BEFORE:\n\t\t\tif (RangeIsEmpty(key) || RangeIsEmpty(DatumGetRangeTypeP(query)))\n\t\t\t\treturn false;\n\t\t\treturn (!range_overright_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\t\t  DatumGetRangeTypeP(query)));\n\t\tcase RANGESTRAT_OVERLEFT:\n\t\t\tif (RangeIsEmpty(key) || RangeIsEmpty(DatumGetRangeTypeP(query)))\n\t\t\t\treturn false;\n\t\t\treturn (!range_after_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\t  DatumGetRangeTypeP(query)));\n\t\tcase RANGESTRAT_OVERLAPS:\n\t\t\treturn range_overlaps_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\t   DatumGetRangeTypeP(query));\n\t\tcase RANGESTRAT_OVERRIGHT:\n\t\t\tif (RangeIsEmpty(key) || RangeIsEmpty(DatumGetRangeTypeP(query)))\n\t\t\t\treturn false;\n\t\t\treturn (!range_before_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\t   DatumGetRangeTypeP(query)));\n\t\tcase RANGESTRAT_AFTER:\n\t\t\tif (RangeIsEmpty(key) || RangeIsEmpty(DatumGetRangeTypeP(query)))\n\t\t\t\treturn false;\n\t\t\treturn (!range_overleft_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\t\t DatumGetRangeTypeP(query)));\n\t\tcase RANGESTRAT_ADJACENT:\n\t\t\tif (RangeIsEmpty(key) || RangeIsEmpty(DatumGetRangeTypeP(query)))\n\t\t\t\treturn false;\n\t\t\tif (range_adjacent_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\tDatumGetRangeTypeP(query)))\n\t\t\t\treturn true;\n\t\t\treturn range_overlaps_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\t   DatumGetRangeTypeP(query));\n\t\tcase RANGESTRAT_CONTAINS:\n\t\t\treturn range_contains_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\t   DatumGetRangeTypeP(query));\n\t\tcase RANGESTRAT_CONTAINED_BY:\n\n\t\t\t/*\n\t\t\t * Empty ranges are contained by anything, so if key is or\n\t\t\t * contains any empty ranges, we must descend into it.  Otherwise,\n\t\t\t * descend only if key overlaps the query.\n\t\t\t */\n\t\t\tif (RangeIsOrContainsEmpty(key))\n\t\t\t\treturn true;\n\t\t\treturn range_overlaps_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\t   DatumGetRangeTypeP(query));\n\t\tcase RANGESTRAT_CONTAINS_ELEM:\n\t\t\treturn range_contains_elem_internal(typcache, key, query);\n\t\tcase RANGESTRAT_EQ:\n\n\t\t\t/*\n\t\t\t * If query is empty, descend only if the key is or contains any\n\t\t\t * empty ranges.  Otherwise, descend if key contains query.\n\t\t\t */\n\t\t\tif (RangeIsEmpty(DatumGetRangeTypeP(query)))\n\t\t\t\treturn RangeIsOrContainsEmpty(key);\n\t\t\treturn range_contains_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\t   DatumGetRangeTypeP(query));\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized range strategy: %d\", strategy);\n\t\t\treturn false;\t\t/* keep compiler quiet */\n\t}\n}",
    "includes": [
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"access/stratnum.h\"",
      "#include \"access/gist.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool range_gist_consistent_int(TypeCacheEntry *typcache,\n\t\t\t\t\t\t  StrategyNumber strategy, RangeType *key,\n\t\t\t\t\t\t  Datum query);",
      "static bool range_gist_consistent_leaf(TypeCacheEntry *typcache,\n\t\t\t\t\t\t   StrategyNumber strategy, RangeType *key,\n\t\t\t\t\t\t   Datum query);",
      "static int\tget_gist_range_class(RangeType *range);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unrecognized range strategy: %d\"",
            "strategy"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_contains_internal",
          "args": [
            "typcache",
            "key",
            "DatumGetRangeTypeP(query)"
          ],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "range_contains_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "2299-2329",
          "snippet": "bool\nrange_contains_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1;\n\tRangeBound\tupper1;\n\tbool\t\tempty1;\n\tRangeBound\tlower2;\n\tRangeBound\tupper2;\n\tbool\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* If either range is empty, the answer is easy */\n\tif (empty2)\n\t\treturn true;\n\telse if (empty1)\n\t\treturn false;\n\n\t/* Else we must have lower1 <= lower2 and upper1 >= upper2 */\n\tif (range_cmp_bounds(typcache, &lower1, &lower2) > 0)\n\t\treturn false;\n\tif (range_cmp_bounds(typcache, &upper1, &upper2) < 0)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nrange_contains_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1;\n\tRangeBound\tupper1;\n\tbool\t\tempty1;\n\tRangeBound\tlower2;\n\tRangeBound\tupper2;\n\tbool\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* If either range is empty, the answer is easy */\n\tif (empty2)\n\t\treturn true;\n\telse if (empty1)\n\t\treturn false;\n\n\t/* Else we must have lower1 <= lower2 and upper1 >= upper2 */\n\tif (range_cmp_bounds(typcache, &lower1, &lower2) > 0)\n\t\treturn false;\n\tif (range_cmp_bounds(typcache, &upper1, &upper2) < 0)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetRangeTypeP",
          "args": [
            "query"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RangeIsOrContainsEmpty",
          "args": [
            "key"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RangeIsEmpty",
          "args": [
            "DatumGetRangeTypeP(query)"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetRangeTypeP",
          "args": [
            "query"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_contains_elem_internal",
          "args": [
            "typcache",
            "key",
            "query"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "range_contains_elem_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "2340-2376",
          "snippet": "bool\nrange_contains_elem_internal(TypeCacheEntry *typcache, RangeType *r, Datum val)\n{\n\tRangeBound\tlower;\n\tRangeBound\tupper;\n\tbool\t\tempty;\n\tint32\t\tcmp;\n\n\trange_deserialize(typcache, r, &lower, &upper, &empty);\n\n\tif (empty)\n\t\treturn false;\n\n\tif (!lower.infinite)\n\t{\n\t\tcmp = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t  typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t  lower.val, val));\n\t\tif (cmp > 0)\n\t\t\treturn false;\n\t\tif (cmp == 0 && !lower.inclusive)\n\t\t\treturn false;\n\t}\n\n\tif (!upper.infinite)\n\t{\n\t\tcmp = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t  typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t  upper.val, val));\n\t\tif (cmp < 0)\n\t\t\treturn false;\n\t\tif (cmp == 0 && !upper.inclusive)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nbool\nrange_contains_elem_internal(TypeCacheEntry *typcache, RangeType *r, Datum val)\n{\n\tRangeBound\tlower;\n\tRangeBound\tupper;\n\tbool\t\tempty;\n\tint32\t\tcmp;\n\n\trange_deserialize(typcache, r, &lower, &upper, &empty);\n\n\tif (empty)\n\t\treturn false;\n\n\tif (!lower.infinite)\n\t{\n\t\tcmp = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t  typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t  lower.val, val));\n\t\tif (cmp > 0)\n\t\t\treturn false;\n\t\tif (cmp == 0 && !lower.inclusive)\n\t\t\treturn false;\n\t}\n\n\tif (!upper.infinite)\n\t{\n\t\tcmp = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t  typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t  upper.val, val));\n\t\tif (cmp < 0)\n\t\t\treturn false;\n\t\tif (cmp == 0 && !upper.inclusive)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_overlaps_internal",
          "args": [
            "typcache",
            "key",
            "DatumGetRangeTypeP(query)"
          ],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "range_overlaps_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "823-853",
          "snippet": "bool\nrange_overlaps_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* An empty range does not overlap any other range */\n\tif (empty1 || empty2)\n\t\treturn false;\n\n\tif (range_cmp_bounds(typcache, &lower1, &lower2) >= 0 &&\n\t\trange_cmp_bounds(typcache, &lower1, &upper2) <= 0)\n\t\treturn true;\n\n\tif (range_cmp_bounds(typcache, &lower2, &lower1) >= 0 &&\n\t\trange_cmp_bounds(typcache, &lower2, &upper1) <= 0)\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nrange_overlaps_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* An empty range does not overlap any other range */\n\tif (empty1 || empty2)\n\t\treturn false;\n\n\tif (range_cmp_bounds(typcache, &lower1, &lower2) >= 0 &&\n\t\trange_cmp_bounds(typcache, &lower1, &upper2) <= 0)\n\t\treturn true;\n\n\tif (range_cmp_bounds(typcache, &lower2, &lower1) >= 0 &&\n\t\trange_cmp_bounds(typcache, &lower2, &upper1) <= 0)\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetRangeTypeP",
          "args": [
            "query"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RangeIsOrContainsEmpty",
          "args": [
            "key"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetRangeTypeP",
          "args": [
            "query"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetRangeTypeP",
          "args": [
            "query"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_adjacent_internal",
          "args": [
            "typcache",
            "key",
            "DatumGetRangeTypeP(query)"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "range_adjacent_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "780-807",
          "snippet": "bool\nrange_adjacent_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* An empty range is not adjacent to any other range */\n\tif (empty1 || empty2)\n\t\treturn false;\n\n\t/*\n\t * Given two ranges A..B and C..D, the ranges are adjacent if and only if\n\t * B is adjacent to C, or D is adjacent to A.\n\t */\n\treturn (bounds_adjacent(typcache, upper1, lower2) ||\n\t\t\tbounds_adjacent(typcache, upper2, lower1));\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nrange_adjacent_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* An empty range is not adjacent to any other range */\n\tif (empty1 || empty2)\n\t\treturn false;\n\n\t/*\n\t * Given two ranges A..B and C..D, the ranges are adjacent if and only if\n\t * B is adjacent to C, or D is adjacent to A.\n\t */\n\treturn (bounds_adjacent(typcache, upper1, lower2) ||\n\t\t\tbounds_adjacent(typcache, upper2, lower1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetRangeTypeP",
          "args": [
            "query"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RangeIsEmpty",
          "args": [
            "DatumGetRangeTypeP(query)"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetRangeTypeP",
          "args": [
            "query"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RangeIsEmpty",
          "args": [
            "key"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_overleft_internal",
          "args": [
            "typcache",
            "key",
            "DatumGetRangeTypeP(query)"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "range_overleft_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "869-894",
          "snippet": "bool\nrange_overleft_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* An empty range is neither before nor after any other range */\n\tif (empty1 || empty2)\n\t\treturn false;\n\n\tif (range_cmp_bounds(typcache, &upper1, &upper2) <= 0)\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nrange_overleft_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* An empty range is neither before nor after any other range */\n\tif (empty1 || empty2)\n\t\treturn false;\n\n\tif (range_cmp_bounds(typcache, &upper1, &upper2) <= 0)\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetRangeTypeP",
          "args": [
            "query"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RangeIsEmpty",
          "args": [
            "DatumGetRangeTypeP(query)"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetRangeTypeP",
          "args": [
            "query"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RangeIsEmpty",
          "args": [
            "key"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_before_internal",
          "args": [
            "typcache",
            "key",
            "DatumGetRangeTypeP(query)"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "range_before_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "646-668",
          "snippet": "bool\nrange_before_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* An empty range is neither before nor after any other range */\n\tif (empty1 || empty2)\n\t\treturn false;\n\n\treturn (range_cmp_bounds(typcache, &upper1, &lower2) < 0);\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nrange_before_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* An empty range is neither before nor after any other range */\n\tif (empty1 || empty2)\n\t\treturn false;\n\n\treturn (range_cmp_bounds(typcache, &upper1, &lower2) < 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetRangeTypeP",
          "args": [
            "query"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RangeIsEmpty",
          "args": [
            "DatumGetRangeTypeP(query)"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetRangeTypeP",
          "args": [
            "query"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RangeIsEmpty",
          "args": [
            "key"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetRangeTypeP",
          "args": [
            "query"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_after_internal",
          "args": [
            "typcache",
            "key",
            "DatumGetRangeTypeP(query)"
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "range_after_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "684-706",
          "snippet": "bool\nrange_after_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* An empty range is neither before nor after any other range */\n\tif (empty1 || empty2)\n\t\treturn false;\n\n\treturn (range_cmp_bounds(typcache, &lower1, &upper2) > 0);\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nrange_after_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* An empty range is neither before nor after any other range */\n\tif (empty1 || empty2)\n\t\treturn false;\n\n\treturn (range_cmp_bounds(typcache, &lower1, &upper2) > 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetRangeTypeP",
          "args": [
            "query"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RangeIsEmpty",
          "args": [
            "DatumGetRangeTypeP(query)"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetRangeTypeP",
          "args": [
            "query"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RangeIsEmpty",
          "args": [
            "key"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_overright_internal",
          "args": [
            "typcache",
            "key",
            "DatumGetRangeTypeP(query)"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "range_overright_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "910-935",
          "snippet": "bool\nrange_overright_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* An empty range is neither before nor after any other range */\n\tif (empty1 || empty2)\n\t\treturn false;\n\n\tif (range_cmp_bounds(typcache, &lower1, &lower2) >= 0)\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nrange_overright_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\t/* An empty range is neither before nor after any other range */\n\tif (empty1 || empty2)\n\t\treturn false;\n\n\tif (range_cmp_bounds(typcache, &lower1, &lower2) >= 0)\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetRangeTypeP",
          "args": [
            "query"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RangeIsEmpty",
          "args": [
            "DatumGetRangeTypeP(query)"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetRangeTypeP",
          "args": [
            "query"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RangeIsEmpty",
          "args": [
            "key"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/rangetypes.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"access/stratnum.h\"\n#include \"access/gist.h\"\n#include \"postgres.h\"\n\nstatic bool range_gist_consistent_int(TypeCacheEntry *typcache,\n\t\t\t\t\t\t  StrategyNumber strategy, RangeType *key,\n\t\t\t\t\t\t  Datum query);\nstatic bool range_gist_consistent_leaf(TypeCacheEntry *typcache,\n\t\t\t\t\t\t   StrategyNumber strategy, RangeType *key,\n\t\t\t\t\t\t   Datum query);\nstatic int\tget_gist_range_class(RangeType *range);\n\nstatic bool\nrange_gist_consistent_int(TypeCacheEntry *typcache, StrategyNumber strategy,\n\t\t\t\t\t\t  RangeType *key, Datum query)\n{\n\tswitch (strategy)\n\t{\n\t\tcase RANGESTRAT_BEFORE:\n\t\t\tif (RangeIsEmpty(key) || RangeIsEmpty(DatumGetRangeTypeP(query)))\n\t\t\t\treturn false;\n\t\t\treturn (!range_overright_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\t\t  DatumGetRangeTypeP(query)));\n\t\tcase RANGESTRAT_OVERLEFT:\n\t\t\tif (RangeIsEmpty(key) || RangeIsEmpty(DatumGetRangeTypeP(query)))\n\t\t\t\treturn false;\n\t\t\treturn (!range_after_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\t  DatumGetRangeTypeP(query)));\n\t\tcase RANGESTRAT_OVERLAPS:\n\t\t\treturn range_overlaps_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\t   DatumGetRangeTypeP(query));\n\t\tcase RANGESTRAT_OVERRIGHT:\n\t\t\tif (RangeIsEmpty(key) || RangeIsEmpty(DatumGetRangeTypeP(query)))\n\t\t\t\treturn false;\n\t\t\treturn (!range_before_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\t   DatumGetRangeTypeP(query)));\n\t\tcase RANGESTRAT_AFTER:\n\t\t\tif (RangeIsEmpty(key) || RangeIsEmpty(DatumGetRangeTypeP(query)))\n\t\t\t\treturn false;\n\t\t\treturn (!range_overleft_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\t\t DatumGetRangeTypeP(query)));\n\t\tcase RANGESTRAT_ADJACENT:\n\t\t\tif (RangeIsEmpty(key) || RangeIsEmpty(DatumGetRangeTypeP(query)))\n\t\t\t\treturn false;\n\t\t\tif (range_adjacent_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\tDatumGetRangeTypeP(query)))\n\t\t\t\treturn true;\n\t\t\treturn range_overlaps_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\t   DatumGetRangeTypeP(query));\n\t\tcase RANGESTRAT_CONTAINS:\n\t\t\treturn range_contains_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\t   DatumGetRangeTypeP(query));\n\t\tcase RANGESTRAT_CONTAINED_BY:\n\n\t\t\t/*\n\t\t\t * Empty ranges are contained by anything, so if key is or\n\t\t\t * contains any empty ranges, we must descend into it.  Otherwise,\n\t\t\t * descend only if key overlaps the query.\n\t\t\t */\n\t\t\tif (RangeIsOrContainsEmpty(key))\n\t\t\t\treturn true;\n\t\t\treturn range_overlaps_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\t   DatumGetRangeTypeP(query));\n\t\tcase RANGESTRAT_CONTAINS_ELEM:\n\t\t\treturn range_contains_elem_internal(typcache, key, query);\n\t\tcase RANGESTRAT_EQ:\n\n\t\t\t/*\n\t\t\t * If query is empty, descend only if the key is or contains any\n\t\t\t * empty ranges.  Otherwise, descend if key contains query.\n\t\t\t */\n\t\t\tif (RangeIsEmpty(DatumGetRangeTypeP(query)))\n\t\t\t\treturn RangeIsOrContainsEmpty(key);\n\t\t\treturn range_contains_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\t   DatumGetRangeTypeP(query));\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized range strategy: %d\", strategy);\n\t\t\treturn false;\t\t/* keep compiler quiet */\n\t}\n}"
  },
  {
    "function_name": "range_super_union",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_gist.c",
    "lines": "694-759",
    "snippet": "static RangeType *\nrange_super_union(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeType  *result;\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\tchar\t\tflags1,\n\t\t\t\tflags2;\n\tRangeBound *result_lower;\n\tRangeBound *result_upper;\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\tflags1 = range_get_flags(r1);\n\tflags2 = range_get_flags(r2);\n\n\tif (empty1)\n\t{\n\t\t/* We can return r2 as-is if it already is or contains empty */\n\t\tif (flags2 & (RANGE_EMPTY | RANGE_CONTAIN_EMPTY))\n\t\t\treturn r2;\n\t\t/* Else we'd better copy it (modify-in-place isn't safe) */\n\t\tr2 = rangeCopy(r2);\n\t\trange_set_contain_empty(r2);\n\t\treturn r2;\n\t}\n\tif (empty2)\n\t{\n\t\t/* We can return r1 as-is if it already is or contains empty */\n\t\tif (flags1 & (RANGE_EMPTY | RANGE_CONTAIN_EMPTY))\n\t\t\treturn r1;\n\t\t/* Else we'd better copy it (modify-in-place isn't safe) */\n\t\tr1 = rangeCopy(r1);\n\t\trange_set_contain_empty(r1);\n\t\treturn r1;\n\t}\n\n\tif (range_cmp_bounds(typcache, &lower1, &lower2) <= 0)\n\t\tresult_lower = &lower1;\n\telse\n\t\tresult_lower = &lower2;\n\n\tif (range_cmp_bounds(typcache, &upper1, &upper2) >= 0)\n\t\tresult_upper = &upper1;\n\telse\n\t\tresult_upper = &upper2;\n\n\t/* optimization to avoid constructing a new range */\n\tif (result_lower == &lower1 && result_upper == &upper1 &&\n\t\t((flags1 & RANGE_CONTAIN_EMPTY) || !(flags2 & RANGE_CONTAIN_EMPTY)))\n\t\treturn r1;\n\tif (result_lower == &lower2 && result_upper == &upper2 &&\n\t\t((flags2 & RANGE_CONTAIN_EMPTY) || !(flags1 & RANGE_CONTAIN_EMPTY)))\n\t\treturn r2;\n\n\tresult = make_range(typcache, result_lower, result_upper, false);\n\n\tif ((flags1 & RANGE_CONTAIN_EMPTY) || (flags2 & RANGE_CONTAIN_EMPTY))\n\t\trange_set_contain_empty(result);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"access/stratnum.h\"",
      "#include \"access/gist.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static RangeType *range_super_union(TypeCacheEntry *typcache, RangeType *r1,\n\t\t\t\t  RangeType *r2);",
      "static int\tget_gist_range_class(RangeType *range);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "range_set_contain_empty",
          "args": [
            "result"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "range_set_contain_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1776-1785",
          "snippet": "void\nrange_set_contain_empty(RangeType *range)\n{\n\tchar\t   *flagsp;\n\n\t/* flag byte is datum's last byte */\n\tflagsp = (char *) range + VARSIZE(range) - 1;\n\n\t*flagsp |= RANGE_CONTAIN_EMPTY;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nrange_set_contain_empty(RangeType *range)\n{\n\tchar\t   *flagsp;\n\n\t/* flag byte is datum's last byte */\n\tflagsp = (char *) range + VARSIZE(range) - 1;\n\n\t*flagsp |= RANGE_CONTAIN_EMPTY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_range",
          "args": [
            "typcache",
            "result_lower",
            "result_upper",
            "false"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "make_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1791-1806",
          "snippet": "RangeType *\nmake_range(TypeCacheEntry *typcache, RangeBound *lower, RangeBound *upper,\n\t\t   bool empty)\n{\n\tRangeType  *range;\n\n\trange = range_serialize(typcache, lower, upper, empty);\n\n\t/* no need to call canonical on empty ranges ... */\n\tif (OidIsValid(typcache->rng_canonical_finfo.fn_oid) &&\n\t\t!RangeIsEmpty(range))\n\t\trange = DatumGetRangeTypeP(FunctionCall1(&typcache->rng_canonical_finfo,\n\t\t\t\t\t\t\t\t\t\t\t\t RangeTypePGetDatum(range)));\n\n\treturn range;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nRangeType *\nmake_range(TypeCacheEntry *typcache, RangeBound *lower, RangeBound *upper,\n\t\t   bool empty)\n{\n\tRangeType  *range;\n\n\trange = range_serialize(typcache, lower, upper, empty);\n\n\t/* no need to call canonical on empty ranges ... */\n\tif (OidIsValid(typcache->rng_canonical_finfo.fn_oid) &&\n\t\t!RangeIsEmpty(range))\n\t\trange = DatumGetRangeTypeP(FunctionCall1(&typcache->rng_canonical_finfo,\n\t\t\t\t\t\t\t\t\t\t\t\t RangeTypePGetDatum(range)));\n\n\treturn range;\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_cmp_bounds",
          "args": [
            "typcache",
            "&upper1",
            "&upper2"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "range_cmp_bounds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1831-1894",
          "snippet": "int\nrange_cmp_bounds(TypeCacheEntry *typcache, RangeBound *b1, RangeBound *b2)\n{\n\tint32\t\tresult;\n\n\t/*\n\t * First, handle cases involving infinity, which don't require invoking\n\t * the comparison proc.\n\t */\n\tif (b1->infinite && b2->infinite)\n\t{\n\t\t/*\n\t\t * Both are infinity, so they are equal unless one is lower and the\n\t\t * other not.\n\t\t */\n\t\tif (b1->lower == b2->lower)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn b1->lower ? -1 : 1;\n\t}\n\telse if (b1->infinite)\n\t\treturn b1->lower ? -1 : 1;\n\telse if (b2->infinite)\n\t\treturn b2->lower ? 1 : -1;\n\n\t/*\n\t * Both boundaries are finite, so compare the held values.\n\t */\n\tresult = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t b1->val, b2->val));\n\n\t/*\n\t * If the comparison is anything other than equal, we're done. If they\n\t * compare equal though, we still have to consider whether the boundaries\n\t * are inclusive or exclusive.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (!b1->inclusive && !b2->inclusive)\n\t\t{\n\t\t\t/* both are exclusive */\n\t\t\tif (b1->lower == b2->lower)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn b1->lower ? 1 : -1;\n\t\t}\n\t\telse if (!b1->inclusive)\n\t\t\treturn b1->lower ? 1 : -1;\n\t\telse if (!b2->inclusive)\n\t\t\treturn b2->lower ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Both are inclusive and the values held are equal, so they are\n\t\t\t * equal regardless of whether they are upper or lower boundaries,\n\t\t\t * or a mix.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nint\nrange_cmp_bounds(TypeCacheEntry *typcache, RangeBound *b1, RangeBound *b2)\n{\n\tint32\t\tresult;\n\n\t/*\n\t * First, handle cases involving infinity, which don't require invoking\n\t * the comparison proc.\n\t */\n\tif (b1->infinite && b2->infinite)\n\t{\n\t\t/*\n\t\t * Both are infinity, so they are equal unless one is lower and the\n\t\t * other not.\n\t\t */\n\t\tif (b1->lower == b2->lower)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn b1->lower ? -1 : 1;\n\t}\n\telse if (b1->infinite)\n\t\treturn b1->lower ? -1 : 1;\n\telse if (b2->infinite)\n\t\treturn b2->lower ? 1 : -1;\n\n\t/*\n\t * Both boundaries are finite, so compare the held values.\n\t */\n\tresult = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t b1->val, b2->val));\n\n\t/*\n\t * If the comparison is anything other than equal, we're done. If they\n\t * compare equal though, we still have to consider whether the boundaries\n\t * are inclusive or exclusive.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (!b1->inclusive && !b2->inclusive)\n\t\t{\n\t\t\t/* both are exclusive */\n\t\t\tif (b1->lower == b2->lower)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn b1->lower ? 1 : -1;\n\t\t}\n\t\telse if (!b1->inclusive)\n\t\t\treturn b1->lower ? 1 : -1;\n\t\telse if (!b2->inclusive)\n\t\t\treturn b2->lower ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Both are inclusive and the values held are equal, so they are\n\t\t\t * equal regardless of whether they are upper or lower boundaries,\n\t\t\t * or a mix.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rangeCopy",
          "args": [
            "r1"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rangeCopy",
          "args": [
            "r2"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_get_flags",
          "args": [
            "r2"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "range_get_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1762-1767",
          "snippet": "char\nrange_get_flags(RangeType *range)\n{\n\t/* fetch the flag byte from datum's last byte */\n\treturn *((char *) range + VARSIZE(range) - 1);\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nchar\nrange_get_flags(RangeType *range)\n{\n\t/* fetch the flag byte from datum's last byte */\n\treturn *((char *) range + VARSIZE(range) - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_deserialize",
          "args": [
            "typcache",
            "r2",
            "&lower2",
            "&upper2",
            "&empty2"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "range_deserialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1695-1754",
          "snippet": "void\nrange_deserialize(TypeCacheEntry *typcache, RangeType *range,\n\t\t\t\t  RangeBound *lower, RangeBound *upper, bool *empty)\n{\n\tchar\t\tflags;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tPointer\t\tptr;\n\tDatum\t\tlbound;\n\tDatum\t\tubound;\n\n\t/* assert caller passed the right typcache entry */\n\tAssert(RangeTypeGetOid(range) == typcache->type_id);\n\n\t/* fetch the flag byte from datum's last byte */\n\tflags = *((char *) range + VARSIZE(range) - 1);\n\n\t/* fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\n\t/* initialize data pointer just after the range OID */\n\tptr = (Pointer) (range + 1);\n\n\t/* fetch lower bound, if any */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/* att_align_pointer cannot be necessary here */\n\t\tlbound = fetch_att(ptr, typbyval, typlen);\n\t\tptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);\n\t}\n\telse\n\t\tlbound = (Datum) 0;\n\n\t/* fetch upper bound, if any */\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);\n\t\tubound = fetch_att(ptr, typbyval, typlen);\n\t\t/* no need for att_addlength_pointer */\n\t}\n\telse\n\t\tubound = (Datum) 0;\n\n\t/* emit results */\n\n\t*empty = (flags & RANGE_EMPTY) != 0;\n\n\tlower->val = lbound;\n\tlower->infinite = (flags & RANGE_LB_INF) != 0;\n\tlower->inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower->lower = true;\n\n\tupper->val = ubound;\n\tupper->infinite = (flags & RANGE_UB_INF) != 0;\n\tupper->inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper->lower = false;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nvoid\nrange_deserialize(TypeCacheEntry *typcache, RangeType *range,\n\t\t\t\t  RangeBound *lower, RangeBound *upper, bool *empty)\n{\n\tchar\t\tflags;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tPointer\t\tptr;\n\tDatum\t\tlbound;\n\tDatum\t\tubound;\n\n\t/* assert caller passed the right typcache entry */\n\tAssert(RangeTypeGetOid(range) == typcache->type_id);\n\n\t/* fetch the flag byte from datum's last byte */\n\tflags = *((char *) range + VARSIZE(range) - 1);\n\n\t/* fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\n\t/* initialize data pointer just after the range OID */\n\tptr = (Pointer) (range + 1);\n\n\t/* fetch lower bound, if any */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/* att_align_pointer cannot be necessary here */\n\t\tlbound = fetch_att(ptr, typbyval, typlen);\n\t\tptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);\n\t}\n\telse\n\t\tlbound = (Datum) 0;\n\n\t/* fetch upper bound, if any */\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);\n\t\tubound = fetch_att(ptr, typbyval, typlen);\n\t\t/* no need for att_addlength_pointer */\n\t}\n\telse\n\t\tubound = (Datum) 0;\n\n\t/* emit results */\n\n\t*empty = (flags & RANGE_EMPTY) != 0;\n\n\tlower->val = lbound;\n\tlower->infinite = (flags & RANGE_LB_INF) != 0;\n\tlower->inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower->lower = true;\n\n\tupper->val = ubound;\n\tupper->infinite = (flags & RANGE_UB_INF) != 0;\n\tupper->inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper->lower = false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/rangetypes.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"access/stratnum.h\"\n#include \"access/gist.h\"\n#include \"postgres.h\"\n\nstatic RangeType *range_super_union(TypeCacheEntry *typcache, RangeType *r1,\n\t\t\t\t  RangeType *r2);\nstatic int\tget_gist_range_class(RangeType *range);\n\nstatic RangeType *\nrange_super_union(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeType  *result;\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\tchar\t\tflags1,\n\t\t\t\tflags2;\n\tRangeBound *result_lower;\n\tRangeBound *result_upper;\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\tflags1 = range_get_flags(r1);\n\tflags2 = range_get_flags(r2);\n\n\tif (empty1)\n\t{\n\t\t/* We can return r2 as-is if it already is or contains empty */\n\t\tif (flags2 & (RANGE_EMPTY | RANGE_CONTAIN_EMPTY))\n\t\t\treturn r2;\n\t\t/* Else we'd better copy it (modify-in-place isn't safe) */\n\t\tr2 = rangeCopy(r2);\n\t\trange_set_contain_empty(r2);\n\t\treturn r2;\n\t}\n\tif (empty2)\n\t{\n\t\t/* We can return r1 as-is if it already is or contains empty */\n\t\tif (flags1 & (RANGE_EMPTY | RANGE_CONTAIN_EMPTY))\n\t\t\treturn r1;\n\t\t/* Else we'd better copy it (modify-in-place isn't safe) */\n\t\tr1 = rangeCopy(r1);\n\t\trange_set_contain_empty(r1);\n\t\treturn r1;\n\t}\n\n\tif (range_cmp_bounds(typcache, &lower1, &lower2) <= 0)\n\t\tresult_lower = &lower1;\n\telse\n\t\tresult_lower = &lower2;\n\n\tif (range_cmp_bounds(typcache, &upper1, &upper2) >= 0)\n\t\tresult_upper = &upper1;\n\telse\n\t\tresult_upper = &upper2;\n\n\t/* optimization to avoid constructing a new range */\n\tif (result_lower == &lower1 && result_upper == &upper1 &&\n\t\t((flags1 & RANGE_CONTAIN_EMPTY) || !(flags2 & RANGE_CONTAIN_EMPTY)))\n\t\treturn r1;\n\tif (result_lower == &lower2 && result_upper == &upper2 &&\n\t\t((flags2 & RANGE_CONTAIN_EMPTY) || !(flags1 & RANGE_CONTAIN_EMPTY)))\n\t\treturn r2;\n\n\tresult = make_range(typcache, result_lower, result_upper, false);\n\n\tif ((flags1 & RANGE_CONTAIN_EMPTY) || (flags2 & RANGE_CONTAIN_EMPTY))\n\t\trange_set_contain_empty(result);\n\n\treturn result;\n}"
  },
  {
    "function_name": "range_gist_same",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_gist.c",
    "lines": "651-676",
    "snippet": "Datum\nrange_gist_same(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r1 = PG_GETARG_RANGE_P(0);\n\tRangeType  *r2 = PG_GETARG_RANGE_P(1);\n\tbool\t   *result = (bool *) PG_GETARG_POINTER(2);\n\n\t/*\n\t * range_eq will ignore the RANGE_CONTAIN_EMPTY flag, so we have to check\n\t * that for ourselves.  More generally, if the entries have been properly\n\t * normalized, then unequal flags bytes must mean unequal ranges ... so\n\t * let's just test all the flag bits at once.\n\t */\n\tif (range_get_flags(r1) != range_get_flags(r2))\n\t\t*result = false;\n\telse\n\t{\n\t\tTypeCacheEntry *typcache;\n\n\t\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(r1));\n\n\t\t*result = range_eq_internal(typcache, r1, r2);\n\t}\n\n\tPG_RETURN_POINTER(result);\n}",
    "includes": [
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"access/stratnum.h\"",
      "#include \"access/gist.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static RangeType *range_super_union(TypeCacheEntry *typcache, RangeType *r1,\n\t\t\t\t  RangeType *r2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "result"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_eq_internal",
          "args": [
            "typcache",
            "r1",
            "r2"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "range_eq_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "555-584",
          "snippet": "bool\nrange_eq_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\tif (empty1 && empty2)\n\t\treturn true;\n\tif (empty1 != empty2)\n\t\treturn false;\n\n\tif (range_cmp_bounds(typcache, &lower1, &lower2) != 0)\n\t\treturn false;\n\n\tif (range_cmp_bounds(typcache, &upper1, &upper2) != 0)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nrange_eq_internal(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\n\t/* Different types should be prevented by ANYRANGE matching rules */\n\tif (RangeTypeGetOid(r1) != RangeTypeGetOid(r2))\n\t\telog(ERROR, \"range types do not match\");\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\n\tif (empty1 && empty2)\n\t\treturn true;\n\tif (empty1 != empty2)\n\t\treturn false;\n\n\tif (range_cmp_bounds(typcache, &lower1, &lower2) != 0)\n\t\treturn false;\n\n\tif (range_cmp_bounds(typcache, &upper1, &upper2) != 0)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_get_typcache",
          "args": [
            "fcinfo",
            "RangeTypeGetOid(r1)"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "range_get_typcache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1542-1557",
          "snippet": "TypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nTypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RangeTypeGetOid",
          "args": [
            "r1"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_get_flags",
          "args": [
            "r2"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "range_get_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1762-1767",
          "snippet": "char\nrange_get_flags(RangeType *range)\n{\n\t/* fetch the flag byte from datum's last byte */\n\treturn *((char *) range + VARSIZE(range) - 1);\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nchar\nrange_get_flags(RangeType *range)\n{\n\t/* fetch the flag byte from datum's last byte */\n\treturn *((char *) range + VARSIZE(range) - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "2"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RANGE_P",
          "args": [
            "1"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RANGE_P",
          "args": [
            "0"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/rangetypes.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"access/stratnum.h\"\n#include \"access/gist.h\"\n#include \"postgres.h\"\n\nstatic RangeType *range_super_union(TypeCacheEntry *typcache, RangeType *r1,\n\t\t\t\t  RangeType *r2);\n\nDatum\nrange_gist_same(PG_FUNCTION_ARGS)\n{\n\tRangeType  *r1 = PG_GETARG_RANGE_P(0);\n\tRangeType  *r2 = PG_GETARG_RANGE_P(1);\n\tbool\t   *result = (bool *) PG_GETARG_POINTER(2);\n\n\t/*\n\t * range_eq will ignore the RANGE_CONTAIN_EMPTY flag, so we have to check\n\t * that for ourselves.  More generally, if the entries have been properly\n\t * normalized, then unequal flags bytes must mean unequal ranges ... so\n\t * let's just test all the flag bits at once.\n\t */\n\tif (range_get_flags(r1) != range_get_flags(r2))\n\t\t*result = false;\n\telse\n\t{\n\t\tTypeCacheEntry *typcache;\n\n\t\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(r1));\n\n\t\t*result = range_eq_internal(typcache, r1, r2);\n\t}\n\n\tPG_RETURN_POINTER(result);\n}"
  },
  {
    "function_name": "range_gist_picksplit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_gist.c",
    "lines": "492-648",
    "snippet": "Datum\nrange_gist_picksplit(PG_FUNCTION_ARGS)\n{\n\tGistEntryVector *entryvec = (GistEntryVector *) PG_GETARG_POINTER(0);\n\tGIST_SPLITVEC *v = (GIST_SPLITVEC *) PG_GETARG_POINTER(1);\n\tTypeCacheEntry *typcache;\n\tOffsetNumber i;\n\tRangeType  *pred_left;\n\tint\t\t\tnbytes;\n\tOffsetNumber maxoff;\n\tint\t\t\tcount_in_classes[CLS_COUNT];\n\tint\t\t\tj;\n\tint\t\t\tnon_empty_classes_count = 0;\n\tint\t\t\tbiggest_class = -1;\n\tint\t\t\tbiggest_class_count = 0;\n\tint\t\t\ttotal_count;\n\n\t/* use first item to look up range type's info */\n\tpred_left = DatumGetRangeTypeP(entryvec->vector[FirstOffsetNumber].key);\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(pred_left));\n\n\tmaxoff = entryvec->n - 1;\n\tnbytes = (maxoff + 1) * sizeof(OffsetNumber);\n\tv->spl_left = (OffsetNumber *) palloc(nbytes);\n\tv->spl_right = (OffsetNumber *) palloc(nbytes);\n\n\t/*\n\t * Get count distribution of range classes.\n\t */\n\tmemset(count_in_classes, 0, sizeof(count_in_classes));\n\tfor (i = FirstOffsetNumber; i <= maxoff; i = OffsetNumberNext(i))\n\t{\n\t\tRangeType  *range = DatumGetRangeTypeP(entryvec->vector[i].key);\n\n\t\tcount_in_classes[get_gist_range_class(range)]++;\n\t}\n\n\t/*\n\t * Count non-empty classes and find biggest class.\n\t */\n\ttotal_count = maxoff;\n\tfor (j = 0; j < CLS_COUNT; j++)\n\t{\n\t\tif (count_in_classes[j] > 0)\n\t\t{\n\t\t\tif (count_in_classes[j] > biggest_class_count)\n\t\t\t{\n\t\t\t\tbiggest_class_count = count_in_classes[j];\n\t\t\t\tbiggest_class = j;\n\t\t\t}\n\t\t\tnon_empty_classes_count++;\n\t\t}\n\t}\n\n\tAssert(non_empty_classes_count > 0);\n\n\tif (non_empty_classes_count == 1)\n\t{\n\t\t/* One non-empty class, so split inside class */\n\t\tif ((biggest_class & ~CLS_CONTAIN_EMPTY) == CLS_NORMAL)\n\t\t{\n\t\t\t/* double sorting split for normal ranges */\n\t\t\trange_gist_double_sorting_split(typcache, entryvec, v);\n\t\t}\n\t\telse if ((biggest_class & ~CLS_CONTAIN_EMPTY) == CLS_LOWER_INF)\n\t\t{\n\t\t\t/* upper bound sorting split for (-inf, x) ranges */\n\t\t\trange_gist_single_sorting_split(typcache, entryvec, v, true);\n\t\t}\n\t\telse if ((biggest_class & ~CLS_CONTAIN_EMPTY) == CLS_UPPER_INF)\n\t\t{\n\t\t\t/* lower bound sorting split for (x, +inf) ranges */\n\t\t\trange_gist_single_sorting_split(typcache, entryvec, v, false);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* trivial split for all (-inf, +inf) or all empty ranges */\n\t\t\trange_gist_fallback_split(typcache, entryvec, v);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Class based split.\n\t\t *\n\t\t * To which side of the split should each class go?  Initialize them\n\t\t * all to go to the left side.\n\t\t */\n\t\tSplitLR\t\tclasses_groups[CLS_COUNT];\n\n\t\tmemset(classes_groups, 0, sizeof(classes_groups));\n\n\t\tif (count_in_classes[CLS_NORMAL] > 0)\n\t\t{\n\t\t\t/* separate normal ranges if any */\n\t\t\tclasses_groups[CLS_NORMAL] = SPLIT_RIGHT;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*----------\n\t\t\t * Try to split classes in one of two ways:\n\t\t\t *\t1) containing infinities - not containing infinities\n\t\t\t *\t2) containing empty - not containing empty\n\t\t\t *\n\t\t\t * Select the way which balances the ranges between left and right\n\t\t\t * the best. If split in these ways is not possible, there are at\n\t\t\t * most 3 classes, so just separate biggest class.\n\t\t\t *----------\n\t\t\t */\n\t\t\tint\t\t\tinfCount,\n\t\t\t\t\t\tnonInfCount;\n\t\t\tint\t\t\temptyCount,\n\t\t\t\t\t\tnonEmptyCount;\n\n\t\t\tnonInfCount =\n\t\t\t\tcount_in_classes[CLS_NORMAL] +\n\t\t\t\tcount_in_classes[CLS_CONTAIN_EMPTY] +\n\t\t\t\tcount_in_classes[CLS_EMPTY];\n\t\t\tinfCount = total_count - nonInfCount;\n\n\t\t\tnonEmptyCount =\n\t\t\t\tcount_in_classes[CLS_NORMAL] +\n\t\t\t\tcount_in_classes[CLS_LOWER_INF] +\n\t\t\t\tcount_in_classes[CLS_UPPER_INF] +\n\t\t\t\tcount_in_classes[CLS_LOWER_INF | CLS_UPPER_INF];\n\t\t\temptyCount = total_count - nonEmptyCount;\n\n\t\t\tif (infCount > 0 && nonInfCount > 0 &&\n\t\t\t\t(Abs(infCount - nonInfCount) <=\n\t\t\t\t Abs(emptyCount - nonEmptyCount)))\n\t\t\t{\n\t\t\t\tclasses_groups[CLS_NORMAL] = SPLIT_RIGHT;\n\t\t\t\tclasses_groups[CLS_CONTAIN_EMPTY] = SPLIT_RIGHT;\n\t\t\t\tclasses_groups[CLS_EMPTY] = SPLIT_RIGHT;\n\t\t\t}\n\t\t\telse if (emptyCount > 0 && nonEmptyCount > 0)\n\t\t\t{\n\t\t\t\tclasses_groups[CLS_NORMAL] = SPLIT_RIGHT;\n\t\t\t\tclasses_groups[CLS_LOWER_INF] = SPLIT_RIGHT;\n\t\t\t\tclasses_groups[CLS_UPPER_INF] = SPLIT_RIGHT;\n\t\t\t\tclasses_groups[CLS_LOWER_INF | CLS_UPPER_INF] = SPLIT_RIGHT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Either total_count == emptyCount or total_count ==\n\t\t\t\t * infCount.\n\t\t\t\t */\n\t\t\t\tclasses_groups[biggest_class] = SPLIT_RIGHT;\n\t\t\t}\n\t\t}\n\n\t\trange_gist_class_split(typcache, entryvec, v, classes_groups);\n\t}\n\n\tPG_RETURN_POINTER(v);\n}",
    "includes": [
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"access/stratnum.h\"",
      "#include \"access/gist.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define CLS_COUNT\t\t\t9\t/* # of classes; includes all combinations of\n\t\t\t\t\t\t\t\t * properties. CLS_EMPTY doesn't combine with\n\t\t\t\t\t\t\t\t * anything else, so it's only 2^3 + 1. */",
      "#define CLS_EMPTY\t\t\t8\t/* Special class for empty ranges */",
      "#define CLS_CONTAIN_EMPTY\t4\t/* Contains underlying empty ranges */",
      "#define CLS_UPPER_INF\t\t2\t/* Upper bound is infinity */",
      "#define CLS_LOWER_INF\t\t1\t/* Lower bound is infinity */",
      "#define CLS_NORMAL\t\t\t0\t/* Ordinary finite range (no bits set) */"
    ],
    "globals_used": [
      "static void range_gist_fallback_split(TypeCacheEntry *typcache,\n\t\t\t\t\t\t  GistEntryVector *entryvec,\n\t\t\t\t\t\t  GIST_SPLITVEC *v);",
      "static void range_gist_class_split(TypeCacheEntry *typcache,\n\t\t\t\t\t   GistEntryVector *entryvec,\n\t\t\t\t\t   GIST_SPLITVEC *v,\n\t\t\t\t\t   SplitLR *classes_groups);",
      "static void range_gist_double_sorting_split(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t\tGistEntryVector *entryvec,\n\t\t\t\t\t\t\t\tGIST_SPLITVEC *v);",
      "static int\tget_gist_range_class(RangeType *range);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "v"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_gist_class_split",
          "args": [
            "typcache",
            "entryvec",
            "v",
            "classes_groups"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "range_gist_class_split",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_gist.c",
          "lines": "918-953",
          "snippet": "static void\nrange_gist_class_split(TypeCacheEntry *typcache,\n\t\t\t\t\t   GistEntryVector *entryvec,\n\t\t\t\t\t   GIST_SPLITVEC *v,\n\t\t\t\t\t   SplitLR *classes_groups)\n{\n\tRangeType  *left_range = NULL;\n\tRangeType  *right_range = NULL;\n\tOffsetNumber i,\n\t\t\t\tmaxoff;\n\n\tmaxoff = entryvec->n - 1;\n\n\tv->spl_nleft = 0;\n\tv->spl_nright = 0;\n\tfor (i = FirstOffsetNumber; i <= maxoff; i = OffsetNumberNext(i))\n\t{\n\t\tRangeType  *range = DatumGetRangeTypeP(entryvec->vector[i].key);\n\t\tint\t\t\tclass;\n\n\t\t/* Get class of range */\n\t\tclass = get_gist_range_class(range);\n\n\t\t/* Place range to appropriate page */\n\t\tif (classes_groups[class] == SPLIT_LEFT)\n\t\t\tPLACE_LEFT(range, i);\n\t\telse\n\t\t{\n\t\t\tAssert(classes_groups[class] == SPLIT_RIGHT);\n\t\t\tPLACE_RIGHT(range, i);\n\t\t}\n\t}\n\n\tv->spl_ldatum = RangeTypePGetDatum(left_range);\n\tv->spl_rdatum = RangeTypePGetDatum(right_range);\n}",
          "includes": [
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"access/stratnum.h\"",
            "#include \"access/gist.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void range_gist_fallback_split(TypeCacheEntry *typcache,\n\t\t\t\t\t\t  GistEntryVector *entryvec,\n\t\t\t\t\t\t  GIST_SPLITVEC *v);",
            "static void range_gist_class_split(TypeCacheEntry *typcache,\n\t\t\t\t\t   GistEntryVector *entryvec,\n\t\t\t\t\t   GIST_SPLITVEC *v,\n\t\t\t\t\t   SplitLR *classes_groups);",
            "static void range_gist_double_sorting_split(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t\tGistEntryVector *entryvec,\n\t\t\t\t\t\t\t\tGIST_SPLITVEC *v);",
            "static int\tget_gist_range_class(RangeType *range);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/rangetypes.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"access/stratnum.h\"\n#include \"access/gist.h\"\n#include \"postgres.h\"\n\nstatic void range_gist_fallback_split(TypeCacheEntry *typcache,\n\t\t\t\t\t\t  GistEntryVector *entryvec,\n\t\t\t\t\t\t  GIST_SPLITVEC *v);\nstatic void range_gist_class_split(TypeCacheEntry *typcache,\n\t\t\t\t\t   GistEntryVector *entryvec,\n\t\t\t\t\t   GIST_SPLITVEC *v,\n\t\t\t\t\t   SplitLR *classes_groups);\nstatic void range_gist_double_sorting_split(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t\tGistEntryVector *entryvec,\n\t\t\t\t\t\t\t\tGIST_SPLITVEC *v);\nstatic int\tget_gist_range_class(RangeType *range);\n\nstatic void\nrange_gist_class_split(TypeCacheEntry *typcache,\n\t\t\t\t\t   GistEntryVector *entryvec,\n\t\t\t\t\t   GIST_SPLITVEC *v,\n\t\t\t\t\t   SplitLR *classes_groups)\n{\n\tRangeType  *left_range = NULL;\n\tRangeType  *right_range = NULL;\n\tOffsetNumber i,\n\t\t\t\tmaxoff;\n\n\tmaxoff = entryvec->n - 1;\n\n\tv->spl_nleft = 0;\n\tv->spl_nright = 0;\n\tfor (i = FirstOffsetNumber; i <= maxoff; i = OffsetNumberNext(i))\n\t{\n\t\tRangeType  *range = DatumGetRangeTypeP(entryvec->vector[i].key);\n\t\tint\t\t\tclass;\n\n\t\t/* Get class of range */\n\t\tclass = get_gist_range_class(range);\n\n\t\t/* Place range to appropriate page */\n\t\tif (classes_groups[class] == SPLIT_LEFT)\n\t\t\tPLACE_LEFT(range, i);\n\t\telse\n\t\t{\n\t\t\tAssert(classes_groups[class] == SPLIT_RIGHT);\n\t\t\tPLACE_RIGHT(range, i);\n\t\t}\n\t}\n\n\tv->spl_ldatum = RangeTypePGetDatum(left_range);\n\tv->spl_rdatum = RangeTypePGetDatum(right_range);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Abs",
          "args": [
            "emptyCount - nonEmptyCount"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Abs",
          "args": [
            "infCount - nonInfCount"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "classes_groups",
            "0",
            "sizeof(classes_groups)"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_gist_fallback_split",
          "args": [
            "typcache",
            "entryvec",
            "v"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "range_gist_fallback_split",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_gist.c",
          "lines": "880-909",
          "snippet": "static void\nrange_gist_fallback_split(TypeCacheEntry *typcache,\n\t\t\t\t\t\t  GistEntryVector *entryvec,\n\t\t\t\t\t\t  GIST_SPLITVEC *v)\n{\n\tRangeType  *left_range = NULL;\n\tRangeType  *right_range = NULL;\n\tOffsetNumber i,\n\t\t\t\tmaxoff,\n\t\t\t\tsplit_idx;\n\n\tmaxoff = entryvec->n - 1;\n\t/* Split entries before this to left page, after to right: */\n\tsplit_idx = (maxoff - FirstOffsetNumber) / 2 + FirstOffsetNumber;\n\n\tv->spl_nleft = 0;\n\tv->spl_nright = 0;\n\tfor (i = FirstOffsetNumber; i <= maxoff; i++)\n\t{\n\t\tRangeType  *range = DatumGetRangeTypeP(entryvec->vector[i].key);\n\n\t\tif (i < split_idx)\n\t\t\tPLACE_LEFT(range, i);\n\t\telse\n\t\t\tPLACE_RIGHT(range, i);\n\t}\n\n\tv->spl_ldatum = RangeTypePGetDatum(left_range);\n\tv->spl_rdatum = RangeTypePGetDatum(right_range);\n}",
          "includes": [
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"access/stratnum.h\"",
            "#include \"access/gist.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void range_gist_fallback_split(TypeCacheEntry *typcache,\n\t\t\t\t\t\t  GistEntryVector *entryvec,\n\t\t\t\t\t\t  GIST_SPLITVEC *v);",
            "static void range_gist_double_sorting_split(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t\tGistEntryVector *entryvec,\n\t\t\t\t\t\t\t\tGIST_SPLITVEC *v);",
            "static int\tget_gist_range_class(RangeType *range);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/rangetypes.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"access/stratnum.h\"\n#include \"access/gist.h\"\n#include \"postgres.h\"\n\nstatic void range_gist_fallback_split(TypeCacheEntry *typcache,\n\t\t\t\t\t\t  GistEntryVector *entryvec,\n\t\t\t\t\t\t  GIST_SPLITVEC *v);\nstatic void range_gist_double_sorting_split(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t\tGistEntryVector *entryvec,\n\t\t\t\t\t\t\t\tGIST_SPLITVEC *v);\nstatic int\tget_gist_range_class(RangeType *range);\n\nstatic void\nrange_gist_fallback_split(TypeCacheEntry *typcache,\n\t\t\t\t\t\t  GistEntryVector *entryvec,\n\t\t\t\t\t\t  GIST_SPLITVEC *v)\n{\n\tRangeType  *left_range = NULL;\n\tRangeType  *right_range = NULL;\n\tOffsetNumber i,\n\t\t\t\tmaxoff,\n\t\t\t\tsplit_idx;\n\n\tmaxoff = entryvec->n - 1;\n\t/* Split entries before this to left page, after to right: */\n\tsplit_idx = (maxoff - FirstOffsetNumber) / 2 + FirstOffsetNumber;\n\n\tv->spl_nleft = 0;\n\tv->spl_nright = 0;\n\tfor (i = FirstOffsetNumber; i <= maxoff; i++)\n\t{\n\t\tRangeType  *range = DatumGetRangeTypeP(entryvec->vector[i].key);\n\n\t\tif (i < split_idx)\n\t\t\tPLACE_LEFT(range, i);\n\t\telse\n\t\t\tPLACE_RIGHT(range, i);\n\t}\n\n\tv->spl_ldatum = RangeTypePGetDatum(left_range);\n\tv->spl_rdatum = RangeTypePGetDatum(right_range);\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_gist_single_sorting_split",
          "args": [
            "typcache",
            "entryvec",
            "v",
            "false"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "range_gist_single_sorting_split",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_gist.c",
          "lines": "961-1020",
          "snippet": "static void\nrange_gist_single_sorting_split(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t\tGistEntryVector *entryvec,\n\t\t\t\t\t\t\t\tGIST_SPLITVEC *v,\n\t\t\t\t\t\t\t\tbool use_upper_bound)\n{\n\tSingleBoundSortItem *sortItems;\n\tRangeType  *left_range = NULL;\n\tRangeType  *right_range = NULL;\n\tOffsetNumber i,\n\t\t\t\tmaxoff,\n\t\t\t\tsplit_idx;\n\n\tmaxoff = entryvec->n - 1;\n\n\tsortItems = (SingleBoundSortItem *)\n\t\tpalloc(maxoff * sizeof(SingleBoundSortItem));\n\n\t/*\n\t * Prepare auxiliary array and sort the values.\n\t */\n\tfor (i = FirstOffsetNumber; i <= maxoff; i = OffsetNumberNext(i))\n\t{\n\t\tRangeType  *range = DatumGetRangeTypeP(entryvec->vector[i].key);\n\t\tRangeBound\tbound2;\n\t\tbool\t\tempty;\n\n\t\tsortItems[i - 1].index = i;\n\t\t/* Put appropriate bound into array */\n\t\tif (use_upper_bound)\n\t\t\trange_deserialize(typcache, range, &bound2,\n\t\t\t\t\t\t\t  &sortItems[i - 1].bound, &empty);\n\t\telse\n\t\t\trange_deserialize(typcache, range, &sortItems[i - 1].bound,\n\t\t\t\t\t\t\t  &bound2, &empty);\n\t\tAssert(!empty);\n\t}\n\n\tqsort_arg(sortItems, maxoff, sizeof(SingleBoundSortItem),\n\t\t\t  single_bound_cmp, typcache);\n\n\tsplit_idx = maxoff / 2;\n\n\tv->spl_nleft = 0;\n\tv->spl_nright = 0;\n\n\tfor (i = 0; i < maxoff; i++)\n\t{\n\t\tint\t\t\tidx = sortItems[i].index;\n\t\tRangeType  *range = DatumGetRangeTypeP(entryvec->vector[idx].key);\n\n\t\tif (i < split_idx)\n\t\t\tPLACE_LEFT(range, idx);\n\t\telse\n\t\t\tPLACE_RIGHT(range, idx);\n\t}\n\n\tv->spl_ldatum = RangeTypePGetDatum(left_range);\n\tv->spl_rdatum = RangeTypePGetDatum(right_range);\n}",
          "includes": [
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"access/stratnum.h\"",
            "#include \"access/gist.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void range_gist_fallback_split(TypeCacheEntry *typcache,\n\t\t\t\t\t\t  GistEntryVector *entryvec,\n\t\t\t\t\t\t  GIST_SPLITVEC *v);",
            "static void range_gist_single_sorting_split(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t\tGistEntryVector *entryvec,\n\t\t\t\t\t\t\t\tGIST_SPLITVEC *v,\n\t\t\t\t\t\t\t\tbool use_upper_bound);",
            "static void range_gist_double_sorting_split(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t\tGistEntryVector *entryvec,\n\t\t\t\t\t\t\t\tGIST_SPLITVEC *v);",
            "static int\tget_gist_range_class(RangeType *range);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/rangetypes.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"access/stratnum.h\"\n#include \"access/gist.h\"\n#include \"postgres.h\"\n\nstatic void range_gist_fallback_split(TypeCacheEntry *typcache,\n\t\t\t\t\t\t  GistEntryVector *entryvec,\n\t\t\t\t\t\t  GIST_SPLITVEC *v);\nstatic void range_gist_single_sorting_split(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t\tGistEntryVector *entryvec,\n\t\t\t\t\t\t\t\tGIST_SPLITVEC *v,\n\t\t\t\t\t\t\t\tbool use_upper_bound);\nstatic void range_gist_double_sorting_split(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t\tGistEntryVector *entryvec,\n\t\t\t\t\t\t\t\tGIST_SPLITVEC *v);\nstatic int\tget_gist_range_class(RangeType *range);\n\nstatic void\nrange_gist_single_sorting_split(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t\tGistEntryVector *entryvec,\n\t\t\t\t\t\t\t\tGIST_SPLITVEC *v,\n\t\t\t\t\t\t\t\tbool use_upper_bound)\n{\n\tSingleBoundSortItem *sortItems;\n\tRangeType  *left_range = NULL;\n\tRangeType  *right_range = NULL;\n\tOffsetNumber i,\n\t\t\t\tmaxoff,\n\t\t\t\tsplit_idx;\n\n\tmaxoff = entryvec->n - 1;\n\n\tsortItems = (SingleBoundSortItem *)\n\t\tpalloc(maxoff * sizeof(SingleBoundSortItem));\n\n\t/*\n\t * Prepare auxiliary array and sort the values.\n\t */\n\tfor (i = FirstOffsetNumber; i <= maxoff; i = OffsetNumberNext(i))\n\t{\n\t\tRangeType  *range = DatumGetRangeTypeP(entryvec->vector[i].key);\n\t\tRangeBound\tbound2;\n\t\tbool\t\tempty;\n\n\t\tsortItems[i - 1].index = i;\n\t\t/* Put appropriate bound into array */\n\t\tif (use_upper_bound)\n\t\t\trange_deserialize(typcache, range, &bound2,\n\t\t\t\t\t\t\t  &sortItems[i - 1].bound, &empty);\n\t\telse\n\t\t\trange_deserialize(typcache, range, &sortItems[i - 1].bound,\n\t\t\t\t\t\t\t  &bound2, &empty);\n\t\tAssert(!empty);\n\t}\n\n\tqsort_arg(sortItems, maxoff, sizeof(SingleBoundSortItem),\n\t\t\t  single_bound_cmp, typcache);\n\n\tsplit_idx = maxoff / 2;\n\n\tv->spl_nleft = 0;\n\tv->spl_nright = 0;\n\n\tfor (i = 0; i < maxoff; i++)\n\t{\n\t\tint\t\t\tidx = sortItems[i].index;\n\t\tRangeType  *range = DatumGetRangeTypeP(entryvec->vector[idx].key);\n\n\t\tif (i < split_idx)\n\t\t\tPLACE_LEFT(range, idx);\n\t\telse\n\t\t\tPLACE_RIGHT(range, idx);\n\t}\n\n\tv->spl_ldatum = RangeTypePGetDatum(left_range);\n\tv->spl_rdatum = RangeTypePGetDatum(right_range);\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_gist_double_sorting_split",
          "args": [
            "typcache",
            "entryvec",
            "v"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "range_gist_double_sorting_split",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_gist.c",
          "lines": "1050-1346",
          "snippet": "static void\nrange_gist_double_sorting_split(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t\tGistEntryVector *entryvec,\n\t\t\t\t\t\t\t\tGIST_SPLITVEC *v)\n{\n\tConsiderSplitContext context;\n\tOffsetNumber i,\n\t\t\t\tmaxoff;\n\tRangeType  *range,\n\t\t\t   *left_range = NULL,\n\t\t\t   *right_range = NULL;\n\tint\t\t\tcommon_entries_count;\n\tNonEmptyRange *by_lower,\n\t\t\t   *by_upper;\n\tCommonEntry *common_entries;\n\tint\t\t\tnentries,\n\t\t\t\ti1,\n\t\t\t\ti2;\n\tRangeBound *right_lower,\n\t\t\t   *left_upper;\n\n\tmemset(&context, 0, sizeof(ConsiderSplitContext));\n\tcontext.typcache = typcache;\n\tcontext.has_subtype_diff = OidIsValid(typcache->rng_subdiff_finfo.fn_oid);\n\n\tmaxoff = entryvec->n - 1;\n\tnentries = context.entries_count = maxoff - FirstOffsetNumber + 1;\n\tcontext.first = true;\n\n\t/* Allocate arrays for sorted range bounds */\n\tby_lower = (NonEmptyRange *) palloc(nentries * sizeof(NonEmptyRange));\n\tby_upper = (NonEmptyRange *) palloc(nentries * sizeof(NonEmptyRange));\n\n\t/* Fill arrays of bounds */\n\tfor (i = FirstOffsetNumber; i <= maxoff; i = OffsetNumberNext(i))\n\t{\n\t\tRangeType  *range = DatumGetRangeTypeP(entryvec->vector[i].key);\n\t\tbool\t\tempty;\n\n\t\trange_deserialize(typcache, range,\n\t\t\t\t\t\t  &by_lower[i - FirstOffsetNumber].lower,\n\t\t\t\t\t\t  &by_lower[i - FirstOffsetNumber].upper,\n\t\t\t\t\t\t  &empty);\n\t\tAssert(!empty);\n\t}\n\n\t/*\n\t * Make two arrays of range bounds: one sorted by lower bound and another\n\t * sorted by upper bound.\n\t */\n\tmemcpy(by_upper, by_lower, nentries * sizeof(NonEmptyRange));\n\tqsort_arg(by_lower, nentries, sizeof(NonEmptyRange),\n\t\t\t  interval_cmp_lower, typcache);\n\tqsort_arg(by_upper, nentries, sizeof(NonEmptyRange),\n\t\t\t  interval_cmp_upper, typcache);\n\n\t/*----------\n\t * The goal is to form a left and right range, so that every entry\n\t * range is contained by either left or right interval (or both).\n\t *\n\t * For example, with the ranges (0,1), (1,3), (2,3), (2,4):\n\t *\n\t * 0 1 2 3 4\n\t * +-+\n\t *\t +---+\n\t *\t   +-+\n\t *\t   +---+\n\t *\n\t * The left and right ranges are of the form (0,a) and (b,4).\n\t * We first consider splits where b is the lower bound of an entry.\n\t * We iterate through all entries, and for each b, calculate the\n\t * smallest possible a. Then we consider splits where a is the\n\t * upper bound of an entry, and for each a, calculate the greatest\n\t * possible b.\n\t *\n\t * In the above example, the first loop would consider splits:\n\t * b=0: (0,1)-(0,4)\n\t * b=1: (0,1)-(1,4)\n\t * b=2: (0,3)-(2,4)\n\t *\n\t * And the second loop:\n\t * a=1: (0,1)-(1,4)\n\t * a=3: (0,3)-(2,4)\n\t * a=4: (0,4)-(2,4)\n\t *----------\n\t */\n\n\t/*\n\t * Iterate over lower bound of right group, finding smallest possible\n\t * upper bound of left group.\n\t */\n\ti1 = 0;\n\ti2 = 0;\n\tright_lower = &by_lower[i1].lower;\n\tleft_upper = &by_upper[i2].lower;\n\twhile (true)\n\t{\n\t\t/*\n\t\t * Find next lower bound of right group.\n\t\t */\n\t\twhile (i1 < nentries &&\n\t\t\t   range_cmp_bounds(typcache, right_lower,\n\t\t\t\t\t\t\t\t&by_lower[i1].lower) == 0)\n\t\t{\n\t\t\tif (range_cmp_bounds(typcache, &by_lower[i1].upper,\n\t\t\t\t\t\t\t\t left_upper) > 0)\n\t\t\t\tleft_upper = &by_lower[i1].upper;\n\t\t\ti1++;\n\t\t}\n\t\tif (i1 >= nentries)\n\t\t\tbreak;\n\t\tright_lower = &by_lower[i1].lower;\n\n\t\t/*\n\t\t * Find count of ranges which anyway should be placed to the left\n\t\t * group.\n\t\t */\n\t\twhile (i2 < nentries &&\n\t\t\t   range_cmp_bounds(typcache, &by_upper[i2].upper,\n\t\t\t\t\t\t\t\tleft_upper) <= 0)\n\t\t\ti2++;\n\n\t\t/*\n\t\t * Consider found split to see if it's better than what we had.\n\t\t */\n\t\trange_gist_consider_split(&context, right_lower, i1, left_upper, i2);\n\t}\n\n\t/*\n\t * Iterate over upper bound of left group finding greatest possible lower\n\t * bound of right group.\n\t */\n\ti1 = nentries - 1;\n\ti2 = nentries - 1;\n\tright_lower = &by_lower[i1].upper;\n\tleft_upper = &by_upper[i2].upper;\n\twhile (true)\n\t{\n\t\t/*\n\t\t * Find next upper bound of left group.\n\t\t */\n\t\twhile (i2 >= 0 &&\n\t\t\t   range_cmp_bounds(typcache, left_upper,\n\t\t\t\t\t\t\t\t&by_upper[i2].upper) == 0)\n\t\t{\n\t\t\tif (range_cmp_bounds(typcache, &by_upper[i2].lower,\n\t\t\t\t\t\t\t\t right_lower) < 0)\n\t\t\t\tright_lower = &by_upper[i2].lower;\n\t\t\ti2--;\n\t\t}\n\t\tif (i2 < 0)\n\t\t\tbreak;\n\t\tleft_upper = &by_upper[i2].upper;\n\n\t\t/*\n\t\t * Find count of intervals which anyway should be placed to the right\n\t\t * group.\n\t\t */\n\t\twhile (i1 >= 0 &&\n\t\t\t   range_cmp_bounds(typcache, &by_lower[i1].lower,\n\t\t\t\t\t\t\t\tright_lower) >= 0)\n\t\t\ti1--;\n\n\t\t/*\n\t\t * Consider found split to see if it's better than what we had.\n\t\t */\n\t\trange_gist_consider_split(&context, right_lower, i1 + 1,\n\t\t\t\t\t\t\t\t  left_upper, i2 + 1);\n\t}\n\n\t/*\n\t * If we failed to find any acceptable splits, use trivial split.\n\t */\n\tif (context.first)\n\t{\n\t\trange_gist_fallback_split(typcache, entryvec, v);\n\t\treturn;\n\t}\n\n\t/*\n\t * Ok, we have now selected bounds of the groups. Now we have to\n\t * distribute entries themselves. At first we distribute entries which can\n\t * be placed unambiguously and collect \"common entries\" to array.\n\t */\n\n\t/* Allocate vectors for results */\n\tv->spl_left = (OffsetNumber *) palloc(nentries * sizeof(OffsetNumber));\n\tv->spl_right = (OffsetNumber *) palloc(nentries * sizeof(OffsetNumber));\n\tv->spl_nleft = 0;\n\tv->spl_nright = 0;\n\n\t/*\n\t * Allocate an array for \"common entries\" - entries which can be placed to\n\t * either group without affecting overlap along selected axis.\n\t */\n\tcommon_entries_count = 0;\n\tcommon_entries = (CommonEntry *) palloc(nentries * sizeof(CommonEntry));\n\n\t/*\n\t * Distribute entries which can be distributed unambiguously, and collect\n\t * common entries.\n\t */\n\tfor (i = FirstOffsetNumber; i <= maxoff; i = OffsetNumberNext(i))\n\t{\n\t\tRangeBound\tlower,\n\t\t\t\t\tupper;\n\t\tbool\t\tempty;\n\n\t\t/*\n\t\t * Get upper and lower bounds along selected axis.\n\t\t */\n\t\trange = DatumGetRangeTypeP(entryvec->vector[i].key);\n\n\t\trange_deserialize(typcache, range, &lower, &upper, &empty);\n\n\t\tif (range_cmp_bounds(typcache, &upper, context.left_upper) <= 0)\n\t\t{\n\t\t\t/* Fits in the left group */\n\t\t\tif (range_cmp_bounds(typcache, &lower, context.right_lower) >= 0)\n\t\t\t{\n\t\t\t\t/* Fits also in the right group, so \"common entry\" */\n\t\t\t\tcommon_entries[common_entries_count].index = i;\n\t\t\t\tif (context.has_subtype_diff)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * delta = (lower - context.right_lower) -\n\t\t\t\t\t * (context.left_upper - upper)\n\t\t\t\t\t */\n\t\t\t\t\tcommon_entries[common_entries_count].delta =\n\t\t\t\t\t\tcall_subtype_diff(typcache,\n\t\t\t\t\t\t\t\t\t\t  lower.val,\n\t\t\t\t\t\t\t\t\t\t  context.right_lower->val) -\n\t\t\t\t\t\tcall_subtype_diff(typcache,\n\t\t\t\t\t\t\t\t\t\t  context.left_upper->val,\n\t\t\t\t\t\t\t\t\t\t  upper.val);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* Without subtype_diff, take all deltas as zero */\n\t\t\t\t\tcommon_entries[common_entries_count].delta = 0;\n\t\t\t\t}\n\t\t\t\tcommon_entries_count++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Doesn't fit to the right group, so join to the left group */\n\t\t\t\tPLACE_LEFT(range, i);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Each entry should fit on either left or right group. Since this\n\t\t\t * entry didn't fit in the left group, it better fit in the right\n\t\t\t * group.\n\t\t\t */\n\t\t\tAssert(range_cmp_bounds(typcache, &lower,\n\t\t\t\t\t\t\t\t\tcontext.right_lower) >= 0);\n\t\t\tPLACE_RIGHT(range, i);\n\t\t}\n\t}\n\n\t/*\n\t * Distribute \"common entries\", if any.\n\t */\n\tif (common_entries_count > 0)\n\t{\n\t\t/*\n\t\t * Sort \"common entries\" by calculated deltas in order to distribute\n\t\t * the most ambiguous entries first.\n\t\t */\n\t\tqsort(common_entries, common_entries_count, sizeof(CommonEntry),\n\t\t\t  common_entry_cmp);\n\n\t\t/*\n\t\t * Distribute \"common entries\" between groups according to sorting.\n\t\t */\n\t\tfor (i = 0; i < common_entries_count; i++)\n\t\t{\n\t\t\tint\t\t\tidx = common_entries[i].index;\n\n\t\t\trange = DatumGetRangeTypeP(entryvec->vector[idx].key);\n\n\t\t\t/*\n\t\t\t * Check if we have to place this entry in either group to achieve\n\t\t\t * LIMIT_RATIO.\n\t\t\t */\n\t\t\tif (i < context.common_left)\n\t\t\t\tPLACE_LEFT(range, idx);\n\t\t\telse\n\t\t\t\tPLACE_RIGHT(range, idx);\n\t\t}\n\t}\n\n\tv->spl_ldatum = PointerGetDatum(left_range);\n\tv->spl_rdatum = PointerGetDatum(right_range);\n}",
          "includes": [
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"access/stratnum.h\"",
            "#include \"access/gist.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define LIMIT_RATIO  0.3"
          ],
          "globals_used": [
            "static void range_gist_fallback_split(TypeCacheEntry *typcache,\n\t\t\t\t\t\t  GistEntryVector *entryvec,\n\t\t\t\t\t\t  GIST_SPLITVEC *v);",
            "static void range_gist_double_sorting_split(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t\tGistEntryVector *entryvec,\n\t\t\t\t\t\t\t\tGIST_SPLITVEC *v);",
            "static int\tget_gist_range_class(RangeType *range);",
            "static int\tcommon_entry_cmp(const void *i1, const void *i2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/rangetypes.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"access/stratnum.h\"\n#include \"access/gist.h\"\n#include \"postgres.h\"\n\n#define LIMIT_RATIO  0.3\n\nstatic void range_gist_fallback_split(TypeCacheEntry *typcache,\n\t\t\t\t\t\t  GistEntryVector *entryvec,\n\t\t\t\t\t\t  GIST_SPLITVEC *v);\nstatic void range_gist_double_sorting_split(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t\tGistEntryVector *entryvec,\n\t\t\t\t\t\t\t\tGIST_SPLITVEC *v);\nstatic int\tget_gist_range_class(RangeType *range);\nstatic int\tcommon_entry_cmp(const void *i1, const void *i2);\n\nstatic void\nrange_gist_double_sorting_split(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t\tGistEntryVector *entryvec,\n\t\t\t\t\t\t\t\tGIST_SPLITVEC *v)\n{\n\tConsiderSplitContext context;\n\tOffsetNumber i,\n\t\t\t\tmaxoff;\n\tRangeType  *range,\n\t\t\t   *left_range = NULL,\n\t\t\t   *right_range = NULL;\n\tint\t\t\tcommon_entries_count;\n\tNonEmptyRange *by_lower,\n\t\t\t   *by_upper;\n\tCommonEntry *common_entries;\n\tint\t\t\tnentries,\n\t\t\t\ti1,\n\t\t\t\ti2;\n\tRangeBound *right_lower,\n\t\t\t   *left_upper;\n\n\tmemset(&context, 0, sizeof(ConsiderSplitContext));\n\tcontext.typcache = typcache;\n\tcontext.has_subtype_diff = OidIsValid(typcache->rng_subdiff_finfo.fn_oid);\n\n\tmaxoff = entryvec->n - 1;\n\tnentries = context.entries_count = maxoff - FirstOffsetNumber + 1;\n\tcontext.first = true;\n\n\t/* Allocate arrays for sorted range bounds */\n\tby_lower = (NonEmptyRange *) palloc(nentries * sizeof(NonEmptyRange));\n\tby_upper = (NonEmptyRange *) palloc(nentries * sizeof(NonEmptyRange));\n\n\t/* Fill arrays of bounds */\n\tfor (i = FirstOffsetNumber; i <= maxoff; i = OffsetNumberNext(i))\n\t{\n\t\tRangeType  *range = DatumGetRangeTypeP(entryvec->vector[i].key);\n\t\tbool\t\tempty;\n\n\t\trange_deserialize(typcache, range,\n\t\t\t\t\t\t  &by_lower[i - FirstOffsetNumber].lower,\n\t\t\t\t\t\t  &by_lower[i - FirstOffsetNumber].upper,\n\t\t\t\t\t\t  &empty);\n\t\tAssert(!empty);\n\t}\n\n\t/*\n\t * Make two arrays of range bounds: one sorted by lower bound and another\n\t * sorted by upper bound.\n\t */\n\tmemcpy(by_upper, by_lower, nentries * sizeof(NonEmptyRange));\n\tqsort_arg(by_lower, nentries, sizeof(NonEmptyRange),\n\t\t\t  interval_cmp_lower, typcache);\n\tqsort_arg(by_upper, nentries, sizeof(NonEmptyRange),\n\t\t\t  interval_cmp_upper, typcache);\n\n\t/*----------\n\t * The goal is to form a left and right range, so that every entry\n\t * range is contained by either left or right interval (or both).\n\t *\n\t * For example, with the ranges (0,1), (1,3), (2,3), (2,4):\n\t *\n\t * 0 1 2 3 4\n\t * +-+\n\t *\t +---+\n\t *\t   +-+\n\t *\t   +---+\n\t *\n\t * The left and right ranges are of the form (0,a) and (b,4).\n\t * We first consider splits where b is the lower bound of an entry.\n\t * We iterate through all entries, and for each b, calculate the\n\t * smallest possible a. Then we consider splits where a is the\n\t * upper bound of an entry, and for each a, calculate the greatest\n\t * possible b.\n\t *\n\t * In the above example, the first loop would consider splits:\n\t * b=0: (0,1)-(0,4)\n\t * b=1: (0,1)-(1,4)\n\t * b=2: (0,3)-(2,4)\n\t *\n\t * And the second loop:\n\t * a=1: (0,1)-(1,4)\n\t * a=3: (0,3)-(2,4)\n\t * a=4: (0,4)-(2,4)\n\t *----------\n\t */\n\n\t/*\n\t * Iterate over lower bound of right group, finding smallest possible\n\t * upper bound of left group.\n\t */\n\ti1 = 0;\n\ti2 = 0;\n\tright_lower = &by_lower[i1].lower;\n\tleft_upper = &by_upper[i2].lower;\n\twhile (true)\n\t{\n\t\t/*\n\t\t * Find next lower bound of right group.\n\t\t */\n\t\twhile (i1 < nentries &&\n\t\t\t   range_cmp_bounds(typcache, right_lower,\n\t\t\t\t\t\t\t\t&by_lower[i1].lower) == 0)\n\t\t{\n\t\t\tif (range_cmp_bounds(typcache, &by_lower[i1].upper,\n\t\t\t\t\t\t\t\t left_upper) > 0)\n\t\t\t\tleft_upper = &by_lower[i1].upper;\n\t\t\ti1++;\n\t\t}\n\t\tif (i1 >= nentries)\n\t\t\tbreak;\n\t\tright_lower = &by_lower[i1].lower;\n\n\t\t/*\n\t\t * Find count of ranges which anyway should be placed to the left\n\t\t * group.\n\t\t */\n\t\twhile (i2 < nentries &&\n\t\t\t   range_cmp_bounds(typcache, &by_upper[i2].upper,\n\t\t\t\t\t\t\t\tleft_upper) <= 0)\n\t\t\ti2++;\n\n\t\t/*\n\t\t * Consider found split to see if it's better than what we had.\n\t\t */\n\t\trange_gist_consider_split(&context, right_lower, i1, left_upper, i2);\n\t}\n\n\t/*\n\t * Iterate over upper bound of left group finding greatest possible lower\n\t * bound of right group.\n\t */\n\ti1 = nentries - 1;\n\ti2 = nentries - 1;\n\tright_lower = &by_lower[i1].upper;\n\tleft_upper = &by_upper[i2].upper;\n\twhile (true)\n\t{\n\t\t/*\n\t\t * Find next upper bound of left group.\n\t\t */\n\t\twhile (i2 >= 0 &&\n\t\t\t   range_cmp_bounds(typcache, left_upper,\n\t\t\t\t\t\t\t\t&by_upper[i2].upper) == 0)\n\t\t{\n\t\t\tif (range_cmp_bounds(typcache, &by_upper[i2].lower,\n\t\t\t\t\t\t\t\t right_lower) < 0)\n\t\t\t\tright_lower = &by_upper[i2].lower;\n\t\t\ti2--;\n\t\t}\n\t\tif (i2 < 0)\n\t\t\tbreak;\n\t\tleft_upper = &by_upper[i2].upper;\n\n\t\t/*\n\t\t * Find count of intervals which anyway should be placed to the right\n\t\t * group.\n\t\t */\n\t\twhile (i1 >= 0 &&\n\t\t\t   range_cmp_bounds(typcache, &by_lower[i1].lower,\n\t\t\t\t\t\t\t\tright_lower) >= 0)\n\t\t\ti1--;\n\n\t\t/*\n\t\t * Consider found split to see if it's better than what we had.\n\t\t */\n\t\trange_gist_consider_split(&context, right_lower, i1 + 1,\n\t\t\t\t\t\t\t\t  left_upper, i2 + 1);\n\t}\n\n\t/*\n\t * If we failed to find any acceptable splits, use trivial split.\n\t */\n\tif (context.first)\n\t{\n\t\trange_gist_fallback_split(typcache, entryvec, v);\n\t\treturn;\n\t}\n\n\t/*\n\t * Ok, we have now selected bounds of the groups. Now we have to\n\t * distribute entries themselves. At first we distribute entries which can\n\t * be placed unambiguously and collect \"common entries\" to array.\n\t */\n\n\t/* Allocate vectors for results */\n\tv->spl_left = (OffsetNumber *) palloc(nentries * sizeof(OffsetNumber));\n\tv->spl_right = (OffsetNumber *) palloc(nentries * sizeof(OffsetNumber));\n\tv->spl_nleft = 0;\n\tv->spl_nright = 0;\n\n\t/*\n\t * Allocate an array for \"common entries\" - entries which can be placed to\n\t * either group without affecting overlap along selected axis.\n\t */\n\tcommon_entries_count = 0;\n\tcommon_entries = (CommonEntry *) palloc(nentries * sizeof(CommonEntry));\n\n\t/*\n\t * Distribute entries which can be distributed unambiguously, and collect\n\t * common entries.\n\t */\n\tfor (i = FirstOffsetNumber; i <= maxoff; i = OffsetNumberNext(i))\n\t{\n\t\tRangeBound\tlower,\n\t\t\t\t\tupper;\n\t\tbool\t\tempty;\n\n\t\t/*\n\t\t * Get upper and lower bounds along selected axis.\n\t\t */\n\t\trange = DatumGetRangeTypeP(entryvec->vector[i].key);\n\n\t\trange_deserialize(typcache, range, &lower, &upper, &empty);\n\n\t\tif (range_cmp_bounds(typcache, &upper, context.left_upper) <= 0)\n\t\t{\n\t\t\t/* Fits in the left group */\n\t\t\tif (range_cmp_bounds(typcache, &lower, context.right_lower) >= 0)\n\t\t\t{\n\t\t\t\t/* Fits also in the right group, so \"common entry\" */\n\t\t\t\tcommon_entries[common_entries_count].index = i;\n\t\t\t\tif (context.has_subtype_diff)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * delta = (lower - context.right_lower) -\n\t\t\t\t\t * (context.left_upper - upper)\n\t\t\t\t\t */\n\t\t\t\t\tcommon_entries[common_entries_count].delta =\n\t\t\t\t\t\tcall_subtype_diff(typcache,\n\t\t\t\t\t\t\t\t\t\t  lower.val,\n\t\t\t\t\t\t\t\t\t\t  context.right_lower->val) -\n\t\t\t\t\t\tcall_subtype_diff(typcache,\n\t\t\t\t\t\t\t\t\t\t  context.left_upper->val,\n\t\t\t\t\t\t\t\t\t\t  upper.val);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* Without subtype_diff, take all deltas as zero */\n\t\t\t\t\tcommon_entries[common_entries_count].delta = 0;\n\t\t\t\t}\n\t\t\t\tcommon_entries_count++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Doesn't fit to the right group, so join to the left group */\n\t\t\t\tPLACE_LEFT(range, i);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Each entry should fit on either left or right group. Since this\n\t\t\t * entry didn't fit in the left group, it better fit in the right\n\t\t\t * group.\n\t\t\t */\n\t\t\tAssert(range_cmp_bounds(typcache, &lower,\n\t\t\t\t\t\t\t\t\tcontext.right_lower) >= 0);\n\t\t\tPLACE_RIGHT(range, i);\n\t\t}\n\t}\n\n\t/*\n\t * Distribute \"common entries\", if any.\n\t */\n\tif (common_entries_count > 0)\n\t{\n\t\t/*\n\t\t * Sort \"common entries\" by calculated deltas in order to distribute\n\t\t * the most ambiguous entries first.\n\t\t */\n\t\tqsort(common_entries, common_entries_count, sizeof(CommonEntry),\n\t\t\t  common_entry_cmp);\n\n\t\t/*\n\t\t * Distribute \"common entries\" between groups according to sorting.\n\t\t */\n\t\tfor (i = 0; i < common_entries_count; i++)\n\t\t{\n\t\t\tint\t\t\tidx = common_entries[i].index;\n\n\t\t\trange = DatumGetRangeTypeP(entryvec->vector[idx].key);\n\n\t\t\t/*\n\t\t\t * Check if we have to place this entry in either group to achieve\n\t\t\t * LIMIT_RATIO.\n\t\t\t */\n\t\t\tif (i < context.common_left)\n\t\t\t\tPLACE_LEFT(range, idx);\n\t\t\telse\n\t\t\t\tPLACE_RIGHT(range, idx);\n\t\t}\n\t}\n\n\tv->spl_ldatum = PointerGetDatum(left_range);\n\tv->spl_rdatum = PointerGetDatum(right_range);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "non_empty_classes_count > 0"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_gist_range_class",
          "args": [
            "range"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "get_gist_range_class",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_gist.c",
          "lines": "1435-1457",
          "snippet": "static int\nget_gist_range_class(RangeType *range)\n{\n\tint\t\t\tclassNumber;\n\tchar\t\tflags;\n\n\tflags = range_get_flags(range);\n\tif (flags & RANGE_EMPTY)\n\t{\n\t\tclassNumber = CLS_EMPTY;\n\t}\n\telse\n\t{\n\t\tclassNumber = 0;\n\t\tif (flags & RANGE_LB_INF)\n\t\t\tclassNumber |= CLS_LOWER_INF;\n\t\tif (flags & RANGE_UB_INF)\n\t\t\tclassNumber |= CLS_UPPER_INF;\n\t\tif (flags & RANGE_CONTAIN_EMPTY)\n\t\t\tclassNumber |= CLS_CONTAIN_EMPTY;\n\t}\n\treturn classNumber;\n}",
          "includes": [
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"access/stratnum.h\"",
            "#include \"access/gist.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define CLS_EMPTY\t\t\t8\t/* Special class for empty ranges */",
            "#define CLS_CONTAIN_EMPTY\t4\t/* Contains underlying empty ranges */",
            "#define CLS_UPPER_INF\t\t2\t/* Upper bound is infinity */",
            "#define CLS_LOWER_INF\t\t1\t/* Lower bound is infinity */"
          ],
          "globals_used": [
            "static int\tget_gist_range_class(RangeType *range);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/rangetypes.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"access/stratnum.h\"\n#include \"access/gist.h\"\n#include \"postgres.h\"\n\n#define CLS_EMPTY\t\t\t8\t/* Special class for empty ranges */\n#define CLS_CONTAIN_EMPTY\t4\t/* Contains underlying empty ranges */\n#define CLS_UPPER_INF\t\t2\t/* Upper bound is infinity */\n#define CLS_LOWER_INF\t\t1\t/* Lower bound is infinity */\n\nstatic int\tget_gist_range_class(RangeType *range);\n\nstatic int\nget_gist_range_class(RangeType *range)\n{\n\tint\t\t\tclassNumber;\n\tchar\t\tflags;\n\n\tflags = range_get_flags(range);\n\tif (flags & RANGE_EMPTY)\n\t{\n\t\tclassNumber = CLS_EMPTY;\n\t}\n\telse\n\t{\n\t\tclassNumber = 0;\n\t\tif (flags & RANGE_LB_INF)\n\t\t\tclassNumber |= CLS_LOWER_INF;\n\t\tif (flags & RANGE_UB_INF)\n\t\t\tclassNumber |= CLS_UPPER_INF;\n\t\tif (flags & RANGE_CONTAIN_EMPTY)\n\t\t\tclassNumber |= CLS_CONTAIN_EMPTY;\n\t}\n\treturn classNumber;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetRangeTypeP",
          "args": [
            "entryvec->vector[i].key"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OffsetNumberNext",
          "args": [
            "i"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "count_in_classes",
            "0",
            "sizeof(count_in_classes)"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "nbytes"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_get_typcache",
          "args": [
            "fcinfo",
            "RangeTypeGetOid(pred_left)"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "range_get_typcache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1542-1557",
          "snippet": "TypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nTypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RangeTypeGetOid",
          "args": [
            "pred_left"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetRangeTypeP",
          "args": [
            "entryvec->vector[FirstOffsetNumber].key"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "1"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/rangetypes.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"access/stratnum.h\"\n#include \"access/gist.h\"\n#include \"postgres.h\"\n\n#define CLS_COUNT\t\t\t9\t/* # of classes; includes all combinations of\n\t\t\t\t\t\t\t\t * properties. CLS_EMPTY doesn't combine with\n\t\t\t\t\t\t\t\t * anything else, so it's only 2^3 + 1. */\n#define CLS_EMPTY\t\t\t8\t/* Special class for empty ranges */\n#define CLS_CONTAIN_EMPTY\t4\t/* Contains underlying empty ranges */\n#define CLS_UPPER_INF\t\t2\t/* Upper bound is infinity */\n#define CLS_LOWER_INF\t\t1\t/* Lower bound is infinity */\n#define CLS_NORMAL\t\t\t0\t/* Ordinary finite range (no bits set) */\n\nstatic void range_gist_fallback_split(TypeCacheEntry *typcache,\n\t\t\t\t\t\t  GistEntryVector *entryvec,\n\t\t\t\t\t\t  GIST_SPLITVEC *v);\nstatic void range_gist_class_split(TypeCacheEntry *typcache,\n\t\t\t\t\t   GistEntryVector *entryvec,\n\t\t\t\t\t   GIST_SPLITVEC *v,\n\t\t\t\t\t   SplitLR *classes_groups);\nstatic void range_gist_double_sorting_split(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t\tGistEntryVector *entryvec,\n\t\t\t\t\t\t\t\tGIST_SPLITVEC *v);\nstatic int\tget_gist_range_class(RangeType *range);\n\nDatum\nrange_gist_picksplit(PG_FUNCTION_ARGS)\n{\n\tGistEntryVector *entryvec = (GistEntryVector *) PG_GETARG_POINTER(0);\n\tGIST_SPLITVEC *v = (GIST_SPLITVEC *) PG_GETARG_POINTER(1);\n\tTypeCacheEntry *typcache;\n\tOffsetNumber i;\n\tRangeType  *pred_left;\n\tint\t\t\tnbytes;\n\tOffsetNumber maxoff;\n\tint\t\t\tcount_in_classes[CLS_COUNT];\n\tint\t\t\tj;\n\tint\t\t\tnon_empty_classes_count = 0;\n\tint\t\t\tbiggest_class = -1;\n\tint\t\t\tbiggest_class_count = 0;\n\tint\t\t\ttotal_count;\n\n\t/* use first item to look up range type's info */\n\tpred_left = DatumGetRangeTypeP(entryvec->vector[FirstOffsetNumber].key);\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(pred_left));\n\n\tmaxoff = entryvec->n - 1;\n\tnbytes = (maxoff + 1) * sizeof(OffsetNumber);\n\tv->spl_left = (OffsetNumber *) palloc(nbytes);\n\tv->spl_right = (OffsetNumber *) palloc(nbytes);\n\n\t/*\n\t * Get count distribution of range classes.\n\t */\n\tmemset(count_in_classes, 0, sizeof(count_in_classes));\n\tfor (i = FirstOffsetNumber; i <= maxoff; i = OffsetNumberNext(i))\n\t{\n\t\tRangeType  *range = DatumGetRangeTypeP(entryvec->vector[i].key);\n\n\t\tcount_in_classes[get_gist_range_class(range)]++;\n\t}\n\n\t/*\n\t * Count non-empty classes and find biggest class.\n\t */\n\ttotal_count = maxoff;\n\tfor (j = 0; j < CLS_COUNT; j++)\n\t{\n\t\tif (count_in_classes[j] > 0)\n\t\t{\n\t\t\tif (count_in_classes[j] > biggest_class_count)\n\t\t\t{\n\t\t\t\tbiggest_class_count = count_in_classes[j];\n\t\t\t\tbiggest_class = j;\n\t\t\t}\n\t\t\tnon_empty_classes_count++;\n\t\t}\n\t}\n\n\tAssert(non_empty_classes_count > 0);\n\n\tif (non_empty_classes_count == 1)\n\t{\n\t\t/* One non-empty class, so split inside class */\n\t\tif ((biggest_class & ~CLS_CONTAIN_EMPTY) == CLS_NORMAL)\n\t\t{\n\t\t\t/* double sorting split for normal ranges */\n\t\t\trange_gist_double_sorting_split(typcache, entryvec, v);\n\t\t}\n\t\telse if ((biggest_class & ~CLS_CONTAIN_EMPTY) == CLS_LOWER_INF)\n\t\t{\n\t\t\t/* upper bound sorting split for (-inf, x) ranges */\n\t\t\trange_gist_single_sorting_split(typcache, entryvec, v, true);\n\t\t}\n\t\telse if ((biggest_class & ~CLS_CONTAIN_EMPTY) == CLS_UPPER_INF)\n\t\t{\n\t\t\t/* lower bound sorting split for (x, +inf) ranges */\n\t\t\trange_gist_single_sorting_split(typcache, entryvec, v, false);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* trivial split for all (-inf, +inf) or all empty ranges */\n\t\t\trange_gist_fallback_split(typcache, entryvec, v);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Class based split.\n\t\t *\n\t\t * To which side of the split should each class go?  Initialize them\n\t\t * all to go to the left side.\n\t\t */\n\t\tSplitLR\t\tclasses_groups[CLS_COUNT];\n\n\t\tmemset(classes_groups, 0, sizeof(classes_groups));\n\n\t\tif (count_in_classes[CLS_NORMAL] > 0)\n\t\t{\n\t\t\t/* separate normal ranges if any */\n\t\t\tclasses_groups[CLS_NORMAL] = SPLIT_RIGHT;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*----------\n\t\t\t * Try to split classes in one of two ways:\n\t\t\t *\t1) containing infinities - not containing infinities\n\t\t\t *\t2) containing empty - not containing empty\n\t\t\t *\n\t\t\t * Select the way which balances the ranges between left and right\n\t\t\t * the best. If split in these ways is not possible, there are at\n\t\t\t * most 3 classes, so just separate biggest class.\n\t\t\t *----------\n\t\t\t */\n\t\t\tint\t\t\tinfCount,\n\t\t\t\t\t\tnonInfCount;\n\t\t\tint\t\t\temptyCount,\n\t\t\t\t\t\tnonEmptyCount;\n\n\t\t\tnonInfCount =\n\t\t\t\tcount_in_classes[CLS_NORMAL] +\n\t\t\t\tcount_in_classes[CLS_CONTAIN_EMPTY] +\n\t\t\t\tcount_in_classes[CLS_EMPTY];\n\t\t\tinfCount = total_count - nonInfCount;\n\n\t\t\tnonEmptyCount =\n\t\t\t\tcount_in_classes[CLS_NORMAL] +\n\t\t\t\tcount_in_classes[CLS_LOWER_INF] +\n\t\t\t\tcount_in_classes[CLS_UPPER_INF] +\n\t\t\t\tcount_in_classes[CLS_LOWER_INF | CLS_UPPER_INF];\n\t\t\temptyCount = total_count - nonEmptyCount;\n\n\t\t\tif (infCount > 0 && nonInfCount > 0 &&\n\t\t\t\t(Abs(infCount - nonInfCount) <=\n\t\t\t\t Abs(emptyCount - nonEmptyCount)))\n\t\t\t{\n\t\t\t\tclasses_groups[CLS_NORMAL] = SPLIT_RIGHT;\n\t\t\t\tclasses_groups[CLS_CONTAIN_EMPTY] = SPLIT_RIGHT;\n\t\t\t\tclasses_groups[CLS_EMPTY] = SPLIT_RIGHT;\n\t\t\t}\n\t\t\telse if (emptyCount > 0 && nonEmptyCount > 0)\n\t\t\t{\n\t\t\t\tclasses_groups[CLS_NORMAL] = SPLIT_RIGHT;\n\t\t\t\tclasses_groups[CLS_LOWER_INF] = SPLIT_RIGHT;\n\t\t\t\tclasses_groups[CLS_UPPER_INF] = SPLIT_RIGHT;\n\t\t\t\tclasses_groups[CLS_LOWER_INF | CLS_UPPER_INF] = SPLIT_RIGHT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Either total_count == emptyCount or total_count ==\n\t\t\t\t * infCount.\n\t\t\t\t */\n\t\t\t\tclasses_groups[biggest_class] = SPLIT_RIGHT;\n\t\t\t}\n\t\t}\n\n\t\trange_gist_class_split(typcache, entryvec, v, classes_groups);\n\t}\n\n\tPG_RETURN_POINTER(v);\n}"
  },
  {
    "function_name": "range_gist_penalty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_gist.c",
    "lines": "235-484",
    "snippet": "Datum\nrange_gist_penalty(PG_FUNCTION_ARGS)\n{\n\tGISTENTRY  *origentry = (GISTENTRY *) PG_GETARG_POINTER(0);\n\tGISTENTRY  *newentry = (GISTENTRY *) PG_GETARG_POINTER(1);\n\tfloat\t   *penalty = (float *) PG_GETARG_POINTER(2);\n\tRangeType  *orig = DatumGetRangeTypeP(origentry->key);\n\tRangeType  *new = DatumGetRangeTypeP(newentry->key);\n\tTypeCacheEntry *typcache;\n\tbool\t\thas_subtype_diff;\n\tRangeBound\torig_lower,\n\t\t\t\tnew_lower,\n\t\t\t\torig_upper,\n\t\t\t\tnew_upper;\n\tbool\t\torig_empty,\n\t\t\t\tnew_empty;\n\n\tif (RangeTypeGetOid(orig) != RangeTypeGetOid(new))\n\t\telog(ERROR, \"range types do not match\");\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(orig));\n\n\thas_subtype_diff = OidIsValid(typcache->rng_subdiff_finfo.fn_oid);\n\n\trange_deserialize(typcache, orig, &orig_lower, &orig_upper, &orig_empty);\n\trange_deserialize(typcache, new, &new_lower, &new_upper, &new_empty);\n\n\t/*\n\t * Distinct branches for handling distinct classes of ranges.  Note that\n\t * penalty values only need to be commensurate within the same class of\n\t * new range.\n\t */\n\tif (new_empty)\n\t{\n\t\t/* Handle insertion of empty range */\n\t\tif (orig_empty)\n\t\t{\n\t\t\t/*\n\t\t\t * The best case is to insert it to empty original range.\n\t\t\t * Insertion here means no broadening of original range. Also\n\t\t\t * original range is the most narrow.\n\t\t\t */\n\t\t\t*penalty = 0.0;\n\t\t}\n\t\telse if (RangeIsOrContainsEmpty(orig))\n\t\t{\n\t\t\t/*\n\t\t\t * The second case is to insert empty range into range which\n\t\t\t * contains at least one underlying empty range.  There is still\n\t\t\t * no broadening of original range, but original range is not as\n\t\t\t * narrow as possible.\n\t\t\t */\n\t\t\t*penalty = CONTAIN_EMPTY_PENALTY;\n\t\t}\n\t\telse if (orig_lower.infinite && orig_upper.infinite)\n\t\t{\n\t\t\t/*\n\t\t\t * Original range requires broadening.  (-inf; +inf) is most far\n\t\t\t * from normal range in this case.\n\t\t\t */\n\t\t\t*penalty = 2 * CONTAIN_EMPTY_PENALTY;\n\t\t}\n\t\telse if (orig_lower.infinite || orig_upper.infinite)\n\t\t{\n\t\t\t/*\n\t\t\t * (-inf, x) or (x, +inf) original ranges are closer to normal\n\t\t\t * ranges, so it's worse to mix it with empty ranges.\n\t\t\t */\n\t\t\t*penalty = 3 * CONTAIN_EMPTY_PENALTY;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * The least preferred case is broadening of normal range.\n\t\t\t */\n\t\t\t*penalty = 4 * CONTAIN_EMPTY_PENALTY;\n\t\t}\n\t}\n\telse if (new_lower.infinite && new_upper.infinite)\n\t{\n\t\t/* Handle insertion of (-inf, +inf) range */\n\t\tif (orig_lower.infinite && orig_upper.infinite)\n\t\t{\n\t\t\t/*\n\t\t\t * Best case is inserting to (-inf, +inf) original range.\n\t\t\t */\n\t\t\t*penalty = 0.0;\n\t\t}\n\t\telse if (orig_lower.infinite || orig_upper.infinite)\n\t\t{\n\t\t\t/*\n\t\t\t * When original range is (-inf, x) or (x, +inf) it requires\n\t\t\t * broadening of original range (extension of one bound to\n\t\t\t * infinity).\n\t\t\t */\n\t\t\t*penalty = INFINITE_BOUND_PENALTY;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Insertion to normal original range is least preferred.\n\t\t\t */\n\t\t\t*penalty = 2 * INFINITE_BOUND_PENALTY;\n\t\t}\n\n\t\tif (RangeIsOrContainsEmpty(orig))\n\t\t{\n\t\t\t/*\n\t\t\t * Original range is narrower when it doesn't contain empty\n\t\t\t * ranges. Add additional penalty otherwise.\n\t\t\t */\n\t\t\t*penalty += CONTAIN_EMPTY_PENALTY;\n\t\t}\n\t}\n\telse if (new_lower.infinite)\n\t{\n\t\t/* Handle insertion of (-inf, x) range */\n\t\tif (!orig_empty && orig_lower.infinite)\n\t\t{\n\t\t\tif (orig_upper.infinite)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * (-inf, +inf) range won't be extended by insertion of (-inf,\n\t\t\t\t * x) range. It's a less desirable case than insertion to\n\t\t\t\t * (-inf, y) original range without extension, because in that\n\t\t\t\t * case original range is narrower. But we can't express that\n\t\t\t\t * in single float value.\n\t\t\t\t */\n\t\t\t\t*penalty = 0.0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (range_cmp_bounds(typcache, &new_upper, &orig_upper) > 0)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * Get extension of original range using subtype_diff. Use\n\t\t\t\t\t * constant if subtype_diff unavailable.\n\t\t\t\t\t */\n\t\t\t\t\tif (has_subtype_diff)\n\t\t\t\t\t\t*penalty = call_subtype_diff(typcache,\n\t\t\t\t\t\t\t\t\t\t\t\t\t new_upper.val,\n\t\t\t\t\t\t\t\t\t\t\t\t\t orig_upper.val);\n\t\t\t\t\telse\n\t\t\t\t\t\t*penalty = DEFAULT_SUBTYPE_DIFF_PENALTY;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* No extension of original range */\n\t\t\t\t\t*penalty = 0.0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * If lower bound of original range is not -inf, then extension of\n\t\t\t * it is infinity.\n\t\t\t */\n\t\t\t*penalty = get_float4_infinity();\n\t\t}\n\t}\n\telse if (new_upper.infinite)\n\t{\n\t\t/* Handle insertion of (x, +inf) range */\n\t\tif (!orig_empty && orig_upper.infinite)\n\t\t{\n\t\t\tif (orig_lower.infinite)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * (-inf, +inf) range won't be extended by insertion of (x,\n\t\t\t\t * +inf) range. It's a less desirable case than insertion to\n\t\t\t\t * (y, +inf) original range without extension, because in that\n\t\t\t\t * case original range is narrower. But we can't express that\n\t\t\t\t * in single float value.\n\t\t\t\t */\n\t\t\t\t*penalty = 0.0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (range_cmp_bounds(typcache, &new_lower, &orig_lower) < 0)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * Get extension of original range using subtype_diff. Use\n\t\t\t\t\t * constant if subtype_diff unavailable.\n\t\t\t\t\t */\n\t\t\t\t\tif (has_subtype_diff)\n\t\t\t\t\t\t*penalty = call_subtype_diff(typcache,\n\t\t\t\t\t\t\t\t\t\t\t\t\t orig_lower.val,\n\t\t\t\t\t\t\t\t\t\t\t\t\t new_lower.val);\n\t\t\t\t\telse\n\t\t\t\t\t\t*penalty = DEFAULT_SUBTYPE_DIFF_PENALTY;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* No extension of original range */\n\t\t\t\t\t*penalty = 0.0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * If upper bound of original range is not +inf, then extension of\n\t\t\t * it is infinity.\n\t\t\t */\n\t\t\t*penalty = get_float4_infinity();\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Handle insertion of normal (non-empty, non-infinite) range */\n\t\tif (orig_empty || orig_lower.infinite || orig_upper.infinite)\n\t\t{\n\t\t\t/*\n\t\t\t * Avoid mixing normal ranges with infinite and empty ranges.\n\t\t\t */\n\t\t\t*penalty = get_float4_infinity();\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Calculate extension of original range by calling subtype_diff.\n\t\t\t * Use constant if subtype_diff unavailable.\n\t\t\t */\n\t\t\tfloat8\t\tdiff = 0.0;\n\n\t\t\tif (range_cmp_bounds(typcache, &new_lower, &orig_lower) < 0)\n\t\t\t{\n\t\t\t\tif (has_subtype_diff)\n\t\t\t\t\tdiff += call_subtype_diff(typcache,\n\t\t\t\t\t\t\t\t\t\t\t  orig_lower.val,\n\t\t\t\t\t\t\t\t\t\t\t  new_lower.val);\n\t\t\t\telse\n\t\t\t\t\tdiff += DEFAULT_SUBTYPE_DIFF_PENALTY;\n\t\t\t}\n\t\t\tif (range_cmp_bounds(typcache, &new_upper, &orig_upper) > 0)\n\t\t\t{\n\t\t\t\tif (has_subtype_diff)\n\t\t\t\t\tdiff += call_subtype_diff(typcache,\n\t\t\t\t\t\t\t\t\t\t\t  new_upper.val,\n\t\t\t\t\t\t\t\t\t\t\t  orig_upper.val);\n\t\t\t\telse\n\t\t\t\t\tdiff += DEFAULT_SUBTYPE_DIFF_PENALTY;\n\t\t\t}\n\t\t\t*penalty = diff;\n\t\t}\n\t}\n\n\tPG_RETURN_POINTER(penalty);\n}",
    "includes": [
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"access/stratnum.h\"",
      "#include \"access/gist.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define DEFAULT_SUBTYPE_DIFF_PENALTY  1.0",
      "#define CONTAIN_EMPTY_PENALTY  1.0",
      "#define INFINITE_BOUND_PENALTY\t2.0"
    ],
    "globals_used": [
      "static int\tget_gist_range_class(RangeType *range);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "penalty"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call_subtype_diff",
          "args": [
            "typcache",
            "new_upper.val",
            "orig_upper.val"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "call_subtype_diff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_gist.c",
          "lines": "1519-1531",
          "snippet": "static float8\ncall_subtype_diff(TypeCacheEntry *typcache, Datum val1, Datum val2)\n{\n\tfloat8\t\tvalue;\n\n\tvalue = DatumGetFloat8(FunctionCall2Coll(&typcache->rng_subdiff_finfo,\n\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t val1, val2));\n\t/* Cope with buggy subtype_diff function by returning zero */\n\tif (value >= 0.0)\n\t\treturn value;\n\treturn 0.0;\n}",
          "includes": [
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"access/stratnum.h\"",
            "#include \"access/gist.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static float8 call_subtype_diff(TypeCacheEntry *typcache,\n\t\t\t\t  Datum val1, Datum val2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/rangetypes.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"access/stratnum.h\"\n#include \"access/gist.h\"\n#include \"postgres.h\"\n\nstatic float8 call_subtype_diff(TypeCacheEntry *typcache,\n\t\t\t\t  Datum val1, Datum val2);\n\nstatic float8\ncall_subtype_diff(TypeCacheEntry *typcache, Datum val1, Datum val2)\n{\n\tfloat8\t\tvalue;\n\n\tvalue = DatumGetFloat8(FunctionCall2Coll(&typcache->rng_subdiff_finfo,\n\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t val1, val2));\n\t/* Cope with buggy subtype_diff function by returning zero */\n\tif (value >= 0.0)\n\t\treturn value;\n\treturn 0.0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_cmp_bounds",
          "args": [
            "typcache",
            "&new_upper",
            "&orig_upper"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "range_cmp_bounds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1831-1894",
          "snippet": "int\nrange_cmp_bounds(TypeCacheEntry *typcache, RangeBound *b1, RangeBound *b2)\n{\n\tint32\t\tresult;\n\n\t/*\n\t * First, handle cases involving infinity, which don't require invoking\n\t * the comparison proc.\n\t */\n\tif (b1->infinite && b2->infinite)\n\t{\n\t\t/*\n\t\t * Both are infinity, so they are equal unless one is lower and the\n\t\t * other not.\n\t\t */\n\t\tif (b1->lower == b2->lower)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn b1->lower ? -1 : 1;\n\t}\n\telse if (b1->infinite)\n\t\treturn b1->lower ? -1 : 1;\n\telse if (b2->infinite)\n\t\treturn b2->lower ? 1 : -1;\n\n\t/*\n\t * Both boundaries are finite, so compare the held values.\n\t */\n\tresult = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t b1->val, b2->val));\n\n\t/*\n\t * If the comparison is anything other than equal, we're done. If they\n\t * compare equal though, we still have to consider whether the boundaries\n\t * are inclusive or exclusive.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (!b1->inclusive && !b2->inclusive)\n\t\t{\n\t\t\t/* both are exclusive */\n\t\t\tif (b1->lower == b2->lower)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn b1->lower ? 1 : -1;\n\t\t}\n\t\telse if (!b1->inclusive)\n\t\t\treturn b1->lower ? 1 : -1;\n\t\telse if (!b2->inclusive)\n\t\t\treturn b2->lower ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Both are inclusive and the values held are equal, so they are\n\t\t\t * equal regardless of whether they are upper or lower boundaries,\n\t\t\t * or a mix.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nint\nrange_cmp_bounds(TypeCacheEntry *typcache, RangeBound *b1, RangeBound *b2)\n{\n\tint32\t\tresult;\n\n\t/*\n\t * First, handle cases involving infinity, which don't require invoking\n\t * the comparison proc.\n\t */\n\tif (b1->infinite && b2->infinite)\n\t{\n\t\t/*\n\t\t * Both are infinity, so they are equal unless one is lower and the\n\t\t * other not.\n\t\t */\n\t\tif (b1->lower == b2->lower)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn b1->lower ? -1 : 1;\n\t}\n\telse if (b1->infinite)\n\t\treturn b1->lower ? -1 : 1;\n\telse if (b2->infinite)\n\t\treturn b2->lower ? 1 : -1;\n\n\t/*\n\t * Both boundaries are finite, so compare the held values.\n\t */\n\tresult = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t b1->val, b2->val));\n\n\t/*\n\t * If the comparison is anything other than equal, we're done. If they\n\t * compare equal though, we still have to consider whether the boundaries\n\t * are inclusive or exclusive.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (!b1->inclusive && !b2->inclusive)\n\t\t{\n\t\t\t/* both are exclusive */\n\t\t\tif (b1->lower == b2->lower)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn b1->lower ? 1 : -1;\n\t\t}\n\t\telse if (!b1->inclusive)\n\t\t\treturn b1->lower ? 1 : -1;\n\t\telse if (!b2->inclusive)\n\t\t\treturn b2->lower ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Both are inclusive and the values held are equal, so they are\n\t\t\t * equal regardless of whether they are upper or lower boundaries,\n\t\t\t * or a mix.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_float4_infinity",
          "args": [],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "get_float4_infinity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "142-160",
          "snippet": "float\nget_float4_infinity(void)\n{\n#ifdef INFINITY\n\t/* C99 standard way */\n\treturn (float) INFINITY;\n#else\n#if (_MSC_VER >= 1800)\n#pragma warning(default:4756)\n#endif\n\n\t/*\n\t * On some platforms, HUGE_VAL is an infinity, elsewhere it's just the\n\t * largest normal double.  We assume forcing an overflow will get us a\n\t * true infinity.\n\t */\n\treturn (float) (HUGE_VAL * HUGE_VAL);\n#endif\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nfloat\nget_float4_infinity(void)\n{\n#ifdef INFINITY\n\t/* C99 standard way */\n\treturn (float) INFINITY;\n#else\n#if (_MSC_VER >= 1800)\n#pragma warning(default:4756)\n#endif\n\n\t/*\n\t * On some platforms, HUGE_VAL is an infinity, elsewhere it's just the\n\t * largest normal double.  We assume forcing an overflow will get us a\n\t * true infinity.\n\t */\n\treturn (float) (HUGE_VAL * HUGE_VAL);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "RangeIsOrContainsEmpty",
          "args": [
            "orig"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RangeIsOrContainsEmpty",
          "args": [
            "orig"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_deserialize",
          "args": [
            "typcache",
            "new",
            "&new_lower",
            "&new_upper",
            "&new_empty"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "range_deserialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1695-1754",
          "snippet": "void\nrange_deserialize(TypeCacheEntry *typcache, RangeType *range,\n\t\t\t\t  RangeBound *lower, RangeBound *upper, bool *empty)\n{\n\tchar\t\tflags;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tPointer\t\tptr;\n\tDatum\t\tlbound;\n\tDatum\t\tubound;\n\n\t/* assert caller passed the right typcache entry */\n\tAssert(RangeTypeGetOid(range) == typcache->type_id);\n\n\t/* fetch the flag byte from datum's last byte */\n\tflags = *((char *) range + VARSIZE(range) - 1);\n\n\t/* fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\n\t/* initialize data pointer just after the range OID */\n\tptr = (Pointer) (range + 1);\n\n\t/* fetch lower bound, if any */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/* att_align_pointer cannot be necessary here */\n\t\tlbound = fetch_att(ptr, typbyval, typlen);\n\t\tptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);\n\t}\n\telse\n\t\tlbound = (Datum) 0;\n\n\t/* fetch upper bound, if any */\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);\n\t\tubound = fetch_att(ptr, typbyval, typlen);\n\t\t/* no need for att_addlength_pointer */\n\t}\n\telse\n\t\tubound = (Datum) 0;\n\n\t/* emit results */\n\n\t*empty = (flags & RANGE_EMPTY) != 0;\n\n\tlower->val = lbound;\n\tlower->infinite = (flags & RANGE_LB_INF) != 0;\n\tlower->inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower->lower = true;\n\n\tupper->val = ubound;\n\tupper->infinite = (flags & RANGE_UB_INF) != 0;\n\tupper->inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper->lower = false;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nvoid\nrange_deserialize(TypeCacheEntry *typcache, RangeType *range,\n\t\t\t\t  RangeBound *lower, RangeBound *upper, bool *empty)\n{\n\tchar\t\tflags;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tPointer\t\tptr;\n\tDatum\t\tlbound;\n\tDatum\t\tubound;\n\n\t/* assert caller passed the right typcache entry */\n\tAssert(RangeTypeGetOid(range) == typcache->type_id);\n\n\t/* fetch the flag byte from datum's last byte */\n\tflags = *((char *) range + VARSIZE(range) - 1);\n\n\t/* fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\n\t/* initialize data pointer just after the range OID */\n\tptr = (Pointer) (range + 1);\n\n\t/* fetch lower bound, if any */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/* att_align_pointer cannot be necessary here */\n\t\tlbound = fetch_att(ptr, typbyval, typlen);\n\t\tptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);\n\t}\n\telse\n\t\tlbound = (Datum) 0;\n\n\t/* fetch upper bound, if any */\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);\n\t\tubound = fetch_att(ptr, typbyval, typlen);\n\t\t/* no need for att_addlength_pointer */\n\t}\n\telse\n\t\tubound = (Datum) 0;\n\n\t/* emit results */\n\n\t*empty = (flags & RANGE_EMPTY) != 0;\n\n\tlower->val = lbound;\n\tlower->infinite = (flags & RANGE_LB_INF) != 0;\n\tlower->inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower->lower = true;\n\n\tupper->val = ubound;\n\tupper->infinite = (flags & RANGE_UB_INF) != 0;\n\tupper->inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper->lower = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "typcache->rng_subdiff_finfo.fn_oid"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_get_typcache",
          "args": [
            "fcinfo",
            "RangeTypeGetOid(orig)"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "range_get_typcache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1542-1557",
          "snippet": "TypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nTypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RangeTypeGetOid",
          "args": [
            "orig"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"range types do not match\""
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RangeTypeGetOid",
          "args": [
            "new"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RangeTypeGetOid",
          "args": [
            "orig"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetRangeTypeP",
          "args": [
            "newentry->key"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetRangeTypeP",
          "args": [
            "origentry->key"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "2"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "1"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/rangetypes.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"access/stratnum.h\"\n#include \"access/gist.h\"\n#include \"postgres.h\"\n\n#define DEFAULT_SUBTYPE_DIFF_PENALTY  1.0\n#define CONTAIN_EMPTY_PENALTY  1.0\n#define INFINITE_BOUND_PENALTY\t2.0\n\nstatic int\tget_gist_range_class(RangeType *range);\n\nDatum\nrange_gist_penalty(PG_FUNCTION_ARGS)\n{\n\tGISTENTRY  *origentry = (GISTENTRY *) PG_GETARG_POINTER(0);\n\tGISTENTRY  *newentry = (GISTENTRY *) PG_GETARG_POINTER(1);\n\tfloat\t   *penalty = (float *) PG_GETARG_POINTER(2);\n\tRangeType  *orig = DatumGetRangeTypeP(origentry->key);\n\tRangeType  *new = DatumGetRangeTypeP(newentry->key);\n\tTypeCacheEntry *typcache;\n\tbool\t\thas_subtype_diff;\n\tRangeBound\torig_lower,\n\t\t\t\tnew_lower,\n\t\t\t\torig_upper,\n\t\t\t\tnew_upper;\n\tbool\t\torig_empty,\n\t\t\t\tnew_empty;\n\n\tif (RangeTypeGetOid(orig) != RangeTypeGetOid(new))\n\t\telog(ERROR, \"range types do not match\");\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(orig));\n\n\thas_subtype_diff = OidIsValid(typcache->rng_subdiff_finfo.fn_oid);\n\n\trange_deserialize(typcache, orig, &orig_lower, &orig_upper, &orig_empty);\n\trange_deserialize(typcache, new, &new_lower, &new_upper, &new_empty);\n\n\t/*\n\t * Distinct branches for handling distinct classes of ranges.  Note that\n\t * penalty values only need to be commensurate within the same class of\n\t * new range.\n\t */\n\tif (new_empty)\n\t{\n\t\t/* Handle insertion of empty range */\n\t\tif (orig_empty)\n\t\t{\n\t\t\t/*\n\t\t\t * The best case is to insert it to empty original range.\n\t\t\t * Insertion here means no broadening of original range. Also\n\t\t\t * original range is the most narrow.\n\t\t\t */\n\t\t\t*penalty = 0.0;\n\t\t}\n\t\telse if (RangeIsOrContainsEmpty(orig))\n\t\t{\n\t\t\t/*\n\t\t\t * The second case is to insert empty range into range which\n\t\t\t * contains at least one underlying empty range.  There is still\n\t\t\t * no broadening of original range, but original range is not as\n\t\t\t * narrow as possible.\n\t\t\t */\n\t\t\t*penalty = CONTAIN_EMPTY_PENALTY;\n\t\t}\n\t\telse if (orig_lower.infinite && orig_upper.infinite)\n\t\t{\n\t\t\t/*\n\t\t\t * Original range requires broadening.  (-inf; +inf) is most far\n\t\t\t * from normal range in this case.\n\t\t\t */\n\t\t\t*penalty = 2 * CONTAIN_EMPTY_PENALTY;\n\t\t}\n\t\telse if (orig_lower.infinite || orig_upper.infinite)\n\t\t{\n\t\t\t/*\n\t\t\t * (-inf, x) or (x, +inf) original ranges are closer to normal\n\t\t\t * ranges, so it's worse to mix it with empty ranges.\n\t\t\t */\n\t\t\t*penalty = 3 * CONTAIN_EMPTY_PENALTY;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * The least preferred case is broadening of normal range.\n\t\t\t */\n\t\t\t*penalty = 4 * CONTAIN_EMPTY_PENALTY;\n\t\t}\n\t}\n\telse if (new_lower.infinite && new_upper.infinite)\n\t{\n\t\t/* Handle insertion of (-inf, +inf) range */\n\t\tif (orig_lower.infinite && orig_upper.infinite)\n\t\t{\n\t\t\t/*\n\t\t\t * Best case is inserting to (-inf, +inf) original range.\n\t\t\t */\n\t\t\t*penalty = 0.0;\n\t\t}\n\t\telse if (orig_lower.infinite || orig_upper.infinite)\n\t\t{\n\t\t\t/*\n\t\t\t * When original range is (-inf, x) or (x, +inf) it requires\n\t\t\t * broadening of original range (extension of one bound to\n\t\t\t * infinity).\n\t\t\t */\n\t\t\t*penalty = INFINITE_BOUND_PENALTY;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Insertion to normal original range is least preferred.\n\t\t\t */\n\t\t\t*penalty = 2 * INFINITE_BOUND_PENALTY;\n\t\t}\n\n\t\tif (RangeIsOrContainsEmpty(orig))\n\t\t{\n\t\t\t/*\n\t\t\t * Original range is narrower when it doesn't contain empty\n\t\t\t * ranges. Add additional penalty otherwise.\n\t\t\t */\n\t\t\t*penalty += CONTAIN_EMPTY_PENALTY;\n\t\t}\n\t}\n\telse if (new_lower.infinite)\n\t{\n\t\t/* Handle insertion of (-inf, x) range */\n\t\tif (!orig_empty && orig_lower.infinite)\n\t\t{\n\t\t\tif (orig_upper.infinite)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * (-inf, +inf) range won't be extended by insertion of (-inf,\n\t\t\t\t * x) range. It's a less desirable case than insertion to\n\t\t\t\t * (-inf, y) original range without extension, because in that\n\t\t\t\t * case original range is narrower. But we can't express that\n\t\t\t\t * in single float value.\n\t\t\t\t */\n\t\t\t\t*penalty = 0.0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (range_cmp_bounds(typcache, &new_upper, &orig_upper) > 0)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * Get extension of original range using subtype_diff. Use\n\t\t\t\t\t * constant if subtype_diff unavailable.\n\t\t\t\t\t */\n\t\t\t\t\tif (has_subtype_diff)\n\t\t\t\t\t\t*penalty = call_subtype_diff(typcache,\n\t\t\t\t\t\t\t\t\t\t\t\t\t new_upper.val,\n\t\t\t\t\t\t\t\t\t\t\t\t\t orig_upper.val);\n\t\t\t\t\telse\n\t\t\t\t\t\t*penalty = DEFAULT_SUBTYPE_DIFF_PENALTY;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* No extension of original range */\n\t\t\t\t\t*penalty = 0.0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * If lower bound of original range is not -inf, then extension of\n\t\t\t * it is infinity.\n\t\t\t */\n\t\t\t*penalty = get_float4_infinity();\n\t\t}\n\t}\n\telse if (new_upper.infinite)\n\t{\n\t\t/* Handle insertion of (x, +inf) range */\n\t\tif (!orig_empty && orig_upper.infinite)\n\t\t{\n\t\t\tif (orig_lower.infinite)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * (-inf, +inf) range won't be extended by insertion of (x,\n\t\t\t\t * +inf) range. It's a less desirable case than insertion to\n\t\t\t\t * (y, +inf) original range without extension, because in that\n\t\t\t\t * case original range is narrower. But we can't express that\n\t\t\t\t * in single float value.\n\t\t\t\t */\n\t\t\t\t*penalty = 0.0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (range_cmp_bounds(typcache, &new_lower, &orig_lower) < 0)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * Get extension of original range using subtype_diff. Use\n\t\t\t\t\t * constant if subtype_diff unavailable.\n\t\t\t\t\t */\n\t\t\t\t\tif (has_subtype_diff)\n\t\t\t\t\t\t*penalty = call_subtype_diff(typcache,\n\t\t\t\t\t\t\t\t\t\t\t\t\t orig_lower.val,\n\t\t\t\t\t\t\t\t\t\t\t\t\t new_lower.val);\n\t\t\t\t\telse\n\t\t\t\t\t\t*penalty = DEFAULT_SUBTYPE_DIFF_PENALTY;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* No extension of original range */\n\t\t\t\t\t*penalty = 0.0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * If upper bound of original range is not +inf, then extension of\n\t\t\t * it is infinity.\n\t\t\t */\n\t\t\t*penalty = get_float4_infinity();\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Handle insertion of normal (non-empty, non-infinite) range */\n\t\tif (orig_empty || orig_lower.infinite || orig_upper.infinite)\n\t\t{\n\t\t\t/*\n\t\t\t * Avoid mixing normal ranges with infinite and empty ranges.\n\t\t\t */\n\t\t\t*penalty = get_float4_infinity();\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Calculate extension of original range by calling subtype_diff.\n\t\t\t * Use constant if subtype_diff unavailable.\n\t\t\t */\n\t\t\tfloat8\t\tdiff = 0.0;\n\n\t\t\tif (range_cmp_bounds(typcache, &new_lower, &orig_lower) < 0)\n\t\t\t{\n\t\t\t\tif (has_subtype_diff)\n\t\t\t\t\tdiff += call_subtype_diff(typcache,\n\t\t\t\t\t\t\t\t\t\t\t  orig_lower.val,\n\t\t\t\t\t\t\t\t\t\t\t  new_lower.val);\n\t\t\t\telse\n\t\t\t\t\tdiff += DEFAULT_SUBTYPE_DIFF_PENALTY;\n\t\t\t}\n\t\t\tif (range_cmp_bounds(typcache, &new_upper, &orig_upper) > 0)\n\t\t\t{\n\t\t\t\tif (has_subtype_diff)\n\t\t\t\t\tdiff += call_subtype_diff(typcache,\n\t\t\t\t\t\t\t\t\t\t\t  new_upper.val,\n\t\t\t\t\t\t\t\t\t\t\t  orig_upper.val);\n\t\t\t\telse\n\t\t\t\t\tdiff += DEFAULT_SUBTYPE_DIFF_PENALTY;\n\t\t\t}\n\t\t\t*penalty = diff;\n\t\t}\n\t}\n\n\tPG_RETURN_POINTER(penalty);\n}"
  },
  {
    "function_name": "range_gist_union",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_gist.c",
    "lines": "197-217",
    "snippet": "Datum\nrange_gist_union(PG_FUNCTION_ARGS)\n{\n\tGistEntryVector *entryvec = (GistEntryVector *) PG_GETARG_POINTER(0);\n\tGISTENTRY  *ent = entryvec->vector;\n\tRangeType  *result_range;\n\tTypeCacheEntry *typcache;\n\tint\t\t\ti;\n\n\tresult_range = DatumGetRangeTypeP(ent[0].key);\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(result_range));\n\n\tfor (i = 1; i < entryvec->n; i++)\n\t{\n\t\tresult_range = range_super_union(typcache, result_range,\n\t\t\t\t\t\t\t\t\t\t DatumGetRangeTypeP(ent[i].key));\n\t}\n\n\tPG_RETURN_RANGE_P(result_range);\n}",
    "includes": [
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"access/stratnum.h\"",
      "#include \"access/gist.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_RANGE_P",
          "args": [
            "result_range"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_super_union",
          "args": [
            "typcache",
            "result_range",
            "DatumGetRangeTypeP(ent[i].key)"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "range_super_union",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_gist.c",
          "lines": "694-759",
          "snippet": "static RangeType *\nrange_super_union(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeType  *result;\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\tchar\t\tflags1,\n\t\t\t\tflags2;\n\tRangeBound *result_lower;\n\tRangeBound *result_upper;\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\tflags1 = range_get_flags(r1);\n\tflags2 = range_get_flags(r2);\n\n\tif (empty1)\n\t{\n\t\t/* We can return r2 as-is if it already is or contains empty */\n\t\tif (flags2 & (RANGE_EMPTY | RANGE_CONTAIN_EMPTY))\n\t\t\treturn r2;\n\t\t/* Else we'd better copy it (modify-in-place isn't safe) */\n\t\tr2 = rangeCopy(r2);\n\t\trange_set_contain_empty(r2);\n\t\treturn r2;\n\t}\n\tif (empty2)\n\t{\n\t\t/* We can return r1 as-is if it already is or contains empty */\n\t\tif (flags1 & (RANGE_EMPTY | RANGE_CONTAIN_EMPTY))\n\t\t\treturn r1;\n\t\t/* Else we'd better copy it (modify-in-place isn't safe) */\n\t\tr1 = rangeCopy(r1);\n\t\trange_set_contain_empty(r1);\n\t\treturn r1;\n\t}\n\n\tif (range_cmp_bounds(typcache, &lower1, &lower2) <= 0)\n\t\tresult_lower = &lower1;\n\telse\n\t\tresult_lower = &lower2;\n\n\tif (range_cmp_bounds(typcache, &upper1, &upper2) >= 0)\n\t\tresult_upper = &upper1;\n\telse\n\t\tresult_upper = &upper2;\n\n\t/* optimization to avoid constructing a new range */\n\tif (result_lower == &lower1 && result_upper == &upper1 &&\n\t\t((flags1 & RANGE_CONTAIN_EMPTY) || !(flags2 & RANGE_CONTAIN_EMPTY)))\n\t\treturn r1;\n\tif (result_lower == &lower2 && result_upper == &upper2 &&\n\t\t((flags2 & RANGE_CONTAIN_EMPTY) || !(flags1 & RANGE_CONTAIN_EMPTY)))\n\t\treturn r2;\n\n\tresult = make_range(typcache, result_lower, result_upper, false);\n\n\tif ((flags1 & RANGE_CONTAIN_EMPTY) || (flags2 & RANGE_CONTAIN_EMPTY))\n\t\trange_set_contain_empty(result);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"access/stratnum.h\"",
            "#include \"access/gist.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static RangeType *range_super_union(TypeCacheEntry *typcache, RangeType *r1,\n\t\t\t\t  RangeType *r2);",
            "static int\tget_gist_range_class(RangeType *range);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/rangetypes.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"access/stratnum.h\"\n#include \"access/gist.h\"\n#include \"postgres.h\"\n\nstatic RangeType *range_super_union(TypeCacheEntry *typcache, RangeType *r1,\n\t\t\t\t  RangeType *r2);\nstatic int\tget_gist_range_class(RangeType *range);\n\nstatic RangeType *\nrange_super_union(TypeCacheEntry *typcache, RangeType *r1, RangeType *r2)\n{\n\tRangeType  *result;\n\tRangeBound\tlower1,\n\t\t\t\tlower2;\n\tRangeBound\tupper1,\n\t\t\t\tupper2;\n\tbool\t\tempty1,\n\t\t\t\tempty2;\n\tchar\t\tflags1,\n\t\t\t\tflags2;\n\tRangeBound *result_lower;\n\tRangeBound *result_upper;\n\n\trange_deserialize(typcache, r1, &lower1, &upper1, &empty1);\n\trange_deserialize(typcache, r2, &lower2, &upper2, &empty2);\n\tflags1 = range_get_flags(r1);\n\tflags2 = range_get_flags(r2);\n\n\tif (empty1)\n\t{\n\t\t/* We can return r2 as-is if it already is or contains empty */\n\t\tif (flags2 & (RANGE_EMPTY | RANGE_CONTAIN_EMPTY))\n\t\t\treturn r2;\n\t\t/* Else we'd better copy it (modify-in-place isn't safe) */\n\t\tr2 = rangeCopy(r2);\n\t\trange_set_contain_empty(r2);\n\t\treturn r2;\n\t}\n\tif (empty2)\n\t{\n\t\t/* We can return r1 as-is if it already is or contains empty */\n\t\tif (flags1 & (RANGE_EMPTY | RANGE_CONTAIN_EMPTY))\n\t\t\treturn r1;\n\t\t/* Else we'd better copy it (modify-in-place isn't safe) */\n\t\tr1 = rangeCopy(r1);\n\t\trange_set_contain_empty(r1);\n\t\treturn r1;\n\t}\n\n\tif (range_cmp_bounds(typcache, &lower1, &lower2) <= 0)\n\t\tresult_lower = &lower1;\n\telse\n\t\tresult_lower = &lower2;\n\n\tif (range_cmp_bounds(typcache, &upper1, &upper2) >= 0)\n\t\tresult_upper = &upper1;\n\telse\n\t\tresult_upper = &upper2;\n\n\t/* optimization to avoid constructing a new range */\n\tif (result_lower == &lower1 && result_upper == &upper1 &&\n\t\t((flags1 & RANGE_CONTAIN_EMPTY) || !(flags2 & RANGE_CONTAIN_EMPTY)))\n\t\treturn r1;\n\tif (result_lower == &lower2 && result_upper == &upper2 &&\n\t\t((flags2 & RANGE_CONTAIN_EMPTY) || !(flags1 & RANGE_CONTAIN_EMPTY)))\n\t\treturn r2;\n\n\tresult = make_range(typcache, result_lower, result_upper, false);\n\n\tif ((flags1 & RANGE_CONTAIN_EMPTY) || (flags2 & RANGE_CONTAIN_EMPTY))\n\t\trange_set_contain_empty(result);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetRangeTypeP",
          "args": [
            "ent[i].key"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_get_typcache",
          "args": [
            "fcinfo",
            "RangeTypeGetOid(result_range)"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "range_get_typcache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1542-1557",
          "snippet": "TypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nTypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RangeTypeGetOid",
          "args": [
            "result_range"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetRangeTypeP",
          "args": [
            "ent[0].key"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/rangetypes.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"access/stratnum.h\"\n#include \"access/gist.h\"\n#include \"postgres.h\"\n\nDatum\nrange_gist_union(PG_FUNCTION_ARGS)\n{\n\tGistEntryVector *entryvec = (GistEntryVector *) PG_GETARG_POINTER(0);\n\tGISTENTRY  *ent = entryvec->vector;\n\tRangeType  *result_range;\n\tTypeCacheEntry *typcache;\n\tint\t\t\ti;\n\n\tresult_range = DatumGetRangeTypeP(ent[0].key);\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(result_range));\n\n\tfor (i = 1; i < entryvec->n; i++)\n\t{\n\t\tresult_range = range_super_union(typcache, result_range,\n\t\t\t\t\t\t\t\t\t\t DatumGetRangeTypeP(ent[i].key));\n\t}\n\n\tPG_RETURN_RANGE_P(result_range);\n}"
  },
  {
    "function_name": "range_gist_consistent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_gist.c",
    "lines": "171-194",
    "snippet": "Datum\nrange_gist_consistent(PG_FUNCTION_ARGS)\n{\n\tGISTENTRY  *entry = (GISTENTRY *) PG_GETARG_POINTER(0);\n\tDatum\t\tquery = PG_GETARG_DATUM(1);\n\tStrategyNumber strategy = (StrategyNumber) PG_GETARG_UINT16(2);\n\n\t/* Oid subtype = PG_GETARG_OID(3); */\n\tbool\t   *recheck = (bool *) PG_GETARG_POINTER(4);\n\tRangeType  *key = DatumGetRangeTypeP(entry->key);\n\tTypeCacheEntry *typcache;\n\n\t/* All operators served by this function are exact */\n\t*recheck = false;\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(key));\n\n\tif (GIST_LEAF(entry))\n\t\tPG_RETURN_BOOL(range_gist_consistent_leaf(typcache, strategy,\n\t\t\t\t\t\t\t\t\t\t\t\t  key, query));\n\telse\n\t\tPG_RETURN_BOOL(range_gist_consistent_int(typcache, strategy,\n\t\t\t\t\t\t\t\t\t\t\t\t key, query));\n}",
    "includes": [
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"access/stratnum.h\"",
      "#include \"access/gist.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool range_gist_consistent_int(TypeCacheEntry *typcache,\n\t\t\t\t\t\t  StrategyNumber strategy, RangeType *key,\n\t\t\t\t\t\t  Datum query);",
      "static bool range_gist_consistent_leaf(TypeCacheEntry *typcache,\n\t\t\t\t\t\t   StrategyNumber strategy, RangeType *key,\n\t\t\t\t\t\t   Datum query);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "range_gist_consistent_int(typcache, strategy,\n\t\t\t\t\t\t\t\t\t\t\t\t key, query)"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_gist_consistent_int",
          "args": [
            "typcache",
            "strategy",
            "key",
            "query"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "range_gist_consistent_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_gist.c",
          "lines": "764-831",
          "snippet": "static bool\nrange_gist_consistent_int(TypeCacheEntry *typcache, StrategyNumber strategy,\n\t\t\t\t\t\t  RangeType *key, Datum query)\n{\n\tswitch (strategy)\n\t{\n\t\tcase RANGESTRAT_BEFORE:\n\t\t\tif (RangeIsEmpty(key) || RangeIsEmpty(DatumGetRangeTypeP(query)))\n\t\t\t\treturn false;\n\t\t\treturn (!range_overright_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\t\t  DatumGetRangeTypeP(query)));\n\t\tcase RANGESTRAT_OVERLEFT:\n\t\t\tif (RangeIsEmpty(key) || RangeIsEmpty(DatumGetRangeTypeP(query)))\n\t\t\t\treturn false;\n\t\t\treturn (!range_after_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\t  DatumGetRangeTypeP(query)));\n\t\tcase RANGESTRAT_OVERLAPS:\n\t\t\treturn range_overlaps_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\t   DatumGetRangeTypeP(query));\n\t\tcase RANGESTRAT_OVERRIGHT:\n\t\t\tif (RangeIsEmpty(key) || RangeIsEmpty(DatumGetRangeTypeP(query)))\n\t\t\t\treturn false;\n\t\t\treturn (!range_before_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\t   DatumGetRangeTypeP(query)));\n\t\tcase RANGESTRAT_AFTER:\n\t\t\tif (RangeIsEmpty(key) || RangeIsEmpty(DatumGetRangeTypeP(query)))\n\t\t\t\treturn false;\n\t\t\treturn (!range_overleft_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\t\t DatumGetRangeTypeP(query)));\n\t\tcase RANGESTRAT_ADJACENT:\n\t\t\tif (RangeIsEmpty(key) || RangeIsEmpty(DatumGetRangeTypeP(query)))\n\t\t\t\treturn false;\n\t\t\tif (range_adjacent_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\tDatumGetRangeTypeP(query)))\n\t\t\t\treturn true;\n\t\t\treturn range_overlaps_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\t   DatumGetRangeTypeP(query));\n\t\tcase RANGESTRAT_CONTAINS:\n\t\t\treturn range_contains_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\t   DatumGetRangeTypeP(query));\n\t\tcase RANGESTRAT_CONTAINED_BY:\n\n\t\t\t/*\n\t\t\t * Empty ranges are contained by anything, so if key is or\n\t\t\t * contains any empty ranges, we must descend into it.  Otherwise,\n\t\t\t * descend only if key overlaps the query.\n\t\t\t */\n\t\t\tif (RangeIsOrContainsEmpty(key))\n\t\t\t\treturn true;\n\t\t\treturn range_overlaps_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\t   DatumGetRangeTypeP(query));\n\t\tcase RANGESTRAT_CONTAINS_ELEM:\n\t\t\treturn range_contains_elem_internal(typcache, key, query);\n\t\tcase RANGESTRAT_EQ:\n\n\t\t\t/*\n\t\t\t * If query is empty, descend only if the key is or contains any\n\t\t\t * empty ranges.  Otherwise, descend if key contains query.\n\t\t\t */\n\t\t\tif (RangeIsEmpty(DatumGetRangeTypeP(query)))\n\t\t\t\treturn RangeIsOrContainsEmpty(key);\n\t\t\treturn range_contains_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\t   DatumGetRangeTypeP(query));\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized range strategy: %d\", strategy);\n\t\t\treturn false;\t\t/* keep compiler quiet */\n\t}\n}",
          "includes": [
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"access/stratnum.h\"",
            "#include \"access/gist.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool range_gist_consistent_int(TypeCacheEntry *typcache,\n\t\t\t\t\t\t  StrategyNumber strategy, RangeType *key,\n\t\t\t\t\t\t  Datum query);",
            "static bool range_gist_consistent_leaf(TypeCacheEntry *typcache,\n\t\t\t\t\t\t   StrategyNumber strategy, RangeType *key,\n\t\t\t\t\t\t   Datum query);",
            "static int\tget_gist_range_class(RangeType *range);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/rangetypes.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"access/stratnum.h\"\n#include \"access/gist.h\"\n#include \"postgres.h\"\n\nstatic bool range_gist_consistent_int(TypeCacheEntry *typcache,\n\t\t\t\t\t\t  StrategyNumber strategy, RangeType *key,\n\t\t\t\t\t\t  Datum query);\nstatic bool range_gist_consistent_leaf(TypeCacheEntry *typcache,\n\t\t\t\t\t\t   StrategyNumber strategy, RangeType *key,\n\t\t\t\t\t\t   Datum query);\nstatic int\tget_gist_range_class(RangeType *range);\n\nstatic bool\nrange_gist_consistent_int(TypeCacheEntry *typcache, StrategyNumber strategy,\n\t\t\t\t\t\t  RangeType *key, Datum query)\n{\n\tswitch (strategy)\n\t{\n\t\tcase RANGESTRAT_BEFORE:\n\t\t\tif (RangeIsEmpty(key) || RangeIsEmpty(DatumGetRangeTypeP(query)))\n\t\t\t\treturn false;\n\t\t\treturn (!range_overright_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\t\t  DatumGetRangeTypeP(query)));\n\t\tcase RANGESTRAT_OVERLEFT:\n\t\t\tif (RangeIsEmpty(key) || RangeIsEmpty(DatumGetRangeTypeP(query)))\n\t\t\t\treturn false;\n\t\t\treturn (!range_after_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\t  DatumGetRangeTypeP(query)));\n\t\tcase RANGESTRAT_OVERLAPS:\n\t\t\treturn range_overlaps_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\t   DatumGetRangeTypeP(query));\n\t\tcase RANGESTRAT_OVERRIGHT:\n\t\t\tif (RangeIsEmpty(key) || RangeIsEmpty(DatumGetRangeTypeP(query)))\n\t\t\t\treturn false;\n\t\t\treturn (!range_before_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\t   DatumGetRangeTypeP(query)));\n\t\tcase RANGESTRAT_AFTER:\n\t\t\tif (RangeIsEmpty(key) || RangeIsEmpty(DatumGetRangeTypeP(query)))\n\t\t\t\treturn false;\n\t\t\treturn (!range_overleft_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\t\t DatumGetRangeTypeP(query)));\n\t\tcase RANGESTRAT_ADJACENT:\n\t\t\tif (RangeIsEmpty(key) || RangeIsEmpty(DatumGetRangeTypeP(query)))\n\t\t\t\treturn false;\n\t\t\tif (range_adjacent_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\tDatumGetRangeTypeP(query)))\n\t\t\t\treturn true;\n\t\t\treturn range_overlaps_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\t   DatumGetRangeTypeP(query));\n\t\tcase RANGESTRAT_CONTAINS:\n\t\t\treturn range_contains_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\t   DatumGetRangeTypeP(query));\n\t\tcase RANGESTRAT_CONTAINED_BY:\n\n\t\t\t/*\n\t\t\t * Empty ranges are contained by anything, so if key is or\n\t\t\t * contains any empty ranges, we must descend into it.  Otherwise,\n\t\t\t * descend only if key overlaps the query.\n\t\t\t */\n\t\t\tif (RangeIsOrContainsEmpty(key))\n\t\t\t\treturn true;\n\t\t\treturn range_overlaps_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\t   DatumGetRangeTypeP(query));\n\t\tcase RANGESTRAT_CONTAINS_ELEM:\n\t\t\treturn range_contains_elem_internal(typcache, key, query);\n\t\tcase RANGESTRAT_EQ:\n\n\t\t\t/*\n\t\t\t * If query is empty, descend only if the key is or contains any\n\t\t\t * empty ranges.  Otherwise, descend if key contains query.\n\t\t\t */\n\t\t\tif (RangeIsEmpty(DatumGetRangeTypeP(query)))\n\t\t\t\treturn RangeIsOrContainsEmpty(key);\n\t\t\treturn range_contains_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\t   DatumGetRangeTypeP(query));\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized range strategy: %d\", strategy);\n\t\t\treturn false;\t\t/* keep compiler quiet */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "range_gist_consistent_leaf(typcache, strategy,\n\t\t\t\t\t\t\t\t\t\t\t\t  key, query)"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_gist_consistent_leaf",
          "args": [
            "typcache",
            "strategy",
            "key",
            "query"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "range_gist_consistent_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_gist.c",
          "lines": "836-874",
          "snippet": "static bool\nrange_gist_consistent_leaf(TypeCacheEntry *typcache, StrategyNumber strategy,\n\t\t\t\t\t\t   RangeType *key, Datum query)\n{\n\tswitch (strategy)\n\t{\n\t\tcase RANGESTRAT_BEFORE:\n\t\t\treturn range_before_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\t DatumGetRangeTypeP(query));\n\t\tcase RANGESTRAT_OVERLEFT:\n\t\t\treturn range_overleft_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\t   DatumGetRangeTypeP(query));\n\t\tcase RANGESTRAT_OVERLAPS:\n\t\t\treturn range_overlaps_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\t   DatumGetRangeTypeP(query));\n\t\tcase RANGESTRAT_OVERRIGHT:\n\t\t\treturn range_overright_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\t\tDatumGetRangeTypeP(query));\n\t\tcase RANGESTRAT_AFTER:\n\t\t\treturn range_after_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\tDatumGetRangeTypeP(query));\n\t\tcase RANGESTRAT_ADJACENT:\n\t\t\treturn range_adjacent_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\t   DatumGetRangeTypeP(query));\n\t\tcase RANGESTRAT_CONTAINS:\n\t\t\treturn range_contains_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\t   DatumGetRangeTypeP(query));\n\t\tcase RANGESTRAT_CONTAINED_BY:\n\t\t\treturn range_contained_by_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\t\t   DatumGetRangeTypeP(query));\n\t\tcase RANGESTRAT_CONTAINS_ELEM:\n\t\t\treturn range_contains_elem_internal(typcache, key, query);\n\t\tcase RANGESTRAT_EQ:\n\t\t\treturn range_eq_internal(typcache, key, DatumGetRangeTypeP(query));\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized range strategy: %d\", strategy);\n\t\t\treturn false;\t\t/* keep compiler quiet */\n\t}\n}",
          "includes": [
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"access/stratnum.h\"",
            "#include \"access/gist.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool range_gist_consistent_int(TypeCacheEntry *typcache,\n\t\t\t\t\t\t  StrategyNumber strategy, RangeType *key,\n\t\t\t\t\t\t  Datum query);",
            "static bool range_gist_consistent_leaf(TypeCacheEntry *typcache,\n\t\t\t\t\t\t   StrategyNumber strategy, RangeType *key,\n\t\t\t\t\t\t   Datum query);",
            "static int\tget_gist_range_class(RangeType *range);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/rangetypes.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"access/stratnum.h\"\n#include \"access/gist.h\"\n#include \"postgres.h\"\n\nstatic bool range_gist_consistent_int(TypeCacheEntry *typcache,\n\t\t\t\t\t\t  StrategyNumber strategy, RangeType *key,\n\t\t\t\t\t\t  Datum query);\nstatic bool range_gist_consistent_leaf(TypeCacheEntry *typcache,\n\t\t\t\t\t\t   StrategyNumber strategy, RangeType *key,\n\t\t\t\t\t\t   Datum query);\nstatic int\tget_gist_range_class(RangeType *range);\n\nstatic bool\nrange_gist_consistent_leaf(TypeCacheEntry *typcache, StrategyNumber strategy,\n\t\t\t\t\t\t   RangeType *key, Datum query)\n{\n\tswitch (strategy)\n\t{\n\t\tcase RANGESTRAT_BEFORE:\n\t\t\treturn range_before_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\t DatumGetRangeTypeP(query));\n\t\tcase RANGESTRAT_OVERLEFT:\n\t\t\treturn range_overleft_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\t   DatumGetRangeTypeP(query));\n\t\tcase RANGESTRAT_OVERLAPS:\n\t\t\treturn range_overlaps_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\t   DatumGetRangeTypeP(query));\n\t\tcase RANGESTRAT_OVERRIGHT:\n\t\t\treturn range_overright_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\t\tDatumGetRangeTypeP(query));\n\t\tcase RANGESTRAT_AFTER:\n\t\t\treturn range_after_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\tDatumGetRangeTypeP(query));\n\t\tcase RANGESTRAT_ADJACENT:\n\t\t\treturn range_adjacent_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\t   DatumGetRangeTypeP(query));\n\t\tcase RANGESTRAT_CONTAINS:\n\t\t\treturn range_contains_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\t   DatumGetRangeTypeP(query));\n\t\tcase RANGESTRAT_CONTAINED_BY:\n\t\t\treturn range_contained_by_internal(typcache, key,\n\t\t\t\t\t\t\t\t\t\t\t   DatumGetRangeTypeP(query));\n\t\tcase RANGESTRAT_CONTAINS_ELEM:\n\t\t\treturn range_contains_elem_internal(typcache, key, query);\n\t\tcase RANGESTRAT_EQ:\n\t\t\treturn range_eq_internal(typcache, key, DatumGetRangeTypeP(query));\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized range strategy: %d\", strategy);\n\t\t\treturn false;\t\t/* keep compiler quiet */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIST_LEAF",
          "args": [
            "entry"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_get_typcache",
          "args": [
            "fcinfo",
            "RangeTypeGetOid(key)"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "range_get_typcache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1542-1557",
          "snippet": "TypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nTypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RangeTypeGetOid",
          "args": [
            "key"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetRangeTypeP",
          "args": [
            "entry->key"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "4"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_UINT16",
          "args": [
            "2"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "1"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/rangetypes.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"access/stratnum.h\"\n#include \"access/gist.h\"\n#include \"postgres.h\"\n\nstatic bool range_gist_consistent_int(TypeCacheEntry *typcache,\n\t\t\t\t\t\t  StrategyNumber strategy, RangeType *key,\n\t\t\t\t\t\t  Datum query);\nstatic bool range_gist_consistent_leaf(TypeCacheEntry *typcache,\n\t\t\t\t\t\t   StrategyNumber strategy, RangeType *key,\n\t\t\t\t\t\t   Datum query);\n\nDatum\nrange_gist_consistent(PG_FUNCTION_ARGS)\n{\n\tGISTENTRY  *entry = (GISTENTRY *) PG_GETARG_POINTER(0);\n\tDatum\t\tquery = PG_GETARG_DATUM(1);\n\tStrategyNumber strategy = (StrategyNumber) PG_GETARG_UINT16(2);\n\n\t/* Oid subtype = PG_GETARG_OID(3); */\n\tbool\t   *recheck = (bool *) PG_GETARG_POINTER(4);\n\tRangeType  *key = DatumGetRangeTypeP(entry->key);\n\tTypeCacheEntry *typcache;\n\n\t/* All operators served by this function are exact */\n\t*recheck = false;\n\n\ttypcache = range_get_typcache(fcinfo, RangeTypeGetOid(key));\n\n\tif (GIST_LEAF(entry))\n\t\tPG_RETURN_BOOL(range_gist_consistent_leaf(typcache, strategy,\n\t\t\t\t\t\t\t\t\t\t\t\t  key, query));\n\telse\n\t\tPG_RETURN_BOOL(range_gist_consistent_int(typcache, strategy,\n\t\t\t\t\t\t\t\t\t\t\t\t key, query));\n}"
  }
]