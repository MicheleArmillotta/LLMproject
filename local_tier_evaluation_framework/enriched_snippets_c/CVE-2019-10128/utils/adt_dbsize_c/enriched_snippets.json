[
  {
    "function_name": "pg_relation_filepath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/dbsize.c",
    "lines": "939-1022",
    "snippet": "Datum\npg_relation_filepath(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\trelid = PG_GETARG_OID(0);\n\tHeapTuple\ttuple;\n\tForm_pg_class relform;\n\tRelFileNode rnode;\n\tBackendId\tbackend;\n\tchar\t   *path;\n\n\ttuple = SearchSysCache1(RELOID, ObjectIdGetDatum(relid));\n\tif (!HeapTupleIsValid(tuple))\n\t\tPG_RETURN_NULL();\n\trelform = (Form_pg_class) GETSTRUCT(tuple);\n\n\tswitch (relform->relkind)\n\t{\n\t\tcase RELKIND_RELATION:\n\t\tcase RELKIND_MATVIEW:\n\t\tcase RELKIND_INDEX:\n\t\tcase RELKIND_SEQUENCE:\n\t\tcase RELKIND_TOASTVALUE:\n\t\t\t/* okay, these have storage */\n\n\t\t\t/* This logic should match RelationInitPhysicalAddr */\n\t\t\tif (relform->reltablespace)\n\t\t\t\trnode.spcNode = relform->reltablespace;\n\t\t\telse\n\t\t\t\trnode.spcNode = MyDatabaseTableSpace;\n\t\t\tif (rnode.spcNode == GLOBALTABLESPACE_OID)\n\t\t\t\trnode.dbNode = InvalidOid;\n\t\t\telse\n\t\t\t\trnode.dbNode = MyDatabaseId;\n\t\t\tif (relform->relfilenode)\n\t\t\t\trnode.relNode = relform->relfilenode;\n\t\t\telse\t\t\t\t/* Consult the relation mapper */\n\t\t\t\trnode.relNode = RelationMapOidToFilenode(relid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t relform->relisshared);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* no storage, return NULL */\n\t\t\trnode.relNode = InvalidOid;\n\t\t\t/* some compilers generate warnings without these next two lines */\n\t\t\trnode.dbNode = InvalidOid;\n\t\t\trnode.spcNode = InvalidOid;\n\t\t\tbreak;\n\t}\n\n\tif (!OidIsValid(rnode.relNode))\n\t{\n\t\tReleaseSysCache(tuple);\n\t\tPG_RETURN_NULL();\n\t}\n\n\t/* Determine owning backend. */\n\tswitch (relform->relpersistence)\n\t{\n\t\tcase RELPERSISTENCE_UNLOGGED:\n\t\tcase RELPERSISTENCE_PERMANENT:\n\t\t\tbackend = InvalidBackendId;\n\t\t\tbreak;\n\t\tcase RELPERSISTENCE_TEMP:\n\t\t\tif (isTempOrTempToastNamespace(relform->relnamespace))\n\t\t\t\tbackend = BackendIdForTempRelations();\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Do it the hard way. */\n\t\t\t\tbackend = GetTempNamespaceBackendId(relform->relnamespace);\n\t\t\t\tAssert(backend != InvalidBackendId);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid relpersistence: %c\", relform->relpersistence);\n\t\t\tbackend = InvalidBackendId; /* placate compiler */\n\t\t\tbreak;\n\t}\n\n\tReleaseSysCache(tuple);\n\n\tpath = relpathbackend(rnode, backend, MAIN_FORKNUM);\n\n\tPG_RETURN_TEXT_P(cstring_to_text(path));\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/relfilenodemap.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/fd.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "cstring_to_text(path)"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cstring_to_text",
          "args": [
            "path"
          ],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "148-152",
          "snippet": "text *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}"
        }
      },
      {
        "call_info": {
          "callee": "relpathbackend",
          "args": [
            "rnode",
            "backend",
            "MAIN_FORKNUM"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseSysCache",
          "args": [
            "tuple"
          ],
          "line": 1017
        },
        "resolved": true,
        "details": {
          "function_name": "ReleaseSysCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1159-1163",
          "snippet": "void\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"invalid relpersistence: %c\"",
            "relform->relpersistence"
          ],
          "line": 1012
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "backend != InvalidBackendId"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetTempNamespaceBackendId",
          "args": [
            "relform->relnamespace"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BackendIdForTempRelations",
          "args": [],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isTempOrTempToastNamespace",
          "args": [
            "relform->relnamespace"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "rnode.relNode"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationMapOidToFilenode",
          "args": [
            "relid",
            "relform->relisshared"
          ],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "RelationMapOidToFilenode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relmapper.c",
          "lines": "145-184",
          "snippet": "Oid\nRelationMapOidToFilenode(Oid relationId, bool shared)\n{\n\tconst RelMapFile *map;\n\tint32\t\ti;\n\n\t/* If there are active updates, believe those over the main maps */\n\tif (shared)\n\t{\n\t\tmap = &active_shared_updates;\n\t\tfor (i = 0; i < map->num_mappings; i++)\n\t\t{\n\t\t\tif (relationId == map->mappings[i].mapoid)\n\t\t\t\treturn map->mappings[i].mapfilenode;\n\t\t}\n\t\tmap = &shared_map;\n\t\tfor (i = 0; i < map->num_mappings; i++)\n\t\t{\n\t\t\tif (relationId == map->mappings[i].mapoid)\n\t\t\t\treturn map->mappings[i].mapfilenode;\n\t\t}\n\t}\n\telse\n\t{\n\t\tmap = &active_local_updates;\n\t\tfor (i = 0; i < map->num_mappings; i++)\n\t\t{\n\t\t\tif (relationId == map->mappings[i].mapoid)\n\t\t\t\treturn map->mappings[i].mapfilenode;\n\t\t}\n\t\tmap = &local_map;\n\t\tfor (i = 0; i < map->num_mappings; i++)\n\t\t{\n\t\t\tif (relationId == map->mappings[i].mapoid)\n\t\t\t\treturn map->mappings[i].mapfilenode;\n\t\t}\n\t}\n\n\treturn InvalidOid;\n}",
          "includes": [
            "#include \"utils/relmapper.h\"",
            "#include \"utils/inval.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/fd.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xloginsert.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static RelMapFile shared_map;",
            "static RelMapFile local_map;",
            "static RelMapFile active_shared_updates;",
            "static RelMapFile active_local_updates;",
            "static void load_relmap_file(bool shared);",
            "static void perform_relmap_update(bool shared, const RelMapFile *updates);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relmapper.h\"\n#include \"utils/inval.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/fd.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xloginsert.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic RelMapFile shared_map;\nstatic RelMapFile local_map;\nstatic RelMapFile active_shared_updates;\nstatic RelMapFile active_local_updates;\nstatic void load_relmap_file(bool shared);\nstatic void perform_relmap_update(bool shared, const RelMapFile *updates);\n\nOid\nRelationMapOidToFilenode(Oid relationId, bool shared)\n{\n\tconst RelMapFile *map;\n\tint32\t\ti;\n\n\t/* If there are active updates, believe those over the main maps */\n\tif (shared)\n\t{\n\t\tmap = &active_shared_updates;\n\t\tfor (i = 0; i < map->num_mappings; i++)\n\t\t{\n\t\t\tif (relationId == map->mappings[i].mapoid)\n\t\t\t\treturn map->mappings[i].mapfilenode;\n\t\t}\n\t\tmap = &shared_map;\n\t\tfor (i = 0; i < map->num_mappings; i++)\n\t\t{\n\t\t\tif (relationId == map->mappings[i].mapoid)\n\t\t\t\treturn map->mappings[i].mapfilenode;\n\t\t}\n\t}\n\telse\n\t{\n\t\tmap = &active_local_updates;\n\t\tfor (i = 0; i < map->num_mappings; i++)\n\t\t{\n\t\t\tif (relationId == map->mappings[i].mapoid)\n\t\t\t\treturn map->mappings[i].mapfilenode;\n\t\t}\n\t\tmap = &local_map;\n\t\tfor (i = 0; i < map->num_mappings; i++)\n\t\t{\n\t\t\tif (relationId == map->mappings[i].mapoid)\n\t\t\t\treturn map->mappings[i].mapfilenode;\n\t\t}\n\t}\n\n\treturn InvalidOid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "tuple"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "tuple"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SearchSysCache1",
          "args": [
            "RELOID",
            "ObjectIdGetDatum(relid)"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "SearchSysCache1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1111-1120",
          "snippet": "HeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nHeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "relid"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "0"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/relfilenodemap.h\"\n#include \"utils/rel.h\"\n#include \"utils/numeric.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/fd.h\"\n#include \"miscadmin.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nDatum\npg_relation_filepath(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\trelid = PG_GETARG_OID(0);\n\tHeapTuple\ttuple;\n\tForm_pg_class relform;\n\tRelFileNode rnode;\n\tBackendId\tbackend;\n\tchar\t   *path;\n\n\ttuple = SearchSysCache1(RELOID, ObjectIdGetDatum(relid));\n\tif (!HeapTupleIsValid(tuple))\n\t\tPG_RETURN_NULL();\n\trelform = (Form_pg_class) GETSTRUCT(tuple);\n\n\tswitch (relform->relkind)\n\t{\n\t\tcase RELKIND_RELATION:\n\t\tcase RELKIND_MATVIEW:\n\t\tcase RELKIND_INDEX:\n\t\tcase RELKIND_SEQUENCE:\n\t\tcase RELKIND_TOASTVALUE:\n\t\t\t/* okay, these have storage */\n\n\t\t\t/* This logic should match RelationInitPhysicalAddr */\n\t\t\tif (relform->reltablespace)\n\t\t\t\trnode.spcNode = relform->reltablespace;\n\t\t\telse\n\t\t\t\trnode.spcNode = MyDatabaseTableSpace;\n\t\t\tif (rnode.spcNode == GLOBALTABLESPACE_OID)\n\t\t\t\trnode.dbNode = InvalidOid;\n\t\t\telse\n\t\t\t\trnode.dbNode = MyDatabaseId;\n\t\t\tif (relform->relfilenode)\n\t\t\t\trnode.relNode = relform->relfilenode;\n\t\t\telse\t\t\t\t/* Consult the relation mapper */\n\t\t\t\trnode.relNode = RelationMapOidToFilenode(relid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t relform->relisshared);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* no storage, return NULL */\n\t\t\trnode.relNode = InvalidOid;\n\t\t\t/* some compilers generate warnings without these next two lines */\n\t\t\trnode.dbNode = InvalidOid;\n\t\t\trnode.spcNode = InvalidOid;\n\t\t\tbreak;\n\t}\n\n\tif (!OidIsValid(rnode.relNode))\n\t{\n\t\tReleaseSysCache(tuple);\n\t\tPG_RETURN_NULL();\n\t}\n\n\t/* Determine owning backend. */\n\tswitch (relform->relpersistence)\n\t{\n\t\tcase RELPERSISTENCE_UNLOGGED:\n\t\tcase RELPERSISTENCE_PERMANENT:\n\t\t\tbackend = InvalidBackendId;\n\t\t\tbreak;\n\t\tcase RELPERSISTENCE_TEMP:\n\t\t\tif (isTempOrTempToastNamespace(relform->relnamespace))\n\t\t\t\tbackend = BackendIdForTempRelations();\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Do it the hard way. */\n\t\t\t\tbackend = GetTempNamespaceBackendId(relform->relnamespace);\n\t\t\t\tAssert(backend != InvalidBackendId);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid relpersistence: %c\", relform->relpersistence);\n\t\t\tbackend = InvalidBackendId; /* placate compiler */\n\t\t\tbreak;\n\t}\n\n\tReleaseSysCache(tuple);\n\n\tpath = relpathbackend(rnode, backend, MAIN_FORKNUM);\n\n\tPG_RETURN_TEXT_P(cstring_to_text(path));\n}"
  },
  {
    "function_name": "pg_filenode_relation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/dbsize.c",
    "lines": "919-932",
    "snippet": "Datum\npg_filenode_relation(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\treltablespace = PG_GETARG_OID(0);\n\tOid\t\t\trelfilenode = PG_GETARG_OID(1);\n\tOid\t\t\theaprel = InvalidOid;\n\n\theaprel = RelidByRelfilenode(reltablespace, relfilenode);\n\n\tif (!OidIsValid(heaprel))\n\t\tPG_RETURN_NULL();\n\telse\n\t\tPG_RETURN_OID(heaprel);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/relfilenodemap.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/fd.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_OID",
          "args": [
            "heaprel"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "heaprel"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelidByRelfilenode",
          "args": [
            "reltablespace",
            "relfilenode"
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "RelidByRelfilenode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relfilenodemap.c",
          "lines": "140-259",
          "snippet": "Oid\nRelidByRelfilenode(Oid reltablespace, Oid relfilenode)\n{\n\tRelfilenodeMapKey key;\n\tRelfilenodeMapEntry *entry;\n\tbool\t\tfound;\n\tSysScanDesc scandesc;\n\tRelation\trelation;\n\tHeapTuple\tntp;\n\tScanKeyData skey[2];\n\tOid\t\t\trelid;\n\n\tif (RelfilenodeMapHash == NULL)\n\t\tInitializeRelfilenodeMap();\n\n\t/* pg_class will show 0 when the value is actually MyDatabaseTableSpace */\n\tif (reltablespace == MyDatabaseTableSpace)\n\t\treltablespace = 0;\n\n\tMemSet(&key, 0, sizeof(key));\n\tkey.reltablespace = reltablespace;\n\tkey.relfilenode = relfilenode;\n\n\t/*\n\t * Check cache and return entry if one is found. Even if no target\n\t * relation can be found later on we store the negative match and return a\n\t * InvalidOid from cache. That's not really necessary for performance\n\t * since querying invalid values isn't supposed to be a frequent thing,\n\t * but it's basically free.\n\t */\n\tentry = hash_search(RelfilenodeMapHash, (void *) &key, HASH_FIND, &found);\n\n\tif (found)\n\t\treturn entry->relid;\n\n\t/* ok, no previous cache entry, do it the hard way */\n\n\t/* initialize empty/negative cache entry before doing the actual lookups */\n\trelid = InvalidOid;\n\n\tif (reltablespace == GLOBALTABLESPACE_OID)\n\t{\n\t\t/*\n\t\t * Ok, shared table, check relmapper.\n\t\t */\n\t\trelid = RelationMapFilenodeToOid(relfilenode, true);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Not a shared table, could either be a plain relation or a\n\t\t * non-shared, nailed one, like e.g. pg_class.\n\t\t */\n\n\t\t/* check for plain relations by looking in pg_class */\n\t\trelation = heap_open(RelationRelationId, AccessShareLock);\n\n\t\t/* copy scankey to local copy, it will be modified during the scan */\n\t\tmemcpy(skey, relfilenode_skey, sizeof(skey));\n\n\t\t/* set scan arguments */\n\t\tskey[0].sk_argument = ObjectIdGetDatum(reltablespace);\n\t\tskey[1].sk_argument = ObjectIdGetDatum(relfilenode);\n\n\t\tscandesc = systable_beginscan(relation,\n\t\t\t\t\t\t\t\t\t  ClassTblspcRelfilenodeIndexId,\n\t\t\t\t\t\t\t\t\t  true,\n\t\t\t\t\t\t\t\t\t  NULL,\n\t\t\t\t\t\t\t\t\t  2,\n\t\t\t\t\t\t\t\t\t  skey);\n\n\t\tfound = false;\n\n\t\twhile (HeapTupleIsValid(ntp = systable_getnext(scandesc)))\n\t\t{\n\t\t\tif (found)\n\t\t\t\telog(ERROR,\n\t\t\t\t\t \"unexpected duplicate for tablespace %u, relfilenode %u\",\n\t\t\t\t\t reltablespace, relfilenode);\n\t\t\tfound = true;\n\n#ifdef USE_ASSERT_CHECKING\n\t\t\t{\n\t\t\t\tbool\t\tisnull;\n\t\t\t\tOid\t\t\tcheck;\n\n\t\t\t\tcheck = fastgetattr(ntp, Anum_pg_class_reltablespace,\n\t\t\t\t\t\t\t\t\tRelationGetDescr(relation),\n\t\t\t\t\t\t\t\t\t&isnull);\n\t\t\t\tAssert(!isnull && check == reltablespace);\n\n\t\t\t\tcheck = fastgetattr(ntp, Anum_pg_class_relfilenode,\n\t\t\t\t\t\t\t\t\tRelationGetDescr(relation),\n\t\t\t\t\t\t\t\t\t&isnull);\n\t\t\t\tAssert(!isnull && check == relfilenode);\n\t\t\t}\n#endif\n\t\t\trelid = HeapTupleGetOid(ntp);\n\t\t}\n\n\t\tsystable_endscan(scandesc);\n\t\theap_close(relation, AccessShareLock);\n\n\t\t/* check for tables that are mapped but not shared */\n\t\tif (!found)\n\t\t\trelid = RelationMapFilenodeToOid(relfilenode, false);\n\t}\n\n\t/*\n\t * Only enter entry into cache now, our opening of pg_class could have\n\t * caused cache invalidations to be executed which would have deleted a\n\t * new entry if we had entered it above.\n\t */\n\tentry = hash_search(RelfilenodeMapHash, (void *) &key, HASH_ENTER, &found);\n\tif (found)\n\t\telog(ERROR, \"corrupted hashtable\");\n\tentry->relid = relid;\n\n\treturn relid;\n}",
          "includes": [
            "#include \"utils/relmapper.h\"",
            "#include \"utils/relfilenodemap.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HTAB *RelfilenodeMapHash = NULL;",
            "static ScanKeyData relfilenode_skey[2];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relmapper.h\"\n#include \"utils/relfilenodemap.h\"\n#include \"utils/rel.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/inval.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/indexing.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic HTAB *RelfilenodeMapHash = NULL;\nstatic ScanKeyData relfilenode_skey[2];\n\nOid\nRelidByRelfilenode(Oid reltablespace, Oid relfilenode)\n{\n\tRelfilenodeMapKey key;\n\tRelfilenodeMapEntry *entry;\n\tbool\t\tfound;\n\tSysScanDesc scandesc;\n\tRelation\trelation;\n\tHeapTuple\tntp;\n\tScanKeyData skey[2];\n\tOid\t\t\trelid;\n\n\tif (RelfilenodeMapHash == NULL)\n\t\tInitializeRelfilenodeMap();\n\n\t/* pg_class will show 0 when the value is actually MyDatabaseTableSpace */\n\tif (reltablespace == MyDatabaseTableSpace)\n\t\treltablespace = 0;\n\n\tMemSet(&key, 0, sizeof(key));\n\tkey.reltablespace = reltablespace;\n\tkey.relfilenode = relfilenode;\n\n\t/*\n\t * Check cache and return entry if one is found. Even if no target\n\t * relation can be found later on we store the negative match and return a\n\t * InvalidOid from cache. That's not really necessary for performance\n\t * since querying invalid values isn't supposed to be a frequent thing,\n\t * but it's basically free.\n\t */\n\tentry = hash_search(RelfilenodeMapHash, (void *) &key, HASH_FIND, &found);\n\n\tif (found)\n\t\treturn entry->relid;\n\n\t/* ok, no previous cache entry, do it the hard way */\n\n\t/* initialize empty/negative cache entry before doing the actual lookups */\n\trelid = InvalidOid;\n\n\tif (reltablespace == GLOBALTABLESPACE_OID)\n\t{\n\t\t/*\n\t\t * Ok, shared table, check relmapper.\n\t\t */\n\t\trelid = RelationMapFilenodeToOid(relfilenode, true);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Not a shared table, could either be a plain relation or a\n\t\t * non-shared, nailed one, like e.g. pg_class.\n\t\t */\n\n\t\t/* check for plain relations by looking in pg_class */\n\t\trelation = heap_open(RelationRelationId, AccessShareLock);\n\n\t\t/* copy scankey to local copy, it will be modified during the scan */\n\t\tmemcpy(skey, relfilenode_skey, sizeof(skey));\n\n\t\t/* set scan arguments */\n\t\tskey[0].sk_argument = ObjectIdGetDatum(reltablespace);\n\t\tskey[1].sk_argument = ObjectIdGetDatum(relfilenode);\n\n\t\tscandesc = systable_beginscan(relation,\n\t\t\t\t\t\t\t\t\t  ClassTblspcRelfilenodeIndexId,\n\t\t\t\t\t\t\t\t\t  true,\n\t\t\t\t\t\t\t\t\t  NULL,\n\t\t\t\t\t\t\t\t\t  2,\n\t\t\t\t\t\t\t\t\t  skey);\n\n\t\tfound = false;\n\n\t\twhile (HeapTupleIsValid(ntp = systable_getnext(scandesc)))\n\t\t{\n\t\t\tif (found)\n\t\t\t\telog(ERROR,\n\t\t\t\t\t \"unexpected duplicate for tablespace %u, relfilenode %u\",\n\t\t\t\t\t reltablespace, relfilenode);\n\t\t\tfound = true;\n\n#ifdef USE_ASSERT_CHECKING\n\t\t\t{\n\t\t\t\tbool\t\tisnull;\n\t\t\t\tOid\t\t\tcheck;\n\n\t\t\t\tcheck = fastgetattr(ntp, Anum_pg_class_reltablespace,\n\t\t\t\t\t\t\t\t\tRelationGetDescr(relation),\n\t\t\t\t\t\t\t\t\t&isnull);\n\t\t\t\tAssert(!isnull && check == reltablespace);\n\n\t\t\t\tcheck = fastgetattr(ntp, Anum_pg_class_relfilenode,\n\t\t\t\t\t\t\t\t\tRelationGetDescr(relation),\n\t\t\t\t\t\t\t\t\t&isnull);\n\t\t\t\tAssert(!isnull && check == relfilenode);\n\t\t\t}\n#endif\n\t\t\trelid = HeapTupleGetOid(ntp);\n\t\t}\n\n\t\tsystable_endscan(scandesc);\n\t\theap_close(relation, AccessShareLock);\n\n\t\t/* check for tables that are mapped but not shared */\n\t\tif (!found)\n\t\t\trelid = RelationMapFilenodeToOid(relfilenode, false);\n\t}\n\n\t/*\n\t * Only enter entry into cache now, our opening of pg_class could have\n\t * caused cache invalidations to be executed which would have deleted a\n\t * new entry if we had entered it above.\n\t */\n\tentry = hash_search(RelfilenodeMapHash, (void *) &key, HASH_ENTER, &found);\n\tif (found)\n\t\telog(ERROR, \"corrupted hashtable\");\n\tentry->relid = relid;\n\n\treturn relid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "1"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "0"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/relfilenodemap.h\"\n#include \"utils/rel.h\"\n#include \"utils/numeric.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/fd.h\"\n#include \"miscadmin.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nDatum\npg_filenode_relation(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\treltablespace = PG_GETARG_OID(0);\n\tOid\t\t\trelfilenode = PG_GETARG_OID(1);\n\tOid\t\t\theaprel = InvalidOid;\n\n\theaprel = RelidByRelfilenode(reltablespace, relfilenode);\n\n\tif (!OidIsValid(heaprel))\n\t\tPG_RETURN_NULL();\n\telse\n\t\tPG_RETURN_OID(heaprel);\n}"
  },
  {
    "function_name": "pg_relation_filenode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/dbsize.c",
    "lines": "864-904",
    "snippet": "Datum\npg_relation_filenode(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\trelid = PG_GETARG_OID(0);\n\tOid\t\t\tresult;\n\tHeapTuple\ttuple;\n\tForm_pg_class relform;\n\n\ttuple = SearchSysCache1(RELOID, ObjectIdGetDatum(relid));\n\tif (!HeapTupleIsValid(tuple))\n\t\tPG_RETURN_NULL();\n\trelform = (Form_pg_class) GETSTRUCT(tuple);\n\n\tswitch (relform->relkind)\n\t{\n\t\tcase RELKIND_RELATION:\n\t\tcase RELKIND_MATVIEW:\n\t\tcase RELKIND_INDEX:\n\t\tcase RELKIND_SEQUENCE:\n\t\tcase RELKIND_TOASTVALUE:\n\t\t\t/* okay, these have storage */\n\t\t\tif (relform->relfilenode)\n\t\t\t\tresult = relform->relfilenode;\n\t\t\telse\t\t\t\t/* Consult the relation mapper */\n\t\t\t\tresult = RelationMapOidToFilenode(relid,\n\t\t\t\t\t\t\t\t\t\t\t\t  relform->relisshared);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* no storage, return NULL */\n\t\t\tresult = InvalidOid;\n\t\t\tbreak;\n\t}\n\n\tReleaseSysCache(tuple);\n\n\tif (!OidIsValid(result))\n\t\tPG_RETURN_NULL();\n\n\tPG_RETURN_OID(result);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/relfilenodemap.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/fd.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_OID",
          "args": [
            "result"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "result"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseSysCache",
          "args": [
            "tuple"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "ReleaseSysCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1159-1163",
          "snippet": "void\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationMapOidToFilenode",
          "args": [
            "relid",
            "relform->relisshared"
          ],
          "line": 888
        },
        "resolved": true,
        "details": {
          "function_name": "RelationMapOidToFilenode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relmapper.c",
          "lines": "145-184",
          "snippet": "Oid\nRelationMapOidToFilenode(Oid relationId, bool shared)\n{\n\tconst RelMapFile *map;\n\tint32\t\ti;\n\n\t/* If there are active updates, believe those over the main maps */\n\tif (shared)\n\t{\n\t\tmap = &active_shared_updates;\n\t\tfor (i = 0; i < map->num_mappings; i++)\n\t\t{\n\t\t\tif (relationId == map->mappings[i].mapoid)\n\t\t\t\treturn map->mappings[i].mapfilenode;\n\t\t}\n\t\tmap = &shared_map;\n\t\tfor (i = 0; i < map->num_mappings; i++)\n\t\t{\n\t\t\tif (relationId == map->mappings[i].mapoid)\n\t\t\t\treturn map->mappings[i].mapfilenode;\n\t\t}\n\t}\n\telse\n\t{\n\t\tmap = &active_local_updates;\n\t\tfor (i = 0; i < map->num_mappings; i++)\n\t\t{\n\t\t\tif (relationId == map->mappings[i].mapoid)\n\t\t\t\treturn map->mappings[i].mapfilenode;\n\t\t}\n\t\tmap = &local_map;\n\t\tfor (i = 0; i < map->num_mappings; i++)\n\t\t{\n\t\t\tif (relationId == map->mappings[i].mapoid)\n\t\t\t\treturn map->mappings[i].mapfilenode;\n\t\t}\n\t}\n\n\treturn InvalidOid;\n}",
          "includes": [
            "#include \"utils/relmapper.h\"",
            "#include \"utils/inval.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/fd.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xloginsert.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static RelMapFile shared_map;",
            "static RelMapFile local_map;",
            "static RelMapFile active_shared_updates;",
            "static RelMapFile active_local_updates;",
            "static void load_relmap_file(bool shared);",
            "static void perform_relmap_update(bool shared, const RelMapFile *updates);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relmapper.h\"\n#include \"utils/inval.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/fd.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xloginsert.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic RelMapFile shared_map;\nstatic RelMapFile local_map;\nstatic RelMapFile active_shared_updates;\nstatic RelMapFile active_local_updates;\nstatic void load_relmap_file(bool shared);\nstatic void perform_relmap_update(bool shared, const RelMapFile *updates);\n\nOid\nRelationMapOidToFilenode(Oid relationId, bool shared)\n{\n\tconst RelMapFile *map;\n\tint32\t\ti;\n\n\t/* If there are active updates, believe those over the main maps */\n\tif (shared)\n\t{\n\t\tmap = &active_shared_updates;\n\t\tfor (i = 0; i < map->num_mappings; i++)\n\t\t{\n\t\t\tif (relationId == map->mappings[i].mapoid)\n\t\t\t\treturn map->mappings[i].mapfilenode;\n\t\t}\n\t\tmap = &shared_map;\n\t\tfor (i = 0; i < map->num_mappings; i++)\n\t\t{\n\t\t\tif (relationId == map->mappings[i].mapoid)\n\t\t\t\treturn map->mappings[i].mapfilenode;\n\t\t}\n\t}\n\telse\n\t{\n\t\tmap = &active_local_updates;\n\t\tfor (i = 0; i < map->num_mappings; i++)\n\t\t{\n\t\t\tif (relationId == map->mappings[i].mapoid)\n\t\t\t\treturn map->mappings[i].mapfilenode;\n\t\t}\n\t\tmap = &local_map;\n\t\tfor (i = 0; i < map->num_mappings; i++)\n\t\t{\n\t\t\tif (relationId == map->mappings[i].mapoid)\n\t\t\t\treturn map->mappings[i].mapfilenode;\n\t\t}\n\t}\n\n\treturn InvalidOid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "tuple"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "tuple"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SearchSysCache1",
          "args": [
            "RELOID",
            "ObjectIdGetDatum(relid)"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "SearchSysCache1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1111-1120",
          "snippet": "HeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nHeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "relid"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "0"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/relfilenodemap.h\"\n#include \"utils/rel.h\"\n#include \"utils/numeric.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/fd.h\"\n#include \"miscadmin.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nDatum\npg_relation_filenode(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\trelid = PG_GETARG_OID(0);\n\tOid\t\t\tresult;\n\tHeapTuple\ttuple;\n\tForm_pg_class relform;\n\n\ttuple = SearchSysCache1(RELOID, ObjectIdGetDatum(relid));\n\tif (!HeapTupleIsValid(tuple))\n\t\tPG_RETURN_NULL();\n\trelform = (Form_pg_class) GETSTRUCT(tuple);\n\n\tswitch (relform->relkind)\n\t{\n\t\tcase RELKIND_RELATION:\n\t\tcase RELKIND_MATVIEW:\n\t\tcase RELKIND_INDEX:\n\t\tcase RELKIND_SEQUENCE:\n\t\tcase RELKIND_TOASTVALUE:\n\t\t\t/* okay, these have storage */\n\t\t\tif (relform->relfilenode)\n\t\t\t\tresult = relform->relfilenode;\n\t\t\telse\t\t\t\t/* Consult the relation mapper */\n\t\t\t\tresult = RelationMapOidToFilenode(relid,\n\t\t\t\t\t\t\t\t\t\t\t\t  relform->relisshared);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* no storage, return NULL */\n\t\t\tresult = InvalidOid;\n\t\t\tbreak;\n\t}\n\n\tReleaseSysCache(tuple);\n\n\tif (!OidIsValid(result))\n\t\tPG_RETURN_NULL();\n\n\tPG_RETURN_OID(result);\n}"
  },
  {
    "function_name": "pg_size_bytes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/dbsize.c",
    "lines": "707-848",
    "snippet": "Datum\npg_size_bytes(PG_FUNCTION_ARGS)\n{\n\ttext\t   *arg = PG_GETARG_TEXT_PP(0);\n\tchar\t   *str,\n\t\t\t   *strptr,\n\t\t\t   *endptr;\n\tchar\t\tsaved_char;\n\tNumeric\t\tnum;\n\tint64\t\tresult;\n\tbool\t\thave_digits = false;\n\n\tstr = text_to_cstring(arg);\n\n\t/* Skip leading whitespace */\n\tstrptr = str;\n\twhile (isspace((unsigned char) *strptr))\n\t\tstrptr++;\n\n\t/* Check that we have a valid number and determine where it ends */\n\tendptr = strptr;\n\n\t/* Part (1): sign */\n\tif (*endptr == '-' || *endptr == '+')\n\t\tendptr++;\n\n\t/* Part (2): main digit string */\n\tif (isdigit((unsigned char) *endptr))\n\t{\n\t\thave_digits = true;\n\t\tdo\n\t\t\tendptr++;\n\t\twhile (isdigit((unsigned char) *endptr));\n\t}\n\n\t/* Part (3): optional decimal point and fractional digits */\n\tif (*endptr == '.')\n\t{\n\t\tendptr++;\n\t\tif (isdigit((unsigned char) *endptr))\n\t\t{\n\t\t\thave_digits = true;\n\t\t\tdo\n\t\t\t\tendptr++;\n\t\t\twhile (isdigit((unsigned char) *endptr));\n\t\t}\n\t}\n\n\t/* Complain if we don't have a valid number at this point */\n\tif (!have_digits)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid size: \\\"%s\\\"\", str)));\n\n\t/* Part (4): optional exponent */\n\tif (*endptr == 'e' || *endptr == 'E')\n\t{\n\t\tlong\t\texponent;\n\t\tchar\t   *cp;\n\n\t\t/*\n\t\t * Note we might one day support EB units, so if what follows 'E'\n\t\t * isn't a number, just treat it all as a unit to be parsed.\n\t\t */\n\t\texponent = strtol(endptr + 1, &cp, 10);\n\t\t(void) exponent;\t\t/* Silence -Wunused-result warnings */\n\t\tif (cp > endptr + 1)\n\t\t\tendptr = cp;\n\t}\n\n\t/*\n\t * Parse the number, saving the next character, which may be the first\n\t * character of the unit string.\n\t */\n\tsaved_char = *endptr;\n\t*endptr = '\\0';\n\n\tnum = DatumGetNumeric(DirectFunctionCall3(numeric_in,\n\t\t\t\t\t\t\t\t\t\t\t  CStringGetDatum(strptr),\n\t\t\t\t\t\t\t\t\t\t\t  ObjectIdGetDatum(InvalidOid),\n\t\t\t\t\t\t\t\t\t\t\t  Int32GetDatum(-1)));\n\n\t*endptr = saved_char;\n\n\t/* Skip whitespace between number and unit */\n\tstrptr = endptr;\n\twhile (isspace((unsigned char) *strptr))\n\t\tstrptr++;\n\n\t/* Handle possible unit */\n\tif (*strptr != '\\0')\n\t{\n\t\tint64\t\tmultiplier = 0;\n\n\t\t/* Trim any trailing whitespace */\n\t\tendptr = str + VARSIZE_ANY_EXHDR(arg) - 1;\n\n\t\twhile (isspace((unsigned char) *endptr))\n\t\t\tendptr--;\n\n\t\tendptr++;\n\t\t*endptr = '\\0';\n\n\t\t/* Parse the unit case-insensitively */\n\t\tif (pg_strcasecmp(strptr, \"bytes\") == 0)\n\t\t\tmultiplier = (int64) 1;\n\t\telse if (pg_strcasecmp(strptr, \"kb\") == 0)\n\t\t\tmultiplier = (int64) 1024;\n\t\telse if (pg_strcasecmp(strptr, \"mb\") == 0)\n\t\t\tmultiplier = ((int64) 1024) * 1024;\n\n\t\telse if (pg_strcasecmp(strptr, \"gb\") == 0)\n\t\t\tmultiplier = ((int64) 1024) * 1024 * 1024;\n\n\t\telse if (pg_strcasecmp(strptr, \"tb\") == 0)\n\t\t\tmultiplier = ((int64) 1024) * 1024 * 1024 * 1024;\n\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"invalid size: \\\"%s\\\"\", text_to_cstring(arg)),\n\t\t\t\t\t errdetail(\"Invalid size unit: \\\"%s\\\".\", strptr),\n\t\t\t\t\t errhint(\"Valid units are \\\"bytes\\\", \\\"kB\\\", \\\"MB\\\", \\\"GB\\\", and \\\"TB\\\".\")));\n\n\t\tif (multiplier > 1)\n\t\t{\n\t\t\tNumeric\t\tmul_num;\n\n\t\t\tmul_num = DatumGetNumeric(DirectFunctionCall1(int8_numeric,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  Int64GetDatum(multiplier)));\n\n\t\t\tnum = DatumGetNumeric(DirectFunctionCall2(numeric_mul,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  NumericGetDatum(mul_num),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  NumericGetDatum(num)));\n\t\t}\n\t}\n\n\tresult = DatumGetInt64(DirectFunctionCall1(numeric_int8,\n\t\t\t\t\t\t\t\t\t\t\t   NumericGetDatum(num)));\n\n\tPG_RETURN_INT64(result);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/relfilenodemap.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/fd.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT64",
          "args": [
            "result"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetInt64",
          "args": [
            "DirectFunctionCall1(numeric_int8,\n\t\t\t\t\t\t\t\t\t\t\t   NumericGetDatum(num))"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "numeric_int8",
            "NumericGetDatum(num)"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NumericGetDatum",
          "args": [
            "num"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetNumeric",
          "args": [
            "DirectFunctionCall2(numeric_mul,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  NumericGetDatum(mul_num),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  NumericGetDatum(num))"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "numeric_mul",
            "NumericGetDatum(mul_num)",
            "NumericGetDatum(num)"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NumericGetDatum",
          "args": [
            "num"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NumericGetDatum",
          "args": [
            "mul_num"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetNumeric",
          "args": [
            "DirectFunctionCall1(int8_numeric,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  Int64GetDatum(multiplier))"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "int8_numeric",
            "Int64GetDatum(multiplier)"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int64GetDatum",
          "args": [
            "multiplier"
          ],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "Int64GetDatum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1876-1883",
          "snippet": "Datum\nInt64GetDatum(int64 X)\n{\n\tint64\t   *retval = (int64 *) palloc(sizeof(int64));\n\n\t*retval = X;\n\treturn PointerGetDatum(retval);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nInt64GetDatum(int64 X)\n{\n\tint64\t   *retval = (int64 *) palloc(sizeof(int64));\n\n\t*retval = X;\n\treturn PointerGetDatum(retval);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"invalid size: \\\"%s\\\"\", text_to_cstring(arg)),\n\t\t\t\t\t errdetail(\"Invalid size unit: \\\"%s\\\".\", strptr),\n\t\t\t\t\t errhint(\"Valid units are \\\"bytes\\\", \\\"kB\\\", \\\"MB\\\", \\\"GB\\\", and \\\"TB\\\".\"))"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errhint",
          "args": [
            "\"Valid units are \\\"bytes\\\", \\\"kB\\\", \\\"MB\\\", \\\"GB\\\", and \\\"TB\\\".\""
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "errhint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "984-999",
          "snippet": "int\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errdetail",
          "args": [
            "\"Invalid size unit: \\\"%s\\\".\"",
            "strptr"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "errdetail_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "918-933",
          "snippet": "int\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid size: \\\"%s\\\"\"",
            "text_to_cstring(arg)"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "text_to_cstring",
          "args": [
            "arg"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "text_to_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "181-197",
          "snippet": "char *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nchar *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_strcasecmp",
          "args": [
            "strptr",
            "\"tb\""
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_strcasecmp",
          "args": [
            "strptr",
            "\"gb\""
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_strcasecmp",
          "args": [
            "strptr",
            "\"mb\""
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_strcasecmp",
          "args": [
            "strptr",
            "\"kb\""
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_strcasecmp",
          "args": [
            "strptr",
            "\"bytes\""
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "(unsigned char) *endptr"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "array_isspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "431-442",
          "snippet": "static bool\narray_isspace(char ch)\n{\n\tif (ch == ' ' ||\n\t\tch == '\\t' ||\n\t\tch == '\\n' ||\n\t\tch == '\\r' ||\n\t\tch == '\\v' ||\n\t\tch == '\\f')\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool array_isspace(char ch);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool array_isspace(char ch);\n\nstatic bool\narray_isspace(char ch)\n{\n\tif (ch == ' ' ||\n\t\tch == '\\t' ||\n\t\tch == '\\n' ||\n\t\tch == '\\r' ||\n\t\tch == '\\v' ||\n\t\tch == '\\f')\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "arg"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetNumeric",
          "args": [
            "DirectFunctionCall3(numeric_in,\n\t\t\t\t\t\t\t\t\t\t\t  CStringGetDatum(strptr),\n\t\t\t\t\t\t\t\t\t\t\t  ObjectIdGetDatum(InvalidOid),\n\t\t\t\t\t\t\t\t\t\t\t  Int32GetDatum(-1))"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall3",
          "args": [
            "numeric_in",
            "CStringGetDatum(strptr)",
            "ObjectIdGetDatum(InvalidOid)",
            "Int32GetDatum(-1)"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int32GetDatum",
          "args": [
            "-1"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "InvalidOid"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CStringGetDatum",
          "args": [
            "strptr"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtol",
          "args": [
            "endptr + 1",
            "&cp",
            "10"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid size: \\\"%s\\\"\", str))"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "(unsigned char) *endptr"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "(unsigned char) *endptr"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "(unsigned char) *endptr"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "(unsigned char) *endptr"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/relfilenodemap.h\"\n#include \"utils/rel.h\"\n#include \"utils/numeric.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/fd.h\"\n#include \"miscadmin.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nDatum\npg_size_bytes(PG_FUNCTION_ARGS)\n{\n\ttext\t   *arg = PG_GETARG_TEXT_PP(0);\n\tchar\t   *str,\n\t\t\t   *strptr,\n\t\t\t   *endptr;\n\tchar\t\tsaved_char;\n\tNumeric\t\tnum;\n\tint64\t\tresult;\n\tbool\t\thave_digits = false;\n\n\tstr = text_to_cstring(arg);\n\n\t/* Skip leading whitespace */\n\tstrptr = str;\n\twhile (isspace((unsigned char) *strptr))\n\t\tstrptr++;\n\n\t/* Check that we have a valid number and determine where it ends */\n\tendptr = strptr;\n\n\t/* Part (1): sign */\n\tif (*endptr == '-' || *endptr == '+')\n\t\tendptr++;\n\n\t/* Part (2): main digit string */\n\tif (isdigit((unsigned char) *endptr))\n\t{\n\t\thave_digits = true;\n\t\tdo\n\t\t\tendptr++;\n\t\twhile (isdigit((unsigned char) *endptr));\n\t}\n\n\t/* Part (3): optional decimal point and fractional digits */\n\tif (*endptr == '.')\n\t{\n\t\tendptr++;\n\t\tif (isdigit((unsigned char) *endptr))\n\t\t{\n\t\t\thave_digits = true;\n\t\t\tdo\n\t\t\t\tendptr++;\n\t\t\twhile (isdigit((unsigned char) *endptr));\n\t\t}\n\t}\n\n\t/* Complain if we don't have a valid number at this point */\n\tif (!have_digits)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid size: \\\"%s\\\"\", str)));\n\n\t/* Part (4): optional exponent */\n\tif (*endptr == 'e' || *endptr == 'E')\n\t{\n\t\tlong\t\texponent;\n\t\tchar\t   *cp;\n\n\t\t/*\n\t\t * Note we might one day support EB units, so if what follows 'E'\n\t\t * isn't a number, just treat it all as a unit to be parsed.\n\t\t */\n\t\texponent = strtol(endptr + 1, &cp, 10);\n\t\t(void) exponent;\t\t/* Silence -Wunused-result warnings */\n\t\tif (cp > endptr + 1)\n\t\t\tendptr = cp;\n\t}\n\n\t/*\n\t * Parse the number, saving the next character, which may be the first\n\t * character of the unit string.\n\t */\n\tsaved_char = *endptr;\n\t*endptr = '\\0';\n\n\tnum = DatumGetNumeric(DirectFunctionCall3(numeric_in,\n\t\t\t\t\t\t\t\t\t\t\t  CStringGetDatum(strptr),\n\t\t\t\t\t\t\t\t\t\t\t  ObjectIdGetDatum(InvalidOid),\n\t\t\t\t\t\t\t\t\t\t\t  Int32GetDatum(-1)));\n\n\t*endptr = saved_char;\n\n\t/* Skip whitespace between number and unit */\n\tstrptr = endptr;\n\twhile (isspace((unsigned char) *strptr))\n\t\tstrptr++;\n\n\t/* Handle possible unit */\n\tif (*strptr != '\\0')\n\t{\n\t\tint64\t\tmultiplier = 0;\n\n\t\t/* Trim any trailing whitespace */\n\t\tendptr = str + VARSIZE_ANY_EXHDR(arg) - 1;\n\n\t\twhile (isspace((unsigned char) *endptr))\n\t\t\tendptr--;\n\n\t\tendptr++;\n\t\t*endptr = '\\0';\n\n\t\t/* Parse the unit case-insensitively */\n\t\tif (pg_strcasecmp(strptr, \"bytes\") == 0)\n\t\t\tmultiplier = (int64) 1;\n\t\telse if (pg_strcasecmp(strptr, \"kb\") == 0)\n\t\t\tmultiplier = (int64) 1024;\n\t\telse if (pg_strcasecmp(strptr, \"mb\") == 0)\n\t\t\tmultiplier = ((int64) 1024) * 1024;\n\n\t\telse if (pg_strcasecmp(strptr, \"gb\") == 0)\n\t\t\tmultiplier = ((int64) 1024) * 1024 * 1024;\n\n\t\telse if (pg_strcasecmp(strptr, \"tb\") == 0)\n\t\t\tmultiplier = ((int64) 1024) * 1024 * 1024 * 1024;\n\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"invalid size: \\\"%s\\\"\", text_to_cstring(arg)),\n\t\t\t\t\t errdetail(\"Invalid size unit: \\\"%s\\\".\", strptr),\n\t\t\t\t\t errhint(\"Valid units are \\\"bytes\\\", \\\"kB\\\", \\\"MB\\\", \\\"GB\\\", and \\\"TB\\\".\")));\n\n\t\tif (multiplier > 1)\n\t\t{\n\t\t\tNumeric\t\tmul_num;\n\n\t\t\tmul_num = DatumGetNumeric(DirectFunctionCall1(int8_numeric,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  Int64GetDatum(multiplier)));\n\n\t\t\tnum = DatumGetNumeric(DirectFunctionCall2(numeric_mul,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  NumericGetDatum(mul_num),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  NumericGetDatum(num)));\n\t\t}\n\t}\n\n\tresult = DatumGetInt64(DirectFunctionCall1(numeric_int8,\n\t\t\t\t\t\t\t\t\t\t\t   NumericGetDatum(num)));\n\n\tPG_RETURN_INT64(result);\n}"
  },
  {
    "function_name": "pg_size_pretty_numeric",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/dbsize.c",
    "lines": "645-702",
    "snippet": "Datum\npg_size_pretty_numeric(PG_FUNCTION_ARGS)\n{\n\tNumeric\t\tsize = PG_GETARG_NUMERIC(0);\n\tNumeric\t\tlimit,\n\t\t\t\tlimit2;\n\tchar\t   *result;\n\n\tlimit = int64_to_numeric(10 * 1024);\n\tlimit2 = int64_to_numeric(10 * 1024 * 2 - 1);\n\n\tif (numeric_is_less(numeric_absolute(size), limit))\n\t{\n\t\tresult = psprintf(\"%s bytes\", numeric_to_cstring(size));\n\t}\n\telse\n\t{\n\t\t/* keep one extra bit for rounding */\n\t\t/* size >>= 9 */\n\t\tsize = numeric_shift_right(size, 9);\n\n\t\tif (numeric_is_less(numeric_absolute(size), limit2))\n\t\t{\n\t\t\tsize = numeric_half_rounded(size);\n\t\t\tresult = psprintf(\"%s kB\", numeric_to_cstring(size));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* size >>= 10 */\n\t\t\tsize = numeric_shift_right(size, 10);\n\t\t\tif (numeric_is_less(numeric_absolute(size), limit2))\n\t\t\t{\n\t\t\t\tsize = numeric_half_rounded(size);\n\t\t\t\tresult = psprintf(\"%s MB\", numeric_to_cstring(size));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* size >>= 10 */\n\t\t\t\tsize = numeric_shift_right(size, 10);\n\n\t\t\t\tif (numeric_is_less(numeric_absolute(size), limit2))\n\t\t\t\t{\n\t\t\t\t\tsize = numeric_half_rounded(size);\n\t\t\t\t\tresult = psprintf(\"%s GB\", numeric_to_cstring(size));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* size >>= 10 */\n\t\t\t\t\tsize = numeric_shift_right(size, 10);\n\t\t\t\t\tsize = numeric_half_rounded(size);\n\t\t\t\t\tresult = psprintf(\"%s TB\", numeric_to_cstring(size));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tPG_RETURN_TEXT_P(cstring_to_text(result));\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/relfilenodemap.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/fd.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "cstring_to_text(result)"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cstring_to_text",
          "args": [
            "result"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "148-152",
          "snippet": "text *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}"
        }
      },
      {
        "call_info": {
          "callee": "psprintf",
          "args": [
            "\"%s TB\"",
            "numeric_to_cstring(size)"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "numeric_to_cstring",
          "args": [
            "size"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "numeric_to_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/dbsize.c",
          "lines": "574-580",
          "snippet": "static char *\nnumeric_to_cstring(Numeric n)\n{\n\tDatum\t\td = NumericGetDatum(n);\n\n\treturn DatumGetCString(DirectFunctionCall1(numeric_out, d));\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/relfilenodemap.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/fd.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/relfilenodemap.h\"\n#include \"utils/rel.h\"\n#include \"utils/numeric.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/fd.h\"\n#include \"miscadmin.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic char *\nnumeric_to_cstring(Numeric n)\n{\n\tDatum\t\td = NumericGetDatum(n);\n\n\treturn DatumGetCString(DirectFunctionCall1(numeric_out, d));\n}"
        }
      },
      {
        "call_info": {
          "callee": "numeric_half_rounded",
          "args": [
            "size"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "numeric_half_rounded",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/dbsize.c",
          "lines": "609-629",
          "snippet": "static Numeric\nnumeric_half_rounded(Numeric n)\n{\n\tDatum\t\td = NumericGetDatum(n);\n\tDatum\t\tzero;\n\tDatum\t\tone;\n\tDatum\t\ttwo;\n\tDatum\t\tresult;\n\n\tzero = DirectFunctionCall1(int8_numeric, Int64GetDatum(0));\n\tone = DirectFunctionCall1(int8_numeric, Int64GetDatum(1));\n\ttwo = DirectFunctionCall1(int8_numeric, Int64GetDatum(2));\n\n\tif (DatumGetBool(DirectFunctionCall2(numeric_ge, d, zero)))\n\t\td = DirectFunctionCall2(numeric_add, d, one);\n\telse\n\t\td = DirectFunctionCall2(numeric_sub, d, one);\n\n\tresult = DirectFunctionCall2(numeric_div_trunc, d, two);\n\treturn DatumGetNumeric(result);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/relfilenodemap.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/fd.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/relfilenodemap.h\"\n#include \"utils/rel.h\"\n#include \"utils/numeric.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/fd.h\"\n#include \"miscadmin.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic Numeric\nnumeric_half_rounded(Numeric n)\n{\n\tDatum\t\td = NumericGetDatum(n);\n\tDatum\t\tzero;\n\tDatum\t\tone;\n\tDatum\t\ttwo;\n\tDatum\t\tresult;\n\n\tzero = DirectFunctionCall1(int8_numeric, Int64GetDatum(0));\n\tone = DirectFunctionCall1(int8_numeric, Int64GetDatum(1));\n\ttwo = DirectFunctionCall1(int8_numeric, Int64GetDatum(2));\n\n\tif (DatumGetBool(DirectFunctionCall2(numeric_ge, d, zero)))\n\t\td = DirectFunctionCall2(numeric_add, d, one);\n\telse\n\t\td = DirectFunctionCall2(numeric_sub, d, one);\n\n\tresult = DirectFunctionCall2(numeric_div_trunc, d, two);\n\treturn DatumGetNumeric(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "numeric_shift_right",
          "args": [
            "size",
            "10"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "numeric_shift_right",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/dbsize.c",
          "lines": "631-643",
          "snippet": "static Numeric\nnumeric_shift_right(Numeric n, unsigned count)\n{\n\tDatum\t\td = NumericGetDatum(n);\n\tDatum\t\tdivisor_int64;\n\tDatum\t\tdivisor_numeric;\n\tDatum\t\tresult;\n\n\tdivisor_int64 = Int64GetDatum((int64) (1 << count));\n\tdivisor_numeric = DirectFunctionCall1(int8_numeric, divisor_int64);\n\tresult = DirectFunctionCall2(numeric_div_trunc, d, divisor_numeric);\n\treturn DatumGetNumeric(result);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/relfilenodemap.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/fd.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/relfilenodemap.h\"\n#include \"utils/rel.h\"\n#include \"utils/numeric.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/fd.h\"\n#include \"miscadmin.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic Numeric\nnumeric_shift_right(Numeric n, unsigned count)\n{\n\tDatum\t\td = NumericGetDatum(n);\n\tDatum\t\tdivisor_int64;\n\tDatum\t\tdivisor_numeric;\n\tDatum\t\tresult;\n\n\tdivisor_int64 = Int64GetDatum((int64) (1 << count));\n\tdivisor_numeric = DirectFunctionCall1(int8_numeric, divisor_int64);\n\tresult = DirectFunctionCall2(numeric_div_trunc, d, divisor_numeric);\n\treturn DatumGetNumeric(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "psprintf",
          "args": [
            "\"%s GB\"",
            "numeric_to_cstring(size)"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "numeric_is_less",
          "args": [
            "numeric_absolute(size)",
            "limit2"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "numeric_is_less",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/dbsize.c",
          "lines": "590-597",
          "snippet": "static bool\nnumeric_is_less(Numeric a, Numeric b)\n{\n\tDatum\t\tda = NumericGetDatum(a);\n\tDatum\t\tdb = NumericGetDatum(b);\n\n\treturn DatumGetBool(DirectFunctionCall2(numeric_lt, da, db));\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/relfilenodemap.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/fd.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/relfilenodemap.h\"\n#include \"utils/rel.h\"\n#include \"utils/numeric.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/fd.h\"\n#include \"miscadmin.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic bool\nnumeric_is_less(Numeric a, Numeric b)\n{\n\tDatum\t\tda = NumericGetDatum(a);\n\tDatum\t\tdb = NumericGetDatum(b);\n\n\treturn DatumGetBool(DirectFunctionCall2(numeric_lt, da, db));\n}"
        }
      },
      {
        "call_info": {
          "callee": "numeric_absolute",
          "args": [
            "size"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "numeric_absolute",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/dbsize.c",
          "lines": "599-607",
          "snippet": "static Numeric\nnumeric_absolute(Numeric n)\n{\n\tDatum\t\td = NumericGetDatum(n);\n\tDatum\t\tresult;\n\n\tresult = DirectFunctionCall1(numeric_abs, d);\n\treturn DatumGetNumeric(result);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/relfilenodemap.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/fd.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/relfilenodemap.h\"\n#include \"utils/rel.h\"\n#include \"utils/numeric.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/fd.h\"\n#include \"miscadmin.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic Numeric\nnumeric_absolute(Numeric n)\n{\n\tDatum\t\td = NumericGetDatum(n);\n\tDatum\t\tresult;\n\n\tresult = DirectFunctionCall1(numeric_abs, d);\n\treturn DatumGetNumeric(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "psprintf",
          "args": [
            "\"%s MB\"",
            "numeric_to_cstring(size)"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "psprintf",
          "args": [
            "\"%s kB\"",
            "numeric_to_cstring(size)"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "psprintf",
          "args": [
            "\"%s bytes\"",
            "numeric_to_cstring(size)"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "int64_to_numeric",
          "args": [
            "10 * 1024 * 2 - 1"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "int64_to_numeric",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/dbsize.c",
          "lines": "582-588",
          "snippet": "static Numeric\nint64_to_numeric(int64 v)\n{\n\tDatum\t\td = Int64GetDatum(v);\n\n\treturn DatumGetNumeric(DirectFunctionCall1(int8_numeric, d));\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/relfilenodemap.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/fd.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/relfilenodemap.h\"\n#include \"utils/rel.h\"\n#include \"utils/numeric.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/fd.h\"\n#include \"miscadmin.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic Numeric\nint64_to_numeric(int64 v)\n{\n\tDatum\t\td = Int64GetDatum(v);\n\n\treturn DatumGetNumeric(DirectFunctionCall1(int8_numeric, d));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_NUMERIC",
          "args": [
            "0"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/relfilenodemap.h\"\n#include \"utils/rel.h\"\n#include \"utils/numeric.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/fd.h\"\n#include \"miscadmin.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nDatum\npg_size_pretty_numeric(PG_FUNCTION_ARGS)\n{\n\tNumeric\t\tsize = PG_GETARG_NUMERIC(0);\n\tNumeric\t\tlimit,\n\t\t\t\tlimit2;\n\tchar\t   *result;\n\n\tlimit = int64_to_numeric(10 * 1024);\n\tlimit2 = int64_to_numeric(10 * 1024 * 2 - 1);\n\n\tif (numeric_is_less(numeric_absolute(size), limit))\n\t{\n\t\tresult = psprintf(\"%s bytes\", numeric_to_cstring(size));\n\t}\n\telse\n\t{\n\t\t/* keep one extra bit for rounding */\n\t\t/* size >>= 9 */\n\t\tsize = numeric_shift_right(size, 9);\n\n\t\tif (numeric_is_less(numeric_absolute(size), limit2))\n\t\t{\n\t\t\tsize = numeric_half_rounded(size);\n\t\t\tresult = psprintf(\"%s kB\", numeric_to_cstring(size));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* size >>= 10 */\n\t\t\tsize = numeric_shift_right(size, 10);\n\t\t\tif (numeric_is_less(numeric_absolute(size), limit2))\n\t\t\t{\n\t\t\t\tsize = numeric_half_rounded(size);\n\t\t\t\tresult = psprintf(\"%s MB\", numeric_to_cstring(size));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* size >>= 10 */\n\t\t\t\tsize = numeric_shift_right(size, 10);\n\n\t\t\t\tif (numeric_is_less(numeric_absolute(size), limit2))\n\t\t\t\t{\n\t\t\t\t\tsize = numeric_half_rounded(size);\n\t\t\t\t\tresult = psprintf(\"%s GB\", numeric_to_cstring(size));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* size >>= 10 */\n\t\t\t\t\tsize = numeric_shift_right(size, 10);\n\t\t\t\t\tsize = numeric_half_rounded(size);\n\t\t\t\t\tresult = psprintf(\"%s TB\", numeric_to_cstring(size));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tPG_RETURN_TEXT_P(cstring_to_text(result));\n}"
  },
  {
    "function_name": "numeric_shift_right",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/dbsize.c",
    "lines": "631-643",
    "snippet": "static Numeric\nnumeric_shift_right(Numeric n, unsigned count)\n{\n\tDatum\t\td = NumericGetDatum(n);\n\tDatum\t\tdivisor_int64;\n\tDatum\t\tdivisor_numeric;\n\tDatum\t\tresult;\n\n\tdivisor_int64 = Int64GetDatum((int64) (1 << count));\n\tdivisor_numeric = DirectFunctionCall1(int8_numeric, divisor_int64);\n\tresult = DirectFunctionCall2(numeric_div_trunc, d, divisor_numeric);\n\treturn DatumGetNumeric(result);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/relfilenodemap.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/fd.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DatumGetNumeric",
          "args": [
            "result"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "numeric_div_trunc",
            "d",
            "divisor_numeric"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "int8_numeric",
            "divisor_int64"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int64GetDatum",
          "args": [
            "(int64) (1 << count)"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "Int64GetDatum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1876-1883",
          "snippet": "Datum\nInt64GetDatum(int64 X)\n{\n\tint64\t   *retval = (int64 *) palloc(sizeof(int64));\n\n\t*retval = X;\n\treturn PointerGetDatum(retval);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nInt64GetDatum(int64 X)\n{\n\tint64\t   *retval = (int64 *) palloc(sizeof(int64));\n\n\t*retval = X;\n\treturn PointerGetDatum(retval);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "1 << count"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NumericGetDatum",
          "args": [
            "n"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/relfilenodemap.h\"\n#include \"utils/rel.h\"\n#include \"utils/numeric.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/fd.h\"\n#include \"miscadmin.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic Numeric\nnumeric_shift_right(Numeric n, unsigned count)\n{\n\tDatum\t\td = NumericGetDatum(n);\n\tDatum\t\tdivisor_int64;\n\tDatum\t\tdivisor_numeric;\n\tDatum\t\tresult;\n\n\tdivisor_int64 = Int64GetDatum((int64) (1 << count));\n\tdivisor_numeric = DirectFunctionCall1(int8_numeric, divisor_int64);\n\tresult = DirectFunctionCall2(numeric_div_trunc, d, divisor_numeric);\n\treturn DatumGetNumeric(result);\n}"
  },
  {
    "function_name": "numeric_half_rounded",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/dbsize.c",
    "lines": "609-629",
    "snippet": "static Numeric\nnumeric_half_rounded(Numeric n)\n{\n\tDatum\t\td = NumericGetDatum(n);\n\tDatum\t\tzero;\n\tDatum\t\tone;\n\tDatum\t\ttwo;\n\tDatum\t\tresult;\n\n\tzero = DirectFunctionCall1(int8_numeric, Int64GetDatum(0));\n\tone = DirectFunctionCall1(int8_numeric, Int64GetDatum(1));\n\ttwo = DirectFunctionCall1(int8_numeric, Int64GetDatum(2));\n\n\tif (DatumGetBool(DirectFunctionCall2(numeric_ge, d, zero)))\n\t\td = DirectFunctionCall2(numeric_add, d, one);\n\telse\n\t\td = DirectFunctionCall2(numeric_sub, d, one);\n\n\tresult = DirectFunctionCall2(numeric_div_trunc, d, two);\n\treturn DatumGetNumeric(result);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/relfilenodemap.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/fd.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DatumGetNumeric",
          "args": [
            "result"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "numeric_div_trunc",
            "d",
            "two"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "numeric_sub",
            "d",
            "one"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "numeric_add",
            "d",
            "one"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetBool",
          "args": [
            "DirectFunctionCall2(numeric_ge, d, zero)"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "numeric_ge",
            "d",
            "zero"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "int8_numeric",
            "Int64GetDatum(2)"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int64GetDatum",
          "args": [
            "2"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "Int64GetDatum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1876-1883",
          "snippet": "Datum\nInt64GetDatum(int64 X)\n{\n\tint64\t   *retval = (int64 *) palloc(sizeof(int64));\n\n\t*retval = X;\n\treturn PointerGetDatum(retval);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nInt64GetDatum(int64 X)\n{\n\tint64\t   *retval = (int64 *) palloc(sizeof(int64));\n\n\t*retval = X;\n\treturn PointerGetDatum(retval);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "int8_numeric",
            "Int64GetDatum(1)"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "int8_numeric",
            "Int64GetDatum(0)"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NumericGetDatum",
          "args": [
            "n"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/relfilenodemap.h\"\n#include \"utils/rel.h\"\n#include \"utils/numeric.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/fd.h\"\n#include \"miscadmin.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic Numeric\nnumeric_half_rounded(Numeric n)\n{\n\tDatum\t\td = NumericGetDatum(n);\n\tDatum\t\tzero;\n\tDatum\t\tone;\n\tDatum\t\ttwo;\n\tDatum\t\tresult;\n\n\tzero = DirectFunctionCall1(int8_numeric, Int64GetDatum(0));\n\tone = DirectFunctionCall1(int8_numeric, Int64GetDatum(1));\n\ttwo = DirectFunctionCall1(int8_numeric, Int64GetDatum(2));\n\n\tif (DatumGetBool(DirectFunctionCall2(numeric_ge, d, zero)))\n\t\td = DirectFunctionCall2(numeric_add, d, one);\n\telse\n\t\td = DirectFunctionCall2(numeric_sub, d, one);\n\n\tresult = DirectFunctionCall2(numeric_div_trunc, d, two);\n\treturn DatumGetNumeric(result);\n}"
  },
  {
    "function_name": "numeric_absolute",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/dbsize.c",
    "lines": "599-607",
    "snippet": "static Numeric\nnumeric_absolute(Numeric n)\n{\n\tDatum\t\td = NumericGetDatum(n);\n\tDatum\t\tresult;\n\n\tresult = DirectFunctionCall1(numeric_abs, d);\n\treturn DatumGetNumeric(result);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/relfilenodemap.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/fd.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DatumGetNumeric",
          "args": [
            "result"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "numeric_abs",
            "d"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NumericGetDatum",
          "args": [
            "n"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/relfilenodemap.h\"\n#include \"utils/rel.h\"\n#include \"utils/numeric.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/fd.h\"\n#include \"miscadmin.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic Numeric\nnumeric_absolute(Numeric n)\n{\n\tDatum\t\td = NumericGetDatum(n);\n\tDatum\t\tresult;\n\n\tresult = DirectFunctionCall1(numeric_abs, d);\n\treturn DatumGetNumeric(result);\n}"
  },
  {
    "function_name": "numeric_is_less",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/dbsize.c",
    "lines": "590-597",
    "snippet": "static bool\nnumeric_is_less(Numeric a, Numeric b)\n{\n\tDatum\t\tda = NumericGetDatum(a);\n\tDatum\t\tdb = NumericGetDatum(b);\n\n\treturn DatumGetBool(DirectFunctionCall2(numeric_lt, da, db));\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/relfilenodemap.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/fd.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DatumGetBool",
          "args": [
            "DirectFunctionCall2(numeric_lt, da, db)"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "numeric_lt",
            "da",
            "db"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NumericGetDatum",
          "args": [
            "b"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NumericGetDatum",
          "args": [
            "a"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/relfilenodemap.h\"\n#include \"utils/rel.h\"\n#include \"utils/numeric.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/fd.h\"\n#include \"miscadmin.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic bool\nnumeric_is_less(Numeric a, Numeric b)\n{\n\tDatum\t\tda = NumericGetDatum(a);\n\tDatum\t\tdb = NumericGetDatum(b);\n\n\treturn DatumGetBool(DirectFunctionCall2(numeric_lt, da, db));\n}"
  },
  {
    "function_name": "int64_to_numeric",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/dbsize.c",
    "lines": "582-588",
    "snippet": "static Numeric\nint64_to_numeric(int64 v)\n{\n\tDatum\t\td = Int64GetDatum(v);\n\n\treturn DatumGetNumeric(DirectFunctionCall1(int8_numeric, d));\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/relfilenodemap.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/fd.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DatumGetNumeric",
          "args": [
            "DirectFunctionCall1(int8_numeric, d)"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "int8_numeric",
            "d"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int64GetDatum",
          "args": [
            "v"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "Int64GetDatum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1876-1883",
          "snippet": "Datum\nInt64GetDatum(int64 X)\n{\n\tint64\t   *retval = (int64 *) palloc(sizeof(int64));\n\n\t*retval = X;\n\treturn PointerGetDatum(retval);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nInt64GetDatum(int64 X)\n{\n\tint64\t   *retval = (int64 *) palloc(sizeof(int64));\n\n\t*retval = X;\n\treturn PointerGetDatum(retval);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/relfilenodemap.h\"\n#include \"utils/rel.h\"\n#include \"utils/numeric.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/fd.h\"\n#include \"miscadmin.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic Numeric\nint64_to_numeric(int64 v)\n{\n\tDatum\t\td = Int64GetDatum(v);\n\n\treturn DatumGetNumeric(DirectFunctionCall1(int8_numeric, d));\n}"
  },
  {
    "function_name": "numeric_to_cstring",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/dbsize.c",
    "lines": "574-580",
    "snippet": "static char *\nnumeric_to_cstring(Numeric n)\n{\n\tDatum\t\td = NumericGetDatum(n);\n\n\treturn DatumGetCString(DirectFunctionCall1(numeric_out, d));\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/relfilenodemap.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/fd.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DatumGetCString",
          "args": [
            "DirectFunctionCall1(numeric_out, d)"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "numeric_out",
            "d"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NumericGetDatum",
          "args": [
            "n"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/relfilenodemap.h\"\n#include \"utils/rel.h\"\n#include \"utils/numeric.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/fd.h\"\n#include \"miscadmin.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic char *\nnumeric_to_cstring(Numeric n)\n{\n\tDatum\t\td = NumericGetDatum(n);\n\n\treturn DatumGetCString(DirectFunctionCall1(numeric_out, d));\n}"
  },
  {
    "function_name": "pg_size_pretty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/dbsize.c",
    "lines": "533-572",
    "snippet": "Datum\npg_size_pretty(PG_FUNCTION_ARGS)\n{\n\tint64\t\tsize = PG_GETARG_INT64(0);\n\tchar\t\tbuf[64];\n\tint64\t\tlimit = 10 * 1024;\n\tint64\t\tlimit2 = limit * 2 - 1;\n\n\tif (Abs(size) < limit)\n\t\tsnprintf(buf, sizeof(buf), INT64_FORMAT \" bytes\", size);\n\telse\n\t{\n\t\tsize >>= 9;\t\t\t\t/* keep one extra bit for rounding */\n\t\tif (Abs(size) < limit2)\n\t\t\tsnprintf(buf, sizeof(buf), INT64_FORMAT \" kB\",\n\t\t\t\t\t half_rounded(size));\n\t\telse\n\t\t{\n\t\t\tsize >>= 10;\n\t\t\tif (Abs(size) < limit2)\n\t\t\t\tsnprintf(buf, sizeof(buf), INT64_FORMAT \" MB\",\n\t\t\t\t\t\t half_rounded(size));\n\t\t\telse\n\t\t\t{\n\t\t\t\tsize >>= 10;\n\t\t\t\tif (Abs(size) < limit2)\n\t\t\t\t\tsnprintf(buf, sizeof(buf), INT64_FORMAT \" GB\",\n\t\t\t\t\t\t\t half_rounded(size));\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tsize >>= 10;\n\t\t\t\t\tsnprintf(buf, sizeof(buf), INT64_FORMAT \" TB\",\n\t\t\t\t\t\t\t half_rounded(size));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tPG_RETURN_TEXT_P(cstring_to_text(buf));\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/relfilenodemap.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/fd.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "cstring_to_text(buf)"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cstring_to_text",
          "args": [
            "buf"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "148-152",
          "snippet": "text *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof(buf)",
            "INT64_FORMAT \" TB\"",
            "half_rounded(size)"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "half_rounded",
          "args": [
            "size"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "numeric_half_rounded",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/dbsize.c",
          "lines": "609-629",
          "snippet": "static Numeric\nnumeric_half_rounded(Numeric n)\n{\n\tDatum\t\td = NumericGetDatum(n);\n\tDatum\t\tzero;\n\tDatum\t\tone;\n\tDatum\t\ttwo;\n\tDatum\t\tresult;\n\n\tzero = DirectFunctionCall1(int8_numeric, Int64GetDatum(0));\n\tone = DirectFunctionCall1(int8_numeric, Int64GetDatum(1));\n\ttwo = DirectFunctionCall1(int8_numeric, Int64GetDatum(2));\n\n\tif (DatumGetBool(DirectFunctionCall2(numeric_ge, d, zero)))\n\t\td = DirectFunctionCall2(numeric_add, d, one);\n\telse\n\t\td = DirectFunctionCall2(numeric_sub, d, one);\n\n\tresult = DirectFunctionCall2(numeric_div_trunc, d, two);\n\treturn DatumGetNumeric(result);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/relfilenodemap.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/fd.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/relfilenodemap.h\"\n#include \"utils/rel.h\"\n#include \"utils/numeric.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/fd.h\"\n#include \"miscadmin.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic Numeric\nnumeric_half_rounded(Numeric n)\n{\n\tDatum\t\td = NumericGetDatum(n);\n\tDatum\t\tzero;\n\tDatum\t\tone;\n\tDatum\t\ttwo;\n\tDatum\t\tresult;\n\n\tzero = DirectFunctionCall1(int8_numeric, Int64GetDatum(0));\n\tone = DirectFunctionCall1(int8_numeric, Int64GetDatum(1));\n\ttwo = DirectFunctionCall1(int8_numeric, Int64GetDatum(2));\n\n\tif (DatumGetBool(DirectFunctionCall2(numeric_ge, d, zero)))\n\t\td = DirectFunctionCall2(numeric_add, d, one);\n\telse\n\t\td = DirectFunctionCall2(numeric_sub, d, one);\n\n\tresult = DirectFunctionCall2(numeric_div_trunc, d, two);\n\treturn DatumGetNumeric(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof(buf)",
            "INT64_FORMAT \" GB\"",
            "half_rounded(size)"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Abs",
          "args": [
            "size"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof(buf)",
            "INT64_FORMAT \" MB\"",
            "half_rounded(size)"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Abs",
          "args": [
            "size"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof(buf)",
            "INT64_FORMAT \" kB\"",
            "half_rounded(size)"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Abs",
          "args": [
            "size"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof(buf)",
            "INT64_FORMAT \" bytes\"",
            "size"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Abs",
          "args": [
            "size"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT64",
          "args": [
            "0"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/relfilenodemap.h\"\n#include \"utils/rel.h\"\n#include \"utils/numeric.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/fd.h\"\n#include \"miscadmin.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nDatum\npg_size_pretty(PG_FUNCTION_ARGS)\n{\n\tint64\t\tsize = PG_GETARG_INT64(0);\n\tchar\t\tbuf[64];\n\tint64\t\tlimit = 10 * 1024;\n\tint64\t\tlimit2 = limit * 2 - 1;\n\n\tif (Abs(size) < limit)\n\t\tsnprintf(buf, sizeof(buf), INT64_FORMAT \" bytes\", size);\n\telse\n\t{\n\t\tsize >>= 9;\t\t\t\t/* keep one extra bit for rounding */\n\t\tif (Abs(size) < limit2)\n\t\t\tsnprintf(buf, sizeof(buf), INT64_FORMAT \" kB\",\n\t\t\t\t\t half_rounded(size));\n\t\telse\n\t\t{\n\t\t\tsize >>= 10;\n\t\t\tif (Abs(size) < limit2)\n\t\t\t\tsnprintf(buf, sizeof(buf), INT64_FORMAT \" MB\",\n\t\t\t\t\t\t half_rounded(size));\n\t\t\telse\n\t\t\t{\n\t\t\t\tsize >>= 10;\n\t\t\t\tif (Abs(size) < limit2)\n\t\t\t\t\tsnprintf(buf, sizeof(buf), INT64_FORMAT \" GB\",\n\t\t\t\t\t\t\t half_rounded(size));\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tsize >>= 10;\n\t\t\t\t\tsnprintf(buf, sizeof(buf), INT64_FORMAT \" TB\",\n\t\t\t\t\t\t\t half_rounded(size));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tPG_RETURN_TEXT_P(cstring_to_text(buf));\n}"
  },
  {
    "function_name": "pg_total_relation_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/dbsize.c",
    "lines": "511-528",
    "snippet": "Datum\npg_total_relation_size(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\trelOid = PG_GETARG_OID(0);\n\tRelation\trel;\n\tint64\t\tsize;\n\n\trel = try_relation_open(relOid, AccessShareLock);\n\n\tif (rel == NULL)\n\t\tPG_RETURN_NULL();\n\n\tsize = calculate_total_relation_size(rel);\n\n\trelation_close(rel, AccessShareLock);\n\n\tPG_RETURN_INT64(size);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/relfilenodemap.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/fd.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT64",
          "args": [
            "size"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relation_close",
          "args": [
            "rel",
            "AccessShareLock"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calculate_total_relation_size",
          "args": [
            "rel"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "calculate_total_relation_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/dbsize.c",
          "lines": "492-509",
          "snippet": "static int64\ncalculate_total_relation_size(Relation rel)\n{\n\tint64\t\tsize;\n\n\t/*\n\t * Aggregate the table size, this includes size of the heap, toast and\n\t * toast index with free space and visibility map\n\t */\n\tsize = calculate_table_size(rel);\n\n\t/*\n\t * Add size of all attached indexes as well\n\t */\n\tsize += calculate_indexes_size(rel);\n\n\treturn size;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/relfilenodemap.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/fd.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/relfilenodemap.h\"\n#include \"utils/rel.h\"\n#include \"utils/numeric.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/fd.h\"\n#include \"miscadmin.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic int64\ncalculate_total_relation_size(Relation rel)\n{\n\tint64\t\tsize;\n\n\t/*\n\t * Aggregate the table size, this includes size of the heap, toast and\n\t * toast index with free space and visibility map\n\t */\n\tsize = calculate_table_size(rel);\n\n\t/*\n\t * Add size of all attached indexes as well\n\t */\n\tsize += calculate_indexes_size(rel);\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_relation_open",
          "args": [
            "relOid",
            "AccessShareLock"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "0"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/relfilenodemap.h\"\n#include \"utils/rel.h\"\n#include \"utils/numeric.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/fd.h\"\n#include \"miscadmin.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nDatum\npg_total_relation_size(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\trelOid = PG_GETARG_OID(0);\n\tRelation\trel;\n\tint64\t\tsize;\n\n\trel = try_relation_open(relOid, AccessShareLock);\n\n\tif (rel == NULL)\n\t\tPG_RETURN_NULL();\n\n\tsize = calculate_total_relation_size(rel);\n\n\trelation_close(rel, AccessShareLock);\n\n\tPG_RETURN_INT64(size);\n}"
  },
  {
    "function_name": "calculate_total_relation_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/dbsize.c",
    "lines": "492-509",
    "snippet": "static int64\ncalculate_total_relation_size(Relation rel)\n{\n\tint64\t\tsize;\n\n\t/*\n\t * Aggregate the table size, this includes size of the heap, toast and\n\t * toast index with free space and visibility map\n\t */\n\tsize = calculate_table_size(rel);\n\n\t/*\n\t * Add size of all attached indexes as well\n\t */\n\tsize += calculate_indexes_size(rel);\n\n\treturn size;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/relfilenodemap.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/fd.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "calculate_indexes_size",
          "args": [
            "rel"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "calculate_indexes_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/dbsize.c",
          "lines": "415-448",
          "snippet": "static int64\ncalculate_indexes_size(Relation rel)\n{\n\tint64\t\tsize = 0;\n\n\t/*\n\t * Aggregate all indexes on the given relation\n\t */\n\tif (rel->rd_rel->relhasindex)\n\t{\n\t\tList\t   *index_oids = RelationGetIndexList(rel);\n\t\tListCell   *cell;\n\n\t\tforeach(cell, index_oids)\n\t\t{\n\t\t\tOid\t\t\tidxOid = lfirst_oid(cell);\n\t\t\tRelation\tidxRel;\n\t\t\tForkNumber\tforkNum;\n\n\t\t\tidxRel = relation_open(idxOid, AccessShareLock);\n\n\t\t\tfor (forkNum = 0; forkNum <= MAX_FORKNUM; forkNum++)\n\t\t\t\tsize += calculate_relation_size(&(idxRel->rd_node),\n\t\t\t\t\t\t\t\t\t\t\t\tidxRel->rd_backend,\n\t\t\t\t\t\t\t\t\t\t\t\tforkNum);\n\n\t\t\trelation_close(idxRel, AccessShareLock);\n\t\t}\n\n\t\tlist_free(index_oids);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/relfilenodemap.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/fd.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/relfilenodemap.h\"\n#include \"utils/rel.h\"\n#include \"utils/numeric.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/fd.h\"\n#include \"miscadmin.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic int64\ncalculate_indexes_size(Relation rel)\n{\n\tint64\t\tsize = 0;\n\n\t/*\n\t * Aggregate all indexes on the given relation\n\t */\n\tif (rel->rd_rel->relhasindex)\n\t{\n\t\tList\t   *index_oids = RelationGetIndexList(rel);\n\t\tListCell   *cell;\n\n\t\tforeach(cell, index_oids)\n\t\t{\n\t\t\tOid\t\t\tidxOid = lfirst_oid(cell);\n\t\t\tRelation\tidxRel;\n\t\t\tForkNumber\tforkNum;\n\n\t\t\tidxRel = relation_open(idxOid, AccessShareLock);\n\n\t\t\tfor (forkNum = 0; forkNum <= MAX_FORKNUM; forkNum++)\n\t\t\t\tsize += calculate_relation_size(&(idxRel->rd_node),\n\t\t\t\t\t\t\t\t\t\t\t\tidxRel->rd_backend,\n\t\t\t\t\t\t\t\t\t\t\t\tforkNum);\n\n\t\t\trelation_close(idxRel, AccessShareLock);\n\t\t}\n\n\t\tlist_free(index_oids);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "calculate_table_size",
          "args": [
            "rel"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "calculate_table_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/dbsize.c",
          "lines": "388-408",
          "snippet": "static int64\ncalculate_table_size(Relation rel)\n{\n\tint64\t\tsize = 0;\n\tForkNumber\tforkNum;\n\n\t/*\n\t * heap size, including FSM and VM\n\t */\n\tfor (forkNum = 0; forkNum <= MAX_FORKNUM; forkNum++)\n\t\tsize += calculate_relation_size(&(rel->rd_node), rel->rd_backend,\n\t\t\t\t\t\t\t\t\t\tforkNum);\n\n\t/*\n\t * Size of toast relation\n\t */\n\tif (OidIsValid(rel->rd_rel->reltoastrelid))\n\t\tsize += calculate_toast_table_size(rel->rd_rel->reltoastrelid);\n\n\treturn size;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/relfilenodemap.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/fd.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/relfilenodemap.h\"\n#include \"utils/rel.h\"\n#include \"utils/numeric.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/fd.h\"\n#include \"miscadmin.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic int64\ncalculate_table_size(Relation rel)\n{\n\tint64\t\tsize = 0;\n\tForkNumber\tforkNum;\n\n\t/*\n\t * heap size, including FSM and VM\n\t */\n\tfor (forkNum = 0; forkNum <= MAX_FORKNUM; forkNum++)\n\t\tsize += calculate_relation_size(&(rel->rd_node), rel->rd_backend,\n\t\t\t\t\t\t\t\t\t\tforkNum);\n\n\t/*\n\t * Size of toast relation\n\t */\n\tif (OidIsValid(rel->rd_rel->reltoastrelid))\n\t\tsize += calculate_toast_table_size(rel->rd_rel->reltoastrelid);\n\n\treturn size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/relfilenodemap.h\"\n#include \"utils/rel.h\"\n#include \"utils/numeric.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/fd.h\"\n#include \"miscadmin.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic int64\ncalculate_total_relation_size(Relation rel)\n{\n\tint64\t\tsize;\n\n\t/*\n\t * Aggregate the table size, this includes size of the heap, toast and\n\t * toast index with free space and visibility map\n\t */\n\tsize = calculate_table_size(rel);\n\n\t/*\n\t * Add size of all attached indexes as well\n\t */\n\tsize += calculate_indexes_size(rel);\n\n\treturn size;\n}"
  },
  {
    "function_name": "pg_indexes_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/dbsize.c",
    "lines": "469-486",
    "snippet": "Datum\npg_indexes_size(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\trelOid = PG_GETARG_OID(0);\n\tRelation\trel;\n\tint64\t\tsize;\n\n\trel = try_relation_open(relOid, AccessShareLock);\n\n\tif (rel == NULL)\n\t\tPG_RETURN_NULL();\n\n\tsize = calculate_indexes_size(rel);\n\n\trelation_close(rel, AccessShareLock);\n\n\tPG_RETURN_INT64(size);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/relfilenodemap.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/fd.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT64",
          "args": [
            "size"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relation_close",
          "args": [
            "rel",
            "AccessShareLock"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calculate_indexes_size",
          "args": [
            "rel"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "calculate_indexes_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/dbsize.c",
          "lines": "415-448",
          "snippet": "static int64\ncalculate_indexes_size(Relation rel)\n{\n\tint64\t\tsize = 0;\n\n\t/*\n\t * Aggregate all indexes on the given relation\n\t */\n\tif (rel->rd_rel->relhasindex)\n\t{\n\t\tList\t   *index_oids = RelationGetIndexList(rel);\n\t\tListCell   *cell;\n\n\t\tforeach(cell, index_oids)\n\t\t{\n\t\t\tOid\t\t\tidxOid = lfirst_oid(cell);\n\t\t\tRelation\tidxRel;\n\t\t\tForkNumber\tforkNum;\n\n\t\t\tidxRel = relation_open(idxOid, AccessShareLock);\n\n\t\t\tfor (forkNum = 0; forkNum <= MAX_FORKNUM; forkNum++)\n\t\t\t\tsize += calculate_relation_size(&(idxRel->rd_node),\n\t\t\t\t\t\t\t\t\t\t\t\tidxRel->rd_backend,\n\t\t\t\t\t\t\t\t\t\t\t\tforkNum);\n\n\t\t\trelation_close(idxRel, AccessShareLock);\n\t\t}\n\n\t\tlist_free(index_oids);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/relfilenodemap.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/fd.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/relfilenodemap.h\"\n#include \"utils/rel.h\"\n#include \"utils/numeric.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/fd.h\"\n#include \"miscadmin.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic int64\ncalculate_indexes_size(Relation rel)\n{\n\tint64\t\tsize = 0;\n\n\t/*\n\t * Aggregate all indexes on the given relation\n\t */\n\tif (rel->rd_rel->relhasindex)\n\t{\n\t\tList\t   *index_oids = RelationGetIndexList(rel);\n\t\tListCell   *cell;\n\n\t\tforeach(cell, index_oids)\n\t\t{\n\t\t\tOid\t\t\tidxOid = lfirst_oid(cell);\n\t\t\tRelation\tidxRel;\n\t\t\tForkNumber\tforkNum;\n\n\t\t\tidxRel = relation_open(idxOid, AccessShareLock);\n\n\t\t\tfor (forkNum = 0; forkNum <= MAX_FORKNUM; forkNum++)\n\t\t\t\tsize += calculate_relation_size(&(idxRel->rd_node),\n\t\t\t\t\t\t\t\t\t\t\t\tidxRel->rd_backend,\n\t\t\t\t\t\t\t\t\t\t\t\tforkNum);\n\n\t\t\trelation_close(idxRel, AccessShareLock);\n\t\t}\n\n\t\tlist_free(index_oids);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_relation_open",
          "args": [
            "relOid",
            "AccessShareLock"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "0"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/relfilenodemap.h\"\n#include \"utils/rel.h\"\n#include \"utils/numeric.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/fd.h\"\n#include \"miscadmin.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nDatum\npg_indexes_size(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\trelOid = PG_GETARG_OID(0);\n\tRelation\trel;\n\tint64\t\tsize;\n\n\trel = try_relation_open(relOid, AccessShareLock);\n\n\tif (rel == NULL)\n\t\tPG_RETURN_NULL();\n\n\tsize = calculate_indexes_size(rel);\n\n\trelation_close(rel, AccessShareLock);\n\n\tPG_RETURN_INT64(size);\n}"
  },
  {
    "function_name": "pg_table_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/dbsize.c",
    "lines": "450-467",
    "snippet": "Datum\npg_table_size(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\trelOid = PG_GETARG_OID(0);\n\tRelation\trel;\n\tint64\t\tsize;\n\n\trel = try_relation_open(relOid, AccessShareLock);\n\n\tif (rel == NULL)\n\t\tPG_RETURN_NULL();\n\n\tsize = calculate_table_size(rel);\n\n\trelation_close(rel, AccessShareLock);\n\n\tPG_RETURN_INT64(size);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/relfilenodemap.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/fd.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT64",
          "args": [
            "size"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relation_close",
          "args": [
            "rel",
            "AccessShareLock"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calculate_table_size",
          "args": [
            "rel"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "calculate_table_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/dbsize.c",
          "lines": "388-408",
          "snippet": "static int64\ncalculate_table_size(Relation rel)\n{\n\tint64\t\tsize = 0;\n\tForkNumber\tforkNum;\n\n\t/*\n\t * heap size, including FSM and VM\n\t */\n\tfor (forkNum = 0; forkNum <= MAX_FORKNUM; forkNum++)\n\t\tsize += calculate_relation_size(&(rel->rd_node), rel->rd_backend,\n\t\t\t\t\t\t\t\t\t\tforkNum);\n\n\t/*\n\t * Size of toast relation\n\t */\n\tif (OidIsValid(rel->rd_rel->reltoastrelid))\n\t\tsize += calculate_toast_table_size(rel->rd_rel->reltoastrelid);\n\n\treturn size;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/relfilenodemap.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/fd.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/relfilenodemap.h\"\n#include \"utils/rel.h\"\n#include \"utils/numeric.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/fd.h\"\n#include \"miscadmin.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic int64\ncalculate_table_size(Relation rel)\n{\n\tint64\t\tsize = 0;\n\tForkNumber\tforkNum;\n\n\t/*\n\t * heap size, including FSM and VM\n\t */\n\tfor (forkNum = 0; forkNum <= MAX_FORKNUM; forkNum++)\n\t\tsize += calculate_relation_size(&(rel->rd_node), rel->rd_backend,\n\t\t\t\t\t\t\t\t\t\tforkNum);\n\n\t/*\n\t * Size of toast relation\n\t */\n\tif (OidIsValid(rel->rd_rel->reltoastrelid))\n\t\tsize += calculate_toast_table_size(rel->rd_rel->reltoastrelid);\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_relation_open",
          "args": [
            "relOid",
            "AccessShareLock"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "0"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/relfilenodemap.h\"\n#include \"utils/rel.h\"\n#include \"utils/numeric.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/fd.h\"\n#include \"miscadmin.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nDatum\npg_table_size(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\trelOid = PG_GETARG_OID(0);\n\tRelation\trel;\n\tint64\t\tsize;\n\n\trel = try_relation_open(relOid, AccessShareLock);\n\n\tif (rel == NULL)\n\t\tPG_RETURN_NULL();\n\n\tsize = calculate_table_size(rel);\n\n\trelation_close(rel, AccessShareLock);\n\n\tPG_RETURN_INT64(size);\n}"
  },
  {
    "function_name": "calculate_indexes_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/dbsize.c",
    "lines": "415-448",
    "snippet": "static int64\ncalculate_indexes_size(Relation rel)\n{\n\tint64\t\tsize = 0;\n\n\t/*\n\t * Aggregate all indexes on the given relation\n\t */\n\tif (rel->rd_rel->relhasindex)\n\t{\n\t\tList\t   *index_oids = RelationGetIndexList(rel);\n\t\tListCell   *cell;\n\n\t\tforeach(cell, index_oids)\n\t\t{\n\t\t\tOid\t\t\tidxOid = lfirst_oid(cell);\n\t\t\tRelation\tidxRel;\n\t\t\tForkNumber\tforkNum;\n\n\t\t\tidxRel = relation_open(idxOid, AccessShareLock);\n\n\t\t\tfor (forkNum = 0; forkNum <= MAX_FORKNUM; forkNum++)\n\t\t\t\tsize += calculate_relation_size(&(idxRel->rd_node),\n\t\t\t\t\t\t\t\t\t\t\t\tidxRel->rd_backend,\n\t\t\t\t\t\t\t\t\t\t\t\tforkNum);\n\n\t\t\trelation_close(idxRel, AccessShareLock);\n\t\t}\n\n\t\tlist_free(index_oids);\n\t}\n\n\treturn size;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/relfilenodemap.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/fd.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_free",
          "args": [
            "index_oids"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relation_close",
          "args": [
            "idxRel",
            "AccessShareLock"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calculate_relation_size",
          "args": [
            "&(idxRel->rd_node)",
            "idxRel->rd_backend",
            "forkNum"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "calculate_relation_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/dbsize.c",
          "lines": "272-308",
          "snippet": "static int64\ncalculate_relation_size(RelFileNode *rfn, BackendId backend, ForkNumber forknum)\n{\n\tint64\t\ttotalsize = 0;\n\tchar\t   *relationpath;\n\tchar\t\tpathname[MAXPGPATH];\n\tunsigned int segcount = 0;\n\n\trelationpath = relpathbackend(*rfn, backend, forknum);\n\n\tfor (segcount = 0;; segcount++)\n\t{\n\t\tstruct stat fst;\n\n\t\tCHECK_FOR_INTERRUPTS();\n\n\t\tif (segcount == 0)\n\t\t\tsnprintf(pathname, MAXPGPATH, \"%s\",\n\t\t\t\t\t relationpath);\n\t\telse\n\t\t\tsnprintf(pathname, MAXPGPATH, \"%s.%u\",\n\t\t\t\t\t relationpath, segcount);\n\n\t\tif (stat(pathname, &fst) < 0)\n\t\t{\n\t\t\tif (errno == ENOENT)\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not stat file \\\"%s\\\": %m\", pathname)));\n\t\t}\n\t\ttotalsize += fst.st_size;\n\t}\n\n\treturn totalsize;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/relfilenodemap.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/fd.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/relfilenodemap.h\"\n#include \"utils/rel.h\"\n#include \"utils/numeric.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/fd.h\"\n#include \"miscadmin.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic int64\ncalculate_relation_size(RelFileNode *rfn, BackendId backend, ForkNumber forknum)\n{\n\tint64\t\ttotalsize = 0;\n\tchar\t   *relationpath;\n\tchar\t\tpathname[MAXPGPATH];\n\tunsigned int segcount = 0;\n\n\trelationpath = relpathbackend(*rfn, backend, forknum);\n\n\tfor (segcount = 0;; segcount++)\n\t{\n\t\tstruct stat fst;\n\n\t\tCHECK_FOR_INTERRUPTS();\n\n\t\tif (segcount == 0)\n\t\t\tsnprintf(pathname, MAXPGPATH, \"%s\",\n\t\t\t\t\t relationpath);\n\t\telse\n\t\t\tsnprintf(pathname, MAXPGPATH, \"%s.%u\",\n\t\t\t\t\t relationpath, segcount);\n\n\t\tif (stat(pathname, &fst) < 0)\n\t\t{\n\t\t\tif (errno == ENOENT)\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not stat file \\\"%s\\\": %m\", pathname)));\n\t\t}\n\t\ttotalsize += fst.st_size;\n\t}\n\n\treturn totalsize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "relation_open",
          "args": [
            "idxOid",
            "AccessShareLock"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst_oid",
          "args": [
            "cell"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "cell",
            "index_oids"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetIndexList",
          "args": [
            "rel"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "RelationGetIndexList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "4242-4359",
          "snippet": "List *\nRelationGetIndexList(Relation relation)\n{\n\tRelation\tindrel;\n\tSysScanDesc indscan;\n\tScanKeyData skey;\n\tHeapTuple\thtup;\n\tList\t   *result;\n\tList\t   *oldlist;\n\tchar\t\treplident = relation->rd_rel->relreplident;\n\tOid\t\t\toidIndex = InvalidOid;\n\tOid\t\t\tpkeyIndex = InvalidOid;\n\tOid\t\t\tcandidateIndex = InvalidOid;\n\tMemoryContext oldcxt;\n\n\t/* Quick exit if we already computed the list. */\n\tif (relation->rd_indexvalid != 0)\n\t\treturn list_copy(relation->rd_indexlist);\n\n\t/*\n\t * We build the list we intend to return (in the caller's context) while\n\t * doing the scan.  After successfully completing the scan, we copy that\n\t * list into the relcache entry.  This avoids cache-context memory leakage\n\t * if we get some sort of error partway through.\n\t */\n\tresult = NIL;\n\toidIndex = InvalidOid;\n\n\t/* Prepare to scan pg_index for entries having indrelid = this rel. */\n\tScanKeyInit(&skey,\n\t\t\t\tAnum_pg_index_indrelid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(RelationGetRelid(relation)));\n\n\tindrel = heap_open(IndexRelationId, AccessShareLock);\n\tindscan = systable_beginscan(indrel, IndexIndrelidIndexId, true,\n\t\t\t\t\t\t\t\t NULL, 1, &skey);\n\n\twhile (HeapTupleIsValid(htup = systable_getnext(indscan)))\n\t{\n\t\tForm_pg_index index = (Form_pg_index) GETSTRUCT(htup);\n\t\tDatum\t\tindclassDatum;\n\t\toidvector  *indclass;\n\t\tbool\t\tisnull;\n\n\t\t/*\n\t\t * Ignore any indexes that are currently being dropped.  This will\n\t\t * prevent them from being searched, inserted into, or considered in\n\t\t * HOT-safety decisions.  It's unsafe to touch such an index at all\n\t\t * since its catalog entries could disappear at any instant.\n\t\t */\n\t\tif (!IndexIsLive(index))\n\t\t\tcontinue;\n\n\t\t/* Add index's OID to result list in the proper order */\n\t\tresult = insert_ordered_oid(result, index->indexrelid);\n\n\t\t/*\n\t\t * indclass cannot be referenced directly through the C struct,\n\t\t * because it comes after the variable-width indkey field.  Must\n\t\t * extract the datum the hard way...\n\t\t */\n\t\tindclassDatum = heap_getattr(htup,\n\t\t\t\t\t\t\t\t\t Anum_pg_index_indclass,\n\t\t\t\t\t\t\t\t\t GetPgIndexDescriptor(),\n\t\t\t\t\t\t\t\t\t &isnull);\n\t\tAssert(!isnull);\n\t\tindclass = (oidvector *) DatumGetPointer(indclassDatum);\n\n\t\t/*\n\t\t * Invalid, non-unique, non-immediate or predicate indexes aren't\n\t\t * interesting for either oid indexes or replication identity indexes,\n\t\t * so don't check them.\n\t\t */\n\t\tif (!IndexIsValid(index) || !index->indisunique ||\n\t\t\t!index->indimmediate ||\n\t\t\t!heap_attisnull(htup, Anum_pg_index_indpred, NULL))\n\t\t\tcontinue;\n\n\t\t/* Check to see if is a usable btree index on OID */\n\t\tif (index->indnatts == 1 &&\n\t\t\tindex->indkey.values[0] == ObjectIdAttributeNumber &&\n\t\t\tindclass->values[0] == OID_BTREE_OPS_OID)\n\t\t\toidIndex = index->indexrelid;\n\n\t\t/* remember primary key index if any */\n\t\tif (index->indisprimary)\n\t\t\tpkeyIndex = index->indexrelid;\n\n\t\t/* remember explicitly chosen replica index */\n\t\tif (index->indisreplident)\n\t\t\tcandidateIndex = index->indexrelid;\n\t}\n\n\tsystable_endscan(indscan);\n\n\theap_close(indrel, AccessShareLock);\n\n\t/* Now save a copy of the completed list in the relcache entry. */\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\toldlist = relation->rd_indexlist;\n\trelation->rd_indexlist = list_copy(result);\n\trelation->rd_oidindex = oidIndex;\n\trelation->rd_pkindex = pkeyIndex;\n\tif (replident == REPLICA_IDENTITY_DEFAULT && OidIsValid(pkeyIndex))\n\t\trelation->rd_replidindex = pkeyIndex;\n\telse if (replident == REPLICA_IDENTITY_INDEX && OidIsValid(candidateIndex))\n\t\trelation->rd_replidindex = candidateIndex;\n\telse\n\t\trelation->rd_replidindex = InvalidOid;\n\trelation->rd_indexvalid = 1;\n\tMemoryContextSwitchTo(oldcxt);\n\n\t/* Don't leak the old list, if there is one */\n\tlist_free(oldlist);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void RelationReloadIndexInfo(Relation relation);",
            "static void RelationReloadNailed(Relation relation);",
            "static void RelationFlushRelation(Relation relation);",
            "static void RelationBuildTupleDesc(Relation relation);",
            "static void RelationInitPhysicalAddr(Relation relation);",
            "static TupleDesc GetPgIndexDescriptor(void);",
            "static void AttrDefaultFetch(Relation relation);",
            "static void CheckConstraintFetch(Relation relation);",
            "static List *insert_ordered_oid(List *list, Oid datum);",
            "static void InitIndexAmRoutine(Relation relation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic TupleDesc GetPgIndexDescriptor(void);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic List *insert_ordered_oid(List *list, Oid datum);\nstatic void InitIndexAmRoutine(Relation relation);\n\nList *\nRelationGetIndexList(Relation relation)\n{\n\tRelation\tindrel;\n\tSysScanDesc indscan;\n\tScanKeyData skey;\n\tHeapTuple\thtup;\n\tList\t   *result;\n\tList\t   *oldlist;\n\tchar\t\treplident = relation->rd_rel->relreplident;\n\tOid\t\t\toidIndex = InvalidOid;\n\tOid\t\t\tpkeyIndex = InvalidOid;\n\tOid\t\t\tcandidateIndex = InvalidOid;\n\tMemoryContext oldcxt;\n\n\t/* Quick exit if we already computed the list. */\n\tif (relation->rd_indexvalid != 0)\n\t\treturn list_copy(relation->rd_indexlist);\n\n\t/*\n\t * We build the list we intend to return (in the caller's context) while\n\t * doing the scan.  After successfully completing the scan, we copy that\n\t * list into the relcache entry.  This avoids cache-context memory leakage\n\t * if we get some sort of error partway through.\n\t */\n\tresult = NIL;\n\toidIndex = InvalidOid;\n\n\t/* Prepare to scan pg_index for entries having indrelid = this rel. */\n\tScanKeyInit(&skey,\n\t\t\t\tAnum_pg_index_indrelid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(RelationGetRelid(relation)));\n\n\tindrel = heap_open(IndexRelationId, AccessShareLock);\n\tindscan = systable_beginscan(indrel, IndexIndrelidIndexId, true,\n\t\t\t\t\t\t\t\t NULL, 1, &skey);\n\n\twhile (HeapTupleIsValid(htup = systable_getnext(indscan)))\n\t{\n\t\tForm_pg_index index = (Form_pg_index) GETSTRUCT(htup);\n\t\tDatum\t\tindclassDatum;\n\t\toidvector  *indclass;\n\t\tbool\t\tisnull;\n\n\t\t/*\n\t\t * Ignore any indexes that are currently being dropped.  This will\n\t\t * prevent them from being searched, inserted into, or considered in\n\t\t * HOT-safety decisions.  It's unsafe to touch such an index at all\n\t\t * since its catalog entries could disappear at any instant.\n\t\t */\n\t\tif (!IndexIsLive(index))\n\t\t\tcontinue;\n\n\t\t/* Add index's OID to result list in the proper order */\n\t\tresult = insert_ordered_oid(result, index->indexrelid);\n\n\t\t/*\n\t\t * indclass cannot be referenced directly through the C struct,\n\t\t * because it comes after the variable-width indkey field.  Must\n\t\t * extract the datum the hard way...\n\t\t */\n\t\tindclassDatum = heap_getattr(htup,\n\t\t\t\t\t\t\t\t\t Anum_pg_index_indclass,\n\t\t\t\t\t\t\t\t\t GetPgIndexDescriptor(),\n\t\t\t\t\t\t\t\t\t &isnull);\n\t\tAssert(!isnull);\n\t\tindclass = (oidvector *) DatumGetPointer(indclassDatum);\n\n\t\t/*\n\t\t * Invalid, non-unique, non-immediate or predicate indexes aren't\n\t\t * interesting for either oid indexes or replication identity indexes,\n\t\t * so don't check them.\n\t\t */\n\t\tif (!IndexIsValid(index) || !index->indisunique ||\n\t\t\t!index->indimmediate ||\n\t\t\t!heap_attisnull(htup, Anum_pg_index_indpred, NULL))\n\t\t\tcontinue;\n\n\t\t/* Check to see if is a usable btree index on OID */\n\t\tif (index->indnatts == 1 &&\n\t\t\tindex->indkey.values[0] == ObjectIdAttributeNumber &&\n\t\t\tindclass->values[0] == OID_BTREE_OPS_OID)\n\t\t\toidIndex = index->indexrelid;\n\n\t\t/* remember primary key index if any */\n\t\tif (index->indisprimary)\n\t\t\tpkeyIndex = index->indexrelid;\n\n\t\t/* remember explicitly chosen replica index */\n\t\tif (index->indisreplident)\n\t\t\tcandidateIndex = index->indexrelid;\n\t}\n\n\tsystable_endscan(indscan);\n\n\theap_close(indrel, AccessShareLock);\n\n\t/* Now save a copy of the completed list in the relcache entry. */\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\toldlist = relation->rd_indexlist;\n\trelation->rd_indexlist = list_copy(result);\n\trelation->rd_oidindex = oidIndex;\n\trelation->rd_pkindex = pkeyIndex;\n\tif (replident == REPLICA_IDENTITY_DEFAULT && OidIsValid(pkeyIndex))\n\t\trelation->rd_replidindex = pkeyIndex;\n\telse if (replident == REPLICA_IDENTITY_INDEX && OidIsValid(candidateIndex))\n\t\trelation->rd_replidindex = candidateIndex;\n\telse\n\t\trelation->rd_replidindex = InvalidOid;\n\trelation->rd_indexvalid = 1;\n\tMemoryContextSwitchTo(oldcxt);\n\n\t/* Don't leak the old list, if there is one */\n\tlist_free(oldlist);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/relfilenodemap.h\"\n#include \"utils/rel.h\"\n#include \"utils/numeric.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/fd.h\"\n#include \"miscadmin.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic int64\ncalculate_indexes_size(Relation rel)\n{\n\tint64\t\tsize = 0;\n\n\t/*\n\t * Aggregate all indexes on the given relation\n\t */\n\tif (rel->rd_rel->relhasindex)\n\t{\n\t\tList\t   *index_oids = RelationGetIndexList(rel);\n\t\tListCell   *cell;\n\n\t\tforeach(cell, index_oids)\n\t\t{\n\t\t\tOid\t\t\tidxOid = lfirst_oid(cell);\n\t\t\tRelation\tidxRel;\n\t\t\tForkNumber\tforkNum;\n\n\t\t\tidxRel = relation_open(idxOid, AccessShareLock);\n\n\t\t\tfor (forkNum = 0; forkNum <= MAX_FORKNUM; forkNum++)\n\t\t\t\tsize += calculate_relation_size(&(idxRel->rd_node),\n\t\t\t\t\t\t\t\t\t\t\t\tidxRel->rd_backend,\n\t\t\t\t\t\t\t\t\t\t\t\tforkNum);\n\n\t\t\trelation_close(idxRel, AccessShareLock);\n\t\t}\n\n\t\tlist_free(index_oids);\n\t}\n\n\treturn size;\n}"
  },
  {
    "function_name": "calculate_table_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/dbsize.c",
    "lines": "388-408",
    "snippet": "static int64\ncalculate_table_size(Relation rel)\n{\n\tint64\t\tsize = 0;\n\tForkNumber\tforkNum;\n\n\t/*\n\t * heap size, including FSM and VM\n\t */\n\tfor (forkNum = 0; forkNum <= MAX_FORKNUM; forkNum++)\n\t\tsize += calculate_relation_size(&(rel->rd_node), rel->rd_backend,\n\t\t\t\t\t\t\t\t\t\tforkNum);\n\n\t/*\n\t * Size of toast relation\n\t */\n\tif (OidIsValid(rel->rd_rel->reltoastrelid))\n\t\tsize += calculate_toast_table_size(rel->rd_rel->reltoastrelid);\n\n\treturn size;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/relfilenodemap.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/fd.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "calculate_toast_table_size",
          "args": [
            "rel->rd_rel->reltoastrelid"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "calculate_toast_table_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/dbsize.c",
          "lines": "342-378",
          "snippet": "static int64\ncalculate_toast_table_size(Oid toastrelid)\n{\n\tint64\t\tsize = 0;\n\tRelation\ttoastRel;\n\tForkNumber\tforkNum;\n\tListCell   *lc;\n\tList\t   *indexlist;\n\n\ttoastRel = relation_open(toastrelid, AccessShareLock);\n\n\t/* toast heap size, including FSM and VM size */\n\tfor (forkNum = 0; forkNum <= MAX_FORKNUM; forkNum++)\n\t\tsize += calculate_relation_size(&(toastRel->rd_node),\n\t\t\t\t\t\t\t\t\t\ttoastRel->rd_backend, forkNum);\n\n\t/* toast index size, including FSM and VM size */\n\tindexlist = RelationGetIndexList(toastRel);\n\n\t/* Size is calculated using all the indexes available */\n\tforeach(lc, indexlist)\n\t{\n\t\tRelation\ttoastIdxRel;\n\n\t\ttoastIdxRel = relation_open(lfirst_oid(lc),\n\t\t\t\t\t\t\t\t\tAccessShareLock);\n\t\tfor (forkNum = 0; forkNum <= MAX_FORKNUM; forkNum++)\n\t\t\tsize += calculate_relation_size(&(toastIdxRel->rd_node),\n\t\t\t\t\t\t\t\t\t\t\ttoastIdxRel->rd_backend, forkNum);\n\n\t\trelation_close(toastIdxRel, AccessShareLock);\n\t}\n\tlist_free(indexlist);\n\trelation_close(toastRel, AccessShareLock);\n\n\treturn size;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/relfilenodemap.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/fd.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/relfilenodemap.h\"\n#include \"utils/rel.h\"\n#include \"utils/numeric.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/fd.h\"\n#include \"miscadmin.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic int64\ncalculate_toast_table_size(Oid toastrelid)\n{\n\tint64\t\tsize = 0;\n\tRelation\ttoastRel;\n\tForkNumber\tforkNum;\n\tListCell   *lc;\n\tList\t   *indexlist;\n\n\ttoastRel = relation_open(toastrelid, AccessShareLock);\n\n\t/* toast heap size, including FSM and VM size */\n\tfor (forkNum = 0; forkNum <= MAX_FORKNUM; forkNum++)\n\t\tsize += calculate_relation_size(&(toastRel->rd_node),\n\t\t\t\t\t\t\t\t\t\ttoastRel->rd_backend, forkNum);\n\n\t/* toast index size, including FSM and VM size */\n\tindexlist = RelationGetIndexList(toastRel);\n\n\t/* Size is calculated using all the indexes available */\n\tforeach(lc, indexlist)\n\t{\n\t\tRelation\ttoastIdxRel;\n\n\t\ttoastIdxRel = relation_open(lfirst_oid(lc),\n\t\t\t\t\t\t\t\t\tAccessShareLock);\n\t\tfor (forkNum = 0; forkNum <= MAX_FORKNUM; forkNum++)\n\t\t\tsize += calculate_relation_size(&(toastIdxRel->rd_node),\n\t\t\t\t\t\t\t\t\t\t\ttoastIdxRel->rd_backend, forkNum);\n\n\t\trelation_close(toastIdxRel, AccessShareLock);\n\t}\n\tlist_free(indexlist);\n\trelation_close(toastRel, AccessShareLock);\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "rel->rd_rel->reltoastrelid"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calculate_relation_size",
          "args": [
            "&(rel->rd_node)",
            "rel->rd_backend",
            "forkNum"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "calculate_relation_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/dbsize.c",
          "lines": "272-308",
          "snippet": "static int64\ncalculate_relation_size(RelFileNode *rfn, BackendId backend, ForkNumber forknum)\n{\n\tint64\t\ttotalsize = 0;\n\tchar\t   *relationpath;\n\tchar\t\tpathname[MAXPGPATH];\n\tunsigned int segcount = 0;\n\n\trelationpath = relpathbackend(*rfn, backend, forknum);\n\n\tfor (segcount = 0;; segcount++)\n\t{\n\t\tstruct stat fst;\n\n\t\tCHECK_FOR_INTERRUPTS();\n\n\t\tif (segcount == 0)\n\t\t\tsnprintf(pathname, MAXPGPATH, \"%s\",\n\t\t\t\t\t relationpath);\n\t\telse\n\t\t\tsnprintf(pathname, MAXPGPATH, \"%s.%u\",\n\t\t\t\t\t relationpath, segcount);\n\n\t\tif (stat(pathname, &fst) < 0)\n\t\t{\n\t\t\tif (errno == ENOENT)\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not stat file \\\"%s\\\": %m\", pathname)));\n\t\t}\n\t\ttotalsize += fst.st_size;\n\t}\n\n\treturn totalsize;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/relfilenodemap.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/fd.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/relfilenodemap.h\"\n#include \"utils/rel.h\"\n#include \"utils/numeric.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/fd.h\"\n#include \"miscadmin.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic int64\ncalculate_relation_size(RelFileNode *rfn, BackendId backend, ForkNumber forknum)\n{\n\tint64\t\ttotalsize = 0;\n\tchar\t   *relationpath;\n\tchar\t\tpathname[MAXPGPATH];\n\tunsigned int segcount = 0;\n\n\trelationpath = relpathbackend(*rfn, backend, forknum);\n\n\tfor (segcount = 0;; segcount++)\n\t{\n\t\tstruct stat fst;\n\n\t\tCHECK_FOR_INTERRUPTS();\n\n\t\tif (segcount == 0)\n\t\t\tsnprintf(pathname, MAXPGPATH, \"%s\",\n\t\t\t\t\t relationpath);\n\t\telse\n\t\t\tsnprintf(pathname, MAXPGPATH, \"%s.%u\",\n\t\t\t\t\t relationpath, segcount);\n\n\t\tif (stat(pathname, &fst) < 0)\n\t\t{\n\t\t\tif (errno == ENOENT)\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not stat file \\\"%s\\\": %m\", pathname)));\n\t\t}\n\t\ttotalsize += fst.st_size;\n\t}\n\n\treturn totalsize;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/relfilenodemap.h\"\n#include \"utils/rel.h\"\n#include \"utils/numeric.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/fd.h\"\n#include \"miscadmin.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic int64\ncalculate_table_size(Relation rel)\n{\n\tint64\t\tsize = 0;\n\tForkNumber\tforkNum;\n\n\t/*\n\t * heap size, including FSM and VM\n\t */\n\tfor (forkNum = 0; forkNum <= MAX_FORKNUM; forkNum++)\n\t\tsize += calculate_relation_size(&(rel->rd_node), rel->rd_backend,\n\t\t\t\t\t\t\t\t\t\tforkNum);\n\n\t/*\n\t * Size of toast relation\n\t */\n\tif (OidIsValid(rel->rd_rel->reltoastrelid))\n\t\tsize += calculate_toast_table_size(rel->rd_rel->reltoastrelid);\n\n\treturn size;\n}"
  },
  {
    "function_name": "calculate_toast_table_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/dbsize.c",
    "lines": "342-378",
    "snippet": "static int64\ncalculate_toast_table_size(Oid toastrelid)\n{\n\tint64\t\tsize = 0;\n\tRelation\ttoastRel;\n\tForkNumber\tforkNum;\n\tListCell   *lc;\n\tList\t   *indexlist;\n\n\ttoastRel = relation_open(toastrelid, AccessShareLock);\n\n\t/* toast heap size, including FSM and VM size */\n\tfor (forkNum = 0; forkNum <= MAX_FORKNUM; forkNum++)\n\t\tsize += calculate_relation_size(&(toastRel->rd_node),\n\t\t\t\t\t\t\t\t\t\ttoastRel->rd_backend, forkNum);\n\n\t/* toast index size, including FSM and VM size */\n\tindexlist = RelationGetIndexList(toastRel);\n\n\t/* Size is calculated using all the indexes available */\n\tforeach(lc, indexlist)\n\t{\n\t\tRelation\ttoastIdxRel;\n\n\t\ttoastIdxRel = relation_open(lfirst_oid(lc),\n\t\t\t\t\t\t\t\t\tAccessShareLock);\n\t\tfor (forkNum = 0; forkNum <= MAX_FORKNUM; forkNum++)\n\t\t\tsize += calculate_relation_size(&(toastIdxRel->rd_node),\n\t\t\t\t\t\t\t\t\t\t\ttoastIdxRel->rd_backend, forkNum);\n\n\t\trelation_close(toastIdxRel, AccessShareLock);\n\t}\n\tlist_free(indexlist);\n\trelation_close(toastRel, AccessShareLock);\n\n\treturn size;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/relfilenodemap.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/fd.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "relation_close",
          "args": [
            "toastRel",
            "AccessShareLock"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_free",
          "args": [
            "indexlist"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relation_close",
          "args": [
            "toastIdxRel",
            "AccessShareLock"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calculate_relation_size",
          "args": [
            "&(toastIdxRel->rd_node)",
            "toastIdxRel->rd_backend",
            "forkNum"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "calculate_relation_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/dbsize.c",
          "lines": "272-308",
          "snippet": "static int64\ncalculate_relation_size(RelFileNode *rfn, BackendId backend, ForkNumber forknum)\n{\n\tint64\t\ttotalsize = 0;\n\tchar\t   *relationpath;\n\tchar\t\tpathname[MAXPGPATH];\n\tunsigned int segcount = 0;\n\n\trelationpath = relpathbackend(*rfn, backend, forknum);\n\n\tfor (segcount = 0;; segcount++)\n\t{\n\t\tstruct stat fst;\n\n\t\tCHECK_FOR_INTERRUPTS();\n\n\t\tif (segcount == 0)\n\t\t\tsnprintf(pathname, MAXPGPATH, \"%s\",\n\t\t\t\t\t relationpath);\n\t\telse\n\t\t\tsnprintf(pathname, MAXPGPATH, \"%s.%u\",\n\t\t\t\t\t relationpath, segcount);\n\n\t\tif (stat(pathname, &fst) < 0)\n\t\t{\n\t\t\tif (errno == ENOENT)\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not stat file \\\"%s\\\": %m\", pathname)));\n\t\t}\n\t\ttotalsize += fst.st_size;\n\t}\n\n\treturn totalsize;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/relfilenodemap.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/fd.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/relfilenodemap.h\"\n#include \"utils/rel.h\"\n#include \"utils/numeric.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/fd.h\"\n#include \"miscadmin.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic int64\ncalculate_relation_size(RelFileNode *rfn, BackendId backend, ForkNumber forknum)\n{\n\tint64\t\ttotalsize = 0;\n\tchar\t   *relationpath;\n\tchar\t\tpathname[MAXPGPATH];\n\tunsigned int segcount = 0;\n\n\trelationpath = relpathbackend(*rfn, backend, forknum);\n\n\tfor (segcount = 0;; segcount++)\n\t{\n\t\tstruct stat fst;\n\n\t\tCHECK_FOR_INTERRUPTS();\n\n\t\tif (segcount == 0)\n\t\t\tsnprintf(pathname, MAXPGPATH, \"%s\",\n\t\t\t\t\t relationpath);\n\t\telse\n\t\t\tsnprintf(pathname, MAXPGPATH, \"%s.%u\",\n\t\t\t\t\t relationpath, segcount);\n\n\t\tif (stat(pathname, &fst) < 0)\n\t\t{\n\t\t\tif (errno == ENOENT)\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not stat file \\\"%s\\\": %m\", pathname)));\n\t\t}\n\t\ttotalsize += fst.st_size;\n\t}\n\n\treturn totalsize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "relation_open",
          "args": [
            "lfirst_oid(lc)",
            "AccessShareLock"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst_oid",
          "args": [
            "lc"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "lc",
            "indexlist"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetIndexList",
          "args": [
            "toastRel"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "RelationGetIndexList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "4242-4359",
          "snippet": "List *\nRelationGetIndexList(Relation relation)\n{\n\tRelation\tindrel;\n\tSysScanDesc indscan;\n\tScanKeyData skey;\n\tHeapTuple\thtup;\n\tList\t   *result;\n\tList\t   *oldlist;\n\tchar\t\treplident = relation->rd_rel->relreplident;\n\tOid\t\t\toidIndex = InvalidOid;\n\tOid\t\t\tpkeyIndex = InvalidOid;\n\tOid\t\t\tcandidateIndex = InvalidOid;\n\tMemoryContext oldcxt;\n\n\t/* Quick exit if we already computed the list. */\n\tif (relation->rd_indexvalid != 0)\n\t\treturn list_copy(relation->rd_indexlist);\n\n\t/*\n\t * We build the list we intend to return (in the caller's context) while\n\t * doing the scan.  After successfully completing the scan, we copy that\n\t * list into the relcache entry.  This avoids cache-context memory leakage\n\t * if we get some sort of error partway through.\n\t */\n\tresult = NIL;\n\toidIndex = InvalidOid;\n\n\t/* Prepare to scan pg_index for entries having indrelid = this rel. */\n\tScanKeyInit(&skey,\n\t\t\t\tAnum_pg_index_indrelid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(RelationGetRelid(relation)));\n\n\tindrel = heap_open(IndexRelationId, AccessShareLock);\n\tindscan = systable_beginscan(indrel, IndexIndrelidIndexId, true,\n\t\t\t\t\t\t\t\t NULL, 1, &skey);\n\n\twhile (HeapTupleIsValid(htup = systable_getnext(indscan)))\n\t{\n\t\tForm_pg_index index = (Form_pg_index) GETSTRUCT(htup);\n\t\tDatum\t\tindclassDatum;\n\t\toidvector  *indclass;\n\t\tbool\t\tisnull;\n\n\t\t/*\n\t\t * Ignore any indexes that are currently being dropped.  This will\n\t\t * prevent them from being searched, inserted into, or considered in\n\t\t * HOT-safety decisions.  It's unsafe to touch such an index at all\n\t\t * since its catalog entries could disappear at any instant.\n\t\t */\n\t\tif (!IndexIsLive(index))\n\t\t\tcontinue;\n\n\t\t/* Add index's OID to result list in the proper order */\n\t\tresult = insert_ordered_oid(result, index->indexrelid);\n\n\t\t/*\n\t\t * indclass cannot be referenced directly through the C struct,\n\t\t * because it comes after the variable-width indkey field.  Must\n\t\t * extract the datum the hard way...\n\t\t */\n\t\tindclassDatum = heap_getattr(htup,\n\t\t\t\t\t\t\t\t\t Anum_pg_index_indclass,\n\t\t\t\t\t\t\t\t\t GetPgIndexDescriptor(),\n\t\t\t\t\t\t\t\t\t &isnull);\n\t\tAssert(!isnull);\n\t\tindclass = (oidvector *) DatumGetPointer(indclassDatum);\n\n\t\t/*\n\t\t * Invalid, non-unique, non-immediate or predicate indexes aren't\n\t\t * interesting for either oid indexes or replication identity indexes,\n\t\t * so don't check them.\n\t\t */\n\t\tif (!IndexIsValid(index) || !index->indisunique ||\n\t\t\t!index->indimmediate ||\n\t\t\t!heap_attisnull(htup, Anum_pg_index_indpred, NULL))\n\t\t\tcontinue;\n\n\t\t/* Check to see if is a usable btree index on OID */\n\t\tif (index->indnatts == 1 &&\n\t\t\tindex->indkey.values[0] == ObjectIdAttributeNumber &&\n\t\t\tindclass->values[0] == OID_BTREE_OPS_OID)\n\t\t\toidIndex = index->indexrelid;\n\n\t\t/* remember primary key index if any */\n\t\tif (index->indisprimary)\n\t\t\tpkeyIndex = index->indexrelid;\n\n\t\t/* remember explicitly chosen replica index */\n\t\tif (index->indisreplident)\n\t\t\tcandidateIndex = index->indexrelid;\n\t}\n\n\tsystable_endscan(indscan);\n\n\theap_close(indrel, AccessShareLock);\n\n\t/* Now save a copy of the completed list in the relcache entry. */\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\toldlist = relation->rd_indexlist;\n\trelation->rd_indexlist = list_copy(result);\n\trelation->rd_oidindex = oidIndex;\n\trelation->rd_pkindex = pkeyIndex;\n\tif (replident == REPLICA_IDENTITY_DEFAULT && OidIsValid(pkeyIndex))\n\t\trelation->rd_replidindex = pkeyIndex;\n\telse if (replident == REPLICA_IDENTITY_INDEX && OidIsValid(candidateIndex))\n\t\trelation->rd_replidindex = candidateIndex;\n\telse\n\t\trelation->rd_replidindex = InvalidOid;\n\trelation->rd_indexvalid = 1;\n\tMemoryContextSwitchTo(oldcxt);\n\n\t/* Don't leak the old list, if there is one */\n\tlist_free(oldlist);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void RelationReloadIndexInfo(Relation relation);",
            "static void RelationReloadNailed(Relation relation);",
            "static void RelationFlushRelation(Relation relation);",
            "static void RelationBuildTupleDesc(Relation relation);",
            "static void RelationInitPhysicalAddr(Relation relation);",
            "static TupleDesc GetPgIndexDescriptor(void);",
            "static void AttrDefaultFetch(Relation relation);",
            "static void CheckConstraintFetch(Relation relation);",
            "static List *insert_ordered_oid(List *list, Oid datum);",
            "static void InitIndexAmRoutine(Relation relation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic TupleDesc GetPgIndexDescriptor(void);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic List *insert_ordered_oid(List *list, Oid datum);\nstatic void InitIndexAmRoutine(Relation relation);\n\nList *\nRelationGetIndexList(Relation relation)\n{\n\tRelation\tindrel;\n\tSysScanDesc indscan;\n\tScanKeyData skey;\n\tHeapTuple\thtup;\n\tList\t   *result;\n\tList\t   *oldlist;\n\tchar\t\treplident = relation->rd_rel->relreplident;\n\tOid\t\t\toidIndex = InvalidOid;\n\tOid\t\t\tpkeyIndex = InvalidOid;\n\tOid\t\t\tcandidateIndex = InvalidOid;\n\tMemoryContext oldcxt;\n\n\t/* Quick exit if we already computed the list. */\n\tif (relation->rd_indexvalid != 0)\n\t\treturn list_copy(relation->rd_indexlist);\n\n\t/*\n\t * We build the list we intend to return (in the caller's context) while\n\t * doing the scan.  After successfully completing the scan, we copy that\n\t * list into the relcache entry.  This avoids cache-context memory leakage\n\t * if we get some sort of error partway through.\n\t */\n\tresult = NIL;\n\toidIndex = InvalidOid;\n\n\t/* Prepare to scan pg_index for entries having indrelid = this rel. */\n\tScanKeyInit(&skey,\n\t\t\t\tAnum_pg_index_indrelid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(RelationGetRelid(relation)));\n\n\tindrel = heap_open(IndexRelationId, AccessShareLock);\n\tindscan = systable_beginscan(indrel, IndexIndrelidIndexId, true,\n\t\t\t\t\t\t\t\t NULL, 1, &skey);\n\n\twhile (HeapTupleIsValid(htup = systable_getnext(indscan)))\n\t{\n\t\tForm_pg_index index = (Form_pg_index) GETSTRUCT(htup);\n\t\tDatum\t\tindclassDatum;\n\t\toidvector  *indclass;\n\t\tbool\t\tisnull;\n\n\t\t/*\n\t\t * Ignore any indexes that are currently being dropped.  This will\n\t\t * prevent them from being searched, inserted into, or considered in\n\t\t * HOT-safety decisions.  It's unsafe to touch such an index at all\n\t\t * since its catalog entries could disappear at any instant.\n\t\t */\n\t\tif (!IndexIsLive(index))\n\t\t\tcontinue;\n\n\t\t/* Add index's OID to result list in the proper order */\n\t\tresult = insert_ordered_oid(result, index->indexrelid);\n\n\t\t/*\n\t\t * indclass cannot be referenced directly through the C struct,\n\t\t * because it comes after the variable-width indkey field.  Must\n\t\t * extract the datum the hard way...\n\t\t */\n\t\tindclassDatum = heap_getattr(htup,\n\t\t\t\t\t\t\t\t\t Anum_pg_index_indclass,\n\t\t\t\t\t\t\t\t\t GetPgIndexDescriptor(),\n\t\t\t\t\t\t\t\t\t &isnull);\n\t\tAssert(!isnull);\n\t\tindclass = (oidvector *) DatumGetPointer(indclassDatum);\n\n\t\t/*\n\t\t * Invalid, non-unique, non-immediate or predicate indexes aren't\n\t\t * interesting for either oid indexes or replication identity indexes,\n\t\t * so don't check them.\n\t\t */\n\t\tif (!IndexIsValid(index) || !index->indisunique ||\n\t\t\t!index->indimmediate ||\n\t\t\t!heap_attisnull(htup, Anum_pg_index_indpred, NULL))\n\t\t\tcontinue;\n\n\t\t/* Check to see if is a usable btree index on OID */\n\t\tif (index->indnatts == 1 &&\n\t\t\tindex->indkey.values[0] == ObjectIdAttributeNumber &&\n\t\t\tindclass->values[0] == OID_BTREE_OPS_OID)\n\t\t\toidIndex = index->indexrelid;\n\n\t\t/* remember primary key index if any */\n\t\tif (index->indisprimary)\n\t\t\tpkeyIndex = index->indexrelid;\n\n\t\t/* remember explicitly chosen replica index */\n\t\tif (index->indisreplident)\n\t\t\tcandidateIndex = index->indexrelid;\n\t}\n\n\tsystable_endscan(indscan);\n\n\theap_close(indrel, AccessShareLock);\n\n\t/* Now save a copy of the completed list in the relcache entry. */\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\toldlist = relation->rd_indexlist;\n\trelation->rd_indexlist = list_copy(result);\n\trelation->rd_oidindex = oidIndex;\n\trelation->rd_pkindex = pkeyIndex;\n\tif (replident == REPLICA_IDENTITY_DEFAULT && OidIsValid(pkeyIndex))\n\t\trelation->rd_replidindex = pkeyIndex;\n\telse if (replident == REPLICA_IDENTITY_INDEX && OidIsValid(candidateIndex))\n\t\trelation->rd_replidindex = candidateIndex;\n\telse\n\t\trelation->rd_replidindex = InvalidOid;\n\trelation->rd_indexvalid = 1;\n\tMemoryContextSwitchTo(oldcxt);\n\n\t/* Don't leak the old list, if there is one */\n\tlist_free(oldlist);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "relation_open",
          "args": [
            "toastrelid",
            "AccessShareLock"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/relfilenodemap.h\"\n#include \"utils/rel.h\"\n#include \"utils/numeric.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/fd.h\"\n#include \"miscadmin.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic int64\ncalculate_toast_table_size(Oid toastrelid)\n{\n\tint64\t\tsize = 0;\n\tRelation\ttoastRel;\n\tForkNumber\tforkNum;\n\tListCell   *lc;\n\tList\t   *indexlist;\n\n\ttoastRel = relation_open(toastrelid, AccessShareLock);\n\n\t/* toast heap size, including FSM and VM size */\n\tfor (forkNum = 0; forkNum <= MAX_FORKNUM; forkNum++)\n\t\tsize += calculate_relation_size(&(toastRel->rd_node),\n\t\t\t\t\t\t\t\t\t\ttoastRel->rd_backend, forkNum);\n\n\t/* toast index size, including FSM and VM size */\n\tindexlist = RelationGetIndexList(toastRel);\n\n\t/* Size is calculated using all the indexes available */\n\tforeach(lc, indexlist)\n\t{\n\t\tRelation\ttoastIdxRel;\n\n\t\ttoastIdxRel = relation_open(lfirst_oid(lc),\n\t\t\t\t\t\t\t\t\tAccessShareLock);\n\t\tfor (forkNum = 0; forkNum <= MAX_FORKNUM; forkNum++)\n\t\t\tsize += calculate_relation_size(&(toastIdxRel->rd_node),\n\t\t\t\t\t\t\t\t\t\t\ttoastIdxRel->rd_backend, forkNum);\n\n\t\trelation_close(toastIdxRel, AccessShareLock);\n\t}\n\tlist_free(indexlist);\n\trelation_close(toastRel, AccessShareLock);\n\n\treturn size;\n}"
  },
  {
    "function_name": "pg_relation_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/dbsize.c",
    "lines": "310-336",
    "snippet": "Datum\npg_relation_size(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\trelOid = PG_GETARG_OID(0);\n\ttext\t   *forkName = PG_GETARG_TEXT_PP(1);\n\tRelation\trel;\n\tint64\t\tsize;\n\n\trel = try_relation_open(relOid, AccessShareLock);\n\n\t/*\n\t * Before 9.2, we used to throw an error if the relation didn't exist, but\n\t * that makes queries like \"SELECT pg_relation_size(oid) FROM pg_class\"\n\t * less robust, because while we scan pg_class with an MVCC snapshot,\n\t * someone else might drop the table. It's better to return NULL for\n\t * already-dropped tables than throw an error and abort the whole query.\n\t */\n\tif (rel == NULL)\n\t\tPG_RETURN_NULL();\n\n\tsize = calculate_relation_size(&(rel->rd_node), rel->rd_backend,\n\t\t\t\t\t\t\t\t   forkname_to_number(text_to_cstring(forkName)));\n\n\trelation_close(rel, AccessShareLock);\n\n\tPG_RETURN_INT64(size);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/relfilenodemap.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/fd.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT64",
          "args": [
            "size"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relation_close",
          "args": [
            "rel",
            "AccessShareLock"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calculate_relation_size",
          "args": [
            "&(rel->rd_node)",
            "rel->rd_backend",
            "forkname_to_number(text_to_cstring(forkName))"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "calculate_relation_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/dbsize.c",
          "lines": "272-308",
          "snippet": "static int64\ncalculate_relation_size(RelFileNode *rfn, BackendId backend, ForkNumber forknum)\n{\n\tint64\t\ttotalsize = 0;\n\tchar\t   *relationpath;\n\tchar\t\tpathname[MAXPGPATH];\n\tunsigned int segcount = 0;\n\n\trelationpath = relpathbackend(*rfn, backend, forknum);\n\n\tfor (segcount = 0;; segcount++)\n\t{\n\t\tstruct stat fst;\n\n\t\tCHECK_FOR_INTERRUPTS();\n\n\t\tif (segcount == 0)\n\t\t\tsnprintf(pathname, MAXPGPATH, \"%s\",\n\t\t\t\t\t relationpath);\n\t\telse\n\t\t\tsnprintf(pathname, MAXPGPATH, \"%s.%u\",\n\t\t\t\t\t relationpath, segcount);\n\n\t\tif (stat(pathname, &fst) < 0)\n\t\t{\n\t\t\tif (errno == ENOENT)\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not stat file \\\"%s\\\": %m\", pathname)));\n\t\t}\n\t\ttotalsize += fst.st_size;\n\t}\n\n\treturn totalsize;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/relfilenodemap.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/fd.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/relfilenodemap.h\"\n#include \"utils/rel.h\"\n#include \"utils/numeric.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/fd.h\"\n#include \"miscadmin.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic int64\ncalculate_relation_size(RelFileNode *rfn, BackendId backend, ForkNumber forknum)\n{\n\tint64\t\ttotalsize = 0;\n\tchar\t   *relationpath;\n\tchar\t\tpathname[MAXPGPATH];\n\tunsigned int segcount = 0;\n\n\trelationpath = relpathbackend(*rfn, backend, forknum);\n\n\tfor (segcount = 0;; segcount++)\n\t{\n\t\tstruct stat fst;\n\n\t\tCHECK_FOR_INTERRUPTS();\n\n\t\tif (segcount == 0)\n\t\t\tsnprintf(pathname, MAXPGPATH, \"%s\",\n\t\t\t\t\t relationpath);\n\t\telse\n\t\t\tsnprintf(pathname, MAXPGPATH, \"%s.%u\",\n\t\t\t\t\t relationpath, segcount);\n\n\t\tif (stat(pathname, &fst) < 0)\n\t\t{\n\t\t\tif (errno == ENOENT)\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not stat file \\\"%s\\\": %m\", pathname)));\n\t\t}\n\t\ttotalsize += fst.st_size;\n\t}\n\n\treturn totalsize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "forkname_to_number",
          "args": [
            "text_to_cstring(forkName)"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text_to_cstring",
          "args": [
            "forkName"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "text_to_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "181-197",
          "snippet": "char *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nchar *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_relation_open",
          "args": [
            "relOid",
            "AccessShareLock"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "0"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/relfilenodemap.h\"\n#include \"utils/rel.h\"\n#include \"utils/numeric.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/fd.h\"\n#include \"miscadmin.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nDatum\npg_relation_size(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\trelOid = PG_GETARG_OID(0);\n\ttext\t   *forkName = PG_GETARG_TEXT_PP(1);\n\tRelation\trel;\n\tint64\t\tsize;\n\n\trel = try_relation_open(relOid, AccessShareLock);\n\n\t/*\n\t * Before 9.2, we used to throw an error if the relation didn't exist, but\n\t * that makes queries like \"SELECT pg_relation_size(oid) FROM pg_class\"\n\t * less robust, because while we scan pg_class with an MVCC snapshot,\n\t * someone else might drop the table. It's better to return NULL for\n\t * already-dropped tables than throw an error and abort the whole query.\n\t */\n\tif (rel == NULL)\n\t\tPG_RETURN_NULL();\n\n\tsize = calculate_relation_size(&(rel->rd_node), rel->rd_backend,\n\t\t\t\t\t\t\t\t   forkname_to_number(text_to_cstring(forkName)));\n\n\trelation_close(rel, AccessShareLock);\n\n\tPG_RETURN_INT64(size);\n}"
  },
  {
    "function_name": "calculate_relation_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/dbsize.c",
    "lines": "272-308",
    "snippet": "static int64\ncalculate_relation_size(RelFileNode *rfn, BackendId backend, ForkNumber forknum)\n{\n\tint64\t\ttotalsize = 0;\n\tchar\t   *relationpath;\n\tchar\t\tpathname[MAXPGPATH];\n\tunsigned int segcount = 0;\n\n\trelationpath = relpathbackend(*rfn, backend, forknum);\n\n\tfor (segcount = 0;; segcount++)\n\t{\n\t\tstruct stat fst;\n\n\t\tCHECK_FOR_INTERRUPTS();\n\n\t\tif (segcount == 0)\n\t\t\tsnprintf(pathname, MAXPGPATH, \"%s\",\n\t\t\t\t\t relationpath);\n\t\telse\n\t\t\tsnprintf(pathname, MAXPGPATH, \"%s.%u\",\n\t\t\t\t\t relationpath, segcount);\n\n\t\tif (stat(pathname, &fst) < 0)\n\t\t{\n\t\t\tif (errno == ENOENT)\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not stat file \\\"%s\\\": %m\", pathname)));\n\t\t}\n\t\ttotalsize += fst.st_size;\n\t}\n\n\treturn totalsize;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/relfilenodemap.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/fd.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not stat file \\\"%s\\\": %m\", pathname))"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not stat file \\\"%s\\\": %m\"",
            "pathname"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode_for_file_access",
          "args": [],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "errcode_for_file_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "595-655",
          "snippet": "int\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "pathname",
            "&fst"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "set_deparse_planstate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ruleutils.c",
          "lines": "4578-4639",
          "snippet": "static void\nset_deparse_planstate(deparse_namespace *dpns, PlanState *ps)\n{\n\tdpns->planstate = ps;\n\n\t/*\n\t * We special-case Append and MergeAppend to pretend that the first child\n\t * plan is the OUTER referent; we have to interpret OUTER Vars in their\n\t * tlists according to one of the children, and the first one is the most\n\t * natural choice.  Likewise special-case ModifyTable to pretend that the\n\t * first child plan is the OUTER referent; this is to support RETURNING\n\t * lists containing references to non-target relations.\n\t */\n\tif (IsA(ps, AppendState))\n\t\tdpns->outer_planstate = ((AppendState *) ps)->appendplans[0];\n\telse if (IsA(ps, MergeAppendState))\n\t\tdpns->outer_planstate = ((MergeAppendState *) ps)->mergeplans[0];\n\telse if (IsA(ps, ModifyTableState))\n\t\tdpns->outer_planstate = ((ModifyTableState *) ps)->mt_plans[0];\n\telse\n\t\tdpns->outer_planstate = outerPlanState(ps);\n\n\tif (dpns->outer_planstate)\n\t\tdpns->outer_tlist = dpns->outer_planstate->plan->targetlist;\n\telse\n\t\tdpns->outer_tlist = NIL;\n\n\t/*\n\t * For a SubqueryScan, pretend the subplan is INNER referent.  (We don't\n\t * use OUTER because that could someday conflict with the normal meaning.)\n\t * Likewise, for a CteScan, pretend the subquery's plan is INNER referent.\n\t * For ON CONFLICT .. UPDATE we just need the inner tlist to point to the\n\t * excluded expression's tlist. (Similar to the SubqueryScan we don't want\n\t * to reuse OUTER, it's used for RETURNING in some modify table cases,\n\t * although not INSERT .. CONFLICT).\n\t */\n\tif (IsA(ps, SubqueryScanState))\n\t\tdpns->inner_planstate = ((SubqueryScanState *) ps)->subplan;\n\telse if (IsA(ps, CteScanState))\n\t\tdpns->inner_planstate = ((CteScanState *) ps)->cteplanstate;\n\telse if (IsA(ps, ModifyTableState))\n\t\tdpns->inner_planstate = ps;\n\telse\n\t\tdpns->inner_planstate = innerPlanState(ps);\n\n\tif (IsA(ps, ModifyTableState))\n\t\tdpns->inner_tlist = ((ModifyTableState *) ps)->mt_excludedtlist;\n\telse if (dpns->inner_planstate)\n\t\tdpns->inner_tlist = dpns->inner_planstate->plan->targetlist;\n\telse\n\t\tdpns->inner_tlist = NIL;\n\n\t/* Set up referent for INDEX_VAR Vars, if needed */\n\tif (IsA(ps->plan, IndexOnlyScan))\n\t\tdpns->index_tlist = ((IndexOnlyScan *) ps->plan)->indextlist;\n\telse if (IsA(ps->plan, ForeignScan))\n\t\tdpns->index_tlist = ((ForeignScan *) ps->plan)->fdw_scan_tlist;\n\telse if (IsA(ps->plan, CustomScan))\n\t\tdpns->index_tlist = ((CustomScan *) ps->plan)->custom_scan_tlist;\n\telse\n\t\tdpns->index_tlist = NIL;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/ruleutils.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"rewrite/rewriteSupport.h\"",
            "#include \"rewrite/rewriteManip.h\"",
            "#include \"rewrite/rewriteHandler.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parser.h\"",
            "#include \"parser/parse_oper.h\"",
            "#include \"parser/parse_func.h\"",
            "#include \"parser/parse_agg.h\"",
            "#include \"parser/parse_node.h\"",
            "#include \"optimizer/tlist.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"common/keywords.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/dependency.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/amapi.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_simple_column_names(deparse_namespace *dpns);",
            "static void set_deparse_planstate(deparse_namespace *dpns, PlanState *ps);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/ruleutils.h\"\n#include \"utils/rel.h\"\n#include \"utils/partcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"rewrite/rewriteSupport.h\"\n#include \"rewrite/rewriteManip.h\"\n#include \"rewrite/rewriteHandler.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parser.h\"\n#include \"parser/parse_oper.h\"\n#include \"parser/parse_func.h\"\n#include \"parser/parse_agg.h\"\n#include \"parser/parse_node.h\"\n#include \"optimizer/tlist.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"common/keywords.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/dependency.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/amapi.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void set_simple_column_names(deparse_namespace *dpns);\nstatic void set_deparse_planstate(deparse_namespace *dpns, PlanState *ps);\n\nstatic void\nset_deparse_planstate(deparse_namespace *dpns, PlanState *ps)\n{\n\tdpns->planstate = ps;\n\n\t/*\n\t * We special-case Append and MergeAppend to pretend that the first child\n\t * plan is the OUTER referent; we have to interpret OUTER Vars in their\n\t * tlists according to one of the children, and the first one is the most\n\t * natural choice.  Likewise special-case ModifyTable to pretend that the\n\t * first child plan is the OUTER referent; this is to support RETURNING\n\t * lists containing references to non-target relations.\n\t */\n\tif (IsA(ps, AppendState))\n\t\tdpns->outer_planstate = ((AppendState *) ps)->appendplans[0];\n\telse if (IsA(ps, MergeAppendState))\n\t\tdpns->outer_planstate = ((MergeAppendState *) ps)->mergeplans[0];\n\telse if (IsA(ps, ModifyTableState))\n\t\tdpns->outer_planstate = ((ModifyTableState *) ps)->mt_plans[0];\n\telse\n\t\tdpns->outer_planstate = outerPlanState(ps);\n\n\tif (dpns->outer_planstate)\n\t\tdpns->outer_tlist = dpns->outer_planstate->plan->targetlist;\n\telse\n\t\tdpns->outer_tlist = NIL;\n\n\t/*\n\t * For a SubqueryScan, pretend the subplan is INNER referent.  (We don't\n\t * use OUTER because that could someday conflict with the normal meaning.)\n\t * Likewise, for a CteScan, pretend the subquery's plan is INNER referent.\n\t * For ON CONFLICT .. UPDATE we just need the inner tlist to point to the\n\t * excluded expression's tlist. (Similar to the SubqueryScan we don't want\n\t * to reuse OUTER, it's used for RETURNING in some modify table cases,\n\t * although not INSERT .. CONFLICT).\n\t */\n\tif (IsA(ps, SubqueryScanState))\n\t\tdpns->inner_planstate = ((SubqueryScanState *) ps)->subplan;\n\telse if (IsA(ps, CteScanState))\n\t\tdpns->inner_planstate = ((CteScanState *) ps)->cteplanstate;\n\telse if (IsA(ps, ModifyTableState))\n\t\tdpns->inner_planstate = ps;\n\telse\n\t\tdpns->inner_planstate = innerPlanState(ps);\n\n\tif (IsA(ps, ModifyTableState))\n\t\tdpns->inner_tlist = ((ModifyTableState *) ps)->mt_excludedtlist;\n\telse if (dpns->inner_planstate)\n\t\tdpns->inner_tlist = dpns->inner_planstate->plan->targetlist;\n\telse\n\t\tdpns->inner_tlist = NIL;\n\n\t/* Set up referent for INDEX_VAR Vars, if needed */\n\tif (IsA(ps->plan, IndexOnlyScan))\n\t\tdpns->index_tlist = ((IndexOnlyScan *) ps->plan)->indextlist;\n\telse if (IsA(ps->plan, ForeignScan))\n\t\tdpns->index_tlist = ((ForeignScan *) ps->plan)->fdw_scan_tlist;\n\telse if (IsA(ps->plan, CustomScan))\n\t\tdpns->index_tlist = ((CustomScan *) ps->plan)->custom_scan_tlist;\n\telse\n\t\tdpns->index_tlist = NIL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "pathname",
            "MAXPGPATH",
            "\"%s.%u\"",
            "relationpath",
            "segcount"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "pathname",
            "MAXPGPATH",
            "\"%s\"",
            "relationpath"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_FOR_INTERRUPTS",
          "args": [],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relpathbackend",
          "args": [
            "*rfn",
            "backend",
            "forknum"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/relfilenodemap.h\"\n#include \"utils/rel.h\"\n#include \"utils/numeric.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/fd.h\"\n#include \"miscadmin.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic int64\ncalculate_relation_size(RelFileNode *rfn, BackendId backend, ForkNumber forknum)\n{\n\tint64\t\ttotalsize = 0;\n\tchar\t   *relationpath;\n\tchar\t\tpathname[MAXPGPATH];\n\tunsigned int segcount = 0;\n\n\trelationpath = relpathbackend(*rfn, backend, forknum);\n\n\tfor (segcount = 0;; segcount++)\n\t{\n\t\tstruct stat fst;\n\n\t\tCHECK_FOR_INTERRUPTS();\n\n\t\tif (segcount == 0)\n\t\t\tsnprintf(pathname, MAXPGPATH, \"%s\",\n\t\t\t\t\t relationpath);\n\t\telse\n\t\t\tsnprintf(pathname, MAXPGPATH, \"%s.%u\",\n\t\t\t\t\t relationpath, segcount);\n\n\t\tif (stat(pathname, &fst) < 0)\n\t\t{\n\t\t\tif (errno == ENOENT)\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not stat file \\\"%s\\\": %m\", pathname)));\n\t\t}\n\t\ttotalsize += fst.st_size;\n\t}\n\n\treturn totalsize;\n}"
  },
  {
    "function_name": "pg_tablespace_size_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/dbsize.c",
    "lines": "250-263",
    "snippet": "Datum\npg_tablespace_size_name(PG_FUNCTION_ARGS)\n{\n\tName\t\ttblspcName = PG_GETARG_NAME(0);\n\tOid\t\t\ttblspcOid = get_tablespace_oid(NameStr(*tblspcName), false);\n\tint64\t\tsize;\n\n\tsize = calculate_tablespace_size(tblspcOid);\n\n\tif (size < 0)\n\t\tPG_RETURN_NULL();\n\n\tPG_RETURN_INT64(size);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/relfilenodemap.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/fd.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT64",
          "args": [
            "size"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calculate_tablespace_size",
          "args": [
            "tblspcOid"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "calculate_tablespace_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/dbsize.c",
          "lines": "166-234",
          "snippet": "static int64\ncalculate_tablespace_size(Oid tblspcOid)\n{\n\tchar\t\ttblspcPath[MAXPGPATH];\n\tchar\t\tpathname[MAXPGPATH * 2];\n\tint64\t\ttotalsize = 0;\n\tDIR\t\t   *dirdesc;\n\tstruct dirent *direntry;\n\tAclResult\taclresult;\n\n\t/*\n\t * User must be a member of pg_read_all_stats or have CREATE privilege for\n\t * target tablespace, either explicitly granted or implicitly because it\n\t * is default for current database.\n\t */\n\tif (tblspcOid != MyDatabaseTableSpace &&\n\t\t!is_member_of_role(GetUserId(), DEFAULT_ROLE_READ_ALL_STATS))\n\t{\n\t\taclresult = pg_tablespace_aclcheck(tblspcOid, GetUserId(), ACL_CREATE);\n\t\tif (aclresult != ACLCHECK_OK)\n\t\t\taclcheck_error(aclresult, OBJECT_TABLESPACE,\n\t\t\t\t\t\t   get_tablespace_name(tblspcOid));\n\t}\n\n\tif (tblspcOid == DEFAULTTABLESPACE_OID)\n\t\tsnprintf(tblspcPath, MAXPGPATH, \"base\");\n\telse if (tblspcOid == GLOBALTABLESPACE_OID)\n\t\tsnprintf(tblspcPath, MAXPGPATH, \"global\");\n\telse\n\t\tsnprintf(tblspcPath, MAXPGPATH, \"pg_tblspc/%u/%s\", tblspcOid,\n\t\t\t\t TABLESPACE_VERSION_DIRECTORY);\n\n\tdirdesc = AllocateDir(tblspcPath);\n\n\tif (!dirdesc)\n\t\treturn -1;\n\n\twhile ((direntry = ReadDir(dirdesc, tblspcPath)) != NULL)\n\t{\n\t\tstruct stat fst;\n\n\t\tCHECK_FOR_INTERRUPTS();\n\n\t\tif (strcmp(direntry->d_name, \".\") == 0 ||\n\t\t\tstrcmp(direntry->d_name, \"..\") == 0)\n\t\t\tcontinue;\n\n\t\tsnprintf(pathname, sizeof(pathname), \"%s/%s\", tblspcPath, direntry->d_name);\n\n\t\tif (stat(pathname, &fst) < 0)\n\t\t{\n\t\t\tif (errno == ENOENT)\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not stat file \\\"%s\\\": %m\", pathname)));\n\t\t}\n\n\t\tif (S_ISDIR(fst.st_mode))\n\t\t\ttotalsize += db_dir_size(pathname);\n\n\t\ttotalsize += fst.st_size;\n\t}\n\n\tFreeDir(dirdesc);\n\n\treturn totalsize;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/relfilenodemap.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/fd.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/relfilenodemap.h\"\n#include \"utils/rel.h\"\n#include \"utils/numeric.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/fd.h\"\n#include \"miscadmin.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic int64\ncalculate_tablespace_size(Oid tblspcOid)\n{\n\tchar\t\ttblspcPath[MAXPGPATH];\n\tchar\t\tpathname[MAXPGPATH * 2];\n\tint64\t\ttotalsize = 0;\n\tDIR\t\t   *dirdesc;\n\tstruct dirent *direntry;\n\tAclResult\taclresult;\n\n\t/*\n\t * User must be a member of pg_read_all_stats or have CREATE privilege for\n\t * target tablespace, either explicitly granted or implicitly because it\n\t * is default for current database.\n\t */\n\tif (tblspcOid != MyDatabaseTableSpace &&\n\t\t!is_member_of_role(GetUserId(), DEFAULT_ROLE_READ_ALL_STATS))\n\t{\n\t\taclresult = pg_tablespace_aclcheck(tblspcOid, GetUserId(), ACL_CREATE);\n\t\tif (aclresult != ACLCHECK_OK)\n\t\t\taclcheck_error(aclresult, OBJECT_TABLESPACE,\n\t\t\t\t\t\t   get_tablespace_name(tblspcOid));\n\t}\n\n\tif (tblspcOid == DEFAULTTABLESPACE_OID)\n\t\tsnprintf(tblspcPath, MAXPGPATH, \"base\");\n\telse if (tblspcOid == GLOBALTABLESPACE_OID)\n\t\tsnprintf(tblspcPath, MAXPGPATH, \"global\");\n\telse\n\t\tsnprintf(tblspcPath, MAXPGPATH, \"pg_tblspc/%u/%s\", tblspcOid,\n\t\t\t\t TABLESPACE_VERSION_DIRECTORY);\n\n\tdirdesc = AllocateDir(tblspcPath);\n\n\tif (!dirdesc)\n\t\treturn -1;\n\n\twhile ((direntry = ReadDir(dirdesc, tblspcPath)) != NULL)\n\t{\n\t\tstruct stat fst;\n\n\t\tCHECK_FOR_INTERRUPTS();\n\n\t\tif (strcmp(direntry->d_name, \".\") == 0 ||\n\t\t\tstrcmp(direntry->d_name, \"..\") == 0)\n\t\t\tcontinue;\n\n\t\tsnprintf(pathname, sizeof(pathname), \"%s/%s\", tblspcPath, direntry->d_name);\n\n\t\tif (stat(pathname, &fst) < 0)\n\t\t{\n\t\t\tif (errno == ENOENT)\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not stat file \\\"%s\\\": %m\", pathname)));\n\t\t}\n\n\t\tif (S_ISDIR(fst.st_mode))\n\t\t\ttotalsize += db_dir_size(pathname);\n\n\t\ttotalsize += fst.st_size;\n\t}\n\n\tFreeDir(dirdesc);\n\n\treturn totalsize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_tablespace_oid",
          "args": [
            "NameStr(*tblspcName)",
            "false"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "*tblspcName"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_NAME",
          "args": [
            "0"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/relfilenodemap.h\"\n#include \"utils/rel.h\"\n#include \"utils/numeric.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/fd.h\"\n#include \"miscadmin.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nDatum\npg_tablespace_size_name(PG_FUNCTION_ARGS)\n{\n\tName\t\ttblspcName = PG_GETARG_NAME(0);\n\tOid\t\t\ttblspcOid = get_tablespace_oid(NameStr(*tblspcName), false);\n\tint64\t\tsize;\n\n\tsize = calculate_tablespace_size(tblspcOid);\n\n\tif (size < 0)\n\t\tPG_RETURN_NULL();\n\n\tPG_RETURN_INT64(size);\n}"
  },
  {
    "function_name": "pg_tablespace_size_oid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/dbsize.c",
    "lines": "236-248",
    "snippet": "Datum\npg_tablespace_size_oid(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\ttblspcOid = PG_GETARG_OID(0);\n\tint64\t\tsize;\n\n\tsize = calculate_tablespace_size(tblspcOid);\n\n\tif (size < 0)\n\t\tPG_RETURN_NULL();\n\n\tPG_RETURN_INT64(size);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/relfilenodemap.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/fd.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT64",
          "args": [
            "size"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calculate_tablespace_size",
          "args": [
            "tblspcOid"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "calculate_tablespace_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/dbsize.c",
          "lines": "166-234",
          "snippet": "static int64\ncalculate_tablespace_size(Oid tblspcOid)\n{\n\tchar\t\ttblspcPath[MAXPGPATH];\n\tchar\t\tpathname[MAXPGPATH * 2];\n\tint64\t\ttotalsize = 0;\n\tDIR\t\t   *dirdesc;\n\tstruct dirent *direntry;\n\tAclResult\taclresult;\n\n\t/*\n\t * User must be a member of pg_read_all_stats or have CREATE privilege for\n\t * target tablespace, either explicitly granted or implicitly because it\n\t * is default for current database.\n\t */\n\tif (tblspcOid != MyDatabaseTableSpace &&\n\t\t!is_member_of_role(GetUserId(), DEFAULT_ROLE_READ_ALL_STATS))\n\t{\n\t\taclresult = pg_tablespace_aclcheck(tblspcOid, GetUserId(), ACL_CREATE);\n\t\tif (aclresult != ACLCHECK_OK)\n\t\t\taclcheck_error(aclresult, OBJECT_TABLESPACE,\n\t\t\t\t\t\t   get_tablespace_name(tblspcOid));\n\t}\n\n\tif (tblspcOid == DEFAULTTABLESPACE_OID)\n\t\tsnprintf(tblspcPath, MAXPGPATH, \"base\");\n\telse if (tblspcOid == GLOBALTABLESPACE_OID)\n\t\tsnprintf(tblspcPath, MAXPGPATH, \"global\");\n\telse\n\t\tsnprintf(tblspcPath, MAXPGPATH, \"pg_tblspc/%u/%s\", tblspcOid,\n\t\t\t\t TABLESPACE_VERSION_DIRECTORY);\n\n\tdirdesc = AllocateDir(tblspcPath);\n\n\tif (!dirdesc)\n\t\treturn -1;\n\n\twhile ((direntry = ReadDir(dirdesc, tblspcPath)) != NULL)\n\t{\n\t\tstruct stat fst;\n\n\t\tCHECK_FOR_INTERRUPTS();\n\n\t\tif (strcmp(direntry->d_name, \".\") == 0 ||\n\t\t\tstrcmp(direntry->d_name, \"..\") == 0)\n\t\t\tcontinue;\n\n\t\tsnprintf(pathname, sizeof(pathname), \"%s/%s\", tblspcPath, direntry->d_name);\n\n\t\tif (stat(pathname, &fst) < 0)\n\t\t{\n\t\t\tif (errno == ENOENT)\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not stat file \\\"%s\\\": %m\", pathname)));\n\t\t}\n\n\t\tif (S_ISDIR(fst.st_mode))\n\t\t\ttotalsize += db_dir_size(pathname);\n\n\t\ttotalsize += fst.st_size;\n\t}\n\n\tFreeDir(dirdesc);\n\n\treturn totalsize;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/relfilenodemap.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/fd.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/relfilenodemap.h\"\n#include \"utils/rel.h\"\n#include \"utils/numeric.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/fd.h\"\n#include \"miscadmin.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic int64\ncalculate_tablespace_size(Oid tblspcOid)\n{\n\tchar\t\ttblspcPath[MAXPGPATH];\n\tchar\t\tpathname[MAXPGPATH * 2];\n\tint64\t\ttotalsize = 0;\n\tDIR\t\t   *dirdesc;\n\tstruct dirent *direntry;\n\tAclResult\taclresult;\n\n\t/*\n\t * User must be a member of pg_read_all_stats or have CREATE privilege for\n\t * target tablespace, either explicitly granted or implicitly because it\n\t * is default for current database.\n\t */\n\tif (tblspcOid != MyDatabaseTableSpace &&\n\t\t!is_member_of_role(GetUserId(), DEFAULT_ROLE_READ_ALL_STATS))\n\t{\n\t\taclresult = pg_tablespace_aclcheck(tblspcOid, GetUserId(), ACL_CREATE);\n\t\tif (aclresult != ACLCHECK_OK)\n\t\t\taclcheck_error(aclresult, OBJECT_TABLESPACE,\n\t\t\t\t\t\t   get_tablespace_name(tblspcOid));\n\t}\n\n\tif (tblspcOid == DEFAULTTABLESPACE_OID)\n\t\tsnprintf(tblspcPath, MAXPGPATH, \"base\");\n\telse if (tblspcOid == GLOBALTABLESPACE_OID)\n\t\tsnprintf(tblspcPath, MAXPGPATH, \"global\");\n\telse\n\t\tsnprintf(tblspcPath, MAXPGPATH, \"pg_tblspc/%u/%s\", tblspcOid,\n\t\t\t\t TABLESPACE_VERSION_DIRECTORY);\n\n\tdirdesc = AllocateDir(tblspcPath);\n\n\tif (!dirdesc)\n\t\treturn -1;\n\n\twhile ((direntry = ReadDir(dirdesc, tblspcPath)) != NULL)\n\t{\n\t\tstruct stat fst;\n\n\t\tCHECK_FOR_INTERRUPTS();\n\n\t\tif (strcmp(direntry->d_name, \".\") == 0 ||\n\t\t\tstrcmp(direntry->d_name, \"..\") == 0)\n\t\t\tcontinue;\n\n\t\tsnprintf(pathname, sizeof(pathname), \"%s/%s\", tblspcPath, direntry->d_name);\n\n\t\tif (stat(pathname, &fst) < 0)\n\t\t{\n\t\t\tif (errno == ENOENT)\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not stat file \\\"%s\\\": %m\", pathname)));\n\t\t}\n\n\t\tif (S_ISDIR(fst.st_mode))\n\t\t\ttotalsize += db_dir_size(pathname);\n\n\t\ttotalsize += fst.st_size;\n\t}\n\n\tFreeDir(dirdesc);\n\n\treturn totalsize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "0"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/relfilenodemap.h\"\n#include \"utils/rel.h\"\n#include \"utils/numeric.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/fd.h\"\n#include \"miscadmin.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nDatum\npg_tablespace_size_oid(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\ttblspcOid = PG_GETARG_OID(0);\n\tint64\t\tsize;\n\n\tsize = calculate_tablespace_size(tblspcOid);\n\n\tif (size < 0)\n\t\tPG_RETURN_NULL();\n\n\tPG_RETURN_INT64(size);\n}"
  },
  {
    "function_name": "calculate_tablespace_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/dbsize.c",
    "lines": "166-234",
    "snippet": "static int64\ncalculate_tablespace_size(Oid tblspcOid)\n{\n\tchar\t\ttblspcPath[MAXPGPATH];\n\tchar\t\tpathname[MAXPGPATH * 2];\n\tint64\t\ttotalsize = 0;\n\tDIR\t\t   *dirdesc;\n\tstruct dirent *direntry;\n\tAclResult\taclresult;\n\n\t/*\n\t * User must be a member of pg_read_all_stats or have CREATE privilege for\n\t * target tablespace, either explicitly granted or implicitly because it\n\t * is default for current database.\n\t */\n\tif (tblspcOid != MyDatabaseTableSpace &&\n\t\t!is_member_of_role(GetUserId(), DEFAULT_ROLE_READ_ALL_STATS))\n\t{\n\t\taclresult = pg_tablespace_aclcheck(tblspcOid, GetUserId(), ACL_CREATE);\n\t\tif (aclresult != ACLCHECK_OK)\n\t\t\taclcheck_error(aclresult, OBJECT_TABLESPACE,\n\t\t\t\t\t\t   get_tablespace_name(tblspcOid));\n\t}\n\n\tif (tblspcOid == DEFAULTTABLESPACE_OID)\n\t\tsnprintf(tblspcPath, MAXPGPATH, \"base\");\n\telse if (tblspcOid == GLOBALTABLESPACE_OID)\n\t\tsnprintf(tblspcPath, MAXPGPATH, \"global\");\n\telse\n\t\tsnprintf(tblspcPath, MAXPGPATH, \"pg_tblspc/%u/%s\", tblspcOid,\n\t\t\t\t TABLESPACE_VERSION_DIRECTORY);\n\n\tdirdesc = AllocateDir(tblspcPath);\n\n\tif (!dirdesc)\n\t\treturn -1;\n\n\twhile ((direntry = ReadDir(dirdesc, tblspcPath)) != NULL)\n\t{\n\t\tstruct stat fst;\n\n\t\tCHECK_FOR_INTERRUPTS();\n\n\t\tif (strcmp(direntry->d_name, \".\") == 0 ||\n\t\t\tstrcmp(direntry->d_name, \"..\") == 0)\n\t\t\tcontinue;\n\n\t\tsnprintf(pathname, sizeof(pathname), \"%s/%s\", tblspcPath, direntry->d_name);\n\n\t\tif (stat(pathname, &fst) < 0)\n\t\t{\n\t\t\tif (errno == ENOENT)\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not stat file \\\"%s\\\": %m\", pathname)));\n\t\t}\n\n\t\tif (S_ISDIR(fst.st_mode))\n\t\t\ttotalsize += db_dir_size(pathname);\n\n\t\ttotalsize += fst.st_size;\n\t}\n\n\tFreeDir(dirdesc);\n\n\treturn totalsize;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/relfilenodemap.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/fd.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "FreeDir",
          "args": [
            "dirdesc"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_dir_size",
          "args": [
            "pathname"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "db_dir_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/dbsize.c",
          "lines": "38-77",
          "snippet": "static int64\ndb_dir_size(const char *path)\n{\n\tint64\t\tdirsize = 0;\n\tstruct dirent *direntry;\n\tDIR\t\t   *dirdesc;\n\tchar\t\tfilename[MAXPGPATH * 2];\n\n\tdirdesc = AllocateDir(path);\n\n\tif (!dirdesc)\n\t\treturn 0;\n\n\twhile ((direntry = ReadDir(dirdesc, path)) != NULL)\n\t{\n\t\tstruct stat fst;\n\n\t\tCHECK_FOR_INTERRUPTS();\n\n\t\tif (strcmp(direntry->d_name, \".\") == 0 ||\n\t\t\tstrcmp(direntry->d_name, \"..\") == 0)\n\t\t\tcontinue;\n\n\t\tsnprintf(filename, sizeof(filename), \"%s/%s\", path, direntry->d_name);\n\n\t\tif (stat(filename, &fst) < 0)\n\t\t{\n\t\t\tif (errno == ENOENT)\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not stat file \\\"%s\\\": %m\", filename)));\n\t\t}\n\t\tdirsize += fst.st_size;\n\t}\n\n\tFreeDir(dirdesc);\n\treturn dirsize;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/relfilenodemap.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/fd.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/relfilenodemap.h\"\n#include \"utils/rel.h\"\n#include \"utils/numeric.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/fd.h\"\n#include \"miscadmin.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic int64\ndb_dir_size(const char *path)\n{\n\tint64\t\tdirsize = 0;\n\tstruct dirent *direntry;\n\tDIR\t\t   *dirdesc;\n\tchar\t\tfilename[MAXPGPATH * 2];\n\n\tdirdesc = AllocateDir(path);\n\n\tif (!dirdesc)\n\t\treturn 0;\n\n\twhile ((direntry = ReadDir(dirdesc, path)) != NULL)\n\t{\n\t\tstruct stat fst;\n\n\t\tCHECK_FOR_INTERRUPTS();\n\n\t\tif (strcmp(direntry->d_name, \".\") == 0 ||\n\t\t\tstrcmp(direntry->d_name, \"..\") == 0)\n\t\t\tcontinue;\n\n\t\tsnprintf(filename, sizeof(filename), \"%s/%s\", path, direntry->d_name);\n\n\t\tif (stat(filename, &fst) < 0)\n\t\t{\n\t\t\tif (errno == ENOENT)\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not stat file \\\"%s\\\": %m\", filename)));\n\t\t}\n\t\tdirsize += fst.st_size;\n\t}\n\n\tFreeDir(dirdesc);\n\treturn dirsize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "fst.st_mode"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not stat file \\\"%s\\\": %m\", pathname))"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not stat file \\\"%s\\\": %m\"",
            "pathname"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode_for_file_access",
          "args": [],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "errcode_for_file_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "595-655",
          "snippet": "int\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "pathname",
            "&fst"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "set_deparse_planstate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ruleutils.c",
          "lines": "4578-4639",
          "snippet": "static void\nset_deparse_planstate(deparse_namespace *dpns, PlanState *ps)\n{\n\tdpns->planstate = ps;\n\n\t/*\n\t * We special-case Append and MergeAppend to pretend that the first child\n\t * plan is the OUTER referent; we have to interpret OUTER Vars in their\n\t * tlists according to one of the children, and the first one is the most\n\t * natural choice.  Likewise special-case ModifyTable to pretend that the\n\t * first child plan is the OUTER referent; this is to support RETURNING\n\t * lists containing references to non-target relations.\n\t */\n\tif (IsA(ps, AppendState))\n\t\tdpns->outer_planstate = ((AppendState *) ps)->appendplans[0];\n\telse if (IsA(ps, MergeAppendState))\n\t\tdpns->outer_planstate = ((MergeAppendState *) ps)->mergeplans[0];\n\telse if (IsA(ps, ModifyTableState))\n\t\tdpns->outer_planstate = ((ModifyTableState *) ps)->mt_plans[0];\n\telse\n\t\tdpns->outer_planstate = outerPlanState(ps);\n\n\tif (dpns->outer_planstate)\n\t\tdpns->outer_tlist = dpns->outer_planstate->plan->targetlist;\n\telse\n\t\tdpns->outer_tlist = NIL;\n\n\t/*\n\t * For a SubqueryScan, pretend the subplan is INNER referent.  (We don't\n\t * use OUTER because that could someday conflict with the normal meaning.)\n\t * Likewise, for a CteScan, pretend the subquery's plan is INNER referent.\n\t * For ON CONFLICT .. UPDATE we just need the inner tlist to point to the\n\t * excluded expression's tlist. (Similar to the SubqueryScan we don't want\n\t * to reuse OUTER, it's used for RETURNING in some modify table cases,\n\t * although not INSERT .. CONFLICT).\n\t */\n\tif (IsA(ps, SubqueryScanState))\n\t\tdpns->inner_planstate = ((SubqueryScanState *) ps)->subplan;\n\telse if (IsA(ps, CteScanState))\n\t\tdpns->inner_planstate = ((CteScanState *) ps)->cteplanstate;\n\telse if (IsA(ps, ModifyTableState))\n\t\tdpns->inner_planstate = ps;\n\telse\n\t\tdpns->inner_planstate = innerPlanState(ps);\n\n\tif (IsA(ps, ModifyTableState))\n\t\tdpns->inner_tlist = ((ModifyTableState *) ps)->mt_excludedtlist;\n\telse if (dpns->inner_planstate)\n\t\tdpns->inner_tlist = dpns->inner_planstate->plan->targetlist;\n\telse\n\t\tdpns->inner_tlist = NIL;\n\n\t/* Set up referent for INDEX_VAR Vars, if needed */\n\tif (IsA(ps->plan, IndexOnlyScan))\n\t\tdpns->index_tlist = ((IndexOnlyScan *) ps->plan)->indextlist;\n\telse if (IsA(ps->plan, ForeignScan))\n\t\tdpns->index_tlist = ((ForeignScan *) ps->plan)->fdw_scan_tlist;\n\telse if (IsA(ps->plan, CustomScan))\n\t\tdpns->index_tlist = ((CustomScan *) ps->plan)->custom_scan_tlist;\n\telse\n\t\tdpns->index_tlist = NIL;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/ruleutils.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"rewrite/rewriteSupport.h\"",
            "#include \"rewrite/rewriteManip.h\"",
            "#include \"rewrite/rewriteHandler.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parser.h\"",
            "#include \"parser/parse_oper.h\"",
            "#include \"parser/parse_func.h\"",
            "#include \"parser/parse_agg.h\"",
            "#include \"parser/parse_node.h\"",
            "#include \"optimizer/tlist.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"common/keywords.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/dependency.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/amapi.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_simple_column_names(deparse_namespace *dpns);",
            "static void set_deparse_planstate(deparse_namespace *dpns, PlanState *ps);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/ruleutils.h\"\n#include \"utils/rel.h\"\n#include \"utils/partcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"rewrite/rewriteSupport.h\"\n#include \"rewrite/rewriteManip.h\"\n#include \"rewrite/rewriteHandler.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parser.h\"\n#include \"parser/parse_oper.h\"\n#include \"parser/parse_func.h\"\n#include \"parser/parse_agg.h\"\n#include \"parser/parse_node.h\"\n#include \"optimizer/tlist.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"common/keywords.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/dependency.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/amapi.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void set_simple_column_names(deparse_namespace *dpns);\nstatic void set_deparse_planstate(deparse_namespace *dpns, PlanState *ps);\n\nstatic void\nset_deparse_planstate(deparse_namespace *dpns, PlanState *ps)\n{\n\tdpns->planstate = ps;\n\n\t/*\n\t * We special-case Append and MergeAppend to pretend that the first child\n\t * plan is the OUTER referent; we have to interpret OUTER Vars in their\n\t * tlists according to one of the children, and the first one is the most\n\t * natural choice.  Likewise special-case ModifyTable to pretend that the\n\t * first child plan is the OUTER referent; this is to support RETURNING\n\t * lists containing references to non-target relations.\n\t */\n\tif (IsA(ps, AppendState))\n\t\tdpns->outer_planstate = ((AppendState *) ps)->appendplans[0];\n\telse if (IsA(ps, MergeAppendState))\n\t\tdpns->outer_planstate = ((MergeAppendState *) ps)->mergeplans[0];\n\telse if (IsA(ps, ModifyTableState))\n\t\tdpns->outer_planstate = ((ModifyTableState *) ps)->mt_plans[0];\n\telse\n\t\tdpns->outer_planstate = outerPlanState(ps);\n\n\tif (dpns->outer_planstate)\n\t\tdpns->outer_tlist = dpns->outer_planstate->plan->targetlist;\n\telse\n\t\tdpns->outer_tlist = NIL;\n\n\t/*\n\t * For a SubqueryScan, pretend the subplan is INNER referent.  (We don't\n\t * use OUTER because that could someday conflict with the normal meaning.)\n\t * Likewise, for a CteScan, pretend the subquery's plan is INNER referent.\n\t * For ON CONFLICT .. UPDATE we just need the inner tlist to point to the\n\t * excluded expression's tlist. (Similar to the SubqueryScan we don't want\n\t * to reuse OUTER, it's used for RETURNING in some modify table cases,\n\t * although not INSERT .. CONFLICT).\n\t */\n\tif (IsA(ps, SubqueryScanState))\n\t\tdpns->inner_planstate = ((SubqueryScanState *) ps)->subplan;\n\telse if (IsA(ps, CteScanState))\n\t\tdpns->inner_planstate = ((CteScanState *) ps)->cteplanstate;\n\telse if (IsA(ps, ModifyTableState))\n\t\tdpns->inner_planstate = ps;\n\telse\n\t\tdpns->inner_planstate = innerPlanState(ps);\n\n\tif (IsA(ps, ModifyTableState))\n\t\tdpns->inner_tlist = ((ModifyTableState *) ps)->mt_excludedtlist;\n\telse if (dpns->inner_planstate)\n\t\tdpns->inner_tlist = dpns->inner_planstate->plan->targetlist;\n\telse\n\t\tdpns->inner_tlist = NIL;\n\n\t/* Set up referent for INDEX_VAR Vars, if needed */\n\tif (IsA(ps->plan, IndexOnlyScan))\n\t\tdpns->index_tlist = ((IndexOnlyScan *) ps->plan)->indextlist;\n\telse if (IsA(ps->plan, ForeignScan))\n\t\tdpns->index_tlist = ((ForeignScan *) ps->plan)->fdw_scan_tlist;\n\telse if (IsA(ps->plan, CustomScan))\n\t\tdpns->index_tlist = ((CustomScan *) ps->plan)->custom_scan_tlist;\n\telse\n\t\tdpns->index_tlist = NIL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "pathname",
            "sizeof(pathname)",
            "\"%s/%s\"",
            "tblspcPath",
            "direntry->d_name"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "direntry->d_name",
            "\"..\""
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "246-256",
          "snippet": "int\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHECK_FOR_INTERRUPTS",
          "args": [],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReadDir",
          "args": [
            "dirdesc",
            "tblspcPath"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocateDir",
          "args": [
            "tblspcPath"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "tblspcPath",
            "MAXPGPATH",
            "\"pg_tblspc/%u/%s\"",
            "tblspcOid",
            "TABLESPACE_VERSION_DIRECTORY"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "tblspcPath",
            "MAXPGPATH",
            "\"global\""
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "tblspcPath",
            "MAXPGPATH",
            "\"base\""
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aclcheck_error",
          "args": [
            "aclresult",
            "OBJECT_TABLESPACE",
            "get_tablespace_name(tblspcOid)"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_tablespace_name",
          "args": [
            "tblspcOid"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_tablespace_aclcheck",
          "args": [
            "tblspcOid",
            "GetUserId()",
            "ACL_CREATE"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetUserId",
          "args": [],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "GetUserId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
          "lines": "386-391",
          "snippet": "Oid\nGetUserId(void)\n{\n\tAssertState(OidIsValid(CurrentUserId));\n\treturn CurrentUserId;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pidfile.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pg_shmem.h\"",
            "#include \"storage/latch.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/fd.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"common/file_perm.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/htup_details.h\"",
            "#include <utime.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/param.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Oid\tCurrentUserId = InvalidOid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nstatic Oid\tCurrentUserId = InvalidOid;\n\nOid\nGetUserId(void)\n{\n\tAssertState(OidIsValid(CurrentUserId));\n\treturn CurrentUserId;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_member_of_role",
          "args": [
            "GetUserId()",
            "DEFAULT_ROLE_READ_ALL_STATS"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "is_member_of_role_nosuper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/acl.c",
          "lines": "4969-4981",
          "snippet": "bool\nis_member_of_role_nosuper(Oid member, Oid role)\n{\n\t/* Fast path for simple case */\n\tif (member == role)\n\t\treturn true;\n\n\t/*\n\t * Find all the roles that member is a member of, including multi-level\n\t * recursion, then see if target role is any one of them.\n\t */\n\treturn list_member_oid(roles_is_member_of(member), role);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"foreign/foreign.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/proclang.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"foreign/foreign.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/proclang.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nbool\nis_member_of_role_nosuper(Oid member, Oid role)\n{\n\t/* Fast path for simple case */\n\tif (member == role)\n\t\treturn true;\n\n\t/*\n\t * Find all the roles that member is a member of, including multi-level\n\t * recursion, then see if target role is any one of them.\n\t */\n\treturn list_member_oid(roles_is_member_of(member), role);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/relfilenodemap.h\"\n#include \"utils/rel.h\"\n#include \"utils/numeric.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/fd.h\"\n#include \"miscadmin.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic int64\ncalculate_tablespace_size(Oid tblspcOid)\n{\n\tchar\t\ttblspcPath[MAXPGPATH];\n\tchar\t\tpathname[MAXPGPATH * 2];\n\tint64\t\ttotalsize = 0;\n\tDIR\t\t   *dirdesc;\n\tstruct dirent *direntry;\n\tAclResult\taclresult;\n\n\t/*\n\t * User must be a member of pg_read_all_stats or have CREATE privilege for\n\t * target tablespace, either explicitly granted or implicitly because it\n\t * is default for current database.\n\t */\n\tif (tblspcOid != MyDatabaseTableSpace &&\n\t\t!is_member_of_role(GetUserId(), DEFAULT_ROLE_READ_ALL_STATS))\n\t{\n\t\taclresult = pg_tablespace_aclcheck(tblspcOid, GetUserId(), ACL_CREATE);\n\t\tif (aclresult != ACLCHECK_OK)\n\t\t\taclcheck_error(aclresult, OBJECT_TABLESPACE,\n\t\t\t\t\t\t   get_tablespace_name(tblspcOid));\n\t}\n\n\tif (tblspcOid == DEFAULTTABLESPACE_OID)\n\t\tsnprintf(tblspcPath, MAXPGPATH, \"base\");\n\telse if (tblspcOid == GLOBALTABLESPACE_OID)\n\t\tsnprintf(tblspcPath, MAXPGPATH, \"global\");\n\telse\n\t\tsnprintf(tblspcPath, MAXPGPATH, \"pg_tblspc/%u/%s\", tblspcOid,\n\t\t\t\t TABLESPACE_VERSION_DIRECTORY);\n\n\tdirdesc = AllocateDir(tblspcPath);\n\n\tif (!dirdesc)\n\t\treturn -1;\n\n\twhile ((direntry = ReadDir(dirdesc, tblspcPath)) != NULL)\n\t{\n\t\tstruct stat fst;\n\n\t\tCHECK_FOR_INTERRUPTS();\n\n\t\tif (strcmp(direntry->d_name, \".\") == 0 ||\n\t\t\tstrcmp(direntry->d_name, \"..\") == 0)\n\t\t\tcontinue;\n\n\t\tsnprintf(pathname, sizeof(pathname), \"%s/%s\", tblspcPath, direntry->d_name);\n\n\t\tif (stat(pathname, &fst) < 0)\n\t\t{\n\t\t\tif (errno == ENOENT)\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not stat file \\\"%s\\\": %m\", pathname)));\n\t\t}\n\n\t\tif (S_ISDIR(fst.st_mode))\n\t\t\ttotalsize += db_dir_size(pathname);\n\n\t\ttotalsize += fst.st_size;\n\t}\n\n\tFreeDir(dirdesc);\n\n\treturn totalsize;\n}"
  },
  {
    "function_name": "pg_database_size_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/dbsize.c",
    "lines": "146-159",
    "snippet": "Datum\npg_database_size_name(PG_FUNCTION_ARGS)\n{\n\tName\t\tdbName = PG_GETARG_NAME(0);\n\tOid\t\t\tdbOid = get_database_oid(NameStr(*dbName), false);\n\tint64\t\tsize;\n\n\tsize = calculate_database_size(dbOid);\n\n\tif (size == 0)\n\t\tPG_RETURN_NULL();\n\n\tPG_RETURN_INT64(size);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/relfilenodemap.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/fd.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT64",
          "args": [
            "size"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calculate_database_size",
          "args": [
            "dbOid"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "calculate_database_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/dbsize.c",
          "lines": "82-130",
          "snippet": "static int64\ncalculate_database_size(Oid dbOid)\n{\n\tint64\t\ttotalsize;\n\tDIR\t\t   *dirdesc;\n\tstruct dirent *direntry;\n\tchar\t\tdirpath[MAXPGPATH];\n\tchar\t\tpathname[MAXPGPATH + 21 + sizeof(TABLESPACE_VERSION_DIRECTORY)];\n\tAclResult\taclresult;\n\n\t/*\n\t * User must have connect privilege for target database or be a member of\n\t * pg_read_all_stats\n\t */\n\taclresult = pg_database_aclcheck(dbOid, GetUserId(), ACL_CONNECT);\n\tif (aclresult != ACLCHECK_OK &&\n\t\t!is_member_of_role(GetUserId(), DEFAULT_ROLE_READ_ALL_STATS))\n\t{\n\t\taclcheck_error(aclresult, OBJECT_DATABASE,\n\t\t\t\t\t   get_database_name(dbOid));\n\t}\n\n\t/* Shared storage in pg_global is not counted */\n\n\t/* Include pg_default storage */\n\tsnprintf(pathname, sizeof(pathname), \"base/%u\", dbOid);\n\ttotalsize = db_dir_size(pathname);\n\n\t/* Scan the non-default tablespaces */\n\tsnprintf(dirpath, MAXPGPATH, \"pg_tblspc\");\n\tdirdesc = AllocateDir(dirpath);\n\n\twhile ((direntry = ReadDir(dirdesc, dirpath)) != NULL)\n\t{\n\t\tCHECK_FOR_INTERRUPTS();\n\n\t\tif (strcmp(direntry->d_name, \".\") == 0 ||\n\t\t\tstrcmp(direntry->d_name, \"..\") == 0)\n\t\t\tcontinue;\n\n\t\tsnprintf(pathname, sizeof(pathname), \"pg_tblspc/%s/%s/%u\",\n\t\t\t\t direntry->d_name, TABLESPACE_VERSION_DIRECTORY, dbOid);\n\t\ttotalsize += db_dir_size(pathname);\n\t}\n\n\tFreeDir(dirdesc);\n\n\treturn totalsize;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/relfilenodemap.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/fd.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/relfilenodemap.h\"\n#include \"utils/rel.h\"\n#include \"utils/numeric.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/fd.h\"\n#include \"miscadmin.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic int64\ncalculate_database_size(Oid dbOid)\n{\n\tint64\t\ttotalsize;\n\tDIR\t\t   *dirdesc;\n\tstruct dirent *direntry;\n\tchar\t\tdirpath[MAXPGPATH];\n\tchar\t\tpathname[MAXPGPATH + 21 + sizeof(TABLESPACE_VERSION_DIRECTORY)];\n\tAclResult\taclresult;\n\n\t/*\n\t * User must have connect privilege for target database or be a member of\n\t * pg_read_all_stats\n\t */\n\taclresult = pg_database_aclcheck(dbOid, GetUserId(), ACL_CONNECT);\n\tif (aclresult != ACLCHECK_OK &&\n\t\t!is_member_of_role(GetUserId(), DEFAULT_ROLE_READ_ALL_STATS))\n\t{\n\t\taclcheck_error(aclresult, OBJECT_DATABASE,\n\t\t\t\t\t   get_database_name(dbOid));\n\t}\n\n\t/* Shared storage in pg_global is not counted */\n\n\t/* Include pg_default storage */\n\tsnprintf(pathname, sizeof(pathname), \"base/%u\", dbOid);\n\ttotalsize = db_dir_size(pathname);\n\n\t/* Scan the non-default tablespaces */\n\tsnprintf(dirpath, MAXPGPATH, \"pg_tblspc\");\n\tdirdesc = AllocateDir(dirpath);\n\n\twhile ((direntry = ReadDir(dirdesc, dirpath)) != NULL)\n\t{\n\t\tCHECK_FOR_INTERRUPTS();\n\n\t\tif (strcmp(direntry->d_name, \".\") == 0 ||\n\t\t\tstrcmp(direntry->d_name, \"..\") == 0)\n\t\t\tcontinue;\n\n\t\tsnprintf(pathname, sizeof(pathname), \"pg_tblspc/%s/%s/%u\",\n\t\t\t\t direntry->d_name, TABLESPACE_VERSION_DIRECTORY, dbOid);\n\t\ttotalsize += db_dir_size(pathname);\n\t}\n\n\tFreeDir(dirdesc);\n\n\treturn totalsize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_database_oid",
          "args": [
            "NameStr(*dbName)",
            "false"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "*dbName"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_NAME",
          "args": [
            "0"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/relfilenodemap.h\"\n#include \"utils/rel.h\"\n#include \"utils/numeric.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/fd.h\"\n#include \"miscadmin.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nDatum\npg_database_size_name(PG_FUNCTION_ARGS)\n{\n\tName\t\tdbName = PG_GETARG_NAME(0);\n\tOid\t\t\tdbOid = get_database_oid(NameStr(*dbName), false);\n\tint64\t\tsize;\n\n\tsize = calculate_database_size(dbOid);\n\n\tif (size == 0)\n\t\tPG_RETURN_NULL();\n\n\tPG_RETURN_INT64(size);\n}"
  },
  {
    "function_name": "pg_database_size_oid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/dbsize.c",
    "lines": "132-144",
    "snippet": "Datum\npg_database_size_oid(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\tdbOid = PG_GETARG_OID(0);\n\tint64\t\tsize;\n\n\tsize = calculate_database_size(dbOid);\n\n\tif (size == 0)\n\t\tPG_RETURN_NULL();\n\n\tPG_RETURN_INT64(size);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/relfilenodemap.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/fd.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT64",
          "args": [
            "size"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calculate_database_size",
          "args": [
            "dbOid"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "calculate_database_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/dbsize.c",
          "lines": "82-130",
          "snippet": "static int64\ncalculate_database_size(Oid dbOid)\n{\n\tint64\t\ttotalsize;\n\tDIR\t\t   *dirdesc;\n\tstruct dirent *direntry;\n\tchar\t\tdirpath[MAXPGPATH];\n\tchar\t\tpathname[MAXPGPATH + 21 + sizeof(TABLESPACE_VERSION_DIRECTORY)];\n\tAclResult\taclresult;\n\n\t/*\n\t * User must have connect privilege for target database or be a member of\n\t * pg_read_all_stats\n\t */\n\taclresult = pg_database_aclcheck(dbOid, GetUserId(), ACL_CONNECT);\n\tif (aclresult != ACLCHECK_OK &&\n\t\t!is_member_of_role(GetUserId(), DEFAULT_ROLE_READ_ALL_STATS))\n\t{\n\t\taclcheck_error(aclresult, OBJECT_DATABASE,\n\t\t\t\t\t   get_database_name(dbOid));\n\t}\n\n\t/* Shared storage in pg_global is not counted */\n\n\t/* Include pg_default storage */\n\tsnprintf(pathname, sizeof(pathname), \"base/%u\", dbOid);\n\ttotalsize = db_dir_size(pathname);\n\n\t/* Scan the non-default tablespaces */\n\tsnprintf(dirpath, MAXPGPATH, \"pg_tblspc\");\n\tdirdesc = AllocateDir(dirpath);\n\n\twhile ((direntry = ReadDir(dirdesc, dirpath)) != NULL)\n\t{\n\t\tCHECK_FOR_INTERRUPTS();\n\n\t\tif (strcmp(direntry->d_name, \".\") == 0 ||\n\t\t\tstrcmp(direntry->d_name, \"..\") == 0)\n\t\t\tcontinue;\n\n\t\tsnprintf(pathname, sizeof(pathname), \"pg_tblspc/%s/%s/%u\",\n\t\t\t\t direntry->d_name, TABLESPACE_VERSION_DIRECTORY, dbOid);\n\t\ttotalsize += db_dir_size(pathname);\n\t}\n\n\tFreeDir(dirdesc);\n\n\treturn totalsize;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/relfilenodemap.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/fd.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/relfilenodemap.h\"\n#include \"utils/rel.h\"\n#include \"utils/numeric.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/fd.h\"\n#include \"miscadmin.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic int64\ncalculate_database_size(Oid dbOid)\n{\n\tint64\t\ttotalsize;\n\tDIR\t\t   *dirdesc;\n\tstruct dirent *direntry;\n\tchar\t\tdirpath[MAXPGPATH];\n\tchar\t\tpathname[MAXPGPATH + 21 + sizeof(TABLESPACE_VERSION_DIRECTORY)];\n\tAclResult\taclresult;\n\n\t/*\n\t * User must have connect privilege for target database or be a member of\n\t * pg_read_all_stats\n\t */\n\taclresult = pg_database_aclcheck(dbOid, GetUserId(), ACL_CONNECT);\n\tif (aclresult != ACLCHECK_OK &&\n\t\t!is_member_of_role(GetUserId(), DEFAULT_ROLE_READ_ALL_STATS))\n\t{\n\t\taclcheck_error(aclresult, OBJECT_DATABASE,\n\t\t\t\t\t   get_database_name(dbOid));\n\t}\n\n\t/* Shared storage in pg_global is not counted */\n\n\t/* Include pg_default storage */\n\tsnprintf(pathname, sizeof(pathname), \"base/%u\", dbOid);\n\ttotalsize = db_dir_size(pathname);\n\n\t/* Scan the non-default tablespaces */\n\tsnprintf(dirpath, MAXPGPATH, \"pg_tblspc\");\n\tdirdesc = AllocateDir(dirpath);\n\n\twhile ((direntry = ReadDir(dirdesc, dirpath)) != NULL)\n\t{\n\t\tCHECK_FOR_INTERRUPTS();\n\n\t\tif (strcmp(direntry->d_name, \".\") == 0 ||\n\t\t\tstrcmp(direntry->d_name, \"..\") == 0)\n\t\t\tcontinue;\n\n\t\tsnprintf(pathname, sizeof(pathname), \"pg_tblspc/%s/%s/%u\",\n\t\t\t\t direntry->d_name, TABLESPACE_VERSION_DIRECTORY, dbOid);\n\t\ttotalsize += db_dir_size(pathname);\n\t}\n\n\tFreeDir(dirdesc);\n\n\treturn totalsize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "0"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/relfilenodemap.h\"\n#include \"utils/rel.h\"\n#include \"utils/numeric.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/fd.h\"\n#include \"miscadmin.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nDatum\npg_database_size_oid(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\tdbOid = PG_GETARG_OID(0);\n\tint64\t\tsize;\n\n\tsize = calculate_database_size(dbOid);\n\n\tif (size == 0)\n\t\tPG_RETURN_NULL();\n\n\tPG_RETURN_INT64(size);\n}"
  },
  {
    "function_name": "calculate_database_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/dbsize.c",
    "lines": "82-130",
    "snippet": "static int64\ncalculate_database_size(Oid dbOid)\n{\n\tint64\t\ttotalsize;\n\tDIR\t\t   *dirdesc;\n\tstruct dirent *direntry;\n\tchar\t\tdirpath[MAXPGPATH];\n\tchar\t\tpathname[MAXPGPATH + 21 + sizeof(TABLESPACE_VERSION_DIRECTORY)];\n\tAclResult\taclresult;\n\n\t/*\n\t * User must have connect privilege for target database or be a member of\n\t * pg_read_all_stats\n\t */\n\taclresult = pg_database_aclcheck(dbOid, GetUserId(), ACL_CONNECT);\n\tif (aclresult != ACLCHECK_OK &&\n\t\t!is_member_of_role(GetUserId(), DEFAULT_ROLE_READ_ALL_STATS))\n\t{\n\t\taclcheck_error(aclresult, OBJECT_DATABASE,\n\t\t\t\t\t   get_database_name(dbOid));\n\t}\n\n\t/* Shared storage in pg_global is not counted */\n\n\t/* Include pg_default storage */\n\tsnprintf(pathname, sizeof(pathname), \"base/%u\", dbOid);\n\ttotalsize = db_dir_size(pathname);\n\n\t/* Scan the non-default tablespaces */\n\tsnprintf(dirpath, MAXPGPATH, \"pg_tblspc\");\n\tdirdesc = AllocateDir(dirpath);\n\n\twhile ((direntry = ReadDir(dirdesc, dirpath)) != NULL)\n\t{\n\t\tCHECK_FOR_INTERRUPTS();\n\n\t\tif (strcmp(direntry->d_name, \".\") == 0 ||\n\t\t\tstrcmp(direntry->d_name, \"..\") == 0)\n\t\t\tcontinue;\n\n\t\tsnprintf(pathname, sizeof(pathname), \"pg_tblspc/%s/%s/%u\",\n\t\t\t\t direntry->d_name, TABLESPACE_VERSION_DIRECTORY, dbOid);\n\t\ttotalsize += db_dir_size(pathname);\n\t}\n\n\tFreeDir(dirdesc);\n\n\treturn totalsize;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/relfilenodemap.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/fd.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "FreeDir",
          "args": [
            "dirdesc"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_dir_size",
          "args": [
            "pathname"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "db_dir_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/dbsize.c",
          "lines": "38-77",
          "snippet": "static int64\ndb_dir_size(const char *path)\n{\n\tint64\t\tdirsize = 0;\n\tstruct dirent *direntry;\n\tDIR\t\t   *dirdesc;\n\tchar\t\tfilename[MAXPGPATH * 2];\n\n\tdirdesc = AllocateDir(path);\n\n\tif (!dirdesc)\n\t\treturn 0;\n\n\twhile ((direntry = ReadDir(dirdesc, path)) != NULL)\n\t{\n\t\tstruct stat fst;\n\n\t\tCHECK_FOR_INTERRUPTS();\n\n\t\tif (strcmp(direntry->d_name, \".\") == 0 ||\n\t\t\tstrcmp(direntry->d_name, \"..\") == 0)\n\t\t\tcontinue;\n\n\t\tsnprintf(filename, sizeof(filename), \"%s/%s\", path, direntry->d_name);\n\n\t\tif (stat(filename, &fst) < 0)\n\t\t{\n\t\t\tif (errno == ENOENT)\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not stat file \\\"%s\\\": %m\", filename)));\n\t\t}\n\t\tdirsize += fst.st_size;\n\t}\n\n\tFreeDir(dirdesc);\n\treturn dirsize;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/relfilenodemap.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/fd.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/relfilenodemap.h\"\n#include \"utils/rel.h\"\n#include \"utils/numeric.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/fd.h\"\n#include \"miscadmin.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic int64\ndb_dir_size(const char *path)\n{\n\tint64\t\tdirsize = 0;\n\tstruct dirent *direntry;\n\tDIR\t\t   *dirdesc;\n\tchar\t\tfilename[MAXPGPATH * 2];\n\n\tdirdesc = AllocateDir(path);\n\n\tif (!dirdesc)\n\t\treturn 0;\n\n\twhile ((direntry = ReadDir(dirdesc, path)) != NULL)\n\t{\n\t\tstruct stat fst;\n\n\t\tCHECK_FOR_INTERRUPTS();\n\n\t\tif (strcmp(direntry->d_name, \".\") == 0 ||\n\t\t\tstrcmp(direntry->d_name, \"..\") == 0)\n\t\t\tcontinue;\n\n\t\tsnprintf(filename, sizeof(filename), \"%s/%s\", path, direntry->d_name);\n\n\t\tif (stat(filename, &fst) < 0)\n\t\t{\n\t\t\tif (errno == ENOENT)\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not stat file \\\"%s\\\": %m\", filename)));\n\t\t}\n\t\tdirsize += fst.st_size;\n\t}\n\n\tFreeDir(dirdesc);\n\treturn dirsize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "pathname",
            "sizeof(pathname)",
            "\"pg_tblspc/%s/%s/%u\"",
            "direntry->d_name",
            "TABLESPACE_VERSION_DIRECTORY",
            "dbOid"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "direntry->d_name",
            "\"..\""
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "246-256",
          "snippet": "int\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHECK_FOR_INTERRUPTS",
          "args": [],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReadDir",
          "args": [
            "dirdesc",
            "dirpath"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocateDir",
          "args": [
            "dirpath"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "dirpath",
            "MAXPGPATH",
            "\"pg_tblspc\""
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "pathname",
            "sizeof(pathname)",
            "\"base/%u\"",
            "dbOid"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aclcheck_error",
          "args": [
            "aclresult",
            "OBJECT_DATABASE",
            "get_database_name(dbOid)"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_database_name",
          "args": [
            "dbOid"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_member_of_role",
          "args": [
            "GetUserId()",
            "DEFAULT_ROLE_READ_ALL_STATS"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "is_member_of_role_nosuper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/acl.c",
          "lines": "4969-4981",
          "snippet": "bool\nis_member_of_role_nosuper(Oid member, Oid role)\n{\n\t/* Fast path for simple case */\n\tif (member == role)\n\t\treturn true;\n\n\t/*\n\t * Find all the roles that member is a member of, including multi-level\n\t * recursion, then see if target role is any one of them.\n\t */\n\treturn list_member_oid(roles_is_member_of(member), role);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"foreign/foreign.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/proclang.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"foreign/foreign.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/proclang.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nbool\nis_member_of_role_nosuper(Oid member, Oid role)\n{\n\t/* Fast path for simple case */\n\tif (member == role)\n\t\treturn true;\n\n\t/*\n\t * Find all the roles that member is a member of, including multi-level\n\t * recursion, then see if target role is any one of them.\n\t */\n\treturn list_member_oid(roles_is_member_of(member), role);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetUserId",
          "args": [],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "GetUserId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
          "lines": "386-391",
          "snippet": "Oid\nGetUserId(void)\n{\n\tAssertState(OidIsValid(CurrentUserId));\n\treturn CurrentUserId;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pidfile.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pg_shmem.h\"",
            "#include \"storage/latch.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/fd.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"common/file_perm.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/htup_details.h\"",
            "#include <utime.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/param.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Oid\tCurrentUserId = InvalidOid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nstatic Oid\tCurrentUserId = InvalidOid;\n\nOid\nGetUserId(void)\n{\n\tAssertState(OidIsValid(CurrentUserId));\n\treturn CurrentUserId;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_database_aclcheck",
          "args": [
            "dbOid",
            "GetUserId()",
            "ACL_CONNECT"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/relfilenodemap.h\"\n#include \"utils/rel.h\"\n#include \"utils/numeric.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/fd.h\"\n#include \"miscadmin.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic int64\ncalculate_database_size(Oid dbOid)\n{\n\tint64\t\ttotalsize;\n\tDIR\t\t   *dirdesc;\n\tstruct dirent *direntry;\n\tchar\t\tdirpath[MAXPGPATH];\n\tchar\t\tpathname[MAXPGPATH + 21 + sizeof(TABLESPACE_VERSION_DIRECTORY)];\n\tAclResult\taclresult;\n\n\t/*\n\t * User must have connect privilege for target database or be a member of\n\t * pg_read_all_stats\n\t */\n\taclresult = pg_database_aclcheck(dbOid, GetUserId(), ACL_CONNECT);\n\tif (aclresult != ACLCHECK_OK &&\n\t\t!is_member_of_role(GetUserId(), DEFAULT_ROLE_READ_ALL_STATS))\n\t{\n\t\taclcheck_error(aclresult, OBJECT_DATABASE,\n\t\t\t\t\t   get_database_name(dbOid));\n\t}\n\n\t/* Shared storage in pg_global is not counted */\n\n\t/* Include pg_default storage */\n\tsnprintf(pathname, sizeof(pathname), \"base/%u\", dbOid);\n\ttotalsize = db_dir_size(pathname);\n\n\t/* Scan the non-default tablespaces */\n\tsnprintf(dirpath, MAXPGPATH, \"pg_tblspc\");\n\tdirdesc = AllocateDir(dirpath);\n\n\twhile ((direntry = ReadDir(dirdesc, dirpath)) != NULL)\n\t{\n\t\tCHECK_FOR_INTERRUPTS();\n\n\t\tif (strcmp(direntry->d_name, \".\") == 0 ||\n\t\t\tstrcmp(direntry->d_name, \"..\") == 0)\n\t\t\tcontinue;\n\n\t\tsnprintf(pathname, sizeof(pathname), \"pg_tblspc/%s/%s/%u\",\n\t\t\t\t direntry->d_name, TABLESPACE_VERSION_DIRECTORY, dbOid);\n\t\ttotalsize += db_dir_size(pathname);\n\t}\n\n\tFreeDir(dirdesc);\n\n\treturn totalsize;\n}"
  },
  {
    "function_name": "db_dir_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/dbsize.c",
    "lines": "38-77",
    "snippet": "static int64\ndb_dir_size(const char *path)\n{\n\tint64\t\tdirsize = 0;\n\tstruct dirent *direntry;\n\tDIR\t\t   *dirdesc;\n\tchar\t\tfilename[MAXPGPATH * 2];\n\n\tdirdesc = AllocateDir(path);\n\n\tif (!dirdesc)\n\t\treturn 0;\n\n\twhile ((direntry = ReadDir(dirdesc, path)) != NULL)\n\t{\n\t\tstruct stat fst;\n\n\t\tCHECK_FOR_INTERRUPTS();\n\n\t\tif (strcmp(direntry->d_name, \".\") == 0 ||\n\t\t\tstrcmp(direntry->d_name, \"..\") == 0)\n\t\t\tcontinue;\n\n\t\tsnprintf(filename, sizeof(filename), \"%s/%s\", path, direntry->d_name);\n\n\t\tif (stat(filename, &fst) < 0)\n\t\t{\n\t\t\tif (errno == ENOENT)\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not stat file \\\"%s\\\": %m\", filename)));\n\t\t}\n\t\tdirsize += fst.st_size;\n\t}\n\n\tFreeDir(dirdesc);\n\treturn dirsize;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/relfilenodemap.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/numeric.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"storage/fd.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"commands/dbcommands.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include <sys/stat.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "FreeDir",
          "args": [
            "dirdesc"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not stat file \\\"%s\\\": %m\", filename))"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not stat file \\\"%s\\\": %m\"",
            "filename"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode_for_file_access",
          "args": [],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "errcode_for_file_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "595-655",
          "snippet": "int\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "filename",
            "&fst"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "set_deparse_planstate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ruleutils.c",
          "lines": "4578-4639",
          "snippet": "static void\nset_deparse_planstate(deparse_namespace *dpns, PlanState *ps)\n{\n\tdpns->planstate = ps;\n\n\t/*\n\t * We special-case Append and MergeAppend to pretend that the first child\n\t * plan is the OUTER referent; we have to interpret OUTER Vars in their\n\t * tlists according to one of the children, and the first one is the most\n\t * natural choice.  Likewise special-case ModifyTable to pretend that the\n\t * first child plan is the OUTER referent; this is to support RETURNING\n\t * lists containing references to non-target relations.\n\t */\n\tif (IsA(ps, AppendState))\n\t\tdpns->outer_planstate = ((AppendState *) ps)->appendplans[0];\n\telse if (IsA(ps, MergeAppendState))\n\t\tdpns->outer_planstate = ((MergeAppendState *) ps)->mergeplans[0];\n\telse if (IsA(ps, ModifyTableState))\n\t\tdpns->outer_planstate = ((ModifyTableState *) ps)->mt_plans[0];\n\telse\n\t\tdpns->outer_planstate = outerPlanState(ps);\n\n\tif (dpns->outer_planstate)\n\t\tdpns->outer_tlist = dpns->outer_planstate->plan->targetlist;\n\telse\n\t\tdpns->outer_tlist = NIL;\n\n\t/*\n\t * For a SubqueryScan, pretend the subplan is INNER referent.  (We don't\n\t * use OUTER because that could someday conflict with the normal meaning.)\n\t * Likewise, for a CteScan, pretend the subquery's plan is INNER referent.\n\t * For ON CONFLICT .. UPDATE we just need the inner tlist to point to the\n\t * excluded expression's tlist. (Similar to the SubqueryScan we don't want\n\t * to reuse OUTER, it's used for RETURNING in some modify table cases,\n\t * although not INSERT .. CONFLICT).\n\t */\n\tif (IsA(ps, SubqueryScanState))\n\t\tdpns->inner_planstate = ((SubqueryScanState *) ps)->subplan;\n\telse if (IsA(ps, CteScanState))\n\t\tdpns->inner_planstate = ((CteScanState *) ps)->cteplanstate;\n\telse if (IsA(ps, ModifyTableState))\n\t\tdpns->inner_planstate = ps;\n\telse\n\t\tdpns->inner_planstate = innerPlanState(ps);\n\n\tif (IsA(ps, ModifyTableState))\n\t\tdpns->inner_tlist = ((ModifyTableState *) ps)->mt_excludedtlist;\n\telse if (dpns->inner_planstate)\n\t\tdpns->inner_tlist = dpns->inner_planstate->plan->targetlist;\n\telse\n\t\tdpns->inner_tlist = NIL;\n\n\t/* Set up referent for INDEX_VAR Vars, if needed */\n\tif (IsA(ps->plan, IndexOnlyScan))\n\t\tdpns->index_tlist = ((IndexOnlyScan *) ps->plan)->indextlist;\n\telse if (IsA(ps->plan, ForeignScan))\n\t\tdpns->index_tlist = ((ForeignScan *) ps->plan)->fdw_scan_tlist;\n\telse if (IsA(ps->plan, CustomScan))\n\t\tdpns->index_tlist = ((CustomScan *) ps->plan)->custom_scan_tlist;\n\telse\n\t\tdpns->index_tlist = NIL;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/ruleutils.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"rewrite/rewriteSupport.h\"",
            "#include \"rewrite/rewriteManip.h\"",
            "#include \"rewrite/rewriteHandler.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parser.h\"",
            "#include \"parser/parse_oper.h\"",
            "#include \"parser/parse_func.h\"",
            "#include \"parser/parse_agg.h\"",
            "#include \"parser/parse_node.h\"",
            "#include \"optimizer/tlist.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"common/keywords.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/dependency.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/amapi.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_simple_column_names(deparse_namespace *dpns);",
            "static void set_deparse_planstate(deparse_namespace *dpns, PlanState *ps);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/ruleutils.h\"\n#include \"utils/rel.h\"\n#include \"utils/partcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"rewrite/rewriteSupport.h\"\n#include \"rewrite/rewriteManip.h\"\n#include \"rewrite/rewriteHandler.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parser.h\"\n#include \"parser/parse_oper.h\"\n#include \"parser/parse_func.h\"\n#include \"parser/parse_agg.h\"\n#include \"parser/parse_node.h\"\n#include \"optimizer/tlist.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"common/keywords.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/dependency.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/amapi.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void set_simple_column_names(deparse_namespace *dpns);\nstatic void set_deparse_planstate(deparse_namespace *dpns, PlanState *ps);\n\nstatic void\nset_deparse_planstate(deparse_namespace *dpns, PlanState *ps)\n{\n\tdpns->planstate = ps;\n\n\t/*\n\t * We special-case Append and MergeAppend to pretend that the first child\n\t * plan is the OUTER referent; we have to interpret OUTER Vars in their\n\t * tlists according to one of the children, and the first one is the most\n\t * natural choice.  Likewise special-case ModifyTable to pretend that the\n\t * first child plan is the OUTER referent; this is to support RETURNING\n\t * lists containing references to non-target relations.\n\t */\n\tif (IsA(ps, AppendState))\n\t\tdpns->outer_planstate = ((AppendState *) ps)->appendplans[0];\n\telse if (IsA(ps, MergeAppendState))\n\t\tdpns->outer_planstate = ((MergeAppendState *) ps)->mergeplans[0];\n\telse if (IsA(ps, ModifyTableState))\n\t\tdpns->outer_planstate = ((ModifyTableState *) ps)->mt_plans[0];\n\telse\n\t\tdpns->outer_planstate = outerPlanState(ps);\n\n\tif (dpns->outer_planstate)\n\t\tdpns->outer_tlist = dpns->outer_planstate->plan->targetlist;\n\telse\n\t\tdpns->outer_tlist = NIL;\n\n\t/*\n\t * For a SubqueryScan, pretend the subplan is INNER referent.  (We don't\n\t * use OUTER because that could someday conflict with the normal meaning.)\n\t * Likewise, for a CteScan, pretend the subquery's plan is INNER referent.\n\t * For ON CONFLICT .. UPDATE we just need the inner tlist to point to the\n\t * excluded expression's tlist. (Similar to the SubqueryScan we don't want\n\t * to reuse OUTER, it's used for RETURNING in some modify table cases,\n\t * although not INSERT .. CONFLICT).\n\t */\n\tif (IsA(ps, SubqueryScanState))\n\t\tdpns->inner_planstate = ((SubqueryScanState *) ps)->subplan;\n\telse if (IsA(ps, CteScanState))\n\t\tdpns->inner_planstate = ((CteScanState *) ps)->cteplanstate;\n\telse if (IsA(ps, ModifyTableState))\n\t\tdpns->inner_planstate = ps;\n\telse\n\t\tdpns->inner_planstate = innerPlanState(ps);\n\n\tif (IsA(ps, ModifyTableState))\n\t\tdpns->inner_tlist = ((ModifyTableState *) ps)->mt_excludedtlist;\n\telse if (dpns->inner_planstate)\n\t\tdpns->inner_tlist = dpns->inner_planstate->plan->targetlist;\n\telse\n\t\tdpns->inner_tlist = NIL;\n\n\t/* Set up referent for INDEX_VAR Vars, if needed */\n\tif (IsA(ps->plan, IndexOnlyScan))\n\t\tdpns->index_tlist = ((IndexOnlyScan *) ps->plan)->indextlist;\n\telse if (IsA(ps->plan, ForeignScan))\n\t\tdpns->index_tlist = ((ForeignScan *) ps->plan)->fdw_scan_tlist;\n\telse if (IsA(ps->plan, CustomScan))\n\t\tdpns->index_tlist = ((CustomScan *) ps->plan)->custom_scan_tlist;\n\telse\n\t\tdpns->index_tlist = NIL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "filename",
            "sizeof(filename)",
            "\"%s/%s\"",
            "path",
            "direntry->d_name"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "direntry->d_name",
            "\"..\""
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "246-256",
          "snippet": "int\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHECK_FOR_INTERRUPTS",
          "args": [],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReadDir",
          "args": [
            "dirdesc",
            "path"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocateDir",
          "args": [
            "path"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/relfilenodemap.h\"\n#include \"utils/rel.h\"\n#include \"utils/numeric.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/fd.h\"\n#include \"miscadmin.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic int64\ndb_dir_size(const char *path)\n{\n\tint64\t\tdirsize = 0;\n\tstruct dirent *direntry;\n\tDIR\t\t   *dirdesc;\n\tchar\t\tfilename[MAXPGPATH * 2];\n\n\tdirdesc = AllocateDir(path);\n\n\tif (!dirdesc)\n\t\treturn 0;\n\n\twhile ((direntry = ReadDir(dirdesc, path)) != NULL)\n\t{\n\t\tstruct stat fst;\n\n\t\tCHECK_FOR_INTERRUPTS();\n\n\t\tif (strcmp(direntry->d_name, \".\") == 0 ||\n\t\t\tstrcmp(direntry->d_name, \"..\") == 0)\n\t\t\tcontinue;\n\n\t\tsnprintf(filename, sizeof(filename), \"%s/%s\", path, direntry->d_name);\n\n\t\tif (stat(filename, &fst) < 0)\n\t\t{\n\t\t\tif (errno == ENOENT)\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not stat file \\\"%s\\\": %m\", filename)));\n\t\t}\n\t\tdirsize += fst.st_size;\n\t}\n\n\tFreeDir(dirdesc);\n\treturn dirsize;\n}"
  }
]