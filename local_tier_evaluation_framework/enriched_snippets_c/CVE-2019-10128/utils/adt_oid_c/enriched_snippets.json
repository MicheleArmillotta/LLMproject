[
  {
    "function_name": "oidvectorgt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oid.c",
    "lines": "465-471",
    "snippet": "Datum\noidvectorgt(PG_FUNCTION_ARGS)\n{\n\tint32\t\tcmp = DatumGetInt32(btoidvectorcmp(fcinfo));\n\n\tPG_RETURN_BOOL(cmp > 0);\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/value.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "cmp > 0"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetInt32",
          "args": [
            "btoidvectorcmp(fcinfo)"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btoidvectorcmp",
          "args": [
            "fcinfo"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/value.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\noidvectorgt(PG_FUNCTION_ARGS)\n{\n\tint32\t\tcmp = DatumGetInt32(btoidvectorcmp(fcinfo));\n\n\tPG_RETURN_BOOL(cmp > 0);\n}"
  },
  {
    "function_name": "oidvectorge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oid.c",
    "lines": "457-463",
    "snippet": "Datum\noidvectorge(PG_FUNCTION_ARGS)\n{\n\tint32\t\tcmp = DatumGetInt32(btoidvectorcmp(fcinfo));\n\n\tPG_RETURN_BOOL(cmp >= 0);\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/value.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "cmp >= 0"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetInt32",
          "args": [
            "btoidvectorcmp(fcinfo)"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btoidvectorcmp",
          "args": [
            "fcinfo"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/value.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\noidvectorge(PG_FUNCTION_ARGS)\n{\n\tint32\t\tcmp = DatumGetInt32(btoidvectorcmp(fcinfo));\n\n\tPG_RETURN_BOOL(cmp >= 0);\n}"
  },
  {
    "function_name": "oidvectorle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oid.c",
    "lines": "449-455",
    "snippet": "Datum\noidvectorle(PG_FUNCTION_ARGS)\n{\n\tint32\t\tcmp = DatumGetInt32(btoidvectorcmp(fcinfo));\n\n\tPG_RETURN_BOOL(cmp <= 0);\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/value.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "cmp <= 0"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetInt32",
          "args": [
            "btoidvectorcmp(fcinfo)"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btoidvectorcmp",
          "args": [
            "fcinfo"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/value.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\noidvectorle(PG_FUNCTION_ARGS)\n{\n\tint32\t\tcmp = DatumGetInt32(btoidvectorcmp(fcinfo));\n\n\tPG_RETURN_BOOL(cmp <= 0);\n}"
  },
  {
    "function_name": "oidvectorlt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oid.c",
    "lines": "441-447",
    "snippet": "Datum\noidvectorlt(PG_FUNCTION_ARGS)\n{\n\tint32\t\tcmp = DatumGetInt32(btoidvectorcmp(fcinfo));\n\n\tPG_RETURN_BOOL(cmp < 0);\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/value.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "cmp < 0"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetInt32",
          "args": [
            "btoidvectorcmp(fcinfo)"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btoidvectorcmp",
          "args": [
            "fcinfo"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/value.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\noidvectorlt(PG_FUNCTION_ARGS)\n{\n\tint32\t\tcmp = DatumGetInt32(btoidvectorcmp(fcinfo));\n\n\tPG_RETURN_BOOL(cmp < 0);\n}"
  },
  {
    "function_name": "oidvectorne",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oid.c",
    "lines": "433-439",
    "snippet": "Datum\noidvectorne(PG_FUNCTION_ARGS)\n{\n\tint32\t\tcmp = DatumGetInt32(btoidvectorcmp(fcinfo));\n\n\tPG_RETURN_BOOL(cmp != 0);\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/value.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "cmp != 0"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetInt32",
          "args": [
            "btoidvectorcmp(fcinfo)"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btoidvectorcmp",
          "args": [
            "fcinfo"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/value.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\noidvectorne(PG_FUNCTION_ARGS)\n{\n\tint32\t\tcmp = DatumGetInt32(btoidvectorcmp(fcinfo));\n\n\tPG_RETURN_BOOL(cmp != 0);\n}"
  },
  {
    "function_name": "oidvectoreq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oid.c",
    "lines": "425-431",
    "snippet": "Datum\noidvectoreq(PG_FUNCTION_ARGS)\n{\n\tint32\t\tcmp = DatumGetInt32(btoidvectorcmp(fcinfo));\n\n\tPG_RETURN_BOOL(cmp == 0);\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/value.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "cmp == 0"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetInt32",
          "args": [
            "btoidvectorcmp(fcinfo)"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btoidvectorcmp",
          "args": [
            "fcinfo"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/value.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\noidvectoreq(PG_FUNCTION_ARGS)\n{\n\tint32\t\tcmp = DatumGetInt32(btoidvectorcmp(fcinfo));\n\n\tPG_RETURN_BOOL(cmp == 0);\n}"
  },
  {
    "function_name": "oidsmaller",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oid.c",
    "lines": "416-423",
    "snippet": "Datum\noidsmaller(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\targ1 = PG_GETARG_OID(0);\n\tOid\t\t\targ2 = PG_GETARG_OID(1);\n\n\tPG_RETURN_OID((arg1 < arg2) ? arg1 : arg2);\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/value.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_OID",
          "args": [
            "(arg1 < arg2) ? arg1 : arg2"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "1"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "0"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/value.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\noidsmaller(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\targ1 = PG_GETARG_OID(0);\n\tOid\t\t\targ2 = PG_GETARG_OID(1);\n\n\tPG_RETURN_OID((arg1 < arg2) ? arg1 : arg2);\n}"
  },
  {
    "function_name": "oidlarger",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oid.c",
    "lines": "407-414",
    "snippet": "Datum\noidlarger(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\targ1 = PG_GETARG_OID(0);\n\tOid\t\t\targ2 = PG_GETARG_OID(1);\n\n\tPG_RETURN_OID((arg1 > arg2) ? arg1 : arg2);\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/value.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_OID",
          "args": [
            "(arg1 > arg2) ? arg1 : arg2"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "1"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "0"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/value.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\noidlarger(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\targ1 = PG_GETARG_OID(0);\n\tOid\t\t\targ2 = PG_GETARG_OID(1);\n\n\tPG_RETURN_OID((arg1 > arg2) ? arg1 : arg2);\n}"
  },
  {
    "function_name": "oidgt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oid.c",
    "lines": "398-405",
    "snippet": "Datum\noidgt(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\targ1 = PG_GETARG_OID(0);\n\tOid\t\t\targ2 = PG_GETARG_OID(1);\n\n\tPG_RETURN_BOOL(arg1 > arg2);\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/value.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "arg1 > arg2"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "1"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "0"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/value.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\noidgt(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\targ1 = PG_GETARG_OID(0);\n\tOid\t\t\targ2 = PG_GETARG_OID(1);\n\n\tPG_RETURN_BOOL(arg1 > arg2);\n}"
  },
  {
    "function_name": "oidge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oid.c",
    "lines": "389-396",
    "snippet": "Datum\noidge(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\targ1 = PG_GETARG_OID(0);\n\tOid\t\t\targ2 = PG_GETARG_OID(1);\n\n\tPG_RETURN_BOOL(arg1 >= arg2);\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/value.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "arg1 >= arg2"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "1"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "0"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/value.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\noidge(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\targ1 = PG_GETARG_OID(0);\n\tOid\t\t\targ2 = PG_GETARG_OID(1);\n\n\tPG_RETURN_BOOL(arg1 >= arg2);\n}"
  },
  {
    "function_name": "oidle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oid.c",
    "lines": "380-387",
    "snippet": "Datum\noidle(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\targ1 = PG_GETARG_OID(0);\n\tOid\t\t\targ2 = PG_GETARG_OID(1);\n\n\tPG_RETURN_BOOL(arg1 <= arg2);\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/value.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "arg1 <= arg2"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "1"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "0"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/value.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\noidle(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\targ1 = PG_GETARG_OID(0);\n\tOid\t\t\targ2 = PG_GETARG_OID(1);\n\n\tPG_RETURN_BOOL(arg1 <= arg2);\n}"
  },
  {
    "function_name": "oidlt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oid.c",
    "lines": "371-378",
    "snippet": "Datum\noidlt(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\targ1 = PG_GETARG_OID(0);\n\tOid\t\t\targ2 = PG_GETARG_OID(1);\n\n\tPG_RETURN_BOOL(arg1 < arg2);\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/value.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "arg1 < arg2"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "1"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "0"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/value.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\noidlt(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\targ1 = PG_GETARG_OID(0);\n\tOid\t\t\targ2 = PG_GETARG_OID(1);\n\n\tPG_RETURN_BOOL(arg1 < arg2);\n}"
  },
  {
    "function_name": "oidne",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oid.c",
    "lines": "362-369",
    "snippet": "Datum\noidne(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\targ1 = PG_GETARG_OID(0);\n\tOid\t\t\targ2 = PG_GETARG_OID(1);\n\n\tPG_RETURN_BOOL(arg1 != arg2);\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/value.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "arg1 != arg2"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "1"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "0"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/value.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\noidne(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\targ1 = PG_GETARG_OID(0);\n\tOid\t\t\targ2 = PG_GETARG_OID(1);\n\n\tPG_RETURN_BOOL(arg1 != arg2);\n}"
  },
  {
    "function_name": "oideq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oid.c",
    "lines": "353-360",
    "snippet": "Datum\noideq(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\targ1 = PG_GETARG_OID(0);\n\tOid\t\t\targ2 = PG_GETARG_OID(1);\n\n\tPG_RETURN_BOOL(arg1 == arg2);\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/value.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "arg1 == arg2"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "1"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "0"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/value.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\noideq(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\targ1 = PG_GETARG_OID(0);\n\tOid\t\t\targ2 = PG_GETARG_OID(1);\n\n\tPG_RETURN_BOOL(arg1 == arg2);\n}"
  },
  {
    "function_name": "oid_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oid.c",
    "lines": "335-346",
    "snippet": "int\noid_cmp(const void *p1, const void *p2)\n{\n\tOid\t\t\tv1 = *((const Oid *) p1);\n\tOid\t\t\tv2 = *((const Oid *) p2);\n\n\tif (v1 < v2)\n\t\treturn -1;\n\tif (v1 > v2)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/value.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/value.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\noid_cmp(const void *p1, const void *p2)\n{\n\tOid\t\t\tv1 = *((const Oid *) p1);\n\tOid\t\t\tv2 = *((const Oid *) p2);\n\n\tif (v1 < v2)\n\t\treturn -1;\n\tif (v1 > v2)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "oidparse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oid.c",
    "lines": "313-332",
    "snippet": "Oid\noidparse(Node *node)\n{\n\tswitch (nodeTag(node))\n\t{\n\t\tcase T_Integer:\n\t\t\treturn intVal(node);\n\t\tcase T_Float:\n\n\t\t\t/*\n\t\t\t * Values too large for int4 will be represented as Float\n\t\t\t * constants by the lexer.  Accept these if they are valid OID\n\t\t\t * strings.\n\t\t\t */\n\t\t\treturn oidin_subr(strVal(node), NULL);\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized node type: %d\", (int) nodeTag(node));\n\t}\n\treturn InvalidOid;\t\t\t/* keep compiler quiet */\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/value.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unrecognized node type: %d\"",
            "(int) nodeTag(node)"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nodeTag",
          "args": [
            "node"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oidin_subr",
          "args": [
            "strVal(node)",
            "NULL"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "oidin_subr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oid.c",
          "lines": "34-114",
          "snippet": "static Oid\noidin_subr(const char *s, char **endloc)\n{\n\tunsigned long cvt;\n\tchar\t   *endptr;\n\tOid\t\t\tresult;\n\n\tif (*s == '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\"oid\", s)));\n\n\terrno = 0;\n\tcvt = strtoul(s, &endptr, 10);\n\n\t/*\n\t * strtoul() normally only sets ERANGE.  On some systems it also may set\n\t * EINVAL, which simply means it couldn't parse the input string. This is\n\t * handled by the second \"if\" consistent across platforms.\n\t */\n\tif (errno && errno != ERANGE && errno != EINVAL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\"oid\", s)));\n\n\tif (endptr == s && *s != '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\"oid\", s)));\n\n\tif (errno == ERANGE)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"value \\\"%s\\\" is out of range for type %s\",\n\t\t\t\t\t\ts, \"oid\")));\n\n\tif (endloc)\n\t{\n\t\t/* caller wants to deal with rest of string */\n\t\t*endloc = endptr;\n\t}\n\telse\n\t{\n\t\t/* allow only whitespace after number */\n\t\twhile (*endptr && isspace((unsigned char) *endptr))\n\t\t\tendptr++;\n\t\tif (*endptr)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\"oid\", s)));\n\t}\n\n\tresult = (Oid) cvt;\n\n\t/*\n\t * Cope with possibility that unsigned long is wider than Oid, in which\n\t * case strtoul will not raise an error for some values that are out of\n\t * the range of Oid.\n\t *\n\t * For backwards compatibility, we want to accept inputs that are given\n\t * with a minus sign, so allow the input value if it matches after either\n\t * signed or unsigned extension to long.\n\t *\n\t * To ensure consistent results on 32-bit and 64-bit platforms, make sure\n\t * the error message is the same as if strtoul() had returned ERANGE.\n\t */\n#if OID_MAX != ULONG_MAX\n\tif (cvt != (unsigned long) result &&\n\t\tcvt != (unsigned long) ((int) result))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"value \\\"%s\\\" is out of range for type %s\",\n\t\t\t\t\t\ts, \"oid\")));\n#endif\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/value.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/value.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Oid\noidin_subr(const char *s, char **endloc)\n{\n\tunsigned long cvt;\n\tchar\t   *endptr;\n\tOid\t\t\tresult;\n\n\tif (*s == '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\"oid\", s)));\n\n\terrno = 0;\n\tcvt = strtoul(s, &endptr, 10);\n\n\t/*\n\t * strtoul() normally only sets ERANGE.  On some systems it also may set\n\t * EINVAL, which simply means it couldn't parse the input string. This is\n\t * handled by the second \"if\" consistent across platforms.\n\t */\n\tif (errno && errno != ERANGE && errno != EINVAL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\"oid\", s)));\n\n\tif (endptr == s && *s != '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\"oid\", s)));\n\n\tif (errno == ERANGE)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"value \\\"%s\\\" is out of range for type %s\",\n\t\t\t\t\t\ts, \"oid\")));\n\n\tif (endloc)\n\t{\n\t\t/* caller wants to deal with rest of string */\n\t\t*endloc = endptr;\n\t}\n\telse\n\t{\n\t\t/* allow only whitespace after number */\n\t\twhile (*endptr && isspace((unsigned char) *endptr))\n\t\t\tendptr++;\n\t\tif (*endptr)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\"oid\", s)));\n\t}\n\n\tresult = (Oid) cvt;\n\n\t/*\n\t * Cope with possibility that unsigned long is wider than Oid, in which\n\t * case strtoul will not raise an error for some values that are out of\n\t * the range of Oid.\n\t *\n\t * For backwards compatibility, we want to accept inputs that are given\n\t * with a minus sign, so allow the input value if it matches after either\n\t * signed or unsigned extension to long.\n\t *\n\t * To ensure consistent results on 32-bit and 64-bit platforms, make sure\n\t * the error message is the same as if strtoul() had returned ERANGE.\n\t */\n#if OID_MAX != ULONG_MAX\n\tif (cvt != (unsigned long) result &&\n\t\tcvt != (unsigned long) ((int) result))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"value \\\"%s\\\" is out of range for type %s\",\n\t\t\t\t\t\ts, \"oid\")));\n#endif\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strVal",
          "args": [
            "node"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "intVal",
          "args": [
            "node"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodeTag",
          "args": [
            "node"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/value.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nOid\noidparse(Node *node)\n{\n\tswitch (nodeTag(node))\n\t{\n\t\tcase T_Integer:\n\t\t\treturn intVal(node);\n\t\tcase T_Float:\n\n\t\t\t/*\n\t\t\t * Values too large for int4 will be represented as Float\n\t\t\t * constants by the lexer.  Accept these if they are valid OID\n\t\t\t * strings.\n\t\t\t */\n\t\t\treturn oidin_subr(strVal(node), NULL);\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized node type: %d\", (int) nodeTag(node));\n\t}\n\treturn InvalidOid;\t\t\t/* keep compiler quiet */\n}"
  },
  {
    "function_name": "oidvectorsend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oid.c",
    "lines": "304-308",
    "snippet": "Datum\noidvectorsend(PG_FUNCTION_ARGS)\n{\n\treturn array_send(fcinfo);\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/value.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "array_send",
          "args": [
            "fcinfo"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "array_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "1546-1644",
          "snippet": "Datum\narray_send(PG_FUNCTION_ARGS)\n{\n\tAnyArrayType *v = PG_GETARG_ANY_ARRAY_P(0);\n\tOid\t\t\telement_type = AARR_ELEMTYPE(v);\n\tint\t\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tint\t\t\tnitems,\n\t\t\t\ti;\n\tint\t\t\tndim,\n\t\t\t   *dim,\n\t\t\t   *lb;\n\tStringInfoData buf;\n\tarray_iter\titer;\n\tArrayMetaState *my_extra;\n\n\t/*\n\t * We arrange to look up info about element type, including its send\n\t * conversion proc, only once per series of calls, assuming the element\n\t * type doesn't change underneath us.\n\t */\n\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL)\n\t{\n\t\tfcinfo->flinfo->fn_extra = MemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  sizeof(ArrayMetaState));\n\t\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->element_type = ~element_type;\n\t}\n\n\tif (my_extra->element_type != element_type)\n\t{\n\t\t/* Get info about element type, including its send proc */\n\t\tget_type_io_data(element_type, IOFunc_send,\n\t\t\t\t\t\t &my_extra->typlen, &my_extra->typbyval,\n\t\t\t\t\t\t &my_extra->typalign, &my_extra->typdelim,\n\t\t\t\t\t\t &my_extra->typioparam, &my_extra->typiofunc);\n\t\tif (!OidIsValid(my_extra->typiofunc))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t errmsg(\"no binary output function available for type %s\",\n\t\t\t\t\t\t\tformat_type_be(element_type))));\n\t\tfmgr_info_cxt(my_extra->typiofunc, &my_extra->proc,\n\t\t\t\t\t  fcinfo->flinfo->fn_mcxt);\n\t\tmy_extra->element_type = element_type;\n\t}\n\ttyplen = my_extra->typlen;\n\ttypbyval = my_extra->typbyval;\n\ttypalign = my_extra->typalign;\n\n\tndim = AARR_NDIM(v);\n\tdim = AARR_DIMS(v);\n\tlb = AARR_LBOUND(v);\n\tnitems = ArrayGetNItems(ndim, dim);\n\n\tpq_begintypsend(&buf);\n\n\t/* Send the array header information */\n\tpq_sendint32(&buf, ndim);\n\tpq_sendint32(&buf, AARR_HASNULL(v) ? 1 : 0);\n\tpq_sendint32(&buf, element_type);\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tpq_sendint32(&buf, dim[i]);\n\t\tpq_sendint32(&buf, lb[i]);\n\t}\n\n\t/* Send the array elements using the element's own sendproc */\n\tarray_iter_setup(&iter, v);\n\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tDatum\t\titemvalue;\n\t\tbool\t\tisnull;\n\n\t\t/* Get source element, checking for NULL */\n\t\titemvalue = array_iter_next(&iter, &isnull, i,\n\t\t\t\t\t\t\t\t\ttyplen, typbyval, typalign);\n\n\t\tif (isnull)\n\t\t{\n\t\t\t/* -1 length means a NULL */\n\t\t\tpq_sendint32(&buf, -1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbytea\t   *outputbytes;\n\n\t\t\toutputbytes = SendFunctionCall(&my_extra->proc, itemvalue);\n\t\t\tpq_sendint32(&buf, VARSIZE(outputbytes) - VARHDRSZ);\n\t\t\tpq_sendbytes(&buf, VARDATA(outputbytes),\n\t\t\t\t\t\t VARSIZE(outputbytes) - VARHDRSZ);\n\t\t\tpfree(outputbytes);\n\t\t}\n\t}\n\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tArrayCount(const char *str, int *dim, char typdelim);",
            "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
            "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
            "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
            "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);",
            "static int\tarray_cmp(FunctionCallInfo fcinfo);",
            "static ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);",
            "static ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\tArrayCount(const char *str, int *dim, char typdelim);\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\nstatic int\tarray_cmp(FunctionCallInfo fcinfo);\nstatic ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);\nstatic ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);\n\nDatum\narray_send(PG_FUNCTION_ARGS)\n{\n\tAnyArrayType *v = PG_GETARG_ANY_ARRAY_P(0);\n\tOid\t\t\telement_type = AARR_ELEMTYPE(v);\n\tint\t\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tint\t\t\tnitems,\n\t\t\t\ti;\n\tint\t\t\tndim,\n\t\t\t   *dim,\n\t\t\t   *lb;\n\tStringInfoData buf;\n\tarray_iter\titer;\n\tArrayMetaState *my_extra;\n\n\t/*\n\t * We arrange to look up info about element type, including its send\n\t * conversion proc, only once per series of calls, assuming the element\n\t * type doesn't change underneath us.\n\t */\n\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL)\n\t{\n\t\tfcinfo->flinfo->fn_extra = MemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  sizeof(ArrayMetaState));\n\t\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->element_type = ~element_type;\n\t}\n\n\tif (my_extra->element_type != element_type)\n\t{\n\t\t/* Get info about element type, including its send proc */\n\t\tget_type_io_data(element_type, IOFunc_send,\n\t\t\t\t\t\t &my_extra->typlen, &my_extra->typbyval,\n\t\t\t\t\t\t &my_extra->typalign, &my_extra->typdelim,\n\t\t\t\t\t\t &my_extra->typioparam, &my_extra->typiofunc);\n\t\tif (!OidIsValid(my_extra->typiofunc))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t errmsg(\"no binary output function available for type %s\",\n\t\t\t\t\t\t\tformat_type_be(element_type))));\n\t\tfmgr_info_cxt(my_extra->typiofunc, &my_extra->proc,\n\t\t\t\t\t  fcinfo->flinfo->fn_mcxt);\n\t\tmy_extra->element_type = element_type;\n\t}\n\ttyplen = my_extra->typlen;\n\ttypbyval = my_extra->typbyval;\n\ttypalign = my_extra->typalign;\n\n\tndim = AARR_NDIM(v);\n\tdim = AARR_DIMS(v);\n\tlb = AARR_LBOUND(v);\n\tnitems = ArrayGetNItems(ndim, dim);\n\n\tpq_begintypsend(&buf);\n\n\t/* Send the array header information */\n\tpq_sendint32(&buf, ndim);\n\tpq_sendint32(&buf, AARR_HASNULL(v) ? 1 : 0);\n\tpq_sendint32(&buf, element_type);\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tpq_sendint32(&buf, dim[i]);\n\t\tpq_sendint32(&buf, lb[i]);\n\t}\n\n\t/* Send the array elements using the element's own sendproc */\n\tarray_iter_setup(&iter, v);\n\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tDatum\t\titemvalue;\n\t\tbool\t\tisnull;\n\n\t\t/* Get source element, checking for NULL */\n\t\titemvalue = array_iter_next(&iter, &isnull, i,\n\t\t\t\t\t\t\t\t\ttyplen, typbyval, typalign);\n\n\t\tif (isnull)\n\t\t{\n\t\t\t/* -1 length means a NULL */\n\t\t\tpq_sendint32(&buf, -1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbytea\t   *outputbytes;\n\n\t\t\toutputbytes = SendFunctionCall(&my_extra->proc, itemvalue);\n\t\t\tpq_sendint32(&buf, VARSIZE(outputbytes) - VARHDRSZ);\n\t\t\tpq_sendbytes(&buf, VARDATA(outputbytes),\n\t\t\t\t\t\t VARSIZE(outputbytes) - VARHDRSZ);\n\t\t\tpfree(outputbytes);\n\t\t}\n\t}\n\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/value.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\noidvectorsend(PG_FUNCTION_ARGS)\n{\n\treturn array_send(fcinfo);\n}"
  },
  {
    "function_name": "oidvectorrecv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oid.c",
    "lines": "256-299",
    "snippet": "Datum\noidvectorrecv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\tFunctionCallInfoData locfcinfo;\n\toidvector  *result;\n\n\t/*\n\t * Normally one would call array_recv() using DirectFunctionCall3, but\n\t * that does not work since array_recv wants to cache some data using\n\t * fcinfo->flinfo->fn_extra.  So we need to pass it our own flinfo\n\t * parameter.\n\t */\n\tInitFunctionCallInfoData(locfcinfo, fcinfo->flinfo, 3,\n\t\t\t\t\t\t\t InvalidOid, NULL, NULL);\n\n\tlocfcinfo.arg[0] = PointerGetDatum(buf);\n\tlocfcinfo.arg[1] = ObjectIdGetDatum(OIDOID);\n\tlocfcinfo.arg[2] = Int32GetDatum(-1);\n\tlocfcinfo.argnull[0] = false;\n\tlocfcinfo.argnull[1] = false;\n\tlocfcinfo.argnull[2] = false;\n\n\tresult = (oidvector *) DatumGetPointer(array_recv(&locfcinfo));\n\n\tAssert(!locfcinfo.isnull);\n\n\t/* sanity checks: oidvector must be 1-D, 0-based, no nulls */\n\tif (ARR_NDIM(result) != 1 ||\n\t\tARR_HASNULL(result) ||\n\t\tARR_ELEMTYPE(result) != OIDOID ||\n\t\tARR_LBOUND(result)[0] != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid oidvector data\")));\n\n\t/* check length for consistency with oidvectorin() */\n\tif (ARR_DIMS(result)[0] > FUNC_MAX_ARGS)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"oidvector has too many elements\")));\n\n\tPG_RETURN_POINTER(result);\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/value.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "result"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"oidvector has too many elements\"))"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"oidvector has too many elements\""
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "result"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid oidvector data\"))"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_LBOUND",
          "args": [
            "result"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_ELEMTYPE",
          "args": [
            "result"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_HASNULL",
          "args": [
            "result"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NDIM",
          "args": [
            "result"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!locfcinfo.isnull"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "array_recv(&locfcinfo)"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_recv",
          "args": [
            "&locfcinfo"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "array_recv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "1266-1418",
          "snippet": "Datum\narray_recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\tOid\t\t\tspec_element_type = PG_GETARG_OID(1);\t/* type of an array\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t * element */\n\tint32\t\ttypmod = PG_GETARG_INT32(2);\t/* typmod for array elements */\n\tOid\t\t\telement_type;\n\tint\t\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tOid\t\t\ttypioparam;\n\tint\t\t\ti,\n\t\t\t\tnitems;\n\tDatum\t   *dataPtr;\n\tbool\t   *nullsPtr;\n\tbool\t\thasnulls;\n\tint32\t\tnbytes;\n\tint32\t\tdataoffset;\n\tArrayType  *retval;\n\tint\t\t\tndim,\n\t\t\t\tflags,\n\t\t\t\tdim[MAXDIM],\n\t\t\t\tlBound[MAXDIM];\n\tArrayMetaState *my_extra;\n\n\t/* Get the array header information */\n\tndim = pq_getmsgint(buf, 4);\n\tif (ndim < 0)\t\t\t\t/* we do allow zero-dimension arrays */\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid number of dimensions: %d\", ndim)));\n\tif (ndim > MAXDIM)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"number of array dimensions (%d) exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\tndim, MAXDIM)));\n\n\tflags = pq_getmsgint(buf, 4);\n\tif (flags != 0 && flags != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid array flags\")));\n\n\telement_type = pq_getmsgint(buf, sizeof(Oid));\n\tif (element_type != spec_element_type)\n\t{\n\t\t/* XXX Can we allow taking the input element type in any cases? */\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t errmsg(\"wrong element type\")));\n\t}\n\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tdim[i] = pq_getmsgint(buf, 4);\n\t\tlBound[i] = pq_getmsgint(buf, 4);\n\n\t\t/*\n\t\t * Check overflow of upper bound. (ArrayNItems() below checks that\n\t\t * dim[i] >= 0)\n\t\t */\n\t\tif (dim[i] != 0)\n\t\t{\n\t\t\tint\t\t\tub = lBound[i] + dim[i] - 1;\n\n\t\t\tif (lBound[i] > ub)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"integer out of range\")));\n\t\t}\n\t}\n\n\t/* This checks for overflow of array dimensions */\n\tnitems = ArrayGetNItems(ndim, dim);\n\n\t/*\n\t * We arrange to look up info about element type, including its receive\n\t * conversion proc, only once per series of calls, assuming the element\n\t * type doesn't change underneath us.\n\t */\n\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL)\n\t{\n\t\tfcinfo->flinfo->fn_extra = MemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  sizeof(ArrayMetaState));\n\t\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->element_type = ~element_type;\n\t}\n\n\tif (my_extra->element_type != element_type)\n\t{\n\t\t/* Get info about element type, including its receive proc */\n\t\tget_type_io_data(element_type, IOFunc_receive,\n\t\t\t\t\t\t &my_extra->typlen, &my_extra->typbyval,\n\t\t\t\t\t\t &my_extra->typalign, &my_extra->typdelim,\n\t\t\t\t\t\t &my_extra->typioparam, &my_extra->typiofunc);\n\t\tif (!OidIsValid(my_extra->typiofunc))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t errmsg(\"no binary input function available for type %s\",\n\t\t\t\t\t\t\tformat_type_be(element_type))));\n\t\tfmgr_info_cxt(my_extra->typiofunc, &my_extra->proc,\n\t\t\t\t\t  fcinfo->flinfo->fn_mcxt);\n\t\tmy_extra->element_type = element_type;\n\t}\n\n\tif (nitems == 0)\n\t{\n\t\t/* Return empty array ... but not till we've validated element_type */\n\t\tPG_RETURN_ARRAYTYPE_P(construct_empty_array(element_type));\n\t}\n\n\ttyplen = my_extra->typlen;\n\ttypbyval = my_extra->typbyval;\n\ttypalign = my_extra->typalign;\n\ttypioparam = my_extra->typioparam;\n\n\tdataPtr = (Datum *) palloc(nitems * sizeof(Datum));\n\tnullsPtr = (bool *) palloc(nitems * sizeof(bool));\n\tReadArrayBinary(buf, nitems,\n\t\t\t\t\t&my_extra->proc, typioparam, typmod,\n\t\t\t\t\ttyplen, typbyval, typalign,\n\t\t\t\t\tdataPtr, nullsPtr,\n\t\t\t\t\t&hasnulls, &nbytes);\n\tif (hasnulls)\n\t{\n\t\tdataoffset = ARR_OVERHEAD_WITHNULLS(ndim, nitems);\n\t\tnbytes += dataoffset;\n\t}\n\telse\n\t{\n\t\tdataoffset = 0;\t\t\t/* marker for no null bitmap */\n\t\tnbytes += ARR_OVERHEAD_NONULLS(ndim);\n\t}\n\tretval = (ArrayType *) palloc0(nbytes);\n\tSET_VARSIZE(retval, nbytes);\n\tretval->ndim = ndim;\n\tretval->dataoffset = dataoffset;\n\tretval->elemtype = element_type;\n\tmemcpy(ARR_DIMS(retval), dim, ndim * sizeof(int));\n\tmemcpy(ARR_LBOUND(retval), lBound, ndim * sizeof(int));\n\n\tCopyArrayEls(retval,\n\t\t\t\t dataPtr, nullsPtr, nitems,\n\t\t\t\t typlen, typbyval, typalign,\n\t\t\t\t true);\n\n\tpfree(dataPtr);\n\tpfree(nullsPtr);\n\n\tPG_RETURN_ARRAYTYPE_P(retval);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tArrayCount(const char *str, int *dim, char typdelim);",
            "static void ReadArrayStr(char *arrayStr, const char *origStr,\n\t\t\t int nitems, int ndim, int *dim,\n\t\t\t FmgrInfo *inputproc, Oid typioparam, int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen, bool typbyval, char typalign,\n\t\t\t Datum *values, bool *nulls,\n\t\t\t bool *hasnulls, int32 *nbytes);",
            "static void ReadArrayBinary(StringInfo buf, int nitems,\n\t\t\t\tFmgrInfo *receiveproc, Oid typioparam, int32 typmod,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tDatum *values, bool *nulls,\n\t\t\t\tbool *hasnulls, int32 *nbytes);",
            "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
            "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
            "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
            "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);",
            "static int\tarray_cmp(FunctionCallInfo fcinfo);",
            "static ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);",
            "static ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);",
            "static ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\tArrayCount(const char *str, int *dim, char typdelim);\nstatic void ReadArrayStr(char *arrayStr, const char *origStr,\n\t\t\t int nitems, int ndim, int *dim,\n\t\t\t FmgrInfo *inputproc, Oid typioparam, int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen, bool typbyval, char typalign,\n\t\t\t Datum *values, bool *nulls,\n\t\t\t bool *hasnulls, int32 *nbytes);\nstatic void ReadArrayBinary(StringInfo buf, int nitems,\n\t\t\t\tFmgrInfo *receiveproc, Oid typioparam, int32 typmod,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tDatum *values, bool *nulls,\n\t\t\t\tbool *hasnulls, int32 *nbytes);\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\nstatic int\tarray_cmp(FunctionCallInfo fcinfo);\nstatic ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);\nstatic ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);\nstatic ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);\n\nDatum\narray_recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\tOid\t\t\tspec_element_type = PG_GETARG_OID(1);\t/* type of an array\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t * element */\n\tint32\t\ttypmod = PG_GETARG_INT32(2);\t/* typmod for array elements */\n\tOid\t\t\telement_type;\n\tint\t\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tOid\t\t\ttypioparam;\n\tint\t\t\ti,\n\t\t\t\tnitems;\n\tDatum\t   *dataPtr;\n\tbool\t   *nullsPtr;\n\tbool\t\thasnulls;\n\tint32\t\tnbytes;\n\tint32\t\tdataoffset;\n\tArrayType  *retval;\n\tint\t\t\tndim,\n\t\t\t\tflags,\n\t\t\t\tdim[MAXDIM],\n\t\t\t\tlBound[MAXDIM];\n\tArrayMetaState *my_extra;\n\n\t/* Get the array header information */\n\tndim = pq_getmsgint(buf, 4);\n\tif (ndim < 0)\t\t\t\t/* we do allow zero-dimension arrays */\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid number of dimensions: %d\", ndim)));\n\tif (ndim > MAXDIM)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"number of array dimensions (%d) exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\tndim, MAXDIM)));\n\n\tflags = pq_getmsgint(buf, 4);\n\tif (flags != 0 && flags != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid array flags\")));\n\n\telement_type = pq_getmsgint(buf, sizeof(Oid));\n\tif (element_type != spec_element_type)\n\t{\n\t\t/* XXX Can we allow taking the input element type in any cases? */\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t errmsg(\"wrong element type\")));\n\t}\n\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tdim[i] = pq_getmsgint(buf, 4);\n\t\tlBound[i] = pq_getmsgint(buf, 4);\n\n\t\t/*\n\t\t * Check overflow of upper bound. (ArrayNItems() below checks that\n\t\t * dim[i] >= 0)\n\t\t */\n\t\tif (dim[i] != 0)\n\t\t{\n\t\t\tint\t\t\tub = lBound[i] + dim[i] - 1;\n\n\t\t\tif (lBound[i] > ub)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"integer out of range\")));\n\t\t}\n\t}\n\n\t/* This checks for overflow of array dimensions */\n\tnitems = ArrayGetNItems(ndim, dim);\n\n\t/*\n\t * We arrange to look up info about element type, including its receive\n\t * conversion proc, only once per series of calls, assuming the element\n\t * type doesn't change underneath us.\n\t */\n\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL)\n\t{\n\t\tfcinfo->flinfo->fn_extra = MemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  sizeof(ArrayMetaState));\n\t\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->element_type = ~element_type;\n\t}\n\n\tif (my_extra->element_type != element_type)\n\t{\n\t\t/* Get info about element type, including its receive proc */\n\t\tget_type_io_data(element_type, IOFunc_receive,\n\t\t\t\t\t\t &my_extra->typlen, &my_extra->typbyval,\n\t\t\t\t\t\t &my_extra->typalign, &my_extra->typdelim,\n\t\t\t\t\t\t &my_extra->typioparam, &my_extra->typiofunc);\n\t\tif (!OidIsValid(my_extra->typiofunc))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t errmsg(\"no binary input function available for type %s\",\n\t\t\t\t\t\t\tformat_type_be(element_type))));\n\t\tfmgr_info_cxt(my_extra->typiofunc, &my_extra->proc,\n\t\t\t\t\t  fcinfo->flinfo->fn_mcxt);\n\t\tmy_extra->element_type = element_type;\n\t}\n\n\tif (nitems == 0)\n\t{\n\t\t/* Return empty array ... but not till we've validated element_type */\n\t\tPG_RETURN_ARRAYTYPE_P(construct_empty_array(element_type));\n\t}\n\n\ttyplen = my_extra->typlen;\n\ttypbyval = my_extra->typbyval;\n\ttypalign = my_extra->typalign;\n\ttypioparam = my_extra->typioparam;\n\n\tdataPtr = (Datum *) palloc(nitems * sizeof(Datum));\n\tnullsPtr = (bool *) palloc(nitems * sizeof(bool));\n\tReadArrayBinary(buf, nitems,\n\t\t\t\t\t&my_extra->proc, typioparam, typmod,\n\t\t\t\t\ttyplen, typbyval, typalign,\n\t\t\t\t\tdataPtr, nullsPtr,\n\t\t\t\t\t&hasnulls, &nbytes);\n\tif (hasnulls)\n\t{\n\t\tdataoffset = ARR_OVERHEAD_WITHNULLS(ndim, nitems);\n\t\tnbytes += dataoffset;\n\t}\n\telse\n\t{\n\t\tdataoffset = 0;\t\t\t/* marker for no null bitmap */\n\t\tnbytes += ARR_OVERHEAD_NONULLS(ndim);\n\t}\n\tretval = (ArrayType *) palloc0(nbytes);\n\tSET_VARSIZE(retval, nbytes);\n\tretval->ndim = ndim;\n\tretval->dataoffset = dataoffset;\n\tretval->elemtype = element_type;\n\tmemcpy(ARR_DIMS(retval), dim, ndim * sizeof(int));\n\tmemcpy(ARR_LBOUND(retval), lBound, ndim * sizeof(int));\n\n\tCopyArrayEls(retval,\n\t\t\t\t dataPtr, nullsPtr, nitems,\n\t\t\t\t typlen, typbyval, typalign,\n\t\t\t\t true);\n\n\tpfree(dataPtr);\n\tpfree(nullsPtr);\n\n\tPG_RETURN_ARRAYTYPE_P(retval);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Int32GetDatum",
          "args": [
            "-1"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "OIDOID"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "buf"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InitFunctionCallInfoData",
          "args": [
            "locfcinfo",
            "fcinfo->flinfo",
            "3",
            "InvalidOid",
            "NULL",
            "NULL"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/value.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\noidvectorrecv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\tFunctionCallInfoData locfcinfo;\n\toidvector  *result;\n\n\t/*\n\t * Normally one would call array_recv() using DirectFunctionCall3, but\n\t * that does not work since array_recv wants to cache some data using\n\t * fcinfo->flinfo->fn_extra.  So we need to pass it our own flinfo\n\t * parameter.\n\t */\n\tInitFunctionCallInfoData(locfcinfo, fcinfo->flinfo, 3,\n\t\t\t\t\t\t\t InvalidOid, NULL, NULL);\n\n\tlocfcinfo.arg[0] = PointerGetDatum(buf);\n\tlocfcinfo.arg[1] = ObjectIdGetDatum(OIDOID);\n\tlocfcinfo.arg[2] = Int32GetDatum(-1);\n\tlocfcinfo.argnull[0] = false;\n\tlocfcinfo.argnull[1] = false;\n\tlocfcinfo.argnull[2] = false;\n\n\tresult = (oidvector *) DatumGetPointer(array_recv(&locfcinfo));\n\n\tAssert(!locfcinfo.isnull);\n\n\t/* sanity checks: oidvector must be 1-D, 0-based, no nulls */\n\tif (ARR_NDIM(result) != 1 ||\n\t\tARR_HASNULL(result) ||\n\t\tARR_ELEMTYPE(result) != OIDOID ||\n\t\tARR_LBOUND(result)[0] != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid oidvector data\")));\n\n\t/* check length for consistency with oidvectorin() */\n\tif (ARR_DIMS(result)[0] > FUNC_MAX_ARGS)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"oidvector has too many elements\")));\n\n\tPG_RETURN_POINTER(result);\n}"
  },
  {
    "function_name": "oidvectorout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oid.c",
    "lines": "230-251",
    "snippet": "Datum\noidvectorout(PG_FUNCTION_ARGS)\n{\n\toidvector  *oidArray = (oidvector *) PG_GETARG_POINTER(0);\n\tint\t\t\tnum,\n\t\t\t\tnnums = oidArray->dim1;\n\tchar\t   *rp;\n\tchar\t   *result;\n\n\t/* assumes sign, 10 digits, ' ' */\n\trp = result = (char *) palloc(nnums * 12 + 1);\n\tfor (num = 0; num < nnums; num++)\n\t{\n\t\tif (num != 0)\n\t\t\t*rp++ = ' ';\n\t\tsprintf(rp, \"%u\", oidArray->values[num]);\n\t\twhile (*++rp != '\\0')\n\t\t\t;\n\t}\n\t*rp = '\\0';\n\tPG_RETURN_CSTRING(result);\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/value.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "result"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "rp",
            "\"%u\"",
            "oidArray->values[num]"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "nnums * 12 + 1"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/value.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\noidvectorout(PG_FUNCTION_ARGS)\n{\n\toidvector  *oidArray = (oidvector *) PG_GETARG_POINTER(0);\n\tint\t\t\tnum,\n\t\t\t\tnnums = oidArray->dim1;\n\tchar\t   *rp;\n\tchar\t   *result;\n\n\t/* assumes sign, 10 digits, ' ' */\n\trp = result = (char *) palloc(nnums * 12 + 1);\n\tfor (num = 0; num < nnums; num++)\n\t{\n\t\tif (num != 0)\n\t\t\t*rp++ = ' ';\n\t\tsprintf(rp, \"%u\", oidArray->values[num]);\n\t\twhile (*++rp != '\\0')\n\t\t\t;\n\t}\n\t*rp = '\\0';\n\tPG_RETURN_CSTRING(result);\n}"
  },
  {
    "function_name": "oidvectorin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oid.c",
    "lines": "193-225",
    "snippet": "Datum\noidvectorin(PG_FUNCTION_ARGS)\n{\n\tchar\t   *oidString = PG_GETARG_CSTRING(0);\n\toidvector  *result;\n\tint\t\t\tn;\n\n\tresult = (oidvector *) palloc0(OidVectorSize(FUNC_MAX_ARGS));\n\n\tfor (n = 0; n < FUNC_MAX_ARGS; n++)\n\t{\n\t\twhile (*oidString && isspace((unsigned char) *oidString))\n\t\t\toidString++;\n\t\tif (*oidString == '\\0')\n\t\t\tbreak;\n\t\tresult->values[n] = oidin_subr(oidString, &oidString);\n\t}\n\twhile (*oidString && isspace((unsigned char) *oidString))\n\t\toidString++;\n\tif (*oidString)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"oidvector has too many elements\")));\n\n\tSET_VARSIZE(result, OidVectorSize(n));\n\tresult->ndim = 1;\n\tresult->dataoffset = 0;\t\t/* never any nulls */\n\tresult->elemtype = OIDOID;\n\tresult->dim1 = n;\n\tresult->lbound1 = 0;\n\n\tPG_RETURN_POINTER(result);\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/value.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "result"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "result",
            "OidVectorSize(n)"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidVectorSize",
          "args": [
            "n"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"oidvector has too many elements\"))"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"oidvector has too many elements\""
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "(unsigned char) *oidString"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "array_isspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "431-442",
          "snippet": "static bool\narray_isspace(char ch)\n{\n\tif (ch == ' ' ||\n\t\tch == '\\t' ||\n\t\tch == '\\n' ||\n\t\tch == '\\r' ||\n\t\tch == '\\v' ||\n\t\tch == '\\f')\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool array_isspace(char ch);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool array_isspace(char ch);\n\nstatic bool\narray_isspace(char ch)\n{\n\tif (ch == ' ' ||\n\t\tch == '\\t' ||\n\t\tch == '\\n' ||\n\t\tch == '\\r' ||\n\t\tch == '\\v' ||\n\t\tch == '\\f')\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "oidin_subr",
          "args": [
            "oidString",
            "&oidString"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "oidin_subr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oid.c",
          "lines": "34-114",
          "snippet": "static Oid\noidin_subr(const char *s, char **endloc)\n{\n\tunsigned long cvt;\n\tchar\t   *endptr;\n\tOid\t\t\tresult;\n\n\tif (*s == '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\"oid\", s)));\n\n\terrno = 0;\n\tcvt = strtoul(s, &endptr, 10);\n\n\t/*\n\t * strtoul() normally only sets ERANGE.  On some systems it also may set\n\t * EINVAL, which simply means it couldn't parse the input string. This is\n\t * handled by the second \"if\" consistent across platforms.\n\t */\n\tif (errno && errno != ERANGE && errno != EINVAL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\"oid\", s)));\n\n\tif (endptr == s && *s != '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\"oid\", s)));\n\n\tif (errno == ERANGE)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"value \\\"%s\\\" is out of range for type %s\",\n\t\t\t\t\t\ts, \"oid\")));\n\n\tif (endloc)\n\t{\n\t\t/* caller wants to deal with rest of string */\n\t\t*endloc = endptr;\n\t}\n\telse\n\t{\n\t\t/* allow only whitespace after number */\n\t\twhile (*endptr && isspace((unsigned char) *endptr))\n\t\t\tendptr++;\n\t\tif (*endptr)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\"oid\", s)));\n\t}\n\n\tresult = (Oid) cvt;\n\n\t/*\n\t * Cope with possibility that unsigned long is wider than Oid, in which\n\t * case strtoul will not raise an error for some values that are out of\n\t * the range of Oid.\n\t *\n\t * For backwards compatibility, we want to accept inputs that are given\n\t * with a minus sign, so allow the input value if it matches after either\n\t * signed or unsigned extension to long.\n\t *\n\t * To ensure consistent results on 32-bit and 64-bit platforms, make sure\n\t * the error message is the same as if strtoul() had returned ERANGE.\n\t */\n#if OID_MAX != ULONG_MAX\n\tif (cvt != (unsigned long) result &&\n\t\tcvt != (unsigned long) ((int) result))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"value \\\"%s\\\" is out of range for type %s\",\n\t\t\t\t\t\ts, \"oid\")));\n#endif\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/value.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/value.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Oid\noidin_subr(const char *s, char **endloc)\n{\n\tunsigned long cvt;\n\tchar\t   *endptr;\n\tOid\t\t\tresult;\n\n\tif (*s == '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\"oid\", s)));\n\n\terrno = 0;\n\tcvt = strtoul(s, &endptr, 10);\n\n\t/*\n\t * strtoul() normally only sets ERANGE.  On some systems it also may set\n\t * EINVAL, which simply means it couldn't parse the input string. This is\n\t * handled by the second \"if\" consistent across platforms.\n\t */\n\tif (errno && errno != ERANGE && errno != EINVAL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\"oid\", s)));\n\n\tif (endptr == s && *s != '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\"oid\", s)));\n\n\tif (errno == ERANGE)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"value \\\"%s\\\" is out of range for type %s\",\n\t\t\t\t\t\ts, \"oid\")));\n\n\tif (endloc)\n\t{\n\t\t/* caller wants to deal with rest of string */\n\t\t*endloc = endptr;\n\t}\n\telse\n\t{\n\t\t/* allow only whitespace after number */\n\t\twhile (*endptr && isspace((unsigned char) *endptr))\n\t\t\tendptr++;\n\t\tif (*endptr)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\"oid\", s)));\n\t}\n\n\tresult = (Oid) cvt;\n\n\t/*\n\t * Cope with possibility that unsigned long is wider than Oid, in which\n\t * case strtoul will not raise an error for some values that are out of\n\t * the range of Oid.\n\t *\n\t * For backwards compatibility, we want to accept inputs that are given\n\t * with a minus sign, so allow the input value if it matches after either\n\t * signed or unsigned extension to long.\n\t *\n\t * To ensure consistent results on 32-bit and 64-bit platforms, make sure\n\t * the error message is the same as if strtoul() had returned ERANGE.\n\t */\n#if OID_MAX != ULONG_MAX\n\tif (cvt != (unsigned long) result &&\n\t\tcvt != (unsigned long) ((int) result))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"value \\\"%s\\\" is out of range for type %s\",\n\t\t\t\t\t\ts, \"oid\")));\n#endif\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "OidVectorSize(FUNC_MAX_ARGS)"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidVectorSize",
          "args": [
            "FUNC_MAX_ARGS"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CSTRING",
          "args": [
            "0"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/value.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\noidvectorin(PG_FUNCTION_ARGS)\n{\n\tchar\t   *oidString = PG_GETARG_CSTRING(0);\n\toidvector  *result;\n\tint\t\t\tn;\n\n\tresult = (oidvector *) palloc0(OidVectorSize(FUNC_MAX_ARGS));\n\n\tfor (n = 0; n < FUNC_MAX_ARGS; n++)\n\t{\n\t\twhile (*oidString && isspace((unsigned char) *oidString))\n\t\t\toidString++;\n\t\tif (*oidString == '\\0')\n\t\t\tbreak;\n\t\tresult->values[n] = oidin_subr(oidString, &oidString);\n\t}\n\twhile (*oidString && isspace((unsigned char) *oidString))\n\t\toidString++;\n\tif (*oidString)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"oidvector has too many elements\")));\n\n\tSET_VARSIZE(result, OidVectorSize(n));\n\tresult->ndim = 1;\n\tresult->dataoffset = 0;\t\t/* never any nulls */\n\tresult->elemtype = OIDOID;\n\tresult->dim1 = n;\n\tresult->lbound1 = 0;\n\n\tPG_RETURN_POINTER(result);\n}"
  },
  {
    "function_name": "buildoidvector",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oid.c",
    "lines": "166-188",
    "snippet": "oidvector *\nbuildoidvector(const Oid *oids, int n)\n{\n\toidvector  *result;\n\n\tresult = (oidvector *) palloc0(OidVectorSize(n));\n\n\tif (n > 0 && oids)\n\t\tmemcpy(result->values, oids, n * sizeof(Oid));\n\n\t/*\n\t * Attach standard array header.  For historical reasons, we set the index\n\t * lower bound to 0 not 1.\n\t */\n\tSET_VARSIZE(result, OidVectorSize(n));\n\tresult->ndim = 1;\n\tresult->dataoffset = 0;\t\t/* never any nulls */\n\tresult->elemtype = OIDOID;\n\tresult->dim1 = n;\n\tresult->lbound1 = 0;\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/value.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "result",
            "OidVectorSize(n)"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidVectorSize",
          "args": [
            "n"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "result->values",
            "oids",
            "n * sizeof(Oid)"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "OidVectorSize(n)"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidVectorSize",
          "args": [
            "n"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/value.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\noidvector *\nbuildoidvector(const Oid *oids, int n)\n{\n\toidvector  *result;\n\n\tresult = (oidvector *) palloc0(OidVectorSize(n));\n\n\tif (n > 0 && oids)\n\t\tmemcpy(result->values, oids, n * sizeof(Oid));\n\n\t/*\n\t * Attach standard array header.  For historical reasons, we set the index\n\t * lower bound to 0 not 1.\n\t */\n\tSET_VARSIZE(result, OidVectorSize(n));\n\tresult->ndim = 1;\n\tresult->dataoffset = 0;\t\t/* never any nulls */\n\tresult->elemtype = OIDOID;\n\tresult->dim1 = n;\n\tresult->lbound1 = 0;\n\n\treturn result;\n}"
  },
  {
    "function_name": "oidsend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oid.c",
    "lines": "150-159",
    "snippet": "Datum\noidsend(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\targ1 = PG_GETARG_OID(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendint32(&buf, arg1);\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/value.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BYTEA_P",
          "args": [
            "pq_endtypsend(&buf)"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_endtypsend",
          "args": [
            "&buf"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendint32",
          "args": [
            "&buf",
            "arg1"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_begintypsend",
          "args": [
            "&buf"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "0"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/value.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\noidsend(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\targ1 = PG_GETARG_OID(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendint32(&buf, arg1);\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}"
  },
  {
    "function_name": "oidrecv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oid.c",
    "lines": "139-145",
    "snippet": "Datum\noidrecv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\n\tPG_RETURN_OID((Oid) pq_getmsgint(buf, sizeof(Oid)));\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/value.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_OID",
          "args": [
            "(Oid) pq_getmsgint(buf, sizeof(Oid))"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgint",
          "args": [
            "buf",
            "sizeof(Oid)"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/value.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\noidrecv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\n\tPG_RETURN_OID((Oid) pq_getmsgint(buf, sizeof(Oid)));\n}"
  },
  {
    "function_name": "oidout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oid.c",
    "lines": "126-134",
    "snippet": "Datum\noidout(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\to = PG_GETARG_OID(0);\n\tchar\t   *result = (char *) palloc(12);\n\n\tsnprintf(result, 12, \"%u\", o);\n\tPG_RETURN_CSTRING(result);\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/value.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "result"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "result",
            "12",
            "\"%u\"",
            "o"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "12"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "0"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/value.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\noidout(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\to = PG_GETARG_OID(0);\n\tchar\t   *result = (char *) palloc(12);\n\n\tsnprintf(result, 12, \"%u\", o);\n\tPG_RETURN_CSTRING(result);\n}"
  },
  {
    "function_name": "oidin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oid.c",
    "lines": "116-124",
    "snippet": "Datum\noidin(PG_FUNCTION_ARGS)\n{\n\tchar\t   *s = PG_GETARG_CSTRING(0);\n\tOid\t\t\tresult;\n\n\tresult = oidin_subr(s, NULL);\n\tPG_RETURN_OID(result);\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/value.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_OID",
          "args": [
            "result"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oidin_subr",
          "args": [
            "s",
            "NULL"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "oidin_subr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oid.c",
          "lines": "34-114",
          "snippet": "static Oid\noidin_subr(const char *s, char **endloc)\n{\n\tunsigned long cvt;\n\tchar\t   *endptr;\n\tOid\t\t\tresult;\n\n\tif (*s == '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\"oid\", s)));\n\n\terrno = 0;\n\tcvt = strtoul(s, &endptr, 10);\n\n\t/*\n\t * strtoul() normally only sets ERANGE.  On some systems it also may set\n\t * EINVAL, which simply means it couldn't parse the input string. This is\n\t * handled by the second \"if\" consistent across platforms.\n\t */\n\tif (errno && errno != ERANGE && errno != EINVAL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\"oid\", s)));\n\n\tif (endptr == s && *s != '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\"oid\", s)));\n\n\tif (errno == ERANGE)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"value \\\"%s\\\" is out of range for type %s\",\n\t\t\t\t\t\ts, \"oid\")));\n\n\tif (endloc)\n\t{\n\t\t/* caller wants to deal with rest of string */\n\t\t*endloc = endptr;\n\t}\n\telse\n\t{\n\t\t/* allow only whitespace after number */\n\t\twhile (*endptr && isspace((unsigned char) *endptr))\n\t\t\tendptr++;\n\t\tif (*endptr)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\"oid\", s)));\n\t}\n\n\tresult = (Oid) cvt;\n\n\t/*\n\t * Cope with possibility that unsigned long is wider than Oid, in which\n\t * case strtoul will not raise an error for some values that are out of\n\t * the range of Oid.\n\t *\n\t * For backwards compatibility, we want to accept inputs that are given\n\t * with a minus sign, so allow the input value if it matches after either\n\t * signed or unsigned extension to long.\n\t *\n\t * To ensure consistent results on 32-bit and 64-bit platforms, make sure\n\t * the error message is the same as if strtoul() had returned ERANGE.\n\t */\n#if OID_MAX != ULONG_MAX\n\tif (cvt != (unsigned long) result &&\n\t\tcvt != (unsigned long) ((int) result))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"value \\\"%s\\\" is out of range for type %s\",\n\t\t\t\t\t\ts, \"oid\")));\n#endif\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/value.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/value.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Oid\noidin_subr(const char *s, char **endloc)\n{\n\tunsigned long cvt;\n\tchar\t   *endptr;\n\tOid\t\t\tresult;\n\n\tif (*s == '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\"oid\", s)));\n\n\terrno = 0;\n\tcvt = strtoul(s, &endptr, 10);\n\n\t/*\n\t * strtoul() normally only sets ERANGE.  On some systems it also may set\n\t * EINVAL, which simply means it couldn't parse the input string. This is\n\t * handled by the second \"if\" consistent across platforms.\n\t */\n\tif (errno && errno != ERANGE && errno != EINVAL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\"oid\", s)));\n\n\tif (endptr == s && *s != '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\"oid\", s)));\n\n\tif (errno == ERANGE)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"value \\\"%s\\\" is out of range for type %s\",\n\t\t\t\t\t\ts, \"oid\")));\n\n\tif (endloc)\n\t{\n\t\t/* caller wants to deal with rest of string */\n\t\t*endloc = endptr;\n\t}\n\telse\n\t{\n\t\t/* allow only whitespace after number */\n\t\twhile (*endptr && isspace((unsigned char) *endptr))\n\t\t\tendptr++;\n\t\tif (*endptr)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\"oid\", s)));\n\t}\n\n\tresult = (Oid) cvt;\n\n\t/*\n\t * Cope with possibility that unsigned long is wider than Oid, in which\n\t * case strtoul will not raise an error for some values that are out of\n\t * the range of Oid.\n\t *\n\t * For backwards compatibility, we want to accept inputs that are given\n\t * with a minus sign, so allow the input value if it matches after either\n\t * signed or unsigned extension to long.\n\t *\n\t * To ensure consistent results on 32-bit and 64-bit platforms, make sure\n\t * the error message is the same as if strtoul() had returned ERANGE.\n\t */\n#if OID_MAX != ULONG_MAX\n\tif (cvt != (unsigned long) result &&\n\t\tcvt != (unsigned long) ((int) result))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"value \\\"%s\\\" is out of range for type %s\",\n\t\t\t\t\t\ts, \"oid\")));\n#endif\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CSTRING",
          "args": [
            "0"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/value.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\noidin(PG_FUNCTION_ARGS)\n{\n\tchar\t   *s = PG_GETARG_CSTRING(0);\n\tOid\t\t\tresult;\n\n\tresult = oidin_subr(s, NULL);\n\tPG_RETURN_OID(result);\n}"
  },
  {
    "function_name": "oidin_subr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oid.c",
    "lines": "34-114",
    "snippet": "static Oid\noidin_subr(const char *s, char **endloc)\n{\n\tunsigned long cvt;\n\tchar\t   *endptr;\n\tOid\t\t\tresult;\n\n\tif (*s == '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\"oid\", s)));\n\n\terrno = 0;\n\tcvt = strtoul(s, &endptr, 10);\n\n\t/*\n\t * strtoul() normally only sets ERANGE.  On some systems it also may set\n\t * EINVAL, which simply means it couldn't parse the input string. This is\n\t * handled by the second \"if\" consistent across platforms.\n\t */\n\tif (errno && errno != ERANGE && errno != EINVAL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\"oid\", s)));\n\n\tif (endptr == s && *s != '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\"oid\", s)));\n\n\tif (errno == ERANGE)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"value \\\"%s\\\" is out of range for type %s\",\n\t\t\t\t\t\ts, \"oid\")));\n\n\tif (endloc)\n\t{\n\t\t/* caller wants to deal with rest of string */\n\t\t*endloc = endptr;\n\t}\n\telse\n\t{\n\t\t/* allow only whitespace after number */\n\t\twhile (*endptr && isspace((unsigned char) *endptr))\n\t\t\tendptr++;\n\t\tif (*endptr)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\"oid\", s)));\n\t}\n\n\tresult = (Oid) cvt;\n\n\t/*\n\t * Cope with possibility that unsigned long is wider than Oid, in which\n\t * case strtoul will not raise an error for some values that are out of\n\t * the range of Oid.\n\t *\n\t * For backwards compatibility, we want to accept inputs that are given\n\t * with a minus sign, so allow the input value if it matches after either\n\t * signed or unsigned extension to long.\n\t *\n\t * To ensure consistent results on 32-bit and 64-bit platforms, make sure\n\t * the error message is the same as if strtoul() had returned ERANGE.\n\t */\n#if OID_MAX != ULONG_MAX\n\tif (cvt != (unsigned long) result &&\n\t\tcvt != (unsigned long) ((int) result))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"value \\\"%s\\\" is out of range for type %s\",\n\t\t\t\t\t\ts, \"oid\")));\n#endif\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/value.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"value \\\"%s\\\" is out of range for type %s\",\n\t\t\t\t\t\ts, \"oid\"))"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"value \\\"%s\\\" is out of range for type %s\"",
            "s",
            "\"oid\""
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\"oid\", s))"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "(unsigned char) *endptr"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "array_isspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "431-442",
          "snippet": "static bool\narray_isspace(char ch)\n{\n\tif (ch == ' ' ||\n\t\tch == '\\t' ||\n\t\tch == '\\n' ||\n\t\tch == '\\r' ||\n\t\tch == '\\v' ||\n\t\tch == '\\f')\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool array_isspace(char ch);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool array_isspace(char ch);\n\nstatic bool\narray_isspace(char ch)\n{\n\tif (ch == ' ' ||\n\t\tch == '\\t' ||\n\t\tch == '\\n' ||\n\t\tch == '\\r' ||\n\t\tch == '\\v' ||\n\t\tch == '\\f')\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"value \\\"%s\\\" is out of range for type %s\",\n\t\t\t\t\t\ts, \"oid\"))"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\"oid\", s))"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\"oid\", s))"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "s",
            "&endptr",
            "10"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\"oid\", s))"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/value.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Oid\noidin_subr(const char *s, char **endloc)\n{\n\tunsigned long cvt;\n\tchar\t   *endptr;\n\tOid\t\t\tresult;\n\n\tif (*s == '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\"oid\", s)));\n\n\terrno = 0;\n\tcvt = strtoul(s, &endptr, 10);\n\n\t/*\n\t * strtoul() normally only sets ERANGE.  On some systems it also may set\n\t * EINVAL, which simply means it couldn't parse the input string. This is\n\t * handled by the second \"if\" consistent across platforms.\n\t */\n\tif (errno && errno != ERANGE && errno != EINVAL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\"oid\", s)));\n\n\tif (endptr == s && *s != '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\"oid\", s)));\n\n\tif (errno == ERANGE)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"value \\\"%s\\\" is out of range for type %s\",\n\t\t\t\t\t\ts, \"oid\")));\n\n\tif (endloc)\n\t{\n\t\t/* caller wants to deal with rest of string */\n\t\t*endloc = endptr;\n\t}\n\telse\n\t{\n\t\t/* allow only whitespace after number */\n\t\twhile (*endptr && isspace((unsigned char) *endptr))\n\t\t\tendptr++;\n\t\tif (*endptr)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\"oid\", s)));\n\t}\n\n\tresult = (Oid) cvt;\n\n\t/*\n\t * Cope with possibility that unsigned long is wider than Oid, in which\n\t * case strtoul will not raise an error for some values that are out of\n\t * the range of Oid.\n\t *\n\t * For backwards compatibility, we want to accept inputs that are given\n\t * with a minus sign, so allow the input value if it matches after either\n\t * signed or unsigned extension to long.\n\t *\n\t * To ensure consistent results on 32-bit and 64-bit platforms, make sure\n\t * the error message is the same as if strtoul() had returned ERANGE.\n\t */\n#if OID_MAX != ULONG_MAX\n\tif (cvt != (unsigned long) result &&\n\t\tcvt != (unsigned long) ((int) result))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"value \\\"%s\\\" is out of range for type %s\",\n\t\t\t\t\t\ts, \"oid\")));\n#endif\n\n\treturn result;\n}"
  }
]