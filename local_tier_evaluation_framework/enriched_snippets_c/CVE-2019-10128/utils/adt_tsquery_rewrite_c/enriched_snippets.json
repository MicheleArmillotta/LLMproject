[
  {
    "function_name": "tsquery_rewrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_rewrite.c",
    "lines": "409-462",
    "snippet": "Datum\ntsquery_rewrite(PG_FUNCTION_ARGS)\n{\n\tTSQuery\t\tquery = PG_GETARG_TSQUERY_COPY(0);\n\tTSQuery\t\tex = PG_GETARG_TSQUERY(1);\n\tTSQuery\t\tsubst = PG_GETARG_TSQUERY(2);\n\tTSQuery\t\trewrited = query;\n\tQTNode\t   *tree,\n\t\t\t   *qex,\n\t\t\t   *subs = NULL;\n\n\tif (query->size == 0 || ex->size == 0)\n\t{\n\t\tPG_FREE_IF_COPY(ex, 1);\n\t\tPG_FREE_IF_COPY(subst, 2);\n\t\tPG_RETURN_POINTER(rewrited);\n\t}\n\n\ttree = QT2QTN(GETQUERY(query), GETOPERAND(query));\n\tQTNTernary(tree);\n\tQTNSort(tree);\n\n\tqex = QT2QTN(GETQUERY(ex), GETOPERAND(ex));\n\tQTNTernary(qex);\n\tQTNSort(qex);\n\n\tif (subst->size)\n\t\tsubs = QT2QTN(GETQUERY(subst), GETOPERAND(subst));\n\n\ttree = findsubquery(tree, qex, subs, NULL);\n\n\tQTNFree(qex);\n\tQTNFree(subs);\n\n\tif (!tree)\n\t{\n\t\tSET_VARSIZE(rewrited, HDRSIZETQ);\n\t\trewrited->size = 0;\n\t\tPG_FREE_IF_COPY(ex, 1);\n\t\tPG_FREE_IF_COPY(subst, 2);\n\t\tPG_RETURN_POINTER(rewrited);\n\t}\n\telse\n\t{\n\t\tQTNBinary(tree);\n\t\trewrited = QTN2QT(tree);\n\t\tQTNFree(tree);\n\t}\n\n\tPG_FREE_IF_COPY(query, 0);\n\tPG_FREE_IF_COPY(ex, 1);\n\tPG_FREE_IF_COPY(subst, 2);\n\tPG_RETURN_POINTER(rewrited);\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/spi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "rewrited"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "subst",
            "2"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "ex",
            "1"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "query",
            "0"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QTNFree",
          "args": [
            "tree"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "QTNFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_util.c",
          "lines": "62-88",
          "snippet": "void\nQTNFree(QTNode *in)\n{\n\tif (!in)\n\t\treturn;\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (in->valnode->type == QI_VAL && in->word && (in->flags & QTN_WORDFREE) != 0)\n\t\tpfree(in->word);\n\n\tif (in->valnode->type == QI_OPR)\n\t{\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < in->nchild; i++)\n\t\t\tQTNFree(in->child[i]);\n\t}\n\tif (in->child)\n\t\tpfree(in->child);\n\n\tif (in->flags & QTN_NEEDFREE)\n\t\tpfree(in->valnode);\n\n\tpfree(in);\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nvoid\nQTNFree(QTNode *in)\n{\n\tif (!in)\n\t\treturn;\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (in->valnode->type == QI_VAL && in->word && (in->flags & QTN_WORDFREE) != 0)\n\t\tpfree(in->word);\n\n\tif (in->valnode->type == QI_OPR)\n\t{\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < in->nchild; i++)\n\t\t\tQTNFree(in->child[i]);\n\t}\n\tif (in->child)\n\t\tpfree(in->child);\n\n\tif (in->flags & QTN_NEEDFREE)\n\t\tpfree(in->valnode);\n\n\tpfree(in);\n}"
        }
      },
      {
        "call_info": {
          "callee": "QTN2QT",
          "args": [
            "tree"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "QTN2QT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_util.c",
          "lines": "361-387",
          "snippet": "TSQuery\nQTN2QT(QTNode *in)\n{\n\tTSQuery\t\tout;\n\tint\t\t\tlen;\n\tint\t\t\tsumlen = 0,\n\t\t\t\tnnode = 0;\n\tQTN2QTState state;\n\n\tcntsize(in, &sumlen, &nnode);\n\n\tif (TSQUERY_TOO_BIG(nnode, sumlen))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"tsquery is too large\")));\n\tlen = COMPUTESIZE(nnode, sumlen);\n\n\tout = (TSQuery) palloc0(len);\n\tSET_VARSIZE(out, len);\n\tout->size = nnode;\n\n\tstate.curitem = GETQUERY(out);\n\tstate.operand = state.curoperand = GETOPERAND(out);\n\n\tfillQT(&state, in);\n\treturn out;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nTSQuery\nQTN2QT(QTNode *in)\n{\n\tTSQuery\t\tout;\n\tint\t\t\tlen;\n\tint\t\t\tsumlen = 0,\n\t\t\t\tnnode = 0;\n\tQTN2QTState state;\n\n\tcntsize(in, &sumlen, &nnode);\n\n\tif (TSQUERY_TOO_BIG(nnode, sumlen))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"tsquery is too large\")));\n\tlen = COMPUTESIZE(nnode, sumlen);\n\n\tout = (TSQuery) palloc0(len);\n\tSET_VARSIZE(out, len);\n\tout->size = nnode;\n\n\tstate.curitem = GETQUERY(out);\n\tstate.operand = state.curoperand = GETOPERAND(out);\n\n\tfillQT(&state, in);\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QTNBinary",
          "args": [
            "tree"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "QTNBinary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_util.c",
          "lines": "248-283",
          "snippet": "void\nQTNBinary(QTNode *in)\n{\n\tint\t\t\ti;\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (in->valnode->type != QI_OPR)\n\t\treturn;\n\n\tfor (i = 0; i < in->nchild; i++)\n\t\tQTNBinary(in->child[i]);\n\n\twhile (in->nchild > 2)\n\t{\n\t\tQTNode\t   *nn = (QTNode *) palloc0(sizeof(QTNode));\n\n\t\tnn->valnode = (QueryItem *) palloc0(sizeof(QueryItem));\n\t\tnn->child = (QTNode **) palloc0(sizeof(QTNode *) * 2);\n\n\t\tnn->nchild = 2;\n\t\tnn->flags = QTN_NEEDFREE;\n\n\t\tnn->child[0] = in->child[0];\n\t\tnn->child[1] = in->child[1];\n\t\tnn->sign = nn->child[0]->sign | nn->child[1]->sign;\n\n\t\tnn->valnode->type = in->valnode->type;\n\t\tnn->valnode->qoperator.oper = in->valnode->qoperator.oper;\n\n\t\tin->child[0] = nn;\n\t\tin->child[1] = in->child[in->nchild - 1];\n\t\tin->nchild--;\n\t}\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nvoid\nQTNBinary(QTNode *in)\n{\n\tint\t\t\ti;\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (in->valnode->type != QI_OPR)\n\t\treturn;\n\n\tfor (i = 0; i < in->nchild; i++)\n\t\tQTNBinary(in->child[i]);\n\n\twhile (in->nchild > 2)\n\t{\n\t\tQTNode\t   *nn = (QTNode *) palloc0(sizeof(QTNode));\n\n\t\tnn->valnode = (QueryItem *) palloc0(sizeof(QueryItem));\n\t\tnn->child = (QTNode **) palloc0(sizeof(QTNode *) * 2);\n\n\t\tnn->nchild = 2;\n\t\tnn->flags = QTN_NEEDFREE;\n\n\t\tnn->child[0] = in->child[0];\n\t\tnn->child[1] = in->child[1];\n\t\tnn->sign = nn->child[0]->sign | nn->child[1]->sign;\n\n\t\tnn->valnode->type = in->valnode->type;\n\t\tnn->valnode->qoperator.oper = in->valnode->qoperator.oper;\n\n\t\tin->child[0] = nn;\n\t\tin->child[1] = in->child[in->nchild - 1];\n\t\tin->nchild--;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "rewrited"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "subst",
            "2"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "ex",
            "1"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "rewrited",
            "HDRSIZETQ"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "findsubquery",
          "args": [
            "tree",
            "qex",
            "subs",
            "NULL"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "findsubquery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_rewrite.c",
          "lines": "266-277",
          "snippet": "QTNode *\nfindsubquery(QTNode *root, QTNode *ex, QTNode *subs, bool *isfind)\n{\n\tbool\t\tDidFind = false;\n\n\troot = dofindsubquery(root, ex, subs, &DidFind);\n\n\tif (isfind)\n\t\t*isfind = DidFind;\n\n\treturn root;\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"miscadmin.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nQTNode *\nfindsubquery(QTNode *root, QTNode *ex, QTNode *subs, bool *isfind)\n{\n\tbool\t\tDidFind = false;\n\n\troot = dofindsubquery(root, ex, subs, &DidFind);\n\n\tif (isfind)\n\t\t*isfind = DidFind;\n\n\treturn root;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QT2QTN",
          "args": [
            "GETQUERY(subst)",
            "GETOPERAND(subst)"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "QT2QTN",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_util.c",
          "lines": "23-54",
          "snippet": "QTNode *\nQT2QTN(QueryItem *in, char *operand)\n{\n\tQTNode\t   *node = (QTNode *) palloc0(sizeof(QTNode));\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tnode->valnode = in;\n\n\tif (in->type == QI_OPR)\n\t{\n\t\tnode->child = (QTNode **) palloc0(sizeof(QTNode *) * 2);\n\t\tnode->child[0] = QT2QTN(in + 1, operand);\n\t\tnode->sign = node->child[0]->sign;\n\t\tif (in->qoperator.oper == OP_NOT)\n\t\t\tnode->nchild = 1;\n\t\telse\n\t\t{\n\t\t\tnode->nchild = 2;\n\t\t\tnode->child[1] = QT2QTN(in + in->qoperator.left, operand);\n\t\t\tnode->sign |= node->child[1]->sign;\n\t\t}\n\t}\n\telse if (operand)\n\t{\n\t\tnode->word = operand + in->qoperand.distance;\n\t\tnode->sign = ((uint32) 1) << (((unsigned int) in->qoperand.valcrc) % 32);\n\t}\n\n\treturn node;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nQTNode *\nQT2QTN(QueryItem *in, char *operand)\n{\n\tQTNode\t   *node = (QTNode *) palloc0(sizeof(QTNode));\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tnode->valnode = in;\n\n\tif (in->type == QI_OPR)\n\t{\n\t\tnode->child = (QTNode **) palloc0(sizeof(QTNode *) * 2);\n\t\tnode->child[0] = QT2QTN(in + 1, operand);\n\t\tnode->sign = node->child[0]->sign;\n\t\tif (in->qoperator.oper == OP_NOT)\n\t\t\tnode->nchild = 1;\n\t\telse\n\t\t{\n\t\t\tnode->nchild = 2;\n\t\t\tnode->child[1] = QT2QTN(in + in->qoperator.left, operand);\n\t\t\tnode->sign |= node->child[1]->sign;\n\t\t}\n\t}\n\telse if (operand)\n\t{\n\t\tnode->word = operand + in->qoperand.distance;\n\t\tnode->sign = ((uint32) 1) << (((unsigned int) in->qoperand.valcrc) % 32);\n\t}\n\n\treturn node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GETOPERAND",
          "args": [
            "subst"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETQUERY",
          "args": [
            "subst"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QTNSort",
          "args": [
            "qex"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "QTNSort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_util.c",
          "lines": "161-176",
          "snippet": "void\nQTNSort(QTNode *in)\n{\n\tint\t\t\ti;\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (in->valnode->type != QI_OPR)\n\t\treturn;\n\n\tfor (i = 0; i < in->nchild; i++)\n\t\tQTNSort(in->child[i]);\n\tif (in->nchild > 1 && in->valnode->qoperator.oper != OP_PHRASE)\n\t\tqsort((void *) in->child, in->nchild, sizeof(QTNode *), cmpQTN);\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nvoid\nQTNSort(QTNode *in)\n{\n\tint\t\t\ti;\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (in->valnode->type != QI_OPR)\n\t\treturn;\n\n\tfor (i = 0; i < in->nchild; i++)\n\t\tQTNSort(in->child[i]);\n\tif (in->nchild > 1 && in->valnode->qoperator.oper != OP_PHRASE)\n\t\tqsort((void *) in->child, in->nchild, sizeof(QTNode *), cmpQTN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "QTNTernary",
          "args": [
            "qex"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "QTNTernary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_util.c",
          "lines": "199-242",
          "snippet": "void\nQTNTernary(QTNode *in)\n{\n\tint\t\t\ti;\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (in->valnode->type != QI_OPR)\n\t\treturn;\n\n\tfor (i = 0; i < in->nchild; i++)\n\t\tQTNTernary(in->child[i]);\n\n\t/* Only AND and OR are associative, so don't flatten other node types */\n\tif (in->valnode->qoperator.oper != OP_AND &&\n\t\tin->valnode->qoperator.oper != OP_OR)\n\t\treturn;\n\n\tfor (i = 0; i < in->nchild; i++)\n\t{\n\t\tQTNode\t   *cc = in->child[i];\n\n\t\tif (cc->valnode->type == QI_OPR &&\n\t\t\tin->valnode->qoperator.oper == cc->valnode->qoperator.oper)\n\t\t{\n\t\t\tint\t\t\toldnchild = in->nchild;\n\n\t\t\tin->nchild += cc->nchild - 1;\n\t\t\tin->child = (QTNode **) repalloc(in->child, in->nchild * sizeof(QTNode *));\n\n\t\t\tif (i + 1 != oldnchild)\n\t\t\t\tmemmove(in->child + i + cc->nchild, in->child + i + 1,\n\t\t\t\t\t\t(oldnchild - i - 1) * sizeof(QTNode *));\n\n\t\t\tmemcpy(in->child + i, cc->child, cc->nchild * sizeof(QTNode *));\n\t\t\ti += cc->nchild - 1;\n\n\t\t\tif (cc->flags & QTN_NEEDFREE)\n\t\t\t\tpfree(cc->valnode);\n\t\t\tpfree(cc);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nvoid\nQTNTernary(QTNode *in)\n{\n\tint\t\t\ti;\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (in->valnode->type != QI_OPR)\n\t\treturn;\n\n\tfor (i = 0; i < in->nchild; i++)\n\t\tQTNTernary(in->child[i]);\n\n\t/* Only AND and OR are associative, so don't flatten other node types */\n\tif (in->valnode->qoperator.oper != OP_AND &&\n\t\tin->valnode->qoperator.oper != OP_OR)\n\t\treturn;\n\n\tfor (i = 0; i < in->nchild; i++)\n\t{\n\t\tQTNode\t   *cc = in->child[i];\n\n\t\tif (cc->valnode->type == QI_OPR &&\n\t\t\tin->valnode->qoperator.oper == cc->valnode->qoperator.oper)\n\t\t{\n\t\t\tint\t\t\toldnchild = in->nchild;\n\n\t\t\tin->nchild += cc->nchild - 1;\n\t\t\tin->child = (QTNode **) repalloc(in->child, in->nchild * sizeof(QTNode *));\n\n\t\t\tif (i + 1 != oldnchild)\n\t\t\t\tmemmove(in->child + i + cc->nchild, in->child + i + 1,\n\t\t\t\t\t\t(oldnchild - i - 1) * sizeof(QTNode *));\n\n\t\t\tmemcpy(in->child + i, cc->child, cc->nchild * sizeof(QTNode *));\n\t\t\ti += cc->nchild - 1;\n\n\t\t\tif (cc->flags & QTN_NEEDFREE)\n\t\t\t\tpfree(cc->valnode);\n\t\t\tpfree(cc);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GETOPERAND",
          "args": [
            "ex"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETQUERY",
          "args": [
            "ex"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETOPERAND",
          "args": [
            "query"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETQUERY",
          "args": [
            "query"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "rewrited"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "subst",
            "2"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "ex",
            "1"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TSQUERY",
          "args": [
            "2"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TSQUERY",
          "args": [
            "1"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TSQUERY_COPY",
          "args": [
            "0"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"miscadmin.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nDatum\ntsquery_rewrite(PG_FUNCTION_ARGS)\n{\n\tTSQuery\t\tquery = PG_GETARG_TSQUERY_COPY(0);\n\tTSQuery\t\tex = PG_GETARG_TSQUERY(1);\n\tTSQuery\t\tsubst = PG_GETARG_TSQUERY(2);\n\tTSQuery\t\trewrited = query;\n\tQTNode\t   *tree,\n\t\t\t   *qex,\n\t\t\t   *subs = NULL;\n\n\tif (query->size == 0 || ex->size == 0)\n\t{\n\t\tPG_FREE_IF_COPY(ex, 1);\n\t\tPG_FREE_IF_COPY(subst, 2);\n\t\tPG_RETURN_POINTER(rewrited);\n\t}\n\n\ttree = QT2QTN(GETQUERY(query), GETOPERAND(query));\n\tQTNTernary(tree);\n\tQTNSort(tree);\n\n\tqex = QT2QTN(GETQUERY(ex), GETOPERAND(ex));\n\tQTNTernary(qex);\n\tQTNSort(qex);\n\n\tif (subst->size)\n\t\tsubs = QT2QTN(GETQUERY(subst), GETOPERAND(subst));\n\n\ttree = findsubquery(tree, qex, subs, NULL);\n\n\tQTNFree(qex);\n\tQTNFree(subs);\n\n\tif (!tree)\n\t{\n\t\tSET_VARSIZE(rewrited, HDRSIZETQ);\n\t\trewrited->size = 0;\n\t\tPG_FREE_IF_COPY(ex, 1);\n\t\tPG_FREE_IF_COPY(subst, 2);\n\t\tPG_RETURN_POINTER(rewrited);\n\t}\n\telse\n\t{\n\t\tQTNBinary(tree);\n\t\trewrited = QTN2QT(tree);\n\t\tQTNFree(tree);\n\t}\n\n\tPG_FREE_IF_COPY(query, 0);\n\tPG_FREE_IF_COPY(ex, 1);\n\tPG_FREE_IF_COPY(subst, 2);\n\tPG_RETURN_POINTER(rewrited);\n}"
  },
  {
    "function_name": "tsquery_rewrite_query",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_rewrite.c",
    "lines": "279-407",
    "snippet": "Datum\ntsquery_rewrite_query(PG_FUNCTION_ARGS)\n{\n\tTSQuery\t\tquery = PG_GETARG_TSQUERY_COPY(0);\n\ttext\t   *in = PG_GETARG_TEXT_PP(1);\n\tTSQuery\t\trewrited = query;\n\tMemoryContext outercontext = CurrentMemoryContext;\n\tMemoryContext oldcontext;\n\tQTNode\t   *tree;\n\tchar\t   *buf;\n\tSPIPlanPtr\tplan;\n\tPortal\t\tportal;\n\tbool\t\tisnull;\n\n\tif (query->size == 0)\n\t{\n\t\tPG_FREE_IF_COPY(in, 1);\n\t\tPG_RETURN_POINTER(rewrited);\n\t}\n\n\ttree = QT2QTN(GETQUERY(query), GETOPERAND(query));\n\tQTNTernary(tree);\n\tQTNSort(tree);\n\n\tbuf = text_to_cstring(in);\n\n\tSPI_connect();\n\n\tif ((plan = SPI_prepare(buf, 0, NULL)) == NULL)\n\t\telog(ERROR, \"SPI_prepare(\\\"%s\\\") failed\", buf);\n\n\tif ((portal = SPI_cursor_open(NULL, plan, NULL, NULL, true)) == NULL)\n\t\telog(ERROR, \"SPI_cursor_open(\\\"%s\\\") failed\", buf);\n\n\tSPI_cursor_fetch(portal, true, 100);\n\n\tif (SPI_tuptable == NULL ||\n\t\tSPI_tuptable->tupdesc->natts != 2 ||\n\t\tSPI_gettypeid(SPI_tuptable->tupdesc, 1) != TSQUERYOID ||\n\t\tSPI_gettypeid(SPI_tuptable->tupdesc, 2) != TSQUERYOID)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"ts_rewrite query must return two tsquery columns\")));\n\n\twhile (SPI_processed > 0 && tree)\n\t{\n\t\tuint64\t\ti;\n\n\t\tfor (i = 0; i < SPI_processed && tree; i++)\n\t\t{\n\t\t\tDatum\t\tqdata = SPI_getbinval(SPI_tuptable->vals[i], SPI_tuptable->tupdesc, 1, &isnull);\n\t\t\tDatum\t\tsdata;\n\n\t\t\tif (isnull)\n\t\t\t\tcontinue;\n\n\t\t\tsdata = SPI_getbinval(SPI_tuptable->vals[i], SPI_tuptable->tupdesc, 2, &isnull);\n\n\t\t\tif (!isnull)\n\t\t\t{\n\t\t\t\tTSQuery\t\tqtex = DatumGetTSQuery(qdata);\n\t\t\t\tTSQuery\t\tqtsubs = DatumGetTSQuery(sdata);\n\t\t\t\tQTNode\t   *qex,\n\t\t\t\t\t\t   *qsubs = NULL;\n\n\t\t\t\tif (qtex->size == 0)\n\t\t\t\t{\n\t\t\t\t\tif (qtex != (TSQuery) DatumGetPointer(qdata))\n\t\t\t\t\t\tpfree(qtex);\n\t\t\t\t\tif (qtsubs != (TSQuery) DatumGetPointer(sdata))\n\t\t\t\t\t\tpfree(qtsubs);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tqex = QT2QTN(GETQUERY(qtex), GETOPERAND(qtex));\n\n\t\t\t\tQTNTernary(qex);\n\t\t\t\tQTNSort(qex);\n\n\t\t\t\tif (qtsubs->size)\n\t\t\t\t\tqsubs = QT2QTN(GETQUERY(qtsubs), GETOPERAND(qtsubs));\n\n\t\t\t\toldcontext = MemoryContextSwitchTo(outercontext);\n\t\t\t\ttree = findsubquery(tree, qex, qsubs, NULL);\n\t\t\t\tMemoryContextSwitchTo(oldcontext);\n\n\t\t\t\tQTNFree(qex);\n\t\t\t\tif (qtex != (TSQuery) DatumGetPointer(qdata))\n\t\t\t\t\tpfree(qtex);\n\t\t\t\tQTNFree(qsubs);\n\t\t\t\tif (qtsubs != (TSQuery) DatumGetPointer(sdata))\n\t\t\t\t\tpfree(qtsubs);\n\n\t\t\t\tif (tree)\n\t\t\t\t{\n\t\t\t\t\t/* ready the tree for another pass */\n\t\t\t\t\tQTNClearFlags(tree, QTN_NOCHANGE);\n\t\t\t\t\tQTNTernary(tree);\n\t\t\t\t\tQTNSort(tree);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSPI_freetuptable(SPI_tuptable);\n\t\tSPI_cursor_fetch(portal, true, 100);\n\t}\n\n\tSPI_freetuptable(SPI_tuptable);\n\tSPI_cursor_close(portal);\n\tSPI_freeplan(plan);\n\tSPI_finish();\n\n\tif (tree)\n\t{\n\t\tQTNBinary(tree);\n\t\trewrited = QTN2QT(tree);\n\t\tQTNFree(tree);\n\t\tPG_FREE_IF_COPY(query, 0);\n\t}\n\telse\n\t{\n\t\tSET_VARSIZE(rewrited, HDRSIZETQ);\n\t\trewrited->size = 0;\n\t}\n\n\tpfree(buf);\n\tPG_FREE_IF_COPY(in, 1);\n\tPG_RETURN_POINTER(rewrited);\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/spi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "rewrited"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "in",
            "1"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "buf"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "rewrited",
            "HDRSIZETQ"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "query",
            "0"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QTNFree",
          "args": [
            "tree"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "QTNFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_util.c",
          "lines": "62-88",
          "snippet": "void\nQTNFree(QTNode *in)\n{\n\tif (!in)\n\t\treturn;\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (in->valnode->type == QI_VAL && in->word && (in->flags & QTN_WORDFREE) != 0)\n\t\tpfree(in->word);\n\n\tif (in->valnode->type == QI_OPR)\n\t{\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < in->nchild; i++)\n\t\t\tQTNFree(in->child[i]);\n\t}\n\tif (in->child)\n\t\tpfree(in->child);\n\n\tif (in->flags & QTN_NEEDFREE)\n\t\tpfree(in->valnode);\n\n\tpfree(in);\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nvoid\nQTNFree(QTNode *in)\n{\n\tif (!in)\n\t\treturn;\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (in->valnode->type == QI_VAL && in->word && (in->flags & QTN_WORDFREE) != 0)\n\t\tpfree(in->word);\n\n\tif (in->valnode->type == QI_OPR)\n\t{\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < in->nchild; i++)\n\t\t\tQTNFree(in->child[i]);\n\t}\n\tif (in->child)\n\t\tpfree(in->child);\n\n\tif (in->flags & QTN_NEEDFREE)\n\t\tpfree(in->valnode);\n\n\tpfree(in);\n}"
        }
      },
      {
        "call_info": {
          "callee": "QTN2QT",
          "args": [
            "tree"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "QTN2QT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_util.c",
          "lines": "361-387",
          "snippet": "TSQuery\nQTN2QT(QTNode *in)\n{\n\tTSQuery\t\tout;\n\tint\t\t\tlen;\n\tint\t\t\tsumlen = 0,\n\t\t\t\tnnode = 0;\n\tQTN2QTState state;\n\n\tcntsize(in, &sumlen, &nnode);\n\n\tif (TSQUERY_TOO_BIG(nnode, sumlen))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"tsquery is too large\")));\n\tlen = COMPUTESIZE(nnode, sumlen);\n\n\tout = (TSQuery) palloc0(len);\n\tSET_VARSIZE(out, len);\n\tout->size = nnode;\n\n\tstate.curitem = GETQUERY(out);\n\tstate.operand = state.curoperand = GETOPERAND(out);\n\n\tfillQT(&state, in);\n\treturn out;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nTSQuery\nQTN2QT(QTNode *in)\n{\n\tTSQuery\t\tout;\n\tint\t\t\tlen;\n\tint\t\t\tsumlen = 0,\n\t\t\t\tnnode = 0;\n\tQTN2QTState state;\n\n\tcntsize(in, &sumlen, &nnode);\n\n\tif (TSQUERY_TOO_BIG(nnode, sumlen))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"tsquery is too large\")));\n\tlen = COMPUTESIZE(nnode, sumlen);\n\n\tout = (TSQuery) palloc0(len);\n\tSET_VARSIZE(out, len);\n\tout->size = nnode;\n\n\tstate.curitem = GETQUERY(out);\n\tstate.operand = state.curoperand = GETOPERAND(out);\n\n\tfillQT(&state, in);\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QTNBinary",
          "args": [
            "tree"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "QTNBinary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_util.c",
          "lines": "248-283",
          "snippet": "void\nQTNBinary(QTNode *in)\n{\n\tint\t\t\ti;\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (in->valnode->type != QI_OPR)\n\t\treturn;\n\n\tfor (i = 0; i < in->nchild; i++)\n\t\tQTNBinary(in->child[i]);\n\n\twhile (in->nchild > 2)\n\t{\n\t\tQTNode\t   *nn = (QTNode *) palloc0(sizeof(QTNode));\n\n\t\tnn->valnode = (QueryItem *) palloc0(sizeof(QueryItem));\n\t\tnn->child = (QTNode **) palloc0(sizeof(QTNode *) * 2);\n\n\t\tnn->nchild = 2;\n\t\tnn->flags = QTN_NEEDFREE;\n\n\t\tnn->child[0] = in->child[0];\n\t\tnn->child[1] = in->child[1];\n\t\tnn->sign = nn->child[0]->sign | nn->child[1]->sign;\n\n\t\tnn->valnode->type = in->valnode->type;\n\t\tnn->valnode->qoperator.oper = in->valnode->qoperator.oper;\n\n\t\tin->child[0] = nn;\n\t\tin->child[1] = in->child[in->nchild - 1];\n\t\tin->nchild--;\n\t}\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nvoid\nQTNBinary(QTNode *in)\n{\n\tint\t\t\ti;\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (in->valnode->type != QI_OPR)\n\t\treturn;\n\n\tfor (i = 0; i < in->nchild; i++)\n\t\tQTNBinary(in->child[i]);\n\n\twhile (in->nchild > 2)\n\t{\n\t\tQTNode\t   *nn = (QTNode *) palloc0(sizeof(QTNode));\n\n\t\tnn->valnode = (QueryItem *) palloc0(sizeof(QueryItem));\n\t\tnn->child = (QTNode **) palloc0(sizeof(QTNode *) * 2);\n\n\t\tnn->nchild = 2;\n\t\tnn->flags = QTN_NEEDFREE;\n\n\t\tnn->child[0] = in->child[0];\n\t\tnn->child[1] = in->child[1];\n\t\tnn->sign = nn->child[0]->sign | nn->child[1]->sign;\n\n\t\tnn->valnode->type = in->valnode->type;\n\t\tnn->valnode->qoperator.oper = in->valnode->qoperator.oper;\n\n\t\tin->child[0] = nn;\n\t\tin->child[1] = in->child[in->nchild - 1];\n\t\tin->nchild--;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "SPI_finish",
          "args": [],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPI_freeplan",
          "args": [
            "plan"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPI_cursor_close",
          "args": [
            "portal"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPI_freetuptable",
          "args": [
            "SPI_tuptable"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPI_cursor_fetch",
          "args": [
            "portal",
            "true",
            "100"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPI_freetuptable",
          "args": [
            "SPI_tuptable"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QTNSort",
          "args": [
            "tree"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "QTNSort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_util.c",
          "lines": "161-176",
          "snippet": "void\nQTNSort(QTNode *in)\n{\n\tint\t\t\ti;\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (in->valnode->type != QI_OPR)\n\t\treturn;\n\n\tfor (i = 0; i < in->nchild; i++)\n\t\tQTNSort(in->child[i]);\n\tif (in->nchild > 1 && in->valnode->qoperator.oper != OP_PHRASE)\n\t\tqsort((void *) in->child, in->nchild, sizeof(QTNode *), cmpQTN);\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nvoid\nQTNSort(QTNode *in)\n{\n\tint\t\t\ti;\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (in->valnode->type != QI_OPR)\n\t\treturn;\n\n\tfor (i = 0; i < in->nchild; i++)\n\t\tQTNSort(in->child[i]);\n\tif (in->nchild > 1 && in->valnode->qoperator.oper != OP_PHRASE)\n\t\tqsort((void *) in->child, in->nchild, sizeof(QTNode *), cmpQTN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "QTNTernary",
          "args": [
            "tree"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "QTNTernary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_util.c",
          "lines": "199-242",
          "snippet": "void\nQTNTernary(QTNode *in)\n{\n\tint\t\t\ti;\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (in->valnode->type != QI_OPR)\n\t\treturn;\n\n\tfor (i = 0; i < in->nchild; i++)\n\t\tQTNTernary(in->child[i]);\n\n\t/* Only AND and OR are associative, so don't flatten other node types */\n\tif (in->valnode->qoperator.oper != OP_AND &&\n\t\tin->valnode->qoperator.oper != OP_OR)\n\t\treturn;\n\n\tfor (i = 0; i < in->nchild; i++)\n\t{\n\t\tQTNode\t   *cc = in->child[i];\n\n\t\tif (cc->valnode->type == QI_OPR &&\n\t\t\tin->valnode->qoperator.oper == cc->valnode->qoperator.oper)\n\t\t{\n\t\t\tint\t\t\toldnchild = in->nchild;\n\n\t\t\tin->nchild += cc->nchild - 1;\n\t\t\tin->child = (QTNode **) repalloc(in->child, in->nchild * sizeof(QTNode *));\n\n\t\t\tif (i + 1 != oldnchild)\n\t\t\t\tmemmove(in->child + i + cc->nchild, in->child + i + 1,\n\t\t\t\t\t\t(oldnchild - i - 1) * sizeof(QTNode *));\n\n\t\t\tmemcpy(in->child + i, cc->child, cc->nchild * sizeof(QTNode *));\n\t\t\ti += cc->nchild - 1;\n\n\t\t\tif (cc->flags & QTN_NEEDFREE)\n\t\t\t\tpfree(cc->valnode);\n\t\t\tpfree(cc);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nvoid\nQTNTernary(QTNode *in)\n{\n\tint\t\t\ti;\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (in->valnode->type != QI_OPR)\n\t\treturn;\n\n\tfor (i = 0; i < in->nchild; i++)\n\t\tQTNTernary(in->child[i]);\n\n\t/* Only AND and OR are associative, so don't flatten other node types */\n\tif (in->valnode->qoperator.oper != OP_AND &&\n\t\tin->valnode->qoperator.oper != OP_OR)\n\t\treturn;\n\n\tfor (i = 0; i < in->nchild; i++)\n\t{\n\t\tQTNode\t   *cc = in->child[i];\n\n\t\tif (cc->valnode->type == QI_OPR &&\n\t\t\tin->valnode->qoperator.oper == cc->valnode->qoperator.oper)\n\t\t{\n\t\t\tint\t\t\toldnchild = in->nchild;\n\n\t\t\tin->nchild += cc->nchild - 1;\n\t\t\tin->child = (QTNode **) repalloc(in->child, in->nchild * sizeof(QTNode *));\n\n\t\t\tif (i + 1 != oldnchild)\n\t\t\t\tmemmove(in->child + i + cc->nchild, in->child + i + 1,\n\t\t\t\t\t\t(oldnchild - i - 1) * sizeof(QTNode *));\n\n\t\t\tmemcpy(in->child + i, cc->child, cc->nchild * sizeof(QTNode *));\n\t\t\ti += cc->nchild - 1;\n\n\t\t\tif (cc->flags & QTN_NEEDFREE)\n\t\t\t\tpfree(cc->valnode);\n\t\t\tpfree(cc);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "QTNClearFlags",
          "args": [
            "tree",
            "QTN_NOCHANGE"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "QTNClearFlags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_util.c",
          "lines": "432-447",
          "snippet": "void\nQTNClearFlags(QTNode *in, uint32 flags)\n{\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tin->flags &= ~flags;\n\n\tif (in->valnode->type != QI_VAL)\n\t{\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < in->nchild; i++)\n\t\t\tQTNClearFlags(in->child[i], flags);\n\t}\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nvoid\nQTNClearFlags(QTNode *in, uint32 flags)\n{\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tin->flags &= ~flags;\n\n\tif (in->valnode->type != QI_VAL)\n\t{\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < in->nchild; i++)\n\t\t\tQTNClearFlags(in->child[i], flags);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "sdata"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "qdata"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "findsubquery",
          "args": [
            "tree",
            "qex",
            "qsubs",
            "NULL"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "findsubquery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_rewrite.c",
          "lines": "266-277",
          "snippet": "QTNode *\nfindsubquery(QTNode *root, QTNode *ex, QTNode *subs, bool *isfind)\n{\n\tbool\t\tDidFind = false;\n\n\troot = dofindsubquery(root, ex, subs, &DidFind);\n\n\tif (isfind)\n\t\t*isfind = DidFind;\n\n\treturn root;\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"miscadmin.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nQTNode *\nfindsubquery(QTNode *root, QTNode *ex, QTNode *subs, bool *isfind)\n{\n\tbool\t\tDidFind = false;\n\n\troot = dofindsubquery(root, ex, subs, &DidFind);\n\n\tif (isfind)\n\t\t*isfind = DidFind;\n\n\treturn root;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "outercontext"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QT2QTN",
          "args": [
            "GETQUERY(qtsubs)",
            "GETOPERAND(qtsubs)"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "QT2QTN",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_util.c",
          "lines": "23-54",
          "snippet": "QTNode *\nQT2QTN(QueryItem *in, char *operand)\n{\n\tQTNode\t   *node = (QTNode *) palloc0(sizeof(QTNode));\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tnode->valnode = in;\n\n\tif (in->type == QI_OPR)\n\t{\n\t\tnode->child = (QTNode **) palloc0(sizeof(QTNode *) * 2);\n\t\tnode->child[0] = QT2QTN(in + 1, operand);\n\t\tnode->sign = node->child[0]->sign;\n\t\tif (in->qoperator.oper == OP_NOT)\n\t\t\tnode->nchild = 1;\n\t\telse\n\t\t{\n\t\t\tnode->nchild = 2;\n\t\t\tnode->child[1] = QT2QTN(in + in->qoperator.left, operand);\n\t\t\tnode->sign |= node->child[1]->sign;\n\t\t}\n\t}\n\telse if (operand)\n\t{\n\t\tnode->word = operand + in->qoperand.distance;\n\t\tnode->sign = ((uint32) 1) << (((unsigned int) in->qoperand.valcrc) % 32);\n\t}\n\n\treturn node;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nQTNode *\nQT2QTN(QueryItem *in, char *operand)\n{\n\tQTNode\t   *node = (QTNode *) palloc0(sizeof(QTNode));\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tnode->valnode = in;\n\n\tif (in->type == QI_OPR)\n\t{\n\t\tnode->child = (QTNode **) palloc0(sizeof(QTNode *) * 2);\n\t\tnode->child[0] = QT2QTN(in + 1, operand);\n\t\tnode->sign = node->child[0]->sign;\n\t\tif (in->qoperator.oper == OP_NOT)\n\t\t\tnode->nchild = 1;\n\t\telse\n\t\t{\n\t\t\tnode->nchild = 2;\n\t\t\tnode->child[1] = QT2QTN(in + in->qoperator.left, operand);\n\t\t\tnode->sign |= node->child[1]->sign;\n\t\t}\n\t}\n\telse if (operand)\n\t{\n\t\tnode->word = operand + in->qoperand.distance;\n\t\tnode->sign = ((uint32) 1) << (((unsigned int) in->qoperand.valcrc) % 32);\n\t}\n\n\treturn node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GETOPERAND",
          "args": [
            "qtsubs"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETQUERY",
          "args": [
            "qtsubs"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETOPERAND",
          "args": [
            "qtex"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETQUERY",
          "args": [
            "qtex"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "sdata"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "qdata"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetTSQuery",
          "args": [
            "sdata"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetTSQuery",
          "args": [
            "qdata"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPI_getbinval",
          "args": [
            "SPI_tuptable->vals[i]",
            "SPI_tuptable->tupdesc",
            "2",
            "&isnull"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPI_getbinval",
          "args": [
            "SPI_tuptable->vals[i]",
            "SPI_tuptable->tupdesc",
            "1",
            "&isnull"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"ts_rewrite query must return two tsquery columns\"))"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"ts_rewrite query must return two tsquery columns\""
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "SPI_gettypeid",
          "args": [
            "SPI_tuptable->tupdesc",
            "2"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPI_gettypeid",
          "args": [
            "SPI_tuptable->tupdesc",
            "1"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPI_cursor_fetch",
          "args": [
            "portal",
            "true",
            "100"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"SPI_cursor_open(\\\"%s\\\") failed\"",
            "buf"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SPI_cursor_open",
          "args": [
            "NULL",
            "plan",
            "NULL",
            "NULL",
            "true"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPI_prepare",
          "args": [
            "buf",
            "0",
            "NULL"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPI_connect",
          "args": [],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text_to_cstring",
          "args": [
            "in"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "text_to_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "181-197",
          "snippet": "char *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nchar *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GETOPERAND",
          "args": [
            "query"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETQUERY",
          "args": [
            "query"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "rewrited"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "in",
            "1"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TSQUERY_COPY",
          "args": [
            "0"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"miscadmin.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nDatum\ntsquery_rewrite_query(PG_FUNCTION_ARGS)\n{\n\tTSQuery\t\tquery = PG_GETARG_TSQUERY_COPY(0);\n\ttext\t   *in = PG_GETARG_TEXT_PP(1);\n\tTSQuery\t\trewrited = query;\n\tMemoryContext outercontext = CurrentMemoryContext;\n\tMemoryContext oldcontext;\n\tQTNode\t   *tree;\n\tchar\t   *buf;\n\tSPIPlanPtr\tplan;\n\tPortal\t\tportal;\n\tbool\t\tisnull;\n\n\tif (query->size == 0)\n\t{\n\t\tPG_FREE_IF_COPY(in, 1);\n\t\tPG_RETURN_POINTER(rewrited);\n\t}\n\n\ttree = QT2QTN(GETQUERY(query), GETOPERAND(query));\n\tQTNTernary(tree);\n\tQTNSort(tree);\n\n\tbuf = text_to_cstring(in);\n\n\tSPI_connect();\n\n\tif ((plan = SPI_prepare(buf, 0, NULL)) == NULL)\n\t\telog(ERROR, \"SPI_prepare(\\\"%s\\\") failed\", buf);\n\n\tif ((portal = SPI_cursor_open(NULL, plan, NULL, NULL, true)) == NULL)\n\t\telog(ERROR, \"SPI_cursor_open(\\\"%s\\\") failed\", buf);\n\n\tSPI_cursor_fetch(portal, true, 100);\n\n\tif (SPI_tuptable == NULL ||\n\t\tSPI_tuptable->tupdesc->natts != 2 ||\n\t\tSPI_gettypeid(SPI_tuptable->tupdesc, 1) != TSQUERYOID ||\n\t\tSPI_gettypeid(SPI_tuptable->tupdesc, 2) != TSQUERYOID)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"ts_rewrite query must return two tsquery columns\")));\n\n\twhile (SPI_processed > 0 && tree)\n\t{\n\t\tuint64\t\ti;\n\n\t\tfor (i = 0; i < SPI_processed && tree; i++)\n\t\t{\n\t\t\tDatum\t\tqdata = SPI_getbinval(SPI_tuptable->vals[i], SPI_tuptable->tupdesc, 1, &isnull);\n\t\t\tDatum\t\tsdata;\n\n\t\t\tif (isnull)\n\t\t\t\tcontinue;\n\n\t\t\tsdata = SPI_getbinval(SPI_tuptable->vals[i], SPI_tuptable->tupdesc, 2, &isnull);\n\n\t\t\tif (!isnull)\n\t\t\t{\n\t\t\t\tTSQuery\t\tqtex = DatumGetTSQuery(qdata);\n\t\t\t\tTSQuery\t\tqtsubs = DatumGetTSQuery(sdata);\n\t\t\t\tQTNode\t   *qex,\n\t\t\t\t\t\t   *qsubs = NULL;\n\n\t\t\t\tif (qtex->size == 0)\n\t\t\t\t{\n\t\t\t\t\tif (qtex != (TSQuery) DatumGetPointer(qdata))\n\t\t\t\t\t\tpfree(qtex);\n\t\t\t\t\tif (qtsubs != (TSQuery) DatumGetPointer(sdata))\n\t\t\t\t\t\tpfree(qtsubs);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tqex = QT2QTN(GETQUERY(qtex), GETOPERAND(qtex));\n\n\t\t\t\tQTNTernary(qex);\n\t\t\t\tQTNSort(qex);\n\n\t\t\t\tif (qtsubs->size)\n\t\t\t\t\tqsubs = QT2QTN(GETQUERY(qtsubs), GETOPERAND(qtsubs));\n\n\t\t\t\toldcontext = MemoryContextSwitchTo(outercontext);\n\t\t\t\ttree = findsubquery(tree, qex, qsubs, NULL);\n\t\t\t\tMemoryContextSwitchTo(oldcontext);\n\n\t\t\t\tQTNFree(qex);\n\t\t\t\tif (qtex != (TSQuery) DatumGetPointer(qdata))\n\t\t\t\t\tpfree(qtex);\n\t\t\t\tQTNFree(qsubs);\n\t\t\t\tif (qtsubs != (TSQuery) DatumGetPointer(sdata))\n\t\t\t\t\tpfree(qtsubs);\n\n\t\t\t\tif (tree)\n\t\t\t\t{\n\t\t\t\t\t/* ready the tree for another pass */\n\t\t\t\t\tQTNClearFlags(tree, QTN_NOCHANGE);\n\t\t\t\t\tQTNTernary(tree);\n\t\t\t\t\tQTNSort(tree);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSPI_freetuptable(SPI_tuptable);\n\t\tSPI_cursor_fetch(portal, true, 100);\n\t}\n\n\tSPI_freetuptable(SPI_tuptable);\n\tSPI_cursor_close(portal);\n\tSPI_freeplan(plan);\n\tSPI_finish();\n\n\tif (tree)\n\t{\n\t\tQTNBinary(tree);\n\t\trewrited = QTN2QT(tree);\n\t\tQTNFree(tree);\n\t\tPG_FREE_IF_COPY(query, 0);\n\t}\n\telse\n\t{\n\t\tSET_VARSIZE(rewrited, HDRSIZETQ);\n\t\trewrited->size = 0;\n\t}\n\n\tpfree(buf);\n\tPG_FREE_IF_COPY(in, 1);\n\tPG_RETURN_POINTER(rewrited);\n}"
  },
  {
    "function_name": "findsubquery",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_rewrite.c",
    "lines": "266-277",
    "snippet": "QTNode *\nfindsubquery(QTNode *root, QTNode *ex, QTNode *subs, bool *isfind)\n{\n\tbool\t\tDidFind = false;\n\n\troot = dofindsubquery(root, ex, subs, &DidFind);\n\n\tif (isfind)\n\t\t*isfind = DidFind;\n\n\treturn root;\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/spi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dofindsubquery",
          "args": [
            "root",
            "ex",
            "subs",
            "&DidFind"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "dofindsubquery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_rewrite.c",
          "lines": "205-256",
          "snippet": "static QTNode *\ndofindsubquery(QTNode *root, QTNode *ex, QTNode *subs, bool *isfind)\n{\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\t/* also, since it's a bit expensive, let's check for query cancel. */\n\tCHECK_FOR_INTERRUPTS();\n\n\t/* match at the node itself */\n\troot = findeq(root, ex, subs, isfind);\n\n\t/* unless we matched here, consider matches at child nodes */\n\tif (root && (root->flags & QTN_NOCHANGE) == 0 &&\n\t\troot->valnode->type == QI_OPR)\n\t{\n\t\tint\t\t\ti,\n\t\t\t\t\tj = 0;\n\n\t\t/*\n\t\t * Any subtrees that are replaced by NULL must be dropped from the\n\t\t * tree.\n\t\t */\n\t\tfor (i = 0; i < root->nchild; i++)\n\t\t{\n\t\t\troot->child[j] = dofindsubquery(root->child[i], ex, subs, isfind);\n\t\t\tif (root->child[j])\n\t\t\t\tj++;\n\t\t}\n\n\t\troot->nchild = j;\n\n\t\t/*\n\t\t * If we have just zero or one remaining child node, simplify out this\n\t\t * operator node.\n\t\t */\n\t\tif (root->nchild == 0)\n\t\t{\n\t\t\tQTNFree(root);\n\t\t\troot = NULL;\n\t\t}\n\t\telse if (root->nchild == 1 && root->valnode->qoperator.oper != OP_NOT)\n\t\t{\n\t\t\tQTNode\t   *nroot = root->child[0];\n\n\t\t\tpfree(root);\n\t\t\troot = nroot;\n\t\t}\n\t}\n\n\treturn root;\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"miscadmin.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nstatic QTNode *\ndofindsubquery(QTNode *root, QTNode *ex, QTNode *subs, bool *isfind)\n{\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\t/* also, since it's a bit expensive, let's check for query cancel. */\n\tCHECK_FOR_INTERRUPTS();\n\n\t/* match at the node itself */\n\troot = findeq(root, ex, subs, isfind);\n\n\t/* unless we matched here, consider matches at child nodes */\n\tif (root && (root->flags & QTN_NOCHANGE) == 0 &&\n\t\troot->valnode->type == QI_OPR)\n\t{\n\t\tint\t\t\ti,\n\t\t\t\t\tj = 0;\n\n\t\t/*\n\t\t * Any subtrees that are replaced by NULL must be dropped from the\n\t\t * tree.\n\t\t */\n\t\tfor (i = 0; i < root->nchild; i++)\n\t\t{\n\t\t\troot->child[j] = dofindsubquery(root->child[i], ex, subs, isfind);\n\t\t\tif (root->child[j])\n\t\t\t\tj++;\n\t\t}\n\n\t\troot->nchild = j;\n\n\t\t/*\n\t\t * If we have just zero or one remaining child node, simplify out this\n\t\t * operator node.\n\t\t */\n\t\tif (root->nchild == 0)\n\t\t{\n\t\t\tQTNFree(root);\n\t\t\troot = NULL;\n\t\t}\n\t\telse if (root->nchild == 1 && root->valnode->qoperator.oper != OP_NOT)\n\t\t{\n\t\t\tQTNode\t   *nroot = root->child[0];\n\n\t\t\tpfree(root);\n\t\t\troot = nroot;\n\t\t}\n\t}\n\n\treturn root;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"miscadmin.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nQTNode *\nfindsubquery(QTNode *root, QTNode *ex, QTNode *subs, bool *isfind)\n{\n\tbool\t\tDidFind = false;\n\n\troot = dofindsubquery(root, ex, subs, &DidFind);\n\n\tif (isfind)\n\t\t*isfind = DidFind;\n\n\treturn root;\n}"
  },
  {
    "function_name": "dofindsubquery",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_rewrite.c",
    "lines": "205-256",
    "snippet": "static QTNode *\ndofindsubquery(QTNode *root, QTNode *ex, QTNode *subs, bool *isfind)\n{\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\t/* also, since it's a bit expensive, let's check for query cancel. */\n\tCHECK_FOR_INTERRUPTS();\n\n\t/* match at the node itself */\n\troot = findeq(root, ex, subs, isfind);\n\n\t/* unless we matched here, consider matches at child nodes */\n\tif (root && (root->flags & QTN_NOCHANGE) == 0 &&\n\t\troot->valnode->type == QI_OPR)\n\t{\n\t\tint\t\t\ti,\n\t\t\t\t\tj = 0;\n\n\t\t/*\n\t\t * Any subtrees that are replaced by NULL must be dropped from the\n\t\t * tree.\n\t\t */\n\t\tfor (i = 0; i < root->nchild; i++)\n\t\t{\n\t\t\troot->child[j] = dofindsubquery(root->child[i], ex, subs, isfind);\n\t\t\tif (root->child[j])\n\t\t\t\tj++;\n\t\t}\n\n\t\troot->nchild = j;\n\n\t\t/*\n\t\t * If we have just zero or one remaining child node, simplify out this\n\t\t * operator node.\n\t\t */\n\t\tif (root->nchild == 0)\n\t\t{\n\t\t\tQTNFree(root);\n\t\t\troot = NULL;\n\t\t}\n\t\telse if (root->nchild == 1 && root->valnode->qoperator.oper != OP_NOT)\n\t\t{\n\t\t\tQTNode\t   *nroot = root->child[0];\n\n\t\t\tpfree(root);\n\t\t\troot = nroot;\n\t\t}\n\t}\n\n\treturn root;\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/spi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "root"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "QTNFree",
          "args": [
            "root"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "QTNFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_util.c",
          "lines": "62-88",
          "snippet": "void\nQTNFree(QTNode *in)\n{\n\tif (!in)\n\t\treturn;\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (in->valnode->type == QI_VAL && in->word && (in->flags & QTN_WORDFREE) != 0)\n\t\tpfree(in->word);\n\n\tif (in->valnode->type == QI_OPR)\n\t{\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < in->nchild; i++)\n\t\t\tQTNFree(in->child[i]);\n\t}\n\tif (in->child)\n\t\tpfree(in->child);\n\n\tif (in->flags & QTN_NEEDFREE)\n\t\tpfree(in->valnode);\n\n\tpfree(in);\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nvoid\nQTNFree(QTNode *in)\n{\n\tif (!in)\n\t\treturn;\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (in->valnode->type == QI_VAL && in->word && (in->flags & QTN_WORDFREE) != 0)\n\t\tpfree(in->word);\n\n\tif (in->valnode->type == QI_OPR)\n\t{\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < in->nchild; i++)\n\t\t\tQTNFree(in->child[i]);\n\t}\n\tif (in->child)\n\t\tpfree(in->child);\n\n\tif (in->flags & QTN_NEEDFREE)\n\t\tpfree(in->valnode);\n\n\tpfree(in);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dofindsubquery",
          "args": [
            "root->child[i]",
            "ex",
            "subs",
            "isfind"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "dofindsubquery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_rewrite.c",
          "lines": "205-256",
          "snippet": "static QTNode *\ndofindsubquery(QTNode *root, QTNode *ex, QTNode *subs, bool *isfind)\n{\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\t/* also, since it's a bit expensive, let's check for query cancel. */\n\tCHECK_FOR_INTERRUPTS();\n\n\t/* match at the node itself */\n\troot = findeq(root, ex, subs, isfind);\n\n\t/* unless we matched here, consider matches at child nodes */\n\tif (root && (root->flags & QTN_NOCHANGE) == 0 &&\n\t\troot->valnode->type == QI_OPR)\n\t{\n\t\tint\t\t\ti,\n\t\t\t\t\tj = 0;\n\n\t\t/*\n\t\t * Any subtrees that are replaced by NULL must be dropped from the\n\t\t * tree.\n\t\t */\n\t\tfor (i = 0; i < root->nchild; i++)\n\t\t{\n\t\t\troot->child[j] = dofindsubquery(root->child[i], ex, subs, isfind);\n\t\t\tif (root->child[j])\n\t\t\t\tj++;\n\t\t}\n\n\t\troot->nchild = j;\n\n\t\t/*\n\t\t * If we have just zero or one remaining child node, simplify out this\n\t\t * operator node.\n\t\t */\n\t\tif (root->nchild == 0)\n\t\t{\n\t\t\tQTNFree(root);\n\t\t\troot = NULL;\n\t\t}\n\t\telse if (root->nchild == 1 && root->valnode->qoperator.oper != OP_NOT)\n\t\t{\n\t\t\tQTNode\t   *nroot = root->child[0];\n\n\t\t\tpfree(root);\n\t\t\troot = nroot;\n\t\t}\n\t}\n\n\treturn root;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "findeq",
          "args": [
            "root",
            "ex",
            "subs",
            "isfind"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "findeq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_rewrite.c",
          "lines": "34-189",
          "snippet": "static QTNode *\nfindeq(QTNode *node, QTNode *ex, QTNode *subs, bool *isfind)\n{\n\t/* Can't match unless signature matches and node type matches. */\n\tif ((node->sign & ex->sign) != ex->sign ||\n\t\tnode->valnode->type != ex->valnode->type)\n\t\treturn node;\n\n\t/* Ignore nodes marked NOCHANGE, too. */\n\tif (node->flags & QTN_NOCHANGE)\n\t\treturn node;\n\n\tif (node->valnode->type == QI_OPR)\n\t{\n\t\t/* Must be same operator. */\n\t\tif (node->valnode->qoperator.oper != ex->valnode->qoperator.oper)\n\t\t\treturn node;\n\n\t\tif (node->nchild == ex->nchild)\n\t\t{\n\t\t\t/*\n\t\t\t * Simple case: when same number of children, match if equal.\n\t\t\t * (This is reliable when the children were sorted earlier.)\n\t\t\t */\n\t\t\tif (QTNEq(node, ex))\n\t\t\t{\n\t\t\t\t/* Match; delete node and return a copy of subs instead. */\n\t\t\t\tQTNFree(node);\n\t\t\t\tif (subs)\n\t\t\t\t{\n\t\t\t\t\tnode = QTNCopy(subs);\n\t\t\t\t\tnode->flags |= QTN_NOCHANGE;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tnode = NULL;\n\t\t\t\t*isfind = true;\n\t\t\t}\n\t\t}\n\t\telse if (node->nchild > ex->nchild && ex->nchild > 0)\n\t\t{\n\t\t\t/*\n\t\t\t * AND and OR are commutative/associative, so we should check if a\n\t\t\t * subset of the children match.  For example, if node is A|B|C,\n\t\t\t * and ex is B|C, we have a match after we notionally convert node\n\t\t\t * to A|(B|C).  This does not work for NOT or PHRASE nodes, but we\n\t\t\t * can't get here for those node types because they have a fixed\n\t\t\t * number of children.\n\t\t\t *\n\t\t\t * Because we expect that the children are sorted, it suffices to\n\t\t\t * make one pass through the two lists to find the matches.\n\t\t\t */\n\t\t\tbool\t   *matched;\n\t\t\tint\t\t\tnmatched;\n\t\t\tint\t\t\ti,\n\t\t\t\t\t\tj;\n\n\t\t\t/* Assert that the subset rule is OK */\n\t\t\tAssert(node->valnode->qoperator.oper == OP_AND ||\n\t\t\t\t   node->valnode->qoperator.oper == OP_OR);\n\n\t\t\t/* matched[] will record which children of node matched */\n\t\t\tmatched = (bool *) palloc0(node->nchild * sizeof(bool));\n\t\t\tnmatched = 0;\n\t\t\ti = j = 0;\n\t\t\twhile (i < node->nchild && j < ex->nchild)\n\t\t\t{\n\t\t\t\tint\t\t\tcmp = QTNodeCompare(node->child[i], ex->child[j]);\n\n\t\t\t\tif (cmp == 0)\n\t\t\t\t{\n\t\t\t\t\t/* match! */\n\t\t\t\t\tmatched[i] = true;\n\t\t\t\t\tnmatched++;\n\t\t\t\t\ti++, j++;\n\t\t\t\t}\n\t\t\t\telse if (cmp < 0)\n\t\t\t\t{\n\t\t\t\t\t/* node->child[i] has no match, ignore it */\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* ex->child[j] has no match; we can give up immediately */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (nmatched == ex->nchild)\n\t\t\t{\n\t\t\t\t/* collapse out the matched children of node */\n\t\t\t\tj = 0;\n\t\t\t\tfor (i = 0; i < node->nchild; i++)\n\t\t\t\t{\n\t\t\t\t\tif (matched[i])\n\t\t\t\t\t\tQTNFree(node->child[i]);\n\t\t\t\t\telse\n\t\t\t\t\t\tnode->child[j++] = node->child[i];\n\t\t\t\t}\n\n\t\t\t\t/* and instead insert a copy of subs */\n\t\t\t\tif (subs)\n\t\t\t\t{\n\t\t\t\t\tsubs = QTNCopy(subs);\n\t\t\t\t\tsubs->flags |= QTN_NOCHANGE;\n\t\t\t\t\tnode->child[j++] = subs;\n\t\t\t\t}\n\n\t\t\t\tnode->nchild = j;\n\n\t\t\t\t/*\n\t\t\t\t * At this point we might have a node with zero or one child,\n\t\t\t\t * which should be simplified.  But we leave it to our caller\n\t\t\t\t * (dofindsubquery) to take care of that.\n\t\t\t\t */\n\n\t\t\t\t/*\n\t\t\t\t * Re-sort the node to put new child in the right place.  This\n\t\t\t\t * is a bit bogus, because it won't matter for findsubquery's\n\t\t\t\t * remaining processing, and it's insufficient to prepare the\n\t\t\t\t * tree for another search (we would need to re-flatten as\n\t\t\t\t * well, and we don't want to do that because we'd lose the\n\t\t\t\t * QTN_NOCHANGE marking on the new child).  But it's needed to\n\t\t\t\t * keep the results the same as the regression tests expect.\n\t\t\t\t */\n\t\t\t\tQTNSort(node);\n\n\t\t\t\t*isfind = true;\n\t\t\t}\n\n\t\t\tpfree(matched);\n\t\t}\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_VAL);\n\n\t\tif (node->valnode->qoperand.valcrc != ex->valnode->qoperand.valcrc)\n\t\t\treturn node;\n\t\telse if (QTNEq(node, ex))\n\t\t{\n\t\t\tQTNFree(node);\n\t\t\tif (subs)\n\t\t\t{\n\t\t\t\tnode = QTNCopy(subs);\n\t\t\t\tnode->flags |= QTN_NOCHANGE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnode = NULL;\n\t\t\t}\n\t\t\t*isfind = true;\n\t\t}\n\t}\n\n\treturn node;\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"miscadmin.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nstatic QTNode *\nfindeq(QTNode *node, QTNode *ex, QTNode *subs, bool *isfind)\n{\n\t/* Can't match unless signature matches and node type matches. */\n\tif ((node->sign & ex->sign) != ex->sign ||\n\t\tnode->valnode->type != ex->valnode->type)\n\t\treturn node;\n\n\t/* Ignore nodes marked NOCHANGE, too. */\n\tif (node->flags & QTN_NOCHANGE)\n\t\treturn node;\n\n\tif (node->valnode->type == QI_OPR)\n\t{\n\t\t/* Must be same operator. */\n\t\tif (node->valnode->qoperator.oper != ex->valnode->qoperator.oper)\n\t\t\treturn node;\n\n\t\tif (node->nchild == ex->nchild)\n\t\t{\n\t\t\t/*\n\t\t\t * Simple case: when same number of children, match if equal.\n\t\t\t * (This is reliable when the children were sorted earlier.)\n\t\t\t */\n\t\t\tif (QTNEq(node, ex))\n\t\t\t{\n\t\t\t\t/* Match; delete node and return a copy of subs instead. */\n\t\t\t\tQTNFree(node);\n\t\t\t\tif (subs)\n\t\t\t\t{\n\t\t\t\t\tnode = QTNCopy(subs);\n\t\t\t\t\tnode->flags |= QTN_NOCHANGE;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tnode = NULL;\n\t\t\t\t*isfind = true;\n\t\t\t}\n\t\t}\n\t\telse if (node->nchild > ex->nchild && ex->nchild > 0)\n\t\t{\n\t\t\t/*\n\t\t\t * AND and OR are commutative/associative, so we should check if a\n\t\t\t * subset of the children match.  For example, if node is A|B|C,\n\t\t\t * and ex is B|C, we have a match after we notionally convert node\n\t\t\t * to A|(B|C).  This does not work for NOT or PHRASE nodes, but we\n\t\t\t * can't get here for those node types because they have a fixed\n\t\t\t * number of children.\n\t\t\t *\n\t\t\t * Because we expect that the children are sorted, it suffices to\n\t\t\t * make one pass through the two lists to find the matches.\n\t\t\t */\n\t\t\tbool\t   *matched;\n\t\t\tint\t\t\tnmatched;\n\t\t\tint\t\t\ti,\n\t\t\t\t\t\tj;\n\n\t\t\t/* Assert that the subset rule is OK */\n\t\t\tAssert(node->valnode->qoperator.oper == OP_AND ||\n\t\t\t\t   node->valnode->qoperator.oper == OP_OR);\n\n\t\t\t/* matched[] will record which children of node matched */\n\t\t\tmatched = (bool *) palloc0(node->nchild * sizeof(bool));\n\t\t\tnmatched = 0;\n\t\t\ti = j = 0;\n\t\t\twhile (i < node->nchild && j < ex->nchild)\n\t\t\t{\n\t\t\t\tint\t\t\tcmp = QTNodeCompare(node->child[i], ex->child[j]);\n\n\t\t\t\tif (cmp == 0)\n\t\t\t\t{\n\t\t\t\t\t/* match! */\n\t\t\t\t\tmatched[i] = true;\n\t\t\t\t\tnmatched++;\n\t\t\t\t\ti++, j++;\n\t\t\t\t}\n\t\t\t\telse if (cmp < 0)\n\t\t\t\t{\n\t\t\t\t\t/* node->child[i] has no match, ignore it */\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* ex->child[j] has no match; we can give up immediately */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (nmatched == ex->nchild)\n\t\t\t{\n\t\t\t\t/* collapse out the matched children of node */\n\t\t\t\tj = 0;\n\t\t\t\tfor (i = 0; i < node->nchild; i++)\n\t\t\t\t{\n\t\t\t\t\tif (matched[i])\n\t\t\t\t\t\tQTNFree(node->child[i]);\n\t\t\t\t\telse\n\t\t\t\t\t\tnode->child[j++] = node->child[i];\n\t\t\t\t}\n\n\t\t\t\t/* and instead insert a copy of subs */\n\t\t\t\tif (subs)\n\t\t\t\t{\n\t\t\t\t\tsubs = QTNCopy(subs);\n\t\t\t\t\tsubs->flags |= QTN_NOCHANGE;\n\t\t\t\t\tnode->child[j++] = subs;\n\t\t\t\t}\n\n\t\t\t\tnode->nchild = j;\n\n\t\t\t\t/*\n\t\t\t\t * At this point we might have a node with zero or one child,\n\t\t\t\t * which should be simplified.  But we leave it to our caller\n\t\t\t\t * (dofindsubquery) to take care of that.\n\t\t\t\t */\n\n\t\t\t\t/*\n\t\t\t\t * Re-sort the node to put new child in the right place.  This\n\t\t\t\t * is a bit bogus, because it won't matter for findsubquery's\n\t\t\t\t * remaining processing, and it's insufficient to prepare the\n\t\t\t\t * tree for another search (we would need to re-flatten as\n\t\t\t\t * well, and we don't want to do that because we'd lose the\n\t\t\t\t * QTN_NOCHANGE marking on the new child).  But it's needed to\n\t\t\t\t * keep the results the same as the regression tests expect.\n\t\t\t\t */\n\t\t\t\tQTNSort(node);\n\n\t\t\t\t*isfind = true;\n\t\t\t}\n\n\t\t\tpfree(matched);\n\t\t}\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_VAL);\n\n\t\tif (node->valnode->qoperand.valcrc != ex->valnode->qoperand.valcrc)\n\t\t\treturn node;\n\t\telse if (QTNEq(node, ex))\n\t\t{\n\t\t\tQTNFree(node);\n\t\t\tif (subs)\n\t\t\t{\n\t\t\t\tnode = QTNCopy(subs);\n\t\t\t\tnode->flags |= QTN_NOCHANGE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnode = NULL;\n\t\t\t}\n\t\t\t*isfind = true;\n\t\t}\n\t}\n\n\treturn node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHECK_FOR_INTERRUPTS",
          "args": [],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_stack_depth",
          "args": [],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"miscadmin.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nstatic QTNode *\ndofindsubquery(QTNode *root, QTNode *ex, QTNode *subs, bool *isfind)\n{\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\t/* also, since it's a bit expensive, let's check for query cancel. */\n\tCHECK_FOR_INTERRUPTS();\n\n\t/* match at the node itself */\n\troot = findeq(root, ex, subs, isfind);\n\n\t/* unless we matched here, consider matches at child nodes */\n\tif (root && (root->flags & QTN_NOCHANGE) == 0 &&\n\t\troot->valnode->type == QI_OPR)\n\t{\n\t\tint\t\t\ti,\n\t\t\t\t\tj = 0;\n\n\t\t/*\n\t\t * Any subtrees that are replaced by NULL must be dropped from the\n\t\t * tree.\n\t\t */\n\t\tfor (i = 0; i < root->nchild; i++)\n\t\t{\n\t\t\troot->child[j] = dofindsubquery(root->child[i], ex, subs, isfind);\n\t\t\tif (root->child[j])\n\t\t\t\tj++;\n\t\t}\n\n\t\troot->nchild = j;\n\n\t\t/*\n\t\t * If we have just zero or one remaining child node, simplify out this\n\t\t * operator node.\n\t\t */\n\t\tif (root->nchild == 0)\n\t\t{\n\t\t\tQTNFree(root);\n\t\t\troot = NULL;\n\t\t}\n\t\telse if (root->nchild == 1 && root->valnode->qoperator.oper != OP_NOT)\n\t\t{\n\t\t\tQTNode\t   *nroot = root->child[0];\n\n\t\t\tpfree(root);\n\t\t\troot = nroot;\n\t\t}\n\t}\n\n\treturn root;\n}"
  },
  {
    "function_name": "findeq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_rewrite.c",
    "lines": "34-189",
    "snippet": "static QTNode *\nfindeq(QTNode *node, QTNode *ex, QTNode *subs, bool *isfind)\n{\n\t/* Can't match unless signature matches and node type matches. */\n\tif ((node->sign & ex->sign) != ex->sign ||\n\t\tnode->valnode->type != ex->valnode->type)\n\t\treturn node;\n\n\t/* Ignore nodes marked NOCHANGE, too. */\n\tif (node->flags & QTN_NOCHANGE)\n\t\treturn node;\n\n\tif (node->valnode->type == QI_OPR)\n\t{\n\t\t/* Must be same operator. */\n\t\tif (node->valnode->qoperator.oper != ex->valnode->qoperator.oper)\n\t\t\treturn node;\n\n\t\tif (node->nchild == ex->nchild)\n\t\t{\n\t\t\t/*\n\t\t\t * Simple case: when same number of children, match if equal.\n\t\t\t * (This is reliable when the children were sorted earlier.)\n\t\t\t */\n\t\t\tif (QTNEq(node, ex))\n\t\t\t{\n\t\t\t\t/* Match; delete node and return a copy of subs instead. */\n\t\t\t\tQTNFree(node);\n\t\t\t\tif (subs)\n\t\t\t\t{\n\t\t\t\t\tnode = QTNCopy(subs);\n\t\t\t\t\tnode->flags |= QTN_NOCHANGE;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tnode = NULL;\n\t\t\t\t*isfind = true;\n\t\t\t}\n\t\t}\n\t\telse if (node->nchild > ex->nchild && ex->nchild > 0)\n\t\t{\n\t\t\t/*\n\t\t\t * AND and OR are commutative/associative, so we should check if a\n\t\t\t * subset of the children match.  For example, if node is A|B|C,\n\t\t\t * and ex is B|C, we have a match after we notionally convert node\n\t\t\t * to A|(B|C).  This does not work for NOT or PHRASE nodes, but we\n\t\t\t * can't get here for those node types because they have a fixed\n\t\t\t * number of children.\n\t\t\t *\n\t\t\t * Because we expect that the children are sorted, it suffices to\n\t\t\t * make one pass through the two lists to find the matches.\n\t\t\t */\n\t\t\tbool\t   *matched;\n\t\t\tint\t\t\tnmatched;\n\t\t\tint\t\t\ti,\n\t\t\t\t\t\tj;\n\n\t\t\t/* Assert that the subset rule is OK */\n\t\t\tAssert(node->valnode->qoperator.oper == OP_AND ||\n\t\t\t\t   node->valnode->qoperator.oper == OP_OR);\n\n\t\t\t/* matched[] will record which children of node matched */\n\t\t\tmatched = (bool *) palloc0(node->nchild * sizeof(bool));\n\t\t\tnmatched = 0;\n\t\t\ti = j = 0;\n\t\t\twhile (i < node->nchild && j < ex->nchild)\n\t\t\t{\n\t\t\t\tint\t\t\tcmp = QTNodeCompare(node->child[i], ex->child[j]);\n\n\t\t\t\tif (cmp == 0)\n\t\t\t\t{\n\t\t\t\t\t/* match! */\n\t\t\t\t\tmatched[i] = true;\n\t\t\t\t\tnmatched++;\n\t\t\t\t\ti++, j++;\n\t\t\t\t}\n\t\t\t\telse if (cmp < 0)\n\t\t\t\t{\n\t\t\t\t\t/* node->child[i] has no match, ignore it */\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* ex->child[j] has no match; we can give up immediately */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (nmatched == ex->nchild)\n\t\t\t{\n\t\t\t\t/* collapse out the matched children of node */\n\t\t\t\tj = 0;\n\t\t\t\tfor (i = 0; i < node->nchild; i++)\n\t\t\t\t{\n\t\t\t\t\tif (matched[i])\n\t\t\t\t\t\tQTNFree(node->child[i]);\n\t\t\t\t\telse\n\t\t\t\t\t\tnode->child[j++] = node->child[i];\n\t\t\t\t}\n\n\t\t\t\t/* and instead insert a copy of subs */\n\t\t\t\tif (subs)\n\t\t\t\t{\n\t\t\t\t\tsubs = QTNCopy(subs);\n\t\t\t\t\tsubs->flags |= QTN_NOCHANGE;\n\t\t\t\t\tnode->child[j++] = subs;\n\t\t\t\t}\n\n\t\t\t\tnode->nchild = j;\n\n\t\t\t\t/*\n\t\t\t\t * At this point we might have a node with zero or one child,\n\t\t\t\t * which should be simplified.  But we leave it to our caller\n\t\t\t\t * (dofindsubquery) to take care of that.\n\t\t\t\t */\n\n\t\t\t\t/*\n\t\t\t\t * Re-sort the node to put new child in the right place.  This\n\t\t\t\t * is a bit bogus, because it won't matter for findsubquery's\n\t\t\t\t * remaining processing, and it's insufficient to prepare the\n\t\t\t\t * tree for another search (we would need to re-flatten as\n\t\t\t\t * well, and we don't want to do that because we'd lose the\n\t\t\t\t * QTN_NOCHANGE marking on the new child).  But it's needed to\n\t\t\t\t * keep the results the same as the regression tests expect.\n\t\t\t\t */\n\t\t\t\tQTNSort(node);\n\n\t\t\t\t*isfind = true;\n\t\t\t}\n\n\t\t\tpfree(matched);\n\t\t}\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_VAL);\n\n\t\tif (node->valnode->qoperand.valcrc != ex->valnode->qoperand.valcrc)\n\t\t\treturn node;\n\t\telse if (QTNEq(node, ex))\n\t\t{\n\t\t\tQTNFree(node);\n\t\t\tif (subs)\n\t\t\t{\n\t\t\t\tnode = QTNCopy(subs);\n\t\t\t\tnode->flags |= QTN_NOCHANGE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnode = NULL;\n\t\t\t}\n\t\t\t*isfind = true;\n\t\t}\n\t}\n\n\treturn node;\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/spi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "QTNCopy",
          "args": [
            "subs"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "QTNCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_util.c",
          "lines": "394-427",
          "snippet": "QTNode *\nQTNCopy(QTNode *in)\n{\n\tQTNode\t   *out;\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tout = (QTNode *) palloc(sizeof(QTNode));\n\n\t*out = *in;\n\tout->valnode = (QueryItem *) palloc(sizeof(QueryItem));\n\t*(out->valnode) = *(in->valnode);\n\tout->flags |= QTN_NEEDFREE;\n\n\tif (in->valnode->type == QI_VAL)\n\t{\n\t\tout->word = palloc(in->valnode->qoperand.length + 1);\n\t\tmemcpy(out->word, in->word, in->valnode->qoperand.length);\n\t\tout->word[in->valnode->qoperand.length] = '\\0';\n\t\tout->flags |= QTN_WORDFREE;\n\t}\n\telse\n\t{\n\t\tint\t\t\ti;\n\n\t\tout->child = (QTNode **) palloc(sizeof(QTNode *) * in->nchild);\n\n\t\tfor (i = 0; i < in->nchild; i++)\n\t\t\tout->child[i] = QTNCopy(in->child[i]);\n\t}\n\n\treturn out;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nQTNode *\nQTNCopy(QTNode *in)\n{\n\tQTNode\t   *out;\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tout = (QTNode *) palloc(sizeof(QTNode));\n\n\t*out = *in;\n\tout->valnode = (QueryItem *) palloc(sizeof(QueryItem));\n\t*(out->valnode) = *(in->valnode);\n\tout->flags |= QTN_NEEDFREE;\n\n\tif (in->valnode->type == QI_VAL)\n\t{\n\t\tout->word = palloc(in->valnode->qoperand.length + 1);\n\t\tmemcpy(out->word, in->word, in->valnode->qoperand.length);\n\t\tout->word[in->valnode->qoperand.length] = '\\0';\n\t\tout->flags |= QTN_WORDFREE;\n\t}\n\telse\n\t{\n\t\tint\t\t\ti;\n\n\t\tout->child = (QTNode **) palloc(sizeof(QTNode *) * in->nchild);\n\n\t\tfor (i = 0; i < in->nchild; i++)\n\t\t\tout->child[i] = QTNCopy(in->child[i]);\n\t}\n\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QTNFree",
          "args": [
            "node"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "QTNFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_util.c",
          "lines": "62-88",
          "snippet": "void\nQTNFree(QTNode *in)\n{\n\tif (!in)\n\t\treturn;\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (in->valnode->type == QI_VAL && in->word && (in->flags & QTN_WORDFREE) != 0)\n\t\tpfree(in->word);\n\n\tif (in->valnode->type == QI_OPR)\n\t{\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < in->nchild; i++)\n\t\t\tQTNFree(in->child[i]);\n\t}\n\tif (in->child)\n\t\tpfree(in->child);\n\n\tif (in->flags & QTN_NEEDFREE)\n\t\tpfree(in->valnode);\n\n\tpfree(in);\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nvoid\nQTNFree(QTNode *in)\n{\n\tif (!in)\n\t\treturn;\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (in->valnode->type == QI_VAL && in->word && (in->flags & QTN_WORDFREE) != 0)\n\t\tpfree(in->word);\n\n\tif (in->valnode->type == QI_OPR)\n\t{\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < in->nchild; i++)\n\t\t\tQTNFree(in->child[i]);\n\t}\n\tif (in->child)\n\t\tpfree(in->child);\n\n\tif (in->flags & QTN_NEEDFREE)\n\t\tpfree(in->valnode);\n\n\tpfree(in);\n}"
        }
      },
      {
        "call_info": {
          "callee": "QTNEq",
          "args": [
            "node",
            "ex"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "QTNEq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_util.c",
          "lines": "181-190",
          "snippet": "bool\nQTNEq(QTNode *a, QTNode *b)\n{\n\tuint32\t\tsign = a->sign & b->sign;\n\n\tif (!(sign == a->sign && sign == b->sign))\n\t\treturn false;\n\n\treturn (QTNodeCompare(a, b) == 0) ? true : false;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nbool\nQTNEq(QTNode *a, QTNode *b)\n{\n\tuint32\t\tsign = a->sign & b->sign;\n\n\tif (!(sign == a->sign && sign == b->sign))\n\t\treturn false;\n\n\treturn (QTNodeCompare(a, b) == 0) ? true : false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "node->valnode->type == QI_VAL"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "matched"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "QTNSort",
          "args": [
            "node"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "QTNSort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_util.c",
          "lines": "161-176",
          "snippet": "void\nQTNSort(QTNode *in)\n{\n\tint\t\t\ti;\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (in->valnode->type != QI_OPR)\n\t\treturn;\n\n\tfor (i = 0; i < in->nchild; i++)\n\t\tQTNSort(in->child[i]);\n\tif (in->nchild > 1 && in->valnode->qoperator.oper != OP_PHRASE)\n\t\tqsort((void *) in->child, in->nchild, sizeof(QTNode *), cmpQTN);\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nvoid\nQTNSort(QTNode *in)\n{\n\tint\t\t\ti;\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (in->valnode->type != QI_OPR)\n\t\treturn;\n\n\tfor (i = 0; i < in->nchild; i++)\n\t\tQTNSort(in->child[i]);\n\tif (in->nchild > 1 && in->valnode->qoperator.oper != OP_PHRASE)\n\t\tqsort((void *) in->child, in->nchild, sizeof(QTNode *), cmpQTN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "QTNodeCompare",
          "args": [
            "node->child[i]",
            "ex->child[j]"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "QTNodeCompare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_util.c",
          "lines": "95-146",
          "snippet": "int\nQTNodeCompare(QTNode *an, QTNode *bn)\n{\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (an->valnode->type != bn->valnode->type)\n\t\treturn (an->valnode->type > bn->valnode->type) ? -1 : 1;\n\n\tif (an->valnode->type == QI_OPR)\n\t{\n\t\tQueryOperator *ao = &an->valnode->qoperator;\n\t\tQueryOperator *bo = &bn->valnode->qoperator;\n\n\t\tif (ao->oper != bo->oper)\n\t\t\treturn (ao->oper > bo->oper) ? -1 : 1;\n\n\t\tif (an->nchild != bn->nchild)\n\t\t\treturn (an->nchild > bn->nchild) ? -1 : 1;\n\n\t\t{\n\t\t\tint\t\t\ti,\n\t\t\t\t\t\tres;\n\n\t\t\tfor (i = 0; i < an->nchild; i++)\n\t\t\t\tif ((res = QTNodeCompare(an->child[i], bn->child[i])) != 0)\n\t\t\t\t\treturn res;\n\t\t}\n\n\t\tif (ao->oper == OP_PHRASE && ao->distance != bo->distance)\n\t\t\treturn (ao->distance > bo->distance) ? -1 : 1;\n\n\t\treturn 0;\n\t}\n\telse if (an->valnode->type == QI_VAL)\n\t{\n\t\tQueryOperand *ao = &an->valnode->qoperand;\n\t\tQueryOperand *bo = &bn->valnode->qoperand;\n\n\t\tif (ao->valcrc != bo->valcrc)\n\t\t{\n\t\t\treturn (ao->valcrc > bo->valcrc) ? -1 : 1;\n\t\t}\n\n\t\treturn tsCompareString(an->word, ao->length, bn->word, bo->length, false);\n\t}\n\telse\n\t{\n\t\telog(ERROR, \"unrecognized QueryItem type: %d\", an->valnode->type);\n\t\treturn 0;\t\t\t\t/* keep compiler quiet */\n\t}\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nint\nQTNodeCompare(QTNode *an, QTNode *bn)\n{\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (an->valnode->type != bn->valnode->type)\n\t\treturn (an->valnode->type > bn->valnode->type) ? -1 : 1;\n\n\tif (an->valnode->type == QI_OPR)\n\t{\n\t\tQueryOperator *ao = &an->valnode->qoperator;\n\t\tQueryOperator *bo = &bn->valnode->qoperator;\n\n\t\tif (ao->oper != bo->oper)\n\t\t\treturn (ao->oper > bo->oper) ? -1 : 1;\n\n\t\tif (an->nchild != bn->nchild)\n\t\t\treturn (an->nchild > bn->nchild) ? -1 : 1;\n\n\t\t{\n\t\t\tint\t\t\ti,\n\t\t\t\t\t\tres;\n\n\t\t\tfor (i = 0; i < an->nchild; i++)\n\t\t\t\tif ((res = QTNodeCompare(an->child[i], bn->child[i])) != 0)\n\t\t\t\t\treturn res;\n\t\t}\n\n\t\tif (ao->oper == OP_PHRASE && ao->distance != bo->distance)\n\t\t\treturn (ao->distance > bo->distance) ? -1 : 1;\n\n\t\treturn 0;\n\t}\n\telse if (an->valnode->type == QI_VAL)\n\t{\n\t\tQueryOperand *ao = &an->valnode->qoperand;\n\t\tQueryOperand *bo = &bn->valnode->qoperand;\n\n\t\tif (ao->valcrc != bo->valcrc)\n\t\t{\n\t\t\treturn (ao->valcrc > bo->valcrc) ? -1 : 1;\n\t\t}\n\n\t\treturn tsCompareString(an->word, ao->length, bn->word, bo->length, false);\n\t}\n\telse\n\t{\n\t\telog(ERROR, \"unrecognized QueryItem type: %d\", an->valnode->type);\n\t\treturn 0;\t\t\t\t/* keep compiler quiet */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "node->nchild * sizeof(bool)"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "node->valnode->qoperator.oper == OP_AND ||\n\t\t\t\t   node->valnode->qoperator.oper == OP_OR"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"miscadmin.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nstatic QTNode *\nfindeq(QTNode *node, QTNode *ex, QTNode *subs, bool *isfind)\n{\n\t/* Can't match unless signature matches and node type matches. */\n\tif ((node->sign & ex->sign) != ex->sign ||\n\t\tnode->valnode->type != ex->valnode->type)\n\t\treturn node;\n\n\t/* Ignore nodes marked NOCHANGE, too. */\n\tif (node->flags & QTN_NOCHANGE)\n\t\treturn node;\n\n\tif (node->valnode->type == QI_OPR)\n\t{\n\t\t/* Must be same operator. */\n\t\tif (node->valnode->qoperator.oper != ex->valnode->qoperator.oper)\n\t\t\treturn node;\n\n\t\tif (node->nchild == ex->nchild)\n\t\t{\n\t\t\t/*\n\t\t\t * Simple case: when same number of children, match if equal.\n\t\t\t * (This is reliable when the children were sorted earlier.)\n\t\t\t */\n\t\t\tif (QTNEq(node, ex))\n\t\t\t{\n\t\t\t\t/* Match; delete node and return a copy of subs instead. */\n\t\t\t\tQTNFree(node);\n\t\t\t\tif (subs)\n\t\t\t\t{\n\t\t\t\t\tnode = QTNCopy(subs);\n\t\t\t\t\tnode->flags |= QTN_NOCHANGE;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tnode = NULL;\n\t\t\t\t*isfind = true;\n\t\t\t}\n\t\t}\n\t\telse if (node->nchild > ex->nchild && ex->nchild > 0)\n\t\t{\n\t\t\t/*\n\t\t\t * AND and OR are commutative/associative, so we should check if a\n\t\t\t * subset of the children match.  For example, if node is A|B|C,\n\t\t\t * and ex is B|C, we have a match after we notionally convert node\n\t\t\t * to A|(B|C).  This does not work for NOT or PHRASE nodes, but we\n\t\t\t * can't get here for those node types because they have a fixed\n\t\t\t * number of children.\n\t\t\t *\n\t\t\t * Because we expect that the children are sorted, it suffices to\n\t\t\t * make one pass through the two lists to find the matches.\n\t\t\t */\n\t\t\tbool\t   *matched;\n\t\t\tint\t\t\tnmatched;\n\t\t\tint\t\t\ti,\n\t\t\t\t\t\tj;\n\n\t\t\t/* Assert that the subset rule is OK */\n\t\t\tAssert(node->valnode->qoperator.oper == OP_AND ||\n\t\t\t\t   node->valnode->qoperator.oper == OP_OR);\n\n\t\t\t/* matched[] will record which children of node matched */\n\t\t\tmatched = (bool *) palloc0(node->nchild * sizeof(bool));\n\t\t\tnmatched = 0;\n\t\t\ti = j = 0;\n\t\t\twhile (i < node->nchild && j < ex->nchild)\n\t\t\t{\n\t\t\t\tint\t\t\tcmp = QTNodeCompare(node->child[i], ex->child[j]);\n\n\t\t\t\tif (cmp == 0)\n\t\t\t\t{\n\t\t\t\t\t/* match! */\n\t\t\t\t\tmatched[i] = true;\n\t\t\t\t\tnmatched++;\n\t\t\t\t\ti++, j++;\n\t\t\t\t}\n\t\t\t\telse if (cmp < 0)\n\t\t\t\t{\n\t\t\t\t\t/* node->child[i] has no match, ignore it */\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* ex->child[j] has no match; we can give up immediately */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (nmatched == ex->nchild)\n\t\t\t{\n\t\t\t\t/* collapse out the matched children of node */\n\t\t\t\tj = 0;\n\t\t\t\tfor (i = 0; i < node->nchild; i++)\n\t\t\t\t{\n\t\t\t\t\tif (matched[i])\n\t\t\t\t\t\tQTNFree(node->child[i]);\n\t\t\t\t\telse\n\t\t\t\t\t\tnode->child[j++] = node->child[i];\n\t\t\t\t}\n\n\t\t\t\t/* and instead insert a copy of subs */\n\t\t\t\tif (subs)\n\t\t\t\t{\n\t\t\t\t\tsubs = QTNCopy(subs);\n\t\t\t\t\tsubs->flags |= QTN_NOCHANGE;\n\t\t\t\t\tnode->child[j++] = subs;\n\t\t\t\t}\n\n\t\t\t\tnode->nchild = j;\n\n\t\t\t\t/*\n\t\t\t\t * At this point we might have a node with zero or one child,\n\t\t\t\t * which should be simplified.  But we leave it to our caller\n\t\t\t\t * (dofindsubquery) to take care of that.\n\t\t\t\t */\n\n\t\t\t\t/*\n\t\t\t\t * Re-sort the node to put new child in the right place.  This\n\t\t\t\t * is a bit bogus, because it won't matter for findsubquery's\n\t\t\t\t * remaining processing, and it's insufficient to prepare the\n\t\t\t\t * tree for another search (we would need to re-flatten as\n\t\t\t\t * well, and we don't want to do that because we'd lose the\n\t\t\t\t * QTN_NOCHANGE marking on the new child).  But it's needed to\n\t\t\t\t * keep the results the same as the regression tests expect.\n\t\t\t\t */\n\t\t\t\tQTNSort(node);\n\n\t\t\t\t*isfind = true;\n\t\t\t}\n\n\t\t\tpfree(matched);\n\t\t}\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_VAL);\n\n\t\tif (node->valnode->qoperand.valcrc != ex->valnode->qoperand.valcrc)\n\t\t\treturn node;\n\t\telse if (QTNEq(node, ex))\n\t\t{\n\t\t\tQTNFree(node);\n\t\t\tif (subs)\n\t\t\t{\n\t\t\t\tnode = QTNCopy(subs);\n\t\t\t\tnode->flags |= QTN_NOCHANGE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnode = NULL;\n\t\t\t}\n\t\t\t*isfind = true;\n\t\t}\n\t}\n\n\treturn node;\n}"
  }
]