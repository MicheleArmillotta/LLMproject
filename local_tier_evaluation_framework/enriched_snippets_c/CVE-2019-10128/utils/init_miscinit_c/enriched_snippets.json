[
  {
    "function_name": "pg_bindtextdomain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
    "lines": "1606-1619",
    "snippet": "void\npg_bindtextdomain(const char *domain)\n{\n#ifdef ENABLE_NLS\n\tif (my_exec_path[0] != '\\0')\n\t{\n\t\tchar\t\tlocale_path[MAXPGPATH];\n\n\t\tget_locale_path(my_exec_path, locale_path);\n\t\tbindtextdomain(domain, locale_path);\n\t\tpg_bind_textdomain_codeset(domain);\n\t}\n#endif\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pidfile.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/pg_shmem.h\"",
      "#include \"storage/latch.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/fd.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"postmaster/autovacuum.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"common/file_perm.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/htup_details.h\"",
      "#include <utime.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <sys/param.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pg_bind_textdomain_codeset",
          "args": [
            "domain"
          ],
          "line": 1616
        },
        "resolved": true,
        "details": {
          "function_name": "pg_bind_textdomain_codeset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "968-995",
          "snippet": "int\npg_bind_textdomain_codeset(const char *domainname)\n{\n\tbool\t\telog_ok = (CurrentMemoryContext != NULL);\n\tint\t\t\tencoding = GetDatabaseEncoding();\n\tint\t\t\tnew_msgenc;\n\n#ifndef WIN32\n\tconst char *ctype = setlocale(LC_CTYPE, NULL);\n\n\tif (pg_strcasecmp(ctype, \"C\") == 0 || pg_strcasecmp(ctype, \"POSIX\") == 0)\n#endif\n\t\tif (encoding != PG_SQL_ASCII &&\n\t\t\traw_pg_bind_textdomain_codeset(domainname, encoding))\n\t\t\treturn encoding;\n\n\tnew_msgenc = pg_get_encoding_from_locale(NULL, elog_ok);\n\tif (new_msgenc < 0)\n\t\tnew_msgenc = PG_SQL_ASCII;\n\n#ifdef WIN32\n\tif (!raw_pg_bind_textdomain_codeset(domainname, new_msgenc))\n\t\t/* On failure, the old message encoding remains valid. */\n\t\treturn GetMessageEncoding();\n#endif\n\n\treturn new_msgenc;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nint\npg_bind_textdomain_codeset(const char *domainname)\n{\n\tbool\t\telog_ok = (CurrentMemoryContext != NULL);\n\tint\t\t\tencoding = GetDatabaseEncoding();\n\tint\t\t\tnew_msgenc;\n\n#ifndef WIN32\n\tconst char *ctype = setlocale(LC_CTYPE, NULL);\n\n\tif (pg_strcasecmp(ctype, \"C\") == 0 || pg_strcasecmp(ctype, \"POSIX\") == 0)\n#endif\n\t\tif (encoding != PG_SQL_ASCII &&\n\t\t\traw_pg_bind_textdomain_codeset(domainname, encoding))\n\t\t\treturn encoding;\n\n\tnew_msgenc = pg_get_encoding_from_locale(NULL, elog_ok);\n\tif (new_msgenc < 0)\n\t\tnew_msgenc = PG_SQL_ASCII;\n\n#ifdef WIN32\n\tif (!raw_pg_bind_textdomain_codeset(domainname, new_msgenc))\n\t\t/* On failure, the old message encoding remains valid. */\n\t\treturn GetMessageEncoding();\n#endif\n\n\treturn new_msgenc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bindtextdomain",
          "args": [
            "domain",
            "locale_path"
          ],
          "line": 1615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_locale_path",
          "args": [
            "my_exec_path",
            "locale_path"
          ],
          "line": 1614
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nvoid\npg_bindtextdomain(const char *domain)\n{\n#ifdef ENABLE_NLS\n\tif (my_exec_path[0] != '\\0')\n\t{\n\t\tchar\t\tlocale_path[MAXPGPATH];\n\n\t\tget_locale_path(my_exec_path, locale_path);\n\t\tbindtextdomain(domain, locale_path);\n\t\tpg_bind_textdomain_codeset(domain);\n\t}\n#endif\n}"
  },
  {
    "function_name": "process_session_preload_libraries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
    "lines": "1595-1604",
    "snippet": "void\nprocess_session_preload_libraries(void)\n{\n\tload_libraries(session_preload_libraries_string,\n\t\t\t\t   \"session_preload_libraries\",\n\t\t\t\t   false);\n\tload_libraries(local_preload_libraries_string,\n\t\t\t\t   \"local_preload_libraries\",\n\t\t\t\t   true);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pidfile.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/pg_shmem.h\"",
      "#include \"storage/latch.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/fd.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"postmaster/autovacuum.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"common/file_perm.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/htup_details.h\"",
      "#include <utime.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <sys/param.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char\t   *session_preload_libraries_string = NULL;",
      "char\t   *local_preload_libraries_string = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "load_libraries",
          "args": [
            "local_preload_libraries_string",
            "\"local_preload_libraries\"",
            "true"
          ],
          "line": 1601
        },
        "resolved": true,
        "details": {
          "function_name": "load_libraries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
          "lines": "1530-1577",
          "snippet": "static void\nload_libraries(const char *libraries, const char *gucname, bool restricted)\n{\n\tchar\t   *rawstring;\n\tList\t   *elemlist;\n\tListCell   *l;\n\n\tif (libraries == NULL || libraries[0] == '\\0')\n\t\treturn;\t\t\t\t\t/* nothing to do */\n\n\t/* Need a modifiable copy of string */\n\trawstring = pstrdup(libraries);\n\n\t/* Parse string into list of filename paths */\n\tif (!SplitDirectoriesString(rawstring, ',', &elemlist))\n\t{\n\t\t/* syntax error in list */\n\t\tlist_free_deep(elemlist);\n\t\tpfree(rawstring);\n\t\tereport(LOG,\n\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t errmsg(\"invalid list syntax in parameter \\\"%s\\\"\",\n\t\t\t\t\t\tgucname)));\n\t\treturn;\n\t}\n\n\tforeach(l, elemlist)\n\t{\n\t\t/* Note that filename was already canonicalized */\n\t\tchar\t   *filename = (char *) lfirst(l);\n\t\tchar\t   *expanded = NULL;\n\n\t\t/* If restricting, insert $libdir/plugins if not mentioned already */\n\t\tif (restricted && first_dir_separator(filename) == NULL)\n\t\t{\n\t\t\texpanded = psprintf(\"$libdir/plugins/%s\", filename);\n\t\t\tfilename = expanded;\n\t\t}\n\t\tload_file(filename, restricted);\n\t\tereport(DEBUG1,\n\t\t\t\t(errmsg(\"loaded library \\\"%s\\\"\", filename)));\n\t\tif (expanded)\n\t\t\tpfree(expanded);\n\t}\n\n\tlist_free_deep(elemlist);\n\tpfree(rawstring);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pidfile.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pg_shmem.h\"",
            "#include \"storage/latch.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/fd.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"common/file_perm.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/htup_details.h\"",
            "#include <utime.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/param.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nstatic void\nload_libraries(const char *libraries, const char *gucname, bool restricted)\n{\n\tchar\t   *rawstring;\n\tList\t   *elemlist;\n\tListCell   *l;\n\n\tif (libraries == NULL || libraries[0] == '\\0')\n\t\treturn;\t\t\t\t\t/* nothing to do */\n\n\t/* Need a modifiable copy of string */\n\trawstring = pstrdup(libraries);\n\n\t/* Parse string into list of filename paths */\n\tif (!SplitDirectoriesString(rawstring, ',', &elemlist))\n\t{\n\t\t/* syntax error in list */\n\t\tlist_free_deep(elemlist);\n\t\tpfree(rawstring);\n\t\tereport(LOG,\n\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t errmsg(\"invalid list syntax in parameter \\\"%s\\\"\",\n\t\t\t\t\t\tgucname)));\n\t\treturn;\n\t}\n\n\tforeach(l, elemlist)\n\t{\n\t\t/* Note that filename was already canonicalized */\n\t\tchar\t   *filename = (char *) lfirst(l);\n\t\tchar\t   *expanded = NULL;\n\n\t\t/* If restricting, insert $libdir/plugins if not mentioned already */\n\t\tif (restricted && first_dir_separator(filename) == NULL)\n\t\t{\n\t\t\texpanded = psprintf(\"$libdir/plugins/%s\", filename);\n\t\t\tfilename = expanded;\n\t\t}\n\t\tload_file(filename, restricted);\n\t\tereport(DEBUG1,\n\t\t\t\t(errmsg(\"loaded library \\\"%s\\\"\", filename)));\n\t\tif (expanded)\n\t\t\tpfree(expanded);\n\t}\n\n\tlist_free_deep(elemlist);\n\tpfree(rawstring);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nchar\t   *session_preload_libraries_string = NULL;\nchar\t   *local_preload_libraries_string = NULL;\n\nvoid\nprocess_session_preload_libraries(void)\n{\n\tload_libraries(session_preload_libraries_string,\n\t\t\t\t   \"session_preload_libraries\",\n\t\t\t\t   false);\n\tload_libraries(local_preload_libraries_string,\n\t\t\t\t   \"local_preload_libraries\",\n\t\t\t\t   true);\n}"
  },
  {
    "function_name": "process_shared_preload_libraries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
    "lines": "1582-1590",
    "snippet": "void\nprocess_shared_preload_libraries(void)\n{\n\tprocess_shared_preload_libraries_in_progress = true;\n\tload_libraries(shared_preload_libraries_string,\n\t\t\t\t   \"shared_preload_libraries\",\n\t\t\t\t   false);\n\tprocess_shared_preload_libraries_in_progress = false;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pidfile.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/pg_shmem.h\"",
      "#include \"storage/latch.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/fd.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"postmaster/autovacuum.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"common/file_perm.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/htup_details.h\"",
      "#include <utime.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <sys/param.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char\t   *shared_preload_libraries_string = NULL;",
      "bool\t\tprocess_shared_preload_libraries_in_progress = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "load_libraries",
          "args": [
            "shared_preload_libraries_string",
            "\"shared_preload_libraries\"",
            "false"
          ],
          "line": 1586
        },
        "resolved": true,
        "details": {
          "function_name": "load_libraries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
          "lines": "1530-1577",
          "snippet": "static void\nload_libraries(const char *libraries, const char *gucname, bool restricted)\n{\n\tchar\t   *rawstring;\n\tList\t   *elemlist;\n\tListCell   *l;\n\n\tif (libraries == NULL || libraries[0] == '\\0')\n\t\treturn;\t\t\t\t\t/* nothing to do */\n\n\t/* Need a modifiable copy of string */\n\trawstring = pstrdup(libraries);\n\n\t/* Parse string into list of filename paths */\n\tif (!SplitDirectoriesString(rawstring, ',', &elemlist))\n\t{\n\t\t/* syntax error in list */\n\t\tlist_free_deep(elemlist);\n\t\tpfree(rawstring);\n\t\tereport(LOG,\n\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t errmsg(\"invalid list syntax in parameter \\\"%s\\\"\",\n\t\t\t\t\t\tgucname)));\n\t\treturn;\n\t}\n\n\tforeach(l, elemlist)\n\t{\n\t\t/* Note that filename was already canonicalized */\n\t\tchar\t   *filename = (char *) lfirst(l);\n\t\tchar\t   *expanded = NULL;\n\n\t\t/* If restricting, insert $libdir/plugins if not mentioned already */\n\t\tif (restricted && first_dir_separator(filename) == NULL)\n\t\t{\n\t\t\texpanded = psprintf(\"$libdir/plugins/%s\", filename);\n\t\t\tfilename = expanded;\n\t\t}\n\t\tload_file(filename, restricted);\n\t\tereport(DEBUG1,\n\t\t\t\t(errmsg(\"loaded library \\\"%s\\\"\", filename)));\n\t\tif (expanded)\n\t\t\tpfree(expanded);\n\t}\n\n\tlist_free_deep(elemlist);\n\tpfree(rawstring);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pidfile.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pg_shmem.h\"",
            "#include \"storage/latch.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/fd.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"common/file_perm.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/htup_details.h\"",
            "#include <utime.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/param.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nstatic void\nload_libraries(const char *libraries, const char *gucname, bool restricted)\n{\n\tchar\t   *rawstring;\n\tList\t   *elemlist;\n\tListCell   *l;\n\n\tif (libraries == NULL || libraries[0] == '\\0')\n\t\treturn;\t\t\t\t\t/* nothing to do */\n\n\t/* Need a modifiable copy of string */\n\trawstring = pstrdup(libraries);\n\n\t/* Parse string into list of filename paths */\n\tif (!SplitDirectoriesString(rawstring, ',', &elemlist))\n\t{\n\t\t/* syntax error in list */\n\t\tlist_free_deep(elemlist);\n\t\tpfree(rawstring);\n\t\tereport(LOG,\n\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t errmsg(\"invalid list syntax in parameter \\\"%s\\\"\",\n\t\t\t\t\t\tgucname)));\n\t\treturn;\n\t}\n\n\tforeach(l, elemlist)\n\t{\n\t\t/* Note that filename was already canonicalized */\n\t\tchar\t   *filename = (char *) lfirst(l);\n\t\tchar\t   *expanded = NULL;\n\n\t\t/* If restricting, insert $libdir/plugins if not mentioned already */\n\t\tif (restricted && first_dir_separator(filename) == NULL)\n\t\t{\n\t\t\texpanded = psprintf(\"$libdir/plugins/%s\", filename);\n\t\t\tfilename = expanded;\n\t\t}\n\t\tload_file(filename, restricted);\n\t\tereport(DEBUG1,\n\t\t\t\t(errmsg(\"loaded library \\\"%s\\\"\", filename)));\n\t\tif (expanded)\n\t\t\tpfree(expanded);\n\t}\n\n\tlist_free_deep(elemlist);\n\tpfree(rawstring);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nchar\t   *shared_preload_libraries_string = NULL;\nbool\t\tprocess_shared_preload_libraries_in_progress = false;\n\nvoid\nprocess_shared_preload_libraries(void)\n{\n\tprocess_shared_preload_libraries_in_progress = true;\n\tload_libraries(shared_preload_libraries_string,\n\t\t\t\t   \"shared_preload_libraries\",\n\t\t\t\t   false);\n\tprocess_shared_preload_libraries_in_progress = false;\n}"
  },
  {
    "function_name": "load_libraries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
    "lines": "1530-1577",
    "snippet": "static void\nload_libraries(const char *libraries, const char *gucname, bool restricted)\n{\n\tchar\t   *rawstring;\n\tList\t   *elemlist;\n\tListCell   *l;\n\n\tif (libraries == NULL || libraries[0] == '\\0')\n\t\treturn;\t\t\t\t\t/* nothing to do */\n\n\t/* Need a modifiable copy of string */\n\trawstring = pstrdup(libraries);\n\n\t/* Parse string into list of filename paths */\n\tif (!SplitDirectoriesString(rawstring, ',', &elemlist))\n\t{\n\t\t/* syntax error in list */\n\t\tlist_free_deep(elemlist);\n\t\tpfree(rawstring);\n\t\tereport(LOG,\n\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t errmsg(\"invalid list syntax in parameter \\\"%s\\\"\",\n\t\t\t\t\t\tgucname)));\n\t\treturn;\n\t}\n\n\tforeach(l, elemlist)\n\t{\n\t\t/* Note that filename was already canonicalized */\n\t\tchar\t   *filename = (char *) lfirst(l);\n\t\tchar\t   *expanded = NULL;\n\n\t\t/* If restricting, insert $libdir/plugins if not mentioned already */\n\t\tif (restricted && first_dir_separator(filename) == NULL)\n\t\t{\n\t\t\texpanded = psprintf(\"$libdir/plugins/%s\", filename);\n\t\t\tfilename = expanded;\n\t\t}\n\t\tload_file(filename, restricted);\n\t\tereport(DEBUG1,\n\t\t\t\t(errmsg(\"loaded library \\\"%s\\\"\", filename)));\n\t\tif (expanded)\n\t\t\tpfree(expanded);\n\t}\n\n\tlist_free_deep(elemlist);\n\tpfree(rawstring);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pidfile.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/pg_shmem.h\"",
      "#include \"storage/latch.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/fd.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"postmaster/autovacuum.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"common/file_perm.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/htup_details.h\"",
      "#include <utime.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <sys/param.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "rawstring"
          ],
          "line": 1576
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_free_deep",
          "args": [
            "elemlist"
          ],
          "line": 1575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "DEBUG1",
            "(errmsg(\"loaded library \\\"%s\\\"\", filename))"
          ],
          "line": 1569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"loaded library \\\"%s\\\"\"",
            "filename"
          ],
          "line": 1570
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_file",
          "args": [
            "filename",
            "restricted"
          ],
          "line": 1568
        },
        "resolved": true,
        "details": {
          "function_name": "load_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/dfmgr.c",
          "lines": "136-155",
          "snippet": "void\nload_file(const char *filename, bool restricted)\n{\n\tchar\t   *fullname;\n\n\t/* Apply security restriction if requested */\n\tif (restricted)\n\t\tcheck_restricted_library_name(filename);\n\n\t/* Expand the possibly-abbreviated filename to an exact path name */\n\tfullname = expand_dynamic_library_name(filename);\n\n\t/* Unload the library if currently loaded */\n\tinternal_unload_library(fullname);\n\n\t/* Load the shared library */\n\t(void) internal_load_library(fullname);\n\n\tpfree(fullname);\n}",
          "includes": [
            "#include \"utils/hsearch.h\"",
            "#include \"utils/dynamic_loader.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"dynloader.h\"",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool file_exists(const char *name);",
            "static char *expand_dynamic_library_name(const char *name);",
            "static void check_restricted_library_name(const char *name);",
            "static char *substitute_libpath_macro(const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/hsearch.h\"\n#include \"utils/dynamic_loader.h\"\n#include \"storage/shmem.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"dynloader.h\"\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic bool file_exists(const char *name);\nstatic char *expand_dynamic_library_name(const char *name);\nstatic void check_restricted_library_name(const char *name);\nstatic char *substitute_libpath_macro(const char *name);\n\nvoid\nload_file(const char *filename, bool restricted)\n{\n\tchar\t   *fullname;\n\n\t/* Apply security restriction if requested */\n\tif (restricted)\n\t\tcheck_restricted_library_name(filename);\n\n\t/* Expand the possibly-abbreviated filename to an exact path name */\n\tfullname = expand_dynamic_library_name(filename);\n\n\t/* Unload the library if currently loaded */\n\tinternal_unload_library(fullname);\n\n\t/* Load the shared library */\n\t(void) internal_load_library(fullname);\n\n\tpfree(fullname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "psprintf",
          "args": [
            "\"$libdir/plugins/%s\"",
            "filename"
          ],
          "line": 1565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "first_dir_separator",
          "args": [
            "filename"
          ],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst",
          "args": [
            "l"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "l",
            "elemlist"
          ],
          "line": 1556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "LOG",
            "(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t errmsg(\"invalid list syntax in parameter \\\"%s\\\"\",\n\t\t\t\t\t\tgucname))"
          ],
          "line": 1549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_SYNTAX_ERROR"
          ],
          "line": 1550
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_free_deep",
          "args": [
            "elemlist"
          ],
          "line": 1547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SplitDirectoriesString",
          "args": [
            "rawstring",
            "','",
            "&elemlist"
          ],
          "line": 1544
        },
        "resolved": true,
        "details": {
          "function_name": "SplitDirectoriesString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "3416-3503",
          "snippet": "bool\nSplitDirectoriesString(char *rawstring, char separator,\n\t\t\t\t\t   List **namelist)\n{\n\tchar\t   *nextp = rawstring;\n\tbool\t\tdone = false;\n\n\t*namelist = NIL;\n\n\twhile (scanner_isspace(*nextp))\n\t\tnextp++;\t\t\t\t/* skip leading whitespace */\n\n\tif (*nextp == '\\0')\n\t\treturn true;\t\t\t/* allow empty string */\n\n\t/* At the top of the loop, we are at start of a new directory. */\n\tdo\n\t{\n\t\tchar\t   *curname;\n\t\tchar\t   *endp;\n\n\t\tif (*nextp == '\"')\n\t\t{\n\t\t\t/* Quoted name --- collapse quote-quote pairs */\n\t\t\tcurname = nextp + 1;\n\t\t\tfor (;;)\n\t\t\t{\n\t\t\t\tendp = strchr(nextp + 1, '\"');\n\t\t\t\tif (endp == NULL)\n\t\t\t\t\treturn false;\t/* mismatched quotes */\n\t\t\t\tif (endp[1] != '\"')\n\t\t\t\t\tbreak;\t\t/* found end of quoted name */\n\t\t\t\t/* Collapse adjacent quotes into one quote, and look again */\n\t\t\t\tmemmove(endp, endp + 1, strlen(endp));\n\t\t\t\tnextp = endp;\n\t\t\t}\n\t\t\t/* endp now points at the terminating quote */\n\t\t\tnextp = endp + 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Unquoted name --- extends to separator or end of string */\n\t\t\tcurname = endp = nextp;\n\t\t\twhile (*nextp && *nextp != separator)\n\t\t\t{\n\t\t\t\t/* trailing whitespace should not be included in name */\n\t\t\t\tif (!scanner_isspace(*nextp))\n\t\t\t\t\tendp = nextp + 1;\n\t\t\t\tnextp++;\n\t\t\t}\n\t\t\tif (curname == endp)\n\t\t\t\treturn false;\t/* empty unquoted name not allowed */\n\t\t}\n\n\t\twhile (scanner_isspace(*nextp))\n\t\t\tnextp++;\t\t\t/* skip trailing whitespace */\n\n\t\tif (*nextp == separator)\n\t\t{\n\t\t\tnextp++;\n\t\t\twhile (scanner_isspace(*nextp))\n\t\t\t\tnextp++;\t\t/* skip leading whitespace for next */\n\t\t\t/* we expect another name, so done remains false */\n\t\t}\n\t\telse if (*nextp == '\\0')\n\t\t\tdone = true;\n\t\telse\n\t\t\treturn false;\t\t/* invalid syntax */\n\n\t\t/* Now safe to overwrite separator with a null */\n\t\t*endp = '\\0';\n\n\t\t/* Truncate path if it's overlength */\n\t\tif (strlen(curname) >= MAXPGPATH)\n\t\t\tcurname[MAXPGPATH - 1] = '\\0';\n\n\t\t/*\n\t\t * Finished isolating current name --- add it to list\n\t\t */\n\t\tcurname = pstrdup(curname);\n\t\tcanonicalize_path(curname);\n\t\t*namelist = lappend(*namelist, curname);\n\n\t\t/* Loop back if we didn't reach end of string */\n\t} while (!done);\n\n\treturn true;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nbool\nSplitDirectoriesString(char *rawstring, char separator,\n\t\t\t\t\t   List **namelist)\n{\n\tchar\t   *nextp = rawstring;\n\tbool\t\tdone = false;\n\n\t*namelist = NIL;\n\n\twhile (scanner_isspace(*nextp))\n\t\tnextp++;\t\t\t\t/* skip leading whitespace */\n\n\tif (*nextp == '\\0')\n\t\treturn true;\t\t\t/* allow empty string */\n\n\t/* At the top of the loop, we are at start of a new directory. */\n\tdo\n\t{\n\t\tchar\t   *curname;\n\t\tchar\t   *endp;\n\n\t\tif (*nextp == '\"')\n\t\t{\n\t\t\t/* Quoted name --- collapse quote-quote pairs */\n\t\t\tcurname = nextp + 1;\n\t\t\tfor (;;)\n\t\t\t{\n\t\t\t\tendp = strchr(nextp + 1, '\"');\n\t\t\t\tif (endp == NULL)\n\t\t\t\t\treturn false;\t/* mismatched quotes */\n\t\t\t\tif (endp[1] != '\"')\n\t\t\t\t\tbreak;\t\t/* found end of quoted name */\n\t\t\t\t/* Collapse adjacent quotes into one quote, and look again */\n\t\t\t\tmemmove(endp, endp + 1, strlen(endp));\n\t\t\t\tnextp = endp;\n\t\t\t}\n\t\t\t/* endp now points at the terminating quote */\n\t\t\tnextp = endp + 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Unquoted name --- extends to separator or end of string */\n\t\t\tcurname = endp = nextp;\n\t\t\twhile (*nextp && *nextp != separator)\n\t\t\t{\n\t\t\t\t/* trailing whitespace should not be included in name */\n\t\t\t\tif (!scanner_isspace(*nextp))\n\t\t\t\t\tendp = nextp + 1;\n\t\t\t\tnextp++;\n\t\t\t}\n\t\t\tif (curname == endp)\n\t\t\t\treturn false;\t/* empty unquoted name not allowed */\n\t\t}\n\n\t\twhile (scanner_isspace(*nextp))\n\t\t\tnextp++;\t\t\t/* skip trailing whitespace */\n\n\t\tif (*nextp == separator)\n\t\t{\n\t\t\tnextp++;\n\t\t\twhile (scanner_isspace(*nextp))\n\t\t\t\tnextp++;\t\t/* skip leading whitespace for next */\n\t\t\t/* we expect another name, so done remains false */\n\t\t}\n\t\telse if (*nextp == '\\0')\n\t\t\tdone = true;\n\t\telse\n\t\t\treturn false;\t\t/* invalid syntax */\n\n\t\t/* Now safe to overwrite separator with a null */\n\t\t*endp = '\\0';\n\n\t\t/* Truncate path if it's overlength */\n\t\tif (strlen(curname) >= MAXPGPATH)\n\t\t\tcurname[MAXPGPATH - 1] = '\\0';\n\n\t\t/*\n\t\t * Finished isolating current name --- add it to list\n\t\t */\n\t\tcurname = pstrdup(curname);\n\t\tcanonicalize_path(curname);\n\t\t*namelist = lappend(*namelist, curname);\n\n\t\t/* Loop back if we didn't reach end of string */\n\t} while (!done);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pstrdup",
          "args": [
            "libraries"
          ],
          "line": 1541
        },
        "resolved": true,
        "details": {
          "function_name": "pstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1160-1164",
          "snippet": "char *\npstrdup(const char *in)\n{\n\treturn MemoryContextStrdup(CurrentMemoryContext, in);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\n\nchar *\npstrdup(const char *in)\n{\n\treturn MemoryContextStrdup(CurrentMemoryContext, in);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nstatic void\nload_libraries(const char *libraries, const char *gucname, bool restricted)\n{\n\tchar\t   *rawstring;\n\tList\t   *elemlist;\n\tListCell   *l;\n\n\tif (libraries == NULL || libraries[0] == '\\0')\n\t\treturn;\t\t\t\t\t/* nothing to do */\n\n\t/* Need a modifiable copy of string */\n\trawstring = pstrdup(libraries);\n\n\t/* Parse string into list of filename paths */\n\tif (!SplitDirectoriesString(rawstring, ',', &elemlist))\n\t{\n\t\t/* syntax error in list */\n\t\tlist_free_deep(elemlist);\n\t\tpfree(rawstring);\n\t\tereport(LOG,\n\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t errmsg(\"invalid list syntax in parameter \\\"%s\\\"\",\n\t\t\t\t\t\tgucname)));\n\t\treturn;\n\t}\n\n\tforeach(l, elemlist)\n\t{\n\t\t/* Note that filename was already canonicalized */\n\t\tchar\t   *filename = (char *) lfirst(l);\n\t\tchar\t   *expanded = NULL;\n\n\t\t/* If restricting, insert $libdir/plugins if not mentioned already */\n\t\tif (restricted && first_dir_separator(filename) == NULL)\n\t\t{\n\t\t\texpanded = psprintf(\"$libdir/plugins/%s\", filename);\n\t\t\tfilename = expanded;\n\t\t}\n\t\tload_file(filename, restricted);\n\t\tereport(DEBUG1,\n\t\t\t\t(errmsg(\"loaded library \\\"%s\\\"\", filename)));\n\t\tif (expanded)\n\t\t\tpfree(expanded);\n\t}\n\n\tlist_free_deep(elemlist);\n\tpfree(rawstring);\n}"
  },
  {
    "function_name": "ValidatePgVersion",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
    "lines": "1453-1506",
    "snippet": "void\nValidatePgVersion(const char *path)\n{\n\tchar\t\tfull_path[MAXPGPATH];\n\tFILE\t   *file;\n\tint\t\t\tret;\n\tlong\t\tfile_major;\n\tlong\t\tmy_major;\n\tchar\t   *endptr;\n\tchar\t\tfile_version_string[64];\n\tconst char *my_version_string = PG_VERSION;\n\n\tmy_major = strtol(my_version_string, &endptr, 10);\n\n\tsnprintf(full_path, sizeof(full_path), \"%s/PG_VERSION\", path);\n\n\tfile = AllocateFile(full_path, \"r\");\n\tif (!file)\n\t{\n\t\tif (errno == ENOENT)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"\\\"%s\\\" is not a valid data directory\",\n\t\t\t\t\t\t\tpath),\n\t\t\t\t\t errdetail(\"File \\\"%s\\\" is missing.\", full_path)));\n\t\telse\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not open file \\\"%s\\\": %m\", full_path)));\n\t}\n\n\tfile_version_string[0] = '\\0';\n\tret = fscanf(file, \"%63s\", file_version_string);\n\tfile_major = strtol(file_version_string, &endptr, 10);\n\n\tif (ret != 1 || endptr == file_version_string)\n\t\tereport(FATAL,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"\\\"%s\\\" is not a valid data directory\",\n\t\t\t\t\t\tpath),\n\t\t\t\t errdetail(\"File \\\"%s\\\" does not contain valid data.\",\n\t\t\t\t\t\t   full_path),\n\t\t\t\t errhint(\"You might need to initdb.\")));\n\n\tFreeFile(file);\n\n\tif (my_major != file_major)\n\t\tereport(FATAL,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"database files are incompatible with server\"),\n\t\t\t\t errdetail(\"The data directory was initialized by PostgreSQL version %s, \"\n\t\t\t\t\t\t   \"which is not compatible with this version %s.\",\n\t\t\t\t\t\t   file_version_string, my_version_string)));\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pidfile.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/pg_shmem.h\"",
      "#include \"storage/latch.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/fd.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"postmaster/autovacuum.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"common/file_perm.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/htup_details.h\"",
      "#include <utime.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <sys/param.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "FATAL",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"database files are incompatible with server\"),\n\t\t\t\t errdetail(\"The data directory was initialized by PostgreSQL version %s, \"\n\t\t\t\t\t\t   \"which is not compatible with this version %s.\",\n\t\t\t\t\t\t   file_version_string, my_version_string))"
          ],
          "line": 1500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errdetail",
          "args": [
            "\"The data directory was initialized by PostgreSQL version %s, \"\n\t\t\t\t\t\t   \"which is not compatible with this version %s.\"",
            "file_version_string",
            "my_version_string"
          ],
          "line": 1503
        },
        "resolved": true,
        "details": {
          "function_name": "errdetail_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "918-933",
          "snippet": "int\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"database files are incompatible with server\""
          ],
          "line": 1502
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 1501
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "FreeFile",
          "args": [
            "file"
          ],
          "line": 1497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "FATAL",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"\\\"%s\\\" is not a valid data directory\",\n\t\t\t\t\t\tpath),\n\t\t\t\t errdetail(\"File \\\"%s\\\" does not contain valid data.\",\n\t\t\t\t\t\t   full_path),\n\t\t\t\t errhint(\"You might need to initdb.\"))"
          ],
          "line": 1489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errhint",
          "args": [
            "\"You might need to initdb.\""
          ],
          "line": 1495
        },
        "resolved": true,
        "details": {
          "function_name": "errhint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "984-999",
          "snippet": "int\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtol",
          "args": [
            "file_version_string",
            "&endptr",
            "10"
          ],
          "line": 1486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscanf",
          "args": [
            "file",
            "\"%63s\"",
            "file_version_string"
          ],
          "line": 1485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "FATAL",
            "(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not open file \\\"%s\\\": %m\", full_path))"
          ],
          "line": 1479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errcode_for_file_access",
          "args": [],
          "line": 1480
        },
        "resolved": true,
        "details": {
          "function_name": "errcode_for_file_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "595-655",
          "snippet": "int\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "FATAL",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"\\\"%s\\\" is not a valid data directory\",\n\t\t\t\t\t\t\tpath),\n\t\t\t\t\t errdetail(\"File \\\"%s\\\" is missing.\", full_path))"
          ],
          "line": 1473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocateFile",
          "args": [
            "full_path",
            "\"r\""
          ],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "full_path",
            "sizeof(full_path)",
            "\"%s/PG_VERSION\"",
            "path"
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtol",
          "args": [
            "my_version_string",
            "&endptr",
            "10"
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nvoid\nValidatePgVersion(const char *path)\n{\n\tchar\t\tfull_path[MAXPGPATH];\n\tFILE\t   *file;\n\tint\t\t\tret;\n\tlong\t\tfile_major;\n\tlong\t\tmy_major;\n\tchar\t   *endptr;\n\tchar\t\tfile_version_string[64];\n\tconst char *my_version_string = PG_VERSION;\n\n\tmy_major = strtol(my_version_string, &endptr, 10);\n\n\tsnprintf(full_path, sizeof(full_path), \"%s/PG_VERSION\", path);\n\n\tfile = AllocateFile(full_path, \"r\");\n\tif (!file)\n\t{\n\t\tif (errno == ENOENT)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"\\\"%s\\\" is not a valid data directory\",\n\t\t\t\t\t\t\tpath),\n\t\t\t\t\t errdetail(\"File \\\"%s\\\" is missing.\", full_path)));\n\t\telse\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not open file \\\"%s\\\": %m\", full_path)));\n\t}\n\n\tfile_version_string[0] = '\\0';\n\tret = fscanf(file, \"%63s\", file_version_string);\n\tfile_major = strtol(file_version_string, &endptr, 10);\n\n\tif (ret != 1 || endptr == file_version_string)\n\t\tereport(FATAL,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"\\\"%s\\\" is not a valid data directory\",\n\t\t\t\t\t\tpath),\n\t\t\t\t errdetail(\"File \\\"%s\\\" does not contain valid data.\",\n\t\t\t\t\t\t   full_path),\n\t\t\t\t errhint(\"You might need to initdb.\")));\n\n\tFreeFile(file);\n\n\tif (my_major != file_major)\n\t\tereport(FATAL,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"database files are incompatible with server\"),\n\t\t\t\t errdetail(\"The data directory was initialized by PostgreSQL version %s, \"\n\t\t\t\t\t\t   \"which is not compatible with this version %s.\",\n\t\t\t\t\t\t   file_version_string, my_version_string)));\n}"
  },
  {
    "function_name": "RecheckDataDirLockFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
    "lines": "1381-1439",
    "snippet": "bool\nRecheckDataDirLockFile(void)\n{\n\tint\t\t\tfd;\n\tint\t\t\tlen;\n\tlong\t\tfile_pid;\n\tchar\t\tbuffer[BLCKSZ];\n\n\tfd = open(DIRECTORY_LOCK_FILE, O_RDWR | PG_BINARY, 0);\n\tif (fd < 0)\n\t{\n\t\t/*\n\t\t * There are many foreseeable false-positive error conditions.  For\n\t\t * safety, fail only on enumerated clearly-something-is-wrong\n\t\t * conditions.\n\t\t */\n\t\tswitch (errno)\n\t\t{\n\t\t\tcase ENOENT:\n\t\t\tcase ENOTDIR:\n\t\t\t\t/* disaster */\n\t\t\t\tereport(LOG,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not open file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\t\tDIRECTORY_LOCK_FILE)));\n\t\t\t\treturn false;\n\t\t\tdefault:\n\t\t\t\t/* non-fatal, at least for now */\n\t\t\t\tereport(LOG,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not open file \\\"%s\\\": %m; continuing anyway\",\n\t\t\t\t\t\t\t\tDIRECTORY_LOCK_FILE)));\n\t\t\t\treturn true;\n\t\t}\n\t}\n\tpgstat_report_wait_start(WAIT_EVENT_LOCK_FILE_RECHECKDATADIR_READ);\n\tlen = read(fd, buffer, sizeof(buffer) - 1);\n\tpgstat_report_wait_end();\n\tif (len < 0)\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not read from file \\\"%s\\\": %m\",\n\t\t\t\t\t\tDIRECTORY_LOCK_FILE)));\n\t\tclose(fd);\n\t\treturn true;\t\t\t/* treat read failure as nonfatal */\n\t}\n\tbuffer[len] = '\\0';\n\tclose(fd);\n\tfile_pid = atol(buffer);\n\tif (file_pid == getpid())\n\t\treturn true;\t\t\t/* all is well */\n\n\t/* Trouble: someone's overwritten the lock file */\n\tereport(LOG,\n\t\t\t(errmsg(\"lock file \\\"%s\\\" contains wrong PID: %ld instead of %ld\",\n\t\t\t\t\tDIRECTORY_LOCK_FILE, file_pid, (long) getpid())));\n\treturn false;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pidfile.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/pg_shmem.h\"",
      "#include \"storage/latch.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/fd.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"postmaster/autovacuum.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"common/file_perm.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/htup_details.h\"",
      "#include <utime.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <sys/param.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define DIRECTORY_LOCK_FILE\t\t\"postmaster.pid\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "LOG",
            "(errmsg(\"lock file \\\"%s\\\" contains wrong PID: %ld instead of %ld\",\n\t\t\t\t\tDIRECTORY_LOCK_FILE, file_pid, (long) getpid()))"
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"lock file \\\"%s\\\" contains wrong PID: %ld instead of %ld\"",
            "DIRECTORY_LOCK_FILE",
            "file_pid",
            "(long) getpid()"
          ],
          "line": 1436
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atol",
          "args": [
            "buffer"
          ],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 1429
        },
        "resolved": true,
        "details": {
          "function_name": "close_lb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "3105-3119",
          "snippet": "Datum\nclose_lb(PG_FUNCTION_ARGS)\n{\n#ifdef NOT_USED\n\tLINE\t   *line = PG_GETARG_LINE_P(0);\n\tBOX\t\t   *box = PG_GETARG_BOX_P(1);\n#endif\n\n\t/* think about this one for a while */\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t errmsg(\"function \\\"close_lb\\\" not implemented\")));\n\n\tPG_RETURN_NULL();\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double box_ht(BOX *box);",
            "static double box_wd(BOX *box);",
            "static double box_ar(BOX *box);",
            "static void box_cn(Point *center, BOX *box);",
            "static Point *interpt_sl(LSEG *lseg, LINE *line);",
            "static bool has_interpt_sl(LSEG *lseg, LINE *line);",
            "static double dist_pl_internal(Point *pt, LINE *line);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double box_ht(BOX *box);\nstatic double box_wd(BOX *box);\nstatic double box_ar(BOX *box);\nstatic void box_cn(Point *center, BOX *box);\nstatic Point *interpt_sl(LSEG *lseg, LINE *line);\nstatic bool has_interpt_sl(LSEG *lseg, LINE *line);\nstatic double dist_pl_internal(Point *pt, LINE *line);\n\nDatum\nclose_lb(PG_FUNCTION_ARGS)\n{\n#ifdef NOT_USED\n\tLINE\t   *line = PG_GETARG_LINE_P(0);\n\tBOX\t\t   *box = PG_GETARG_BOX_P(1);\n#endif\n\n\t/* think about this one for a while */\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t errmsg(\"function \\\"close_lb\\\" not implemented\")));\n\n\tPG_RETURN_NULL();\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "LOG",
            "(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not read from file \\\"%s\\\": %m\",\n\t\t\t\t\t\tDIRECTORY_LOCK_FILE))"
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errcode_for_file_access",
          "args": [],
          "line": 1422
        },
        "resolved": true,
        "details": {
          "function_name": "errcode_for_file_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "595-655",
          "snippet": "int\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "pgstat_report_wait_end",
          "args": [],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "fd",
            "buffer",
            "sizeof(buffer) - 1"
          ],
          "line": 1417
        },
        "resolved": true,
        "details": {
          "function_name": "tuplestore_copy_read_pointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplestore.c",
          "lines": "1267-1345",
          "snippet": "void\ntuplestore_copy_read_pointer(Tuplestorestate *state,\n\t\t\t\t\t\t\t int srcptr, int destptr)\n{\n\tTSReadPointer *sptr = &state->readptrs[srcptr];\n\tTSReadPointer *dptr = &state->readptrs[destptr];\n\n\tAssert(srcptr >= 0 && srcptr < state->readptrcount);\n\tAssert(destptr >= 0 && destptr < state->readptrcount);\n\n\t/* Assigning to self is a no-op */\n\tif (srcptr == destptr)\n\t\treturn;\n\n\tif (dptr->eflags != sptr->eflags)\n\t{\n\t\t/* Possible change of overall eflags, so copy and then recompute */\n\t\tint\t\t\teflags;\n\t\tint\t\t\ti;\n\n\t\t*dptr = *sptr;\n\t\teflags = state->readptrs[0].eflags;\n\t\tfor (i = 1; i < state->readptrcount; i++)\n\t\t\teflags |= state->readptrs[i].eflags;\n\t\tstate->eflags = eflags;\n\t}\n\telse\n\t\t*dptr = *sptr;\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INMEM:\n\t\tcase TSS_WRITEFILE:\n\t\t\t/* no work */\n\t\t\tbreak;\n\t\tcase TSS_READFILE:\n\n\t\t\t/*\n\t\t\t * This case is a bit tricky since the active read pointer's\n\t\t\t * position corresponds to the seek point, not what is in its\n\t\t\t * variables.  Assigning to the active requires a seek, and\n\t\t\t * assigning from the active requires a tell, except when\n\t\t\t * eof_reached.\n\t\t\t */\n\t\t\tif (destptr == state->activeptr)\n\t\t\t{\n\t\t\t\tif (dptr->eof_reached)\n\t\t\t\t{\n\t\t\t\t\tif (BufFileSeek(state->myfile,\n\t\t\t\t\t\t\t\t\tstate->writepos_file,\n\t\t\t\t\t\t\t\t\tstate->writepos_offset,\n\t\t\t\t\t\t\t\t\tSEEK_SET) != 0)\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (BufFileSeek(state->myfile,\n\t\t\t\t\t\t\t\t\tdptr->file, dptr->offset,\n\t\t\t\t\t\t\t\t\tSEEK_SET) != 0)\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (srcptr == state->activeptr)\n\t\t\t{\n\t\t\t\tif (!dptr->eof_reached)\n\t\t\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t\t\t&dptr->file,\n\t\t\t\t\t\t\t\t&dptr->offset);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplestore state\");\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"utils/resowner.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void dumptuples(Tuplestorestate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/resowner.h\"\n#include \"utils/memutils.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void dumptuples(Tuplestorestate *state);\n\nvoid\ntuplestore_copy_read_pointer(Tuplestorestate *state,\n\t\t\t\t\t\t\t int srcptr, int destptr)\n{\n\tTSReadPointer *sptr = &state->readptrs[srcptr];\n\tTSReadPointer *dptr = &state->readptrs[destptr];\n\n\tAssert(srcptr >= 0 && srcptr < state->readptrcount);\n\tAssert(destptr >= 0 && destptr < state->readptrcount);\n\n\t/* Assigning to self is a no-op */\n\tif (srcptr == destptr)\n\t\treturn;\n\n\tif (dptr->eflags != sptr->eflags)\n\t{\n\t\t/* Possible change of overall eflags, so copy and then recompute */\n\t\tint\t\t\teflags;\n\t\tint\t\t\ti;\n\n\t\t*dptr = *sptr;\n\t\teflags = state->readptrs[0].eflags;\n\t\tfor (i = 1; i < state->readptrcount; i++)\n\t\t\teflags |= state->readptrs[i].eflags;\n\t\tstate->eflags = eflags;\n\t}\n\telse\n\t\t*dptr = *sptr;\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INMEM:\n\t\tcase TSS_WRITEFILE:\n\t\t\t/* no work */\n\t\t\tbreak;\n\t\tcase TSS_READFILE:\n\n\t\t\t/*\n\t\t\t * This case is a bit tricky since the active read pointer's\n\t\t\t * position corresponds to the seek point, not what is in its\n\t\t\t * variables.  Assigning to the active requires a seek, and\n\t\t\t * assigning from the active requires a tell, except when\n\t\t\t * eof_reached.\n\t\t\t */\n\t\t\tif (destptr == state->activeptr)\n\t\t\t{\n\t\t\t\tif (dptr->eof_reached)\n\t\t\t\t{\n\t\t\t\t\tif (BufFileSeek(state->myfile,\n\t\t\t\t\t\t\t\t\tstate->writepos_file,\n\t\t\t\t\t\t\t\t\tstate->writepos_offset,\n\t\t\t\t\t\t\t\t\tSEEK_SET) != 0)\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (BufFileSeek(state->myfile,\n\t\t\t\t\t\t\t\t\tdptr->file, dptr->offset,\n\t\t\t\t\t\t\t\t\tSEEK_SET) != 0)\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (srcptr == state->activeptr)\n\t\t\t{\n\t\t\t\tif (!dptr->eof_reached)\n\t\t\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t\t\t&dptr->file,\n\t\t\t\t\t\t\t\t&dptr->offset);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplestore state\");\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pgstat_report_wait_start",
          "args": [
            "WAIT_EVENT_LOCK_FILE_RECHECKDATADIR_READ"
          ],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "LOG",
            "(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not open file \\\"%s\\\": %m; continuing anyway\",\n\t\t\t\t\t\t\t\tDIRECTORY_LOCK_FILE))"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "LOG",
            "(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not open file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\t\tDIRECTORY_LOCK_FILE))"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "DIRECTORY_LOCK_FILE",
            "O_RDWR | PG_BINARY",
            "0"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\n#define DIRECTORY_LOCK_FILE\t\t\"postmaster.pid\"\n\nbool\nRecheckDataDirLockFile(void)\n{\n\tint\t\t\tfd;\n\tint\t\t\tlen;\n\tlong\t\tfile_pid;\n\tchar\t\tbuffer[BLCKSZ];\n\n\tfd = open(DIRECTORY_LOCK_FILE, O_RDWR | PG_BINARY, 0);\n\tif (fd < 0)\n\t{\n\t\t/*\n\t\t * There are many foreseeable false-positive error conditions.  For\n\t\t * safety, fail only on enumerated clearly-something-is-wrong\n\t\t * conditions.\n\t\t */\n\t\tswitch (errno)\n\t\t{\n\t\t\tcase ENOENT:\n\t\t\tcase ENOTDIR:\n\t\t\t\t/* disaster */\n\t\t\t\tereport(LOG,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not open file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\t\tDIRECTORY_LOCK_FILE)));\n\t\t\t\treturn false;\n\t\t\tdefault:\n\t\t\t\t/* non-fatal, at least for now */\n\t\t\t\tereport(LOG,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not open file \\\"%s\\\": %m; continuing anyway\",\n\t\t\t\t\t\t\t\tDIRECTORY_LOCK_FILE)));\n\t\t\t\treturn true;\n\t\t}\n\t}\n\tpgstat_report_wait_start(WAIT_EVENT_LOCK_FILE_RECHECKDATADIR_READ);\n\tlen = read(fd, buffer, sizeof(buffer) - 1);\n\tpgstat_report_wait_end();\n\tif (len < 0)\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not read from file \\\"%s\\\": %m\",\n\t\t\t\t\t\tDIRECTORY_LOCK_FILE)));\n\t\tclose(fd);\n\t\treturn true;\t\t\t/* treat read failure as nonfatal */\n\t}\n\tbuffer[len] = '\\0';\n\tclose(fd);\n\tfile_pid = atol(buffer);\n\tif (file_pid == getpid())\n\t\treturn true;\t\t\t/* all is well */\n\n\t/* Trouble: someone's overwritten the lock file */\n\tereport(LOG,\n\t\t\t(errmsg(\"lock file \\\"%s\\\" contains wrong PID: %ld instead of %ld\",\n\t\t\t\t\tDIRECTORY_LOCK_FILE, file_pid, (long) getpid())));\n\treturn false;\n}"
  },
  {
    "function_name": "AddToDataDirLockFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
    "lines": "1253-1367",
    "snippet": "void\nAddToDataDirLockFile(int target_line, const char *str)\n{\n\tint\t\t\tfd;\n\tint\t\t\tlen;\n\tint\t\t\tlineno;\n\tchar\t   *srcptr;\n\tchar\t   *destptr;\n\tchar\t\tsrcbuffer[BLCKSZ];\n\tchar\t\tdestbuffer[BLCKSZ];\n\n\tfd = open(DIRECTORY_LOCK_FILE, O_RDWR | PG_BINARY, 0);\n\tif (fd < 0)\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not open file \\\"%s\\\": %m\",\n\t\t\t\t\t\tDIRECTORY_LOCK_FILE)));\n\t\treturn;\n\t}\n\tpgstat_report_wait_start(WAIT_EVENT_LOCK_FILE_ADDTODATADIR_READ);\n\tlen = read(fd, srcbuffer, sizeof(srcbuffer) - 1);\n\tpgstat_report_wait_end();\n\tif (len < 0)\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not read from file \\\"%s\\\": %m\",\n\t\t\t\t\t\tDIRECTORY_LOCK_FILE)));\n\t\tclose(fd);\n\t\treturn;\n\t}\n\tsrcbuffer[len] = '\\0';\n\n\t/*\n\t * Advance over lines we are not supposed to rewrite, then copy them to\n\t * destbuffer.\n\t */\n\tsrcptr = srcbuffer;\n\tfor (lineno = 1; lineno < target_line; lineno++)\n\t{\n\t\tchar\t   *eol = strchr(srcptr, '\\n');\n\n\t\tif (eol == NULL)\n\t\t\tbreak;\t\t\t\t/* not enough lines in file yet */\n\t\tsrcptr = eol + 1;\n\t}\n\tmemcpy(destbuffer, srcbuffer, srcptr - srcbuffer);\n\tdestptr = destbuffer + (srcptr - srcbuffer);\n\n\t/*\n\t * Fill in any missing lines before the target line, in case lines are\n\t * added to the file out of order.\n\t */\n\tfor (; lineno < target_line; lineno++)\n\t{\n\t\tif (destptr < destbuffer + sizeof(destbuffer))\n\t\t\t*destptr++ = '\\n';\n\t}\n\n\t/*\n\t * Write or rewrite the target line.\n\t */\n\tsnprintf(destptr, destbuffer + sizeof(destbuffer) - destptr, \"%s\\n\", str);\n\tdestptr += strlen(destptr);\n\n\t/*\n\t * If there are more lines in the old file, append them to destbuffer.\n\t */\n\tif ((srcptr = strchr(srcptr, '\\n')) != NULL)\n\t{\n\t\tsrcptr++;\n\t\tsnprintf(destptr, destbuffer + sizeof(destbuffer) - destptr, \"%s\",\n\t\t\t\t srcptr);\n\t}\n\n\t/*\n\t * And rewrite the data.  Since we write in a single kernel call, this\n\t * update should appear atomic to onlookers.\n\t */\n\tlen = strlen(destbuffer);\n\terrno = 0;\n\tpgstat_report_wait_start(WAIT_EVENT_LOCK_FILE_ADDTODATADIR_WRITE);\n\tif (lseek(fd, (off_t) 0, SEEK_SET) != 0 ||\n\t\t(int) write(fd, destbuffer, len) != len)\n\t{\n\t\tpgstat_report_wait_end();\n\t\t/* if write didn't set errno, assume problem is no disk space */\n\t\tif (errno == 0)\n\t\t\terrno = ENOSPC;\n\t\tereport(LOG,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write to file \\\"%s\\\": %m\",\n\t\t\t\t\t\tDIRECTORY_LOCK_FILE)));\n\t\tclose(fd);\n\t\treturn;\n\t}\n\tpgstat_report_wait_end();\n\tpgstat_report_wait_start(WAIT_EVENT_LOCK_FILE_ADDTODATADIR_SYNC);\n\tif (pg_fsync(fd) != 0)\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write to file \\\"%s\\\": %m\",\n\t\t\t\t\t\tDIRECTORY_LOCK_FILE)));\n\t}\n\tpgstat_report_wait_end();\n\tif (close(fd) != 0)\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write to file \\\"%s\\\": %m\",\n\t\t\t\t\t\tDIRECTORY_LOCK_FILE)));\n\t}\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pidfile.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/pg_shmem.h\"",
      "#include \"storage/latch.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/fd.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"postmaster/autovacuum.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"common/file_perm.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/htup_details.h\"",
      "#include <utime.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <sys/param.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define DIRECTORY_LOCK_FILE\t\t\"postmaster.pid\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "LOG",
            "(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write to file \\\"%s\\\": %m\",\n\t\t\t\t\t\tDIRECTORY_LOCK_FILE))"
          ],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not write to file \\\"%s\\\": %m\"",
            "DIRECTORY_LOCK_FILE"
          ],
          "line": 1364
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode_for_file_access",
          "args": [],
          "line": 1363
        },
        "resolved": true,
        "details": {
          "function_name": "errcode_for_file_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "595-655",
          "snippet": "int\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 1360
        },
        "resolved": true,
        "details": {
          "function_name": "close_lb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "3105-3119",
          "snippet": "Datum\nclose_lb(PG_FUNCTION_ARGS)\n{\n#ifdef NOT_USED\n\tLINE\t   *line = PG_GETARG_LINE_P(0);\n\tBOX\t\t   *box = PG_GETARG_BOX_P(1);\n#endif\n\n\t/* think about this one for a while */\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t errmsg(\"function \\\"close_lb\\\" not implemented\")));\n\n\tPG_RETURN_NULL();\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double box_ht(BOX *box);",
            "static double box_wd(BOX *box);",
            "static double box_ar(BOX *box);",
            "static void box_cn(Point *center, BOX *box);",
            "static Point *interpt_sl(LSEG *lseg, LINE *line);",
            "static bool has_interpt_sl(LSEG *lseg, LINE *line);",
            "static double dist_pl_internal(Point *pt, LINE *line);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double box_ht(BOX *box);\nstatic double box_wd(BOX *box);\nstatic double box_ar(BOX *box);\nstatic void box_cn(Point *center, BOX *box);\nstatic Point *interpt_sl(LSEG *lseg, LINE *line);\nstatic bool has_interpt_sl(LSEG *lseg, LINE *line);\nstatic double dist_pl_internal(Point *pt, LINE *line);\n\nDatum\nclose_lb(PG_FUNCTION_ARGS)\n{\n#ifdef NOT_USED\n\tLINE\t   *line = PG_GETARG_LINE_P(0);\n\tBOX\t\t   *box = PG_GETARG_BOX_P(1);\n#endif\n\n\t/* think about this one for a while */\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t errmsg(\"function \\\"close_lb\\\" not implemented\")));\n\n\tPG_RETURN_NULL();\n}"
        }
      },
      {
        "call_info": {
          "callee": "pgstat_report_wait_end",
          "args": [],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "LOG",
            "(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write to file \\\"%s\\\": %m\",\n\t\t\t\t\t\tDIRECTORY_LOCK_FILE))"
          ],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_fsync",
          "args": [
            "fd"
          ],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgstat_report_wait_start",
          "args": [
            "WAIT_EVENT_LOCK_FILE_ADDTODATADIR_SYNC"
          ],
          "line": 1351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgstat_report_wait_end",
          "args": [],
          "line": 1350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "LOG",
            "(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write to file \\\"%s\\\": %m\",\n\t\t\t\t\t\tDIRECTORY_LOCK_FILE))"
          ],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgstat_report_wait_end",
          "args": [],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "fd",
            "destbuffer",
            "len"
          ],
          "line": 1337
        },
        "resolved": true,
        "details": {
          "function_name": "write_stderr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "3668-3703",
          "snippet": "void\nwrite_stderr(const char *fmt,...)\n{\n\tva_list\t\tap;\n\n#ifdef WIN32\n\tchar\t\terrbuf[2048];\t/* Arbitrary size? */\n#endif\n\n\tfmt = _(fmt);\n\n\tva_start(ap, fmt);\n#ifndef WIN32\n\t/* On Unix, we just fprintf to stderr */\n\tvfprintf(stderr, fmt, ap);\n\tfflush(stderr);\n#else\n\tvsnprintf(errbuf, sizeof(errbuf), fmt, ap);\n\n\t/*\n\t * On Win32, we print to stderr if running on a console, or write to\n\t * eventlog if running as a service\n\t */\n\tif (pgwin32_is_service())\t/* Running as a service */\n\t{\n\t\twrite_eventlog(ERROR, errbuf, strlen(errbuf));\n\t}\n\telse\n\t{\n\t\t/* Not running as service, write to stderr */\n\t\twrite_console(errbuf, strlen(errbuf));\n\t\tfflush(stderr);\n\t}\n#endif\n\tva_end(ap);\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nvoid\nwrite_stderr(const char *fmt,...)\n{\n\tva_list\t\tap;\n\n#ifdef WIN32\n\tchar\t\terrbuf[2048];\t/* Arbitrary size? */\n#endif\n\n\tfmt = _(fmt);\n\n\tva_start(ap, fmt);\n#ifndef WIN32\n\t/* On Unix, we just fprintf to stderr */\n\tvfprintf(stderr, fmt, ap);\n\tfflush(stderr);\n#else\n\tvsnprintf(errbuf, sizeof(errbuf), fmt, ap);\n\n\t/*\n\t * On Win32, we print to stderr if running on a console, or write to\n\t * eventlog if running as a service\n\t */\n\tif (pgwin32_is_service())\t/* Running as a service */\n\t{\n\t\twrite_eventlog(ERROR, errbuf, strlen(errbuf));\n\t}\n\telse\n\t{\n\t\t/* Not running as service, write to stderr */\n\t\twrite_console(errbuf, strlen(errbuf));\n\t\tfflush(stderr);\n\t}\n#endif\n\tva_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lseek",
          "args": [
            "fd",
            "(off_t) 0",
            "SEEK_SET"
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgstat_report_wait_start",
          "args": [
            "WAIT_EVENT_LOCK_FILE_ADDTODATADIR_WRITE"
          ],
          "line": 1335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "destbuffer"
          ],
          "line": 1333
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "destptr",
            "destbuffer + sizeof(destbuffer) - destptr",
            "\"%s\"",
            "srcptr"
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "srcptr",
            "'\\n'"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "destptr",
            "destbuffer + sizeof(destbuffer) - destptr",
            "\"%s\\n\"",
            "str"
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "destbuffer",
            "srcbuffer",
            "srcptr - srcbuffer"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "srcptr",
            "'\\n'"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "LOG",
            "(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not read from file \\\"%s\\\": %m\",\n\t\t\t\t\t\tDIRECTORY_LOCK_FILE))"
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgstat_report_wait_end",
          "args": [],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "fd",
            "srcbuffer",
            "sizeof(srcbuffer) - 1"
          ],
          "line": 1274
        },
        "resolved": true,
        "details": {
          "function_name": "tuplestore_copy_read_pointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplestore.c",
          "lines": "1267-1345",
          "snippet": "void\ntuplestore_copy_read_pointer(Tuplestorestate *state,\n\t\t\t\t\t\t\t int srcptr, int destptr)\n{\n\tTSReadPointer *sptr = &state->readptrs[srcptr];\n\tTSReadPointer *dptr = &state->readptrs[destptr];\n\n\tAssert(srcptr >= 0 && srcptr < state->readptrcount);\n\tAssert(destptr >= 0 && destptr < state->readptrcount);\n\n\t/* Assigning to self is a no-op */\n\tif (srcptr == destptr)\n\t\treturn;\n\n\tif (dptr->eflags != sptr->eflags)\n\t{\n\t\t/* Possible change of overall eflags, so copy and then recompute */\n\t\tint\t\t\teflags;\n\t\tint\t\t\ti;\n\n\t\t*dptr = *sptr;\n\t\teflags = state->readptrs[0].eflags;\n\t\tfor (i = 1; i < state->readptrcount; i++)\n\t\t\teflags |= state->readptrs[i].eflags;\n\t\tstate->eflags = eflags;\n\t}\n\telse\n\t\t*dptr = *sptr;\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INMEM:\n\t\tcase TSS_WRITEFILE:\n\t\t\t/* no work */\n\t\t\tbreak;\n\t\tcase TSS_READFILE:\n\n\t\t\t/*\n\t\t\t * This case is a bit tricky since the active read pointer's\n\t\t\t * position corresponds to the seek point, not what is in its\n\t\t\t * variables.  Assigning to the active requires a seek, and\n\t\t\t * assigning from the active requires a tell, except when\n\t\t\t * eof_reached.\n\t\t\t */\n\t\t\tif (destptr == state->activeptr)\n\t\t\t{\n\t\t\t\tif (dptr->eof_reached)\n\t\t\t\t{\n\t\t\t\t\tif (BufFileSeek(state->myfile,\n\t\t\t\t\t\t\t\t\tstate->writepos_file,\n\t\t\t\t\t\t\t\t\tstate->writepos_offset,\n\t\t\t\t\t\t\t\t\tSEEK_SET) != 0)\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (BufFileSeek(state->myfile,\n\t\t\t\t\t\t\t\t\tdptr->file, dptr->offset,\n\t\t\t\t\t\t\t\t\tSEEK_SET) != 0)\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (srcptr == state->activeptr)\n\t\t\t{\n\t\t\t\tif (!dptr->eof_reached)\n\t\t\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t\t\t&dptr->file,\n\t\t\t\t\t\t\t\t&dptr->offset);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplestore state\");\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"utils/resowner.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void dumptuples(Tuplestorestate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/resowner.h\"\n#include \"utils/memutils.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void dumptuples(Tuplestorestate *state);\n\nvoid\ntuplestore_copy_read_pointer(Tuplestorestate *state,\n\t\t\t\t\t\t\t int srcptr, int destptr)\n{\n\tTSReadPointer *sptr = &state->readptrs[srcptr];\n\tTSReadPointer *dptr = &state->readptrs[destptr];\n\n\tAssert(srcptr >= 0 && srcptr < state->readptrcount);\n\tAssert(destptr >= 0 && destptr < state->readptrcount);\n\n\t/* Assigning to self is a no-op */\n\tif (srcptr == destptr)\n\t\treturn;\n\n\tif (dptr->eflags != sptr->eflags)\n\t{\n\t\t/* Possible change of overall eflags, so copy and then recompute */\n\t\tint\t\t\teflags;\n\t\tint\t\t\ti;\n\n\t\t*dptr = *sptr;\n\t\teflags = state->readptrs[0].eflags;\n\t\tfor (i = 1; i < state->readptrcount; i++)\n\t\t\teflags |= state->readptrs[i].eflags;\n\t\tstate->eflags = eflags;\n\t}\n\telse\n\t\t*dptr = *sptr;\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INMEM:\n\t\tcase TSS_WRITEFILE:\n\t\t\t/* no work */\n\t\t\tbreak;\n\t\tcase TSS_READFILE:\n\n\t\t\t/*\n\t\t\t * This case is a bit tricky since the active read pointer's\n\t\t\t * position corresponds to the seek point, not what is in its\n\t\t\t * variables.  Assigning to the active requires a seek, and\n\t\t\t * assigning from the active requires a tell, except when\n\t\t\t * eof_reached.\n\t\t\t */\n\t\t\tif (destptr == state->activeptr)\n\t\t\t{\n\t\t\t\tif (dptr->eof_reached)\n\t\t\t\t{\n\t\t\t\t\tif (BufFileSeek(state->myfile,\n\t\t\t\t\t\t\t\t\tstate->writepos_file,\n\t\t\t\t\t\t\t\t\tstate->writepos_offset,\n\t\t\t\t\t\t\t\t\tSEEK_SET) != 0)\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (BufFileSeek(state->myfile,\n\t\t\t\t\t\t\t\t\tdptr->file, dptr->offset,\n\t\t\t\t\t\t\t\t\tSEEK_SET) != 0)\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (srcptr == state->activeptr)\n\t\t\t{\n\t\t\t\tif (!dptr->eof_reached)\n\t\t\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t\t\t&dptr->file,\n\t\t\t\t\t\t\t\t&dptr->offset);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplestore state\");\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pgstat_report_wait_start",
          "args": [
            "WAIT_EVENT_LOCK_FILE_ADDTODATADIR_READ"
          ],
          "line": 1273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "LOG",
            "(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not open file \\\"%s\\\": %m\",\n\t\t\t\t\t\tDIRECTORY_LOCK_FILE))"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "DIRECTORY_LOCK_FILE",
            "O_RDWR | PG_BINARY",
            "0"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\n#define DIRECTORY_LOCK_FILE\t\t\"postmaster.pid\"\n\nvoid\nAddToDataDirLockFile(int target_line, const char *str)\n{\n\tint\t\t\tfd;\n\tint\t\t\tlen;\n\tint\t\t\tlineno;\n\tchar\t   *srcptr;\n\tchar\t   *destptr;\n\tchar\t\tsrcbuffer[BLCKSZ];\n\tchar\t\tdestbuffer[BLCKSZ];\n\n\tfd = open(DIRECTORY_LOCK_FILE, O_RDWR | PG_BINARY, 0);\n\tif (fd < 0)\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not open file \\\"%s\\\": %m\",\n\t\t\t\t\t\tDIRECTORY_LOCK_FILE)));\n\t\treturn;\n\t}\n\tpgstat_report_wait_start(WAIT_EVENT_LOCK_FILE_ADDTODATADIR_READ);\n\tlen = read(fd, srcbuffer, sizeof(srcbuffer) - 1);\n\tpgstat_report_wait_end();\n\tif (len < 0)\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not read from file \\\"%s\\\": %m\",\n\t\t\t\t\t\tDIRECTORY_LOCK_FILE)));\n\t\tclose(fd);\n\t\treturn;\n\t}\n\tsrcbuffer[len] = '\\0';\n\n\t/*\n\t * Advance over lines we are not supposed to rewrite, then copy them to\n\t * destbuffer.\n\t */\n\tsrcptr = srcbuffer;\n\tfor (lineno = 1; lineno < target_line; lineno++)\n\t{\n\t\tchar\t   *eol = strchr(srcptr, '\\n');\n\n\t\tif (eol == NULL)\n\t\t\tbreak;\t\t\t\t/* not enough lines in file yet */\n\t\tsrcptr = eol + 1;\n\t}\n\tmemcpy(destbuffer, srcbuffer, srcptr - srcbuffer);\n\tdestptr = destbuffer + (srcptr - srcbuffer);\n\n\t/*\n\t * Fill in any missing lines before the target line, in case lines are\n\t * added to the file out of order.\n\t */\n\tfor (; lineno < target_line; lineno++)\n\t{\n\t\tif (destptr < destbuffer + sizeof(destbuffer))\n\t\t\t*destptr++ = '\\n';\n\t}\n\n\t/*\n\t * Write or rewrite the target line.\n\t */\n\tsnprintf(destptr, destbuffer + sizeof(destbuffer) - destptr, \"%s\\n\", str);\n\tdestptr += strlen(destptr);\n\n\t/*\n\t * If there are more lines in the old file, append them to destbuffer.\n\t */\n\tif ((srcptr = strchr(srcptr, '\\n')) != NULL)\n\t{\n\t\tsrcptr++;\n\t\tsnprintf(destptr, destbuffer + sizeof(destbuffer) - destptr, \"%s\",\n\t\t\t\t srcptr);\n\t}\n\n\t/*\n\t * And rewrite the data.  Since we write in a single kernel call, this\n\t * update should appear atomic to onlookers.\n\t */\n\tlen = strlen(destbuffer);\n\terrno = 0;\n\tpgstat_report_wait_start(WAIT_EVENT_LOCK_FILE_ADDTODATADIR_WRITE);\n\tif (lseek(fd, (off_t) 0, SEEK_SET) != 0 ||\n\t\t(int) write(fd, destbuffer, len) != len)\n\t{\n\t\tpgstat_report_wait_end();\n\t\t/* if write didn't set errno, assume problem is no disk space */\n\t\tif (errno == 0)\n\t\t\terrno = ENOSPC;\n\t\tereport(LOG,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write to file \\\"%s\\\": %m\",\n\t\t\t\t\t\tDIRECTORY_LOCK_FILE)));\n\t\tclose(fd);\n\t\treturn;\n\t}\n\tpgstat_report_wait_end();\n\tpgstat_report_wait_start(WAIT_EVENT_LOCK_FILE_ADDTODATADIR_SYNC);\n\tif (pg_fsync(fd) != 0)\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write to file \\\"%s\\\": %m\",\n\t\t\t\t\t\tDIRECTORY_LOCK_FILE)));\n\t}\n\tpgstat_report_wait_end();\n\tif (close(fd) != 0)\n\t{\n\t\tereport(LOG,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write to file \\\"%s\\\": %m\",\n\t\t\t\t\t\tDIRECTORY_LOCK_FILE)));\n\t}\n}"
  },
  {
    "function_name": "TouchSocketLockFiles",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
    "lines": "1203-1240",
    "snippet": "void\nTouchSocketLockFiles(void)\n{\n\tListCell   *l;\n\n\tforeach(l, lock_files)\n\t{\n\t\tchar\t   *socketLockFile = (char *) lfirst(l);\n\n\t\t/* No need to touch the data directory lock file, we trust */\n\t\tif (strcmp(socketLockFile, DIRECTORY_LOCK_FILE) == 0)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * utime() is POSIX standard, utimes() is a common alternative; if we\n\t\t * have neither, fall back to actually reading the file (which only\n\t\t * sets the access time not mod time, but that should be enough in\n\t\t * most cases).  In all paths, we ignore errors.\n\t\t */\n#ifdef HAVE_UTIME\n\t\tutime(socketLockFile, NULL);\n#else\t\t\t\t\t\t\t/* !HAVE_UTIME */\n#ifdef HAVE_UTIMES\n\t\tutimes(socketLockFile, NULL);\n#else\t\t\t\t\t\t\t/* !HAVE_UTIMES */\n\t\tint\t\t\tfd;\n\t\tchar\t\tbuffer[1];\n\n\t\tfd = open(socketLockFile, O_RDONLY | PG_BINARY, 0);\n\t\tif (fd >= 0)\n\t\t{\n\t\t\tread(fd, buffer, sizeof(buffer));\n\t\t\tclose(fd);\n\t\t}\n#endif\t\t\t\t\t\t\t/* HAVE_UTIMES */\n#endif\t\t\t\t\t\t\t/* HAVE_UTIME */\n\t}\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pidfile.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/pg_shmem.h\"",
      "#include \"storage/latch.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/fd.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"postmaster/autovacuum.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"common/file_perm.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/htup_details.h\"",
      "#include <utime.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <sys/param.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define DIRECTORY_LOCK_FILE\t\t\"postmaster.pid\""
    ],
    "globals_used": [
      "static List *lock_files = NIL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 1235
        },
        "resolved": true,
        "details": {
          "function_name": "close_lb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "3105-3119",
          "snippet": "Datum\nclose_lb(PG_FUNCTION_ARGS)\n{\n#ifdef NOT_USED\n\tLINE\t   *line = PG_GETARG_LINE_P(0);\n\tBOX\t\t   *box = PG_GETARG_BOX_P(1);\n#endif\n\n\t/* think about this one for a while */\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t errmsg(\"function \\\"close_lb\\\" not implemented\")));\n\n\tPG_RETURN_NULL();\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double box_ht(BOX *box);",
            "static double box_wd(BOX *box);",
            "static double box_ar(BOX *box);",
            "static void box_cn(Point *center, BOX *box);",
            "static Point *interpt_sl(LSEG *lseg, LINE *line);",
            "static bool has_interpt_sl(LSEG *lseg, LINE *line);",
            "static double dist_pl_internal(Point *pt, LINE *line);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double box_ht(BOX *box);\nstatic double box_wd(BOX *box);\nstatic double box_ar(BOX *box);\nstatic void box_cn(Point *center, BOX *box);\nstatic Point *interpt_sl(LSEG *lseg, LINE *line);\nstatic bool has_interpt_sl(LSEG *lseg, LINE *line);\nstatic double dist_pl_internal(Point *pt, LINE *line);\n\nDatum\nclose_lb(PG_FUNCTION_ARGS)\n{\n#ifdef NOT_USED\n\tLINE\t   *line = PG_GETARG_LINE_P(0);\n\tBOX\t\t   *box = PG_GETARG_BOX_P(1);\n#endif\n\n\t/* think about this one for a while */\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t errmsg(\"function \\\"close_lb\\\" not implemented\")));\n\n\tPG_RETURN_NULL();\n}"
        }
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "fd",
            "buffer",
            "sizeof(buffer)"
          ],
          "line": 1234
        },
        "resolved": true,
        "details": {
          "function_name": "tuplestore_copy_read_pointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplestore.c",
          "lines": "1267-1345",
          "snippet": "void\ntuplestore_copy_read_pointer(Tuplestorestate *state,\n\t\t\t\t\t\t\t int srcptr, int destptr)\n{\n\tTSReadPointer *sptr = &state->readptrs[srcptr];\n\tTSReadPointer *dptr = &state->readptrs[destptr];\n\n\tAssert(srcptr >= 0 && srcptr < state->readptrcount);\n\tAssert(destptr >= 0 && destptr < state->readptrcount);\n\n\t/* Assigning to self is a no-op */\n\tif (srcptr == destptr)\n\t\treturn;\n\n\tif (dptr->eflags != sptr->eflags)\n\t{\n\t\t/* Possible change of overall eflags, so copy and then recompute */\n\t\tint\t\t\teflags;\n\t\tint\t\t\ti;\n\n\t\t*dptr = *sptr;\n\t\teflags = state->readptrs[0].eflags;\n\t\tfor (i = 1; i < state->readptrcount; i++)\n\t\t\teflags |= state->readptrs[i].eflags;\n\t\tstate->eflags = eflags;\n\t}\n\telse\n\t\t*dptr = *sptr;\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INMEM:\n\t\tcase TSS_WRITEFILE:\n\t\t\t/* no work */\n\t\t\tbreak;\n\t\tcase TSS_READFILE:\n\n\t\t\t/*\n\t\t\t * This case is a bit tricky since the active read pointer's\n\t\t\t * position corresponds to the seek point, not what is in its\n\t\t\t * variables.  Assigning to the active requires a seek, and\n\t\t\t * assigning from the active requires a tell, except when\n\t\t\t * eof_reached.\n\t\t\t */\n\t\t\tif (destptr == state->activeptr)\n\t\t\t{\n\t\t\t\tif (dptr->eof_reached)\n\t\t\t\t{\n\t\t\t\t\tif (BufFileSeek(state->myfile,\n\t\t\t\t\t\t\t\t\tstate->writepos_file,\n\t\t\t\t\t\t\t\t\tstate->writepos_offset,\n\t\t\t\t\t\t\t\t\tSEEK_SET) != 0)\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (BufFileSeek(state->myfile,\n\t\t\t\t\t\t\t\t\tdptr->file, dptr->offset,\n\t\t\t\t\t\t\t\t\tSEEK_SET) != 0)\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (srcptr == state->activeptr)\n\t\t\t{\n\t\t\t\tif (!dptr->eof_reached)\n\t\t\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t\t\t&dptr->file,\n\t\t\t\t\t\t\t\t&dptr->offset);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplestore state\");\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"utils/resowner.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void dumptuples(Tuplestorestate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/resowner.h\"\n#include \"utils/memutils.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void dumptuples(Tuplestorestate *state);\n\nvoid\ntuplestore_copy_read_pointer(Tuplestorestate *state,\n\t\t\t\t\t\t\t int srcptr, int destptr)\n{\n\tTSReadPointer *sptr = &state->readptrs[srcptr];\n\tTSReadPointer *dptr = &state->readptrs[destptr];\n\n\tAssert(srcptr >= 0 && srcptr < state->readptrcount);\n\tAssert(destptr >= 0 && destptr < state->readptrcount);\n\n\t/* Assigning to self is a no-op */\n\tif (srcptr == destptr)\n\t\treturn;\n\n\tif (dptr->eflags != sptr->eflags)\n\t{\n\t\t/* Possible change of overall eflags, so copy and then recompute */\n\t\tint\t\t\teflags;\n\t\tint\t\t\ti;\n\n\t\t*dptr = *sptr;\n\t\teflags = state->readptrs[0].eflags;\n\t\tfor (i = 1; i < state->readptrcount; i++)\n\t\t\teflags |= state->readptrs[i].eflags;\n\t\tstate->eflags = eflags;\n\t}\n\telse\n\t\t*dptr = *sptr;\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INMEM:\n\t\tcase TSS_WRITEFILE:\n\t\t\t/* no work */\n\t\t\tbreak;\n\t\tcase TSS_READFILE:\n\n\t\t\t/*\n\t\t\t * This case is a bit tricky since the active read pointer's\n\t\t\t * position corresponds to the seek point, not what is in its\n\t\t\t * variables.  Assigning to the active requires a seek, and\n\t\t\t * assigning from the active requires a tell, except when\n\t\t\t * eof_reached.\n\t\t\t */\n\t\t\tif (destptr == state->activeptr)\n\t\t\t{\n\t\t\t\tif (dptr->eof_reached)\n\t\t\t\t{\n\t\t\t\t\tif (BufFileSeek(state->myfile,\n\t\t\t\t\t\t\t\t\tstate->writepos_file,\n\t\t\t\t\t\t\t\t\tstate->writepos_offset,\n\t\t\t\t\t\t\t\t\tSEEK_SET) != 0)\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (BufFileSeek(state->myfile,\n\t\t\t\t\t\t\t\t\tdptr->file, dptr->offset,\n\t\t\t\t\t\t\t\t\tSEEK_SET) != 0)\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (srcptr == state->activeptr)\n\t\t\t{\n\t\t\t\tif (!dptr->eof_reached)\n\t\t\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t\t\t&dptr->file,\n\t\t\t\t\t\t\t\t&dptr->offset);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplestore state\");\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "socketLockFile",
            "O_RDONLY | PG_BINARY",
            "0"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "utimes",
          "args": [
            "socketLockFile",
            "NULL"
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "utime",
          "args": [
            "socketLockFile",
            "NULL"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "socketLockFile",
            "DIRECTORY_LOCK_FILE"
          ],
          "line": 1213
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "246-256",
          "snippet": "int\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lfirst",
          "args": [
            "l"
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "l",
            "lock_files"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\n#define DIRECTORY_LOCK_FILE\t\t\"postmaster.pid\"\n\nstatic List *lock_files = NIL;\n\nvoid\nTouchSocketLockFiles(void)\n{\n\tListCell   *l;\n\n\tforeach(l, lock_files)\n\t{\n\t\tchar\t   *socketLockFile = (char *) lfirst(l);\n\n\t\t/* No need to touch the data directory lock file, we trust */\n\t\tif (strcmp(socketLockFile, DIRECTORY_LOCK_FILE) == 0)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * utime() is POSIX standard, utimes() is a common alternative; if we\n\t\t * have neither, fall back to actually reading the file (which only\n\t\t * sets the access time not mod time, but that should be enough in\n\t\t * most cases).  In all paths, we ignore errors.\n\t\t */\n#ifdef HAVE_UTIME\n\t\tutime(socketLockFile, NULL);\n#else\t\t\t\t\t\t\t/* !HAVE_UTIME */\n#ifdef HAVE_UTIMES\n\t\tutimes(socketLockFile, NULL);\n#else\t\t\t\t\t\t\t/* !HAVE_UTIMES */\n\t\tint\t\t\tfd;\n\t\tchar\t\tbuffer[1];\n\n\t\tfd = open(socketLockFile, O_RDONLY | PG_BINARY, 0);\n\t\tif (fd >= 0)\n\t\t{\n\t\t\tread(fd, buffer, sizeof(buffer));\n\t\t\tclose(fd);\n\t\t}\n#endif\t\t\t\t\t\t\t/* HAVE_UTIMES */\n#endif\t\t\t\t\t\t\t/* HAVE_UTIME */\n\t}\n}"
  },
  {
    "function_name": "CreateSocketLockFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
    "lines": "1185-1193",
    "snippet": "void\nCreateSocketLockFile(const char *socketfile, bool amPostmaster,\n\t\t\t\t\t const char *socketDir)\n{\n\tchar\t\tlockfile[MAXPGPATH];\n\n\tsnprintf(lockfile, sizeof(lockfile), \"%s.lock\", socketfile);\n\tCreateLockFile(lockfile, amPostmaster, socketDir, false, socketfile);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pidfile.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/pg_shmem.h\"",
      "#include \"storage/latch.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/fd.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"postmaster/autovacuum.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"common/file_perm.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/htup_details.h\"",
      "#include <utime.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <sys/param.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CreateLockFile",
          "args": [
            "lockfile",
            "amPostmaster",
            "socketDir",
            "false",
            "socketfile"
          ],
          "line": 1192
        },
        "resolved": true,
        "details": {
          "function_name": "CreateLockFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
          "lines": "871-1164",
          "snippet": "static void\nCreateLockFile(const char *filename, bool amPostmaster,\n\t\t\t   const char *socketDir,\n\t\t\t   bool isDDLock, const char *refName)\n{\n\tint\t\t\tfd;\n\tchar\t\tbuffer[MAXPGPATH * 2 + 256];\n\tint\t\t\tntries;\n\tint\t\t\tlen;\n\tint\t\t\tencoded_pid;\n\tpid_t\t\tother_pid;\n\tpid_t\t\tmy_pid,\n\t\t\t\tmy_p_pid,\n\t\t\t\tmy_gp_pid;\n\tconst char *envvar;\n\n\t/*\n\t * If the PID in the lockfile is our own PID or our parent's or\n\t * grandparent's PID, then the file must be stale (probably left over from\n\t * a previous system boot cycle).  We need to check this because of the\n\t * likelihood that a reboot will assign exactly the same PID as we had in\n\t * the previous reboot, or one that's only one or two counts larger and\n\t * hence the lockfile's PID now refers to an ancestor shell process.  We\n\t * allow pg_ctl to pass down its parent shell PID (our grandparent PID)\n\t * via the environment variable PG_GRANDPARENT_PID; this is so that\n\t * launching the postmaster via pg_ctl can be just as reliable as\n\t * launching it directly.  There is no provision for detecting\n\t * further-removed ancestor processes, but if the init script is written\n\t * carefully then all but the immediate parent shell will be root-owned\n\t * processes and so the kill test will fail with EPERM.  Note that we\n\t * cannot get a false negative this way, because an existing postmaster\n\t * would surely never launch a competing postmaster or pg_ctl process\n\t * directly.\n\t */\n\tmy_pid = getpid();\n\n#ifndef WIN32\n\tmy_p_pid = getppid();\n#else\n\n\t/*\n\t * Windows hasn't got getppid(), but doesn't need it since it's not using\n\t * real kill() either...\n\t */\n\tmy_p_pid = 0;\n#endif\n\n\tenvvar = getenv(\"PG_GRANDPARENT_PID\");\n\tif (envvar)\n\t\tmy_gp_pid = atoi(envvar);\n\telse\n\t\tmy_gp_pid = 0;\n\n\t/*\n\t * We need a loop here because of race conditions.  But don't loop forever\n\t * (for example, a non-writable $PGDATA directory might cause a failure\n\t * that won't go away).  100 tries seems like plenty.\n\t */\n\tfor (ntries = 0;; ntries++)\n\t{\n\t\t/*\n\t\t * Try to create the lock file --- O_EXCL makes this atomic.\n\t\t *\n\t\t * Think not to make the file protection weaker than 0600/0640.  See\n\t\t * comments below.\n\t\t */\n\t\tfd = open(filename, O_RDWR | O_CREAT | O_EXCL, pg_file_create_mode);\n\t\tif (fd >= 0)\n\t\t\tbreak;\t\t\t\t/* Success; exit the retry loop */\n\n\t\t/*\n\t\t * Couldn't create the pid file. Probably it already exists.\n\t\t */\n\t\tif ((errno != EEXIST && errno != EACCES) || ntries > 100)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not create lock file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tfilename)));\n\n\t\t/*\n\t\t * Read the file to get the old owner's PID.  Note race condition\n\t\t * here: file might have been deleted since we tried to create it.\n\t\t */\n\t\tfd = open(filename, O_RDONLY, pg_file_create_mode);\n\t\tif (fd < 0)\n\t\t{\n\t\t\tif (errno == ENOENT)\n\t\t\t\tcontinue;\t\t/* race condition; try again */\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not open lock file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tfilename)));\n\t\t}\n\t\tpgstat_report_wait_start(WAIT_EVENT_LOCK_FILE_CREATE_READ);\n\t\tif ((len = read(fd, buffer, sizeof(buffer) - 1)) < 0)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not read lock file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tfilename)));\n\t\tpgstat_report_wait_end();\n\t\tclose(fd);\n\n\t\tif (len == 0)\n\t\t{\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_LOCK_FILE_EXISTS),\n\t\t\t\t\t errmsg(\"lock file \\\"%s\\\" is empty\", filename),\n\t\t\t\t\t errhint(\"Either another server is starting, or the lock file is the remnant of a previous server startup crash.\")));\n\t\t}\n\n\t\tbuffer[len] = '\\0';\n\t\tencoded_pid = atoi(buffer);\n\n\t\t/* if pid < 0, the pid is for postgres, not postmaster */\n\t\tother_pid = (pid_t) (encoded_pid < 0 ? -encoded_pid : encoded_pid);\n\n\t\tif (other_pid <= 0)\n\t\t\telog(FATAL, \"bogus data in lock file \\\"%s\\\": \\\"%s\\\"\",\n\t\t\t\t filename, buffer);\n\n\t\t/*\n\t\t * Check to see if the other process still exists\n\t\t *\n\t\t * Per discussion above, my_pid, my_p_pid, and my_gp_pid can be\n\t\t * ignored as false matches.\n\t\t *\n\t\t * Normally kill() will fail with ESRCH if the given PID doesn't\n\t\t * exist.\n\t\t *\n\t\t * We can treat the EPERM-error case as okay because that error\n\t\t * implies that the existing process has a different userid than we\n\t\t * do, which means it cannot be a competing postmaster.  A postmaster\n\t\t * cannot successfully attach to a data directory owned by a userid\n\t\t * other than its own, as enforced in checkDataDir(). Also, since we\n\t\t * create the lockfiles mode 0600/0640, we'd have failed above if the\n\t\t * lockfile belonged to another userid --- which means that whatever\n\t\t * process kill() is reporting about isn't the one that made the\n\t\t * lockfile.  (NOTE: this last consideration is the only one that\n\t\t * keeps us from blowing away a Unix socket file belonging to an\n\t\t * instance of Postgres being run by someone else, at least on\n\t\t * machines where /tmp hasn't got a stickybit.)\n\t\t */\n\t\tif (other_pid != my_pid && other_pid != my_p_pid &&\n\t\t\tother_pid != my_gp_pid)\n\t\t{\n\t\t\tif (kill(other_pid, 0) == 0 ||\n\t\t\t\t(errno != ESRCH && errno != EPERM))\n\t\t\t{\n\t\t\t\t/* lockfile belongs to a live process */\n\t\t\t\tereport(FATAL,\n\t\t\t\t\t\t(errcode(ERRCODE_LOCK_FILE_EXISTS),\n\t\t\t\t\t\t errmsg(\"lock file \\\"%s\\\" already exists\",\n\t\t\t\t\t\t\t\tfilename),\n\t\t\t\t\t\t isDDLock ?\n\t\t\t\t\t\t (encoded_pid < 0 ?\n\t\t\t\t\t\t  errhint(\"Is another postgres (PID %d) running in data directory \\\"%s\\\"?\",\n\t\t\t\t\t\t\t\t  (int) other_pid, refName) :\n\t\t\t\t\t\t  errhint(\"Is another postmaster (PID %d) running in data directory \\\"%s\\\"?\",\n\t\t\t\t\t\t\t\t  (int) other_pid, refName)) :\n\t\t\t\t\t\t (encoded_pid < 0 ?\n\t\t\t\t\t\t  errhint(\"Is another postgres (PID %d) using socket file \\\"%s\\\"?\",\n\t\t\t\t\t\t\t\t  (int) other_pid, refName) :\n\t\t\t\t\t\t  errhint(\"Is another postmaster (PID %d) using socket file \\\"%s\\\"?\",\n\t\t\t\t\t\t\t\t  (int) other_pid, refName))));\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * No, the creating process did not exist.  However, it could be that\n\t\t * the postmaster crashed (or more likely was kill -9'd by a clueless\n\t\t * admin) but has left orphan backends behind.  Check for this by\n\t\t * looking to see if there is an associated shmem segment that is\n\t\t * still in use.\n\t\t *\n\t\t * Note: because postmaster.pid is written in multiple steps, we might\n\t\t * not find the shmem ID values in it; we can't treat that as an\n\t\t * error.\n\t\t */\n\t\tif (isDDLock)\n\t\t{\n\t\t\tchar\t   *ptr = buffer;\n\t\t\tunsigned long id1,\n\t\t\t\t\t\tid2;\n\t\t\tint\t\t\tlineno;\n\n\t\t\tfor (lineno = 1; lineno < LOCK_FILE_LINE_SHMEM_KEY; lineno++)\n\t\t\t{\n\t\t\t\tif ((ptr = strchr(ptr, '\\n')) == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tptr++;\n\t\t\t}\n\n\t\t\tif (ptr != NULL &&\n\t\t\t\tsscanf(ptr, \"%lu %lu\", &id1, &id2) == 2)\n\t\t\t{\n\t\t\t\tif (PGSharedMemoryIsInUse(id1, id2))\n\t\t\t\t\tereport(FATAL,\n\t\t\t\t\t\t\t(errcode(ERRCODE_LOCK_FILE_EXISTS),\n\t\t\t\t\t\t\t errmsg(\"pre-existing shared memory block (key %lu, ID %lu) is still in use\",\n\t\t\t\t\t\t\t\t\tid1, id2),\n\t\t\t\t\t\t\t errhint(\"Terminate any old server processes associated with data directory \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t\t refName)));\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Looks like nobody's home.  Unlink the file and try again to create\n\t\t * it.  Need a loop because of possible race condition against other\n\t\t * would-be creators.\n\t\t */\n\t\tif (unlink(filename) < 0)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not remove old lock file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tfilename),\n\t\t\t\t\t errhint(\"The file seems accidentally left over, but \"\n\t\t\t\t\t\t\t \"it could not be removed. Please remove the file \"\n\t\t\t\t\t\t\t \"by hand and try again.\")));\n\t}\n\n\t/*\n\t * Successfully created the file, now fill it.  See comment in miscadmin.h\n\t * about the contents.  Note that we write the same first five lines into\n\t * both datadir and socket lockfiles; although more stuff may get added to\n\t * the datadir lockfile later.\n\t */\n\tsnprintf(buffer, sizeof(buffer), \"%d\\n%s\\n%ld\\n%d\\n%s\\n\",\n\t\t\t amPostmaster ? (int) my_pid : -((int) my_pid),\n\t\t\t DataDir,\n\t\t\t (long) MyStartTime,\n\t\t\t PostPortNumber,\n\t\t\t socketDir);\n\n\t/*\n\t * In a standalone backend, the next line (LOCK_FILE_LINE_LISTEN_ADDR)\n\t * will never receive data, so fill it in as empty now.\n\t */\n\tif (isDDLock && !amPostmaster)\n\t\tstrlcat(buffer, \"\\n\", sizeof(buffer));\n\n\terrno = 0;\n\tpgstat_report_wait_start(WAIT_EVENT_LOCK_FILE_CREATE_WRITE);\n\tif (write(fd, buffer, strlen(buffer)) != strlen(buffer))\n\t{\n\t\tint\t\t\tsave_errno = errno;\n\n\t\tclose(fd);\n\t\tunlink(filename);\n\t\t/* if write didn't set errno, assume problem is no disk space */\n\t\terrno = save_errno ? save_errno : ENOSPC;\n\t\tereport(FATAL,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write lock file \\\"%s\\\": %m\", filename)));\n\t}\n\tpgstat_report_wait_end();\n\n\tpgstat_report_wait_start(WAIT_EVENT_LOCK_FILE_CREATE_SYNC);\n\tif (pg_fsync(fd) != 0)\n\t{\n\t\tint\t\t\tsave_errno = errno;\n\n\t\tclose(fd);\n\t\tunlink(filename);\n\t\terrno = save_errno;\n\t\tereport(FATAL,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write lock file \\\"%s\\\": %m\", filename)));\n\t}\n\tpgstat_report_wait_end();\n\tif (close(fd) != 0)\n\t{\n\t\tint\t\t\tsave_errno = errno;\n\n\t\tunlink(filename);\n\t\terrno = save_errno;\n\t\tereport(FATAL,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write lock file \\\"%s\\\": %m\", filename)));\n\t}\n\n\t/*\n\t * Arrange to unlink the lock file(s) at proc_exit.  If this is the first\n\t * one, set up the on_proc_exit function to do it; then add this lock file\n\t * to the list of files to unlink.\n\t */\n\tif (lock_files == NIL)\n\t\ton_proc_exit(UnlinkLockFiles, 0);\n\n\t/*\n\t * Use lcons so that the lock files are unlinked in reverse order of\n\t * creation; this is critical!\n\t */\n\tlock_files = lcons(pstrdup(filename), lock_files);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pidfile.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pg_shmem.h\"",
            "#include \"storage/latch.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/fd.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"common/file_perm.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/htup_details.h\"",
            "#include <utime.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/param.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static List *lock_files = NIL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nstatic List *lock_files = NIL;\n\nstatic void\nCreateLockFile(const char *filename, bool amPostmaster,\n\t\t\t   const char *socketDir,\n\t\t\t   bool isDDLock, const char *refName)\n{\n\tint\t\t\tfd;\n\tchar\t\tbuffer[MAXPGPATH * 2 + 256];\n\tint\t\t\tntries;\n\tint\t\t\tlen;\n\tint\t\t\tencoded_pid;\n\tpid_t\t\tother_pid;\n\tpid_t\t\tmy_pid,\n\t\t\t\tmy_p_pid,\n\t\t\t\tmy_gp_pid;\n\tconst char *envvar;\n\n\t/*\n\t * If the PID in the lockfile is our own PID or our parent's or\n\t * grandparent's PID, then the file must be stale (probably left over from\n\t * a previous system boot cycle).  We need to check this because of the\n\t * likelihood that a reboot will assign exactly the same PID as we had in\n\t * the previous reboot, or one that's only one or two counts larger and\n\t * hence the lockfile's PID now refers to an ancestor shell process.  We\n\t * allow pg_ctl to pass down its parent shell PID (our grandparent PID)\n\t * via the environment variable PG_GRANDPARENT_PID; this is so that\n\t * launching the postmaster via pg_ctl can be just as reliable as\n\t * launching it directly.  There is no provision for detecting\n\t * further-removed ancestor processes, but if the init script is written\n\t * carefully then all but the immediate parent shell will be root-owned\n\t * processes and so the kill test will fail with EPERM.  Note that we\n\t * cannot get a false negative this way, because an existing postmaster\n\t * would surely never launch a competing postmaster or pg_ctl process\n\t * directly.\n\t */\n\tmy_pid = getpid();\n\n#ifndef WIN32\n\tmy_p_pid = getppid();\n#else\n\n\t/*\n\t * Windows hasn't got getppid(), but doesn't need it since it's not using\n\t * real kill() either...\n\t */\n\tmy_p_pid = 0;\n#endif\n\n\tenvvar = getenv(\"PG_GRANDPARENT_PID\");\n\tif (envvar)\n\t\tmy_gp_pid = atoi(envvar);\n\telse\n\t\tmy_gp_pid = 0;\n\n\t/*\n\t * We need a loop here because of race conditions.  But don't loop forever\n\t * (for example, a non-writable $PGDATA directory might cause a failure\n\t * that won't go away).  100 tries seems like plenty.\n\t */\n\tfor (ntries = 0;; ntries++)\n\t{\n\t\t/*\n\t\t * Try to create the lock file --- O_EXCL makes this atomic.\n\t\t *\n\t\t * Think not to make the file protection weaker than 0600/0640.  See\n\t\t * comments below.\n\t\t */\n\t\tfd = open(filename, O_RDWR | O_CREAT | O_EXCL, pg_file_create_mode);\n\t\tif (fd >= 0)\n\t\t\tbreak;\t\t\t\t/* Success; exit the retry loop */\n\n\t\t/*\n\t\t * Couldn't create the pid file. Probably it already exists.\n\t\t */\n\t\tif ((errno != EEXIST && errno != EACCES) || ntries > 100)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not create lock file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tfilename)));\n\n\t\t/*\n\t\t * Read the file to get the old owner's PID.  Note race condition\n\t\t * here: file might have been deleted since we tried to create it.\n\t\t */\n\t\tfd = open(filename, O_RDONLY, pg_file_create_mode);\n\t\tif (fd < 0)\n\t\t{\n\t\t\tif (errno == ENOENT)\n\t\t\t\tcontinue;\t\t/* race condition; try again */\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not open lock file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tfilename)));\n\t\t}\n\t\tpgstat_report_wait_start(WAIT_EVENT_LOCK_FILE_CREATE_READ);\n\t\tif ((len = read(fd, buffer, sizeof(buffer) - 1)) < 0)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not read lock file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tfilename)));\n\t\tpgstat_report_wait_end();\n\t\tclose(fd);\n\n\t\tif (len == 0)\n\t\t{\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_LOCK_FILE_EXISTS),\n\t\t\t\t\t errmsg(\"lock file \\\"%s\\\" is empty\", filename),\n\t\t\t\t\t errhint(\"Either another server is starting, or the lock file is the remnant of a previous server startup crash.\")));\n\t\t}\n\n\t\tbuffer[len] = '\\0';\n\t\tencoded_pid = atoi(buffer);\n\n\t\t/* if pid < 0, the pid is for postgres, not postmaster */\n\t\tother_pid = (pid_t) (encoded_pid < 0 ? -encoded_pid : encoded_pid);\n\n\t\tif (other_pid <= 0)\n\t\t\telog(FATAL, \"bogus data in lock file \\\"%s\\\": \\\"%s\\\"\",\n\t\t\t\t filename, buffer);\n\n\t\t/*\n\t\t * Check to see if the other process still exists\n\t\t *\n\t\t * Per discussion above, my_pid, my_p_pid, and my_gp_pid can be\n\t\t * ignored as false matches.\n\t\t *\n\t\t * Normally kill() will fail with ESRCH if the given PID doesn't\n\t\t * exist.\n\t\t *\n\t\t * We can treat the EPERM-error case as okay because that error\n\t\t * implies that the existing process has a different userid than we\n\t\t * do, which means it cannot be a competing postmaster.  A postmaster\n\t\t * cannot successfully attach to a data directory owned by a userid\n\t\t * other than its own, as enforced in checkDataDir(). Also, since we\n\t\t * create the lockfiles mode 0600/0640, we'd have failed above if the\n\t\t * lockfile belonged to another userid --- which means that whatever\n\t\t * process kill() is reporting about isn't the one that made the\n\t\t * lockfile.  (NOTE: this last consideration is the only one that\n\t\t * keeps us from blowing away a Unix socket file belonging to an\n\t\t * instance of Postgres being run by someone else, at least on\n\t\t * machines where /tmp hasn't got a stickybit.)\n\t\t */\n\t\tif (other_pid != my_pid && other_pid != my_p_pid &&\n\t\t\tother_pid != my_gp_pid)\n\t\t{\n\t\t\tif (kill(other_pid, 0) == 0 ||\n\t\t\t\t(errno != ESRCH && errno != EPERM))\n\t\t\t{\n\t\t\t\t/* lockfile belongs to a live process */\n\t\t\t\tereport(FATAL,\n\t\t\t\t\t\t(errcode(ERRCODE_LOCK_FILE_EXISTS),\n\t\t\t\t\t\t errmsg(\"lock file \\\"%s\\\" already exists\",\n\t\t\t\t\t\t\t\tfilename),\n\t\t\t\t\t\t isDDLock ?\n\t\t\t\t\t\t (encoded_pid < 0 ?\n\t\t\t\t\t\t  errhint(\"Is another postgres (PID %d) running in data directory \\\"%s\\\"?\",\n\t\t\t\t\t\t\t\t  (int) other_pid, refName) :\n\t\t\t\t\t\t  errhint(\"Is another postmaster (PID %d) running in data directory \\\"%s\\\"?\",\n\t\t\t\t\t\t\t\t  (int) other_pid, refName)) :\n\t\t\t\t\t\t (encoded_pid < 0 ?\n\t\t\t\t\t\t  errhint(\"Is another postgres (PID %d) using socket file \\\"%s\\\"?\",\n\t\t\t\t\t\t\t\t  (int) other_pid, refName) :\n\t\t\t\t\t\t  errhint(\"Is another postmaster (PID %d) using socket file \\\"%s\\\"?\",\n\t\t\t\t\t\t\t\t  (int) other_pid, refName))));\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * No, the creating process did not exist.  However, it could be that\n\t\t * the postmaster crashed (or more likely was kill -9'd by a clueless\n\t\t * admin) but has left orphan backends behind.  Check for this by\n\t\t * looking to see if there is an associated shmem segment that is\n\t\t * still in use.\n\t\t *\n\t\t * Note: because postmaster.pid is written in multiple steps, we might\n\t\t * not find the shmem ID values in it; we can't treat that as an\n\t\t * error.\n\t\t */\n\t\tif (isDDLock)\n\t\t{\n\t\t\tchar\t   *ptr = buffer;\n\t\t\tunsigned long id1,\n\t\t\t\t\t\tid2;\n\t\t\tint\t\t\tlineno;\n\n\t\t\tfor (lineno = 1; lineno < LOCK_FILE_LINE_SHMEM_KEY; lineno++)\n\t\t\t{\n\t\t\t\tif ((ptr = strchr(ptr, '\\n')) == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tptr++;\n\t\t\t}\n\n\t\t\tif (ptr != NULL &&\n\t\t\t\tsscanf(ptr, \"%lu %lu\", &id1, &id2) == 2)\n\t\t\t{\n\t\t\t\tif (PGSharedMemoryIsInUse(id1, id2))\n\t\t\t\t\tereport(FATAL,\n\t\t\t\t\t\t\t(errcode(ERRCODE_LOCK_FILE_EXISTS),\n\t\t\t\t\t\t\t errmsg(\"pre-existing shared memory block (key %lu, ID %lu) is still in use\",\n\t\t\t\t\t\t\t\t\tid1, id2),\n\t\t\t\t\t\t\t errhint(\"Terminate any old server processes associated with data directory \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t\t refName)));\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Looks like nobody's home.  Unlink the file and try again to create\n\t\t * it.  Need a loop because of possible race condition against other\n\t\t * would-be creators.\n\t\t */\n\t\tif (unlink(filename) < 0)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not remove old lock file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tfilename),\n\t\t\t\t\t errhint(\"The file seems accidentally left over, but \"\n\t\t\t\t\t\t\t \"it could not be removed. Please remove the file \"\n\t\t\t\t\t\t\t \"by hand and try again.\")));\n\t}\n\n\t/*\n\t * Successfully created the file, now fill it.  See comment in miscadmin.h\n\t * about the contents.  Note that we write the same first five lines into\n\t * both datadir and socket lockfiles; although more stuff may get added to\n\t * the datadir lockfile later.\n\t */\n\tsnprintf(buffer, sizeof(buffer), \"%d\\n%s\\n%ld\\n%d\\n%s\\n\",\n\t\t\t amPostmaster ? (int) my_pid : -((int) my_pid),\n\t\t\t DataDir,\n\t\t\t (long) MyStartTime,\n\t\t\t PostPortNumber,\n\t\t\t socketDir);\n\n\t/*\n\t * In a standalone backend, the next line (LOCK_FILE_LINE_LISTEN_ADDR)\n\t * will never receive data, so fill it in as empty now.\n\t */\n\tif (isDDLock && !amPostmaster)\n\t\tstrlcat(buffer, \"\\n\", sizeof(buffer));\n\n\terrno = 0;\n\tpgstat_report_wait_start(WAIT_EVENT_LOCK_FILE_CREATE_WRITE);\n\tif (write(fd, buffer, strlen(buffer)) != strlen(buffer))\n\t{\n\t\tint\t\t\tsave_errno = errno;\n\n\t\tclose(fd);\n\t\tunlink(filename);\n\t\t/* if write didn't set errno, assume problem is no disk space */\n\t\terrno = save_errno ? save_errno : ENOSPC;\n\t\tereport(FATAL,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write lock file \\\"%s\\\": %m\", filename)));\n\t}\n\tpgstat_report_wait_end();\n\n\tpgstat_report_wait_start(WAIT_EVENT_LOCK_FILE_CREATE_SYNC);\n\tif (pg_fsync(fd) != 0)\n\t{\n\t\tint\t\t\tsave_errno = errno;\n\n\t\tclose(fd);\n\t\tunlink(filename);\n\t\terrno = save_errno;\n\t\tereport(FATAL,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write lock file \\\"%s\\\": %m\", filename)));\n\t}\n\tpgstat_report_wait_end();\n\tif (close(fd) != 0)\n\t{\n\t\tint\t\t\tsave_errno = errno;\n\n\t\tunlink(filename);\n\t\terrno = save_errno;\n\t\tereport(FATAL,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write lock file \\\"%s\\\": %m\", filename)));\n\t}\n\n\t/*\n\t * Arrange to unlink the lock file(s) at proc_exit.  If this is the first\n\t * one, set up the on_proc_exit function to do it; then add this lock file\n\t * to the list of files to unlink.\n\t */\n\tif (lock_files == NIL)\n\t\ton_proc_exit(UnlinkLockFiles, 0);\n\n\t/*\n\t * Use lcons so that the lock files are unlinked in reverse order of\n\t * creation; this is critical!\n\t */\n\tlock_files = lcons(pstrdup(filename), lock_files);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "lockfile",
            "sizeof(lockfile)",
            "\"%s.lock\"",
            "socketfile"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nvoid\nCreateSocketLockFile(const char *socketfile, bool amPostmaster,\n\t\t\t\t\t const char *socketDir)\n{\n\tchar\t\tlockfile[MAXPGPATH];\n\n\tsnprintf(lockfile, sizeof(lockfile), \"%s.lock\", socketfile);\n\tCreateLockFile(lockfile, amPostmaster, socketDir, false, socketfile);\n}"
  },
  {
    "function_name": "CreateDataDirLockFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
    "lines": "1176-1180",
    "snippet": "void\nCreateDataDirLockFile(bool amPostmaster)\n{\n\tCreateLockFile(DIRECTORY_LOCK_FILE, amPostmaster, \"\", true, DataDir);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pidfile.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/pg_shmem.h\"",
      "#include \"storage/latch.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/fd.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"postmaster/autovacuum.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"common/file_perm.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/htup_details.h\"",
      "#include <utime.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <sys/param.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define DIRECTORY_LOCK_FILE\t\t\"postmaster.pid\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CreateLockFile",
          "args": [
            "DIRECTORY_LOCK_FILE",
            "amPostmaster",
            "\"\"",
            "true",
            "DataDir"
          ],
          "line": 1179
        },
        "resolved": true,
        "details": {
          "function_name": "CreateLockFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
          "lines": "871-1164",
          "snippet": "static void\nCreateLockFile(const char *filename, bool amPostmaster,\n\t\t\t   const char *socketDir,\n\t\t\t   bool isDDLock, const char *refName)\n{\n\tint\t\t\tfd;\n\tchar\t\tbuffer[MAXPGPATH * 2 + 256];\n\tint\t\t\tntries;\n\tint\t\t\tlen;\n\tint\t\t\tencoded_pid;\n\tpid_t\t\tother_pid;\n\tpid_t\t\tmy_pid,\n\t\t\t\tmy_p_pid,\n\t\t\t\tmy_gp_pid;\n\tconst char *envvar;\n\n\t/*\n\t * If the PID in the lockfile is our own PID or our parent's or\n\t * grandparent's PID, then the file must be stale (probably left over from\n\t * a previous system boot cycle).  We need to check this because of the\n\t * likelihood that a reboot will assign exactly the same PID as we had in\n\t * the previous reboot, or one that's only one or two counts larger and\n\t * hence the lockfile's PID now refers to an ancestor shell process.  We\n\t * allow pg_ctl to pass down its parent shell PID (our grandparent PID)\n\t * via the environment variable PG_GRANDPARENT_PID; this is so that\n\t * launching the postmaster via pg_ctl can be just as reliable as\n\t * launching it directly.  There is no provision for detecting\n\t * further-removed ancestor processes, but if the init script is written\n\t * carefully then all but the immediate parent shell will be root-owned\n\t * processes and so the kill test will fail with EPERM.  Note that we\n\t * cannot get a false negative this way, because an existing postmaster\n\t * would surely never launch a competing postmaster or pg_ctl process\n\t * directly.\n\t */\n\tmy_pid = getpid();\n\n#ifndef WIN32\n\tmy_p_pid = getppid();\n#else\n\n\t/*\n\t * Windows hasn't got getppid(), but doesn't need it since it's not using\n\t * real kill() either...\n\t */\n\tmy_p_pid = 0;\n#endif\n\n\tenvvar = getenv(\"PG_GRANDPARENT_PID\");\n\tif (envvar)\n\t\tmy_gp_pid = atoi(envvar);\n\telse\n\t\tmy_gp_pid = 0;\n\n\t/*\n\t * We need a loop here because of race conditions.  But don't loop forever\n\t * (for example, a non-writable $PGDATA directory might cause a failure\n\t * that won't go away).  100 tries seems like plenty.\n\t */\n\tfor (ntries = 0;; ntries++)\n\t{\n\t\t/*\n\t\t * Try to create the lock file --- O_EXCL makes this atomic.\n\t\t *\n\t\t * Think not to make the file protection weaker than 0600/0640.  See\n\t\t * comments below.\n\t\t */\n\t\tfd = open(filename, O_RDWR | O_CREAT | O_EXCL, pg_file_create_mode);\n\t\tif (fd >= 0)\n\t\t\tbreak;\t\t\t\t/* Success; exit the retry loop */\n\n\t\t/*\n\t\t * Couldn't create the pid file. Probably it already exists.\n\t\t */\n\t\tif ((errno != EEXIST && errno != EACCES) || ntries > 100)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not create lock file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tfilename)));\n\n\t\t/*\n\t\t * Read the file to get the old owner's PID.  Note race condition\n\t\t * here: file might have been deleted since we tried to create it.\n\t\t */\n\t\tfd = open(filename, O_RDONLY, pg_file_create_mode);\n\t\tif (fd < 0)\n\t\t{\n\t\t\tif (errno == ENOENT)\n\t\t\t\tcontinue;\t\t/* race condition; try again */\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not open lock file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tfilename)));\n\t\t}\n\t\tpgstat_report_wait_start(WAIT_EVENT_LOCK_FILE_CREATE_READ);\n\t\tif ((len = read(fd, buffer, sizeof(buffer) - 1)) < 0)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not read lock file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tfilename)));\n\t\tpgstat_report_wait_end();\n\t\tclose(fd);\n\n\t\tif (len == 0)\n\t\t{\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_LOCK_FILE_EXISTS),\n\t\t\t\t\t errmsg(\"lock file \\\"%s\\\" is empty\", filename),\n\t\t\t\t\t errhint(\"Either another server is starting, or the lock file is the remnant of a previous server startup crash.\")));\n\t\t}\n\n\t\tbuffer[len] = '\\0';\n\t\tencoded_pid = atoi(buffer);\n\n\t\t/* if pid < 0, the pid is for postgres, not postmaster */\n\t\tother_pid = (pid_t) (encoded_pid < 0 ? -encoded_pid : encoded_pid);\n\n\t\tif (other_pid <= 0)\n\t\t\telog(FATAL, \"bogus data in lock file \\\"%s\\\": \\\"%s\\\"\",\n\t\t\t\t filename, buffer);\n\n\t\t/*\n\t\t * Check to see if the other process still exists\n\t\t *\n\t\t * Per discussion above, my_pid, my_p_pid, and my_gp_pid can be\n\t\t * ignored as false matches.\n\t\t *\n\t\t * Normally kill() will fail with ESRCH if the given PID doesn't\n\t\t * exist.\n\t\t *\n\t\t * We can treat the EPERM-error case as okay because that error\n\t\t * implies that the existing process has a different userid than we\n\t\t * do, which means it cannot be a competing postmaster.  A postmaster\n\t\t * cannot successfully attach to a data directory owned by a userid\n\t\t * other than its own, as enforced in checkDataDir(). Also, since we\n\t\t * create the lockfiles mode 0600/0640, we'd have failed above if the\n\t\t * lockfile belonged to another userid --- which means that whatever\n\t\t * process kill() is reporting about isn't the one that made the\n\t\t * lockfile.  (NOTE: this last consideration is the only one that\n\t\t * keeps us from blowing away a Unix socket file belonging to an\n\t\t * instance of Postgres being run by someone else, at least on\n\t\t * machines where /tmp hasn't got a stickybit.)\n\t\t */\n\t\tif (other_pid != my_pid && other_pid != my_p_pid &&\n\t\t\tother_pid != my_gp_pid)\n\t\t{\n\t\t\tif (kill(other_pid, 0) == 0 ||\n\t\t\t\t(errno != ESRCH && errno != EPERM))\n\t\t\t{\n\t\t\t\t/* lockfile belongs to a live process */\n\t\t\t\tereport(FATAL,\n\t\t\t\t\t\t(errcode(ERRCODE_LOCK_FILE_EXISTS),\n\t\t\t\t\t\t errmsg(\"lock file \\\"%s\\\" already exists\",\n\t\t\t\t\t\t\t\tfilename),\n\t\t\t\t\t\t isDDLock ?\n\t\t\t\t\t\t (encoded_pid < 0 ?\n\t\t\t\t\t\t  errhint(\"Is another postgres (PID %d) running in data directory \\\"%s\\\"?\",\n\t\t\t\t\t\t\t\t  (int) other_pid, refName) :\n\t\t\t\t\t\t  errhint(\"Is another postmaster (PID %d) running in data directory \\\"%s\\\"?\",\n\t\t\t\t\t\t\t\t  (int) other_pid, refName)) :\n\t\t\t\t\t\t (encoded_pid < 0 ?\n\t\t\t\t\t\t  errhint(\"Is another postgres (PID %d) using socket file \\\"%s\\\"?\",\n\t\t\t\t\t\t\t\t  (int) other_pid, refName) :\n\t\t\t\t\t\t  errhint(\"Is another postmaster (PID %d) using socket file \\\"%s\\\"?\",\n\t\t\t\t\t\t\t\t  (int) other_pid, refName))));\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * No, the creating process did not exist.  However, it could be that\n\t\t * the postmaster crashed (or more likely was kill -9'd by a clueless\n\t\t * admin) but has left orphan backends behind.  Check for this by\n\t\t * looking to see if there is an associated shmem segment that is\n\t\t * still in use.\n\t\t *\n\t\t * Note: because postmaster.pid is written in multiple steps, we might\n\t\t * not find the shmem ID values in it; we can't treat that as an\n\t\t * error.\n\t\t */\n\t\tif (isDDLock)\n\t\t{\n\t\t\tchar\t   *ptr = buffer;\n\t\t\tunsigned long id1,\n\t\t\t\t\t\tid2;\n\t\t\tint\t\t\tlineno;\n\n\t\t\tfor (lineno = 1; lineno < LOCK_FILE_LINE_SHMEM_KEY; lineno++)\n\t\t\t{\n\t\t\t\tif ((ptr = strchr(ptr, '\\n')) == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tptr++;\n\t\t\t}\n\n\t\t\tif (ptr != NULL &&\n\t\t\t\tsscanf(ptr, \"%lu %lu\", &id1, &id2) == 2)\n\t\t\t{\n\t\t\t\tif (PGSharedMemoryIsInUse(id1, id2))\n\t\t\t\t\tereport(FATAL,\n\t\t\t\t\t\t\t(errcode(ERRCODE_LOCK_FILE_EXISTS),\n\t\t\t\t\t\t\t errmsg(\"pre-existing shared memory block (key %lu, ID %lu) is still in use\",\n\t\t\t\t\t\t\t\t\tid1, id2),\n\t\t\t\t\t\t\t errhint(\"Terminate any old server processes associated with data directory \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t\t refName)));\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Looks like nobody's home.  Unlink the file and try again to create\n\t\t * it.  Need a loop because of possible race condition against other\n\t\t * would-be creators.\n\t\t */\n\t\tif (unlink(filename) < 0)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not remove old lock file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tfilename),\n\t\t\t\t\t errhint(\"The file seems accidentally left over, but \"\n\t\t\t\t\t\t\t \"it could not be removed. Please remove the file \"\n\t\t\t\t\t\t\t \"by hand and try again.\")));\n\t}\n\n\t/*\n\t * Successfully created the file, now fill it.  See comment in miscadmin.h\n\t * about the contents.  Note that we write the same first five lines into\n\t * both datadir and socket lockfiles; although more stuff may get added to\n\t * the datadir lockfile later.\n\t */\n\tsnprintf(buffer, sizeof(buffer), \"%d\\n%s\\n%ld\\n%d\\n%s\\n\",\n\t\t\t amPostmaster ? (int) my_pid : -((int) my_pid),\n\t\t\t DataDir,\n\t\t\t (long) MyStartTime,\n\t\t\t PostPortNumber,\n\t\t\t socketDir);\n\n\t/*\n\t * In a standalone backend, the next line (LOCK_FILE_LINE_LISTEN_ADDR)\n\t * will never receive data, so fill it in as empty now.\n\t */\n\tif (isDDLock && !amPostmaster)\n\t\tstrlcat(buffer, \"\\n\", sizeof(buffer));\n\n\terrno = 0;\n\tpgstat_report_wait_start(WAIT_EVENT_LOCK_FILE_CREATE_WRITE);\n\tif (write(fd, buffer, strlen(buffer)) != strlen(buffer))\n\t{\n\t\tint\t\t\tsave_errno = errno;\n\n\t\tclose(fd);\n\t\tunlink(filename);\n\t\t/* if write didn't set errno, assume problem is no disk space */\n\t\terrno = save_errno ? save_errno : ENOSPC;\n\t\tereport(FATAL,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write lock file \\\"%s\\\": %m\", filename)));\n\t}\n\tpgstat_report_wait_end();\n\n\tpgstat_report_wait_start(WAIT_EVENT_LOCK_FILE_CREATE_SYNC);\n\tif (pg_fsync(fd) != 0)\n\t{\n\t\tint\t\t\tsave_errno = errno;\n\n\t\tclose(fd);\n\t\tunlink(filename);\n\t\terrno = save_errno;\n\t\tereport(FATAL,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write lock file \\\"%s\\\": %m\", filename)));\n\t}\n\tpgstat_report_wait_end();\n\tif (close(fd) != 0)\n\t{\n\t\tint\t\t\tsave_errno = errno;\n\n\t\tunlink(filename);\n\t\terrno = save_errno;\n\t\tereport(FATAL,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write lock file \\\"%s\\\": %m\", filename)));\n\t}\n\n\t/*\n\t * Arrange to unlink the lock file(s) at proc_exit.  If this is the first\n\t * one, set up the on_proc_exit function to do it; then add this lock file\n\t * to the list of files to unlink.\n\t */\n\tif (lock_files == NIL)\n\t\ton_proc_exit(UnlinkLockFiles, 0);\n\n\t/*\n\t * Use lcons so that the lock files are unlinked in reverse order of\n\t * creation; this is critical!\n\t */\n\tlock_files = lcons(pstrdup(filename), lock_files);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pidfile.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pg_shmem.h\"",
            "#include \"storage/latch.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/fd.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"common/file_perm.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/htup_details.h\"",
            "#include <utime.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/param.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static List *lock_files = NIL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nstatic List *lock_files = NIL;\n\nstatic void\nCreateLockFile(const char *filename, bool amPostmaster,\n\t\t\t   const char *socketDir,\n\t\t\t   bool isDDLock, const char *refName)\n{\n\tint\t\t\tfd;\n\tchar\t\tbuffer[MAXPGPATH * 2 + 256];\n\tint\t\t\tntries;\n\tint\t\t\tlen;\n\tint\t\t\tencoded_pid;\n\tpid_t\t\tother_pid;\n\tpid_t\t\tmy_pid,\n\t\t\t\tmy_p_pid,\n\t\t\t\tmy_gp_pid;\n\tconst char *envvar;\n\n\t/*\n\t * If the PID in the lockfile is our own PID or our parent's or\n\t * grandparent's PID, then the file must be stale (probably left over from\n\t * a previous system boot cycle).  We need to check this because of the\n\t * likelihood that a reboot will assign exactly the same PID as we had in\n\t * the previous reboot, or one that's only one or two counts larger and\n\t * hence the lockfile's PID now refers to an ancestor shell process.  We\n\t * allow pg_ctl to pass down its parent shell PID (our grandparent PID)\n\t * via the environment variable PG_GRANDPARENT_PID; this is so that\n\t * launching the postmaster via pg_ctl can be just as reliable as\n\t * launching it directly.  There is no provision for detecting\n\t * further-removed ancestor processes, but if the init script is written\n\t * carefully then all but the immediate parent shell will be root-owned\n\t * processes and so the kill test will fail with EPERM.  Note that we\n\t * cannot get a false negative this way, because an existing postmaster\n\t * would surely never launch a competing postmaster or pg_ctl process\n\t * directly.\n\t */\n\tmy_pid = getpid();\n\n#ifndef WIN32\n\tmy_p_pid = getppid();\n#else\n\n\t/*\n\t * Windows hasn't got getppid(), but doesn't need it since it's not using\n\t * real kill() either...\n\t */\n\tmy_p_pid = 0;\n#endif\n\n\tenvvar = getenv(\"PG_GRANDPARENT_PID\");\n\tif (envvar)\n\t\tmy_gp_pid = atoi(envvar);\n\telse\n\t\tmy_gp_pid = 0;\n\n\t/*\n\t * We need a loop here because of race conditions.  But don't loop forever\n\t * (for example, a non-writable $PGDATA directory might cause a failure\n\t * that won't go away).  100 tries seems like plenty.\n\t */\n\tfor (ntries = 0;; ntries++)\n\t{\n\t\t/*\n\t\t * Try to create the lock file --- O_EXCL makes this atomic.\n\t\t *\n\t\t * Think not to make the file protection weaker than 0600/0640.  See\n\t\t * comments below.\n\t\t */\n\t\tfd = open(filename, O_RDWR | O_CREAT | O_EXCL, pg_file_create_mode);\n\t\tif (fd >= 0)\n\t\t\tbreak;\t\t\t\t/* Success; exit the retry loop */\n\n\t\t/*\n\t\t * Couldn't create the pid file. Probably it already exists.\n\t\t */\n\t\tif ((errno != EEXIST && errno != EACCES) || ntries > 100)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not create lock file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tfilename)));\n\n\t\t/*\n\t\t * Read the file to get the old owner's PID.  Note race condition\n\t\t * here: file might have been deleted since we tried to create it.\n\t\t */\n\t\tfd = open(filename, O_RDONLY, pg_file_create_mode);\n\t\tif (fd < 0)\n\t\t{\n\t\t\tif (errno == ENOENT)\n\t\t\t\tcontinue;\t\t/* race condition; try again */\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not open lock file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tfilename)));\n\t\t}\n\t\tpgstat_report_wait_start(WAIT_EVENT_LOCK_FILE_CREATE_READ);\n\t\tif ((len = read(fd, buffer, sizeof(buffer) - 1)) < 0)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not read lock file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tfilename)));\n\t\tpgstat_report_wait_end();\n\t\tclose(fd);\n\n\t\tif (len == 0)\n\t\t{\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_LOCK_FILE_EXISTS),\n\t\t\t\t\t errmsg(\"lock file \\\"%s\\\" is empty\", filename),\n\t\t\t\t\t errhint(\"Either another server is starting, or the lock file is the remnant of a previous server startup crash.\")));\n\t\t}\n\n\t\tbuffer[len] = '\\0';\n\t\tencoded_pid = atoi(buffer);\n\n\t\t/* if pid < 0, the pid is for postgres, not postmaster */\n\t\tother_pid = (pid_t) (encoded_pid < 0 ? -encoded_pid : encoded_pid);\n\n\t\tif (other_pid <= 0)\n\t\t\telog(FATAL, \"bogus data in lock file \\\"%s\\\": \\\"%s\\\"\",\n\t\t\t\t filename, buffer);\n\n\t\t/*\n\t\t * Check to see if the other process still exists\n\t\t *\n\t\t * Per discussion above, my_pid, my_p_pid, and my_gp_pid can be\n\t\t * ignored as false matches.\n\t\t *\n\t\t * Normally kill() will fail with ESRCH if the given PID doesn't\n\t\t * exist.\n\t\t *\n\t\t * We can treat the EPERM-error case as okay because that error\n\t\t * implies that the existing process has a different userid than we\n\t\t * do, which means it cannot be a competing postmaster.  A postmaster\n\t\t * cannot successfully attach to a data directory owned by a userid\n\t\t * other than its own, as enforced in checkDataDir(). Also, since we\n\t\t * create the lockfiles mode 0600/0640, we'd have failed above if the\n\t\t * lockfile belonged to another userid --- which means that whatever\n\t\t * process kill() is reporting about isn't the one that made the\n\t\t * lockfile.  (NOTE: this last consideration is the only one that\n\t\t * keeps us from blowing away a Unix socket file belonging to an\n\t\t * instance of Postgres being run by someone else, at least on\n\t\t * machines where /tmp hasn't got a stickybit.)\n\t\t */\n\t\tif (other_pid != my_pid && other_pid != my_p_pid &&\n\t\t\tother_pid != my_gp_pid)\n\t\t{\n\t\t\tif (kill(other_pid, 0) == 0 ||\n\t\t\t\t(errno != ESRCH && errno != EPERM))\n\t\t\t{\n\t\t\t\t/* lockfile belongs to a live process */\n\t\t\t\tereport(FATAL,\n\t\t\t\t\t\t(errcode(ERRCODE_LOCK_FILE_EXISTS),\n\t\t\t\t\t\t errmsg(\"lock file \\\"%s\\\" already exists\",\n\t\t\t\t\t\t\t\tfilename),\n\t\t\t\t\t\t isDDLock ?\n\t\t\t\t\t\t (encoded_pid < 0 ?\n\t\t\t\t\t\t  errhint(\"Is another postgres (PID %d) running in data directory \\\"%s\\\"?\",\n\t\t\t\t\t\t\t\t  (int) other_pid, refName) :\n\t\t\t\t\t\t  errhint(\"Is another postmaster (PID %d) running in data directory \\\"%s\\\"?\",\n\t\t\t\t\t\t\t\t  (int) other_pid, refName)) :\n\t\t\t\t\t\t (encoded_pid < 0 ?\n\t\t\t\t\t\t  errhint(\"Is another postgres (PID %d) using socket file \\\"%s\\\"?\",\n\t\t\t\t\t\t\t\t  (int) other_pid, refName) :\n\t\t\t\t\t\t  errhint(\"Is another postmaster (PID %d) using socket file \\\"%s\\\"?\",\n\t\t\t\t\t\t\t\t  (int) other_pid, refName))));\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * No, the creating process did not exist.  However, it could be that\n\t\t * the postmaster crashed (or more likely was kill -9'd by a clueless\n\t\t * admin) but has left orphan backends behind.  Check for this by\n\t\t * looking to see if there is an associated shmem segment that is\n\t\t * still in use.\n\t\t *\n\t\t * Note: because postmaster.pid is written in multiple steps, we might\n\t\t * not find the shmem ID values in it; we can't treat that as an\n\t\t * error.\n\t\t */\n\t\tif (isDDLock)\n\t\t{\n\t\t\tchar\t   *ptr = buffer;\n\t\t\tunsigned long id1,\n\t\t\t\t\t\tid2;\n\t\t\tint\t\t\tlineno;\n\n\t\t\tfor (lineno = 1; lineno < LOCK_FILE_LINE_SHMEM_KEY; lineno++)\n\t\t\t{\n\t\t\t\tif ((ptr = strchr(ptr, '\\n')) == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tptr++;\n\t\t\t}\n\n\t\t\tif (ptr != NULL &&\n\t\t\t\tsscanf(ptr, \"%lu %lu\", &id1, &id2) == 2)\n\t\t\t{\n\t\t\t\tif (PGSharedMemoryIsInUse(id1, id2))\n\t\t\t\t\tereport(FATAL,\n\t\t\t\t\t\t\t(errcode(ERRCODE_LOCK_FILE_EXISTS),\n\t\t\t\t\t\t\t errmsg(\"pre-existing shared memory block (key %lu, ID %lu) is still in use\",\n\t\t\t\t\t\t\t\t\tid1, id2),\n\t\t\t\t\t\t\t errhint(\"Terminate any old server processes associated with data directory \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t\t refName)));\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Looks like nobody's home.  Unlink the file and try again to create\n\t\t * it.  Need a loop because of possible race condition against other\n\t\t * would-be creators.\n\t\t */\n\t\tif (unlink(filename) < 0)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not remove old lock file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tfilename),\n\t\t\t\t\t errhint(\"The file seems accidentally left over, but \"\n\t\t\t\t\t\t\t \"it could not be removed. Please remove the file \"\n\t\t\t\t\t\t\t \"by hand and try again.\")));\n\t}\n\n\t/*\n\t * Successfully created the file, now fill it.  See comment in miscadmin.h\n\t * about the contents.  Note that we write the same first five lines into\n\t * both datadir and socket lockfiles; although more stuff may get added to\n\t * the datadir lockfile later.\n\t */\n\tsnprintf(buffer, sizeof(buffer), \"%d\\n%s\\n%ld\\n%d\\n%s\\n\",\n\t\t\t amPostmaster ? (int) my_pid : -((int) my_pid),\n\t\t\t DataDir,\n\t\t\t (long) MyStartTime,\n\t\t\t PostPortNumber,\n\t\t\t socketDir);\n\n\t/*\n\t * In a standalone backend, the next line (LOCK_FILE_LINE_LISTEN_ADDR)\n\t * will never receive data, so fill it in as empty now.\n\t */\n\tif (isDDLock && !amPostmaster)\n\t\tstrlcat(buffer, \"\\n\", sizeof(buffer));\n\n\terrno = 0;\n\tpgstat_report_wait_start(WAIT_EVENT_LOCK_FILE_CREATE_WRITE);\n\tif (write(fd, buffer, strlen(buffer)) != strlen(buffer))\n\t{\n\t\tint\t\t\tsave_errno = errno;\n\n\t\tclose(fd);\n\t\tunlink(filename);\n\t\t/* if write didn't set errno, assume problem is no disk space */\n\t\terrno = save_errno ? save_errno : ENOSPC;\n\t\tereport(FATAL,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write lock file \\\"%s\\\": %m\", filename)));\n\t}\n\tpgstat_report_wait_end();\n\n\tpgstat_report_wait_start(WAIT_EVENT_LOCK_FILE_CREATE_SYNC);\n\tif (pg_fsync(fd) != 0)\n\t{\n\t\tint\t\t\tsave_errno = errno;\n\n\t\tclose(fd);\n\t\tunlink(filename);\n\t\terrno = save_errno;\n\t\tereport(FATAL,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write lock file \\\"%s\\\": %m\", filename)));\n\t}\n\tpgstat_report_wait_end();\n\tif (close(fd) != 0)\n\t{\n\t\tint\t\t\tsave_errno = errno;\n\n\t\tunlink(filename);\n\t\terrno = save_errno;\n\t\tereport(FATAL,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write lock file \\\"%s\\\": %m\", filename)));\n\t}\n\n\t/*\n\t * Arrange to unlink the lock file(s) at proc_exit.  If this is the first\n\t * one, set up the on_proc_exit function to do it; then add this lock file\n\t * to the list of files to unlink.\n\t */\n\tif (lock_files == NIL)\n\t\ton_proc_exit(UnlinkLockFiles, 0);\n\n\t/*\n\t * Use lcons so that the lock files are unlinked in reverse order of\n\t * creation; this is critical!\n\t */\n\tlock_files = lcons(pstrdup(filename), lock_files);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\n#define DIRECTORY_LOCK_FILE\t\t\"postmaster.pid\"\n\nvoid\nCreateDataDirLockFile(bool amPostmaster)\n{\n\tCreateLockFile(DIRECTORY_LOCK_FILE, amPostmaster, \"\", true, DataDir);\n}"
  },
  {
    "function_name": "CreateLockFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
    "lines": "871-1164",
    "snippet": "static void\nCreateLockFile(const char *filename, bool amPostmaster,\n\t\t\t   const char *socketDir,\n\t\t\t   bool isDDLock, const char *refName)\n{\n\tint\t\t\tfd;\n\tchar\t\tbuffer[MAXPGPATH * 2 + 256];\n\tint\t\t\tntries;\n\tint\t\t\tlen;\n\tint\t\t\tencoded_pid;\n\tpid_t\t\tother_pid;\n\tpid_t\t\tmy_pid,\n\t\t\t\tmy_p_pid,\n\t\t\t\tmy_gp_pid;\n\tconst char *envvar;\n\n\t/*\n\t * If the PID in the lockfile is our own PID or our parent's or\n\t * grandparent's PID, then the file must be stale (probably left over from\n\t * a previous system boot cycle).  We need to check this because of the\n\t * likelihood that a reboot will assign exactly the same PID as we had in\n\t * the previous reboot, or one that's only one or two counts larger and\n\t * hence the lockfile's PID now refers to an ancestor shell process.  We\n\t * allow pg_ctl to pass down its parent shell PID (our grandparent PID)\n\t * via the environment variable PG_GRANDPARENT_PID; this is so that\n\t * launching the postmaster via pg_ctl can be just as reliable as\n\t * launching it directly.  There is no provision for detecting\n\t * further-removed ancestor processes, but if the init script is written\n\t * carefully then all but the immediate parent shell will be root-owned\n\t * processes and so the kill test will fail with EPERM.  Note that we\n\t * cannot get a false negative this way, because an existing postmaster\n\t * would surely never launch a competing postmaster or pg_ctl process\n\t * directly.\n\t */\n\tmy_pid = getpid();\n\n#ifndef WIN32\n\tmy_p_pid = getppid();\n#else\n\n\t/*\n\t * Windows hasn't got getppid(), but doesn't need it since it's not using\n\t * real kill() either...\n\t */\n\tmy_p_pid = 0;\n#endif\n\n\tenvvar = getenv(\"PG_GRANDPARENT_PID\");\n\tif (envvar)\n\t\tmy_gp_pid = atoi(envvar);\n\telse\n\t\tmy_gp_pid = 0;\n\n\t/*\n\t * We need a loop here because of race conditions.  But don't loop forever\n\t * (for example, a non-writable $PGDATA directory might cause a failure\n\t * that won't go away).  100 tries seems like plenty.\n\t */\n\tfor (ntries = 0;; ntries++)\n\t{\n\t\t/*\n\t\t * Try to create the lock file --- O_EXCL makes this atomic.\n\t\t *\n\t\t * Think not to make the file protection weaker than 0600/0640.  See\n\t\t * comments below.\n\t\t */\n\t\tfd = open(filename, O_RDWR | O_CREAT | O_EXCL, pg_file_create_mode);\n\t\tif (fd >= 0)\n\t\t\tbreak;\t\t\t\t/* Success; exit the retry loop */\n\n\t\t/*\n\t\t * Couldn't create the pid file. Probably it already exists.\n\t\t */\n\t\tif ((errno != EEXIST && errno != EACCES) || ntries > 100)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not create lock file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tfilename)));\n\n\t\t/*\n\t\t * Read the file to get the old owner's PID.  Note race condition\n\t\t * here: file might have been deleted since we tried to create it.\n\t\t */\n\t\tfd = open(filename, O_RDONLY, pg_file_create_mode);\n\t\tif (fd < 0)\n\t\t{\n\t\t\tif (errno == ENOENT)\n\t\t\t\tcontinue;\t\t/* race condition; try again */\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not open lock file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tfilename)));\n\t\t}\n\t\tpgstat_report_wait_start(WAIT_EVENT_LOCK_FILE_CREATE_READ);\n\t\tif ((len = read(fd, buffer, sizeof(buffer) - 1)) < 0)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not read lock file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tfilename)));\n\t\tpgstat_report_wait_end();\n\t\tclose(fd);\n\n\t\tif (len == 0)\n\t\t{\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_LOCK_FILE_EXISTS),\n\t\t\t\t\t errmsg(\"lock file \\\"%s\\\" is empty\", filename),\n\t\t\t\t\t errhint(\"Either another server is starting, or the lock file is the remnant of a previous server startup crash.\")));\n\t\t}\n\n\t\tbuffer[len] = '\\0';\n\t\tencoded_pid = atoi(buffer);\n\n\t\t/* if pid < 0, the pid is for postgres, not postmaster */\n\t\tother_pid = (pid_t) (encoded_pid < 0 ? -encoded_pid : encoded_pid);\n\n\t\tif (other_pid <= 0)\n\t\t\telog(FATAL, \"bogus data in lock file \\\"%s\\\": \\\"%s\\\"\",\n\t\t\t\t filename, buffer);\n\n\t\t/*\n\t\t * Check to see if the other process still exists\n\t\t *\n\t\t * Per discussion above, my_pid, my_p_pid, and my_gp_pid can be\n\t\t * ignored as false matches.\n\t\t *\n\t\t * Normally kill() will fail with ESRCH if the given PID doesn't\n\t\t * exist.\n\t\t *\n\t\t * We can treat the EPERM-error case as okay because that error\n\t\t * implies that the existing process has a different userid than we\n\t\t * do, which means it cannot be a competing postmaster.  A postmaster\n\t\t * cannot successfully attach to a data directory owned by a userid\n\t\t * other than its own, as enforced in checkDataDir(). Also, since we\n\t\t * create the lockfiles mode 0600/0640, we'd have failed above if the\n\t\t * lockfile belonged to another userid --- which means that whatever\n\t\t * process kill() is reporting about isn't the one that made the\n\t\t * lockfile.  (NOTE: this last consideration is the only one that\n\t\t * keeps us from blowing away a Unix socket file belonging to an\n\t\t * instance of Postgres being run by someone else, at least on\n\t\t * machines where /tmp hasn't got a stickybit.)\n\t\t */\n\t\tif (other_pid != my_pid && other_pid != my_p_pid &&\n\t\t\tother_pid != my_gp_pid)\n\t\t{\n\t\t\tif (kill(other_pid, 0) == 0 ||\n\t\t\t\t(errno != ESRCH && errno != EPERM))\n\t\t\t{\n\t\t\t\t/* lockfile belongs to a live process */\n\t\t\t\tereport(FATAL,\n\t\t\t\t\t\t(errcode(ERRCODE_LOCK_FILE_EXISTS),\n\t\t\t\t\t\t errmsg(\"lock file \\\"%s\\\" already exists\",\n\t\t\t\t\t\t\t\tfilename),\n\t\t\t\t\t\t isDDLock ?\n\t\t\t\t\t\t (encoded_pid < 0 ?\n\t\t\t\t\t\t  errhint(\"Is another postgres (PID %d) running in data directory \\\"%s\\\"?\",\n\t\t\t\t\t\t\t\t  (int) other_pid, refName) :\n\t\t\t\t\t\t  errhint(\"Is another postmaster (PID %d) running in data directory \\\"%s\\\"?\",\n\t\t\t\t\t\t\t\t  (int) other_pid, refName)) :\n\t\t\t\t\t\t (encoded_pid < 0 ?\n\t\t\t\t\t\t  errhint(\"Is another postgres (PID %d) using socket file \\\"%s\\\"?\",\n\t\t\t\t\t\t\t\t  (int) other_pid, refName) :\n\t\t\t\t\t\t  errhint(\"Is another postmaster (PID %d) using socket file \\\"%s\\\"?\",\n\t\t\t\t\t\t\t\t  (int) other_pid, refName))));\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * No, the creating process did not exist.  However, it could be that\n\t\t * the postmaster crashed (or more likely was kill -9'd by a clueless\n\t\t * admin) but has left orphan backends behind.  Check for this by\n\t\t * looking to see if there is an associated shmem segment that is\n\t\t * still in use.\n\t\t *\n\t\t * Note: because postmaster.pid is written in multiple steps, we might\n\t\t * not find the shmem ID values in it; we can't treat that as an\n\t\t * error.\n\t\t */\n\t\tif (isDDLock)\n\t\t{\n\t\t\tchar\t   *ptr = buffer;\n\t\t\tunsigned long id1,\n\t\t\t\t\t\tid2;\n\t\t\tint\t\t\tlineno;\n\n\t\t\tfor (lineno = 1; lineno < LOCK_FILE_LINE_SHMEM_KEY; lineno++)\n\t\t\t{\n\t\t\t\tif ((ptr = strchr(ptr, '\\n')) == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tptr++;\n\t\t\t}\n\n\t\t\tif (ptr != NULL &&\n\t\t\t\tsscanf(ptr, \"%lu %lu\", &id1, &id2) == 2)\n\t\t\t{\n\t\t\t\tif (PGSharedMemoryIsInUse(id1, id2))\n\t\t\t\t\tereport(FATAL,\n\t\t\t\t\t\t\t(errcode(ERRCODE_LOCK_FILE_EXISTS),\n\t\t\t\t\t\t\t errmsg(\"pre-existing shared memory block (key %lu, ID %lu) is still in use\",\n\t\t\t\t\t\t\t\t\tid1, id2),\n\t\t\t\t\t\t\t errhint(\"Terminate any old server processes associated with data directory \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t\t refName)));\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Looks like nobody's home.  Unlink the file and try again to create\n\t\t * it.  Need a loop because of possible race condition against other\n\t\t * would-be creators.\n\t\t */\n\t\tif (unlink(filename) < 0)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not remove old lock file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tfilename),\n\t\t\t\t\t errhint(\"The file seems accidentally left over, but \"\n\t\t\t\t\t\t\t \"it could not be removed. Please remove the file \"\n\t\t\t\t\t\t\t \"by hand and try again.\")));\n\t}\n\n\t/*\n\t * Successfully created the file, now fill it.  See comment in miscadmin.h\n\t * about the contents.  Note that we write the same first five lines into\n\t * both datadir and socket lockfiles; although more stuff may get added to\n\t * the datadir lockfile later.\n\t */\n\tsnprintf(buffer, sizeof(buffer), \"%d\\n%s\\n%ld\\n%d\\n%s\\n\",\n\t\t\t amPostmaster ? (int) my_pid : -((int) my_pid),\n\t\t\t DataDir,\n\t\t\t (long) MyStartTime,\n\t\t\t PostPortNumber,\n\t\t\t socketDir);\n\n\t/*\n\t * In a standalone backend, the next line (LOCK_FILE_LINE_LISTEN_ADDR)\n\t * will never receive data, so fill it in as empty now.\n\t */\n\tif (isDDLock && !amPostmaster)\n\t\tstrlcat(buffer, \"\\n\", sizeof(buffer));\n\n\terrno = 0;\n\tpgstat_report_wait_start(WAIT_EVENT_LOCK_FILE_CREATE_WRITE);\n\tif (write(fd, buffer, strlen(buffer)) != strlen(buffer))\n\t{\n\t\tint\t\t\tsave_errno = errno;\n\n\t\tclose(fd);\n\t\tunlink(filename);\n\t\t/* if write didn't set errno, assume problem is no disk space */\n\t\terrno = save_errno ? save_errno : ENOSPC;\n\t\tereport(FATAL,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write lock file \\\"%s\\\": %m\", filename)));\n\t}\n\tpgstat_report_wait_end();\n\n\tpgstat_report_wait_start(WAIT_EVENT_LOCK_FILE_CREATE_SYNC);\n\tif (pg_fsync(fd) != 0)\n\t{\n\t\tint\t\t\tsave_errno = errno;\n\n\t\tclose(fd);\n\t\tunlink(filename);\n\t\terrno = save_errno;\n\t\tereport(FATAL,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write lock file \\\"%s\\\": %m\", filename)));\n\t}\n\tpgstat_report_wait_end();\n\tif (close(fd) != 0)\n\t{\n\t\tint\t\t\tsave_errno = errno;\n\n\t\tunlink(filename);\n\t\terrno = save_errno;\n\t\tereport(FATAL,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write lock file \\\"%s\\\": %m\", filename)));\n\t}\n\n\t/*\n\t * Arrange to unlink the lock file(s) at proc_exit.  If this is the first\n\t * one, set up the on_proc_exit function to do it; then add this lock file\n\t * to the list of files to unlink.\n\t */\n\tif (lock_files == NIL)\n\t\ton_proc_exit(UnlinkLockFiles, 0);\n\n\t/*\n\t * Use lcons so that the lock files are unlinked in reverse order of\n\t * creation; this is critical!\n\t */\n\tlock_files = lcons(pstrdup(filename), lock_files);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pidfile.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/pg_shmem.h\"",
      "#include \"storage/latch.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/fd.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"postmaster/autovacuum.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"common/file_perm.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/htup_details.h\"",
      "#include <utime.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <sys/param.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static List *lock_files = NIL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lcons",
          "args": [
            "pstrdup(filename)",
            "lock_files"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pstrdup",
          "args": [
            "filename"
          ],
          "line": 1163
        },
        "resolved": true,
        "details": {
          "function_name": "pstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1160-1164",
          "snippet": "char *\npstrdup(const char *in)\n{\n\treturn MemoryContextStrdup(CurrentMemoryContext, in);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\n\nchar *\npstrdup(const char *in)\n{\n\treturn MemoryContextStrdup(CurrentMemoryContext, in);\n}"
        }
      },
      {
        "call_info": {
          "callee": "on_proc_exit",
          "args": [
            "UnlinkLockFiles",
            "0"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "FATAL",
            "(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write lock file \\\"%s\\\": %m\", filename))"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not write lock file \\\"%s\\\": %m\"",
            "filename"
          ],
          "line": 1148
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode_for_file_access",
          "args": [],
          "line": 1147
        },
        "resolved": true,
        "details": {
          "function_name": "errcode_for_file_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "595-655",
          "snippet": "int\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "filename"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 1140
        },
        "resolved": true,
        "details": {
          "function_name": "close_lb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "3105-3119",
          "snippet": "Datum\nclose_lb(PG_FUNCTION_ARGS)\n{\n#ifdef NOT_USED\n\tLINE\t   *line = PG_GETARG_LINE_P(0);\n\tBOX\t\t   *box = PG_GETARG_BOX_P(1);\n#endif\n\n\t/* think about this one for a while */\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t errmsg(\"function \\\"close_lb\\\" not implemented\")));\n\n\tPG_RETURN_NULL();\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double box_ht(BOX *box);",
            "static double box_wd(BOX *box);",
            "static double box_ar(BOX *box);",
            "static void box_cn(Point *center, BOX *box);",
            "static Point *interpt_sl(LSEG *lseg, LINE *line);",
            "static bool has_interpt_sl(LSEG *lseg, LINE *line);",
            "static double dist_pl_internal(Point *pt, LINE *line);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double box_ht(BOX *box);\nstatic double box_wd(BOX *box);\nstatic double box_ar(BOX *box);\nstatic void box_cn(Point *center, BOX *box);\nstatic Point *interpt_sl(LSEG *lseg, LINE *line);\nstatic bool has_interpt_sl(LSEG *lseg, LINE *line);\nstatic double dist_pl_internal(Point *pt, LINE *line);\n\nDatum\nclose_lb(PG_FUNCTION_ARGS)\n{\n#ifdef NOT_USED\n\tLINE\t   *line = PG_GETARG_LINE_P(0);\n\tBOX\t\t   *box = PG_GETARG_BOX_P(1);\n#endif\n\n\t/* think about this one for a while */\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t errmsg(\"function \\\"close_lb\\\" not implemented\")));\n\n\tPG_RETURN_NULL();\n}"
        }
      },
      {
        "call_info": {
          "callee": "pgstat_report_wait_end",
          "args": [],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "FATAL",
            "(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write lock file \\\"%s\\\": %m\", filename))"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "filename"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_fsync",
          "args": [
            "fd"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgstat_report_wait_start",
          "args": [
            "WAIT_EVENT_LOCK_FILE_CREATE_SYNC"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgstat_report_wait_end",
          "args": [],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "FATAL",
            "(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write lock file \\\"%s\\\": %m\", filename))"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "filename"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buffer"
          ],
          "line": 1113
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "fd",
            "buffer",
            "strlen(buffer)"
          ],
          "line": 1113
        },
        "resolved": true,
        "details": {
          "function_name": "write_stderr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "3668-3703",
          "snippet": "void\nwrite_stderr(const char *fmt,...)\n{\n\tva_list\t\tap;\n\n#ifdef WIN32\n\tchar\t\terrbuf[2048];\t/* Arbitrary size? */\n#endif\n\n\tfmt = _(fmt);\n\n\tva_start(ap, fmt);\n#ifndef WIN32\n\t/* On Unix, we just fprintf to stderr */\n\tvfprintf(stderr, fmt, ap);\n\tfflush(stderr);\n#else\n\tvsnprintf(errbuf, sizeof(errbuf), fmt, ap);\n\n\t/*\n\t * On Win32, we print to stderr if running on a console, or write to\n\t * eventlog if running as a service\n\t */\n\tif (pgwin32_is_service())\t/* Running as a service */\n\t{\n\t\twrite_eventlog(ERROR, errbuf, strlen(errbuf));\n\t}\n\telse\n\t{\n\t\t/* Not running as service, write to stderr */\n\t\twrite_console(errbuf, strlen(errbuf));\n\t\tfflush(stderr);\n\t}\n#endif\n\tva_end(ap);\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nvoid\nwrite_stderr(const char *fmt,...)\n{\n\tva_list\t\tap;\n\n#ifdef WIN32\n\tchar\t\terrbuf[2048];\t/* Arbitrary size? */\n#endif\n\n\tfmt = _(fmt);\n\n\tva_start(ap, fmt);\n#ifndef WIN32\n\t/* On Unix, we just fprintf to stderr */\n\tvfprintf(stderr, fmt, ap);\n\tfflush(stderr);\n#else\n\tvsnprintf(errbuf, sizeof(errbuf), fmt, ap);\n\n\t/*\n\t * On Win32, we print to stderr if running on a console, or write to\n\t * eventlog if running as a service\n\t */\n\tif (pgwin32_is_service())\t/* Running as a service */\n\t{\n\t\twrite_eventlog(ERROR, errbuf, strlen(errbuf));\n\t}\n\telse\n\t{\n\t\t/* Not running as service, write to stderr */\n\t\twrite_console(errbuf, strlen(errbuf));\n\t\tfflush(stderr);\n\t}\n#endif\n\tva_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pgstat_report_wait_start",
          "args": [
            "WAIT_EVENT_LOCK_FILE_CREATE_WRITE"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlcat",
          "args": [
            "buffer",
            "\"\\n\"",
            "sizeof(buffer)"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buffer",
            "sizeof(buffer)",
            "\"%d\\n%s\\n%ld\\n%d\\n%s\\n\"",
            "amPostmaster ? (int) my_pid : -((int) my_pid)",
            "DataDir",
            "(long) MyStartTime",
            "PostPortNumber",
            "socketDir"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "FATAL",
            "(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not remove old lock file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tfilename),\n\t\t\t\t\t errhint(\"The file seems accidentally left over, but \"\n\t\t\t\t\t\t\t \"it could not be removed. Please remove the file \"\n\t\t\t\t\t\t\t \"by hand and try again.\"))"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errhint",
          "args": [
            "\"The file seems accidentally left over, but \"\n\t\t\t\t\t\t\t \"it could not be removed. Please remove the file \"\n\t\t\t\t\t\t\t \"by hand and try again.\""
          ],
          "line": 1086
        },
        "resolved": true,
        "details": {
          "function_name": "errhint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "984-999",
          "snippet": "int\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "filename"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "FATAL",
            "(errcode(ERRCODE_LOCK_FILE_EXISTS),\n\t\t\t\t\t\t\t errmsg(\"pre-existing shared memory block (key %lu, ID %lu) is still in use\",\n\t\t\t\t\t\t\t\t\tid1, id2),\n\t\t\t\t\t\t\t errhint(\"Terminate any old server processes associated with data directory \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t\t refName))"
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_LOCK_FILE_EXISTS"
          ],
          "line": 1068
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "PGSharedMemoryIsInUse",
          "args": [
            "id1",
            "id2"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "ptr",
            "\"%lu %lu\"",
            "&id1",
            "&id2"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "ptr",
            "'\\n'"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "FATAL",
            "(errcode(ERRCODE_LOCK_FILE_EXISTS),\n\t\t\t\t\t\t errmsg(\"lock file \\\"%s\\\" already exists\",\n\t\t\t\t\t\t\t\tfilename),\n\t\t\t\t\t\t isDDLock ?\n\t\t\t\t\t\t (encoded_pid < 0 ?\n\t\t\t\t\t\t  errhint(\"Is another postgres (PID %d) running in data directory \\\"%s\\\"?\",\n\t\t\t\t\t\t\t\t  (int) other_pid, refName) :\n\t\t\t\t\t\t  errhint(\"Is another postmaster (PID %d) running in data directory \\\"%s\\\"?\",\n\t\t\t\t\t\t\t\t  (int) other_pid, refName)) :\n\t\t\t\t\t\t (encoded_pid < 0 ?\n\t\t\t\t\t\t  errhint(\"Is another postgres (PID %d) using socket file \\\"%s\\\"?\",\n\t\t\t\t\t\t\t\t  (int) other_pid, refName) :\n\t\t\t\t\t\t  errhint(\"Is another postmaster (PID %d) using socket file \\\"%s\\\"?\",\n\t\t\t\t\t\t\t\t  (int) other_pid, refName)))"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "other_pid",
            "0"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "FATAL",
            "\"bogus data in lock file \\\"%s\\\": \\\"%s\\\"\"",
            "filename",
            "buffer"
          ],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "encoded_pid < 0 ? -encoded_pid : encoded_pid"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "buffer"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "FATAL",
            "(errcode(ERRCODE_LOCK_FILE_EXISTS),\n\t\t\t\t\t errmsg(\"lock file \\\"%s\\\" is empty\", filename),\n\t\t\t\t\t errhint(\"Either another server is starting, or the lock file is the remnant of a previous server startup crash.\"))"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgstat_report_wait_end",
          "args": [],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "FATAL",
            "(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not read lock file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tfilename))"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "fd",
            "buffer",
            "sizeof(buffer) - 1"
          ],
          "line": 965
        },
        "resolved": true,
        "details": {
          "function_name": "tuplestore_copy_read_pointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplestore.c",
          "lines": "1267-1345",
          "snippet": "void\ntuplestore_copy_read_pointer(Tuplestorestate *state,\n\t\t\t\t\t\t\t int srcptr, int destptr)\n{\n\tTSReadPointer *sptr = &state->readptrs[srcptr];\n\tTSReadPointer *dptr = &state->readptrs[destptr];\n\n\tAssert(srcptr >= 0 && srcptr < state->readptrcount);\n\tAssert(destptr >= 0 && destptr < state->readptrcount);\n\n\t/* Assigning to self is a no-op */\n\tif (srcptr == destptr)\n\t\treturn;\n\n\tif (dptr->eflags != sptr->eflags)\n\t{\n\t\t/* Possible change of overall eflags, so copy and then recompute */\n\t\tint\t\t\teflags;\n\t\tint\t\t\ti;\n\n\t\t*dptr = *sptr;\n\t\teflags = state->readptrs[0].eflags;\n\t\tfor (i = 1; i < state->readptrcount; i++)\n\t\t\teflags |= state->readptrs[i].eflags;\n\t\tstate->eflags = eflags;\n\t}\n\telse\n\t\t*dptr = *sptr;\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INMEM:\n\t\tcase TSS_WRITEFILE:\n\t\t\t/* no work */\n\t\t\tbreak;\n\t\tcase TSS_READFILE:\n\n\t\t\t/*\n\t\t\t * This case is a bit tricky since the active read pointer's\n\t\t\t * position corresponds to the seek point, not what is in its\n\t\t\t * variables.  Assigning to the active requires a seek, and\n\t\t\t * assigning from the active requires a tell, except when\n\t\t\t * eof_reached.\n\t\t\t */\n\t\t\tif (destptr == state->activeptr)\n\t\t\t{\n\t\t\t\tif (dptr->eof_reached)\n\t\t\t\t{\n\t\t\t\t\tif (BufFileSeek(state->myfile,\n\t\t\t\t\t\t\t\t\tstate->writepos_file,\n\t\t\t\t\t\t\t\t\tstate->writepos_offset,\n\t\t\t\t\t\t\t\t\tSEEK_SET) != 0)\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (BufFileSeek(state->myfile,\n\t\t\t\t\t\t\t\t\tdptr->file, dptr->offset,\n\t\t\t\t\t\t\t\t\tSEEK_SET) != 0)\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (srcptr == state->activeptr)\n\t\t\t{\n\t\t\t\tif (!dptr->eof_reached)\n\t\t\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t\t\t&dptr->file,\n\t\t\t\t\t\t\t\t&dptr->offset);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplestore state\");\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"utils/resowner.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void dumptuples(Tuplestorestate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/resowner.h\"\n#include \"utils/memutils.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void dumptuples(Tuplestorestate *state);\n\nvoid\ntuplestore_copy_read_pointer(Tuplestorestate *state,\n\t\t\t\t\t\t\t int srcptr, int destptr)\n{\n\tTSReadPointer *sptr = &state->readptrs[srcptr];\n\tTSReadPointer *dptr = &state->readptrs[destptr];\n\n\tAssert(srcptr >= 0 && srcptr < state->readptrcount);\n\tAssert(destptr >= 0 && destptr < state->readptrcount);\n\n\t/* Assigning to self is a no-op */\n\tif (srcptr == destptr)\n\t\treturn;\n\n\tif (dptr->eflags != sptr->eflags)\n\t{\n\t\t/* Possible change of overall eflags, so copy and then recompute */\n\t\tint\t\t\teflags;\n\t\tint\t\t\ti;\n\n\t\t*dptr = *sptr;\n\t\teflags = state->readptrs[0].eflags;\n\t\tfor (i = 1; i < state->readptrcount; i++)\n\t\t\teflags |= state->readptrs[i].eflags;\n\t\tstate->eflags = eflags;\n\t}\n\telse\n\t\t*dptr = *sptr;\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INMEM:\n\t\tcase TSS_WRITEFILE:\n\t\t\t/* no work */\n\t\t\tbreak;\n\t\tcase TSS_READFILE:\n\n\t\t\t/*\n\t\t\t * This case is a bit tricky since the active read pointer's\n\t\t\t * position corresponds to the seek point, not what is in its\n\t\t\t * variables.  Assigning to the active requires a seek, and\n\t\t\t * assigning from the active requires a tell, except when\n\t\t\t * eof_reached.\n\t\t\t */\n\t\t\tif (destptr == state->activeptr)\n\t\t\t{\n\t\t\t\tif (dptr->eof_reached)\n\t\t\t\t{\n\t\t\t\t\tif (BufFileSeek(state->myfile,\n\t\t\t\t\t\t\t\t\tstate->writepos_file,\n\t\t\t\t\t\t\t\t\tstate->writepos_offset,\n\t\t\t\t\t\t\t\t\tSEEK_SET) != 0)\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (BufFileSeek(state->myfile,\n\t\t\t\t\t\t\t\t\tdptr->file, dptr->offset,\n\t\t\t\t\t\t\t\t\tSEEK_SET) != 0)\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (srcptr == state->activeptr)\n\t\t\t{\n\t\t\t\tif (!dptr->eof_reached)\n\t\t\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t\t\t&dptr->file,\n\t\t\t\t\t\t\t\t&dptr->offset);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplestore state\");\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pgstat_report_wait_start",
          "args": [
            "WAIT_EVENT_LOCK_FILE_CREATE_READ"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "FATAL",
            "(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not open lock file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tfilename))"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "filename",
            "O_RDONLY",
            "pg_file_create_mode"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "FATAL",
            "(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not create lock file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tfilename))"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "filename",
            "O_RDWR | O_CREAT | O_EXCL",
            "pg_file_create_mode"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "envvar"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"PG_GRANDPARENT_PID\""
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getppid",
          "args": [],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nstatic List *lock_files = NIL;\n\nstatic void\nCreateLockFile(const char *filename, bool amPostmaster,\n\t\t\t   const char *socketDir,\n\t\t\t   bool isDDLock, const char *refName)\n{\n\tint\t\t\tfd;\n\tchar\t\tbuffer[MAXPGPATH * 2 + 256];\n\tint\t\t\tntries;\n\tint\t\t\tlen;\n\tint\t\t\tencoded_pid;\n\tpid_t\t\tother_pid;\n\tpid_t\t\tmy_pid,\n\t\t\t\tmy_p_pid,\n\t\t\t\tmy_gp_pid;\n\tconst char *envvar;\n\n\t/*\n\t * If the PID in the lockfile is our own PID or our parent's or\n\t * grandparent's PID, then the file must be stale (probably left over from\n\t * a previous system boot cycle).  We need to check this because of the\n\t * likelihood that a reboot will assign exactly the same PID as we had in\n\t * the previous reboot, or one that's only one or two counts larger and\n\t * hence the lockfile's PID now refers to an ancestor shell process.  We\n\t * allow pg_ctl to pass down its parent shell PID (our grandparent PID)\n\t * via the environment variable PG_GRANDPARENT_PID; this is so that\n\t * launching the postmaster via pg_ctl can be just as reliable as\n\t * launching it directly.  There is no provision for detecting\n\t * further-removed ancestor processes, but if the init script is written\n\t * carefully then all but the immediate parent shell will be root-owned\n\t * processes and so the kill test will fail with EPERM.  Note that we\n\t * cannot get a false negative this way, because an existing postmaster\n\t * would surely never launch a competing postmaster or pg_ctl process\n\t * directly.\n\t */\n\tmy_pid = getpid();\n\n#ifndef WIN32\n\tmy_p_pid = getppid();\n#else\n\n\t/*\n\t * Windows hasn't got getppid(), but doesn't need it since it's not using\n\t * real kill() either...\n\t */\n\tmy_p_pid = 0;\n#endif\n\n\tenvvar = getenv(\"PG_GRANDPARENT_PID\");\n\tif (envvar)\n\t\tmy_gp_pid = atoi(envvar);\n\telse\n\t\tmy_gp_pid = 0;\n\n\t/*\n\t * We need a loop here because of race conditions.  But don't loop forever\n\t * (for example, a non-writable $PGDATA directory might cause a failure\n\t * that won't go away).  100 tries seems like plenty.\n\t */\n\tfor (ntries = 0;; ntries++)\n\t{\n\t\t/*\n\t\t * Try to create the lock file --- O_EXCL makes this atomic.\n\t\t *\n\t\t * Think not to make the file protection weaker than 0600/0640.  See\n\t\t * comments below.\n\t\t */\n\t\tfd = open(filename, O_RDWR | O_CREAT | O_EXCL, pg_file_create_mode);\n\t\tif (fd >= 0)\n\t\t\tbreak;\t\t\t\t/* Success; exit the retry loop */\n\n\t\t/*\n\t\t * Couldn't create the pid file. Probably it already exists.\n\t\t */\n\t\tif ((errno != EEXIST && errno != EACCES) || ntries > 100)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not create lock file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tfilename)));\n\n\t\t/*\n\t\t * Read the file to get the old owner's PID.  Note race condition\n\t\t * here: file might have been deleted since we tried to create it.\n\t\t */\n\t\tfd = open(filename, O_RDONLY, pg_file_create_mode);\n\t\tif (fd < 0)\n\t\t{\n\t\t\tif (errno == ENOENT)\n\t\t\t\tcontinue;\t\t/* race condition; try again */\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not open lock file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tfilename)));\n\t\t}\n\t\tpgstat_report_wait_start(WAIT_EVENT_LOCK_FILE_CREATE_READ);\n\t\tif ((len = read(fd, buffer, sizeof(buffer) - 1)) < 0)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not read lock file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tfilename)));\n\t\tpgstat_report_wait_end();\n\t\tclose(fd);\n\n\t\tif (len == 0)\n\t\t{\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_LOCK_FILE_EXISTS),\n\t\t\t\t\t errmsg(\"lock file \\\"%s\\\" is empty\", filename),\n\t\t\t\t\t errhint(\"Either another server is starting, or the lock file is the remnant of a previous server startup crash.\")));\n\t\t}\n\n\t\tbuffer[len] = '\\0';\n\t\tencoded_pid = atoi(buffer);\n\n\t\t/* if pid < 0, the pid is for postgres, not postmaster */\n\t\tother_pid = (pid_t) (encoded_pid < 0 ? -encoded_pid : encoded_pid);\n\n\t\tif (other_pid <= 0)\n\t\t\telog(FATAL, \"bogus data in lock file \\\"%s\\\": \\\"%s\\\"\",\n\t\t\t\t filename, buffer);\n\n\t\t/*\n\t\t * Check to see if the other process still exists\n\t\t *\n\t\t * Per discussion above, my_pid, my_p_pid, and my_gp_pid can be\n\t\t * ignored as false matches.\n\t\t *\n\t\t * Normally kill() will fail with ESRCH if the given PID doesn't\n\t\t * exist.\n\t\t *\n\t\t * We can treat the EPERM-error case as okay because that error\n\t\t * implies that the existing process has a different userid than we\n\t\t * do, which means it cannot be a competing postmaster.  A postmaster\n\t\t * cannot successfully attach to a data directory owned by a userid\n\t\t * other than its own, as enforced in checkDataDir(). Also, since we\n\t\t * create the lockfiles mode 0600/0640, we'd have failed above if the\n\t\t * lockfile belonged to another userid --- which means that whatever\n\t\t * process kill() is reporting about isn't the one that made the\n\t\t * lockfile.  (NOTE: this last consideration is the only one that\n\t\t * keeps us from blowing away a Unix socket file belonging to an\n\t\t * instance of Postgres being run by someone else, at least on\n\t\t * machines where /tmp hasn't got a stickybit.)\n\t\t */\n\t\tif (other_pid != my_pid && other_pid != my_p_pid &&\n\t\t\tother_pid != my_gp_pid)\n\t\t{\n\t\t\tif (kill(other_pid, 0) == 0 ||\n\t\t\t\t(errno != ESRCH && errno != EPERM))\n\t\t\t{\n\t\t\t\t/* lockfile belongs to a live process */\n\t\t\t\tereport(FATAL,\n\t\t\t\t\t\t(errcode(ERRCODE_LOCK_FILE_EXISTS),\n\t\t\t\t\t\t errmsg(\"lock file \\\"%s\\\" already exists\",\n\t\t\t\t\t\t\t\tfilename),\n\t\t\t\t\t\t isDDLock ?\n\t\t\t\t\t\t (encoded_pid < 0 ?\n\t\t\t\t\t\t  errhint(\"Is another postgres (PID %d) running in data directory \\\"%s\\\"?\",\n\t\t\t\t\t\t\t\t  (int) other_pid, refName) :\n\t\t\t\t\t\t  errhint(\"Is another postmaster (PID %d) running in data directory \\\"%s\\\"?\",\n\t\t\t\t\t\t\t\t  (int) other_pid, refName)) :\n\t\t\t\t\t\t (encoded_pid < 0 ?\n\t\t\t\t\t\t  errhint(\"Is another postgres (PID %d) using socket file \\\"%s\\\"?\",\n\t\t\t\t\t\t\t\t  (int) other_pid, refName) :\n\t\t\t\t\t\t  errhint(\"Is another postmaster (PID %d) using socket file \\\"%s\\\"?\",\n\t\t\t\t\t\t\t\t  (int) other_pid, refName))));\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * No, the creating process did not exist.  However, it could be that\n\t\t * the postmaster crashed (or more likely was kill -9'd by a clueless\n\t\t * admin) but has left orphan backends behind.  Check for this by\n\t\t * looking to see if there is an associated shmem segment that is\n\t\t * still in use.\n\t\t *\n\t\t * Note: because postmaster.pid is written in multiple steps, we might\n\t\t * not find the shmem ID values in it; we can't treat that as an\n\t\t * error.\n\t\t */\n\t\tif (isDDLock)\n\t\t{\n\t\t\tchar\t   *ptr = buffer;\n\t\t\tunsigned long id1,\n\t\t\t\t\t\tid2;\n\t\t\tint\t\t\tlineno;\n\n\t\t\tfor (lineno = 1; lineno < LOCK_FILE_LINE_SHMEM_KEY; lineno++)\n\t\t\t{\n\t\t\t\tif ((ptr = strchr(ptr, '\\n')) == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tptr++;\n\t\t\t}\n\n\t\t\tif (ptr != NULL &&\n\t\t\t\tsscanf(ptr, \"%lu %lu\", &id1, &id2) == 2)\n\t\t\t{\n\t\t\t\tif (PGSharedMemoryIsInUse(id1, id2))\n\t\t\t\t\tereport(FATAL,\n\t\t\t\t\t\t\t(errcode(ERRCODE_LOCK_FILE_EXISTS),\n\t\t\t\t\t\t\t errmsg(\"pre-existing shared memory block (key %lu, ID %lu) is still in use\",\n\t\t\t\t\t\t\t\t\tid1, id2),\n\t\t\t\t\t\t\t errhint(\"Terminate any old server processes associated with data directory \\\"%s\\\".\",\n\t\t\t\t\t\t\t\t\t refName)));\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Looks like nobody's home.  Unlink the file and try again to create\n\t\t * it.  Need a loop because of possible race condition against other\n\t\t * would-be creators.\n\t\t */\n\t\tif (unlink(filename) < 0)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not remove old lock file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tfilename),\n\t\t\t\t\t errhint(\"The file seems accidentally left over, but \"\n\t\t\t\t\t\t\t \"it could not be removed. Please remove the file \"\n\t\t\t\t\t\t\t \"by hand and try again.\")));\n\t}\n\n\t/*\n\t * Successfully created the file, now fill it.  See comment in miscadmin.h\n\t * about the contents.  Note that we write the same first five lines into\n\t * both datadir and socket lockfiles; although more stuff may get added to\n\t * the datadir lockfile later.\n\t */\n\tsnprintf(buffer, sizeof(buffer), \"%d\\n%s\\n%ld\\n%d\\n%s\\n\",\n\t\t\t amPostmaster ? (int) my_pid : -((int) my_pid),\n\t\t\t DataDir,\n\t\t\t (long) MyStartTime,\n\t\t\t PostPortNumber,\n\t\t\t socketDir);\n\n\t/*\n\t * In a standalone backend, the next line (LOCK_FILE_LINE_LISTEN_ADDR)\n\t * will never receive data, so fill it in as empty now.\n\t */\n\tif (isDDLock && !amPostmaster)\n\t\tstrlcat(buffer, \"\\n\", sizeof(buffer));\n\n\terrno = 0;\n\tpgstat_report_wait_start(WAIT_EVENT_LOCK_FILE_CREATE_WRITE);\n\tif (write(fd, buffer, strlen(buffer)) != strlen(buffer))\n\t{\n\t\tint\t\t\tsave_errno = errno;\n\n\t\tclose(fd);\n\t\tunlink(filename);\n\t\t/* if write didn't set errno, assume problem is no disk space */\n\t\terrno = save_errno ? save_errno : ENOSPC;\n\t\tereport(FATAL,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write lock file \\\"%s\\\": %m\", filename)));\n\t}\n\tpgstat_report_wait_end();\n\n\tpgstat_report_wait_start(WAIT_EVENT_LOCK_FILE_CREATE_SYNC);\n\tif (pg_fsync(fd) != 0)\n\t{\n\t\tint\t\t\tsave_errno = errno;\n\n\t\tclose(fd);\n\t\tunlink(filename);\n\t\terrno = save_errno;\n\t\tereport(FATAL,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write lock file \\\"%s\\\": %m\", filename)));\n\t}\n\tpgstat_report_wait_end();\n\tif (close(fd) != 0)\n\t{\n\t\tint\t\t\tsave_errno = errno;\n\n\t\tunlink(filename);\n\t\terrno = save_errno;\n\t\tereport(FATAL,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write lock file \\\"%s\\\": %m\", filename)));\n\t}\n\n\t/*\n\t * Arrange to unlink the lock file(s) at proc_exit.  If this is the first\n\t * one, set up the on_proc_exit function to do it; then add this lock file\n\t * to the list of files to unlink.\n\t */\n\tif (lock_files == NIL)\n\t\ton_proc_exit(UnlinkLockFiles, 0);\n\n\t/*\n\t * Use lcons so that the lock files are unlinked in reverse order of\n\t * creation; this is critical!\n\t */\n\tlock_files = lcons(pstrdup(filename), lock_files);\n}"
  },
  {
    "function_name": "UnlinkLockFiles",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
    "lines": "836-861",
    "snippet": "static void\nUnlinkLockFiles(int status, Datum arg)\n{\n\tListCell   *l;\n\n\tforeach(l, lock_files)\n\t{\n\t\tchar\t   *curfile = (char *) lfirst(l);\n\n\t\tunlink(curfile);\n\t\t/* Should we complain if the unlink fails? */\n\t}\n\t/* Since we're about to exit, no need to reclaim storage */\n\tlock_files = NIL;\n\n\t/*\n\t * Lock file removal should always be the last externally visible action\n\t * of a postmaster or standalone backend, while we won't come here at all\n\t * when exiting postmaster child processes.  Therefore, this is a good\n\t * place to log completion of shutdown.  We could alternatively teach\n\t * proc_exit() to do it, but that seems uglier.  In a standalone backend,\n\t * use NOTICE elevel to be less chatty.\n\t */\n\tereport(IsPostmasterEnvironment ? LOG : NOTICE,\n\t\t\t(errmsg(\"database system is shut down\")));\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pidfile.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/pg_shmem.h\"",
      "#include \"storage/latch.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/fd.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"postmaster/autovacuum.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"common/file_perm.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/htup_details.h\"",
      "#include <utime.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <sys/param.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static List *lock_files = NIL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "IsPostmasterEnvironment ? LOG : NOTICE",
            "(errmsg(\"database system is shut down\"))"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"database system is shut down\""
          ],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "curfile"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst",
          "args": [
            "l"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "l",
            "lock_files"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nstatic List *lock_files = NIL;\n\nstatic void\nUnlinkLockFiles(int status, Datum arg)\n{\n\tListCell   *l;\n\n\tforeach(l, lock_files)\n\t{\n\t\tchar\t   *curfile = (char *) lfirst(l);\n\n\t\tunlink(curfile);\n\t\t/* Should we complain if the unlink fails? */\n\t}\n\t/* Since we're about to exit, no need to reclaim storage */\n\tlock_files = NIL;\n\n\t/*\n\t * Lock file removal should always be the last externally visible action\n\t * of a postmaster or standalone backend, while we won't come here at all\n\t * when exiting postmaster child processes.  Therefore, this is a good\n\t * place to log completion of shutdown.  We could alternatively teach\n\t * proc_exit() to do it, but that seems uglier.  In a standalone backend,\n\t * use NOTICE elevel to be less chatty.\n\t */\n\tereport(IsPostmasterEnvironment ? LOG : NOTICE,\n\t\t\t(errmsg(\"database system is shut down\")));\n}"
  },
  {
    "function_name": "GetUserNameFromId",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
    "lines": "794-815",
    "snippet": "char *\nGetUserNameFromId(Oid roleid, bool noerr)\n{\n\tHeapTuple\ttuple;\n\tchar\t   *result;\n\n\ttuple = SearchSysCache1(AUTHOID, ObjectIdGetDatum(roleid));\n\tif (!HeapTupleIsValid(tuple))\n\t{\n\t\tif (!noerr)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"invalid role OID: %u\", roleid)));\n\t\tresult = NULL;\n\t}\n\telse\n\t{\n\t\tresult = pstrdup(NameStr(((Form_pg_authid) GETSTRUCT(tuple))->rolname));\n\t\tReleaseSysCache(tuple);\n\t}\n\treturn result;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pidfile.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/pg_shmem.h\"",
      "#include \"storage/latch.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/fd.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"postmaster/autovacuum.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"common/file_perm.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/htup_details.h\"",
      "#include <utime.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <sys/param.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ReleaseSysCache",
          "args": [
            "tuple"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "ReleaseSysCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1159-1163",
          "snippet": "void\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pstrdup",
          "args": [
            "NameStr(((Form_pg_authid) GETSTRUCT(tuple))->rolname)"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "pstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1160-1164",
          "snippet": "char *\npstrdup(const char *in)\n{\n\treturn MemoryContextStrdup(CurrentMemoryContext, in);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\n\nchar *\npstrdup(const char *in)\n{\n\treturn MemoryContextStrdup(CurrentMemoryContext, in);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "((Form_pg_authid) GETSTRUCT(tuple))->rolname"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "tuple"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"invalid role OID: %u\", roleid))"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid role OID: %u\"",
            "roleid"
          ],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_UNDEFINED_OBJECT"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "tuple"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SearchSysCache1",
          "args": [
            "AUTHOID",
            "ObjectIdGetDatum(roleid)"
          ],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "SearchSysCache1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1111-1120",
          "snippet": "HeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nHeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "roleid"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nchar *\nGetUserNameFromId(Oid roleid, bool noerr)\n{\n\tHeapTuple\ttuple;\n\tchar\t   *result;\n\n\ttuple = SearchSysCache1(AUTHOID, ObjectIdGetDatum(roleid));\n\tif (!HeapTupleIsValid(tuple))\n\t{\n\t\tif (!noerr)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"invalid role OID: %u\", roleid)));\n\t\tresult = NULL;\n\t}\n\telse\n\t{\n\t\tresult = pstrdup(NameStr(((Form_pg_authid) GETSTRUCT(tuple))->rolname));\n\t\tReleaseSysCache(tuple);\n\t}\n\treturn result;\n}"
  },
  {
    "function_name": "SetCurrentRoleId",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
    "lines": "759-787",
    "snippet": "void\nSetCurrentRoleId(Oid roleid, bool is_superuser)\n{\n\t/*\n\t * Get correct info if it's SET ROLE NONE\n\t *\n\t * If SessionUserId hasn't been set yet, just do nothing --- the eventual\n\t * SetSessionUserId call will fix everything.  This is needed since we\n\t * will get called during GUC initialization.\n\t */\n\tif (!OidIsValid(roleid))\n\t{\n\t\tif (!OidIsValid(SessionUserId))\n\t\t\treturn;\n\n\t\troleid = SessionUserId;\n\t\tis_superuser = SessionUserIsSuperuser;\n\n\t\tSetRoleIsActive = false;\n\t}\n\telse\n\t\tSetRoleIsActive = true;\n\n\tSetOuterUserId(roleid);\n\n\tSetConfigOption(\"is_superuser\",\n\t\t\t\t\tis_superuser ? \"on\" : \"off\",\n\t\t\t\t\tPGC_INTERNAL, PGC_S_OVERRIDE);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pidfile.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/pg_shmem.h\"",
      "#include \"storage/latch.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/fd.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"postmaster/autovacuum.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"common/file_perm.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/htup_details.h\"",
      "#include <utime.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <sys/param.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Oid\tSessionUserId = InvalidOid;",
      "static bool SessionUserIsSuperuser = false;",
      "static bool SetRoleIsActive = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetConfigOption",
          "args": [
            "\"is_superuser\"",
            "is_superuser ? \"on\" : \"off\"",
            "PGC_INTERNAL",
            "PGC_S_OVERRIDE"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "SetConfigOption",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/guc.c",
          "lines": "6930-6936",
          "snippet": "void\nSetConfigOption(const char *name, const char *value,\n\t\t\t\tGucContext context, GucSource source)\n{\n\t(void) set_config_option(name, value, context, source,\n\t\t\t\t\t\t\t GUC_ACTION_SET, true, 0, false);\n}",
          "includes": [
            "#include \"guc-file.c\"",
            "#include \"utils/xml.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/tzparser.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/ps_status.h\"",
            "#include \"utils/portal.h\"",
            "#include \"utils/plancache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc_tables.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_cache.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pg_shmem.h\"",
            "#include \"storage/large_object.h\"",
            "#include \"storage/fd.h\"",
            "#include \"storage/standby.h\"",
            "#include \"storage/dsm_impl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"replication/walsender.h\"",
            "#include \"replication/walreceiver.h\"",
            "#include \"replication/syncrep.h\"",
            "#include \"replication/slot.h\"",
            "#include \"replication/logicallauncher.h\"",
            "#include \"postmaster/walwriter.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/bgwriter.h\"",
            "#include \"postmaster/bgworker_internals.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"parser/parser.h\"",
            "#include \"parser/parse_type.h\"",
            "#include \"parser/parse_expr.h\"",
            "#include \"optimizer/planmain.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/geqo.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"libpq/auth.h\"",
            "#include \"jit/jit.h\"",
            "#include \"funcapi.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/variable.h\"",
            "#include \"commands/vacuum.h\"",
            "#include \"commands/user.h\"",
            "#include \"commands/prepare.h\"",
            "#include \"commands/async.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xlog_internal.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/twophase.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/rmgr.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/commit_ts.h\"",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool check_log_destination(char **newval, void **extra, GucSource source);",
            "static bool check_wal_consistency_checking(char **newval, void **extra,\n\t\t\t\t\t\t\t   GucSource source);",
            "static bool check_client_min_messages(int *newval, void **extra, GucSource source);",
            "static bool check_temp_buffers(int *newval, void **extra, GucSource source);",
            "static bool check_bonjour(bool *newval, void **extra, GucSource source);",
            "static bool check_ssl(bool *newval, void **extra, GucSource source);",
            "static bool check_stage_log_stats(bool *newval, void **extra, GucSource source);",
            "static bool check_log_stats(bool *newval, void **extra, GucSource source);",
            "static bool check_canonical_path(char **newval, void **extra, GucSource source);",
            "static bool check_timezone_abbreviations(char **newval, void **extra, GucSource source);",
            "static bool check_maxconnections(int *newval, void **extra, GucSource source);",
            "static bool check_max_worker_processes(int *newval, void **extra, GucSource source);",
            "static bool check_autovacuum_max_workers(int *newval, void **extra, GucSource source);",
            "static bool check_autovacuum_work_mem(int *newval, void **extra, GucSource source);",
            "static bool check_effective_io_concurrency(int *newval, void **extra, GucSource source);",
            "static bool check_application_name(char **newval, void **extra, GucSource source);",
            "static bool check_cluster_name(char **newval, void **extra, GucSource source);",
            "static void replace_auto_config_value(ConfigVariable **head_p, ConfigVariable **tail_p,\n\t\t\t\t\t\t  const char *name, const char *value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"guc-file.c\"\n#include \"utils/xml.h\"\n#include \"utils/varlena.h\"\n#include \"utils/tzparser.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/ps_status.h\"\n#include \"utils/portal.h\"\n#include \"utils/plancache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc_tables.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_cache.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/predicate.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/large_object.h\"\n#include \"storage/fd.h\"\n#include \"storage/standby.h\"\n#include \"storage/dsm_impl.h\"\n#include \"storage/bufmgr.h\"\n#include \"replication/walsender.h\"\n#include \"replication/walreceiver.h\"\n#include \"replication/syncrep.h\"\n#include \"replication/slot.h\"\n#include \"replication/logicallauncher.h\"\n#include \"postmaster/walwriter.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/bgwriter.h\"\n#include \"postmaster/bgworker_internals.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parser.h\"\n#include \"parser/parse_type.h\"\n#include \"parser/parse_expr.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/geqo.h\"\n#include \"optimizer/cost.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"libpq/auth.h\"\n#include \"jit/jit.h\"\n#include \"funcapi.h\"\n#include \"commands/trigger.h\"\n#include \"commands/variable.h\"\n#include \"commands/vacuum.h\"\n#include \"commands/user.h\"\n#include \"commands/prepare.h\"\n#include \"commands/async.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xlog_internal.h\"\n#include \"access/xact.h\"\n#include \"access/twophase.h\"\n#include \"access/transam.h\"\n#include \"access/rmgr.h\"\n#include \"access/gin.h\"\n#include \"access/commit_ts.h\"\n#include <syslog.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool check_log_destination(char **newval, void **extra, GucSource source);\nstatic bool check_wal_consistency_checking(char **newval, void **extra,\n\t\t\t\t\t\t\t   GucSource source);\nstatic bool check_client_min_messages(int *newval, void **extra, GucSource source);\nstatic bool check_temp_buffers(int *newval, void **extra, GucSource source);\nstatic bool check_bonjour(bool *newval, void **extra, GucSource source);\nstatic bool check_ssl(bool *newval, void **extra, GucSource source);\nstatic bool check_stage_log_stats(bool *newval, void **extra, GucSource source);\nstatic bool check_log_stats(bool *newval, void **extra, GucSource source);\nstatic bool check_canonical_path(char **newval, void **extra, GucSource source);\nstatic bool check_timezone_abbreviations(char **newval, void **extra, GucSource source);\nstatic bool check_maxconnections(int *newval, void **extra, GucSource source);\nstatic bool check_max_worker_processes(int *newval, void **extra, GucSource source);\nstatic bool check_autovacuum_max_workers(int *newval, void **extra, GucSource source);\nstatic bool check_autovacuum_work_mem(int *newval, void **extra, GucSource source);\nstatic bool check_effective_io_concurrency(int *newval, void **extra, GucSource source);\nstatic bool check_application_name(char **newval, void **extra, GucSource source);\nstatic bool check_cluster_name(char **newval, void **extra, GucSource source);\nstatic void replace_auto_config_value(ConfigVariable **head_p, ConfigVariable **tail_p,\n\t\t\t\t\t\t  const char *name, const char *value);\n\nvoid\nSetConfigOption(const char *name, const char *value,\n\t\t\t\tGucContext context, GucSource source)\n{\n\t(void) set_config_option(name, value, context, source,\n\t\t\t\t\t\t\t GUC_ACTION_SET, true, 0, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetOuterUserId",
          "args": [
            "roleid"
          ],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "SetOuterUserId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
          "lines": "405-414",
          "snippet": "static void\nSetOuterUserId(Oid userid)\n{\n\tAssertState(SecurityRestrictionContext == 0);\n\tAssertArg(OidIsValid(userid));\n\tOuterUserId = userid;\n\n\t/* We force the effective user ID to match, too */\n\tCurrentUserId = userid;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pidfile.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pg_shmem.h\"",
            "#include \"storage/latch.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/fd.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"common/file_perm.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/htup_details.h\"",
            "#include <utime.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/param.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Oid\tOuterUserId = InvalidOid;",
            "static Oid\tCurrentUserId = InvalidOid;",
            "static int\tSecurityRestrictionContext = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nstatic Oid\tOuterUserId = InvalidOid;\nstatic Oid\tCurrentUserId = InvalidOid;\nstatic int\tSecurityRestrictionContext = 0;\n\nstatic void\nSetOuterUserId(Oid userid)\n{\n\tAssertState(SecurityRestrictionContext == 0);\n\tAssertArg(OidIsValid(userid));\n\tOuterUserId = userid;\n\n\t/* We force the effective user ID to match, too */\n\tCurrentUserId = userid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "SessionUserId"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "roleid"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nstatic Oid\tSessionUserId = InvalidOid;\nstatic bool SessionUserIsSuperuser = false;\nstatic bool SetRoleIsActive = false;\n\nvoid\nSetCurrentRoleId(Oid roleid, bool is_superuser)\n{\n\t/*\n\t * Get correct info if it's SET ROLE NONE\n\t *\n\t * If SessionUserId hasn't been set yet, just do nothing --- the eventual\n\t * SetSessionUserId call will fix everything.  This is needed since we\n\t * will get called during GUC initialization.\n\t */\n\tif (!OidIsValid(roleid))\n\t{\n\t\tif (!OidIsValid(SessionUserId))\n\t\t\treturn;\n\n\t\troleid = SessionUserId;\n\t\tis_superuser = SessionUserIsSuperuser;\n\n\t\tSetRoleIsActive = false;\n\t}\n\telse\n\t\tSetRoleIsActive = true;\n\n\tSetOuterUserId(roleid);\n\n\tSetConfigOption(\"is_superuser\",\n\t\t\t\t\tis_superuser ? \"on\" : \"off\",\n\t\t\t\t\tPGC_INTERNAL, PGC_S_OVERRIDE);\n}"
  },
  {
    "function_name": "GetCurrentRoleId",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
    "lines": "738-745",
    "snippet": "Oid\nGetCurrentRoleId(void)\n{\n\tif (SetRoleIsActive)\n\t\treturn OuterUserId;\n\telse\n\t\treturn InvalidOid;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pidfile.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/pg_shmem.h\"",
      "#include \"storage/latch.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/fd.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"postmaster/autovacuum.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"common/file_perm.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/htup_details.h\"",
      "#include <utime.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <sys/param.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Oid\tOuterUserId = InvalidOid;",
      "static bool SetRoleIsActive = false;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nstatic Oid\tOuterUserId = InvalidOid;\nstatic bool SetRoleIsActive = false;\n\nOid\nGetCurrentRoleId(void)\n{\n\tif (SetRoleIsActive)\n\t\treturn OuterUserId;\n\telse\n\t\treturn InvalidOid;\n}"
  },
  {
    "function_name": "SetSessionAuthorization",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
    "lines": "713-730",
    "snippet": "void\nSetSessionAuthorization(Oid userid, bool is_superuser)\n{\n\t/* Must have authenticated already, else can't make permission check */\n\tAssertState(OidIsValid(AuthenticatedUserId));\n\n\tif (userid != AuthenticatedUserId &&\n\t\t!AuthenticatedUserIsSuperuser)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t errmsg(\"permission denied to set session authorization\")));\n\n\tSetSessionUserId(userid, is_superuser);\n\n\tSetConfigOption(\"is_superuser\",\n\t\t\t\t\tis_superuser ? \"on\" : \"off\",\n\t\t\t\t\tPGC_INTERNAL, PGC_S_OVERRIDE);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pidfile.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/pg_shmem.h\"",
      "#include \"storage/latch.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/fd.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"postmaster/autovacuum.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"common/file_perm.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/htup_details.h\"",
      "#include <utime.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <sys/param.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Oid\tAuthenticatedUserId = InvalidOid;",
      "static bool AuthenticatedUserIsSuperuser = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetConfigOption",
          "args": [
            "\"is_superuser\"",
            "is_superuser ? \"on\" : \"off\"",
            "PGC_INTERNAL",
            "PGC_S_OVERRIDE"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "SetConfigOption",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/guc.c",
          "lines": "6930-6936",
          "snippet": "void\nSetConfigOption(const char *name, const char *value,\n\t\t\t\tGucContext context, GucSource source)\n{\n\t(void) set_config_option(name, value, context, source,\n\t\t\t\t\t\t\t GUC_ACTION_SET, true, 0, false);\n}",
          "includes": [
            "#include \"guc-file.c\"",
            "#include \"utils/xml.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/tzparser.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/ps_status.h\"",
            "#include \"utils/portal.h\"",
            "#include \"utils/plancache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc_tables.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_cache.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pg_shmem.h\"",
            "#include \"storage/large_object.h\"",
            "#include \"storage/fd.h\"",
            "#include \"storage/standby.h\"",
            "#include \"storage/dsm_impl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"replication/walsender.h\"",
            "#include \"replication/walreceiver.h\"",
            "#include \"replication/syncrep.h\"",
            "#include \"replication/slot.h\"",
            "#include \"replication/logicallauncher.h\"",
            "#include \"postmaster/walwriter.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/bgwriter.h\"",
            "#include \"postmaster/bgworker_internals.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"parser/parser.h\"",
            "#include \"parser/parse_type.h\"",
            "#include \"parser/parse_expr.h\"",
            "#include \"optimizer/planmain.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/geqo.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"libpq/auth.h\"",
            "#include \"jit/jit.h\"",
            "#include \"funcapi.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/variable.h\"",
            "#include \"commands/vacuum.h\"",
            "#include \"commands/user.h\"",
            "#include \"commands/prepare.h\"",
            "#include \"commands/async.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xlog_internal.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/twophase.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/rmgr.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/commit_ts.h\"",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool check_log_destination(char **newval, void **extra, GucSource source);",
            "static bool check_wal_consistency_checking(char **newval, void **extra,\n\t\t\t\t\t\t\t   GucSource source);",
            "static bool check_client_min_messages(int *newval, void **extra, GucSource source);",
            "static bool check_temp_buffers(int *newval, void **extra, GucSource source);",
            "static bool check_bonjour(bool *newval, void **extra, GucSource source);",
            "static bool check_ssl(bool *newval, void **extra, GucSource source);",
            "static bool check_stage_log_stats(bool *newval, void **extra, GucSource source);",
            "static bool check_log_stats(bool *newval, void **extra, GucSource source);",
            "static bool check_canonical_path(char **newval, void **extra, GucSource source);",
            "static bool check_timezone_abbreviations(char **newval, void **extra, GucSource source);",
            "static bool check_maxconnections(int *newval, void **extra, GucSource source);",
            "static bool check_max_worker_processes(int *newval, void **extra, GucSource source);",
            "static bool check_autovacuum_max_workers(int *newval, void **extra, GucSource source);",
            "static bool check_autovacuum_work_mem(int *newval, void **extra, GucSource source);",
            "static bool check_effective_io_concurrency(int *newval, void **extra, GucSource source);",
            "static bool check_application_name(char **newval, void **extra, GucSource source);",
            "static bool check_cluster_name(char **newval, void **extra, GucSource source);",
            "static void replace_auto_config_value(ConfigVariable **head_p, ConfigVariable **tail_p,\n\t\t\t\t\t\t  const char *name, const char *value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"guc-file.c\"\n#include \"utils/xml.h\"\n#include \"utils/varlena.h\"\n#include \"utils/tzparser.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/ps_status.h\"\n#include \"utils/portal.h\"\n#include \"utils/plancache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc_tables.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_cache.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/predicate.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/large_object.h\"\n#include \"storage/fd.h\"\n#include \"storage/standby.h\"\n#include \"storage/dsm_impl.h\"\n#include \"storage/bufmgr.h\"\n#include \"replication/walsender.h\"\n#include \"replication/walreceiver.h\"\n#include \"replication/syncrep.h\"\n#include \"replication/slot.h\"\n#include \"replication/logicallauncher.h\"\n#include \"postmaster/walwriter.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/bgwriter.h\"\n#include \"postmaster/bgworker_internals.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parser.h\"\n#include \"parser/parse_type.h\"\n#include \"parser/parse_expr.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/geqo.h\"\n#include \"optimizer/cost.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"libpq/auth.h\"\n#include \"jit/jit.h\"\n#include \"funcapi.h\"\n#include \"commands/trigger.h\"\n#include \"commands/variable.h\"\n#include \"commands/vacuum.h\"\n#include \"commands/user.h\"\n#include \"commands/prepare.h\"\n#include \"commands/async.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xlog_internal.h\"\n#include \"access/xact.h\"\n#include \"access/twophase.h\"\n#include \"access/transam.h\"\n#include \"access/rmgr.h\"\n#include \"access/gin.h\"\n#include \"access/commit_ts.h\"\n#include <syslog.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool check_log_destination(char **newval, void **extra, GucSource source);\nstatic bool check_wal_consistency_checking(char **newval, void **extra,\n\t\t\t\t\t\t\t   GucSource source);\nstatic bool check_client_min_messages(int *newval, void **extra, GucSource source);\nstatic bool check_temp_buffers(int *newval, void **extra, GucSource source);\nstatic bool check_bonjour(bool *newval, void **extra, GucSource source);\nstatic bool check_ssl(bool *newval, void **extra, GucSource source);\nstatic bool check_stage_log_stats(bool *newval, void **extra, GucSource source);\nstatic bool check_log_stats(bool *newval, void **extra, GucSource source);\nstatic bool check_canonical_path(char **newval, void **extra, GucSource source);\nstatic bool check_timezone_abbreviations(char **newval, void **extra, GucSource source);\nstatic bool check_maxconnections(int *newval, void **extra, GucSource source);\nstatic bool check_max_worker_processes(int *newval, void **extra, GucSource source);\nstatic bool check_autovacuum_max_workers(int *newval, void **extra, GucSource source);\nstatic bool check_autovacuum_work_mem(int *newval, void **extra, GucSource source);\nstatic bool check_effective_io_concurrency(int *newval, void **extra, GucSource source);\nstatic bool check_application_name(char **newval, void **extra, GucSource source);\nstatic bool check_cluster_name(char **newval, void **extra, GucSource source);\nstatic void replace_auto_config_value(ConfigVariable **head_p, ConfigVariable **tail_p,\n\t\t\t\t\t\t  const char *name, const char *value);\n\nvoid\nSetConfigOption(const char *name, const char *value,\n\t\t\t\tGucContext context, GucSource source)\n{\n\t(void) set_config_option(name, value, context, source,\n\t\t\t\t\t\t\t GUC_ACTION_SET, true, 0, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetSessionUserId",
          "args": [
            "userid",
            "is_superuser"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "SetSessionUserId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
          "lines": "428-440",
          "snippet": "static void\nSetSessionUserId(Oid userid, bool is_superuser)\n{\n\tAssertState(SecurityRestrictionContext == 0);\n\tAssertArg(OidIsValid(userid));\n\tSessionUserId = userid;\n\tSessionUserIsSuperuser = is_superuser;\n\tSetRoleIsActive = false;\n\n\t/* We force the effective user IDs to match, too */\n\tOuterUserId = userid;\n\tCurrentUserId = userid;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pidfile.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pg_shmem.h\"",
            "#include \"storage/latch.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/fd.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"common/file_perm.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/htup_details.h\"",
            "#include <utime.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/param.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Oid\tSessionUserId = InvalidOid;",
            "static Oid\tOuterUserId = InvalidOid;",
            "static Oid\tCurrentUserId = InvalidOid;",
            "static bool SessionUserIsSuperuser = false;",
            "static int\tSecurityRestrictionContext = 0;",
            "static bool SetRoleIsActive = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nstatic Oid\tSessionUserId = InvalidOid;\nstatic Oid\tOuterUserId = InvalidOid;\nstatic Oid\tCurrentUserId = InvalidOid;\nstatic bool SessionUserIsSuperuser = false;\nstatic int\tSecurityRestrictionContext = 0;\nstatic bool SetRoleIsActive = false;\n\nstatic void\nSetSessionUserId(Oid userid, bool is_superuser)\n{\n\tAssertState(SecurityRestrictionContext == 0);\n\tAssertArg(OidIsValid(userid));\n\tSessionUserId = userid;\n\tSessionUserIsSuperuser = is_superuser;\n\tSetRoleIsActive = false;\n\n\t/* We force the effective user IDs to match, too */\n\tOuterUserId = userid;\n\tCurrentUserId = userid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t errmsg(\"permission denied to set session authorization\"))"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"permission denied to set session authorization\""
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INSUFFICIENT_PRIVILEGE"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "AssertState",
          "args": [
            "OidIsValid(AuthenticatedUserId)"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "AuthenticatedUserId"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nstatic Oid\tAuthenticatedUserId = InvalidOid;\nstatic bool AuthenticatedUserIsSuperuser = false;\n\nvoid\nSetSessionAuthorization(Oid userid, bool is_superuser)\n{\n\t/* Must have authenticated already, else can't make permission check */\n\tAssertState(OidIsValid(AuthenticatedUserId));\n\n\tif (userid != AuthenticatedUserId &&\n\t\t!AuthenticatedUserIsSuperuser)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t errmsg(\"permission denied to set session authorization\")));\n\n\tSetSessionUserId(userid, is_superuser);\n\n\tSetConfigOption(\"is_superuser\",\n\t\t\t\t\tis_superuser ? \"on\" : \"off\",\n\t\t\t\t\tPGC_INTERNAL, PGC_S_OVERRIDE);\n}"
  },
  {
    "function_name": "InitializeSessionUserIdStandalone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
    "lines": "681-697",
    "snippet": "void\nInitializeSessionUserIdStandalone(void)\n{\n\t/*\n\t * This function should only be called in single-user mode, in autovacuum\n\t * workers, and in background workers.\n\t */\n\tAssertState(!IsUnderPostmaster || IsAutoVacuumWorkerProcess() || IsBackgroundWorker);\n\n\t/* call only once */\n\tAssertState(!OidIsValid(AuthenticatedUserId));\n\n\tAuthenticatedUserId = BOOTSTRAP_SUPERUSERID;\n\tAuthenticatedUserIsSuperuser = true;\n\n\tSetSessionUserId(BOOTSTRAP_SUPERUSERID, true);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pidfile.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/pg_shmem.h\"",
      "#include \"storage/latch.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/fd.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"postmaster/autovacuum.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"common/file_perm.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/htup_details.h\"",
      "#include <utime.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <sys/param.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Oid\tAuthenticatedUserId = InvalidOid;",
      "static bool AuthenticatedUserIsSuperuser = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetSessionUserId",
          "args": [
            "BOOTSTRAP_SUPERUSERID",
            "true"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "SetSessionUserId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
          "lines": "428-440",
          "snippet": "static void\nSetSessionUserId(Oid userid, bool is_superuser)\n{\n\tAssertState(SecurityRestrictionContext == 0);\n\tAssertArg(OidIsValid(userid));\n\tSessionUserId = userid;\n\tSessionUserIsSuperuser = is_superuser;\n\tSetRoleIsActive = false;\n\n\t/* We force the effective user IDs to match, too */\n\tOuterUserId = userid;\n\tCurrentUserId = userid;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pidfile.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pg_shmem.h\"",
            "#include \"storage/latch.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/fd.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"common/file_perm.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/htup_details.h\"",
            "#include <utime.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/param.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Oid\tSessionUserId = InvalidOid;",
            "static Oid\tOuterUserId = InvalidOid;",
            "static Oid\tCurrentUserId = InvalidOid;",
            "static bool SessionUserIsSuperuser = false;",
            "static int\tSecurityRestrictionContext = 0;",
            "static bool SetRoleIsActive = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nstatic Oid\tSessionUserId = InvalidOid;\nstatic Oid\tOuterUserId = InvalidOid;\nstatic Oid\tCurrentUserId = InvalidOid;\nstatic bool SessionUserIsSuperuser = false;\nstatic int\tSecurityRestrictionContext = 0;\nstatic bool SetRoleIsActive = false;\n\nstatic void\nSetSessionUserId(Oid userid, bool is_superuser)\n{\n\tAssertState(SecurityRestrictionContext == 0);\n\tAssertArg(OidIsValid(userid));\n\tSessionUserId = userid;\n\tSessionUserIsSuperuser = is_superuser;\n\tSetRoleIsActive = false;\n\n\t/* We force the effective user IDs to match, too */\n\tOuterUserId = userid;\n\tCurrentUserId = userid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AssertState",
          "args": [
            "!OidIsValid(AuthenticatedUserId)"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "AuthenticatedUserId"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AssertState",
          "args": [
            "!IsUnderPostmaster || IsAutoVacuumWorkerProcess() || IsBackgroundWorker"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsAutoVacuumWorkerProcess",
          "args": [],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nstatic Oid\tAuthenticatedUserId = InvalidOid;\nstatic bool AuthenticatedUserIsSuperuser = false;\n\nvoid\nInitializeSessionUserIdStandalone(void)\n{\n\t/*\n\t * This function should only be called in single-user mode, in autovacuum\n\t * workers, and in background workers.\n\t */\n\tAssertState(!IsUnderPostmaster || IsAutoVacuumWorkerProcess() || IsBackgroundWorker);\n\n\t/* call only once */\n\tAssertState(!OidIsValid(AuthenticatedUserId));\n\n\tAuthenticatedUserId = BOOTSTRAP_SUPERUSERID;\n\tAuthenticatedUserIsSuperuser = true;\n\n\tSetSessionUserId(BOOTSTRAP_SUPERUSERID, true);\n}"
  },
  {
    "function_name": "InitializeSessionUserId",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
    "lines": "585-675",
    "snippet": "void\nInitializeSessionUserId(const char *rolename, Oid roleid)\n{\n\tHeapTuple\troleTup;\n\tForm_pg_authid rform;\n\tchar\t   *rname;\n\n\t/*\n\t * Don't do scans if we're bootstrapping, none of the system catalogs\n\t * exist yet, and they should be owned by postgres anyway.\n\t */\n\tAssertState(!IsBootstrapProcessingMode());\n\n\t/* call only once */\n\tAssertState(!OidIsValid(AuthenticatedUserId));\n\n\tif (rolename != NULL)\n\t{\n\t\troleTup = SearchSysCache1(AUTHNAME, PointerGetDatum(rolename));\n\t\tif (!HeapTupleIsValid(roleTup))\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_AUTHORIZATION_SPECIFICATION),\n\t\t\t\t\t errmsg(\"role \\\"%s\\\" does not exist\", rolename)));\n\t}\n\telse\n\t{\n\t\troleTup = SearchSysCache1(AUTHOID, ObjectIdGetDatum(roleid));\n\t\tif (!HeapTupleIsValid(roleTup))\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_AUTHORIZATION_SPECIFICATION),\n\t\t\t\t\t errmsg(\"role with OID %u does not exist\", roleid)));\n\t}\n\n\trform = (Form_pg_authid) GETSTRUCT(roleTup);\n\troleid = HeapTupleGetOid(roleTup);\n\trname = NameStr(rform->rolname);\n\n\tAuthenticatedUserId = roleid;\n\tAuthenticatedUserIsSuperuser = rform->rolsuper;\n\n\t/* This sets OuterUserId/CurrentUserId too */\n\tSetSessionUserId(roleid, AuthenticatedUserIsSuperuser);\n\n\t/* Also mark our PGPROC entry with the authenticated user id */\n\t/* (We assume this is an atomic store so no lock is needed) */\n\tMyProc->roleId = roleid;\n\n\t/*\n\t * These next checks are not enforced when in standalone mode, so that\n\t * there is a way to recover from sillinesses like \"UPDATE pg_authid SET\n\t * rolcanlogin = false;\".\n\t */\n\tif (IsUnderPostmaster)\n\t{\n\t\t/*\n\t\t * Is role allowed to login at all?\n\t\t */\n\t\tif (!rform->rolcanlogin)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_AUTHORIZATION_SPECIFICATION),\n\t\t\t\t\t errmsg(\"role \\\"%s\\\" is not permitted to log in\",\n\t\t\t\t\t\t\trname)));\n\n\t\t/*\n\t\t * Check connection limit for this role.\n\t\t *\n\t\t * There is a race condition here --- we create our PGPROC before\n\t\t * checking for other PGPROCs.  If two backends did this at about the\n\t\t * same time, they might both think they were over the limit, while\n\t\t * ideally one should succeed and one fail.  Getting that to work\n\t\t * exactly seems more trouble than it is worth, however; instead we\n\t\t * just document that the connection limit is approximate.\n\t\t */\n\t\tif (rform->rolconnlimit >= 0 &&\n\t\t\t!AuthenticatedUserIsSuperuser &&\n\t\t\tCountUserBackends(roleid) > rform->rolconnlimit)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_TOO_MANY_CONNECTIONS),\n\t\t\t\t\t errmsg(\"too many connections for role \\\"%s\\\"\",\n\t\t\t\t\t\t\trname)));\n\t}\n\n\t/* Record username and superuser status as GUC settings too */\n\tSetConfigOption(\"session_authorization\", rname,\n\t\t\t\t\tPGC_BACKEND, PGC_S_OVERRIDE);\n\tSetConfigOption(\"is_superuser\",\n\t\t\t\t\tAuthenticatedUserIsSuperuser ? \"on\" : \"off\",\n\t\t\t\t\tPGC_INTERNAL, PGC_S_OVERRIDE);\n\n\tReleaseSysCache(roleTup);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pidfile.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/pg_shmem.h\"",
      "#include \"storage/latch.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/fd.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"postmaster/autovacuum.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"common/file_perm.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/htup_details.h\"",
      "#include <utime.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <sys/param.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Oid\tAuthenticatedUserId = InvalidOid;",
      "static Oid\tOuterUserId = InvalidOid;",
      "static Oid\tCurrentUserId = InvalidOid;",
      "static bool AuthenticatedUserIsSuperuser = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ReleaseSysCache",
          "args": [
            "roleTup"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "ReleaseSysCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1159-1163",
          "snippet": "void\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetConfigOption",
          "args": [
            "\"is_superuser\"",
            "AuthenticatedUserIsSuperuser ? \"on\" : \"off\"",
            "PGC_INTERNAL",
            "PGC_S_OVERRIDE"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "SetConfigOption",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/guc.c",
          "lines": "6930-6936",
          "snippet": "void\nSetConfigOption(const char *name, const char *value,\n\t\t\t\tGucContext context, GucSource source)\n{\n\t(void) set_config_option(name, value, context, source,\n\t\t\t\t\t\t\t GUC_ACTION_SET, true, 0, false);\n}",
          "includes": [
            "#include \"guc-file.c\"",
            "#include \"utils/xml.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/tzparser.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/ps_status.h\"",
            "#include \"utils/portal.h\"",
            "#include \"utils/plancache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc_tables.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_cache.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pg_shmem.h\"",
            "#include \"storage/large_object.h\"",
            "#include \"storage/fd.h\"",
            "#include \"storage/standby.h\"",
            "#include \"storage/dsm_impl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"replication/walsender.h\"",
            "#include \"replication/walreceiver.h\"",
            "#include \"replication/syncrep.h\"",
            "#include \"replication/slot.h\"",
            "#include \"replication/logicallauncher.h\"",
            "#include \"postmaster/walwriter.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/bgwriter.h\"",
            "#include \"postmaster/bgworker_internals.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"parser/parser.h\"",
            "#include \"parser/parse_type.h\"",
            "#include \"parser/parse_expr.h\"",
            "#include \"optimizer/planmain.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/geqo.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"libpq/auth.h\"",
            "#include \"jit/jit.h\"",
            "#include \"funcapi.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/variable.h\"",
            "#include \"commands/vacuum.h\"",
            "#include \"commands/user.h\"",
            "#include \"commands/prepare.h\"",
            "#include \"commands/async.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xlog_internal.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/twophase.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/rmgr.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/commit_ts.h\"",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool check_log_destination(char **newval, void **extra, GucSource source);",
            "static bool check_wal_consistency_checking(char **newval, void **extra,\n\t\t\t\t\t\t\t   GucSource source);",
            "static bool check_client_min_messages(int *newval, void **extra, GucSource source);",
            "static bool check_temp_buffers(int *newval, void **extra, GucSource source);",
            "static bool check_bonjour(bool *newval, void **extra, GucSource source);",
            "static bool check_ssl(bool *newval, void **extra, GucSource source);",
            "static bool check_stage_log_stats(bool *newval, void **extra, GucSource source);",
            "static bool check_log_stats(bool *newval, void **extra, GucSource source);",
            "static bool check_canonical_path(char **newval, void **extra, GucSource source);",
            "static bool check_timezone_abbreviations(char **newval, void **extra, GucSource source);",
            "static bool check_maxconnections(int *newval, void **extra, GucSource source);",
            "static bool check_max_worker_processes(int *newval, void **extra, GucSource source);",
            "static bool check_autovacuum_max_workers(int *newval, void **extra, GucSource source);",
            "static bool check_autovacuum_work_mem(int *newval, void **extra, GucSource source);",
            "static bool check_effective_io_concurrency(int *newval, void **extra, GucSource source);",
            "static bool check_application_name(char **newval, void **extra, GucSource source);",
            "static bool check_cluster_name(char **newval, void **extra, GucSource source);",
            "static void replace_auto_config_value(ConfigVariable **head_p, ConfigVariable **tail_p,\n\t\t\t\t\t\t  const char *name, const char *value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"guc-file.c\"\n#include \"utils/xml.h\"\n#include \"utils/varlena.h\"\n#include \"utils/tzparser.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/ps_status.h\"\n#include \"utils/portal.h\"\n#include \"utils/plancache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc_tables.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_cache.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/predicate.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/large_object.h\"\n#include \"storage/fd.h\"\n#include \"storage/standby.h\"\n#include \"storage/dsm_impl.h\"\n#include \"storage/bufmgr.h\"\n#include \"replication/walsender.h\"\n#include \"replication/walreceiver.h\"\n#include \"replication/syncrep.h\"\n#include \"replication/slot.h\"\n#include \"replication/logicallauncher.h\"\n#include \"postmaster/walwriter.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/bgwriter.h\"\n#include \"postmaster/bgworker_internals.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parser.h\"\n#include \"parser/parse_type.h\"\n#include \"parser/parse_expr.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/geqo.h\"\n#include \"optimizer/cost.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"libpq/auth.h\"\n#include \"jit/jit.h\"\n#include \"funcapi.h\"\n#include \"commands/trigger.h\"\n#include \"commands/variable.h\"\n#include \"commands/vacuum.h\"\n#include \"commands/user.h\"\n#include \"commands/prepare.h\"\n#include \"commands/async.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xlog_internal.h\"\n#include \"access/xact.h\"\n#include \"access/twophase.h\"\n#include \"access/transam.h\"\n#include \"access/rmgr.h\"\n#include \"access/gin.h\"\n#include \"access/commit_ts.h\"\n#include <syslog.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool check_log_destination(char **newval, void **extra, GucSource source);\nstatic bool check_wal_consistency_checking(char **newval, void **extra,\n\t\t\t\t\t\t\t   GucSource source);\nstatic bool check_client_min_messages(int *newval, void **extra, GucSource source);\nstatic bool check_temp_buffers(int *newval, void **extra, GucSource source);\nstatic bool check_bonjour(bool *newval, void **extra, GucSource source);\nstatic bool check_ssl(bool *newval, void **extra, GucSource source);\nstatic bool check_stage_log_stats(bool *newval, void **extra, GucSource source);\nstatic bool check_log_stats(bool *newval, void **extra, GucSource source);\nstatic bool check_canonical_path(char **newval, void **extra, GucSource source);\nstatic bool check_timezone_abbreviations(char **newval, void **extra, GucSource source);\nstatic bool check_maxconnections(int *newval, void **extra, GucSource source);\nstatic bool check_max_worker_processes(int *newval, void **extra, GucSource source);\nstatic bool check_autovacuum_max_workers(int *newval, void **extra, GucSource source);\nstatic bool check_autovacuum_work_mem(int *newval, void **extra, GucSource source);\nstatic bool check_effective_io_concurrency(int *newval, void **extra, GucSource source);\nstatic bool check_application_name(char **newval, void **extra, GucSource source);\nstatic bool check_cluster_name(char **newval, void **extra, GucSource source);\nstatic void replace_auto_config_value(ConfigVariable **head_p, ConfigVariable **tail_p,\n\t\t\t\t\t\t  const char *name, const char *value);\n\nvoid\nSetConfigOption(const char *name, const char *value,\n\t\t\t\tGucContext context, GucSource source)\n{\n\t(void) set_config_option(name, value, context, source,\n\t\t\t\t\t\t\t GUC_ACTION_SET, true, 0, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "FATAL",
            "(errcode(ERRCODE_TOO_MANY_CONNECTIONS),\n\t\t\t\t\t errmsg(\"too many connections for role \\\"%s\\\"\",\n\t\t\t\t\t\t\trname))"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"too many connections for role \\\"%s\\\"\"",
            "rname"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_TOO_MANY_CONNECTIONS"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "CountUserBackends",
          "args": [
            "roleid"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "FATAL",
            "(errcode(ERRCODE_INVALID_AUTHORIZATION_SPECIFICATION),\n\t\t\t\t\t errmsg(\"role \\\"%s\\\" is not permitted to log in\",\n\t\t\t\t\t\t\trname))"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetSessionUserId",
          "args": [
            "roleid",
            "AuthenticatedUserIsSuperuser"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "SetSessionUserId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
          "lines": "428-440",
          "snippet": "static void\nSetSessionUserId(Oid userid, bool is_superuser)\n{\n\tAssertState(SecurityRestrictionContext == 0);\n\tAssertArg(OidIsValid(userid));\n\tSessionUserId = userid;\n\tSessionUserIsSuperuser = is_superuser;\n\tSetRoleIsActive = false;\n\n\t/* We force the effective user IDs to match, too */\n\tOuterUserId = userid;\n\tCurrentUserId = userid;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pidfile.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pg_shmem.h\"",
            "#include \"storage/latch.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/fd.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"common/file_perm.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/htup_details.h\"",
            "#include <utime.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/param.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Oid\tSessionUserId = InvalidOid;",
            "static Oid\tOuterUserId = InvalidOid;",
            "static Oid\tCurrentUserId = InvalidOid;",
            "static bool SessionUserIsSuperuser = false;",
            "static int\tSecurityRestrictionContext = 0;",
            "static bool SetRoleIsActive = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nstatic Oid\tSessionUserId = InvalidOid;\nstatic Oid\tOuterUserId = InvalidOid;\nstatic Oid\tCurrentUserId = InvalidOid;\nstatic bool SessionUserIsSuperuser = false;\nstatic int\tSecurityRestrictionContext = 0;\nstatic bool SetRoleIsActive = false;\n\nstatic void\nSetSessionUserId(Oid userid, bool is_superuser)\n{\n\tAssertState(SecurityRestrictionContext == 0);\n\tAssertArg(OidIsValid(userid));\n\tSessionUserId = userid;\n\tSessionUserIsSuperuser = is_superuser;\n\tSetRoleIsActive = false;\n\n\t/* We force the effective user IDs to match, too */\n\tOuterUserId = userid;\n\tCurrentUserId = userid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "rform->rolname"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleGetOid",
          "args": [
            "roleTup"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "roleTup"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "FATAL",
            "(errcode(ERRCODE_INVALID_AUTHORIZATION_SPECIFICATION),\n\t\t\t\t\t errmsg(\"role with OID %u does not exist\", roleid))"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "roleTup"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SearchSysCache1",
          "args": [
            "AUTHOID",
            "ObjectIdGetDatum(roleid)"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "SearchSysCache1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1111-1120",
          "snippet": "HeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nHeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "roleid"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "FATAL",
            "(errcode(ERRCODE_INVALID_AUTHORIZATION_SPECIFICATION),\n\t\t\t\t\t errmsg(\"role \\\"%s\\\" does not exist\", rolename))"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "roleTup"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "rolename"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AssertState",
          "args": [
            "!OidIsValid(AuthenticatedUserId)"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "AuthenticatedUserId"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AssertState",
          "args": [
            "!IsBootstrapProcessingMode()"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsBootstrapProcessingMode",
          "args": [],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nstatic Oid\tAuthenticatedUserId = InvalidOid;\nstatic Oid\tOuterUserId = InvalidOid;\nstatic Oid\tCurrentUserId = InvalidOid;\nstatic bool AuthenticatedUserIsSuperuser = false;\n\nvoid\nInitializeSessionUserId(const char *rolename, Oid roleid)\n{\n\tHeapTuple\troleTup;\n\tForm_pg_authid rform;\n\tchar\t   *rname;\n\n\t/*\n\t * Don't do scans if we're bootstrapping, none of the system catalogs\n\t * exist yet, and they should be owned by postgres anyway.\n\t */\n\tAssertState(!IsBootstrapProcessingMode());\n\n\t/* call only once */\n\tAssertState(!OidIsValid(AuthenticatedUserId));\n\n\tif (rolename != NULL)\n\t{\n\t\troleTup = SearchSysCache1(AUTHNAME, PointerGetDatum(rolename));\n\t\tif (!HeapTupleIsValid(roleTup))\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_AUTHORIZATION_SPECIFICATION),\n\t\t\t\t\t errmsg(\"role \\\"%s\\\" does not exist\", rolename)));\n\t}\n\telse\n\t{\n\t\troleTup = SearchSysCache1(AUTHOID, ObjectIdGetDatum(roleid));\n\t\tif (!HeapTupleIsValid(roleTup))\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_AUTHORIZATION_SPECIFICATION),\n\t\t\t\t\t errmsg(\"role with OID %u does not exist\", roleid)));\n\t}\n\n\trform = (Form_pg_authid) GETSTRUCT(roleTup);\n\troleid = HeapTupleGetOid(roleTup);\n\trname = NameStr(rform->rolname);\n\n\tAuthenticatedUserId = roleid;\n\tAuthenticatedUserIsSuperuser = rform->rolsuper;\n\n\t/* This sets OuterUserId/CurrentUserId too */\n\tSetSessionUserId(roleid, AuthenticatedUserIsSuperuser);\n\n\t/* Also mark our PGPROC entry with the authenticated user id */\n\t/* (We assume this is an atomic store so no lock is needed) */\n\tMyProc->roleId = roleid;\n\n\t/*\n\t * These next checks are not enforced when in standalone mode, so that\n\t * there is a way to recover from sillinesses like \"UPDATE pg_authid SET\n\t * rolcanlogin = false;\".\n\t */\n\tif (IsUnderPostmaster)\n\t{\n\t\t/*\n\t\t * Is role allowed to login at all?\n\t\t */\n\t\tif (!rform->rolcanlogin)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_AUTHORIZATION_SPECIFICATION),\n\t\t\t\t\t errmsg(\"role \\\"%s\\\" is not permitted to log in\",\n\t\t\t\t\t\t\trname)));\n\n\t\t/*\n\t\t * Check connection limit for this role.\n\t\t *\n\t\t * There is a race condition here --- we create our PGPROC before\n\t\t * checking for other PGPROCs.  If two backends did this at about the\n\t\t * same time, they might both think they were over the limit, while\n\t\t * ideally one should succeed and one fail.  Getting that to work\n\t\t * exactly seems more trouble than it is worth, however; instead we\n\t\t * just document that the connection limit is approximate.\n\t\t */\n\t\tif (rform->rolconnlimit >= 0 &&\n\t\t\t!AuthenticatedUserIsSuperuser &&\n\t\t\tCountUserBackends(roleid) > rform->rolconnlimit)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_TOO_MANY_CONNECTIONS),\n\t\t\t\t\t errmsg(\"too many connections for role \\\"%s\\\"\",\n\t\t\t\t\t\t\trname)));\n\t}\n\n\t/* Record username and superuser status as GUC settings too */\n\tSetConfigOption(\"session_authorization\", rname,\n\t\t\t\t\tPGC_BACKEND, PGC_S_OVERRIDE);\n\tSetConfigOption(\"is_superuser\",\n\t\t\t\t\tAuthenticatedUserIsSuperuser ? \"on\" : \"off\",\n\t\t\t\t\tPGC_INTERNAL, PGC_S_OVERRIDE);\n\n\tReleaseSysCache(roleTup);\n}"
  },
  {
    "function_name": "has_rolreplication",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
    "lines": "567-580",
    "snippet": "bool\nhas_rolreplication(Oid roleid)\n{\n\tbool\t\tresult = false;\n\tHeapTuple\tutup;\n\n\tutup = SearchSysCache1(AUTHOID, ObjectIdGetDatum(roleid));\n\tif (HeapTupleIsValid(utup))\n\t{\n\t\tresult = ((Form_pg_authid) GETSTRUCT(utup))->rolreplication;\n\t\tReleaseSysCache(utup);\n\t}\n\treturn result;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pidfile.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/pg_shmem.h\"",
      "#include \"storage/latch.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/fd.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"postmaster/autovacuum.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"common/file_perm.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/htup_details.h\"",
      "#include <utime.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <sys/param.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ReleaseSysCache",
          "args": [
            "utup"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "ReleaseSysCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1159-1163",
          "snippet": "void\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "utup"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "utup"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SearchSysCache1",
          "args": [
            "AUTHOID",
            "ObjectIdGetDatum(roleid)"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "SearchSysCache1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1111-1120",
          "snippet": "HeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nHeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "roleid"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nbool\nhas_rolreplication(Oid roleid)\n{\n\tbool\t\tresult = false;\n\tHeapTuple\tutup;\n\n\tutup = SearchSysCache1(AUTHOID, ObjectIdGetDatum(roleid));\n\tif (HeapTupleIsValid(utup))\n\t{\n\t\tresult = ((Form_pg_authid) GETSTRUCT(utup))->rolreplication;\n\t\tReleaseSysCache(utup);\n\t}\n\treturn result;\n}"
  },
  {
    "function_name": "SetUserIdAndContext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
    "lines": "547-561",
    "snippet": "void\nSetUserIdAndContext(Oid userid, bool sec_def_context)\n{\n\t/* We throw the same error SET ROLE would. */\n\tif (InSecurityRestrictedOperation())\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t errmsg(\"cannot set parameter \\\"%s\\\" within security-restricted operation\",\n\t\t\t\t\t\t\"role\")));\n\tCurrentUserId = userid;\n\tif (sec_def_context)\n\t\tSecurityRestrictionContext |= SECURITY_LOCAL_USERID_CHANGE;\n\telse\n\t\tSecurityRestrictionContext &= ~SECURITY_LOCAL_USERID_CHANGE;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pidfile.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/pg_shmem.h\"",
      "#include \"storage/latch.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/fd.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"postmaster/autovacuum.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"common/file_perm.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/htup_details.h\"",
      "#include <utime.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <sys/param.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Oid\tCurrentUserId = InvalidOid;",
      "static int\tSecurityRestrictionContext = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t errmsg(\"cannot set parameter \\\"%s\\\" within security-restricted operation\",\n\t\t\t\t\t\t\"role\"))"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"cannot set parameter \\\"%s\\\" within security-restricted operation\"",
            "\"role\""
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INSUFFICIENT_PRIVILEGE"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "InSecurityRestrictedOperation",
          "args": [],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "InSecurityRestrictedOperation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
          "lines": "518-522",
          "snippet": "bool\nInSecurityRestrictedOperation(void)\n{\n\treturn (SecurityRestrictionContext & SECURITY_RESTRICTED_OPERATION) != 0;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pidfile.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pg_shmem.h\"",
            "#include \"storage/latch.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/fd.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"common/file_perm.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/htup_details.h\"",
            "#include <utime.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/param.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tSecurityRestrictionContext = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nstatic int\tSecurityRestrictionContext = 0;\n\nbool\nInSecurityRestrictedOperation(void)\n{\n\treturn (SecurityRestrictionContext & SECURITY_RESTRICTED_OPERATION) != 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nstatic Oid\tCurrentUserId = InvalidOid;\nstatic int\tSecurityRestrictionContext = 0;\n\nvoid\nSetUserIdAndContext(Oid userid, bool sec_def_context)\n{\n\t/* We throw the same error SET ROLE would. */\n\tif (InSecurityRestrictedOperation())\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t errmsg(\"cannot set parameter \\\"%s\\\" within security-restricted operation\",\n\t\t\t\t\t\t\"role\")));\n\tCurrentUserId = userid;\n\tif (sec_def_context)\n\t\tSecurityRestrictionContext |= SECURITY_LOCAL_USERID_CHANGE;\n\telse\n\t\tSecurityRestrictionContext &= ~SECURITY_LOCAL_USERID_CHANGE;\n}"
  },
  {
    "function_name": "GetUserIdAndContext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
    "lines": "540-545",
    "snippet": "void\nGetUserIdAndContext(Oid *userid, bool *sec_def_context)\n{\n\t*userid = CurrentUserId;\n\t*sec_def_context = InLocalUserIdChange();\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pidfile.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/pg_shmem.h\"",
      "#include \"storage/latch.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/fd.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"postmaster/autovacuum.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"common/file_perm.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/htup_details.h\"",
      "#include <utime.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <sys/param.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Oid\tCurrentUserId = InvalidOid;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "InLocalUserIdChange",
          "args": [],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "InLocalUserIdChange",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
          "lines": "509-513",
          "snippet": "bool\nInLocalUserIdChange(void)\n{\n\treturn (SecurityRestrictionContext & SECURITY_LOCAL_USERID_CHANGE) != 0;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pidfile.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pg_shmem.h\"",
            "#include \"storage/latch.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/fd.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"common/file_perm.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/htup_details.h\"",
            "#include <utime.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/param.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tSecurityRestrictionContext = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nstatic int\tSecurityRestrictionContext = 0;\n\nbool\nInLocalUserIdChange(void)\n{\n\treturn (SecurityRestrictionContext & SECURITY_LOCAL_USERID_CHANGE) != 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nstatic Oid\tCurrentUserId = InvalidOid;\n\nvoid\nGetUserIdAndContext(Oid *userid, bool *sec_def_context)\n{\n\t*userid = CurrentUserId;\n\t*sec_def_context = InLocalUserIdChange();\n}"
  },
  {
    "function_name": "InNoForceRLSOperation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
    "lines": "527-531",
    "snippet": "bool\nInNoForceRLSOperation(void)\n{\n\treturn (SecurityRestrictionContext & SECURITY_NOFORCE_RLS) != 0;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pidfile.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/pg_shmem.h\"",
      "#include \"storage/latch.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/fd.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"postmaster/autovacuum.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"common/file_perm.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/htup_details.h\"",
      "#include <utime.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <sys/param.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tSecurityRestrictionContext = 0;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nstatic int\tSecurityRestrictionContext = 0;\n\nbool\nInNoForceRLSOperation(void)\n{\n\treturn (SecurityRestrictionContext & SECURITY_NOFORCE_RLS) != 0;\n}"
  },
  {
    "function_name": "InSecurityRestrictedOperation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
    "lines": "518-522",
    "snippet": "bool\nInSecurityRestrictedOperation(void)\n{\n\treturn (SecurityRestrictionContext & SECURITY_RESTRICTED_OPERATION) != 0;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pidfile.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/pg_shmem.h\"",
      "#include \"storage/latch.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/fd.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"postmaster/autovacuum.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"common/file_perm.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/htup_details.h\"",
      "#include <utime.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <sys/param.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tSecurityRestrictionContext = 0;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nstatic int\tSecurityRestrictionContext = 0;\n\nbool\nInSecurityRestrictedOperation(void)\n{\n\treturn (SecurityRestrictionContext & SECURITY_RESTRICTED_OPERATION) != 0;\n}"
  },
  {
    "function_name": "InLocalUserIdChange",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
    "lines": "509-513",
    "snippet": "bool\nInLocalUserIdChange(void)\n{\n\treturn (SecurityRestrictionContext & SECURITY_LOCAL_USERID_CHANGE) != 0;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pidfile.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/pg_shmem.h\"",
      "#include \"storage/latch.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/fd.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"postmaster/autovacuum.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"common/file_perm.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/htup_details.h\"",
      "#include <utime.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <sys/param.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tSecurityRestrictionContext = 0;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nstatic int\tSecurityRestrictionContext = 0;\n\nbool\nInLocalUserIdChange(void)\n{\n\treturn (SecurityRestrictionContext & SECURITY_LOCAL_USERID_CHANGE) != 0;\n}"
  },
  {
    "function_name": "SetUserIdAndSecContext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
    "lines": "498-503",
    "snippet": "void\nSetUserIdAndSecContext(Oid userid, int sec_context)\n{\n\tCurrentUserId = userid;\n\tSecurityRestrictionContext = sec_context;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pidfile.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/pg_shmem.h\"",
      "#include \"storage/latch.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/fd.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"postmaster/autovacuum.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"common/file_perm.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/htup_details.h\"",
      "#include <utime.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <sys/param.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Oid\tCurrentUserId = InvalidOid;",
      "static int\tSecurityRestrictionContext = 0;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nstatic Oid\tCurrentUserId = InvalidOid;\nstatic int\tSecurityRestrictionContext = 0;\n\nvoid\nSetUserIdAndSecContext(Oid userid, int sec_context)\n{\n\tCurrentUserId = userid;\n\tSecurityRestrictionContext = sec_context;\n}"
  },
  {
    "function_name": "GetUserIdAndSecContext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
    "lines": "491-496",
    "snippet": "void\nGetUserIdAndSecContext(Oid *userid, int *sec_context)\n{\n\t*userid = CurrentUserId;\n\t*sec_context = SecurityRestrictionContext;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pidfile.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/pg_shmem.h\"",
      "#include \"storage/latch.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/fd.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"postmaster/autovacuum.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"common/file_perm.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/htup_details.h\"",
      "#include <utime.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <sys/param.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Oid\tCurrentUserId = InvalidOid;",
      "static int\tSecurityRestrictionContext = 0;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nstatic Oid\tCurrentUserId = InvalidOid;\nstatic int\tSecurityRestrictionContext = 0;\n\nvoid\nGetUserIdAndSecContext(Oid *userid, int *sec_context)\n{\n\t*userid = CurrentUserId;\n\t*sec_context = SecurityRestrictionContext;\n}"
  },
  {
    "function_name": "GetAuthenticatedUserId",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
    "lines": "445-450",
    "snippet": "Oid\nGetAuthenticatedUserId(void)\n{\n\tAssertState(OidIsValid(AuthenticatedUserId));\n\treturn AuthenticatedUserId;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pidfile.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/pg_shmem.h\"",
      "#include \"storage/latch.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/fd.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"postmaster/autovacuum.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"common/file_perm.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/htup_details.h\"",
      "#include <utime.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <sys/param.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Oid\tAuthenticatedUserId = InvalidOid;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "AssertState",
          "args": [
            "OidIsValid(AuthenticatedUserId)"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "AuthenticatedUserId"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nstatic Oid\tAuthenticatedUserId = InvalidOid;\n\nOid\nGetAuthenticatedUserId(void)\n{\n\tAssertState(OidIsValid(AuthenticatedUserId));\n\treturn AuthenticatedUserId;\n}"
  },
  {
    "function_name": "SetSessionUserId",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
    "lines": "428-440",
    "snippet": "static void\nSetSessionUserId(Oid userid, bool is_superuser)\n{\n\tAssertState(SecurityRestrictionContext == 0);\n\tAssertArg(OidIsValid(userid));\n\tSessionUserId = userid;\n\tSessionUserIsSuperuser = is_superuser;\n\tSetRoleIsActive = false;\n\n\t/* We force the effective user IDs to match, too */\n\tOuterUserId = userid;\n\tCurrentUserId = userid;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pidfile.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/pg_shmem.h\"",
      "#include \"storage/latch.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/fd.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"postmaster/autovacuum.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"common/file_perm.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/htup_details.h\"",
      "#include <utime.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <sys/param.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Oid\tSessionUserId = InvalidOid;",
      "static Oid\tOuterUserId = InvalidOid;",
      "static Oid\tCurrentUserId = InvalidOid;",
      "static bool SessionUserIsSuperuser = false;",
      "static int\tSecurityRestrictionContext = 0;",
      "static bool SetRoleIsActive = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "AssertArg",
          "args": [
            "OidIsValid(userid)"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "userid"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AssertState",
          "args": [
            "SecurityRestrictionContext == 0"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nstatic Oid\tSessionUserId = InvalidOid;\nstatic Oid\tOuterUserId = InvalidOid;\nstatic Oid\tCurrentUserId = InvalidOid;\nstatic bool SessionUserIsSuperuser = false;\nstatic int\tSecurityRestrictionContext = 0;\nstatic bool SetRoleIsActive = false;\n\nstatic void\nSetSessionUserId(Oid userid, bool is_superuser)\n{\n\tAssertState(SecurityRestrictionContext == 0);\n\tAssertArg(OidIsValid(userid));\n\tSessionUserId = userid;\n\tSessionUserIsSuperuser = is_superuser;\n\tSetRoleIsActive = false;\n\n\t/* We force the effective user IDs to match, too */\n\tOuterUserId = userid;\n\tCurrentUserId = userid;\n}"
  },
  {
    "function_name": "GetSessionUserId",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
    "lines": "420-425",
    "snippet": "Oid\nGetSessionUserId(void)\n{\n\tAssertState(OidIsValid(SessionUserId));\n\treturn SessionUserId;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pidfile.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/pg_shmem.h\"",
      "#include \"storage/latch.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/fd.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"postmaster/autovacuum.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"common/file_perm.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/htup_details.h\"",
      "#include <utime.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <sys/param.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Oid\tSessionUserId = InvalidOid;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "AssertState",
          "args": [
            "OidIsValid(SessionUserId)"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "SessionUserId"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nstatic Oid\tSessionUserId = InvalidOid;\n\nOid\nGetSessionUserId(void)\n{\n\tAssertState(OidIsValid(SessionUserId));\n\treturn SessionUserId;\n}"
  },
  {
    "function_name": "SetOuterUserId",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
    "lines": "405-414",
    "snippet": "static void\nSetOuterUserId(Oid userid)\n{\n\tAssertState(SecurityRestrictionContext == 0);\n\tAssertArg(OidIsValid(userid));\n\tOuterUserId = userid;\n\n\t/* We force the effective user ID to match, too */\n\tCurrentUserId = userid;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pidfile.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/pg_shmem.h\"",
      "#include \"storage/latch.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/fd.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"postmaster/autovacuum.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"common/file_perm.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/htup_details.h\"",
      "#include <utime.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <sys/param.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Oid\tOuterUserId = InvalidOid;",
      "static Oid\tCurrentUserId = InvalidOid;",
      "static int\tSecurityRestrictionContext = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "AssertArg",
          "args": [
            "OidIsValid(userid)"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "userid"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AssertState",
          "args": [
            "SecurityRestrictionContext == 0"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nstatic Oid\tOuterUserId = InvalidOid;\nstatic Oid\tCurrentUserId = InvalidOid;\nstatic int\tSecurityRestrictionContext = 0;\n\nstatic void\nSetOuterUserId(Oid userid)\n{\n\tAssertState(SecurityRestrictionContext == 0);\n\tAssertArg(OidIsValid(userid));\n\tOuterUserId = userid;\n\n\t/* We force the effective user ID to match, too */\n\tCurrentUserId = userid;\n}"
  },
  {
    "function_name": "GetOuterUserId",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
    "lines": "397-402",
    "snippet": "Oid\nGetOuterUserId(void)\n{\n\tAssertState(OidIsValid(OuterUserId));\n\treturn OuterUserId;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pidfile.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/pg_shmem.h\"",
      "#include \"storage/latch.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/fd.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"postmaster/autovacuum.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"common/file_perm.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/htup_details.h\"",
      "#include <utime.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <sys/param.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Oid\tOuterUserId = InvalidOid;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "AssertState",
          "args": [
            "OidIsValid(OuterUserId)"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "OuterUserId"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nstatic Oid\tOuterUserId = InvalidOid;\n\nOid\nGetOuterUserId(void)\n{\n\tAssertState(OidIsValid(OuterUserId));\n\treturn OuterUserId;\n}"
  },
  {
    "function_name": "GetUserId",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
    "lines": "386-391",
    "snippet": "Oid\nGetUserId(void)\n{\n\tAssertState(OidIsValid(CurrentUserId));\n\treturn CurrentUserId;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pidfile.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/pg_shmem.h\"",
      "#include \"storage/latch.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/fd.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"postmaster/autovacuum.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"common/file_perm.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/htup_details.h\"",
      "#include <utime.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <sys/param.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Oid\tCurrentUserId = InvalidOid;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "AssertState",
          "args": [
            "OidIsValid(CurrentUserId)"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "CurrentUserId"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nstatic Oid\tCurrentUserId = InvalidOid;\n\nOid\nGetUserId(void)\n{\n\tAssertState(OidIsValid(CurrentUserId));\n\treturn CurrentUserId;\n}"
  },
  {
    "function_name": "SwitchBackToLocalLatch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
    "lines": "367-379",
    "snippet": "void\nSwitchBackToLocalLatch(void)\n{\n\tAssert(MyLatch != &LocalLatchData);\n\tAssert(MyProc != NULL && MyLatch == &MyProc->procLatch);\n\n\tMyLatch = &LocalLatchData;\n\n\tif (FeBeWaitSet)\n\t\tModifyWaitEvent(FeBeWaitSet, 1, WL_LATCH_SET, MyLatch);\n\n\tSetLatch(MyLatch);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pidfile.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/pg_shmem.h\"",
      "#include \"storage/latch.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/fd.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"postmaster/autovacuum.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"common/file_perm.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/htup_details.h\"",
      "#include <utime.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <sys/param.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Latch LocalLatchData;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetLatch",
          "args": [
            "MyLatch"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ModifyWaitEvent",
          "args": [
            "FeBeWaitSet",
            "1",
            "WL_LATCH_SET",
            "MyLatch"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "MyProc != NULL && MyLatch == &MyProc->procLatch"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "MyLatch != &LocalLatchData"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nstatic Latch LocalLatchData;\n\nvoid\nSwitchBackToLocalLatch(void)\n{\n\tAssert(MyLatch != &LocalLatchData);\n\tAssert(MyProc != NULL && MyLatch == &MyProc->procLatch);\n\n\tMyLatch = &LocalLatchData;\n\n\tif (FeBeWaitSet)\n\t\tModifyWaitEvent(FeBeWaitSet, 1, WL_LATCH_SET, MyLatch);\n\n\tSetLatch(MyLatch);\n}"
  },
  {
    "function_name": "SwitchToSharedLatch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
    "lines": "348-365",
    "snippet": "void\nSwitchToSharedLatch(void)\n{\n\tAssert(MyLatch == &LocalLatchData);\n\tAssert(MyProc != NULL);\n\n\tMyLatch = &MyProc->procLatch;\n\n\tif (FeBeWaitSet)\n\t\tModifyWaitEvent(FeBeWaitSet, 1, WL_LATCH_SET, MyLatch);\n\n\t/*\n\t * Set the shared latch as the local one might have been set. This\n\t * shouldn't normally be necessary as code is supposed to check the\n\t * condition before waiting for the latch, but a bit care can't hurt.\n\t */\n\tSetLatch(MyLatch);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pidfile.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/pg_shmem.h\"",
      "#include \"storage/latch.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/fd.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"postmaster/autovacuum.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"common/file_perm.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/htup_details.h\"",
      "#include <utime.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <sys/param.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Latch LocalLatchData;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetLatch",
          "args": [
            "MyLatch"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ModifyWaitEvent",
          "args": [
            "FeBeWaitSet",
            "1",
            "WL_LATCH_SET",
            "MyLatch"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "MyProc != NULL"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "MyLatch == &LocalLatchData"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nstatic Latch LocalLatchData;\n\nvoid\nSwitchToSharedLatch(void)\n{\n\tAssert(MyLatch == &LocalLatchData);\n\tAssert(MyProc != NULL);\n\n\tMyLatch = &MyProc->procLatch;\n\n\tif (FeBeWaitSet)\n\t\tModifyWaitEvent(FeBeWaitSet, 1, WL_LATCH_SET, MyLatch);\n\n\t/*\n\t * Set the shared latch as the local one might have been set. This\n\t * shouldn't normally be necessary as code is supposed to check the\n\t * condition before waiting for the latch, but a bit care can't hurt.\n\t */\n\tSetLatch(MyLatch);\n}"
  },
  {
    "function_name": "InitStandaloneProcess",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
    "lines": "314-346",
    "snippet": "void\nInitStandaloneProcess(const char *argv0)\n{\n\tAssert(!IsPostmasterEnvironment);\n\n\tMyProcPid = getpid();\t\t/* reset MyProcPid */\n\n\tMyStartTime = time(NULL);\t/* set our start time in case we call elog */\n\n\t/*\n\t * Initialize random() for the first time, like PostmasterMain() would.\n\t * In a regular IsUnderPostmaster backend, BackendRun() computes a\n\t * high-entropy seed before any user query.  Fewer distinct initial seeds\n\t * can occur here.\n\t */\n\tsrandom((unsigned int) (MyProcPid ^ MyStartTime));\n\n\t/* Initialize process-local latch support */\n\tInitializeLatchSupport();\n\tMyLatch = &LocalLatchData;\n\tInitLatch(MyLatch);\n\n\t/* Compute paths, no postmaster to inherit from */\n\tif (my_exec_path[0] == '\\0')\n\t{\n\t\tif (find_my_exec(argv0, my_exec_path) < 0)\n\t\t\telog(FATAL, \"%s: could not locate my own executable path\",\n\t\t\t\t argv0);\n\t}\n\n\tif (pkglib_path[0] == '\\0')\n\t\tget_pkglib_path(my_exec_path, pkglib_path);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pidfile.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/pg_shmem.h\"",
      "#include \"storage/latch.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/fd.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"postmaster/autovacuum.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"common/file_perm.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/htup_details.h\"",
      "#include <utime.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <sys/param.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Latch LocalLatchData;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_pkglib_path",
          "args": [
            "my_exec_path",
            "pkglib_path"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "FATAL",
            "\"%s: could not locate my own executable path\"",
            "argv0"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_my_exec",
          "args": [
            "argv0",
            "my_exec_path"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InitLatch",
          "args": [
            "MyLatch"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InitializeLatchSupport",
          "args": [],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srandom",
          "args": [
            "(unsigned int) (MyProcPid ^ MyStartTime)"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "pg_timezone_names",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "4766-4876",
          "snippet": "Datum\npg_timezone_names(PG_FUNCTION_ARGS)\n{\n\tMemoryContext oldcontext;\n\tFuncCallContext *funcctx;\n\tpg_tzenum  *tzenum;\n\tpg_tz\t   *tz;\n\tDatum\t\tresult;\n\tHeapTuple\ttuple;\n\tDatum\t\tvalues[4];\n\tbool\t\tnulls[4];\n\tint\t\t\ttzoff;\n\tstruct pg_tm tm;\n\tfsec_t\t\tfsec;\n\tconst char *tzn;\n\tInterval   *resInterval;\n\tstruct pg_tm itm;\n\n\t/* stuff done only on the first call of the function */\n\tif (SRF_IS_FIRSTCALL())\n\t{\n\t\tTupleDesc\ttupdesc;\n\n\t\t/* create a function context for cross-call persistence */\n\t\tfuncctx = SRF_FIRSTCALL_INIT();\n\n\t\t/*\n\t\t * switch to memory context appropriate for multiple function calls\n\t\t */\n\t\toldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);\n\n\t\t/* initialize timezone scanning code */\n\t\ttzenum = pg_tzenumerate_start();\n\t\tfuncctx->user_fctx = (void *) tzenum;\n\n\t\t/*\n\t\t * build tupdesc for result tuples. This must match this function's\n\t\t * pg_proc entry!\n\t\t */\n\t\ttupdesc = CreateTemplateTupleDesc(4, false);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 1, \"name\",\n\t\t\t\t\t\t   TEXTOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 2, \"abbrev\",\n\t\t\t\t\t\t   TEXTOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 3, \"utc_offset\",\n\t\t\t\t\t\t   INTERVALOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 4, \"is_dst\",\n\t\t\t\t\t\t   BOOLOID, -1, 0);\n\n\t\tfuncctx->tuple_desc = BlessTupleDesc(tupdesc);\n\t\tMemoryContextSwitchTo(oldcontext);\n\t}\n\n\t/* stuff done on every call of the function */\n\tfuncctx = SRF_PERCALL_SETUP();\n\ttzenum = (pg_tzenum *) funcctx->user_fctx;\n\n\t/* search for another zone to display */\n\tfor (;;)\n\t{\n\t\toldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);\n\t\ttz = pg_tzenumerate_next(tzenum);\n\t\tMemoryContextSwitchTo(oldcontext);\n\n\t\tif (!tz)\n\t\t{\n\t\t\tpg_tzenumerate_end(tzenum);\n\t\t\tfuncctx->user_fctx = NULL;\n\t\t\tSRF_RETURN_DONE(funcctx);\n\t\t}\n\n\t\t/* Convert now() to local time in this zone */\n\t\tif (timestamp2tm(GetCurrentTransactionStartTimestamp(),\n\t\t\t\t\t\t &tzoff, &tm, &fsec, &tzn, tz) != 0)\n\t\t\tcontinue;\t\t\t/* ignore if conversion fails */\n\n\t\t/*\n\t\t * Ignore zic's rather silly \"Factory\" time zone.  The long string\n\t\t * about \"see zic manual page\" is used in tzdata versions before\n\t\t * 2016g; we can drop it someday when we're pretty sure no such data\n\t\t * exists in the wild on platforms using --with-system-tzdata.  In\n\t\t * 2016g and later, the time zone abbreviation \"-00\" is used for\n\t\t * \"Factory\" as well as some invalid cases, all of which we can\n\t\t * reasonably omit from the pg_timezone_names view.\n\t\t */\n\t\tif (tzn && (strcmp(tzn, \"-00\") == 0 ||\n\t\t\t\t\tstrcmp(tzn, \"Local time zone must be set--see zic manual page\") == 0))\n\t\t\tcontinue;\n\n\t\t/* Found a displayable zone */\n\t\tbreak;\n\t}\n\n\tMemSet(nulls, 0, sizeof(nulls));\n\n\tvalues[0] = CStringGetTextDatum(pg_get_timezone_name(tz));\n\tvalues[1] = CStringGetTextDatum(tzn ? tzn : \"\");\n\n\tMemSet(&itm, 0, sizeof(struct pg_tm));\n\titm.tm_sec = -tzoff;\n\tresInterval = (Interval *) palloc(sizeof(Interval));\n\ttm2interval(&itm, 0, resInterval);\n\tvalues[2] = IntervalPGetDatum(resInterval);\n\n\tvalues[3] = BoolGetDatum(tm.tm_isdst > 0);\n\n\ttuple = heap_form_tuple(funcctx->tuple_desc, values, nulls);\n\tresult = HeapTupleGetDatum(tuple);\n\n\tSRF_RETURN_NEXT(funcctx, result);\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nDatum\npg_timezone_names(PG_FUNCTION_ARGS)\n{\n\tMemoryContext oldcontext;\n\tFuncCallContext *funcctx;\n\tpg_tzenum  *tzenum;\n\tpg_tz\t   *tz;\n\tDatum\t\tresult;\n\tHeapTuple\ttuple;\n\tDatum\t\tvalues[4];\n\tbool\t\tnulls[4];\n\tint\t\t\ttzoff;\n\tstruct pg_tm tm;\n\tfsec_t\t\tfsec;\n\tconst char *tzn;\n\tInterval   *resInterval;\n\tstruct pg_tm itm;\n\n\t/* stuff done only on the first call of the function */\n\tif (SRF_IS_FIRSTCALL())\n\t{\n\t\tTupleDesc\ttupdesc;\n\n\t\t/* create a function context for cross-call persistence */\n\t\tfuncctx = SRF_FIRSTCALL_INIT();\n\n\t\t/*\n\t\t * switch to memory context appropriate for multiple function calls\n\t\t */\n\t\toldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);\n\n\t\t/* initialize timezone scanning code */\n\t\ttzenum = pg_tzenumerate_start();\n\t\tfuncctx->user_fctx = (void *) tzenum;\n\n\t\t/*\n\t\t * build tupdesc for result tuples. This must match this function's\n\t\t * pg_proc entry!\n\t\t */\n\t\ttupdesc = CreateTemplateTupleDesc(4, false);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 1, \"name\",\n\t\t\t\t\t\t   TEXTOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 2, \"abbrev\",\n\t\t\t\t\t\t   TEXTOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 3, \"utc_offset\",\n\t\t\t\t\t\t   INTERVALOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 4, \"is_dst\",\n\t\t\t\t\t\t   BOOLOID, -1, 0);\n\n\t\tfuncctx->tuple_desc = BlessTupleDesc(tupdesc);\n\t\tMemoryContextSwitchTo(oldcontext);\n\t}\n\n\t/* stuff done on every call of the function */\n\tfuncctx = SRF_PERCALL_SETUP();\n\ttzenum = (pg_tzenum *) funcctx->user_fctx;\n\n\t/* search for another zone to display */\n\tfor (;;)\n\t{\n\t\toldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);\n\t\ttz = pg_tzenumerate_next(tzenum);\n\t\tMemoryContextSwitchTo(oldcontext);\n\n\t\tif (!tz)\n\t\t{\n\t\t\tpg_tzenumerate_end(tzenum);\n\t\t\tfuncctx->user_fctx = NULL;\n\t\t\tSRF_RETURN_DONE(funcctx);\n\t\t}\n\n\t\t/* Convert now() to local time in this zone */\n\t\tif (timestamp2tm(GetCurrentTransactionStartTimestamp(),\n\t\t\t\t\t\t &tzoff, &tm, &fsec, &tzn, tz) != 0)\n\t\t\tcontinue;\t\t\t/* ignore if conversion fails */\n\n\t\t/*\n\t\t * Ignore zic's rather silly \"Factory\" time zone.  The long string\n\t\t * about \"see zic manual page\" is used in tzdata versions before\n\t\t * 2016g; we can drop it someday when we're pretty sure no such data\n\t\t * exists in the wild on platforms using --with-system-tzdata.  In\n\t\t * 2016g and later, the time zone abbreviation \"-00\" is used for\n\t\t * \"Factory\" as well as some invalid cases, all of which we can\n\t\t * reasonably omit from the pg_timezone_names view.\n\t\t */\n\t\tif (tzn && (strcmp(tzn, \"-00\") == 0 ||\n\t\t\t\t\tstrcmp(tzn, \"Local time zone must be set--see zic manual page\") == 0))\n\t\t\tcontinue;\n\n\t\t/* Found a displayable zone */\n\t\tbreak;\n\t}\n\n\tMemSet(nulls, 0, sizeof(nulls));\n\n\tvalues[0] = CStringGetTextDatum(pg_get_timezone_name(tz));\n\tvalues[1] = CStringGetTextDatum(tzn ? tzn : \"\");\n\n\tMemSet(&itm, 0, sizeof(struct pg_tm));\n\titm.tm_sec = -tzoff;\n\tresInterval = (Interval *) palloc(sizeof(Interval));\n\ttm2interval(&itm, 0, resInterval);\n\tvalues[2] = IntervalPGetDatum(resInterval);\n\n\tvalues[3] = BoolGetDatum(tm.tm_isdst > 0);\n\n\ttuple = heap_form_tuple(funcctx->tuple_desc, values, nulls);\n\tresult = HeapTupleGetDatum(tuple);\n\n\tSRF_RETURN_NEXT(funcctx, result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!IsPostmasterEnvironment"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nstatic Latch LocalLatchData;\n\nvoid\nInitStandaloneProcess(const char *argv0)\n{\n\tAssert(!IsPostmasterEnvironment);\n\n\tMyProcPid = getpid();\t\t/* reset MyProcPid */\n\n\tMyStartTime = time(NULL);\t/* set our start time in case we call elog */\n\n\t/*\n\t * Initialize random() for the first time, like PostmasterMain() would.\n\t * In a regular IsUnderPostmaster backend, BackendRun() computes a\n\t * high-entropy seed before any user query.  Fewer distinct initial seeds\n\t * can occur here.\n\t */\n\tsrandom((unsigned int) (MyProcPid ^ MyStartTime));\n\n\t/* Initialize process-local latch support */\n\tInitializeLatchSupport();\n\tMyLatch = &LocalLatchData;\n\tInitLatch(MyLatch);\n\n\t/* Compute paths, no postmaster to inherit from */\n\tif (my_exec_path[0] == '\\0')\n\t{\n\t\tif (find_my_exec(argv0, my_exec_path) < 0)\n\t\t\telog(FATAL, \"%s: could not locate my own executable path\",\n\t\t\t\t argv0);\n\t}\n\n\tif (pkglib_path[0] == '\\0')\n\t\tget_pkglib_path(my_exec_path, pkglib_path);\n}"
  },
  {
    "function_name": "InitPostmasterChild",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
    "lines": "270-307",
    "snippet": "void\nInitPostmasterChild(void)\n{\n\tIsUnderPostmaster = true;\t/* we are a postmaster subprocess now */\n\n\tMyProcPid = getpid();\t\t/* reset MyProcPid */\n\n\tMyStartTime = time(NULL);\t/* set our start time in case we call elog */\n\n\t/*\n\t * make sure stderr is in binary mode before anything can possibly be\n\t * written to it, in case it's actually the syslogger pipe, so the pipe\n\t * chunking protocol isn't disturbed. Non-logpipe data gets translated on\n\t * redirection (e.g. via pg_ctl -l) anyway.\n\t */\n#ifdef WIN32\n\t_setmode(fileno(stderr), _O_BINARY);\n#endif\n\n\t/* We don't want the postmaster's proc_exit() handlers */\n\ton_exit_reset();\n\n\t/* Initialize process-local latch support */\n\tInitializeLatchSupport();\n\tMyLatch = &LocalLatchData;\n\tInitLatch(MyLatch);\n\n\t/*\n\t * If possible, make this process a group leader, so that the postmaster\n\t * can signal any child processes too. Not all processes will have\n\t * children, but for consistency we make all postmaster child processes do\n\t * this.\n\t */\n#ifdef HAVE_SETSID\n\tif (setsid() < 0)\n\t\telog(FATAL, \"setsid() failed: %m\");\n#endif\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pidfile.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/pg_shmem.h\"",
      "#include \"storage/latch.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/fd.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"postmaster/autovacuum.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"common/file_perm.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/htup_details.h\"",
      "#include <utime.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <sys/param.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Latch LocalLatchData;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "FATAL",
            "\"setsid() failed: %m\""
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setsid",
          "args": [],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InitLatch",
          "args": [
            "MyLatch"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InitializeLatchSupport",
          "args": [],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "on_exit_reset",
          "args": [],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_setmode",
          "args": [
            "fileno(stderr)",
            "_O_BINARY"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileno",
          "args": [
            "stderr"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "pg_filenode_relation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/dbsize.c",
          "lines": "919-932",
          "snippet": "Datum\npg_filenode_relation(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\treltablespace = PG_GETARG_OID(0);\n\tOid\t\t\trelfilenode = PG_GETARG_OID(1);\n\tOid\t\t\theaprel = InvalidOid;\n\n\theaprel = RelidByRelfilenode(reltablespace, relfilenode);\n\n\tif (!OidIsValid(heaprel))\n\t\tPG_RETURN_NULL();\n\telse\n\t\tPG_RETURN_OID(heaprel);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/relfilenodemap.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/fd.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/relfilenodemap.h\"\n#include \"utils/rel.h\"\n#include \"utils/numeric.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/fd.h\"\n#include \"miscadmin.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nDatum\npg_filenode_relation(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\treltablespace = PG_GETARG_OID(0);\n\tOid\t\t\trelfilenode = PG_GETARG_OID(1);\n\tOid\t\t\theaprel = InvalidOid;\n\n\theaprel = RelidByRelfilenode(reltablespace, relfilenode);\n\n\tif (!OidIsValid(heaprel))\n\t\tPG_RETURN_NULL();\n\telse\n\t\tPG_RETURN_OID(heaprel);\n}"
        }
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "pg_timezone_names",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "4766-4876",
          "snippet": "Datum\npg_timezone_names(PG_FUNCTION_ARGS)\n{\n\tMemoryContext oldcontext;\n\tFuncCallContext *funcctx;\n\tpg_tzenum  *tzenum;\n\tpg_tz\t   *tz;\n\tDatum\t\tresult;\n\tHeapTuple\ttuple;\n\tDatum\t\tvalues[4];\n\tbool\t\tnulls[4];\n\tint\t\t\ttzoff;\n\tstruct pg_tm tm;\n\tfsec_t\t\tfsec;\n\tconst char *tzn;\n\tInterval   *resInterval;\n\tstruct pg_tm itm;\n\n\t/* stuff done only on the first call of the function */\n\tif (SRF_IS_FIRSTCALL())\n\t{\n\t\tTupleDesc\ttupdesc;\n\n\t\t/* create a function context for cross-call persistence */\n\t\tfuncctx = SRF_FIRSTCALL_INIT();\n\n\t\t/*\n\t\t * switch to memory context appropriate for multiple function calls\n\t\t */\n\t\toldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);\n\n\t\t/* initialize timezone scanning code */\n\t\ttzenum = pg_tzenumerate_start();\n\t\tfuncctx->user_fctx = (void *) tzenum;\n\n\t\t/*\n\t\t * build tupdesc for result tuples. This must match this function's\n\t\t * pg_proc entry!\n\t\t */\n\t\ttupdesc = CreateTemplateTupleDesc(4, false);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 1, \"name\",\n\t\t\t\t\t\t   TEXTOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 2, \"abbrev\",\n\t\t\t\t\t\t   TEXTOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 3, \"utc_offset\",\n\t\t\t\t\t\t   INTERVALOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 4, \"is_dst\",\n\t\t\t\t\t\t   BOOLOID, -1, 0);\n\n\t\tfuncctx->tuple_desc = BlessTupleDesc(tupdesc);\n\t\tMemoryContextSwitchTo(oldcontext);\n\t}\n\n\t/* stuff done on every call of the function */\n\tfuncctx = SRF_PERCALL_SETUP();\n\ttzenum = (pg_tzenum *) funcctx->user_fctx;\n\n\t/* search for another zone to display */\n\tfor (;;)\n\t{\n\t\toldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);\n\t\ttz = pg_tzenumerate_next(tzenum);\n\t\tMemoryContextSwitchTo(oldcontext);\n\n\t\tif (!tz)\n\t\t{\n\t\t\tpg_tzenumerate_end(tzenum);\n\t\t\tfuncctx->user_fctx = NULL;\n\t\t\tSRF_RETURN_DONE(funcctx);\n\t\t}\n\n\t\t/* Convert now() to local time in this zone */\n\t\tif (timestamp2tm(GetCurrentTransactionStartTimestamp(),\n\t\t\t\t\t\t &tzoff, &tm, &fsec, &tzn, tz) != 0)\n\t\t\tcontinue;\t\t\t/* ignore if conversion fails */\n\n\t\t/*\n\t\t * Ignore zic's rather silly \"Factory\" time zone.  The long string\n\t\t * about \"see zic manual page\" is used in tzdata versions before\n\t\t * 2016g; we can drop it someday when we're pretty sure no such data\n\t\t * exists in the wild on platforms using --with-system-tzdata.  In\n\t\t * 2016g and later, the time zone abbreviation \"-00\" is used for\n\t\t * \"Factory\" as well as some invalid cases, all of which we can\n\t\t * reasonably omit from the pg_timezone_names view.\n\t\t */\n\t\tif (tzn && (strcmp(tzn, \"-00\") == 0 ||\n\t\t\t\t\tstrcmp(tzn, \"Local time zone must be set--see zic manual page\") == 0))\n\t\t\tcontinue;\n\n\t\t/* Found a displayable zone */\n\t\tbreak;\n\t}\n\n\tMemSet(nulls, 0, sizeof(nulls));\n\n\tvalues[0] = CStringGetTextDatum(pg_get_timezone_name(tz));\n\tvalues[1] = CStringGetTextDatum(tzn ? tzn : \"\");\n\n\tMemSet(&itm, 0, sizeof(struct pg_tm));\n\titm.tm_sec = -tzoff;\n\tresInterval = (Interval *) palloc(sizeof(Interval));\n\ttm2interval(&itm, 0, resInterval);\n\tvalues[2] = IntervalPGetDatum(resInterval);\n\n\tvalues[3] = BoolGetDatum(tm.tm_isdst > 0);\n\n\ttuple = heap_form_tuple(funcctx->tuple_desc, values, nulls);\n\tresult = HeapTupleGetDatum(tuple);\n\n\tSRF_RETURN_NEXT(funcctx, result);\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nDatum\npg_timezone_names(PG_FUNCTION_ARGS)\n{\n\tMemoryContext oldcontext;\n\tFuncCallContext *funcctx;\n\tpg_tzenum  *tzenum;\n\tpg_tz\t   *tz;\n\tDatum\t\tresult;\n\tHeapTuple\ttuple;\n\tDatum\t\tvalues[4];\n\tbool\t\tnulls[4];\n\tint\t\t\ttzoff;\n\tstruct pg_tm tm;\n\tfsec_t\t\tfsec;\n\tconst char *tzn;\n\tInterval   *resInterval;\n\tstruct pg_tm itm;\n\n\t/* stuff done only on the first call of the function */\n\tif (SRF_IS_FIRSTCALL())\n\t{\n\t\tTupleDesc\ttupdesc;\n\n\t\t/* create a function context for cross-call persistence */\n\t\tfuncctx = SRF_FIRSTCALL_INIT();\n\n\t\t/*\n\t\t * switch to memory context appropriate for multiple function calls\n\t\t */\n\t\toldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);\n\n\t\t/* initialize timezone scanning code */\n\t\ttzenum = pg_tzenumerate_start();\n\t\tfuncctx->user_fctx = (void *) tzenum;\n\n\t\t/*\n\t\t * build tupdesc for result tuples. This must match this function's\n\t\t * pg_proc entry!\n\t\t */\n\t\ttupdesc = CreateTemplateTupleDesc(4, false);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 1, \"name\",\n\t\t\t\t\t\t   TEXTOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 2, \"abbrev\",\n\t\t\t\t\t\t   TEXTOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 3, \"utc_offset\",\n\t\t\t\t\t\t   INTERVALOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 4, \"is_dst\",\n\t\t\t\t\t\t   BOOLOID, -1, 0);\n\n\t\tfuncctx->tuple_desc = BlessTupleDesc(tupdesc);\n\t\tMemoryContextSwitchTo(oldcontext);\n\t}\n\n\t/* stuff done on every call of the function */\n\tfuncctx = SRF_PERCALL_SETUP();\n\ttzenum = (pg_tzenum *) funcctx->user_fctx;\n\n\t/* search for another zone to display */\n\tfor (;;)\n\t{\n\t\toldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);\n\t\ttz = pg_tzenumerate_next(tzenum);\n\t\tMemoryContextSwitchTo(oldcontext);\n\n\t\tif (!tz)\n\t\t{\n\t\t\tpg_tzenumerate_end(tzenum);\n\t\t\tfuncctx->user_fctx = NULL;\n\t\t\tSRF_RETURN_DONE(funcctx);\n\t\t}\n\n\t\t/* Convert now() to local time in this zone */\n\t\tif (timestamp2tm(GetCurrentTransactionStartTimestamp(),\n\t\t\t\t\t\t &tzoff, &tm, &fsec, &tzn, tz) != 0)\n\t\t\tcontinue;\t\t\t/* ignore if conversion fails */\n\n\t\t/*\n\t\t * Ignore zic's rather silly \"Factory\" time zone.  The long string\n\t\t * about \"see zic manual page\" is used in tzdata versions before\n\t\t * 2016g; we can drop it someday when we're pretty sure no such data\n\t\t * exists in the wild on platforms using --with-system-tzdata.  In\n\t\t * 2016g and later, the time zone abbreviation \"-00\" is used for\n\t\t * \"Factory\" as well as some invalid cases, all of which we can\n\t\t * reasonably omit from the pg_timezone_names view.\n\t\t */\n\t\tif (tzn && (strcmp(tzn, \"-00\") == 0 ||\n\t\t\t\t\tstrcmp(tzn, \"Local time zone must be set--see zic manual page\") == 0))\n\t\t\tcontinue;\n\n\t\t/* Found a displayable zone */\n\t\tbreak;\n\t}\n\n\tMemSet(nulls, 0, sizeof(nulls));\n\n\tvalues[0] = CStringGetTextDatum(pg_get_timezone_name(tz));\n\tvalues[1] = CStringGetTextDatum(tzn ? tzn : \"\");\n\n\tMemSet(&itm, 0, sizeof(struct pg_tm));\n\titm.tm_sec = -tzoff;\n\tresInterval = (Interval *) palloc(sizeof(Interval));\n\ttm2interval(&itm, 0, resInterval);\n\tvalues[2] = IntervalPGetDatum(resInterval);\n\n\tvalues[3] = BoolGetDatum(tm.tm_isdst > 0);\n\n\ttuple = heap_form_tuple(funcctx->tuple_desc, values, nulls);\n\tresult = HeapTupleGetDatum(tuple);\n\n\tSRF_RETURN_NEXT(funcctx, result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nstatic Latch LocalLatchData;\n\nvoid\nInitPostmasterChild(void)\n{\n\tIsUnderPostmaster = true;\t/* we are a postmaster subprocess now */\n\n\tMyProcPid = getpid();\t\t/* reset MyProcPid */\n\n\tMyStartTime = time(NULL);\t/* set our start time in case we call elog */\n\n\t/*\n\t * make sure stderr is in binary mode before anything can possibly be\n\t * written to it, in case it's actually the syslogger pipe, so the pipe\n\t * chunking protocol isn't disturbed. Non-logpipe data gets translated on\n\t * redirection (e.g. via pg_ctl -l) anyway.\n\t */\n#ifdef WIN32\n\t_setmode(fileno(stderr), _O_BINARY);\n#endif\n\n\t/* We don't want the postmaster's proc_exit() handlers */\n\ton_exit_reset();\n\n\t/* Initialize process-local latch support */\n\tInitializeLatchSupport();\n\tMyLatch = &LocalLatchData;\n\tInitLatch(MyLatch);\n\n\t/*\n\t * If possible, make this process a group leader, so that the postmaster\n\t * can signal any child processes too. Not all processes will have\n\t * children, but for consistency we make all postmaster child processes do\n\t * this.\n\t */\n#ifdef HAVE_SETSID\n\tif (setsid() < 0)\n\t\telog(FATAL, \"setsid() failed: %m\");\n#endif\n}"
  },
  {
    "function_name": "ChangeToDataDir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
    "lines": "210-220",
    "snippet": "void\nChangeToDataDir(void)\n{\n\tAssertState(DataDir);\n\n\tif (chdir(DataDir) < 0)\n\t\tereport(FATAL,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not change directory to \\\"%s\\\": %m\",\n\t\t\t\t\t\tDataDir)));\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pidfile.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/pg_shmem.h\"",
      "#include \"storage/latch.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/fd.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"postmaster/autovacuum.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"common/file_perm.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/htup_details.h\"",
      "#include <utime.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <sys/param.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "FATAL",
            "(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not change directory to \\\"%s\\\": %m\",\n\t\t\t\t\t\tDataDir))"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not change directory to \\\"%s\\\": %m\"",
            "DataDir"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode_for_file_access",
          "args": [],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "errcode_for_file_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "595-655",
          "snippet": "int\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "chdir",
          "args": [
            "DataDir"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AssertState",
          "args": [
            "DataDir"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nvoid\nChangeToDataDir(void)\n{\n\tAssertState(DataDir);\n\n\tif (chdir(DataDir) < 0)\n\t\tereport(FATAL,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not change directory to \\\"%s\\\": %m\",\n\t\t\t\t\t\tDataDir)));\n}"
  },
  {
    "function_name": "SetDataDir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
    "lines": "189-202",
    "snippet": "void\nSetDataDir(const char *dir)\n{\n\tchar\t   *new;\n\n\tAssertArg(dir);\n\n\t/* If presented path is relative, convert to absolute */\n\tnew = make_absolute_path(dir);\n\n\tif (DataDir)\n\t\tfree(DataDir);\n\tDataDir = new;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pidfile.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/pg_shmem.h\"",
      "#include \"storage/latch.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/fd.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"postmaster/autovacuum.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"common/file_perm.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/htup_details.h\"",
      "#include <utime.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <sys/param.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "DataDir"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "free_attstatsslot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "3052-3064",
          "snippet": "void\nfree_attstatsslot(AttStatsSlot *sslot)\n{\n\t/* The values[] array was separately palloc'd by deconstruct_array */\n\tif (sslot->values)\n\t\tpfree(sslot->values);\n\t/* The numbers[] array points into numbers_arr, do not pfree it */\n\t/* Free the detoasted array objects, if any */\n\tif (sslot->values_arr)\n\t\tpfree(sslot->values_arr);\n\tif (sslot->numbers_arr)\n\t\tpfree(sslot->numbers_arr);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nfree_attstatsslot(AttStatsSlot *sslot)\n{\n\t/* The values[] array was separately palloc'd by deconstruct_array */\n\tif (sslot->values)\n\t\tpfree(sslot->values);\n\t/* The numbers[] array points into numbers_arr, do not pfree it */\n\t/* Free the detoasted array objects, if any */\n\tif (sslot->values_arr)\n\t\tpfree(sslot->values_arr);\n\tif (sslot->numbers_arr)\n\t\tpfree(sslot->numbers_arr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_absolute_path",
          "args": [
            "dir"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AssertArg",
          "args": [
            "dir"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nvoid\nSetDataDir(const char *dir)\n{\n\tchar\t   *new;\n\n\tAssertArg(dir);\n\n\t/* If presented path is relative, convert to absolute */\n\tnew = make_absolute_path(dir);\n\n\tif (DataDir)\n\t\tfree(DataDir);\n\tDataDir = new;\n}"
  },
  {
    "function_name": "checkDataDir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
    "lines": "96-183",
    "snippet": "void\ncheckDataDir(void)\n{\n\tstruct stat stat_buf;\n\n\tAssert(DataDir);\n\n\tif (stat(DataDir, &stat_buf) != 0)\n\t{\n\t\tif (errno == ENOENT)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"data directory \\\"%s\\\" does not exist\",\n\t\t\t\t\t\t\tDataDir)));\n\t\telse\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not read permissions of directory \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tDataDir)));\n\t}\n\n\t/* eventual chdir would fail anyway, but let's test ... */\n\tif (!S_ISDIR(stat_buf.st_mode))\n\t\tereport(FATAL,\n\t\t\t\t(errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\n\t\t\t\t errmsg(\"specified data directory \\\"%s\\\" is not a directory\",\n\t\t\t\t\t\tDataDir)));\n\n\t/*\n\t * Check that the directory belongs to my userid; if not, reject.\n\t *\n\t * This check is an essential part of the interlock that prevents two\n\t * postmasters from starting in the same directory (see CreateLockFile()).\n\t * Do not remove or weaken it.\n\t *\n\t * XXX can we safely enable this check on Windows?\n\t */\n#if !defined(WIN32) && !defined(__CYGWIN__)\n\tif (stat_buf.st_uid != geteuid())\n\t\tereport(FATAL,\n\t\t\t\t(errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\n\t\t\t\t errmsg(\"data directory \\\"%s\\\" has wrong ownership\",\n\t\t\t\t\t\tDataDir),\n\t\t\t\t errhint(\"The server must be started by the user that owns the data directory.\")));\n#endif\n\n\t/*\n\t * Check if the directory has correct permissions.  If not, reject.\n\t *\n\t * Only two possible modes are allowed, 0700 and 0750.  The latter mode\n\t * indicates that group read/execute should be allowed on all newly\n\t * created files and directories.\n\t *\n\t * XXX temporarily suppress check when on Windows, because there may not\n\t * be proper support for Unix-y file permissions.  Need to think of a\n\t * reasonable check to apply on Windows.\n\t */\n#if !defined(WIN32) && !defined(__CYGWIN__)\n\tif (stat_buf.st_mode & PG_MODE_MASK_GROUP)\n\t\tereport(FATAL,\n\t\t\t\t(errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\n\t\t\t\t errmsg(\"data directory \\\"%s\\\" has invalid permissions\",\n\t\t\t\t\t\tDataDir),\n\t\t\t\t errdetail(\"Permissions should be u=rwx (0700) or u=rwx,g=rx (0750).\")));\n#endif\n\n\t/*\n\t * Reset creation modes and mask based on the mode of the data directory.\n\t *\n\t * The mask was set earlier in startup to disallow group permissions on\n\t * newly created files and directories.  However, if group read/execute\n\t * are present on the data directory then modify the create modes and mask\n\t * to allow group read/execute on newly created files and directories and\n\t * set the data_directory_mode GUC.\n\t *\n\t * Suppress when on Windows, because there may not be proper support for\n\t * Unix-y file permissions.\n\t */\n#if !defined(WIN32) && !defined(__CYGWIN__)\n\tSetDataDirectoryCreatePerm(stat_buf.st_mode);\n\n\tumask(pg_mode_mask);\n\tdata_directory_mode = pg_dir_create_mode;\n#endif\n\n\t/* Check for PG_VERSION */\n\tValidatePgVersion(DataDir);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pidfile.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/pg_shmem.h\"",
      "#include \"storage/latch.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/fd.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"postmaster/autovacuum.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"common/file_perm.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/htup_details.h\"",
      "#include <utime.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <sys/param.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ValidatePgVersion",
          "args": [
            "DataDir"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "ValidatePgVersion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
          "lines": "1453-1506",
          "snippet": "void\nValidatePgVersion(const char *path)\n{\n\tchar\t\tfull_path[MAXPGPATH];\n\tFILE\t   *file;\n\tint\t\t\tret;\n\tlong\t\tfile_major;\n\tlong\t\tmy_major;\n\tchar\t   *endptr;\n\tchar\t\tfile_version_string[64];\n\tconst char *my_version_string = PG_VERSION;\n\n\tmy_major = strtol(my_version_string, &endptr, 10);\n\n\tsnprintf(full_path, sizeof(full_path), \"%s/PG_VERSION\", path);\n\n\tfile = AllocateFile(full_path, \"r\");\n\tif (!file)\n\t{\n\t\tif (errno == ENOENT)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"\\\"%s\\\" is not a valid data directory\",\n\t\t\t\t\t\t\tpath),\n\t\t\t\t\t errdetail(\"File \\\"%s\\\" is missing.\", full_path)));\n\t\telse\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not open file \\\"%s\\\": %m\", full_path)));\n\t}\n\n\tfile_version_string[0] = '\\0';\n\tret = fscanf(file, \"%63s\", file_version_string);\n\tfile_major = strtol(file_version_string, &endptr, 10);\n\n\tif (ret != 1 || endptr == file_version_string)\n\t\tereport(FATAL,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"\\\"%s\\\" is not a valid data directory\",\n\t\t\t\t\t\tpath),\n\t\t\t\t errdetail(\"File \\\"%s\\\" does not contain valid data.\",\n\t\t\t\t\t\t   full_path),\n\t\t\t\t errhint(\"You might need to initdb.\")));\n\n\tFreeFile(file);\n\n\tif (my_major != file_major)\n\t\tereport(FATAL,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"database files are incompatible with server\"),\n\t\t\t\t errdetail(\"The data directory was initialized by PostgreSQL version %s, \"\n\t\t\t\t\t\t   \"which is not compatible with this version %s.\",\n\t\t\t\t\t\t   file_version_string, my_version_string)));\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pidfile.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pg_shmem.h\"",
            "#include \"storage/latch.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/fd.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"common/file_perm.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/htup_details.h\"",
            "#include <utime.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/param.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nvoid\nValidatePgVersion(const char *path)\n{\n\tchar\t\tfull_path[MAXPGPATH];\n\tFILE\t   *file;\n\tint\t\t\tret;\n\tlong\t\tfile_major;\n\tlong\t\tmy_major;\n\tchar\t   *endptr;\n\tchar\t\tfile_version_string[64];\n\tconst char *my_version_string = PG_VERSION;\n\n\tmy_major = strtol(my_version_string, &endptr, 10);\n\n\tsnprintf(full_path, sizeof(full_path), \"%s/PG_VERSION\", path);\n\n\tfile = AllocateFile(full_path, \"r\");\n\tif (!file)\n\t{\n\t\tif (errno == ENOENT)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"\\\"%s\\\" is not a valid data directory\",\n\t\t\t\t\t\t\tpath),\n\t\t\t\t\t errdetail(\"File \\\"%s\\\" is missing.\", full_path)));\n\t\telse\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not open file \\\"%s\\\": %m\", full_path)));\n\t}\n\n\tfile_version_string[0] = '\\0';\n\tret = fscanf(file, \"%63s\", file_version_string);\n\tfile_major = strtol(file_version_string, &endptr, 10);\n\n\tif (ret != 1 || endptr == file_version_string)\n\t\tereport(FATAL,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"\\\"%s\\\" is not a valid data directory\",\n\t\t\t\t\t\tpath),\n\t\t\t\t errdetail(\"File \\\"%s\\\" does not contain valid data.\",\n\t\t\t\t\t\t   full_path),\n\t\t\t\t errhint(\"You might need to initdb.\")));\n\n\tFreeFile(file);\n\n\tif (my_major != file_major)\n\t\tereport(FATAL,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"database files are incompatible with server\"),\n\t\t\t\t errdetail(\"The data directory was initialized by PostgreSQL version %s, \"\n\t\t\t\t\t\t   \"which is not compatible with this version %s.\",\n\t\t\t\t\t\t   file_version_string, my_version_string)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "umask",
          "args": [
            "pg_mode_mask"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetDataDirectoryCreatePerm",
          "args": [
            "stat_buf.st_mode"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "FATAL",
            "(errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\n\t\t\t\t errmsg(\"data directory \\\"%s\\\" has invalid permissions\",\n\t\t\t\t\t\tDataDir),\n\t\t\t\t errdetail(\"Permissions should be u=rwx (0700) or u=rwx,g=rx (0750).\"))"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errdetail",
          "args": [
            "\"Permissions should be u=rwx (0700) or u=rwx,g=rx (0750).\""
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "errdetail_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "918-933",
          "snippet": "int\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"data directory \\\"%s\\\" has invalid permissions\"",
            "DataDir"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "FATAL",
            "(errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\n\t\t\t\t errmsg(\"data directory \\\"%s\\\" has wrong ownership\",\n\t\t\t\t\t\tDataDir),\n\t\t\t\t errhint(\"The server must be started by the user that owns the data directory.\"))"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errhint",
          "args": [
            "\"The server must be started by the user that owns the data directory.\""
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "errhint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "984-999",
          "snippet": "int\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "FATAL",
            "(errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\n\t\t\t\t errmsg(\"specified data directory \\\"%s\\\" is not a directory\",\n\t\t\t\t\t\tDataDir))"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "stat_buf.st_mode"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "FATAL",
            "(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not read permissions of directory \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tDataDir))"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errcode_for_file_access",
          "args": [],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "errcode_for_file_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "595-655",
          "snippet": "int\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "FATAL",
            "(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"data directory \\\"%s\\\" does not exist\",\n\t\t\t\t\t\t\tDataDir))"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "DataDir",
            "&stat_buf"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "set_deparse_planstate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ruleutils.c",
          "lines": "4578-4639",
          "snippet": "static void\nset_deparse_planstate(deparse_namespace *dpns, PlanState *ps)\n{\n\tdpns->planstate = ps;\n\n\t/*\n\t * We special-case Append and MergeAppend to pretend that the first child\n\t * plan is the OUTER referent; we have to interpret OUTER Vars in their\n\t * tlists according to one of the children, and the first one is the most\n\t * natural choice.  Likewise special-case ModifyTable to pretend that the\n\t * first child plan is the OUTER referent; this is to support RETURNING\n\t * lists containing references to non-target relations.\n\t */\n\tif (IsA(ps, AppendState))\n\t\tdpns->outer_planstate = ((AppendState *) ps)->appendplans[0];\n\telse if (IsA(ps, MergeAppendState))\n\t\tdpns->outer_planstate = ((MergeAppendState *) ps)->mergeplans[0];\n\telse if (IsA(ps, ModifyTableState))\n\t\tdpns->outer_planstate = ((ModifyTableState *) ps)->mt_plans[0];\n\telse\n\t\tdpns->outer_planstate = outerPlanState(ps);\n\n\tif (dpns->outer_planstate)\n\t\tdpns->outer_tlist = dpns->outer_planstate->plan->targetlist;\n\telse\n\t\tdpns->outer_tlist = NIL;\n\n\t/*\n\t * For a SubqueryScan, pretend the subplan is INNER referent.  (We don't\n\t * use OUTER because that could someday conflict with the normal meaning.)\n\t * Likewise, for a CteScan, pretend the subquery's plan is INNER referent.\n\t * For ON CONFLICT .. UPDATE we just need the inner tlist to point to the\n\t * excluded expression's tlist. (Similar to the SubqueryScan we don't want\n\t * to reuse OUTER, it's used for RETURNING in some modify table cases,\n\t * although not INSERT .. CONFLICT).\n\t */\n\tif (IsA(ps, SubqueryScanState))\n\t\tdpns->inner_planstate = ((SubqueryScanState *) ps)->subplan;\n\telse if (IsA(ps, CteScanState))\n\t\tdpns->inner_planstate = ((CteScanState *) ps)->cteplanstate;\n\telse if (IsA(ps, ModifyTableState))\n\t\tdpns->inner_planstate = ps;\n\telse\n\t\tdpns->inner_planstate = innerPlanState(ps);\n\n\tif (IsA(ps, ModifyTableState))\n\t\tdpns->inner_tlist = ((ModifyTableState *) ps)->mt_excludedtlist;\n\telse if (dpns->inner_planstate)\n\t\tdpns->inner_tlist = dpns->inner_planstate->plan->targetlist;\n\telse\n\t\tdpns->inner_tlist = NIL;\n\n\t/* Set up referent for INDEX_VAR Vars, if needed */\n\tif (IsA(ps->plan, IndexOnlyScan))\n\t\tdpns->index_tlist = ((IndexOnlyScan *) ps->plan)->indextlist;\n\telse if (IsA(ps->plan, ForeignScan))\n\t\tdpns->index_tlist = ((ForeignScan *) ps->plan)->fdw_scan_tlist;\n\telse if (IsA(ps->plan, CustomScan))\n\t\tdpns->index_tlist = ((CustomScan *) ps->plan)->custom_scan_tlist;\n\telse\n\t\tdpns->index_tlist = NIL;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/ruleutils.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"rewrite/rewriteSupport.h\"",
            "#include \"rewrite/rewriteManip.h\"",
            "#include \"rewrite/rewriteHandler.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parser.h\"",
            "#include \"parser/parse_oper.h\"",
            "#include \"parser/parse_func.h\"",
            "#include \"parser/parse_agg.h\"",
            "#include \"parser/parse_node.h\"",
            "#include \"optimizer/tlist.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"common/keywords.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/dependency.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/amapi.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_simple_column_names(deparse_namespace *dpns);",
            "static void set_deparse_planstate(deparse_namespace *dpns, PlanState *ps);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/ruleutils.h\"\n#include \"utils/rel.h\"\n#include \"utils/partcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"rewrite/rewriteSupport.h\"\n#include \"rewrite/rewriteManip.h\"\n#include \"rewrite/rewriteHandler.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parser.h\"\n#include \"parser/parse_oper.h\"\n#include \"parser/parse_func.h\"\n#include \"parser/parse_agg.h\"\n#include \"parser/parse_node.h\"\n#include \"optimizer/tlist.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"common/keywords.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/dependency.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/amapi.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void set_simple_column_names(deparse_namespace *dpns);\nstatic void set_deparse_planstate(deparse_namespace *dpns, PlanState *ps);\n\nstatic void\nset_deparse_planstate(deparse_namespace *dpns, PlanState *ps)\n{\n\tdpns->planstate = ps;\n\n\t/*\n\t * We special-case Append and MergeAppend to pretend that the first child\n\t * plan is the OUTER referent; we have to interpret OUTER Vars in their\n\t * tlists according to one of the children, and the first one is the most\n\t * natural choice.  Likewise special-case ModifyTable to pretend that the\n\t * first child plan is the OUTER referent; this is to support RETURNING\n\t * lists containing references to non-target relations.\n\t */\n\tif (IsA(ps, AppendState))\n\t\tdpns->outer_planstate = ((AppendState *) ps)->appendplans[0];\n\telse if (IsA(ps, MergeAppendState))\n\t\tdpns->outer_planstate = ((MergeAppendState *) ps)->mergeplans[0];\n\telse if (IsA(ps, ModifyTableState))\n\t\tdpns->outer_planstate = ((ModifyTableState *) ps)->mt_plans[0];\n\telse\n\t\tdpns->outer_planstate = outerPlanState(ps);\n\n\tif (dpns->outer_planstate)\n\t\tdpns->outer_tlist = dpns->outer_planstate->plan->targetlist;\n\telse\n\t\tdpns->outer_tlist = NIL;\n\n\t/*\n\t * For a SubqueryScan, pretend the subplan is INNER referent.  (We don't\n\t * use OUTER because that could someday conflict with the normal meaning.)\n\t * Likewise, for a CteScan, pretend the subquery's plan is INNER referent.\n\t * For ON CONFLICT .. UPDATE we just need the inner tlist to point to the\n\t * excluded expression's tlist. (Similar to the SubqueryScan we don't want\n\t * to reuse OUTER, it's used for RETURNING in some modify table cases,\n\t * although not INSERT .. CONFLICT).\n\t */\n\tif (IsA(ps, SubqueryScanState))\n\t\tdpns->inner_planstate = ((SubqueryScanState *) ps)->subplan;\n\telse if (IsA(ps, CteScanState))\n\t\tdpns->inner_planstate = ((CteScanState *) ps)->cteplanstate;\n\telse if (IsA(ps, ModifyTableState))\n\t\tdpns->inner_planstate = ps;\n\telse\n\t\tdpns->inner_planstate = innerPlanState(ps);\n\n\tif (IsA(ps, ModifyTableState))\n\t\tdpns->inner_tlist = ((ModifyTableState *) ps)->mt_excludedtlist;\n\telse if (dpns->inner_planstate)\n\t\tdpns->inner_tlist = dpns->inner_planstate->plan->targetlist;\n\telse\n\t\tdpns->inner_tlist = NIL;\n\n\t/* Set up referent for INDEX_VAR Vars, if needed */\n\tif (IsA(ps->plan, IndexOnlyScan))\n\t\tdpns->index_tlist = ((IndexOnlyScan *) ps->plan)->indextlist;\n\telse if (IsA(ps->plan, ForeignScan))\n\t\tdpns->index_tlist = ((ForeignScan *) ps->plan)->fdw_scan_tlist;\n\telse if (IsA(ps->plan, CustomScan))\n\t\tdpns->index_tlist = ((CustomScan *) ps->plan)->custom_scan_tlist;\n\telse\n\t\tdpns->index_tlist = NIL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "DataDir"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nvoid\ncheckDataDir(void)\n{\n\tstruct stat stat_buf;\n\n\tAssert(DataDir);\n\n\tif (stat(DataDir, &stat_buf) != 0)\n\t{\n\t\tif (errno == ENOENT)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"data directory \\\"%s\\\" does not exist\",\n\t\t\t\t\t\t\tDataDir)));\n\t\telse\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not read permissions of directory \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tDataDir)));\n\t}\n\n\t/* eventual chdir would fail anyway, but let's test ... */\n\tif (!S_ISDIR(stat_buf.st_mode))\n\t\tereport(FATAL,\n\t\t\t\t(errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\n\t\t\t\t errmsg(\"specified data directory \\\"%s\\\" is not a directory\",\n\t\t\t\t\t\tDataDir)));\n\n\t/*\n\t * Check that the directory belongs to my userid; if not, reject.\n\t *\n\t * This check is an essential part of the interlock that prevents two\n\t * postmasters from starting in the same directory (see CreateLockFile()).\n\t * Do not remove or weaken it.\n\t *\n\t * XXX can we safely enable this check on Windows?\n\t */\n#if !defined(WIN32) && !defined(__CYGWIN__)\n\tif (stat_buf.st_uid != geteuid())\n\t\tereport(FATAL,\n\t\t\t\t(errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\n\t\t\t\t errmsg(\"data directory \\\"%s\\\" has wrong ownership\",\n\t\t\t\t\t\tDataDir),\n\t\t\t\t errhint(\"The server must be started by the user that owns the data directory.\")));\n#endif\n\n\t/*\n\t * Check if the directory has correct permissions.  If not, reject.\n\t *\n\t * Only two possible modes are allowed, 0700 and 0750.  The latter mode\n\t * indicates that group read/execute should be allowed on all newly\n\t * created files and directories.\n\t *\n\t * XXX temporarily suppress check when on Windows, because there may not\n\t * be proper support for Unix-y file permissions.  Need to think of a\n\t * reasonable check to apply on Windows.\n\t */\n#if !defined(WIN32) && !defined(__CYGWIN__)\n\tif (stat_buf.st_mode & PG_MODE_MASK_GROUP)\n\t\tereport(FATAL,\n\t\t\t\t(errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\n\t\t\t\t errmsg(\"data directory \\\"%s\\\" has invalid permissions\",\n\t\t\t\t\t\tDataDir),\n\t\t\t\t errdetail(\"Permissions should be u=rwx (0700) or u=rwx,g=rx (0750).\")));\n#endif\n\n\t/*\n\t * Reset creation modes and mask based on the mode of the data directory.\n\t *\n\t * The mask was set earlier in startup to disallow group permissions on\n\t * newly created files and directories.  However, if group read/execute\n\t * are present on the data directory then modify the create modes and mask\n\t * to allow group read/execute on newly created files and directories and\n\t * set the data_directory_mode GUC.\n\t *\n\t * Suppress when on Windows, because there may not be proper support for\n\t * Unix-y file permissions.\n\t */\n#if !defined(WIN32) && !defined(__CYGWIN__)\n\tSetDataDirectoryCreatePerm(stat_buf.st_mode);\n\n\tumask(pg_mode_mask);\n\tdata_directory_mode = pg_dir_create_mode;\n#endif\n\n\t/* Check for PG_VERSION */\n\tValidatePgVersion(DataDir);\n}"
  },
  {
    "function_name": "SetDatabasePath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
    "lines": "83-89",
    "snippet": "void\nSetDatabasePath(const char *path)\n{\n\t/* This should happen only once per process */\n\tAssert(!DatabasePath);\n\tDatabasePath = MemoryContextStrdup(TopMemoryContext, path);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/pidfile.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/pg_shmem.h\"",
      "#include \"storage/latch.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"storage/fd.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"postmaster/autovacuum.h\"",
      "#include \"pgstat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"common/file_perm.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/htup_details.h\"",
      "#include <utime.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <pwd.h>",
      "#include <grp.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <sys/param.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextStrdup",
          "args": [
            "TopMemoryContext",
            "path"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextStrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1147-1158",
          "snippet": "char *\nMemoryContextStrdup(MemoryContext context, const char *string)\n{\n\tchar\t   *nstr;\n\tSize\t\tlen = strlen(string) + 1;\n\n\tnstr = (char *) MemoryContextAlloc(context, len);\n\n\tmemcpy(nstr, string, len);\n\n\treturn nstr;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nchar *\nMemoryContextStrdup(MemoryContext context, const char *string)\n{\n\tchar\t   *nstr;\n\tSize\t\tlen = strlen(string) + 1;\n\n\tnstr = (char *) MemoryContextAlloc(context, len);\n\n\tmemcpy(nstr, string, len);\n\n\treturn nstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!DatabasePath"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nvoid\nSetDatabasePath(const char *path)\n{\n\t/* This should happen only once per process */\n\tAssert(!DatabasePath);\n\tDatabasePath = MemoryContextStrdup(TopMemoryContext, path);\n}"
  }
]