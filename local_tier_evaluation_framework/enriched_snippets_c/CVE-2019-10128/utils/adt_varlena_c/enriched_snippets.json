[
  {
    "function_name": "rest_of_char_same",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "5601-5611",
    "snippet": "static inline bool\nrest_of_char_same(const char *s1, const char *s2, int len)\n{\n\twhile (len > 0)\n\t{\n\t\tlen--;\n\t\tif (s1[len] != s2[len])\n\t\t\treturn false;\n\t}\n\treturn true;\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic inline bool\nrest_of_char_same(const char *s1, const char *s2, int len)\n{\n\twhile (len > 0)\n\t{\n\t\tlen--;\n\t\tif (s1[len] != s2[len])\n\t\t\treturn false;\n\t}\n\treturn true;\n}"
  },
  {
    "function_name": "text_format_nv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "5591-5595",
    "snippet": "Datum\ntext_format_nv(PG_FUNCTION_ARGS)\n{\n\treturn text_format(fcinfo);\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);",
      "static StringInfo makeStringAggState(FunctionCallInfo fcinfo);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "text_format",
          "args": [
            "fcinfo"
          ],
          "line": 5594
        },
        "resolved": true,
        "details": {
          "function_name": "text_format_nv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "5591-5595",
          "snippet": "Datum\ntext_format_nv(PG_FUNCTION_ARGS)\n{\n\treturn text_format(fcinfo);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\nstatic StringInfo makeStringAggState(FunctionCallInfo fcinfo);\n\nDatum\ntext_format_nv(PG_FUNCTION_ARGS)\n{\n\treturn text_format(fcinfo);\n}"
  },
  {
    "function_name": "text_format_append_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "5539-5582",
    "snippet": "static void\ntext_format_append_string(StringInfo buf, const char *str,\n\t\t\t\t\t\t  int flags, int width)\n{\n\tbool\t\talign_to_left = false;\n\tint\t\t\tlen;\n\n\t/* fast path for typical easy case */\n\tif (width == 0)\n\t{\n\t\tappendStringInfoString(buf, str);\n\t\treturn;\n\t}\n\n\tif (width < 0)\n\t{\n\t\t/* Negative width: implicit '-' flag, then take absolute value */\n\t\talign_to_left = true;\n\t\t/* -INT_MIN is undefined */\n\t\tif (width <= INT_MIN)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"number is out of range\")));\n\t\twidth = -width;\n\t}\n\telse if (flags & TEXT_FORMAT_FLAG_MINUS)\n\t\talign_to_left = true;\n\n\tlen = pg_mbstrlen(str);\n\tif (align_to_left)\n\t{\n\t\t/* left justify */\n\t\tappendStringInfoString(buf, str);\n\t\tif (len < width)\n\t\t\tappendStringInfoSpaces(buf, width - len);\n\t}\n\telse\n\t{\n\t\t/* right justify */\n\t\tif (len < width)\n\t\t\tappendStringInfoSpaces(buf, width - len);\n\t\tappendStringInfoString(buf, str);\n\t}\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define TEXT_FORMAT_FLAG_MINUS\t0x0001\t/* is minus flag present? */"
    ],
    "globals_used": [
      "static int32 text_length(Datum str);",
      "static bool text_format_parse_digits(const char **ptr, const char *end_ptr,\n\t\t\t\t\t\t int *value);",
      "static const char *text_format_parse_format(const char *start_ptr,\n\t\t\t\t\t\t const char *end_ptr,\n\t\t\t\t\t\t int *argpos, int *widthpos,\n\t\t\t\t\t\t int *flags, int *width);",
      "static void text_format_string_conversion(StringInfo buf, char conversion,\n\t\t\t\t\t\t\t  FmgrInfo *typOutputInfo,\n\t\t\t\t\t\t\t  Datum value, bool isNull,\n\t\t\t\t\t\t\t  int flags, int width);",
      "static void text_format_append_string(StringInfo buf, const char *str,\n\t\t\t\t\t\t  int flags, int width);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "buf",
            "str"
          ],
          "line": 5580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoSpaces",
          "args": [
            "buf",
            "width - len"
          ],
          "line": 5579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoSpaces",
          "args": [
            "buf",
            "width - len"
          ],
          "line": 5573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "buf",
            "str"
          ],
          "line": 5571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_mbstrlen",
          "args": [
            "str"
          ],
          "line": 5567
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mbstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "773-788",
          "snippet": "int\npg_mbstrlen(const char *mbstr)\n{\n\tint\t\t\tlen = 0;\n\n\t/* optimization for single byte encoding */\n\tif (pg_database_encoding_max_length() == 1)\n\t\treturn strlen(mbstr);\n\n\twhile (*mbstr)\n\t{\n\t\tmbstr += pg_mblen(mbstr);\n\t\tlen++;\n\t}\n\treturn len;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nint\npg_mbstrlen(const char *mbstr)\n{\n\tint\t\t\tlen = 0;\n\n\t/* optimization for single byte encoding */\n\tif (pg_database_encoding_max_length() == 1)\n\t\treturn strlen(mbstr);\n\n\twhile (*mbstr)\n\t{\n\t\tmbstr += pg_mblen(mbstr);\n\t\tlen++;\n\t}\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"number is out of range\"))"
          ],
          "line": 5559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"number is out of range\""
          ],
          "line": 5561
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE"
          ],
          "line": 5560
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "buf",
            "str"
          ],
          "line": 5549
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define TEXT_FORMAT_FLAG_MINUS\t0x0001\t/* is minus flag present? */\n\nstatic int32 text_length(Datum str);\nstatic bool text_format_parse_digits(const char **ptr, const char *end_ptr,\n\t\t\t\t\t\t int *value);\nstatic const char *text_format_parse_format(const char *start_ptr,\n\t\t\t\t\t\t const char *end_ptr,\n\t\t\t\t\t\t int *argpos, int *widthpos,\n\t\t\t\t\t\t int *flags, int *width);\nstatic void text_format_string_conversion(StringInfo buf, char conversion,\n\t\t\t\t\t\t\t  FmgrInfo *typOutputInfo,\n\t\t\t\t\t\t\t  Datum value, bool isNull,\n\t\t\t\t\t\t\t  int flags, int width);\nstatic void text_format_append_string(StringInfo buf, const char *str,\n\t\t\t\t\t\t  int flags, int width);\n\nstatic void\ntext_format_append_string(StringInfo buf, const char *str,\n\t\t\t\t\t\t  int flags, int width)\n{\n\tbool\t\talign_to_left = false;\n\tint\t\t\tlen;\n\n\t/* fast path for typical easy case */\n\tif (width == 0)\n\t{\n\t\tappendStringInfoString(buf, str);\n\t\treturn;\n\t}\n\n\tif (width < 0)\n\t{\n\t\t/* Negative width: implicit '-' flag, then take absolute value */\n\t\talign_to_left = true;\n\t\t/* -INT_MIN is undefined */\n\t\tif (width <= INT_MIN)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"number is out of range\")));\n\t\twidth = -width;\n\t}\n\telse if (flags & TEXT_FORMAT_FLAG_MINUS)\n\t\talign_to_left = true;\n\n\tlen = pg_mbstrlen(str);\n\tif (align_to_left)\n\t{\n\t\t/* left justify */\n\t\tappendStringInfoString(buf, str);\n\t\tif (len < width)\n\t\t\tappendStringInfoSpaces(buf, width - len);\n\t}\n\telse\n\t{\n\t\t/* right justify */\n\t\tif (len < width)\n\t\t\tappendStringInfoSpaces(buf, width - len);\n\t\tappendStringInfoString(buf, str);\n\t}\n}"
  },
  {
    "function_name": "text_format_string_conversion",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "5490-5534",
    "snippet": "static void\ntext_format_string_conversion(StringInfo buf, char conversion,\n\t\t\t\t\t\t\t  FmgrInfo *typOutputInfo,\n\t\t\t\t\t\t\t  Datum value, bool isNull,\n\t\t\t\t\t\t\t  int flags, int width)\n{\n\tchar\t   *str;\n\n\t/* Handle NULL arguments before trying to stringify the value. */\n\tif (isNull)\n\t{\n\t\tif (conversion == 's')\n\t\t\ttext_format_append_string(buf, \"\", flags, width);\n\t\telse if (conversion == 'L')\n\t\t\ttext_format_append_string(buf, \"NULL\", flags, width);\n\t\telse if (conversion == 'I')\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"null values cannot be formatted as an SQL identifier\")));\n\t\treturn;\n\t}\n\n\t/* Stringify. */\n\tstr = OutputFunctionCall(typOutputInfo, value);\n\n\t/* Escape. */\n\tif (conversion == 'I')\n\t{\n\t\t/* quote_identifier may or may not allocate a new string. */\n\t\ttext_format_append_string(buf, quote_identifier(str), flags, width);\n\t}\n\telse if (conversion == 'L')\n\t{\n\t\tchar\t   *qstr = quote_literal_cstr(str);\n\n\t\ttext_format_append_string(buf, qstr, flags, width);\n\t\t/* quote_literal_cstr() always allocates a new string */\n\t\tpfree(qstr);\n\t}\n\telse\n\t\ttext_format_append_string(buf, str, flags, width);\n\n\t/* Cleanup. */\n\tpfree(str);\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int32 text_length(Datum str);",
      "static bool text_format_parse_digits(const char **ptr, const char *end_ptr,\n\t\t\t\t\t\t int *value);",
      "static const char *text_format_parse_format(const char *start_ptr,\n\t\t\t\t\t\t const char *end_ptr,\n\t\t\t\t\t\t int *argpos, int *widthpos,\n\t\t\t\t\t\t int *flags, int *width);",
      "static void text_format_string_conversion(StringInfo buf, char conversion,\n\t\t\t\t\t\t\t  FmgrInfo *typOutputInfo,\n\t\t\t\t\t\t\t  Datum value, bool isNull,\n\t\t\t\t\t\t\t  int flags, int width);",
      "static void text_format_append_string(StringInfo buf, const char *str,\n\t\t\t\t\t\t  int flags, int width);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "str"
          ],
          "line": 5533
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "text_format_append_string",
          "args": [
            "buf",
            "str",
            "flags",
            "width"
          ],
          "line": 5530
        },
        "resolved": true,
        "details": {
          "function_name": "text_format_append_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "5539-5582",
          "snippet": "static void\ntext_format_append_string(StringInfo buf, const char *str,\n\t\t\t\t\t\t  int flags, int width)\n{\n\tbool\t\talign_to_left = false;\n\tint\t\t\tlen;\n\n\t/* fast path for typical easy case */\n\tif (width == 0)\n\t{\n\t\tappendStringInfoString(buf, str);\n\t\treturn;\n\t}\n\n\tif (width < 0)\n\t{\n\t\t/* Negative width: implicit '-' flag, then take absolute value */\n\t\talign_to_left = true;\n\t\t/* -INT_MIN is undefined */\n\t\tif (width <= INT_MIN)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"number is out of range\")));\n\t\twidth = -width;\n\t}\n\telse if (flags & TEXT_FORMAT_FLAG_MINUS)\n\t\talign_to_left = true;\n\n\tlen = pg_mbstrlen(str);\n\tif (align_to_left)\n\t{\n\t\t/* left justify */\n\t\tappendStringInfoString(buf, str);\n\t\tif (len < width)\n\t\t\tappendStringInfoSpaces(buf, width - len);\n\t}\n\telse\n\t{\n\t\t/* right justify */\n\t\tif (len < width)\n\t\t\tappendStringInfoSpaces(buf, width - len);\n\t\tappendStringInfoString(buf, str);\n\t}\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TEXT_FORMAT_FLAG_MINUS\t0x0001\t/* is minus flag present? */"
          ],
          "globals_used": [
            "static int32 text_length(Datum str);",
            "static bool text_format_parse_digits(const char **ptr, const char *end_ptr,\n\t\t\t\t\t\t int *value);",
            "static const char *text_format_parse_format(const char *start_ptr,\n\t\t\t\t\t\t const char *end_ptr,\n\t\t\t\t\t\t int *argpos, int *widthpos,\n\t\t\t\t\t\t int *flags, int *width);",
            "static void text_format_string_conversion(StringInfo buf, char conversion,\n\t\t\t\t\t\t\t  FmgrInfo *typOutputInfo,\n\t\t\t\t\t\t\t  Datum value, bool isNull,\n\t\t\t\t\t\t\t  int flags, int width);",
            "static void text_format_append_string(StringInfo buf, const char *str,\n\t\t\t\t\t\t  int flags, int width);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define TEXT_FORMAT_FLAG_MINUS\t0x0001\t/* is minus flag present? */\n\nstatic int32 text_length(Datum str);\nstatic bool text_format_parse_digits(const char **ptr, const char *end_ptr,\n\t\t\t\t\t\t int *value);\nstatic const char *text_format_parse_format(const char *start_ptr,\n\t\t\t\t\t\t const char *end_ptr,\n\t\t\t\t\t\t int *argpos, int *widthpos,\n\t\t\t\t\t\t int *flags, int *width);\nstatic void text_format_string_conversion(StringInfo buf, char conversion,\n\t\t\t\t\t\t\t  FmgrInfo *typOutputInfo,\n\t\t\t\t\t\t\t  Datum value, bool isNull,\n\t\t\t\t\t\t\t  int flags, int width);\nstatic void text_format_append_string(StringInfo buf, const char *str,\n\t\t\t\t\t\t  int flags, int width);\n\nstatic void\ntext_format_append_string(StringInfo buf, const char *str,\n\t\t\t\t\t\t  int flags, int width)\n{\n\tbool\t\talign_to_left = false;\n\tint\t\t\tlen;\n\n\t/* fast path for typical easy case */\n\tif (width == 0)\n\t{\n\t\tappendStringInfoString(buf, str);\n\t\treturn;\n\t}\n\n\tif (width < 0)\n\t{\n\t\t/* Negative width: implicit '-' flag, then take absolute value */\n\t\talign_to_left = true;\n\t\t/* -INT_MIN is undefined */\n\t\tif (width <= INT_MIN)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"number is out of range\")));\n\t\twidth = -width;\n\t}\n\telse if (flags & TEXT_FORMAT_FLAG_MINUS)\n\t\talign_to_left = true;\n\n\tlen = pg_mbstrlen(str);\n\tif (align_to_left)\n\t{\n\t\t/* left justify */\n\t\tappendStringInfoString(buf, str);\n\t\tif (len < width)\n\t\t\tappendStringInfoSpaces(buf, width - len);\n\t}\n\telse\n\t{\n\t\t/* right justify */\n\t\tif (len < width)\n\t\t\tappendStringInfoSpaces(buf, width - len);\n\t\tappendStringInfoString(buf, str);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "quote_literal_cstr",
          "args": [
            "str"
          ],
          "line": 5523
        },
        "resolved": true,
        "details": {
          "function_name": "quote_literal_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/quote.c",
          "lines": "101-116",
          "snippet": "char *\nquote_literal_cstr(const char *rawstr)\n{\n\tchar\t   *result;\n\tint\t\t\tlen;\n\tint\t\t\tnewlen;\n\n\tlen = strlen(rawstr);\n\t/* We make a worst-case result area; wasting a little space is OK */\n\tresult = palloc(len * 2 + 3 + 1);\n\n\tnewlen = quote_literal_internal(result, rawstr, len);\n\tresult[newlen] = '\\0';\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"postgres.h\"\n\nchar *\nquote_literal_cstr(const char *rawstr)\n{\n\tchar\t   *result;\n\tint\t\t\tlen;\n\tint\t\t\tnewlen;\n\n\tlen = strlen(rawstr);\n\t/* We make a worst-case result area; wasting a little space is OK */\n\tresult = palloc(len * 2 + 3 + 1);\n\n\tnewlen = quote_literal_internal(result, rawstr, len);\n\tresult[newlen] = '\\0';\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "quote_identifier",
          "args": [
            "str"
          ],
          "line": 5519
        },
        "resolved": true,
        "details": {
          "function_name": "quote_identifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ruleutils.c",
          "lines": "10550-10628",
          "snippet": "const char *\nquote_identifier(const char *ident)\n{\n\t/*\n\t * Can avoid quoting if ident starts with a lowercase letter or underscore\n\t * and contains only lowercase letters, digits, and underscores, *and* is\n\t * not any SQL keyword.  Otherwise, supply quotes.\n\t */\n\tint\t\t\tnquotes = 0;\n\tbool\t\tsafe;\n\tconst char *ptr;\n\tchar\t   *result;\n\tchar\t   *optr;\n\n\t/*\n\t * would like to use <ctype.h> macros here, but they might yield unwanted\n\t * locale-specific results...\n\t */\n\tsafe = ((ident[0] >= 'a' && ident[0] <= 'z') || ident[0] == '_');\n\n\tfor (ptr = ident; *ptr; ptr++)\n\t{\n\t\tchar\t\tch = *ptr;\n\n\t\tif ((ch >= 'a' && ch <= 'z') ||\n\t\t\t(ch >= '0' && ch <= '9') ||\n\t\t\t(ch == '_'))\n\t\t{\n\t\t\t/* okay */\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsafe = false;\n\t\t\tif (ch == '\"')\n\t\t\t\tnquotes++;\n\t\t}\n\t}\n\n\tif (quote_all_identifiers)\n\t\tsafe = false;\n\n\tif (safe)\n\t{\n\t\t/*\n\t\t * Check for keyword.  We quote keywords except for unreserved ones.\n\t\t * (In some cases we could avoid quoting a col_name or type_func_name\n\t\t * keyword, but it seems much harder than it's worth to tell that.)\n\t\t *\n\t\t * Note: ScanKeywordLookup() does case-insensitive comparison, but\n\t\t * that's fine, since we already know we have all-lower-case.\n\t\t */\n\t\tconst ScanKeyword *keyword = ScanKeywordLookup(ident,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   ScanKeywords,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   NumScanKeywords);\n\n\t\tif (keyword != NULL && keyword->category != UNRESERVED_KEYWORD)\n\t\t\tsafe = false;\n\t}\n\n\tif (safe)\n\t\treturn ident;\t\t\t/* no change needed */\n\n\tresult = (char *) palloc(strlen(ident) + nquotes + 2 + 1);\n\n\toptr = result;\n\t*optr++ = '\"';\n\tfor (ptr = ident; *ptr; ptr++)\n\t{\n\t\tchar\t\tch = *ptr;\n\n\t\tif (ch == '\"')\n\t\t\t*optr++ = '\"';\n\t\t*optr++ = ch;\n\t}\n\t*optr++ = '\"';\n\t*optr = '\\0';\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/ruleutils.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"rewrite/rewriteSupport.h\"",
            "#include \"rewrite/rewriteManip.h\"",
            "#include \"rewrite/rewriteHandler.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parser.h\"",
            "#include \"parser/parse_oper.h\"",
            "#include \"parser/parse_func.h\"",
            "#include \"parser/parse_agg.h\"",
            "#include \"parser/parse_node.h\"",
            "#include \"optimizer/tlist.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"common/keywords.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/dependency.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/amapi.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "bool\t\tquote_all_identifiers = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/ruleutils.h\"\n#include \"utils/rel.h\"\n#include \"utils/partcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"rewrite/rewriteSupport.h\"\n#include \"rewrite/rewriteManip.h\"\n#include \"rewrite/rewriteHandler.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parser.h\"\n#include \"parser/parse_oper.h\"\n#include \"parser/parse_func.h\"\n#include \"parser/parse_agg.h\"\n#include \"parser/parse_node.h\"\n#include \"optimizer/tlist.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"common/keywords.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/dependency.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/amapi.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nbool\t\tquote_all_identifiers = false;\n\nconst char *\nquote_identifier(const char *ident)\n{\n\t/*\n\t * Can avoid quoting if ident starts with a lowercase letter or underscore\n\t * and contains only lowercase letters, digits, and underscores, *and* is\n\t * not any SQL keyword.  Otherwise, supply quotes.\n\t */\n\tint\t\t\tnquotes = 0;\n\tbool\t\tsafe;\n\tconst char *ptr;\n\tchar\t   *result;\n\tchar\t   *optr;\n\n\t/*\n\t * would like to use <ctype.h> macros here, but they might yield unwanted\n\t * locale-specific results...\n\t */\n\tsafe = ((ident[0] >= 'a' && ident[0] <= 'z') || ident[0] == '_');\n\n\tfor (ptr = ident; *ptr; ptr++)\n\t{\n\t\tchar\t\tch = *ptr;\n\n\t\tif ((ch >= 'a' && ch <= 'z') ||\n\t\t\t(ch >= '0' && ch <= '9') ||\n\t\t\t(ch == '_'))\n\t\t{\n\t\t\t/* okay */\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsafe = false;\n\t\t\tif (ch == '\"')\n\t\t\t\tnquotes++;\n\t\t}\n\t}\n\n\tif (quote_all_identifiers)\n\t\tsafe = false;\n\n\tif (safe)\n\t{\n\t\t/*\n\t\t * Check for keyword.  We quote keywords except for unreserved ones.\n\t\t * (In some cases we could avoid quoting a col_name or type_func_name\n\t\t * keyword, but it seems much harder than it's worth to tell that.)\n\t\t *\n\t\t * Note: ScanKeywordLookup() does case-insensitive comparison, but\n\t\t * that's fine, since we already know we have all-lower-case.\n\t\t */\n\t\tconst ScanKeyword *keyword = ScanKeywordLookup(ident,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   ScanKeywords,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   NumScanKeywords);\n\n\t\tif (keyword != NULL && keyword->category != UNRESERVED_KEYWORD)\n\t\t\tsafe = false;\n\t}\n\n\tif (safe)\n\t\treturn ident;\t\t\t/* no change needed */\n\n\tresult = (char *) palloc(strlen(ident) + nquotes + 2 + 1);\n\n\toptr = result;\n\t*optr++ = '\"';\n\tfor (ptr = ident; *ptr; ptr++)\n\t{\n\t\tchar\t\tch = *ptr;\n\n\t\tif (ch == '\"')\n\t\t\t*optr++ = '\"';\n\t\t*optr++ = ch;\n\t}\n\t*optr++ = '\"';\n\t*optr = '\\0';\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OutputFunctionCall",
          "args": [
            "typOutputInfo",
            "value"
          ],
          "line": 5513
        },
        "resolved": true,
        "details": {
          "function_name": "OidOutputFunctionCall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1832-1839",
          "snippet": "char *\nOidOutputFunctionCall(Oid functionId, Datum val)\n{\n\tFmgrInfo\tflinfo;\n\n\tfmgr_info(functionId, &flinfo);\n\treturn OutputFunctionCall(&flinfo, val);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nchar *\nOidOutputFunctionCall(Oid functionId, Datum val)\n{\n\tFmgrInfo\tflinfo;\n\n\tfmgr_info(functionId, &flinfo);\n\treturn OutputFunctionCall(&flinfo, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"null values cannot be formatted as an SQL identifier\"))"
          ],
          "line": 5506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"null values cannot be formatted as an SQL identifier\""
          ],
          "line": 5508
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_NULL_VALUE_NOT_ALLOWED"
          ],
          "line": 5507
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int32 text_length(Datum str);\nstatic bool text_format_parse_digits(const char **ptr, const char *end_ptr,\n\t\t\t\t\t\t int *value);\nstatic const char *text_format_parse_format(const char *start_ptr,\n\t\t\t\t\t\t const char *end_ptr,\n\t\t\t\t\t\t int *argpos, int *widthpos,\n\t\t\t\t\t\t int *flags, int *width);\nstatic void text_format_string_conversion(StringInfo buf, char conversion,\n\t\t\t\t\t\t\t  FmgrInfo *typOutputInfo,\n\t\t\t\t\t\t\t  Datum value, bool isNull,\n\t\t\t\t\t\t\t  int flags, int width);\nstatic void text_format_append_string(StringInfo buf, const char *str,\n\t\t\t\t\t\t  int flags, int width);\n\nstatic void\ntext_format_string_conversion(StringInfo buf, char conversion,\n\t\t\t\t\t\t\t  FmgrInfo *typOutputInfo,\n\t\t\t\t\t\t\t  Datum value, bool isNull,\n\t\t\t\t\t\t\t  int flags, int width)\n{\n\tchar\t   *str;\n\n\t/* Handle NULL arguments before trying to stringify the value. */\n\tif (isNull)\n\t{\n\t\tif (conversion == 's')\n\t\t\ttext_format_append_string(buf, \"\", flags, width);\n\t\telse if (conversion == 'L')\n\t\t\ttext_format_append_string(buf, \"NULL\", flags, width);\n\t\telse if (conversion == 'I')\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"null values cannot be formatted as an SQL identifier\")));\n\t\treturn;\n\t}\n\n\t/* Stringify. */\n\tstr = OutputFunctionCall(typOutputInfo, value);\n\n\t/* Escape. */\n\tif (conversion == 'I')\n\t{\n\t\t/* quote_identifier may or may not allocate a new string. */\n\t\ttext_format_append_string(buf, quote_identifier(str), flags, width);\n\t}\n\telse if (conversion == 'L')\n\t{\n\t\tchar\t   *qstr = quote_literal_cstr(str);\n\n\t\ttext_format_append_string(buf, qstr, flags, width);\n\t\t/* quote_literal_cstr() always allocates a new string */\n\t\tpfree(qstr);\n\t}\n\telse\n\t\ttext_format_append_string(buf, str, flags, width);\n\n\t/* Cleanup. */\n\tpfree(str);\n}"
  },
  {
    "function_name": "text_format_parse_format",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "5413-5485",
    "snippet": "static const char *\ntext_format_parse_format(const char *start_ptr, const char *end_ptr,\n\t\t\t\t\t\t int *argpos, int *widthpos,\n\t\t\t\t\t\t int *flags, int *width)\n{\n\tconst char *cp = start_ptr;\n\tint\t\t\tn;\n\n\t/* set defaults for output parameters */\n\t*argpos = -1;\n\t*widthpos = -1;\n\t*flags = 0;\n\t*width = 0;\n\n\t/* try to identify first number */\n\tif (text_format_parse_digits(&cp, end_ptr, &n))\n\t{\n\t\tif (*cp != '$')\n\t\t{\n\t\t\t/* Must be just a width and a type, so we're done */\n\t\t\t*width = n;\n\t\t\treturn cp;\n\t\t}\n\t\t/* The number was argument position */\n\t\t*argpos = n;\n\t\t/* Explicit 0 for argument index is immediately refused */\n\t\tif (n == 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"format specifies argument 0, but arguments are numbered from 1\")));\n\t\tADVANCE_PARSE_POINTER(cp, end_ptr);\n\t}\n\n\t/* Handle flags (only minus is supported now) */\n\twhile (*cp == '-')\n\t{\n\t\t*flags |= TEXT_FORMAT_FLAG_MINUS;\n\t\tADVANCE_PARSE_POINTER(cp, end_ptr);\n\t}\n\n\tif (*cp == '*')\n\t{\n\t\t/* Handle indirect width */\n\t\tADVANCE_PARSE_POINTER(cp, end_ptr);\n\t\tif (text_format_parse_digits(&cp, end_ptr, &n))\n\t\t{\n\t\t\t/* number in this position must be closed by $ */\n\t\t\tif (*cp != '$')\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"width argument position must be ended by \\\"$\\\"\")));\n\t\t\t/* The number was width argument position */\n\t\t\t*widthpos = n;\n\t\t\t/* Explicit 0 for argument index is immediately refused */\n\t\t\tif (n == 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"format specifies argument 0, but arguments are numbered from 1\")));\n\t\t\tADVANCE_PARSE_POINTER(cp, end_ptr);\n\t\t}\n\t\telse\n\t\t\t*widthpos = 0;\t\t/* width's argument position is unspecified */\n\t}\n\telse\n\t{\n\t\t/* Check for direct width specification */\n\t\tif (text_format_parse_digits(&cp, end_ptr, &n))\n\t\t\t*width = n;\n\t}\n\n\t/* cp should now be pointing at type character */\n\treturn cp;\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define TEXT_FORMAT_FLAG_MINUS\t0x0001\t/* is minus flag present? */"
    ],
    "globals_used": [
      "static const char *text_format_parse_format(const char *start_ptr,\n\t\t\t\t\t\t const char *end_ptr,\n\t\t\t\t\t\t int *argpos, int *widthpos,\n\t\t\t\t\t\t int *flags, int *width);",
      "static void text_format_string_conversion(StringInfo buf, char conversion,\n\t\t\t\t\t\t\t  FmgrInfo *typOutputInfo,\n\t\t\t\t\t\t\t  Datum value, bool isNull,\n\t\t\t\t\t\t\t  int flags, int width);",
      "static void text_format_append_string(StringInfo buf, const char *str,\n\t\t\t\t\t\t  int flags, int width);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "text_format_parse_digits",
          "args": [
            "&cp",
            "end_ptr",
            "&n"
          ],
          "line": 5479
        },
        "resolved": true,
        "details": {
          "function_name": "text_format_parse_digits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "5364-5388",
          "snippet": "static bool\ntext_format_parse_digits(const char **ptr, const char *end_ptr, int *value)\n{\n\tbool\t\tfound = false;\n\tconst char *cp = *ptr;\n\tint\t\t\tval = 0;\n\n\twhile (*cp >= '0' && *cp <= '9')\n\t{\n\t\tint8\t\tdigit = (*cp - '0');\n\n\t\tif (unlikely(pg_mul_s32_overflow(val, 10, &val)) ||\n\t\t\tunlikely(pg_add_s32_overflow(val, digit, &val)))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"number is out of range\")));\n\t\tADVANCE_PARSE_POINTER(cp, end_ptr);\n\t\tfound = true;\n\t}\n\n\t*ptr = cp;\n\t*value = val;\n\n\treturn found;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool text_format_parse_digits(const char **ptr, const char *end_ptr,\n\t\t\t\t\t\t int *value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool text_format_parse_digits(const char **ptr, const char *end_ptr,\n\t\t\t\t\t\t int *value);\n\nstatic bool\ntext_format_parse_digits(const char **ptr, const char *end_ptr, int *value)\n{\n\tbool\t\tfound = false;\n\tconst char *cp = *ptr;\n\tint\t\t\tval = 0;\n\n\twhile (*cp >= '0' && *cp <= '9')\n\t{\n\t\tint8\t\tdigit = (*cp - '0');\n\n\t\tif (unlikely(pg_mul_s32_overflow(val, 10, &val)) ||\n\t\t\tunlikely(pg_add_s32_overflow(val, digit, &val)))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"number is out of range\")));\n\t\tADVANCE_PARSE_POINTER(cp, end_ptr);\n\t\tfound = true;\n\t}\n\n\t*ptr = cp;\n\t*value = val;\n\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ADVANCE_PARSE_POINTER",
          "args": [
            "cp",
            "end_ptr"
          ],
          "line": 5471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"format specifies argument 0, but arguments are numbered from 1\"))"
          ],
          "line": 5468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"format specifies argument 0, but arguments are numbered from 1\""
          ],
          "line": 5470
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 5469
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"width argument position must be ended by \\\"$\\\"\"))"
          ],
          "line": 5461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADVANCE_PARSE_POINTER",
          "args": [
            "cp",
            "end_ptr"
          ],
          "line": 5456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADVANCE_PARSE_POINTER",
          "args": [
            "cp",
            "end_ptr"
          ],
          "line": 5450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADVANCE_PARSE_POINTER",
          "args": [
            "cp",
            "end_ptr"
          ],
          "line": 5443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"format specifies argument 0, but arguments are numbered from 1\"))"
          ],
          "line": 5440
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define TEXT_FORMAT_FLAG_MINUS\t0x0001\t/* is minus flag present? */\n\nstatic const char *text_format_parse_format(const char *start_ptr,\n\t\t\t\t\t\t const char *end_ptr,\n\t\t\t\t\t\t int *argpos, int *widthpos,\n\t\t\t\t\t\t int *flags, int *width);\nstatic void text_format_string_conversion(StringInfo buf, char conversion,\n\t\t\t\t\t\t\t  FmgrInfo *typOutputInfo,\n\t\t\t\t\t\t\t  Datum value, bool isNull,\n\t\t\t\t\t\t\t  int flags, int width);\nstatic void text_format_append_string(StringInfo buf, const char *str,\n\t\t\t\t\t\t  int flags, int width);\n\nstatic const char *\ntext_format_parse_format(const char *start_ptr, const char *end_ptr,\n\t\t\t\t\t\t int *argpos, int *widthpos,\n\t\t\t\t\t\t int *flags, int *width)\n{\n\tconst char *cp = start_ptr;\n\tint\t\t\tn;\n\n\t/* set defaults for output parameters */\n\t*argpos = -1;\n\t*widthpos = -1;\n\t*flags = 0;\n\t*width = 0;\n\n\t/* try to identify first number */\n\tif (text_format_parse_digits(&cp, end_ptr, &n))\n\t{\n\t\tif (*cp != '$')\n\t\t{\n\t\t\t/* Must be just a width and a type, so we're done */\n\t\t\t*width = n;\n\t\t\treturn cp;\n\t\t}\n\t\t/* The number was argument position */\n\t\t*argpos = n;\n\t\t/* Explicit 0 for argument index is immediately refused */\n\t\tif (n == 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"format specifies argument 0, but arguments are numbered from 1\")));\n\t\tADVANCE_PARSE_POINTER(cp, end_ptr);\n\t}\n\n\t/* Handle flags (only minus is supported now) */\n\twhile (*cp == '-')\n\t{\n\t\t*flags |= TEXT_FORMAT_FLAG_MINUS;\n\t\tADVANCE_PARSE_POINTER(cp, end_ptr);\n\t}\n\n\tif (*cp == '*')\n\t{\n\t\t/* Handle indirect width */\n\t\tADVANCE_PARSE_POINTER(cp, end_ptr);\n\t\tif (text_format_parse_digits(&cp, end_ptr, &n))\n\t\t{\n\t\t\t/* number in this position must be closed by $ */\n\t\t\tif (*cp != '$')\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"width argument position must be ended by \\\"$\\\"\")));\n\t\t\t/* The number was width argument position */\n\t\t\t*widthpos = n;\n\t\t\t/* Explicit 0 for argument index is immediately refused */\n\t\t\tif (n == 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"format specifies argument 0, but arguments are numbered from 1\")));\n\t\t\tADVANCE_PARSE_POINTER(cp, end_ptr);\n\t\t}\n\t\telse\n\t\t\t*widthpos = 0;\t\t/* width's argument position is unspecified */\n\t}\n\telse\n\t{\n\t\t/* Check for direct width specification */\n\t\tif (text_format_parse_digits(&cp, end_ptr, &n))\n\t\t\t*width = n;\n\t}\n\n\t/* cp should now be pointing at type character */\n\treturn cp;\n}"
  },
  {
    "function_name": "text_format_parse_digits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "5364-5388",
    "snippet": "static bool\ntext_format_parse_digits(const char **ptr, const char *end_ptr, int *value)\n{\n\tbool\t\tfound = false;\n\tconst char *cp = *ptr;\n\tint\t\t\tval = 0;\n\n\twhile (*cp >= '0' && *cp <= '9')\n\t{\n\t\tint8\t\tdigit = (*cp - '0');\n\n\t\tif (unlikely(pg_mul_s32_overflow(val, 10, &val)) ||\n\t\t\tunlikely(pg_add_s32_overflow(val, digit, &val)))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"number is out of range\")));\n\t\tADVANCE_PARSE_POINTER(cp, end_ptr);\n\t\tfound = true;\n\t}\n\n\t*ptr = cp;\n\t*value = val;\n\n\treturn found;\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool text_format_parse_digits(const char **ptr, const char *end_ptr,\n\t\t\t\t\t\t int *value);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ADVANCE_PARSE_POINTER",
          "args": [
            "cp",
            "end_ptr"
          ],
          "line": 5380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"number is out of range\"))"
          ],
          "line": 5377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"number is out of range\""
          ],
          "line": 5379
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE"
          ],
          "line": 5378
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "pg_add_s32_overflow(val, digit, &val)"
          ],
          "line": 5376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_add_s32_overflow",
          "args": [
            "val",
            "digit",
            "&val"
          ],
          "line": 5376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "pg_mul_s32_overflow(val, 10, &val)"
          ],
          "line": 5375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_mul_s32_overflow",
          "args": [
            "val",
            "10",
            "&val"
          ],
          "line": 5375
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool text_format_parse_digits(const char **ptr, const char *end_ptr,\n\t\t\t\t\t\t int *value);\n\nstatic bool\ntext_format_parse_digits(const char **ptr, const char *end_ptr, int *value)\n{\n\tbool\t\tfound = false;\n\tconst char *cp = *ptr;\n\tint\t\t\tval = 0;\n\n\twhile (*cp >= '0' && *cp <= '9')\n\t{\n\t\tint8\t\tdigit = (*cp - '0');\n\n\t\tif (unlikely(pg_mul_s32_overflow(val, 10, &val)) ||\n\t\t\tunlikely(pg_add_s32_overflow(val, digit, &val)))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"number is out of range\")));\n\t\tADVANCE_PARSE_POINTER(cp, end_ptr);\n\t\tfound = true;\n\t}\n\n\t*ptr = cp;\n\t*value = val;\n\n\treturn found;\n}"
  },
  {
    "function_name": "text_format",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "5087-5352",
    "snippet": "Datum\ntext_format(PG_FUNCTION_ARGS)\n{\n\ttext\t   *fmt;\n\tStringInfoData str;\n\tconst char *cp;\n\tconst char *start_ptr;\n\tconst char *end_ptr;\n\ttext\t   *result;\n\tint\t\t\targ;\n\tbool\t\tfuncvariadic;\n\tint\t\t\tnargs;\n\tDatum\t   *elements = NULL;\n\tbool\t   *nulls = NULL;\n\tOid\t\t\telement_type = InvalidOid;\n\tOid\t\t\tprev_type = InvalidOid;\n\tOid\t\t\tprev_width_type = InvalidOid;\n\tFmgrInfo\ttypoutputfinfo;\n\tFmgrInfo\ttypoutputinfo_width;\n\n\t/* When format string is null, immediately return null */\n\tif (PG_ARGISNULL(0))\n\t\tPG_RETURN_NULL();\n\n\t/* If argument is marked VARIADIC, expand array into elements */\n\tif (get_fn_expr_variadic(fcinfo->flinfo))\n\t{\n\t\tArrayType  *arr;\n\t\tint16\t\telmlen;\n\t\tbool\t\telmbyval;\n\t\tchar\t\telmalign;\n\t\tint\t\t\tnitems;\n\n\t\t/* Should have just the one argument */\n\t\tAssert(PG_NARGS() == 2);\n\n\t\t/* If argument is NULL, we treat it as zero-length array */\n\t\tif (PG_ARGISNULL(1))\n\t\t\tnitems = 0;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Non-null argument had better be an array.  We assume that any\n\t\t\t * call context that could let get_fn_expr_variadic return true\n\t\t\t * will have checked that a VARIADIC-labeled parameter actually is\n\t\t\t * an array.  So it should be okay to just Assert that it's an\n\t\t\t * array rather than doing a full-fledged error check.\n\t\t\t */\n\t\t\tAssert(OidIsValid(get_base_element_type(get_fn_expr_argtype(fcinfo->flinfo, 1))));\n\n\t\t\t/* OK, safe to fetch the array value */\n\t\t\tarr = PG_GETARG_ARRAYTYPE_P(1);\n\n\t\t\t/* Get info about array element type */\n\t\t\telement_type = ARR_ELEMTYPE(arr);\n\t\t\tget_typlenbyvalalign(element_type,\n\t\t\t\t\t\t\t\t &elmlen, &elmbyval, &elmalign);\n\n\t\t\t/* Extract all array elements */\n\t\t\tdeconstruct_array(arr, element_type, elmlen, elmbyval, elmalign,\n\t\t\t\t\t\t\t  &elements, &nulls, &nitems);\n\t\t}\n\n\t\tnargs = nitems + 1;\n\t\tfuncvariadic = true;\n\t}\n\telse\n\t{\n\t\t/* Non-variadic case, we'll process the arguments individually */\n\t\tnargs = PG_NARGS();\n\t\tfuncvariadic = false;\n\t}\n\n\t/* Setup for main loop. */\n\tfmt = PG_GETARG_TEXT_PP(0);\n\tstart_ptr = VARDATA_ANY(fmt);\n\tend_ptr = start_ptr + VARSIZE_ANY_EXHDR(fmt);\n\tinitStringInfo(&str);\n\targ = 1;\t\t\t\t\t/* next argument position to print */\n\n\t/* Scan format string, looking for conversion specifiers. */\n\tfor (cp = start_ptr; cp < end_ptr; cp++)\n\t{\n\t\tint\t\t\targpos;\n\t\tint\t\t\twidthpos;\n\t\tint\t\t\tflags;\n\t\tint\t\t\twidth;\n\t\tDatum\t\tvalue;\n\t\tbool\t\tisNull;\n\t\tOid\t\t\ttypid;\n\n\t\t/*\n\t\t * If it's not the start of a conversion specifier, just copy it to\n\t\t * the output buffer.\n\t\t */\n\t\tif (*cp != '%')\n\t\t{\n\t\t\tappendStringInfoCharMacro(&str, *cp);\n\t\t\tcontinue;\n\t\t}\n\n\t\tADVANCE_PARSE_POINTER(cp, end_ptr);\n\n\t\t/* Easy case: %% outputs a single % */\n\t\tif (*cp == '%')\n\t\t{\n\t\t\tappendStringInfoCharMacro(&str, *cp);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Parse the optional portions of the format specifier */\n\t\tcp = text_format_parse_format(cp, end_ptr,\n\t\t\t\t\t\t\t\t\t  &argpos, &widthpos,\n\t\t\t\t\t\t\t\t\t  &flags, &width);\n\n\t\t/*\n\t\t * Next we should see the main conversion specifier.  Whether or not\n\t\t * an argument position was present, it's known that at least one\n\t\t * character remains in the string at this point.  Experience suggests\n\t\t * that it's worth checking that that character is one of the expected\n\t\t * ones before we try to fetch arguments, so as to produce the least\n\t\t * confusing response to a mis-formatted specifier.\n\t\t */\n\t\tif (strchr(\"sIL\", *cp) == NULL)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"unrecognized format() type specifier \\\"%c\\\"\",\n\t\t\t\t\t\t\t*cp),\n\t\t\t\t\t errhint(\"For a single \\\"%%\\\" use \\\"%%%%\\\".\")));\n\n\t\t/* If indirect width was specified, get its value */\n\t\tif (widthpos >= 0)\n\t\t{\n\t\t\t/* Collect the specified or next argument position */\n\t\t\tif (widthpos > 0)\n\t\t\t\targ = widthpos;\n\t\t\tif (arg >= nargs)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"too few arguments for format()\")));\n\n\t\t\t/* Get the value and type of the selected argument */\n\t\t\tif (!funcvariadic)\n\t\t\t{\n\t\t\t\tvalue = PG_GETARG_DATUM(arg);\n\t\t\t\tisNull = PG_ARGISNULL(arg);\n\t\t\t\ttypid = get_fn_expr_argtype(fcinfo->flinfo, arg);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvalue = elements[arg - 1];\n\t\t\t\tisNull = nulls[arg - 1];\n\t\t\t\ttypid = element_type;\n\t\t\t}\n\t\t\tif (!OidIsValid(typid))\n\t\t\t\telog(ERROR, \"could not determine data type of format() input\");\n\n\t\t\targ++;\n\n\t\t\t/* We can treat NULL width the same as zero */\n\t\t\tif (isNull)\n\t\t\t\twidth = 0;\n\t\t\telse if (typid == INT4OID)\n\t\t\t\twidth = DatumGetInt32(value);\n\t\t\telse if (typid == INT2OID)\n\t\t\t\twidth = DatumGetInt16(value);\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* For less-usual datatypes, convert to text then to int */\n\t\t\t\tchar\t   *str;\n\n\t\t\t\tif (typid != prev_width_type)\n\t\t\t\t{\n\t\t\t\t\tOid\t\t\ttypoutputfunc;\n\t\t\t\t\tbool\t\ttypIsVarlena;\n\n\t\t\t\t\tgetTypeOutputInfo(typid, &typoutputfunc, &typIsVarlena);\n\t\t\t\t\tfmgr_info(typoutputfunc, &typoutputinfo_width);\n\t\t\t\t\tprev_width_type = typid;\n\t\t\t\t}\n\n\t\t\t\tstr = OutputFunctionCall(&typoutputinfo_width, value);\n\n\t\t\t\t/* pg_atoi will complain about bad data or overflow */\n\t\t\t\twidth = pg_atoi(str, sizeof(int), '\\0');\n\n\t\t\t\tpfree(str);\n\t\t\t}\n\t\t}\n\n\t\t/* Collect the specified or next argument position */\n\t\tif (argpos > 0)\n\t\t\targ = argpos;\n\t\tif (arg >= nargs)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"too few arguments for format()\")));\n\n\t\t/* Get the value and type of the selected argument */\n\t\tif (!funcvariadic)\n\t\t{\n\t\t\tvalue = PG_GETARG_DATUM(arg);\n\t\t\tisNull = PG_ARGISNULL(arg);\n\t\t\ttypid = get_fn_expr_argtype(fcinfo->flinfo, arg);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvalue = elements[arg - 1];\n\t\t\tisNull = nulls[arg - 1];\n\t\t\ttypid = element_type;\n\t\t}\n\t\tif (!OidIsValid(typid))\n\t\t\telog(ERROR, \"could not determine data type of format() input\");\n\n\t\targ++;\n\n\t\t/*\n\t\t * Get the appropriate typOutput function, reusing previous one if\n\t\t * same type as previous argument.  That's particularly useful in the\n\t\t * variadic-array case, but often saves work even for ordinary calls.\n\t\t */\n\t\tif (typid != prev_type)\n\t\t{\n\t\t\tOid\t\t\ttypoutputfunc;\n\t\t\tbool\t\ttypIsVarlena;\n\n\t\t\tgetTypeOutputInfo(typid, &typoutputfunc, &typIsVarlena);\n\t\t\tfmgr_info(typoutputfunc, &typoutputfinfo);\n\t\t\tprev_type = typid;\n\t\t}\n\n\t\t/*\n\t\t * And now we can format the value.\n\t\t */\n\t\tswitch (*cp)\n\t\t{\n\t\t\tcase 's':\n\t\t\tcase 'I':\n\t\t\tcase 'L':\n\t\t\t\ttext_format_string_conversion(&str, *cp, &typoutputfinfo,\n\t\t\t\t\t\t\t\t\t\t\t  value, isNull,\n\t\t\t\t\t\t\t\t\t\t\t  flags, width);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* should not get here, because of previous check */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"unrecognized format() type specifier \\\"%c\\\"\",\n\t\t\t\t\t\t\t\t*cp),\n\t\t\t\t\t\t errhint(\"For a single \\\"%%\\\" use \\\"%%%%\\\".\")));\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Don't need deconstruct_array results anymore. */\n\tif (elements != NULL)\n\t\tpfree(elements);\n\tif (nulls != NULL)\n\t\tpfree(nulls);\n\n\t/* Generate results. */\n\tresult = cstring_to_text_with_len(str.data, str.len);\n\tpfree(str.data);\n\n\tPG_RETURN_TEXT_P(result);\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int32 text_length(Datum str);",
      "static void appendStringInfoText(StringInfo str, const text *t);",
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);",
      "static StringInfo makeStringAggState(FunctionCallInfo fcinfo);",
      "static bool text_format_parse_digits(const char **ptr, const char *end_ptr,\n\t\t\t\t\t\t int *value);",
      "static const char *text_format_parse_format(const char *start_ptr,\n\t\t\t\t\t\t const char *end_ptr,\n\t\t\t\t\t\t int *argpos, int *widthpos,\n\t\t\t\t\t\t int *flags, int *width);",
      "static void text_format_string_conversion(StringInfo buf, char conversion,\n\t\t\t\t\t\t\t  FmgrInfo *typOutputInfo,\n\t\t\t\t\t\t\t  Datum value, bool isNull,\n\t\t\t\t\t\t\t  int flags, int width);",
      "static void text_format_append_string(StringInfo buf, const char *str,\n\t\t\t\t\t\t  int flags, int width);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "result"
          ],
          "line": 5351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "str.data"
          ],
          "line": 5349
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cstring_to_text_with_len",
          "args": [
            "str.data",
            "str.len"
          ],
          "line": 5348
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "160-169",
          "snippet": "text *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"unrecognized format() type specifier \\\"%c\\\"\",\n\t\t\t\t\t\t\t\t*cp),\n\t\t\t\t\t\t errhint(\"For a single \\\"%%\\\" use \\\"%%%%\\\".\"))"
          ],
          "line": 5332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errhint",
          "args": [
            "\"For a single \\\"%%\\\" use \\\"%%%%\\\".\""
          ],
          "line": 5336
        },
        "resolved": true,
        "details": {
          "function_name": "errhint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "984-999",
          "snippet": "int\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"unrecognized format() type specifier \\\"%c\\\"\"",
            "*cp"
          ],
          "line": 5334
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 5333
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "text_format_string_conversion",
          "args": [
            "&str",
            "*cp",
            "&typoutputfinfo",
            "value",
            "isNull",
            "flags",
            "width"
          ],
          "line": 5326
        },
        "resolved": true,
        "details": {
          "function_name": "text_format_string_conversion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "5490-5534",
          "snippet": "static void\ntext_format_string_conversion(StringInfo buf, char conversion,\n\t\t\t\t\t\t\t  FmgrInfo *typOutputInfo,\n\t\t\t\t\t\t\t  Datum value, bool isNull,\n\t\t\t\t\t\t\t  int flags, int width)\n{\n\tchar\t   *str;\n\n\t/* Handle NULL arguments before trying to stringify the value. */\n\tif (isNull)\n\t{\n\t\tif (conversion == 's')\n\t\t\ttext_format_append_string(buf, \"\", flags, width);\n\t\telse if (conversion == 'L')\n\t\t\ttext_format_append_string(buf, \"NULL\", flags, width);\n\t\telse if (conversion == 'I')\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"null values cannot be formatted as an SQL identifier\")));\n\t\treturn;\n\t}\n\n\t/* Stringify. */\n\tstr = OutputFunctionCall(typOutputInfo, value);\n\n\t/* Escape. */\n\tif (conversion == 'I')\n\t{\n\t\t/* quote_identifier may or may not allocate a new string. */\n\t\ttext_format_append_string(buf, quote_identifier(str), flags, width);\n\t}\n\telse if (conversion == 'L')\n\t{\n\t\tchar\t   *qstr = quote_literal_cstr(str);\n\n\t\ttext_format_append_string(buf, qstr, flags, width);\n\t\t/* quote_literal_cstr() always allocates a new string */\n\t\tpfree(qstr);\n\t}\n\telse\n\t\ttext_format_append_string(buf, str, flags, width);\n\n\t/* Cleanup. */\n\tpfree(str);\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int32 text_length(Datum str);",
            "static bool text_format_parse_digits(const char **ptr, const char *end_ptr,\n\t\t\t\t\t\t int *value);",
            "static const char *text_format_parse_format(const char *start_ptr,\n\t\t\t\t\t\t const char *end_ptr,\n\t\t\t\t\t\t int *argpos, int *widthpos,\n\t\t\t\t\t\t int *flags, int *width);",
            "static void text_format_string_conversion(StringInfo buf, char conversion,\n\t\t\t\t\t\t\t  FmgrInfo *typOutputInfo,\n\t\t\t\t\t\t\t  Datum value, bool isNull,\n\t\t\t\t\t\t\t  int flags, int width);",
            "static void text_format_append_string(StringInfo buf, const char *str,\n\t\t\t\t\t\t  int flags, int width);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int32 text_length(Datum str);\nstatic bool text_format_parse_digits(const char **ptr, const char *end_ptr,\n\t\t\t\t\t\t int *value);\nstatic const char *text_format_parse_format(const char *start_ptr,\n\t\t\t\t\t\t const char *end_ptr,\n\t\t\t\t\t\t int *argpos, int *widthpos,\n\t\t\t\t\t\t int *flags, int *width);\nstatic void text_format_string_conversion(StringInfo buf, char conversion,\n\t\t\t\t\t\t\t  FmgrInfo *typOutputInfo,\n\t\t\t\t\t\t\t  Datum value, bool isNull,\n\t\t\t\t\t\t\t  int flags, int width);\nstatic void text_format_append_string(StringInfo buf, const char *str,\n\t\t\t\t\t\t  int flags, int width);\n\nstatic void\ntext_format_string_conversion(StringInfo buf, char conversion,\n\t\t\t\t\t\t\t  FmgrInfo *typOutputInfo,\n\t\t\t\t\t\t\t  Datum value, bool isNull,\n\t\t\t\t\t\t\t  int flags, int width)\n{\n\tchar\t   *str;\n\n\t/* Handle NULL arguments before trying to stringify the value. */\n\tif (isNull)\n\t{\n\t\tif (conversion == 's')\n\t\t\ttext_format_append_string(buf, \"\", flags, width);\n\t\telse if (conversion == 'L')\n\t\t\ttext_format_append_string(buf, \"NULL\", flags, width);\n\t\telse if (conversion == 'I')\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"null values cannot be formatted as an SQL identifier\")));\n\t\treturn;\n\t}\n\n\t/* Stringify. */\n\tstr = OutputFunctionCall(typOutputInfo, value);\n\n\t/* Escape. */\n\tif (conversion == 'I')\n\t{\n\t\t/* quote_identifier may or may not allocate a new string. */\n\t\ttext_format_append_string(buf, quote_identifier(str), flags, width);\n\t}\n\telse if (conversion == 'L')\n\t{\n\t\tchar\t   *qstr = quote_literal_cstr(str);\n\n\t\ttext_format_append_string(buf, qstr, flags, width);\n\t\t/* quote_literal_cstr() always allocates a new string */\n\t\tpfree(qstr);\n\t}\n\telse\n\t\ttext_format_append_string(buf, str, flags, width);\n\n\t/* Cleanup. */\n\tpfree(str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fmgr_info",
          "args": [
            "typoutputfunc",
            "&typoutputfinfo"
          ],
          "line": 5314
        },
        "resolved": true,
        "details": {
          "function_name": "fmgr_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "123-127",
          "snippet": "void\nfmgr_info(Oid functionId, FmgrInfo *finfo)\n{\n\tfmgr_info_cxt_security(functionId, finfo, CurrentMemoryContext, false);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nvoid\nfmgr_info(Oid functionId, FmgrInfo *finfo)\n{\n\tfmgr_info_cxt_security(functionId, finfo, CurrentMemoryContext, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getTypeOutputInfo",
          "args": [
            "typid",
            "&typoutputfunc",
            "&typIsVarlena"
          ],
          "line": 5313
        },
        "resolved": true,
        "details": {
          "function_name": "getTypeOutputInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2673-2699",
          "snippet": "void\ngetTypeOutputInfo(Oid type, Oid *typOutput, bool *typIsVarlena)\n{\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type pt;\n\n\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type));\n\tif (!HeapTupleIsValid(typeTuple))\n\t\telog(ERROR, \"cache lookup failed for type %u\", type);\n\tpt = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\tif (!pt->typisdefined)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t errmsg(\"type %s is only a shell\",\n\t\t\t\t\t\tformat_type_be(type))));\n\tif (!OidIsValid(pt->typoutput))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"no output function available for type %s\",\n\t\t\t\t\t\tformat_type_be(type))));\n\n\t*typOutput = pt->typoutput;\n\t*typIsVarlena = (!pt->typbyval) && (pt->typlen == -1);\n\n\tReleaseSysCache(typeTuple);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\ngetTypeOutputInfo(Oid type, Oid *typOutput, bool *typIsVarlena)\n{\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type pt;\n\n\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type));\n\tif (!HeapTupleIsValid(typeTuple))\n\t\telog(ERROR, \"cache lookup failed for type %u\", type);\n\tpt = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\tif (!pt->typisdefined)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t errmsg(\"type %s is only a shell\",\n\t\t\t\t\t\tformat_type_be(type))));\n\tif (!OidIsValid(pt->typoutput))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"no output function available for type %s\",\n\t\t\t\t\t\tformat_type_be(type))));\n\n\t*typOutput = pt->typoutput;\n\t*typIsVarlena = (!pt->typbyval) && (pt->typlen == -1);\n\n\tReleaseSysCache(typeTuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"could not determine data type of format() input\""
          ],
          "line": 5299
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "typid"
          ],
          "line": 5298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fn_expr_argtype",
          "args": [
            "fcinfo->flinfo",
            "arg"
          ],
          "line": 5290
        },
        "resolved": true,
        "details": {
          "function_name": "get_fn_expr_argtype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1994-2005",
          "snippet": "Oid\nget_fn_expr_argtype(FmgrInfo *flinfo, int argnum)\n{\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn InvalidOid;\n\n\treturn get_call_expr_argtype(flinfo->fn_expr, argnum);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nOid\nget_fn_expr_argtype(FmgrInfo *flinfo, int argnum)\n{\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn InvalidOid;\n\n\treturn get_call_expr_argtype(flinfo->fn_expr, argnum);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "arg"
          ],
          "line": 5289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "arg"
          ],
          "line": 5288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"too few arguments for format()\"))"
          ],
          "line": 5281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_atoi",
          "args": [
            "str",
            "sizeof(int)",
            "'\\0'"
          ],
          "line": 5271
        },
        "resolved": true,
        "details": {
          "function_name": "pg_atoi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/numutils.c",
          "lines": "36-109",
          "snippet": "int32\npg_atoi(const char *s, int size, int c)\n{\n\tlong\t\tl;\n\tchar\t   *badp;\n\n\t/*\n\t * Some versions of strtol treat the empty string as an error, but some\n\t * seem not to.  Make an explicit test to be sure we catch it.\n\t */\n\tif (s == NULL)\n\t\telog(ERROR, \"NULL pointer\");\n\tif (*s == 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for integer: \\\"%s\\\"\",\n\t\t\t\t\t\ts)));\n\n\terrno = 0;\n\tl = strtol(s, &badp, 10);\n\n\t/* We made no progress parsing the string, so bail out */\n\tif (s == badp)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for integer: \\\"%s\\\"\",\n\t\t\t\t\t\ts)));\n\n\tswitch (size)\n\t{\n\t\tcase sizeof(int32):\n\t\t\tif (errno == ERANGE\n#if defined(HAVE_LONG_INT_64)\n\t\t\t/* won't get ERANGE on these with 64-bit longs... */\n\t\t\t\t|| l < INT_MIN || l > INT_MAX\n#endif\n\t\t\t\t)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"value \\\"%s\\\" is out of range for type %s\", s,\n\t\t\t\t\t\t\t\t\"integer\")));\n\t\t\tbreak;\n\t\tcase sizeof(int16):\n\t\t\tif (errno == ERANGE || l < SHRT_MIN || l > SHRT_MAX)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"value \\\"%s\\\" is out of range for type %s\", s,\n\t\t\t\t\t\t\t\t\"smallint\")));\n\t\t\tbreak;\n\t\tcase sizeof(int8):\n\t\t\tif (errno == ERANGE || l < SCHAR_MIN || l > SCHAR_MAX)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"value \\\"%s\\\" is out of range for 8-bit integer\", s)));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unsupported result size: %d\", size);\n\t}\n\n\t/*\n\t * Skip any trailing whitespace; if anything but whitespace remains before\n\t * the terminating character, bail out\n\t */\n\twhile (*badp && *badp != c && isspace((unsigned char) *badp))\n\t\tbadp++;\n\n\tif (*badp && *badp != c)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for integer: \\\"%s\\\"\",\n\t\t\t\t\t\ts)));\n\n\treturn (int32) l;\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include <ctype.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include <ctype.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nint32\npg_atoi(const char *s, int size, int c)\n{\n\tlong\t\tl;\n\tchar\t   *badp;\n\n\t/*\n\t * Some versions of strtol treat the empty string as an error, but some\n\t * seem not to.  Make an explicit test to be sure we catch it.\n\t */\n\tif (s == NULL)\n\t\telog(ERROR, \"NULL pointer\");\n\tif (*s == 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for integer: \\\"%s\\\"\",\n\t\t\t\t\t\ts)));\n\n\terrno = 0;\n\tl = strtol(s, &badp, 10);\n\n\t/* We made no progress parsing the string, so bail out */\n\tif (s == badp)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for integer: \\\"%s\\\"\",\n\t\t\t\t\t\ts)));\n\n\tswitch (size)\n\t{\n\t\tcase sizeof(int32):\n\t\t\tif (errno == ERANGE\n#if defined(HAVE_LONG_INT_64)\n\t\t\t/* won't get ERANGE on these with 64-bit longs... */\n\t\t\t\t|| l < INT_MIN || l > INT_MAX\n#endif\n\t\t\t\t)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"value \\\"%s\\\" is out of range for type %s\", s,\n\t\t\t\t\t\t\t\t\"integer\")));\n\t\t\tbreak;\n\t\tcase sizeof(int16):\n\t\t\tif (errno == ERANGE || l < SHRT_MIN || l > SHRT_MAX)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"value \\\"%s\\\" is out of range for type %s\", s,\n\t\t\t\t\t\t\t\t\"smallint\")));\n\t\t\tbreak;\n\t\tcase sizeof(int8):\n\t\t\tif (errno == ERANGE || l < SCHAR_MIN || l > SCHAR_MAX)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"value \\\"%s\\\" is out of range for 8-bit integer\", s)));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unsupported result size: %d\", size);\n\t}\n\n\t/*\n\t * Skip any trailing whitespace; if anything but whitespace remains before\n\t * the terminating character, bail out\n\t */\n\twhile (*badp && *badp != c && isspace((unsigned char) *badp))\n\t\tbadp++;\n\n\tif (*badp && *badp != c)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for integer: \\\"%s\\\"\",\n\t\t\t\t\t\ts)));\n\n\treturn (int32) l;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OutputFunctionCall",
          "args": [
            "&typoutputinfo_width",
            "value"
          ],
          "line": 5268
        },
        "resolved": true,
        "details": {
          "function_name": "OidOutputFunctionCall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1832-1839",
          "snippet": "char *\nOidOutputFunctionCall(Oid functionId, Datum val)\n{\n\tFmgrInfo\tflinfo;\n\n\tfmgr_info(functionId, &flinfo);\n\treturn OutputFunctionCall(&flinfo, val);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nchar *\nOidOutputFunctionCall(Oid functionId, Datum val)\n{\n\tFmgrInfo\tflinfo;\n\n\tfmgr_info(functionId, &flinfo);\n\treturn OutputFunctionCall(&flinfo, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetInt16",
          "args": [
            "value"
          ],
          "line": 5252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetInt32",
          "args": [
            "value"
          ],
          "line": 5250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "typid"
          ],
          "line": 5241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "arg"
          ],
          "line": 5232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "arg"
          ],
          "line": 5231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"too few arguments for format()\"))"
          ],
          "line": 5224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"unrecognized format() type specifier \\\"%c\\\"\",\n\t\t\t\t\t\t\t*cp),\n\t\t\t\t\t errhint(\"For a single \\\"%%\\\" use \\\"%%%%\\\".\"))"
          ],
          "line": 5211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "\"sIL\"",
            "*cp"
          ],
          "line": 5210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text_format_parse_format",
          "args": [
            "cp",
            "end_ptr",
            "&argpos",
            "&widthpos",
            "&flags",
            "&width"
          ],
          "line": 5198
        },
        "resolved": true,
        "details": {
          "function_name": "text_format_parse_format",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "5413-5485",
          "snippet": "static const char *\ntext_format_parse_format(const char *start_ptr, const char *end_ptr,\n\t\t\t\t\t\t int *argpos, int *widthpos,\n\t\t\t\t\t\t int *flags, int *width)\n{\n\tconst char *cp = start_ptr;\n\tint\t\t\tn;\n\n\t/* set defaults for output parameters */\n\t*argpos = -1;\n\t*widthpos = -1;\n\t*flags = 0;\n\t*width = 0;\n\n\t/* try to identify first number */\n\tif (text_format_parse_digits(&cp, end_ptr, &n))\n\t{\n\t\tif (*cp != '$')\n\t\t{\n\t\t\t/* Must be just a width and a type, so we're done */\n\t\t\t*width = n;\n\t\t\treturn cp;\n\t\t}\n\t\t/* The number was argument position */\n\t\t*argpos = n;\n\t\t/* Explicit 0 for argument index is immediately refused */\n\t\tif (n == 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"format specifies argument 0, but arguments are numbered from 1\")));\n\t\tADVANCE_PARSE_POINTER(cp, end_ptr);\n\t}\n\n\t/* Handle flags (only minus is supported now) */\n\twhile (*cp == '-')\n\t{\n\t\t*flags |= TEXT_FORMAT_FLAG_MINUS;\n\t\tADVANCE_PARSE_POINTER(cp, end_ptr);\n\t}\n\n\tif (*cp == '*')\n\t{\n\t\t/* Handle indirect width */\n\t\tADVANCE_PARSE_POINTER(cp, end_ptr);\n\t\tif (text_format_parse_digits(&cp, end_ptr, &n))\n\t\t{\n\t\t\t/* number in this position must be closed by $ */\n\t\t\tif (*cp != '$')\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"width argument position must be ended by \\\"$\\\"\")));\n\t\t\t/* The number was width argument position */\n\t\t\t*widthpos = n;\n\t\t\t/* Explicit 0 for argument index is immediately refused */\n\t\t\tif (n == 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"format specifies argument 0, but arguments are numbered from 1\")));\n\t\t\tADVANCE_PARSE_POINTER(cp, end_ptr);\n\t\t}\n\t\telse\n\t\t\t*widthpos = 0;\t\t/* width's argument position is unspecified */\n\t}\n\telse\n\t{\n\t\t/* Check for direct width specification */\n\t\tif (text_format_parse_digits(&cp, end_ptr, &n))\n\t\t\t*width = n;\n\t}\n\n\t/* cp should now be pointing at type character */\n\treturn cp;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TEXT_FORMAT_FLAG_MINUS\t0x0001\t/* is minus flag present? */"
          ],
          "globals_used": [
            "static const char *text_format_parse_format(const char *start_ptr,\n\t\t\t\t\t\t const char *end_ptr,\n\t\t\t\t\t\t int *argpos, int *widthpos,\n\t\t\t\t\t\t int *flags, int *width);",
            "static void text_format_string_conversion(StringInfo buf, char conversion,\n\t\t\t\t\t\t\t  FmgrInfo *typOutputInfo,\n\t\t\t\t\t\t\t  Datum value, bool isNull,\n\t\t\t\t\t\t\t  int flags, int width);",
            "static void text_format_append_string(StringInfo buf, const char *str,\n\t\t\t\t\t\t  int flags, int width);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define TEXT_FORMAT_FLAG_MINUS\t0x0001\t/* is minus flag present? */\n\nstatic const char *text_format_parse_format(const char *start_ptr,\n\t\t\t\t\t\t const char *end_ptr,\n\t\t\t\t\t\t int *argpos, int *widthpos,\n\t\t\t\t\t\t int *flags, int *width);\nstatic void text_format_string_conversion(StringInfo buf, char conversion,\n\t\t\t\t\t\t\t  FmgrInfo *typOutputInfo,\n\t\t\t\t\t\t\t  Datum value, bool isNull,\n\t\t\t\t\t\t\t  int flags, int width);\nstatic void text_format_append_string(StringInfo buf, const char *str,\n\t\t\t\t\t\t  int flags, int width);\n\nstatic const char *\ntext_format_parse_format(const char *start_ptr, const char *end_ptr,\n\t\t\t\t\t\t int *argpos, int *widthpos,\n\t\t\t\t\t\t int *flags, int *width)\n{\n\tconst char *cp = start_ptr;\n\tint\t\t\tn;\n\n\t/* set defaults for output parameters */\n\t*argpos = -1;\n\t*widthpos = -1;\n\t*flags = 0;\n\t*width = 0;\n\n\t/* try to identify first number */\n\tif (text_format_parse_digits(&cp, end_ptr, &n))\n\t{\n\t\tif (*cp != '$')\n\t\t{\n\t\t\t/* Must be just a width and a type, so we're done */\n\t\t\t*width = n;\n\t\t\treturn cp;\n\t\t}\n\t\t/* The number was argument position */\n\t\t*argpos = n;\n\t\t/* Explicit 0 for argument index is immediately refused */\n\t\tif (n == 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"format specifies argument 0, but arguments are numbered from 1\")));\n\t\tADVANCE_PARSE_POINTER(cp, end_ptr);\n\t}\n\n\t/* Handle flags (only minus is supported now) */\n\twhile (*cp == '-')\n\t{\n\t\t*flags |= TEXT_FORMAT_FLAG_MINUS;\n\t\tADVANCE_PARSE_POINTER(cp, end_ptr);\n\t}\n\n\tif (*cp == '*')\n\t{\n\t\t/* Handle indirect width */\n\t\tADVANCE_PARSE_POINTER(cp, end_ptr);\n\t\tif (text_format_parse_digits(&cp, end_ptr, &n))\n\t\t{\n\t\t\t/* number in this position must be closed by $ */\n\t\t\tif (*cp != '$')\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"width argument position must be ended by \\\"$\\\"\")));\n\t\t\t/* The number was width argument position */\n\t\t\t*widthpos = n;\n\t\t\t/* Explicit 0 for argument index is immediately refused */\n\t\t\tif (n == 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"format specifies argument 0, but arguments are numbered from 1\")));\n\t\t\tADVANCE_PARSE_POINTER(cp, end_ptr);\n\t\t}\n\t\telse\n\t\t\t*widthpos = 0;\t\t/* width's argument position is unspecified */\n\t}\n\telse\n\t{\n\t\t/* Check for direct width specification */\n\t\tif (text_format_parse_digits(&cp, end_ptr, &n))\n\t\t\t*width = n;\n\t}\n\n\t/* cp should now be pointing at type character */\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoCharMacro",
          "args": [
            "&str",
            "*cp"
          ],
          "line": 5193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADVANCE_PARSE_POINTER",
          "args": [
            "cp",
            "end_ptr"
          ],
          "line": 5188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoCharMacro",
          "args": [
            "&str",
            "*cp"
          ],
          "line": 5184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initStringInfo",
          "args": [
            "&str"
          ],
          "line": 5164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "fmt"
          ],
          "line": 5163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "fmt"
          ],
          "line": 5162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 5161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_NARGS",
          "args": [],
          "line": 5156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deconstruct_array",
          "args": [
            "arr",
            "element_type",
            "elmlen",
            "elmbyval",
            "elmalign",
            "&elements",
            "&nulls",
            "&nitems"
          ],
          "line": 5146
        },
        "resolved": true,
        "details": {
          "function_name": "deconstruct_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3460-3519",
          "snippet": "void\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\n\nvoid\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_typlenbyvalalign",
          "args": [
            "element_type",
            "&elmlen",
            "&elmbyval",
            "&elmalign"
          ],
          "line": 5142
        },
        "resolved": true,
        "details": {
          "function_name": "get_typlenbyvalalign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2048-2063",
          "snippet": "void\nget_typlenbyvalalign(Oid typid, int16 *typlen, bool *typbyval,\n\t\t\t\t\t char *typalign)\n{\n\tHeapTuple\ttp;\n\tForm_pg_type typtup;\n\n\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t*typlen = typtup->typlen;\n\t*typbyval = typtup->typbyval;\n\t*typalign = typtup->typalign;\n\tReleaseSysCache(tp);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nget_typlenbyvalalign(Oid typid, int16 *typlen, bool *typbyval,\n\t\t\t\t\t char *typalign)\n{\n\tHeapTuple\ttp;\n\tForm_pg_type typtup;\n\n\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t*typlen = typtup->typlen;\n\t*typbyval = typtup->typbyval;\n\t*typalign = typtup->typalign;\n\tReleaseSysCache(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_ELEMTYPE",
          "args": [
            "arr"
          ],
          "line": 5141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "1"
          ],
          "line": 5138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "OidIsValid(get_base_element_type(get_fn_expr_argtype(fcinfo->flinfo, 1)))"
          ],
          "line": 5135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "get_base_element_type(get_fn_expr_argtype(fcinfo->flinfo, 1))"
          ],
          "line": 5135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_base_element_type",
          "args": [
            "get_fn_expr_argtype(fcinfo->flinfo, 1)"
          ],
          "line": 5135
        },
        "resolved": true,
        "details": {
          "function_name": "get_base_element_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2598-2633",
          "snippet": "Oid\nget_base_element_type(Oid typid)\n{\n\t/*\n\t * We loop to find the bottom base type in a stack of domains.\n\t */\n\tfor (;;)\n\t{\n\t\tHeapTuple\ttup;\n\t\tForm_pg_type typTup;\n\n\t\ttup = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\t\tif (!HeapTupleIsValid(tup))\n\t\t\tbreak;\n\t\ttypTup = (Form_pg_type) GETSTRUCT(tup);\n\t\tif (typTup->typtype != TYPTYPE_DOMAIN)\n\t\t{\n\t\t\t/* Not a domain, so stop descending */\n\t\t\tOid\t\t\tresult;\n\n\t\t\t/* This test must match get_element_type */\n\t\t\tif (typTup->typlen == -1)\n\t\t\t\tresult = typTup->typelem;\n\t\t\telse\n\t\t\t\tresult = InvalidOid;\n\t\t\tReleaseSysCache(tup);\n\t\t\treturn result;\n\t\t}\n\n\t\ttypid = typTup->typbasetype;\n\t\tReleaseSysCache(tup);\n\t}\n\n\t/* Like get_element_type, silently return InvalidOid for bogus input */\n\treturn InvalidOid;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nOid\nget_base_element_type(Oid typid)\n{\n\t/*\n\t * We loop to find the bottom base type in a stack of domains.\n\t */\n\tfor (;;)\n\t{\n\t\tHeapTuple\ttup;\n\t\tForm_pg_type typTup;\n\n\t\ttup = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\t\tif (!HeapTupleIsValid(tup))\n\t\t\tbreak;\n\t\ttypTup = (Form_pg_type) GETSTRUCT(tup);\n\t\tif (typTup->typtype != TYPTYPE_DOMAIN)\n\t\t{\n\t\t\t/* Not a domain, so stop descending */\n\t\t\tOid\t\t\tresult;\n\n\t\t\t/* This test must match get_element_type */\n\t\t\tif (typTup->typlen == -1)\n\t\t\t\tresult = typTup->typelem;\n\t\t\telse\n\t\t\t\tresult = InvalidOid;\n\t\t\tReleaseSysCache(tup);\n\t\t\treturn result;\n\t\t}\n\n\t\ttypid = typTup->typbasetype;\n\t\tReleaseSysCache(tup);\n\t}\n\n\t/* Like get_element_type, silently return InvalidOid for bogus input */\n\treturn InvalidOid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "1"
          ],
          "line": 5124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "PG_NARGS() == 2"
          ],
          "line": 5121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_NARGS",
          "args": [],
          "line": 5121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fn_expr_variadic",
          "args": [
            "fcinfo->flinfo"
          ],
          "line": 5112
        },
        "resolved": true,
        "details": {
          "function_name": "get_fn_expr_variadic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "2128-2146",
          "snippet": "bool\nget_fn_expr_variadic(FmgrInfo *flinfo)\n{\n\tNode\t   *expr;\n\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn false;\n\n\texpr = flinfo->fn_expr;\n\n\tif (IsA(expr, FuncExpr))\n\t\treturn ((FuncExpr *) expr)->funcvariadic;\n\telse\n\t\treturn false;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nbool\nget_fn_expr_variadic(FmgrInfo *flinfo)\n{\n\tNode\t   *expr;\n\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn false;\n\n\texpr = flinfo->fn_expr;\n\n\tif (IsA(expr, FuncExpr))\n\t\treturn ((FuncExpr *) expr)->funcvariadic;\n\telse\n\t\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 5109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "0"
          ],
          "line": 5108
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int32 text_length(Datum str);\nstatic void appendStringInfoText(StringInfo str, const text *t);\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\nstatic StringInfo makeStringAggState(FunctionCallInfo fcinfo);\nstatic bool text_format_parse_digits(const char **ptr, const char *end_ptr,\n\t\t\t\t\t\t int *value);\nstatic const char *text_format_parse_format(const char *start_ptr,\n\t\t\t\t\t\t const char *end_ptr,\n\t\t\t\t\t\t int *argpos, int *widthpos,\n\t\t\t\t\t\t int *flags, int *width);\nstatic void text_format_string_conversion(StringInfo buf, char conversion,\n\t\t\t\t\t\t\t  FmgrInfo *typOutputInfo,\n\t\t\t\t\t\t\t  Datum value, bool isNull,\n\t\t\t\t\t\t\t  int flags, int width);\nstatic void text_format_append_string(StringInfo buf, const char *str,\n\t\t\t\t\t\t  int flags, int width);\n\nDatum\ntext_format(PG_FUNCTION_ARGS)\n{\n\ttext\t   *fmt;\n\tStringInfoData str;\n\tconst char *cp;\n\tconst char *start_ptr;\n\tconst char *end_ptr;\n\ttext\t   *result;\n\tint\t\t\targ;\n\tbool\t\tfuncvariadic;\n\tint\t\t\tnargs;\n\tDatum\t   *elements = NULL;\n\tbool\t   *nulls = NULL;\n\tOid\t\t\telement_type = InvalidOid;\n\tOid\t\t\tprev_type = InvalidOid;\n\tOid\t\t\tprev_width_type = InvalidOid;\n\tFmgrInfo\ttypoutputfinfo;\n\tFmgrInfo\ttypoutputinfo_width;\n\n\t/* When format string is null, immediately return null */\n\tif (PG_ARGISNULL(0))\n\t\tPG_RETURN_NULL();\n\n\t/* If argument is marked VARIADIC, expand array into elements */\n\tif (get_fn_expr_variadic(fcinfo->flinfo))\n\t{\n\t\tArrayType  *arr;\n\t\tint16\t\telmlen;\n\t\tbool\t\telmbyval;\n\t\tchar\t\telmalign;\n\t\tint\t\t\tnitems;\n\n\t\t/* Should have just the one argument */\n\t\tAssert(PG_NARGS() == 2);\n\n\t\t/* If argument is NULL, we treat it as zero-length array */\n\t\tif (PG_ARGISNULL(1))\n\t\t\tnitems = 0;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Non-null argument had better be an array.  We assume that any\n\t\t\t * call context that could let get_fn_expr_variadic return true\n\t\t\t * will have checked that a VARIADIC-labeled parameter actually is\n\t\t\t * an array.  So it should be okay to just Assert that it's an\n\t\t\t * array rather than doing a full-fledged error check.\n\t\t\t */\n\t\t\tAssert(OidIsValid(get_base_element_type(get_fn_expr_argtype(fcinfo->flinfo, 1))));\n\n\t\t\t/* OK, safe to fetch the array value */\n\t\t\tarr = PG_GETARG_ARRAYTYPE_P(1);\n\n\t\t\t/* Get info about array element type */\n\t\t\telement_type = ARR_ELEMTYPE(arr);\n\t\t\tget_typlenbyvalalign(element_type,\n\t\t\t\t\t\t\t\t &elmlen, &elmbyval, &elmalign);\n\n\t\t\t/* Extract all array elements */\n\t\t\tdeconstruct_array(arr, element_type, elmlen, elmbyval, elmalign,\n\t\t\t\t\t\t\t  &elements, &nulls, &nitems);\n\t\t}\n\n\t\tnargs = nitems + 1;\n\t\tfuncvariadic = true;\n\t}\n\telse\n\t{\n\t\t/* Non-variadic case, we'll process the arguments individually */\n\t\tnargs = PG_NARGS();\n\t\tfuncvariadic = false;\n\t}\n\n\t/* Setup for main loop. */\n\tfmt = PG_GETARG_TEXT_PP(0);\n\tstart_ptr = VARDATA_ANY(fmt);\n\tend_ptr = start_ptr + VARSIZE_ANY_EXHDR(fmt);\n\tinitStringInfo(&str);\n\targ = 1;\t\t\t\t\t/* next argument position to print */\n\n\t/* Scan format string, looking for conversion specifiers. */\n\tfor (cp = start_ptr; cp < end_ptr; cp++)\n\t{\n\t\tint\t\t\targpos;\n\t\tint\t\t\twidthpos;\n\t\tint\t\t\tflags;\n\t\tint\t\t\twidth;\n\t\tDatum\t\tvalue;\n\t\tbool\t\tisNull;\n\t\tOid\t\t\ttypid;\n\n\t\t/*\n\t\t * If it's not the start of a conversion specifier, just copy it to\n\t\t * the output buffer.\n\t\t */\n\t\tif (*cp != '%')\n\t\t{\n\t\t\tappendStringInfoCharMacro(&str, *cp);\n\t\t\tcontinue;\n\t\t}\n\n\t\tADVANCE_PARSE_POINTER(cp, end_ptr);\n\n\t\t/* Easy case: %% outputs a single % */\n\t\tif (*cp == '%')\n\t\t{\n\t\t\tappendStringInfoCharMacro(&str, *cp);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Parse the optional portions of the format specifier */\n\t\tcp = text_format_parse_format(cp, end_ptr,\n\t\t\t\t\t\t\t\t\t  &argpos, &widthpos,\n\t\t\t\t\t\t\t\t\t  &flags, &width);\n\n\t\t/*\n\t\t * Next we should see the main conversion specifier.  Whether or not\n\t\t * an argument position was present, it's known that at least one\n\t\t * character remains in the string at this point.  Experience suggests\n\t\t * that it's worth checking that that character is one of the expected\n\t\t * ones before we try to fetch arguments, so as to produce the least\n\t\t * confusing response to a mis-formatted specifier.\n\t\t */\n\t\tif (strchr(\"sIL\", *cp) == NULL)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"unrecognized format() type specifier \\\"%c\\\"\",\n\t\t\t\t\t\t\t*cp),\n\t\t\t\t\t errhint(\"For a single \\\"%%\\\" use \\\"%%%%\\\".\")));\n\n\t\t/* If indirect width was specified, get its value */\n\t\tif (widthpos >= 0)\n\t\t{\n\t\t\t/* Collect the specified or next argument position */\n\t\t\tif (widthpos > 0)\n\t\t\t\targ = widthpos;\n\t\t\tif (arg >= nargs)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"too few arguments for format()\")));\n\n\t\t\t/* Get the value and type of the selected argument */\n\t\t\tif (!funcvariadic)\n\t\t\t{\n\t\t\t\tvalue = PG_GETARG_DATUM(arg);\n\t\t\t\tisNull = PG_ARGISNULL(arg);\n\t\t\t\ttypid = get_fn_expr_argtype(fcinfo->flinfo, arg);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvalue = elements[arg - 1];\n\t\t\t\tisNull = nulls[arg - 1];\n\t\t\t\ttypid = element_type;\n\t\t\t}\n\t\t\tif (!OidIsValid(typid))\n\t\t\t\telog(ERROR, \"could not determine data type of format() input\");\n\n\t\t\targ++;\n\n\t\t\t/* We can treat NULL width the same as zero */\n\t\t\tif (isNull)\n\t\t\t\twidth = 0;\n\t\t\telse if (typid == INT4OID)\n\t\t\t\twidth = DatumGetInt32(value);\n\t\t\telse if (typid == INT2OID)\n\t\t\t\twidth = DatumGetInt16(value);\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* For less-usual datatypes, convert to text then to int */\n\t\t\t\tchar\t   *str;\n\n\t\t\t\tif (typid != prev_width_type)\n\t\t\t\t{\n\t\t\t\t\tOid\t\t\ttypoutputfunc;\n\t\t\t\t\tbool\t\ttypIsVarlena;\n\n\t\t\t\t\tgetTypeOutputInfo(typid, &typoutputfunc, &typIsVarlena);\n\t\t\t\t\tfmgr_info(typoutputfunc, &typoutputinfo_width);\n\t\t\t\t\tprev_width_type = typid;\n\t\t\t\t}\n\n\t\t\t\tstr = OutputFunctionCall(&typoutputinfo_width, value);\n\n\t\t\t\t/* pg_atoi will complain about bad data or overflow */\n\t\t\t\twidth = pg_atoi(str, sizeof(int), '\\0');\n\n\t\t\t\tpfree(str);\n\t\t\t}\n\t\t}\n\n\t\t/* Collect the specified or next argument position */\n\t\tif (argpos > 0)\n\t\t\targ = argpos;\n\t\tif (arg >= nargs)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"too few arguments for format()\")));\n\n\t\t/* Get the value and type of the selected argument */\n\t\tif (!funcvariadic)\n\t\t{\n\t\t\tvalue = PG_GETARG_DATUM(arg);\n\t\t\tisNull = PG_ARGISNULL(arg);\n\t\t\ttypid = get_fn_expr_argtype(fcinfo->flinfo, arg);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvalue = elements[arg - 1];\n\t\t\tisNull = nulls[arg - 1];\n\t\t\ttypid = element_type;\n\t\t}\n\t\tif (!OidIsValid(typid))\n\t\t\telog(ERROR, \"could not determine data type of format() input\");\n\n\t\targ++;\n\n\t\t/*\n\t\t * Get the appropriate typOutput function, reusing previous one if\n\t\t * same type as previous argument.  That's particularly useful in the\n\t\t * variadic-array case, but often saves work even for ordinary calls.\n\t\t */\n\t\tif (typid != prev_type)\n\t\t{\n\t\t\tOid\t\t\ttypoutputfunc;\n\t\t\tbool\t\ttypIsVarlena;\n\n\t\t\tgetTypeOutputInfo(typid, &typoutputfunc, &typIsVarlena);\n\t\t\tfmgr_info(typoutputfunc, &typoutputfinfo);\n\t\t\tprev_type = typid;\n\t\t}\n\n\t\t/*\n\t\t * And now we can format the value.\n\t\t */\n\t\tswitch (*cp)\n\t\t{\n\t\t\tcase 's':\n\t\t\tcase 'I':\n\t\t\tcase 'L':\n\t\t\t\ttext_format_string_conversion(&str, *cp, &typoutputfinfo,\n\t\t\t\t\t\t\t\t\t\t\t  value, isNull,\n\t\t\t\t\t\t\t\t\t\t\t  flags, width);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* should not get here, because of previous check */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"unrecognized format() type specifier \\\"%c\\\"\",\n\t\t\t\t\t\t\t\t*cp),\n\t\t\t\t\t\t errhint(\"For a single \\\"%%\\\" use \\\"%%%%\\\".\")));\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Don't need deconstruct_array results anymore. */\n\tif (elements != NULL)\n\t\tpfree(elements);\n\tif (nulls != NULL)\n\t\tpfree(nulls);\n\n\t/* Generate results. */\n\tresult = cstring_to_text_with_len(str.data, str.len);\n\tpfree(str.data);\n\n\tPG_RETURN_TEXT_P(result);\n}"
  },
  {
    "function_name": "text_reverse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "5032-5067",
    "snippet": "Datum\ntext_reverse(PG_FUNCTION_ARGS)\n{\n\ttext\t   *str = PG_GETARG_TEXT_PP(0);\n\tconst char *p = VARDATA_ANY(str);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(str);\n\tconst char *endp = p + len;\n\ttext\t   *result;\n\tchar\t   *dst;\n\n\tresult = palloc(len + VARHDRSZ);\n\tdst = (char *) VARDATA(result) + len;\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\n\tif (pg_database_encoding_max_length() > 1)\n\t{\n\t\t/* multibyte version */\n\t\twhile (p < endp)\n\t\t{\n\t\t\tint\t\t\tsz;\n\n\t\t\tsz = pg_mblen(p);\n\t\t\tdst -= sz;\n\t\t\tmemcpy(dst, p, sz);\n\t\t\tp += sz;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* single byte version */\n\t\twhile (p < endp)\n\t\t\t*(--dst) = *p++;\n\t}\n\n\tPG_RETURN_TEXT_P(result);\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int32 text_length(Datum str);",
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "result"
          ],
          "line": 5066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst",
            "p",
            "sz"
          ],
          "line": 5055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_mblen",
          "args": [
            "p"
          ],
          "line": 5053
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mblen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "759-763",
          "snippet": "int\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nint\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_database_encoding_max_length",
          "args": [],
          "line": 5046
        },
        "resolved": true,
        "details": {
          "function_name": "pg_database_encoding_max_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "1832-1836",
          "snippet": "int\npg_database_encoding_max_length(void)\n{\n\treturn pg_wchar_table[GetDatabaseEncoding()].maxmblen;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nconst pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};\n\nint\npg_database_encoding_max_length(void)\n{\n\treturn pg_wchar_table[GetDatabaseEncoding()].maxmblen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "result",
            "len + VARHDRSZ"
          ],
          "line": 5044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA",
          "args": [
            "result"
          ],
          "line": 5043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "len + VARHDRSZ"
          ],
          "line": 5042
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "str"
          ],
          "line": 5037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "str"
          ],
          "line": 5036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 5035
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int32 text_length(Datum str);\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\n\nDatum\ntext_reverse(PG_FUNCTION_ARGS)\n{\n\ttext\t   *str = PG_GETARG_TEXT_PP(0);\n\tconst char *p = VARDATA_ANY(str);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(str);\n\tconst char *endp = p + len;\n\ttext\t   *result;\n\tchar\t   *dst;\n\n\tresult = palloc(len + VARHDRSZ);\n\tdst = (char *) VARDATA(result) + len;\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\n\tif (pg_database_encoding_max_length() > 1)\n\t{\n\t\t/* multibyte version */\n\t\twhile (p < endp)\n\t\t{\n\t\t\tint\t\t\tsz;\n\n\t\t\tsz = pg_mblen(p);\n\t\t\tdst -= sz;\n\t\t\tmemcpy(dst, p, sz);\n\t\t\tp += sz;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* single byte version */\n\t\twhile (p < endp)\n\t\t\t*(--dst) = *p++;\n\t}\n\n\tPG_RETURN_TEXT_P(result);\n}"
  },
  {
    "function_name": "text_right",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "5011-5027",
    "snippet": "Datum\ntext_right(PG_FUNCTION_ARGS)\n{\n\ttext\t   *str = PG_GETARG_TEXT_PP(0);\n\tconst char *p = VARDATA_ANY(str);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(str);\n\tint\t\t\tn = PG_GETARG_INT32(1);\n\tint\t\t\toff;\n\n\tif (n < 0)\n\t\tn = -n;\n\telse\n\t\tn = pg_mbstrlen_with_len(p, len) - n;\n\toff = pg_mbcharcliplen(p, len, n);\n\n\tPG_RETURN_TEXT_P(cstring_to_text_with_len(p + off, len - off));\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int32 text_length(Datum str);",
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "cstring_to_text_with_len(p + off, len - off)"
          ],
          "line": 5026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cstring_to_text_with_len",
          "args": [
            "p + off",
            "len - off"
          ],
          "line": 5026
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "160-169",
          "snippet": "text *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_mbcharcliplen",
          "args": [
            "p",
            "len",
            "n"
          ],
          "line": 5024
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mbcharcliplen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "861-883",
          "snippet": "int\npg_mbcharcliplen(const char *mbstr, int len, int limit)\n{\n\tint\t\t\tclen = 0;\n\tint\t\t\tnch = 0;\n\tint\t\t\tl;\n\n\t/* optimization for single byte encoding */\n\tif (pg_database_encoding_max_length() == 1)\n\t\treturn cliplen(mbstr, len, limit);\n\n\twhile (len > 0 && *mbstr)\n\t{\n\t\tl = pg_mblen(mbstr);\n\t\tnch++;\n\t\tif (nch > limit)\n\t\t\tbreak;\n\t\tclen += l;\n\t\tlen -= l;\n\t\tmbstr += l;\n\t}\n\treturn clen;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tcliplen(const char *str, int len, int limit);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic int\tcliplen(const char *str, int len, int limit);\n\nint\npg_mbcharcliplen(const char *mbstr, int len, int limit)\n{\n\tint\t\t\tclen = 0;\n\tint\t\t\tnch = 0;\n\tint\t\t\tl;\n\n\t/* optimization for single byte encoding */\n\tif (pg_database_encoding_max_length() == 1)\n\t\treturn cliplen(mbstr, len, limit);\n\n\twhile (len > 0 && *mbstr)\n\t{\n\t\tl = pg_mblen(mbstr);\n\t\tnch++;\n\t\tif (nch > limit)\n\t\t\tbreak;\n\t\tclen += l;\n\t\tlen -= l;\n\t\tmbstr += l;\n\t}\n\treturn clen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_mbstrlen_with_len",
          "args": [
            "p",
            "len"
          ],
          "line": 5023
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mbstrlen_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "793-811",
          "snippet": "int\npg_mbstrlen_with_len(const char *mbstr, int limit)\n{\n\tint\t\t\tlen = 0;\n\n\t/* optimization for single byte encoding */\n\tif (pg_database_encoding_max_length() == 1)\n\t\treturn limit;\n\n\twhile (limit > 0 && *mbstr)\n\t{\n\t\tint\t\t\tl = pg_mblen(mbstr);\n\n\t\tlimit -= l;\n\t\tmbstr += l;\n\t\tlen++;\n\t}\n\treturn len;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tcliplen(const char *str, int len, int limit);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic int\tcliplen(const char *str, int len, int limit);\n\nint\npg_mbstrlen_with_len(const char *mbstr, int limit)\n{\n\tint\t\t\tlen = 0;\n\n\t/* optimization for single byte encoding */\n\tif (pg_database_encoding_max_length() == 1)\n\t\treturn limit;\n\n\twhile (limit > 0 && *mbstr)\n\t{\n\t\tint\t\t\tl = pg_mblen(mbstr);\n\n\t\tlimit -= l;\n\t\tmbstr += l;\n\t\tlen++;\n\t}\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "1"
          ],
          "line": 5017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "str"
          ],
          "line": 5016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "str"
          ],
          "line": 5015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 5014
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int32 text_length(Datum str);\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\n\nDatum\ntext_right(PG_FUNCTION_ARGS)\n{\n\ttext\t   *str = PG_GETARG_TEXT_PP(0);\n\tconst char *p = VARDATA_ANY(str);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(str);\n\tint\t\t\tn = PG_GETARG_INT32(1);\n\tint\t\t\toff;\n\n\tif (n < 0)\n\t\tn = -n;\n\telse\n\t\tn = pg_mbstrlen_with_len(p, len) - n;\n\toff = pg_mbcharcliplen(p, len, n);\n\n\tPG_RETURN_TEXT_P(cstring_to_text_with_len(p + off, len - off));\n}"
  },
  {
    "function_name": "text_left",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "4991-5005",
    "snippet": "Datum\ntext_left(PG_FUNCTION_ARGS)\n{\n\ttext\t   *str = PG_GETARG_TEXT_PP(0);\n\tconst char *p = VARDATA_ANY(str);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(str);\n\tint\t\t\tn = PG_GETARG_INT32(1);\n\tint\t\t\trlen;\n\n\tif (n < 0)\n\t\tn = pg_mbstrlen_with_len(p, len) + n;\n\trlen = pg_mbcharcliplen(p, len, n);\n\n\tPG_RETURN_TEXT_P(cstring_to_text_with_len(p, rlen));\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int32 text_length(Datum str);",
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "cstring_to_text_with_len(p, rlen)"
          ],
          "line": 5004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cstring_to_text_with_len",
          "args": [
            "p",
            "rlen"
          ],
          "line": 5004
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "160-169",
          "snippet": "text *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_mbcharcliplen",
          "args": [
            "p",
            "len",
            "n"
          ],
          "line": 5002
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mbcharcliplen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "861-883",
          "snippet": "int\npg_mbcharcliplen(const char *mbstr, int len, int limit)\n{\n\tint\t\t\tclen = 0;\n\tint\t\t\tnch = 0;\n\tint\t\t\tl;\n\n\t/* optimization for single byte encoding */\n\tif (pg_database_encoding_max_length() == 1)\n\t\treturn cliplen(mbstr, len, limit);\n\n\twhile (len > 0 && *mbstr)\n\t{\n\t\tl = pg_mblen(mbstr);\n\t\tnch++;\n\t\tif (nch > limit)\n\t\t\tbreak;\n\t\tclen += l;\n\t\tlen -= l;\n\t\tmbstr += l;\n\t}\n\treturn clen;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tcliplen(const char *str, int len, int limit);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic int\tcliplen(const char *str, int len, int limit);\n\nint\npg_mbcharcliplen(const char *mbstr, int len, int limit)\n{\n\tint\t\t\tclen = 0;\n\tint\t\t\tnch = 0;\n\tint\t\t\tl;\n\n\t/* optimization for single byte encoding */\n\tif (pg_database_encoding_max_length() == 1)\n\t\treturn cliplen(mbstr, len, limit);\n\n\twhile (len > 0 && *mbstr)\n\t{\n\t\tl = pg_mblen(mbstr);\n\t\tnch++;\n\t\tif (nch > limit)\n\t\t\tbreak;\n\t\tclen += l;\n\t\tlen -= l;\n\t\tmbstr += l;\n\t}\n\treturn clen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_mbstrlen_with_len",
          "args": [
            "p",
            "len"
          ],
          "line": 5001
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mbstrlen_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "793-811",
          "snippet": "int\npg_mbstrlen_with_len(const char *mbstr, int limit)\n{\n\tint\t\t\tlen = 0;\n\n\t/* optimization for single byte encoding */\n\tif (pg_database_encoding_max_length() == 1)\n\t\treturn limit;\n\n\twhile (limit > 0 && *mbstr)\n\t{\n\t\tint\t\t\tl = pg_mblen(mbstr);\n\n\t\tlimit -= l;\n\t\tmbstr += l;\n\t\tlen++;\n\t}\n\treturn len;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tcliplen(const char *str, int len, int limit);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic int\tcliplen(const char *str, int len, int limit);\n\nint\npg_mbstrlen_with_len(const char *mbstr, int limit)\n{\n\tint\t\t\tlen = 0;\n\n\t/* optimization for single byte encoding */\n\tif (pg_database_encoding_max_length() == 1)\n\t\treturn limit;\n\n\twhile (limit > 0 && *mbstr)\n\t{\n\t\tint\t\t\tl = pg_mblen(mbstr);\n\n\t\tlimit -= l;\n\t\tmbstr += l;\n\t\tlen++;\n\t}\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "1"
          ],
          "line": 4997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "str"
          ],
          "line": 4996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "str"
          ],
          "line": 4995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 4994
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int32 text_length(Datum str);\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\n\nDatum\ntext_left(PG_FUNCTION_ARGS)\n{\n\ttext\t   *str = PG_GETARG_TEXT_PP(0);\n\tconst char *p = VARDATA_ANY(str);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(str);\n\tint\t\t\tn = PG_GETARG_INT32(1);\n\tint\t\t\trlen;\n\n\tif (n < 0)\n\t\tn = pg_mbstrlen_with_len(p, len) + n;\n\trlen = pg_mbcharcliplen(p, len, n);\n\n\tPG_RETURN_TEXT_P(cstring_to_text_with_len(p, rlen));\n}"
  },
  {
    "function_name": "text_concat_ws",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "4970-4985",
    "snippet": "Datum\ntext_concat_ws(PG_FUNCTION_ARGS)\n{\n\tchar\t   *sep;\n\ttext\t   *result;\n\n\t/* return NULL when separator is NULL */\n\tif (PG_ARGISNULL(0))\n\t\tPG_RETURN_NULL();\n\tsep = text_to_cstring(PG_GETARG_TEXT_PP(0));\n\n\tresult = concat_internal(sep, 1, fcinfo);\n\tif (result == NULL)\n\t\tPG_RETURN_NULL();\n\tPG_RETURN_TEXT_P(result);\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);",
      "static StringInfo makeStringAggState(FunctionCallInfo fcinfo);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "result"
          ],
          "line": 4984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 4983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "concat_internal",
          "args": [
            "sep",
            "1",
            "fcinfo"
          ],
          "line": 4981
        },
        "resolved": true,
        "details": {
          "function_name": "concat_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "4875-4950",
          "snippet": "static text *\nconcat_internal(const char *sepstr, int argidx,\n\t\t\t\tFunctionCallInfo fcinfo)\n{\n\ttext\t   *result;\n\tStringInfoData str;\n\tFmgrInfo   *foutcache;\n\tbool\t\tfirst_arg = true;\n\tint\t\t\ti;\n\n\t/*\n\t * concat(VARIADIC some-array) is essentially equivalent to\n\t * array_to_text(), ie concat the array elements with the given separator.\n\t * So we just pass the case off to that code.\n\t */\n\tif (get_fn_expr_variadic(fcinfo->flinfo))\n\t{\n\t\tArrayType  *arr;\n\n\t\t/* Should have just the one argument */\n\t\tAssert(argidx == PG_NARGS() - 1);\n\n\t\t/* concat(VARIADIC NULL) is defined as NULL */\n\t\tif (PG_ARGISNULL(argidx))\n\t\t\treturn NULL;\n\n\t\t/*\n\t\t * Non-null argument had better be an array.  We assume that any call\n\t\t * context that could let get_fn_expr_variadic return true will have\n\t\t * checked that a VARIADIC-labeled parameter actually is an array.  So\n\t\t * it should be okay to just Assert that it's an array rather than\n\t\t * doing a full-fledged error check.\n\t\t */\n\t\tAssert(OidIsValid(get_base_element_type(get_fn_expr_argtype(fcinfo->flinfo, argidx))));\n\n\t\t/* OK, safe to fetch the array value */\n\t\tarr = PG_GETARG_ARRAYTYPE_P(argidx);\n\n\t\t/*\n\t\t * And serialize the array.  We tell array_to_text to ignore null\n\t\t * elements, which matches the behavior of the loop below.\n\t\t */\n\t\treturn array_to_text_internal(fcinfo, arr, sepstr, NULL);\n\t}\n\n\t/* Normal case without explicit VARIADIC marker */\n\tinitStringInfo(&str);\n\n\t/* Get output function info, building it if first time through */\n\tfoutcache = (FmgrInfo *) fcinfo->flinfo->fn_extra;\n\tif (foutcache == NULL)\n\t\tfoutcache = build_concat_foutcache(fcinfo, argidx);\n\n\tfor (i = argidx; i < PG_NARGS(); i++)\n\t{\n\t\tif (!PG_ARGISNULL(i))\n\t\t{\n\t\t\tDatum\t\tvalue = PG_GETARG_DATUM(i);\n\n\t\t\t/* add separator if appropriate */\n\t\t\tif (first_arg)\n\t\t\t\tfirst_arg = false;\n\t\t\telse\n\t\t\t\tappendStringInfoString(&str, sepstr);\n\n\t\t\t/* call the appropriate type output function, append the result */\n\t\t\tappendStringInfoString(&str,\n\t\t\t\t\t\t\t\t   OutputFunctionCall(&foutcache[i], value));\n\t\t}\n\t}\n\n\tresult = cstring_to_text_with_len(str.data, str.len);\n\tpfree(str.data);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int32 text_length(Datum str);",
            "static StringInfo makeStringAggState(FunctionCallInfo fcinfo);",
            "static bool text_format_parse_digits(const char **ptr, const char *end_ptr,\n\t\t\t\t\t\t int *value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int32 text_length(Datum str);\nstatic StringInfo makeStringAggState(FunctionCallInfo fcinfo);\nstatic bool text_format_parse_digits(const char **ptr, const char *end_ptr,\n\t\t\t\t\t\t int *value);\n\nstatic text *\nconcat_internal(const char *sepstr, int argidx,\n\t\t\t\tFunctionCallInfo fcinfo)\n{\n\ttext\t   *result;\n\tStringInfoData str;\n\tFmgrInfo   *foutcache;\n\tbool\t\tfirst_arg = true;\n\tint\t\t\ti;\n\n\t/*\n\t * concat(VARIADIC some-array) is essentially equivalent to\n\t * array_to_text(), ie concat the array elements with the given separator.\n\t * So we just pass the case off to that code.\n\t */\n\tif (get_fn_expr_variadic(fcinfo->flinfo))\n\t{\n\t\tArrayType  *arr;\n\n\t\t/* Should have just the one argument */\n\t\tAssert(argidx == PG_NARGS() - 1);\n\n\t\t/* concat(VARIADIC NULL) is defined as NULL */\n\t\tif (PG_ARGISNULL(argidx))\n\t\t\treturn NULL;\n\n\t\t/*\n\t\t * Non-null argument had better be an array.  We assume that any call\n\t\t * context that could let get_fn_expr_variadic return true will have\n\t\t * checked that a VARIADIC-labeled parameter actually is an array.  So\n\t\t * it should be okay to just Assert that it's an array rather than\n\t\t * doing a full-fledged error check.\n\t\t */\n\t\tAssert(OidIsValid(get_base_element_type(get_fn_expr_argtype(fcinfo->flinfo, argidx))));\n\n\t\t/* OK, safe to fetch the array value */\n\t\tarr = PG_GETARG_ARRAYTYPE_P(argidx);\n\n\t\t/*\n\t\t * And serialize the array.  We tell array_to_text to ignore null\n\t\t * elements, which matches the behavior of the loop below.\n\t\t */\n\t\treturn array_to_text_internal(fcinfo, arr, sepstr, NULL);\n\t}\n\n\t/* Normal case without explicit VARIADIC marker */\n\tinitStringInfo(&str);\n\n\t/* Get output function info, building it if first time through */\n\tfoutcache = (FmgrInfo *) fcinfo->flinfo->fn_extra;\n\tif (foutcache == NULL)\n\t\tfoutcache = build_concat_foutcache(fcinfo, argidx);\n\n\tfor (i = argidx; i < PG_NARGS(); i++)\n\t{\n\t\tif (!PG_ARGISNULL(i))\n\t\t{\n\t\t\tDatum\t\tvalue = PG_GETARG_DATUM(i);\n\n\t\t\t/* add separator if appropriate */\n\t\t\tif (first_arg)\n\t\t\t\tfirst_arg = false;\n\t\t\telse\n\t\t\t\tappendStringInfoString(&str, sepstr);\n\n\t\t\t/* call the appropriate type output function, append the result */\n\t\t\tappendStringInfoString(&str,\n\t\t\t\t\t\t\t\t   OutputFunctionCall(&foutcache[i], value));\n\t\t}\n\t}\n\n\tresult = cstring_to_text_with_len(str.data, str.len);\n\tpfree(str.data);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "text_to_cstring",
          "args": [
            "PG_GETARG_TEXT_PP(0)"
          ],
          "line": 4979
        },
        "resolved": true,
        "details": {
          "function_name": "text_to_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "181-197",
          "snippet": "char *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nchar *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 4979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 4978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "0"
          ],
          "line": 4977
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\nstatic StringInfo makeStringAggState(FunctionCallInfo fcinfo);\n\nDatum\ntext_concat_ws(PG_FUNCTION_ARGS)\n{\n\tchar\t   *sep;\n\ttext\t   *result;\n\n\t/* return NULL when separator is NULL */\n\tif (PG_ARGISNULL(0))\n\t\tPG_RETURN_NULL();\n\tsep = text_to_cstring(PG_GETARG_TEXT_PP(0));\n\n\tresult = concat_internal(sep, 1, fcinfo);\n\tif (result == NULL)\n\t\tPG_RETURN_NULL();\n\tPG_RETURN_TEXT_P(result);\n}"
  },
  {
    "function_name": "text_concat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "4955-4964",
    "snippet": "Datum\ntext_concat(PG_FUNCTION_ARGS)\n{\n\ttext\t   *result;\n\n\tresult = concat_internal(\"\", 0, fcinfo);\n\tif (result == NULL)\n\t\tPG_RETURN_NULL();\n\tPG_RETURN_TEXT_P(result);\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);",
      "static StringInfo makeStringAggState(FunctionCallInfo fcinfo);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "result"
          ],
          "line": 4963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 4962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "concat_internal",
          "args": [
            "\"\"",
            "0",
            "fcinfo"
          ],
          "line": 4960
        },
        "resolved": true,
        "details": {
          "function_name": "concat_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "4875-4950",
          "snippet": "static text *\nconcat_internal(const char *sepstr, int argidx,\n\t\t\t\tFunctionCallInfo fcinfo)\n{\n\ttext\t   *result;\n\tStringInfoData str;\n\tFmgrInfo   *foutcache;\n\tbool\t\tfirst_arg = true;\n\tint\t\t\ti;\n\n\t/*\n\t * concat(VARIADIC some-array) is essentially equivalent to\n\t * array_to_text(), ie concat the array elements with the given separator.\n\t * So we just pass the case off to that code.\n\t */\n\tif (get_fn_expr_variadic(fcinfo->flinfo))\n\t{\n\t\tArrayType  *arr;\n\n\t\t/* Should have just the one argument */\n\t\tAssert(argidx == PG_NARGS() - 1);\n\n\t\t/* concat(VARIADIC NULL) is defined as NULL */\n\t\tif (PG_ARGISNULL(argidx))\n\t\t\treturn NULL;\n\n\t\t/*\n\t\t * Non-null argument had better be an array.  We assume that any call\n\t\t * context that could let get_fn_expr_variadic return true will have\n\t\t * checked that a VARIADIC-labeled parameter actually is an array.  So\n\t\t * it should be okay to just Assert that it's an array rather than\n\t\t * doing a full-fledged error check.\n\t\t */\n\t\tAssert(OidIsValid(get_base_element_type(get_fn_expr_argtype(fcinfo->flinfo, argidx))));\n\n\t\t/* OK, safe to fetch the array value */\n\t\tarr = PG_GETARG_ARRAYTYPE_P(argidx);\n\n\t\t/*\n\t\t * And serialize the array.  We tell array_to_text to ignore null\n\t\t * elements, which matches the behavior of the loop below.\n\t\t */\n\t\treturn array_to_text_internal(fcinfo, arr, sepstr, NULL);\n\t}\n\n\t/* Normal case without explicit VARIADIC marker */\n\tinitStringInfo(&str);\n\n\t/* Get output function info, building it if first time through */\n\tfoutcache = (FmgrInfo *) fcinfo->flinfo->fn_extra;\n\tif (foutcache == NULL)\n\t\tfoutcache = build_concat_foutcache(fcinfo, argidx);\n\n\tfor (i = argidx; i < PG_NARGS(); i++)\n\t{\n\t\tif (!PG_ARGISNULL(i))\n\t\t{\n\t\t\tDatum\t\tvalue = PG_GETARG_DATUM(i);\n\n\t\t\t/* add separator if appropriate */\n\t\t\tif (first_arg)\n\t\t\t\tfirst_arg = false;\n\t\t\telse\n\t\t\t\tappendStringInfoString(&str, sepstr);\n\n\t\t\t/* call the appropriate type output function, append the result */\n\t\t\tappendStringInfoString(&str,\n\t\t\t\t\t\t\t\t   OutputFunctionCall(&foutcache[i], value));\n\t\t}\n\t}\n\n\tresult = cstring_to_text_with_len(str.data, str.len);\n\tpfree(str.data);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int32 text_length(Datum str);",
            "static StringInfo makeStringAggState(FunctionCallInfo fcinfo);",
            "static bool text_format_parse_digits(const char **ptr, const char *end_ptr,\n\t\t\t\t\t\t int *value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int32 text_length(Datum str);\nstatic StringInfo makeStringAggState(FunctionCallInfo fcinfo);\nstatic bool text_format_parse_digits(const char **ptr, const char *end_ptr,\n\t\t\t\t\t\t int *value);\n\nstatic text *\nconcat_internal(const char *sepstr, int argidx,\n\t\t\t\tFunctionCallInfo fcinfo)\n{\n\ttext\t   *result;\n\tStringInfoData str;\n\tFmgrInfo   *foutcache;\n\tbool\t\tfirst_arg = true;\n\tint\t\t\ti;\n\n\t/*\n\t * concat(VARIADIC some-array) is essentially equivalent to\n\t * array_to_text(), ie concat the array elements with the given separator.\n\t * So we just pass the case off to that code.\n\t */\n\tif (get_fn_expr_variadic(fcinfo->flinfo))\n\t{\n\t\tArrayType  *arr;\n\n\t\t/* Should have just the one argument */\n\t\tAssert(argidx == PG_NARGS() - 1);\n\n\t\t/* concat(VARIADIC NULL) is defined as NULL */\n\t\tif (PG_ARGISNULL(argidx))\n\t\t\treturn NULL;\n\n\t\t/*\n\t\t * Non-null argument had better be an array.  We assume that any call\n\t\t * context that could let get_fn_expr_variadic return true will have\n\t\t * checked that a VARIADIC-labeled parameter actually is an array.  So\n\t\t * it should be okay to just Assert that it's an array rather than\n\t\t * doing a full-fledged error check.\n\t\t */\n\t\tAssert(OidIsValid(get_base_element_type(get_fn_expr_argtype(fcinfo->flinfo, argidx))));\n\n\t\t/* OK, safe to fetch the array value */\n\t\tarr = PG_GETARG_ARRAYTYPE_P(argidx);\n\n\t\t/*\n\t\t * And serialize the array.  We tell array_to_text to ignore null\n\t\t * elements, which matches the behavior of the loop below.\n\t\t */\n\t\treturn array_to_text_internal(fcinfo, arr, sepstr, NULL);\n\t}\n\n\t/* Normal case without explicit VARIADIC marker */\n\tinitStringInfo(&str);\n\n\t/* Get output function info, building it if first time through */\n\tfoutcache = (FmgrInfo *) fcinfo->flinfo->fn_extra;\n\tif (foutcache == NULL)\n\t\tfoutcache = build_concat_foutcache(fcinfo, argidx);\n\n\tfor (i = argidx; i < PG_NARGS(); i++)\n\t{\n\t\tif (!PG_ARGISNULL(i))\n\t\t{\n\t\t\tDatum\t\tvalue = PG_GETARG_DATUM(i);\n\n\t\t\t/* add separator if appropriate */\n\t\t\tif (first_arg)\n\t\t\t\tfirst_arg = false;\n\t\t\telse\n\t\t\t\tappendStringInfoString(&str, sepstr);\n\n\t\t\t/* call the appropriate type output function, append the result */\n\t\t\tappendStringInfoString(&str,\n\t\t\t\t\t\t\t\t   OutputFunctionCall(&foutcache[i], value));\n\t\t}\n\t}\n\n\tresult = cstring_to_text_with_len(str.data, str.len);\n\tpfree(str.data);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\nstatic StringInfo makeStringAggState(FunctionCallInfo fcinfo);\n\nDatum\ntext_concat(PG_FUNCTION_ARGS)\n{\n\ttext\t   *result;\n\n\tresult = concat_internal(\"\", 0, fcinfo);\n\tif (result == NULL)\n\t\tPG_RETURN_NULL();\n\tPG_RETURN_TEXT_P(result);\n}"
  },
  {
    "function_name": "concat_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "4875-4950",
    "snippet": "static text *\nconcat_internal(const char *sepstr, int argidx,\n\t\t\t\tFunctionCallInfo fcinfo)\n{\n\ttext\t   *result;\n\tStringInfoData str;\n\tFmgrInfo   *foutcache;\n\tbool\t\tfirst_arg = true;\n\tint\t\t\ti;\n\n\t/*\n\t * concat(VARIADIC some-array) is essentially equivalent to\n\t * array_to_text(), ie concat the array elements with the given separator.\n\t * So we just pass the case off to that code.\n\t */\n\tif (get_fn_expr_variadic(fcinfo->flinfo))\n\t{\n\t\tArrayType  *arr;\n\n\t\t/* Should have just the one argument */\n\t\tAssert(argidx == PG_NARGS() - 1);\n\n\t\t/* concat(VARIADIC NULL) is defined as NULL */\n\t\tif (PG_ARGISNULL(argidx))\n\t\t\treturn NULL;\n\n\t\t/*\n\t\t * Non-null argument had better be an array.  We assume that any call\n\t\t * context that could let get_fn_expr_variadic return true will have\n\t\t * checked that a VARIADIC-labeled parameter actually is an array.  So\n\t\t * it should be okay to just Assert that it's an array rather than\n\t\t * doing a full-fledged error check.\n\t\t */\n\t\tAssert(OidIsValid(get_base_element_type(get_fn_expr_argtype(fcinfo->flinfo, argidx))));\n\n\t\t/* OK, safe to fetch the array value */\n\t\tarr = PG_GETARG_ARRAYTYPE_P(argidx);\n\n\t\t/*\n\t\t * And serialize the array.  We tell array_to_text to ignore null\n\t\t * elements, which matches the behavior of the loop below.\n\t\t */\n\t\treturn array_to_text_internal(fcinfo, arr, sepstr, NULL);\n\t}\n\n\t/* Normal case without explicit VARIADIC marker */\n\tinitStringInfo(&str);\n\n\t/* Get output function info, building it if first time through */\n\tfoutcache = (FmgrInfo *) fcinfo->flinfo->fn_extra;\n\tif (foutcache == NULL)\n\t\tfoutcache = build_concat_foutcache(fcinfo, argidx);\n\n\tfor (i = argidx; i < PG_NARGS(); i++)\n\t{\n\t\tif (!PG_ARGISNULL(i))\n\t\t{\n\t\t\tDatum\t\tvalue = PG_GETARG_DATUM(i);\n\n\t\t\t/* add separator if appropriate */\n\t\t\tif (first_arg)\n\t\t\t\tfirst_arg = false;\n\t\t\telse\n\t\t\t\tappendStringInfoString(&str, sepstr);\n\n\t\t\t/* call the appropriate type output function, append the result */\n\t\t\tappendStringInfoString(&str,\n\t\t\t\t\t\t\t\t   OutputFunctionCall(&foutcache[i], value));\n\t\t}\n\t}\n\n\tresult = cstring_to_text_with_len(str.data, str.len);\n\tpfree(str.data);\n\n\treturn result;\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int32 text_length(Datum str);",
      "static StringInfo makeStringAggState(FunctionCallInfo fcinfo);",
      "static bool text_format_parse_digits(const char **ptr, const char *end_ptr,\n\t\t\t\t\t\t int *value);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "str.data"
          ],
          "line": 4947
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cstring_to_text_with_len",
          "args": [
            "str.data",
            "str.len"
          ],
          "line": 4946
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "160-169",
          "snippet": "text *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&str",
            "OutputFunctionCall(&foutcache[i], value)"
          ],
          "line": 4941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OutputFunctionCall",
          "args": [
            "&foutcache[i]",
            "value"
          ],
          "line": 4942
        },
        "resolved": true,
        "details": {
          "function_name": "OidOutputFunctionCall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1832-1839",
          "snippet": "char *\nOidOutputFunctionCall(Oid functionId, Datum val)\n{\n\tFmgrInfo\tflinfo;\n\n\tfmgr_info(functionId, &flinfo);\n\treturn OutputFunctionCall(&flinfo, val);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nchar *\nOidOutputFunctionCall(Oid functionId, Datum val)\n{\n\tFmgrInfo\tflinfo;\n\n\tfmgr_info(functionId, &flinfo);\n\treturn OutputFunctionCall(&flinfo, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&str",
            "sepstr"
          ],
          "line": 4938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "i"
          ],
          "line": 4932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "i"
          ],
          "line": 4930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_NARGS",
          "args": [],
          "line": 4928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_concat_foutcache",
          "args": [
            "fcinfo",
            "argidx"
          ],
          "line": 4926
        },
        "resolved": true,
        "details": {
          "function_name": "build_concat_foutcache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "4837-4864",
          "snippet": "static FmgrInfo *\nbuild_concat_foutcache(FunctionCallInfo fcinfo, int argidx)\n{\n\tFmgrInfo   *foutcache;\n\tint\t\t\ti;\n\n\t/* We keep the info in fn_mcxt so it survives across calls */\n\tfoutcache = (FmgrInfo *) MemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t\t\t\t\t\tPG_NARGS() * sizeof(FmgrInfo));\n\n\tfor (i = argidx; i < PG_NARGS(); i++)\n\t{\n\t\tOid\t\t\tvaltype;\n\t\tOid\t\t\ttypOutput;\n\t\tbool\t\ttypIsVarlena;\n\n\t\tvaltype = get_fn_expr_argtype(fcinfo->flinfo, i);\n\t\tif (!OidIsValid(valtype))\n\t\t\telog(ERROR, \"could not determine data type of concat() input\");\n\n\t\tgetTypeOutputInfo(valtype, &typOutput, &typIsVarlena);\n\t\tfmgr_info_cxt(typOutput, &foutcache[i], fcinfo->flinfo->fn_mcxt);\n\t}\n\n\tfcinfo->flinfo->fn_extra = foutcache;\n\n\treturn foutcache;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static StringInfo makeStringAggState(FunctionCallInfo fcinfo);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic StringInfo makeStringAggState(FunctionCallInfo fcinfo);\n\nstatic FmgrInfo *\nbuild_concat_foutcache(FunctionCallInfo fcinfo, int argidx)\n{\n\tFmgrInfo   *foutcache;\n\tint\t\t\ti;\n\n\t/* We keep the info in fn_mcxt so it survives across calls */\n\tfoutcache = (FmgrInfo *) MemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t\t\t\t\t\tPG_NARGS() * sizeof(FmgrInfo));\n\n\tfor (i = argidx; i < PG_NARGS(); i++)\n\t{\n\t\tOid\t\t\tvaltype;\n\t\tOid\t\t\ttypOutput;\n\t\tbool\t\ttypIsVarlena;\n\n\t\tvaltype = get_fn_expr_argtype(fcinfo->flinfo, i);\n\t\tif (!OidIsValid(valtype))\n\t\t\telog(ERROR, \"could not determine data type of concat() input\");\n\n\t\tgetTypeOutputInfo(valtype, &typOutput, &typIsVarlena);\n\t\tfmgr_info_cxt(typOutput, &foutcache[i], fcinfo->flinfo->fn_mcxt);\n\t}\n\n\tfcinfo->flinfo->fn_extra = foutcache;\n\n\treturn foutcache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "initStringInfo",
          "args": [
            "&str"
          ],
          "line": 4921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_to_text_internal",
          "args": [
            "fcinfo",
            "arr",
            "sepstr",
            "NULL"
          ],
          "line": 4917
        },
        "resolved": true,
        "details": {
          "function_name": "array_to_text_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "4539-4655",
          "snippet": "static text *\narray_to_text_internal(FunctionCallInfo fcinfo, ArrayType *v,\n\t\t\t\t\t   const char *fldsep, const char *null_string)\n{\n\ttext\t   *result;\n\tint\t\t\tnitems,\n\t\t\t   *dims,\n\t\t\t\tndims;\n\tOid\t\t\telement_type;\n\tint\t\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tStringInfoData buf;\n\tbool\t\tprinted = false;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\tArrayMetaState *my_extra;\n\n\tndims = ARR_NDIM(v);\n\tdims = ARR_DIMS(v);\n\tnitems = ArrayGetNItems(ndims, dims);\n\n\t/* if there are no elements, return an empty string */\n\tif (nitems == 0)\n\t\treturn cstring_to_text_with_len(\"\", 0);\n\n\telement_type = ARR_ELEMTYPE(v);\n\tinitStringInfo(&buf);\n\n\t/*\n\t * We arrange to look up info about element type, including its output\n\t * conversion proc, only once per series of calls, assuming the element\n\t * type doesn't change underneath us.\n\t */\n\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL)\n\t{\n\t\tfcinfo->flinfo->fn_extra = MemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  sizeof(ArrayMetaState));\n\t\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->element_type = ~element_type;\n\t}\n\n\tif (my_extra->element_type != element_type)\n\t{\n\t\t/*\n\t\t * Get info about element type, including its output conversion proc\n\t\t */\n\t\tget_type_io_data(element_type, IOFunc_output,\n\t\t\t\t\t\t &my_extra->typlen, &my_extra->typbyval,\n\t\t\t\t\t\t &my_extra->typalign, &my_extra->typdelim,\n\t\t\t\t\t\t &my_extra->typioparam, &my_extra->typiofunc);\n\t\tfmgr_info_cxt(my_extra->typiofunc, &my_extra->proc,\n\t\t\t\t\t  fcinfo->flinfo->fn_mcxt);\n\t\tmy_extra->element_type = element_type;\n\t}\n\ttyplen = my_extra->typlen;\n\ttypbyval = my_extra->typbyval;\n\ttypalign = my_extra->typalign;\n\n\tp = ARR_DATA_PTR(v);\n\tbitmap = ARR_NULLBITMAP(v);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tDatum\t\titemvalue;\n\t\tchar\t   *value;\n\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\t/* if null_string is NULL, we just ignore null elements */\n\t\t\tif (null_string != NULL)\n\t\t\t{\n\t\t\t\tif (printed)\n\t\t\t\t\tappendStringInfo(&buf, \"%s%s\", fldsep, null_string);\n\t\t\t\telse\n\t\t\t\t\tappendStringInfoString(&buf, null_string);\n\t\t\t\tprinted = true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\titemvalue = fetch_att(p, typbyval, typlen);\n\n\t\t\tvalue = OutputFunctionCall(&my_extra->proc, itemvalue);\n\n\t\t\tif (printed)\n\t\t\t\tappendStringInfo(&buf, \"%s%s\", fldsep, value);\n\t\t\telse\n\t\t\t\tappendStringInfoString(&buf, value);\n\t\t\tprinted = true;\n\n\t\t\tp = att_addlength_pointer(p, typlen, p);\n\t\t\tp = (char *) att_align_nominal(p, typalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tresult = cstring_to_text_with_len(buf.data, buf.len);\n\tpfree(buf.data);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void appendStringInfoText(StringInfo str, const text *t);",
            "static text *array_to_text_internal(FunctionCallInfo fcinfo, ArrayType *v,\n\t\t\t\t\t   const char *fldsep, const char *null_string);",
            "static StringInfo makeStringAggState(FunctionCallInfo fcinfo);",
            "static bool text_format_parse_digits(const char **ptr, const char *end_ptr,\n\t\t\t\t\t\t int *value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\nstatic text *array_to_text_internal(FunctionCallInfo fcinfo, ArrayType *v,\n\t\t\t\t\t   const char *fldsep, const char *null_string);\nstatic StringInfo makeStringAggState(FunctionCallInfo fcinfo);\nstatic bool text_format_parse_digits(const char **ptr, const char *end_ptr,\n\t\t\t\t\t\t int *value);\n\nstatic text *\narray_to_text_internal(FunctionCallInfo fcinfo, ArrayType *v,\n\t\t\t\t\t   const char *fldsep, const char *null_string)\n{\n\ttext\t   *result;\n\tint\t\t\tnitems,\n\t\t\t   *dims,\n\t\t\t\tndims;\n\tOid\t\t\telement_type;\n\tint\t\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tStringInfoData buf;\n\tbool\t\tprinted = false;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\tArrayMetaState *my_extra;\n\n\tndims = ARR_NDIM(v);\n\tdims = ARR_DIMS(v);\n\tnitems = ArrayGetNItems(ndims, dims);\n\n\t/* if there are no elements, return an empty string */\n\tif (nitems == 0)\n\t\treturn cstring_to_text_with_len(\"\", 0);\n\n\telement_type = ARR_ELEMTYPE(v);\n\tinitStringInfo(&buf);\n\n\t/*\n\t * We arrange to look up info about element type, including its output\n\t * conversion proc, only once per series of calls, assuming the element\n\t * type doesn't change underneath us.\n\t */\n\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL)\n\t{\n\t\tfcinfo->flinfo->fn_extra = MemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  sizeof(ArrayMetaState));\n\t\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->element_type = ~element_type;\n\t}\n\n\tif (my_extra->element_type != element_type)\n\t{\n\t\t/*\n\t\t * Get info about element type, including its output conversion proc\n\t\t */\n\t\tget_type_io_data(element_type, IOFunc_output,\n\t\t\t\t\t\t &my_extra->typlen, &my_extra->typbyval,\n\t\t\t\t\t\t &my_extra->typalign, &my_extra->typdelim,\n\t\t\t\t\t\t &my_extra->typioparam, &my_extra->typiofunc);\n\t\tfmgr_info_cxt(my_extra->typiofunc, &my_extra->proc,\n\t\t\t\t\t  fcinfo->flinfo->fn_mcxt);\n\t\tmy_extra->element_type = element_type;\n\t}\n\ttyplen = my_extra->typlen;\n\ttypbyval = my_extra->typbyval;\n\ttypalign = my_extra->typalign;\n\n\tp = ARR_DATA_PTR(v);\n\tbitmap = ARR_NULLBITMAP(v);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tDatum\t\titemvalue;\n\t\tchar\t   *value;\n\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\t/* if null_string is NULL, we just ignore null elements */\n\t\t\tif (null_string != NULL)\n\t\t\t{\n\t\t\t\tif (printed)\n\t\t\t\t\tappendStringInfo(&buf, \"%s%s\", fldsep, null_string);\n\t\t\t\telse\n\t\t\t\t\tappendStringInfoString(&buf, null_string);\n\t\t\t\tprinted = true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\titemvalue = fetch_att(p, typbyval, typlen);\n\n\t\t\tvalue = OutputFunctionCall(&my_extra->proc, itemvalue);\n\n\t\t\tif (printed)\n\t\t\t\tappendStringInfo(&buf, \"%s%s\", fldsep, value);\n\t\t\telse\n\t\t\t\tappendStringInfoString(&buf, value);\n\t\t\tprinted = true;\n\n\t\t\tp = att_addlength_pointer(p, typlen, p);\n\t\t\tp = (char *) att_align_nominal(p, typalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tresult = cstring_to_text_with_len(buf.data, buf.len);\n\tpfree(buf.data);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "argidx"
          ],
          "line": 4911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "OidIsValid(get_base_element_type(get_fn_expr_argtype(fcinfo->flinfo, argidx)))"
          ],
          "line": 4908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "get_base_element_type(get_fn_expr_argtype(fcinfo->flinfo, argidx))"
          ],
          "line": 4908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_base_element_type",
          "args": [
            "get_fn_expr_argtype(fcinfo->flinfo, argidx)"
          ],
          "line": 4908
        },
        "resolved": true,
        "details": {
          "function_name": "get_base_element_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2598-2633",
          "snippet": "Oid\nget_base_element_type(Oid typid)\n{\n\t/*\n\t * We loop to find the bottom base type in a stack of domains.\n\t */\n\tfor (;;)\n\t{\n\t\tHeapTuple\ttup;\n\t\tForm_pg_type typTup;\n\n\t\ttup = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\t\tif (!HeapTupleIsValid(tup))\n\t\t\tbreak;\n\t\ttypTup = (Form_pg_type) GETSTRUCT(tup);\n\t\tif (typTup->typtype != TYPTYPE_DOMAIN)\n\t\t{\n\t\t\t/* Not a domain, so stop descending */\n\t\t\tOid\t\t\tresult;\n\n\t\t\t/* This test must match get_element_type */\n\t\t\tif (typTup->typlen == -1)\n\t\t\t\tresult = typTup->typelem;\n\t\t\telse\n\t\t\t\tresult = InvalidOid;\n\t\t\tReleaseSysCache(tup);\n\t\t\treturn result;\n\t\t}\n\n\t\ttypid = typTup->typbasetype;\n\t\tReleaseSysCache(tup);\n\t}\n\n\t/* Like get_element_type, silently return InvalidOid for bogus input */\n\treturn InvalidOid;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nOid\nget_base_element_type(Oid typid)\n{\n\t/*\n\t * We loop to find the bottom base type in a stack of domains.\n\t */\n\tfor (;;)\n\t{\n\t\tHeapTuple\ttup;\n\t\tForm_pg_type typTup;\n\n\t\ttup = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\t\tif (!HeapTupleIsValid(tup))\n\t\t\tbreak;\n\t\ttypTup = (Form_pg_type) GETSTRUCT(tup);\n\t\tif (typTup->typtype != TYPTYPE_DOMAIN)\n\t\t{\n\t\t\t/* Not a domain, so stop descending */\n\t\t\tOid\t\t\tresult;\n\n\t\t\t/* This test must match get_element_type */\n\t\t\tif (typTup->typlen == -1)\n\t\t\t\tresult = typTup->typelem;\n\t\t\telse\n\t\t\t\tresult = InvalidOid;\n\t\t\tReleaseSysCache(tup);\n\t\t\treturn result;\n\t\t}\n\n\t\ttypid = typTup->typbasetype;\n\t\tReleaseSysCache(tup);\n\t}\n\n\t/* Like get_element_type, silently return InvalidOid for bogus input */\n\treturn InvalidOid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fn_expr_argtype",
          "args": [
            "fcinfo->flinfo",
            "argidx"
          ],
          "line": 4908
        },
        "resolved": true,
        "details": {
          "function_name": "get_fn_expr_argtype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1994-2005",
          "snippet": "Oid\nget_fn_expr_argtype(FmgrInfo *flinfo, int argnum)\n{\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn InvalidOid;\n\n\treturn get_call_expr_argtype(flinfo->fn_expr, argnum);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nOid\nget_fn_expr_argtype(FmgrInfo *flinfo, int argnum)\n{\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn InvalidOid;\n\n\treturn get_call_expr_argtype(flinfo->fn_expr, argnum);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "argidx"
          ],
          "line": 4898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "argidx == PG_NARGS() - 1"
          ],
          "line": 4895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_NARGS",
          "args": [],
          "line": 4895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fn_expr_variadic",
          "args": [
            "fcinfo->flinfo"
          ],
          "line": 4890
        },
        "resolved": true,
        "details": {
          "function_name": "get_fn_expr_variadic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "2128-2146",
          "snippet": "bool\nget_fn_expr_variadic(FmgrInfo *flinfo)\n{\n\tNode\t   *expr;\n\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn false;\n\n\texpr = flinfo->fn_expr;\n\n\tif (IsA(expr, FuncExpr))\n\t\treturn ((FuncExpr *) expr)->funcvariadic;\n\telse\n\t\treturn false;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nbool\nget_fn_expr_variadic(FmgrInfo *flinfo)\n{\n\tNode\t   *expr;\n\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn false;\n\n\texpr = flinfo->fn_expr;\n\n\tif (IsA(expr, FuncExpr))\n\t\treturn ((FuncExpr *) expr)->funcvariadic;\n\telse\n\t\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int32 text_length(Datum str);\nstatic StringInfo makeStringAggState(FunctionCallInfo fcinfo);\nstatic bool text_format_parse_digits(const char **ptr, const char *end_ptr,\n\t\t\t\t\t\t int *value);\n\nstatic text *\nconcat_internal(const char *sepstr, int argidx,\n\t\t\t\tFunctionCallInfo fcinfo)\n{\n\ttext\t   *result;\n\tStringInfoData str;\n\tFmgrInfo   *foutcache;\n\tbool\t\tfirst_arg = true;\n\tint\t\t\ti;\n\n\t/*\n\t * concat(VARIADIC some-array) is essentially equivalent to\n\t * array_to_text(), ie concat the array elements with the given separator.\n\t * So we just pass the case off to that code.\n\t */\n\tif (get_fn_expr_variadic(fcinfo->flinfo))\n\t{\n\t\tArrayType  *arr;\n\n\t\t/* Should have just the one argument */\n\t\tAssert(argidx == PG_NARGS() - 1);\n\n\t\t/* concat(VARIADIC NULL) is defined as NULL */\n\t\tif (PG_ARGISNULL(argidx))\n\t\t\treturn NULL;\n\n\t\t/*\n\t\t * Non-null argument had better be an array.  We assume that any call\n\t\t * context that could let get_fn_expr_variadic return true will have\n\t\t * checked that a VARIADIC-labeled parameter actually is an array.  So\n\t\t * it should be okay to just Assert that it's an array rather than\n\t\t * doing a full-fledged error check.\n\t\t */\n\t\tAssert(OidIsValid(get_base_element_type(get_fn_expr_argtype(fcinfo->flinfo, argidx))));\n\n\t\t/* OK, safe to fetch the array value */\n\t\tarr = PG_GETARG_ARRAYTYPE_P(argidx);\n\n\t\t/*\n\t\t * And serialize the array.  We tell array_to_text to ignore null\n\t\t * elements, which matches the behavior of the loop below.\n\t\t */\n\t\treturn array_to_text_internal(fcinfo, arr, sepstr, NULL);\n\t}\n\n\t/* Normal case without explicit VARIADIC marker */\n\tinitStringInfo(&str);\n\n\t/* Get output function info, building it if first time through */\n\tfoutcache = (FmgrInfo *) fcinfo->flinfo->fn_extra;\n\tif (foutcache == NULL)\n\t\tfoutcache = build_concat_foutcache(fcinfo, argidx);\n\n\tfor (i = argidx; i < PG_NARGS(); i++)\n\t{\n\t\tif (!PG_ARGISNULL(i))\n\t\t{\n\t\t\tDatum\t\tvalue = PG_GETARG_DATUM(i);\n\n\t\t\t/* add separator if appropriate */\n\t\t\tif (first_arg)\n\t\t\t\tfirst_arg = false;\n\t\t\telse\n\t\t\t\tappendStringInfoString(&str, sepstr);\n\n\t\t\t/* call the appropriate type output function, append the result */\n\t\t\tappendStringInfoString(&str,\n\t\t\t\t\t\t\t\t   OutputFunctionCall(&foutcache[i], value));\n\t\t}\n\t}\n\n\tresult = cstring_to_text_with_len(str.data, str.len);\n\tpfree(str.data);\n\n\treturn result;\n}"
  },
  {
    "function_name": "build_concat_foutcache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "4837-4864",
    "snippet": "static FmgrInfo *\nbuild_concat_foutcache(FunctionCallInfo fcinfo, int argidx)\n{\n\tFmgrInfo   *foutcache;\n\tint\t\t\ti;\n\n\t/* We keep the info in fn_mcxt so it survives across calls */\n\tfoutcache = (FmgrInfo *) MemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t\t\t\t\t\tPG_NARGS() * sizeof(FmgrInfo));\n\n\tfor (i = argidx; i < PG_NARGS(); i++)\n\t{\n\t\tOid\t\t\tvaltype;\n\t\tOid\t\t\ttypOutput;\n\t\tbool\t\ttypIsVarlena;\n\n\t\tvaltype = get_fn_expr_argtype(fcinfo->flinfo, i);\n\t\tif (!OidIsValid(valtype))\n\t\t\telog(ERROR, \"could not determine data type of concat() input\");\n\n\t\tgetTypeOutputInfo(valtype, &typOutput, &typIsVarlena);\n\t\tfmgr_info_cxt(typOutput, &foutcache[i], fcinfo->flinfo->fn_mcxt);\n\t}\n\n\tfcinfo->flinfo->fn_extra = foutcache;\n\n\treturn foutcache;\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static StringInfo makeStringAggState(FunctionCallInfo fcinfo);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fmgr_info_cxt",
          "args": [
            "typOutput",
            "&foutcache[i]",
            "fcinfo->flinfo->fn_mcxt"
          ],
          "line": 4858
        },
        "resolved": true,
        "details": {
          "function_name": "fmgr_info_cxt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "133-137",
          "snippet": "void\nfmgr_info_cxt(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt)\n{\n\tfmgr_info_cxt_security(functionId, finfo, mcxt, false);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nvoid\nfmgr_info_cxt(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt)\n{\n\tfmgr_info_cxt_security(functionId, finfo, mcxt, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getTypeOutputInfo",
          "args": [
            "valtype",
            "&typOutput",
            "&typIsVarlena"
          ],
          "line": 4857
        },
        "resolved": true,
        "details": {
          "function_name": "getTypeOutputInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2673-2699",
          "snippet": "void\ngetTypeOutputInfo(Oid type, Oid *typOutput, bool *typIsVarlena)\n{\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type pt;\n\n\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type));\n\tif (!HeapTupleIsValid(typeTuple))\n\t\telog(ERROR, \"cache lookup failed for type %u\", type);\n\tpt = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\tif (!pt->typisdefined)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t errmsg(\"type %s is only a shell\",\n\t\t\t\t\t\tformat_type_be(type))));\n\tif (!OidIsValid(pt->typoutput))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"no output function available for type %s\",\n\t\t\t\t\t\tformat_type_be(type))));\n\n\t*typOutput = pt->typoutput;\n\t*typIsVarlena = (!pt->typbyval) && (pt->typlen == -1);\n\n\tReleaseSysCache(typeTuple);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\ngetTypeOutputInfo(Oid type, Oid *typOutput, bool *typIsVarlena)\n{\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type pt;\n\n\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type));\n\tif (!HeapTupleIsValid(typeTuple))\n\t\telog(ERROR, \"cache lookup failed for type %u\", type);\n\tpt = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\tif (!pt->typisdefined)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t errmsg(\"type %s is only a shell\",\n\t\t\t\t\t\tformat_type_be(type))));\n\tif (!OidIsValid(pt->typoutput))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"no output function available for type %s\",\n\t\t\t\t\t\tformat_type_be(type))));\n\n\t*typOutput = pt->typoutput;\n\t*typIsVarlena = (!pt->typbyval) && (pt->typlen == -1);\n\n\tReleaseSysCache(typeTuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"could not determine data type of concat() input\""
          ],
          "line": 4855
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "valtype"
          ],
          "line": 4854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fn_expr_argtype",
          "args": [
            "fcinfo->flinfo",
            "i"
          ],
          "line": 4853
        },
        "resolved": true,
        "details": {
          "function_name": "get_fn_expr_argtype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1994-2005",
          "snippet": "Oid\nget_fn_expr_argtype(FmgrInfo *flinfo, int argnum)\n{\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn InvalidOid;\n\n\treturn get_call_expr_argtype(flinfo->fn_expr, argnum);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nOid\nget_fn_expr_argtype(FmgrInfo *flinfo, int argnum)\n{\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn InvalidOid;\n\n\treturn get_call_expr_argtype(flinfo->fn_expr, argnum);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_NARGS",
          "args": [],
          "line": 4847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextAlloc",
          "args": [
            "fcinfo->flinfo->fn_mcxt",
            "PG_NARGS() * sizeof(FmgrInfo)"
          ],
          "line": 4844
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1079-1106",
          "snippet": "void *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_NARGS",
          "args": [],
          "line": 4845
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic StringInfo makeStringAggState(FunctionCallInfo fcinfo);\n\nstatic FmgrInfo *\nbuild_concat_foutcache(FunctionCallInfo fcinfo, int argidx)\n{\n\tFmgrInfo   *foutcache;\n\tint\t\t\ti;\n\n\t/* We keep the info in fn_mcxt so it survives across calls */\n\tfoutcache = (FmgrInfo *) MemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t\t\t\t\t\tPG_NARGS() * sizeof(FmgrInfo));\n\n\tfor (i = argidx; i < PG_NARGS(); i++)\n\t{\n\t\tOid\t\t\tvaltype;\n\t\tOid\t\t\ttypOutput;\n\t\tbool\t\ttypIsVarlena;\n\n\t\tvaltype = get_fn_expr_argtype(fcinfo->flinfo, i);\n\t\tif (!OidIsValid(valtype))\n\t\t\telog(ERROR, \"could not determine data type of concat() input\");\n\n\t\tgetTypeOutputInfo(valtype, &typOutput, &typIsVarlena);\n\t\tfmgr_info_cxt(typOutput, &foutcache[i], fcinfo->flinfo->fn_mcxt);\n\t}\n\n\tfcinfo->flinfo->fn_extra = foutcache;\n\n\treturn foutcache;\n}"
  },
  {
    "function_name": "string_agg_finalfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "4815-4829",
    "snippet": "Datum\nstring_agg_finalfn(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tstate;\n\n\t/* cannot be called directly because of internal-type argument */\n\tAssert(AggCheckCallContext(fcinfo, NULL));\n\n\tstate = PG_ARGISNULL(0) ? NULL : (StringInfo) PG_GETARG_POINTER(0);\n\n\tif (state != NULL)\n\t\tPG_RETURN_TEXT_P(cstring_to_text_with_len(state->data, state->len));\n\telse\n\t\tPG_RETURN_NULL();\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void text_position_setup(text *t1, text *t2, TextPositionState *state);",
      "static int\ttext_position_next(int start_pos, TextPositionState *state);",
      "static void text_position_cleanup(TextPositionState *state);",
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);",
      "static StringInfo makeStringAggState(FunctionCallInfo fcinfo);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 4828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "cstring_to_text_with_len(state->data, state->len)"
          ],
          "line": 4826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cstring_to_text_with_len",
          "args": [
            "state->data",
            "state->len"
          ],
          "line": 4826
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "160-169",
          "snippet": "text *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 4823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "0"
          ],
          "line": 4823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "AggCheckCallContext(fcinfo, NULL)"
          ],
          "line": 4821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AggCheckCallContext",
          "args": [
            "fcinfo",
            "NULL"
          ],
          "line": 4821
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void text_position_setup(text *t1, text *t2, TextPositionState *state);\nstatic int\ttext_position_next(int start_pos, TextPositionState *state);\nstatic void text_position_cleanup(TextPositionState *state);\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\nstatic StringInfo makeStringAggState(FunctionCallInfo fcinfo);\n\nDatum\nstring_agg_finalfn(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tstate;\n\n\t/* cannot be called directly because of internal-type argument */\n\tAssert(AggCheckCallContext(fcinfo, NULL));\n\n\tstate = PG_ARGISNULL(0) ? NULL : (StringInfo) PG_GETARG_POINTER(0);\n\n\tif (state != NULL)\n\t\tPG_RETURN_TEXT_P(cstring_to_text_with_len(state->data, state->len));\n\telse\n\t\tPG_RETURN_NULL();\n}"
  },
  {
    "function_name": "string_agg_transfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "4789-4813",
    "snippet": "Datum\nstring_agg_transfn(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tstate;\n\n\tstate = PG_ARGISNULL(0) ? NULL : (StringInfo) PG_GETARG_POINTER(0);\n\n\t/* Append the value unless null. */\n\tif (!PG_ARGISNULL(1))\n\t{\n\t\t/* On the first time through, we ignore the delimiter. */\n\t\tif (state == NULL)\n\t\t\tstate = makeStringAggState(fcinfo);\n\t\telse if (!PG_ARGISNULL(2))\n\t\t\tappendStringInfoText(state, PG_GETARG_TEXT_PP(2));\t/* delimiter */\n\n\t\tappendStringInfoText(state, PG_GETARG_TEXT_PP(1));\t/* value */\n\t}\n\n\t/*\n\t * The transition type for string_agg() is declared to be \"internal\",\n\t * which is a pass-by-value type the same size as a pointer.\n\t */\n\tPG_RETURN_POINTER(state);\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void text_position_setup(text *t1, text *t2, TextPositionState *state);",
      "static int\ttext_position_next(int start_pos, TextPositionState *state);",
      "static void text_position_cleanup(TextPositionState *state);",
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);",
      "static StringInfo makeStringAggState(FunctionCallInfo fcinfo);",
      "static bool text_format_parse_digits(const char **ptr, const char *end_ptr,\n\t\t\t\t\t\t int *value);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "state"
          ],
          "line": 4812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoText",
          "args": [
            "state",
            "PG_GETARG_TEXT_PP(1)"
          ],
          "line": 4805
        },
        "resolved": true,
        "details": {
          "function_name": "appendStringInfoText",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "3814-3818",
          "snippet": "static void\nappendStringInfoText(StringInfo str, const text *t)\n{\n\tappendBinaryStringInfo(str, VARDATA_ANY(t), VARSIZE_ANY_EXHDR(t));\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int32 text_length(Datum str);",
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int32 text_length(Datum str);\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nstatic void\nappendStringInfoText(StringInfo str, const text *t)\n{\n\tappendBinaryStringInfo(str, VARDATA_ANY(t), VARSIZE_ANY_EXHDR(t));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 4805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "2"
          ],
          "line": 4803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "2"
          ],
          "line": 4802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeStringAggState",
          "args": [
            "fcinfo"
          ],
          "line": 4801
        },
        "resolved": true,
        "details": {
          "function_name": "makeStringAggState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "4765-4787",
          "snippet": "static StringInfo\nmakeStringAggState(FunctionCallInfo fcinfo)\n{\n\tStringInfo\tstate;\n\tMemoryContext aggcontext;\n\tMemoryContext oldcontext;\n\n\tif (!AggCheckCallContext(fcinfo, &aggcontext))\n\t{\n\t\t/* cannot be called directly because of internal-type argument */\n\t\telog(ERROR, \"string_agg_transfn called in non-aggregate context\");\n\t}\n\n\t/*\n\t * Create state in aggregate context.  It'll stay there across subsequent\n\t * calls.\n\t */\n\toldcontext = MemoryContextSwitchTo(aggcontext);\n\tstate = makeStringInfo();\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn state;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void text_position_setup(text *t1, text *t2, TextPositionState *state);",
            "static int\ttext_position_next(int start_pos, TextPositionState *state);",
            "static void text_position_cleanup(TextPositionState *state);",
            "static StringInfo makeStringAggState(FunctionCallInfo fcinfo);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void text_position_setup(text *t1, text *t2, TextPositionState *state);\nstatic int\ttext_position_next(int start_pos, TextPositionState *state);\nstatic void text_position_cleanup(TextPositionState *state);\nstatic StringInfo makeStringAggState(FunctionCallInfo fcinfo);\n\nstatic StringInfo\nmakeStringAggState(FunctionCallInfo fcinfo)\n{\n\tStringInfo\tstate;\n\tMemoryContext aggcontext;\n\tMemoryContext oldcontext;\n\n\tif (!AggCheckCallContext(fcinfo, &aggcontext))\n\t{\n\t\t/* cannot be called directly because of internal-type argument */\n\t\telog(ERROR, \"string_agg_transfn called in non-aggregate context\");\n\t}\n\n\t/*\n\t * Create state in aggregate context.  It'll stay there across subsequent\n\t * calls.\n\t */\n\toldcontext = MemoryContextSwitchTo(aggcontext);\n\tstate = makeStringInfo();\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "1"
          ],
          "line": 4797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 4794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "0"
          ],
          "line": 4794
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void text_position_setup(text *t1, text *t2, TextPositionState *state);\nstatic int\ttext_position_next(int start_pos, TextPositionState *state);\nstatic void text_position_cleanup(TextPositionState *state);\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\nstatic StringInfo makeStringAggState(FunctionCallInfo fcinfo);\nstatic bool text_format_parse_digits(const char **ptr, const char *end_ptr,\n\t\t\t\t\t\t int *value);\n\nDatum\nstring_agg_transfn(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tstate;\n\n\tstate = PG_ARGISNULL(0) ? NULL : (StringInfo) PG_GETARG_POINTER(0);\n\n\t/* Append the value unless null. */\n\tif (!PG_ARGISNULL(1))\n\t{\n\t\t/* On the first time through, we ignore the delimiter. */\n\t\tif (state == NULL)\n\t\t\tstate = makeStringAggState(fcinfo);\n\t\telse if (!PG_ARGISNULL(2))\n\t\t\tappendStringInfoText(state, PG_GETARG_TEXT_PP(2));\t/* delimiter */\n\n\t\tappendStringInfoText(state, PG_GETARG_TEXT_PP(1));\t/* value */\n\t}\n\n\t/*\n\t * The transition type for string_agg() is declared to be \"internal\",\n\t * which is a pass-by-value type the same size as a pointer.\n\t */\n\tPG_RETURN_POINTER(state);\n}"
  },
  {
    "function_name": "makeStringAggState",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "4765-4787",
    "snippet": "static StringInfo\nmakeStringAggState(FunctionCallInfo fcinfo)\n{\n\tStringInfo\tstate;\n\tMemoryContext aggcontext;\n\tMemoryContext oldcontext;\n\n\tif (!AggCheckCallContext(fcinfo, &aggcontext))\n\t{\n\t\t/* cannot be called directly because of internal-type argument */\n\t\telog(ERROR, \"string_agg_transfn called in non-aggregate context\");\n\t}\n\n\t/*\n\t * Create state in aggregate context.  It'll stay there across subsequent\n\t * calls.\n\t */\n\toldcontext = MemoryContextSwitchTo(aggcontext);\n\tstate = makeStringInfo();\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn state;\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void text_position_setup(text *t1, text *t2, TextPositionState *state);",
      "static int\ttext_position_next(int start_pos, TextPositionState *state);",
      "static void text_position_cleanup(TextPositionState *state);",
      "static StringInfo makeStringAggState(FunctionCallInfo fcinfo);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 4784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeStringInfo",
          "args": [],
          "line": 4783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "aggcontext"
          ],
          "line": 4782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"string_agg_transfn called in non-aggregate context\""
          ],
          "line": 4775
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AggCheckCallContext",
          "args": [
            "fcinfo",
            "&aggcontext"
          ],
          "line": 4772
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void text_position_setup(text *t1, text *t2, TextPositionState *state);\nstatic int\ttext_position_next(int start_pos, TextPositionState *state);\nstatic void text_position_cleanup(TextPositionState *state);\nstatic StringInfo makeStringAggState(FunctionCallInfo fcinfo);\n\nstatic StringInfo\nmakeStringAggState(FunctionCallInfo fcinfo)\n{\n\tStringInfo\tstate;\n\tMemoryContext aggcontext;\n\tMemoryContext oldcontext;\n\n\tif (!AggCheckCallContext(fcinfo, &aggcontext))\n\t{\n\t\t/* cannot be called directly because of internal-type argument */\n\t\telog(ERROR, \"string_agg_transfn called in non-aggregate context\");\n\t}\n\n\t/*\n\t * Create state in aggregate context.  It'll stay there across subsequent\n\t * calls.\n\t */\n\toldcontext = MemoryContextSwitchTo(aggcontext);\n\tstate = makeStringInfo();\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn state;\n}"
  },
  {
    "function_name": "pg_column_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "4711-4752",
    "snippet": "Datum\npg_column_size(PG_FUNCTION_ARGS)\n{\n\tDatum\t\tvalue = PG_GETARG_DATUM(0);\n\tint32\t\tresult;\n\tint\t\t\ttyplen;\n\n\t/* On first call, get the input type's typlen, and save at *fn_extra */\n\tif (fcinfo->flinfo->fn_extra == NULL)\n\t{\n\t\t/* Lookup the datatype of the supplied argument */\n\t\tOid\t\t\targtypeid = get_fn_expr_argtype(fcinfo->flinfo, 0);\n\n\t\ttyplen = get_typlen(argtypeid);\n\t\tif (typlen == 0)\t\t/* should not happen */\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", argtypeid);\n\n\t\tfcinfo->flinfo->fn_extra = MemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  sizeof(int));\n\t\t*((int *) fcinfo->flinfo->fn_extra) = typlen;\n\t}\n\telse\n\t\ttyplen = *((int *) fcinfo->flinfo->fn_extra);\n\n\tif (typlen == -1)\n\t{\n\t\t/* varlena type, possibly toasted */\n\t\tresult = toast_datum_size(value);\n\t}\n\telse if (typlen == -2)\n\t{\n\t\t/* cstring */\n\t\tresult = strlen(DatumGetCString(value)) + 1;\n\t}\n\telse\n\t{\n\t\t/* ordinary fixed-width type */\n\t\tresult = typlen;\n\t}\n\n\tPG_RETURN_INT32(result);\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);",
      "static StringInfo makeStringAggState(FunctionCallInfo fcinfo);",
      "static bool text_format_parse_digits(const char **ptr, const char *end_ptr,\n\t\t\t\t\t\t int *value);",
      "static const char *text_format_parse_format(const char *start_ptr,\n\t\t\t\t\t\t const char *end_ptr,\n\t\t\t\t\t\t int *argpos, int *widthpos,\n\t\t\t\t\t\t int *flags, int *width);",
      "static void text_format_string_conversion(StringInfo buf, char conversion,\n\t\t\t\t\t\t\t  FmgrInfo *typOutputInfo,\n\t\t\t\t\t\t\t  Datum value, bool isNull,\n\t\t\t\t\t\t\t  int flags, int width);",
      "static void text_format_append_string(StringInfo buf, const char *str,\n\t\t\t\t\t\t  int flags, int width);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "result"
          ],
          "line": 4751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "DatumGetCString(value)"
          ],
          "line": 4743
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetCString",
          "args": [
            "value"
          ],
          "line": 4743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toast_datum_size",
          "args": [
            "value"
          ],
          "line": 4738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextAlloc",
          "args": [
            "fcinfo->flinfo->fn_mcxt",
            "sizeof(int)"
          ],
          "line": 4728
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1079-1106",
          "snippet": "void *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"cache lookup failed for type %u\"",
            "argtypeid"
          ],
          "line": 4726
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_typlen",
          "args": [
            "argtypeid"
          ],
          "line": 4724
        },
        "resolved": true,
        "details": {
          "function_name": "get_typlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "1974-1991",
          "snippet": "int16\nget_typlen(Oid typid)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_type typtup = (Form_pg_type) GETSTRUCT(tp);\n\t\tint16\t\tresult;\n\n\t\tresult = typtup->typlen;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn 0;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nint16\nget_typlen(Oid typid)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_type typtup = (Form_pg_type) GETSTRUCT(tp);\n\t\tint16\t\tresult;\n\n\t\tresult = typtup->typlen;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fn_expr_argtype",
          "args": [
            "fcinfo->flinfo",
            "0"
          ],
          "line": 4722
        },
        "resolved": true,
        "details": {
          "function_name": "get_fn_expr_argtype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1994-2005",
          "snippet": "Oid\nget_fn_expr_argtype(FmgrInfo *flinfo, int argnum)\n{\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn InvalidOid;\n\n\treturn get_call_expr_argtype(flinfo->fn_expr, argnum);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nOid\nget_fn_expr_argtype(FmgrInfo *flinfo, int argnum)\n{\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn InvalidOid;\n\n\treturn get_call_expr_argtype(flinfo->fn_expr, argnum);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "0"
          ],
          "line": 4714
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\nstatic StringInfo makeStringAggState(FunctionCallInfo fcinfo);\nstatic bool text_format_parse_digits(const char **ptr, const char *end_ptr,\n\t\t\t\t\t\t int *value);\nstatic const char *text_format_parse_format(const char *start_ptr,\n\t\t\t\t\t\t const char *end_ptr,\n\t\t\t\t\t\t int *argpos, int *widthpos,\n\t\t\t\t\t\t int *flags, int *width);\nstatic void text_format_string_conversion(StringInfo buf, char conversion,\n\t\t\t\t\t\t\t  FmgrInfo *typOutputInfo,\n\t\t\t\t\t\t\t  Datum value, bool isNull,\n\t\t\t\t\t\t\t  int flags, int width);\nstatic void text_format_append_string(StringInfo buf, const char *str,\n\t\t\t\t\t\t  int flags, int width);\n\nDatum\npg_column_size(PG_FUNCTION_ARGS)\n{\n\tDatum\t\tvalue = PG_GETARG_DATUM(0);\n\tint32\t\tresult;\n\tint\t\t\ttyplen;\n\n\t/* On first call, get the input type's typlen, and save at *fn_extra */\n\tif (fcinfo->flinfo->fn_extra == NULL)\n\t{\n\t\t/* Lookup the datatype of the supplied argument */\n\t\tOid\t\t\targtypeid = get_fn_expr_argtype(fcinfo->flinfo, 0);\n\n\t\ttyplen = get_typlen(argtypeid);\n\t\tif (typlen == 0)\t\t/* should not happen */\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", argtypeid);\n\n\t\tfcinfo->flinfo->fn_extra = MemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  sizeof(int));\n\t\t*((int *) fcinfo->flinfo->fn_extra) = typlen;\n\t}\n\telse\n\t\ttyplen = *((int *) fcinfo->flinfo->fn_extra);\n\n\tif (typlen == -1)\n\t{\n\t\t/* varlena type, possibly toasted */\n\t\tresult = toast_datum_size(value);\n\t}\n\telse if (typlen == -2)\n\t{\n\t\t/* cstring */\n\t\tresult = strlen(DatumGetCString(value)) + 1;\n\t}\n\telse\n\t{\n\t\t/* ordinary fixed-width type */\n\t\tresult = typlen;\n\t}\n\n\tPG_RETURN_INT32(result);\n}"
  },
  {
    "function_name": "to_hex64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "4686-4704",
    "snippet": "Datum\nto_hex64(PG_FUNCTION_ARGS)\n{\n\tuint64\t\tvalue = (uint64) PG_GETARG_INT64(0);\n\tchar\t   *ptr;\n\tconst char *digits = \"0123456789abcdef\";\n\tchar\t\tbuf[32];\t\t/* bigger than needed, but reasonable */\n\n\tptr = buf + sizeof(buf) - 1;\n\t*ptr = '\\0';\n\n\tdo\n\t{\n\t\t*--ptr = digits[value % HEXBASE];\n\t\tvalue /= HEXBASE;\n\t} while (ptr > buf && value);\n\n\tPG_RETURN_TEXT_P(cstring_to_text(ptr));\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define HEXBASE 16"
    ],
    "globals_used": [
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);",
      "static bool text_format_parse_digits(const char **ptr, const char *end_ptr,\n\t\t\t\t\t\t int *value);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "cstring_to_text(ptr)"
          ],
          "line": 4703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cstring_to_text",
          "args": [
            "ptr"
          ],
          "line": 4703
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "148-152",
          "snippet": "text *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT64",
          "args": [
            "0"
          ],
          "line": 4689
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define HEXBASE 16\n\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\nstatic bool text_format_parse_digits(const char **ptr, const char *end_ptr,\n\t\t\t\t\t\t int *value);\n\nDatum\nto_hex64(PG_FUNCTION_ARGS)\n{\n\tuint64\t\tvalue = (uint64) PG_GETARG_INT64(0);\n\tchar\t   *ptr;\n\tconst char *digits = \"0123456789abcdef\";\n\tchar\t\tbuf[32];\t\t/* bigger than needed, but reasonable */\n\n\tptr = buf + sizeof(buf) - 1;\n\t*ptr = '\\0';\n\n\tdo\n\t{\n\t\t*--ptr = digits[value % HEXBASE];\n\t\tvalue /= HEXBASE;\n\t} while (ptr > buf && value);\n\n\tPG_RETURN_TEXT_P(cstring_to_text(ptr));\n}"
  },
  {
    "function_name": "to_hex32",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "4662-4680",
    "snippet": "Datum\nto_hex32(PG_FUNCTION_ARGS)\n{\n\tuint32\t\tvalue = (uint32) PG_GETARG_INT32(0);\n\tchar\t   *ptr;\n\tconst char *digits = \"0123456789abcdef\";\n\tchar\t\tbuf[32];\t\t/* bigger than needed, but reasonable */\n\n\tptr = buf + sizeof(buf) - 1;\n\t*ptr = '\\0';\n\n\tdo\n\t{\n\t\t*--ptr = digits[value % HEXBASE];\n\t\tvalue /= HEXBASE;\n\t} while (ptr > buf && value);\n\n\tPG_RETURN_TEXT_P(cstring_to_text(ptr));\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define HEXBASE 16"
    ],
    "globals_used": [
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);",
      "static bool text_format_parse_digits(const char **ptr, const char *end_ptr,\n\t\t\t\t\t\t int *value);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "cstring_to_text(ptr)"
          ],
          "line": 4679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cstring_to_text",
          "args": [
            "ptr"
          ],
          "line": 4679
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "148-152",
          "snippet": "text *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "0"
          ],
          "line": 4665
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define HEXBASE 16\n\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\nstatic bool text_format_parse_digits(const char **ptr, const char *end_ptr,\n\t\t\t\t\t\t int *value);\n\nDatum\nto_hex32(PG_FUNCTION_ARGS)\n{\n\tuint32\t\tvalue = (uint32) PG_GETARG_INT32(0);\n\tchar\t   *ptr;\n\tconst char *digits = \"0123456789abcdef\";\n\tchar\t\tbuf[32];\t\t/* bigger than needed, but reasonable */\n\n\tptr = buf + sizeof(buf) - 1;\n\t*ptr = '\\0';\n\n\tdo\n\t{\n\t\t*--ptr = digits[value % HEXBASE];\n\t\tvalue /= HEXBASE;\n\t} while (ptr > buf && value);\n\n\tPG_RETURN_TEXT_P(cstring_to_text(ptr));\n}"
  },
  {
    "function_name": "array_to_text_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "4539-4655",
    "snippet": "static text *\narray_to_text_internal(FunctionCallInfo fcinfo, ArrayType *v,\n\t\t\t\t\t   const char *fldsep, const char *null_string)\n{\n\ttext\t   *result;\n\tint\t\t\tnitems,\n\t\t\t   *dims,\n\t\t\t\tndims;\n\tOid\t\t\telement_type;\n\tint\t\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tStringInfoData buf;\n\tbool\t\tprinted = false;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\tArrayMetaState *my_extra;\n\n\tndims = ARR_NDIM(v);\n\tdims = ARR_DIMS(v);\n\tnitems = ArrayGetNItems(ndims, dims);\n\n\t/* if there are no elements, return an empty string */\n\tif (nitems == 0)\n\t\treturn cstring_to_text_with_len(\"\", 0);\n\n\telement_type = ARR_ELEMTYPE(v);\n\tinitStringInfo(&buf);\n\n\t/*\n\t * We arrange to look up info about element type, including its output\n\t * conversion proc, only once per series of calls, assuming the element\n\t * type doesn't change underneath us.\n\t */\n\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL)\n\t{\n\t\tfcinfo->flinfo->fn_extra = MemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  sizeof(ArrayMetaState));\n\t\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->element_type = ~element_type;\n\t}\n\n\tif (my_extra->element_type != element_type)\n\t{\n\t\t/*\n\t\t * Get info about element type, including its output conversion proc\n\t\t */\n\t\tget_type_io_data(element_type, IOFunc_output,\n\t\t\t\t\t\t &my_extra->typlen, &my_extra->typbyval,\n\t\t\t\t\t\t &my_extra->typalign, &my_extra->typdelim,\n\t\t\t\t\t\t &my_extra->typioparam, &my_extra->typiofunc);\n\t\tfmgr_info_cxt(my_extra->typiofunc, &my_extra->proc,\n\t\t\t\t\t  fcinfo->flinfo->fn_mcxt);\n\t\tmy_extra->element_type = element_type;\n\t}\n\ttyplen = my_extra->typlen;\n\ttypbyval = my_extra->typbyval;\n\ttypalign = my_extra->typalign;\n\n\tp = ARR_DATA_PTR(v);\n\tbitmap = ARR_NULLBITMAP(v);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tDatum\t\titemvalue;\n\t\tchar\t   *value;\n\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\t/* if null_string is NULL, we just ignore null elements */\n\t\t\tif (null_string != NULL)\n\t\t\t{\n\t\t\t\tif (printed)\n\t\t\t\t\tappendStringInfo(&buf, \"%s%s\", fldsep, null_string);\n\t\t\t\telse\n\t\t\t\t\tappendStringInfoString(&buf, null_string);\n\t\t\t\tprinted = true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\titemvalue = fetch_att(p, typbyval, typlen);\n\n\t\t\tvalue = OutputFunctionCall(&my_extra->proc, itemvalue);\n\n\t\t\tif (printed)\n\t\t\t\tappendStringInfo(&buf, \"%s%s\", fldsep, value);\n\t\t\telse\n\t\t\t\tappendStringInfoString(&buf, value);\n\t\t\tprinted = true;\n\n\t\t\tp = att_addlength_pointer(p, typlen, p);\n\t\t\tp = (char *) att_align_nominal(p, typalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tresult = cstring_to_text_with_len(buf.data, buf.len);\n\tpfree(buf.data);\n\n\treturn result;\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void appendStringInfoText(StringInfo str, const text *t);",
      "static text *array_to_text_internal(FunctionCallInfo fcinfo, ArrayType *v,\n\t\t\t\t\t   const char *fldsep, const char *null_string);",
      "static StringInfo makeStringAggState(FunctionCallInfo fcinfo);",
      "static bool text_format_parse_digits(const char **ptr, const char *end_ptr,\n\t\t\t\t\t\t int *value);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "buf.data"
          ],
          "line": 4652
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cstring_to_text_with_len",
          "args": [
            "buf.data",
            "buf.len"
          ],
          "line": 4651
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "160-169",
          "snippet": "text *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "att_align_nominal",
          "args": [
            "p",
            "typalign"
          ],
          "line": 4636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "att_addlength_pointer",
          "args": [
            "p",
            "typlen",
            "p"
          ],
          "line": 4635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&buf",
            "value"
          ],
          "line": 4632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&buf",
            "\"%s%s\"",
            "fldsep",
            "value"
          ],
          "line": 4630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OutputFunctionCall",
          "args": [
            "&my_extra->proc",
            "itemvalue"
          ],
          "line": 4627
        },
        "resolved": true,
        "details": {
          "function_name": "OidOutputFunctionCall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1832-1839",
          "snippet": "char *\nOidOutputFunctionCall(Oid functionId, Datum val)\n{\n\tFmgrInfo\tflinfo;\n\n\tfmgr_info(functionId, &flinfo);\n\treturn OutputFunctionCall(&flinfo, val);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nchar *\nOidOutputFunctionCall(Oid functionId, Datum val)\n{\n\tFmgrInfo\tflinfo;\n\n\tfmgr_info(functionId, &flinfo);\n\treturn OutputFunctionCall(&flinfo, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fetch_att",
          "args": [
            "p",
            "typbyval",
            "typlen"
          ],
          "line": 4625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&buf",
            "null_string"
          ],
          "line": 4619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&buf",
            "\"%s%s\"",
            "fldsep",
            "null_string"
          ],
          "line": 4617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NULLBITMAP",
          "args": [
            "v"
          ],
          "line": 4602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DATA_PTR",
          "args": [
            "v"
          ],
          "line": 4601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fmgr_info_cxt",
          "args": [
            "my_extra->typiofunc",
            "&my_extra->proc",
            "fcinfo->flinfo->fn_mcxt"
          ],
          "line": 4593
        },
        "resolved": true,
        "details": {
          "function_name": "fmgr_info_cxt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "133-137",
          "snippet": "void\nfmgr_info_cxt(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt)\n{\n\tfmgr_info_cxt_security(functionId, finfo, mcxt, false);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nvoid\nfmgr_info_cxt(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt)\n{\n\tfmgr_info_cxt_security(functionId, finfo, mcxt, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_type_io_data",
          "args": [
            "element_type",
            "IOFunc_output",
            "&my_extra->typlen",
            "&my_extra->typbyval",
            "&my_extra->typalign",
            "&my_extra->typdelim",
            "&my_extra->typioparam",
            "&my_extra->typiofunc"
          ],
          "line": 4589
        },
        "resolved": true,
        "details": {
          "function_name": "get_type_io_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2102-2173",
          "snippet": "void\nget_type_io_data(Oid typid,\n\t\t\t\t IOFuncSelector which_func,\n\t\t\t\t int16 *typlen,\n\t\t\t\t bool *typbyval,\n\t\t\t\t char *typalign,\n\t\t\t\t char *typdelim,\n\t\t\t\t Oid *typioparam,\n\t\t\t\t Oid *func)\n{\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type typeStruct;\n\n\t/*\n\t * In bootstrap mode, pass it off to bootstrap.c.  This hack allows us to\n\t * use array_in and array_out during bootstrap.\n\t */\n\tif (IsBootstrapProcessingMode())\n\t{\n\t\tOid\t\t\ttypinput;\n\t\tOid\t\t\ttypoutput;\n\n\t\tboot_get_type_io_data(typid,\n\t\t\t\t\t\t\t  typlen,\n\t\t\t\t\t\t\t  typbyval,\n\t\t\t\t\t\t\t  typalign,\n\t\t\t\t\t\t\t  typdelim,\n\t\t\t\t\t\t\t  typioparam,\n\t\t\t\t\t\t\t  &typinput,\n\t\t\t\t\t\t\t  &typoutput);\n\t\tswitch (which_func)\n\t\t{\n\t\t\tcase IOFunc_input:\n\t\t\t\t*func = typinput;\n\t\t\t\tbreak;\n\t\t\tcase IOFunc_output:\n\t\t\t\t*func = typoutput;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"binary I/O not supported during bootstrap\");\n\t\t\t\tbreak;\n\t\t}\n\t\treturn;\n\t}\n\n\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (!HeapTupleIsValid(typeTuple))\n\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\ttypeStruct = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\t*typlen = typeStruct->typlen;\n\t*typbyval = typeStruct->typbyval;\n\t*typalign = typeStruct->typalign;\n\t*typdelim = typeStruct->typdelim;\n\t*typioparam = getTypeIOParam(typeTuple);\n\tswitch (which_func)\n\t{\n\t\tcase IOFunc_input:\n\t\t\t*func = typeStruct->typinput;\n\t\t\tbreak;\n\t\tcase IOFunc_output:\n\t\t\t*func = typeStruct->typoutput;\n\t\t\tbreak;\n\t\tcase IOFunc_receive:\n\t\t\t*func = typeStruct->typreceive;\n\t\t\tbreak;\n\t\tcase IOFunc_send:\n\t\t\t*func = typeStruct->typsend;\n\t\t\tbreak;\n\t}\n\tReleaseSysCache(typeTuple);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nget_type_io_data(Oid typid,\n\t\t\t\t IOFuncSelector which_func,\n\t\t\t\t int16 *typlen,\n\t\t\t\t bool *typbyval,\n\t\t\t\t char *typalign,\n\t\t\t\t char *typdelim,\n\t\t\t\t Oid *typioparam,\n\t\t\t\t Oid *func)\n{\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type typeStruct;\n\n\t/*\n\t * In bootstrap mode, pass it off to bootstrap.c.  This hack allows us to\n\t * use array_in and array_out during bootstrap.\n\t */\n\tif (IsBootstrapProcessingMode())\n\t{\n\t\tOid\t\t\ttypinput;\n\t\tOid\t\t\ttypoutput;\n\n\t\tboot_get_type_io_data(typid,\n\t\t\t\t\t\t\t  typlen,\n\t\t\t\t\t\t\t  typbyval,\n\t\t\t\t\t\t\t  typalign,\n\t\t\t\t\t\t\t  typdelim,\n\t\t\t\t\t\t\t  typioparam,\n\t\t\t\t\t\t\t  &typinput,\n\t\t\t\t\t\t\t  &typoutput);\n\t\tswitch (which_func)\n\t\t{\n\t\t\tcase IOFunc_input:\n\t\t\t\t*func = typinput;\n\t\t\t\tbreak;\n\t\t\tcase IOFunc_output:\n\t\t\t\t*func = typoutput;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"binary I/O not supported during bootstrap\");\n\t\t\t\tbreak;\n\t\t}\n\t\treturn;\n\t}\n\n\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (!HeapTupleIsValid(typeTuple))\n\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\ttypeStruct = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\t*typlen = typeStruct->typlen;\n\t*typbyval = typeStruct->typbyval;\n\t*typalign = typeStruct->typalign;\n\t*typdelim = typeStruct->typdelim;\n\t*typioparam = getTypeIOParam(typeTuple);\n\tswitch (which_func)\n\t{\n\t\tcase IOFunc_input:\n\t\t\t*func = typeStruct->typinput;\n\t\t\tbreak;\n\t\tcase IOFunc_output:\n\t\t\t*func = typeStruct->typoutput;\n\t\t\tbreak;\n\t\tcase IOFunc_receive:\n\t\t\t*func = typeStruct->typreceive;\n\t\t\tbreak;\n\t\tcase IOFunc_send:\n\t\t\t*func = typeStruct->typsend;\n\t\t\tbreak;\n\t}\n\tReleaseSysCache(typeTuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextAlloc",
          "args": [
            "fcinfo->flinfo->fn_mcxt",
            "sizeof(ArrayMetaState)"
          ],
          "line": 4578
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1079-1106",
          "snippet": "void *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "initStringInfo",
          "args": [
            "&buf"
          ],
          "line": 4568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_ELEMTYPE",
          "args": [
            "v"
          ],
          "line": 4567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ArrayGetNItems",
          "args": [
            "ndims",
            "dims"
          ],
          "line": 4561
        },
        "resolved": true,
        "details": {
          "function_name": "ArrayGetNItems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
          "lines": "74-112",
          "snippet": "int\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\nint\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "v"
          ],
          "line": 4560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NDIM",
          "args": [
            "v"
          ],
          "line": 4559
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\nstatic text *array_to_text_internal(FunctionCallInfo fcinfo, ArrayType *v,\n\t\t\t\t\t   const char *fldsep, const char *null_string);\nstatic StringInfo makeStringAggState(FunctionCallInfo fcinfo);\nstatic bool text_format_parse_digits(const char **ptr, const char *end_ptr,\n\t\t\t\t\t\t int *value);\n\nstatic text *\narray_to_text_internal(FunctionCallInfo fcinfo, ArrayType *v,\n\t\t\t\t\t   const char *fldsep, const char *null_string)\n{\n\ttext\t   *result;\n\tint\t\t\tnitems,\n\t\t\t   *dims,\n\t\t\t\tndims;\n\tOid\t\t\telement_type;\n\tint\t\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tStringInfoData buf;\n\tbool\t\tprinted = false;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\tArrayMetaState *my_extra;\n\n\tndims = ARR_NDIM(v);\n\tdims = ARR_DIMS(v);\n\tnitems = ArrayGetNItems(ndims, dims);\n\n\t/* if there are no elements, return an empty string */\n\tif (nitems == 0)\n\t\treturn cstring_to_text_with_len(\"\", 0);\n\n\telement_type = ARR_ELEMTYPE(v);\n\tinitStringInfo(&buf);\n\n\t/*\n\t * We arrange to look up info about element type, including its output\n\t * conversion proc, only once per series of calls, assuming the element\n\t * type doesn't change underneath us.\n\t */\n\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL)\n\t{\n\t\tfcinfo->flinfo->fn_extra = MemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  sizeof(ArrayMetaState));\n\t\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->element_type = ~element_type;\n\t}\n\n\tif (my_extra->element_type != element_type)\n\t{\n\t\t/*\n\t\t * Get info about element type, including its output conversion proc\n\t\t */\n\t\tget_type_io_data(element_type, IOFunc_output,\n\t\t\t\t\t\t &my_extra->typlen, &my_extra->typbyval,\n\t\t\t\t\t\t &my_extra->typalign, &my_extra->typdelim,\n\t\t\t\t\t\t &my_extra->typioparam, &my_extra->typiofunc);\n\t\tfmgr_info_cxt(my_extra->typiofunc, &my_extra->proc,\n\t\t\t\t\t  fcinfo->flinfo->fn_mcxt);\n\t\tmy_extra->element_type = element_type;\n\t}\n\ttyplen = my_extra->typlen;\n\ttypbyval = my_extra->typbyval;\n\ttypalign = my_extra->typalign;\n\n\tp = ARR_DATA_PTR(v);\n\tbitmap = ARR_NULLBITMAP(v);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tDatum\t\titemvalue;\n\t\tchar\t   *value;\n\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\t/* if null_string is NULL, we just ignore null elements */\n\t\t\tif (null_string != NULL)\n\t\t\t{\n\t\t\t\tif (printed)\n\t\t\t\t\tappendStringInfo(&buf, \"%s%s\", fldsep, null_string);\n\t\t\t\telse\n\t\t\t\t\tappendStringInfoString(&buf, null_string);\n\t\t\t\tprinted = true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\titemvalue = fetch_att(p, typbyval, typlen);\n\n\t\t\tvalue = OutputFunctionCall(&my_extra->proc, itemvalue);\n\n\t\t\tif (printed)\n\t\t\t\tappendStringInfo(&buf, \"%s%s\", fldsep, value);\n\t\t\telse\n\t\t\t\tappendStringInfoString(&buf, value);\n\t\t\tprinted = true;\n\n\t\t\tp = att_addlength_pointer(p, typlen, p);\n\t\t\tp = (char *) att_align_nominal(p, typalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tresult = cstring_to_text_with_len(buf.data, buf.len);\n\tpfree(buf.data);\n\n\treturn result;\n}"
  },
  {
    "function_name": "array_to_text_null",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "4513-4534",
    "snippet": "Datum\narray_to_text_null(PG_FUNCTION_ARGS)\n{\n\tArrayType  *v;\n\tchar\t   *fldsep;\n\tchar\t   *null_string;\n\n\t/* returns NULL when first or second parameter is NULL */\n\tif (PG_ARGISNULL(0) || PG_ARGISNULL(1))\n\t\tPG_RETURN_NULL();\n\n\tv = PG_GETARG_ARRAYTYPE_P(0);\n\tfldsep = text_to_cstring(PG_GETARG_TEXT_PP(1));\n\n\t/* NULL null string is passed through as a null pointer */\n\tif (!PG_ARGISNULL(2))\n\t\tnull_string = text_to_cstring(PG_GETARG_TEXT_PP(2));\n\telse\n\t\tnull_string = NULL;\n\n\tPG_RETURN_TEXT_P(array_to_text_internal(fcinfo, v, fldsep, null_string));\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);",
      "static text *array_to_text_internal(FunctionCallInfo fcinfo, ArrayType *v,\n\t\t\t\t\t   const char *fldsep, const char *null_string);",
      "static StringInfo makeStringAggState(FunctionCallInfo fcinfo);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "array_to_text_internal(fcinfo, v, fldsep, null_string)"
          ],
          "line": 4533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_to_text_internal",
          "args": [
            "fcinfo",
            "v",
            "fldsep",
            "null_string"
          ],
          "line": 4533
        },
        "resolved": true,
        "details": {
          "function_name": "array_to_text_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "4539-4655",
          "snippet": "static text *\narray_to_text_internal(FunctionCallInfo fcinfo, ArrayType *v,\n\t\t\t\t\t   const char *fldsep, const char *null_string)\n{\n\ttext\t   *result;\n\tint\t\t\tnitems,\n\t\t\t   *dims,\n\t\t\t\tndims;\n\tOid\t\t\telement_type;\n\tint\t\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tStringInfoData buf;\n\tbool\t\tprinted = false;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\tArrayMetaState *my_extra;\n\n\tndims = ARR_NDIM(v);\n\tdims = ARR_DIMS(v);\n\tnitems = ArrayGetNItems(ndims, dims);\n\n\t/* if there are no elements, return an empty string */\n\tif (nitems == 0)\n\t\treturn cstring_to_text_with_len(\"\", 0);\n\n\telement_type = ARR_ELEMTYPE(v);\n\tinitStringInfo(&buf);\n\n\t/*\n\t * We arrange to look up info about element type, including its output\n\t * conversion proc, only once per series of calls, assuming the element\n\t * type doesn't change underneath us.\n\t */\n\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL)\n\t{\n\t\tfcinfo->flinfo->fn_extra = MemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  sizeof(ArrayMetaState));\n\t\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->element_type = ~element_type;\n\t}\n\n\tif (my_extra->element_type != element_type)\n\t{\n\t\t/*\n\t\t * Get info about element type, including its output conversion proc\n\t\t */\n\t\tget_type_io_data(element_type, IOFunc_output,\n\t\t\t\t\t\t &my_extra->typlen, &my_extra->typbyval,\n\t\t\t\t\t\t &my_extra->typalign, &my_extra->typdelim,\n\t\t\t\t\t\t &my_extra->typioparam, &my_extra->typiofunc);\n\t\tfmgr_info_cxt(my_extra->typiofunc, &my_extra->proc,\n\t\t\t\t\t  fcinfo->flinfo->fn_mcxt);\n\t\tmy_extra->element_type = element_type;\n\t}\n\ttyplen = my_extra->typlen;\n\ttypbyval = my_extra->typbyval;\n\ttypalign = my_extra->typalign;\n\n\tp = ARR_DATA_PTR(v);\n\tbitmap = ARR_NULLBITMAP(v);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tDatum\t\titemvalue;\n\t\tchar\t   *value;\n\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\t/* if null_string is NULL, we just ignore null elements */\n\t\t\tif (null_string != NULL)\n\t\t\t{\n\t\t\t\tif (printed)\n\t\t\t\t\tappendStringInfo(&buf, \"%s%s\", fldsep, null_string);\n\t\t\t\telse\n\t\t\t\t\tappendStringInfoString(&buf, null_string);\n\t\t\t\tprinted = true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\titemvalue = fetch_att(p, typbyval, typlen);\n\n\t\t\tvalue = OutputFunctionCall(&my_extra->proc, itemvalue);\n\n\t\t\tif (printed)\n\t\t\t\tappendStringInfo(&buf, \"%s%s\", fldsep, value);\n\t\t\telse\n\t\t\t\tappendStringInfoString(&buf, value);\n\t\t\tprinted = true;\n\n\t\t\tp = att_addlength_pointer(p, typlen, p);\n\t\t\tp = (char *) att_align_nominal(p, typalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tresult = cstring_to_text_with_len(buf.data, buf.len);\n\tpfree(buf.data);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void appendStringInfoText(StringInfo str, const text *t);",
            "static text *array_to_text_internal(FunctionCallInfo fcinfo, ArrayType *v,\n\t\t\t\t\t   const char *fldsep, const char *null_string);",
            "static StringInfo makeStringAggState(FunctionCallInfo fcinfo);",
            "static bool text_format_parse_digits(const char **ptr, const char *end_ptr,\n\t\t\t\t\t\t int *value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\nstatic text *array_to_text_internal(FunctionCallInfo fcinfo, ArrayType *v,\n\t\t\t\t\t   const char *fldsep, const char *null_string);\nstatic StringInfo makeStringAggState(FunctionCallInfo fcinfo);\nstatic bool text_format_parse_digits(const char **ptr, const char *end_ptr,\n\t\t\t\t\t\t int *value);\n\nstatic text *\narray_to_text_internal(FunctionCallInfo fcinfo, ArrayType *v,\n\t\t\t\t\t   const char *fldsep, const char *null_string)\n{\n\ttext\t   *result;\n\tint\t\t\tnitems,\n\t\t\t   *dims,\n\t\t\t\tndims;\n\tOid\t\t\telement_type;\n\tint\t\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tStringInfoData buf;\n\tbool\t\tprinted = false;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\tArrayMetaState *my_extra;\n\n\tndims = ARR_NDIM(v);\n\tdims = ARR_DIMS(v);\n\tnitems = ArrayGetNItems(ndims, dims);\n\n\t/* if there are no elements, return an empty string */\n\tif (nitems == 0)\n\t\treturn cstring_to_text_with_len(\"\", 0);\n\n\telement_type = ARR_ELEMTYPE(v);\n\tinitStringInfo(&buf);\n\n\t/*\n\t * We arrange to look up info about element type, including its output\n\t * conversion proc, only once per series of calls, assuming the element\n\t * type doesn't change underneath us.\n\t */\n\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL)\n\t{\n\t\tfcinfo->flinfo->fn_extra = MemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  sizeof(ArrayMetaState));\n\t\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->element_type = ~element_type;\n\t}\n\n\tif (my_extra->element_type != element_type)\n\t{\n\t\t/*\n\t\t * Get info about element type, including its output conversion proc\n\t\t */\n\t\tget_type_io_data(element_type, IOFunc_output,\n\t\t\t\t\t\t &my_extra->typlen, &my_extra->typbyval,\n\t\t\t\t\t\t &my_extra->typalign, &my_extra->typdelim,\n\t\t\t\t\t\t &my_extra->typioparam, &my_extra->typiofunc);\n\t\tfmgr_info_cxt(my_extra->typiofunc, &my_extra->proc,\n\t\t\t\t\t  fcinfo->flinfo->fn_mcxt);\n\t\tmy_extra->element_type = element_type;\n\t}\n\ttyplen = my_extra->typlen;\n\ttypbyval = my_extra->typbyval;\n\ttypalign = my_extra->typalign;\n\n\tp = ARR_DATA_PTR(v);\n\tbitmap = ARR_NULLBITMAP(v);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tDatum\t\titemvalue;\n\t\tchar\t   *value;\n\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\t/* if null_string is NULL, we just ignore null elements */\n\t\t\tif (null_string != NULL)\n\t\t\t{\n\t\t\t\tif (printed)\n\t\t\t\t\tappendStringInfo(&buf, \"%s%s\", fldsep, null_string);\n\t\t\t\telse\n\t\t\t\t\tappendStringInfoString(&buf, null_string);\n\t\t\t\tprinted = true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\titemvalue = fetch_att(p, typbyval, typlen);\n\n\t\t\tvalue = OutputFunctionCall(&my_extra->proc, itemvalue);\n\n\t\t\tif (printed)\n\t\t\t\tappendStringInfo(&buf, \"%s%s\", fldsep, value);\n\t\t\telse\n\t\t\t\tappendStringInfoString(&buf, value);\n\t\t\tprinted = true;\n\n\t\t\tp = att_addlength_pointer(p, typlen, p);\n\t\t\tp = (char *) att_align_nominal(p, typalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tresult = cstring_to_text_with_len(buf.data, buf.len);\n\tpfree(buf.data);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "text_to_cstring",
          "args": [
            "PG_GETARG_TEXT_PP(2)"
          ],
          "line": 4529
        },
        "resolved": true,
        "details": {
          "function_name": "text_to_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "181-197",
          "snippet": "char *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nchar *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "2"
          ],
          "line": 4529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "2"
          ],
          "line": 4528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 4525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "0"
          ],
          "line": 4524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 4522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "1"
          ],
          "line": 4521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "0"
          ],
          "line": 4521
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\nstatic text *array_to_text_internal(FunctionCallInfo fcinfo, ArrayType *v,\n\t\t\t\t\t   const char *fldsep, const char *null_string);\nstatic StringInfo makeStringAggState(FunctionCallInfo fcinfo);\n\nDatum\narray_to_text_null(PG_FUNCTION_ARGS)\n{\n\tArrayType  *v;\n\tchar\t   *fldsep;\n\tchar\t   *null_string;\n\n\t/* returns NULL when first or second parameter is NULL */\n\tif (PG_ARGISNULL(0) || PG_ARGISNULL(1))\n\t\tPG_RETURN_NULL();\n\n\tv = PG_GETARG_ARRAYTYPE_P(0);\n\tfldsep = text_to_cstring(PG_GETARG_TEXT_PP(1));\n\n\t/* NULL null string is passed through as a null pointer */\n\tif (!PG_ARGISNULL(2))\n\t\tnull_string = text_to_cstring(PG_GETARG_TEXT_PP(2));\n\telse\n\t\tnull_string = NULL;\n\n\tPG_RETURN_TEXT_P(array_to_text_internal(fcinfo, v, fldsep, null_string));\n}"
  },
  {
    "function_name": "array_to_text",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "4497-4504",
    "snippet": "Datum\narray_to_text(PG_FUNCTION_ARGS)\n{\n\tArrayType  *v = PG_GETARG_ARRAYTYPE_P(0);\n\tchar\t   *fldsep = text_to_cstring(PG_GETARG_TEXT_PP(1));\n\n\tPG_RETURN_TEXT_P(array_to_text_internal(fcinfo, v, fldsep, NULL));\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);",
      "static StringInfo makeStringAggState(FunctionCallInfo fcinfo);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "array_to_text_internal(fcinfo, v, fldsep, NULL)"
          ],
          "line": 4503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_to_text_internal",
          "args": [
            "fcinfo",
            "v",
            "fldsep",
            "NULL"
          ],
          "line": 4503
        },
        "resolved": true,
        "details": {
          "function_name": "array_to_text_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "4539-4655",
          "snippet": "static text *\narray_to_text_internal(FunctionCallInfo fcinfo, ArrayType *v,\n\t\t\t\t\t   const char *fldsep, const char *null_string)\n{\n\ttext\t   *result;\n\tint\t\t\tnitems,\n\t\t\t   *dims,\n\t\t\t\tndims;\n\tOid\t\t\telement_type;\n\tint\t\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tStringInfoData buf;\n\tbool\t\tprinted = false;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\tArrayMetaState *my_extra;\n\n\tndims = ARR_NDIM(v);\n\tdims = ARR_DIMS(v);\n\tnitems = ArrayGetNItems(ndims, dims);\n\n\t/* if there are no elements, return an empty string */\n\tif (nitems == 0)\n\t\treturn cstring_to_text_with_len(\"\", 0);\n\n\telement_type = ARR_ELEMTYPE(v);\n\tinitStringInfo(&buf);\n\n\t/*\n\t * We arrange to look up info about element type, including its output\n\t * conversion proc, only once per series of calls, assuming the element\n\t * type doesn't change underneath us.\n\t */\n\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL)\n\t{\n\t\tfcinfo->flinfo->fn_extra = MemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  sizeof(ArrayMetaState));\n\t\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->element_type = ~element_type;\n\t}\n\n\tif (my_extra->element_type != element_type)\n\t{\n\t\t/*\n\t\t * Get info about element type, including its output conversion proc\n\t\t */\n\t\tget_type_io_data(element_type, IOFunc_output,\n\t\t\t\t\t\t &my_extra->typlen, &my_extra->typbyval,\n\t\t\t\t\t\t &my_extra->typalign, &my_extra->typdelim,\n\t\t\t\t\t\t &my_extra->typioparam, &my_extra->typiofunc);\n\t\tfmgr_info_cxt(my_extra->typiofunc, &my_extra->proc,\n\t\t\t\t\t  fcinfo->flinfo->fn_mcxt);\n\t\tmy_extra->element_type = element_type;\n\t}\n\ttyplen = my_extra->typlen;\n\ttypbyval = my_extra->typbyval;\n\ttypalign = my_extra->typalign;\n\n\tp = ARR_DATA_PTR(v);\n\tbitmap = ARR_NULLBITMAP(v);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tDatum\t\titemvalue;\n\t\tchar\t   *value;\n\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\t/* if null_string is NULL, we just ignore null elements */\n\t\t\tif (null_string != NULL)\n\t\t\t{\n\t\t\t\tif (printed)\n\t\t\t\t\tappendStringInfo(&buf, \"%s%s\", fldsep, null_string);\n\t\t\t\telse\n\t\t\t\t\tappendStringInfoString(&buf, null_string);\n\t\t\t\tprinted = true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\titemvalue = fetch_att(p, typbyval, typlen);\n\n\t\t\tvalue = OutputFunctionCall(&my_extra->proc, itemvalue);\n\n\t\t\tif (printed)\n\t\t\t\tappendStringInfo(&buf, \"%s%s\", fldsep, value);\n\t\t\telse\n\t\t\t\tappendStringInfoString(&buf, value);\n\t\t\tprinted = true;\n\n\t\t\tp = att_addlength_pointer(p, typlen, p);\n\t\t\tp = (char *) att_align_nominal(p, typalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tresult = cstring_to_text_with_len(buf.data, buf.len);\n\tpfree(buf.data);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void appendStringInfoText(StringInfo str, const text *t);",
            "static text *array_to_text_internal(FunctionCallInfo fcinfo, ArrayType *v,\n\t\t\t\t\t   const char *fldsep, const char *null_string);",
            "static StringInfo makeStringAggState(FunctionCallInfo fcinfo);",
            "static bool text_format_parse_digits(const char **ptr, const char *end_ptr,\n\t\t\t\t\t\t int *value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\nstatic text *array_to_text_internal(FunctionCallInfo fcinfo, ArrayType *v,\n\t\t\t\t\t   const char *fldsep, const char *null_string);\nstatic StringInfo makeStringAggState(FunctionCallInfo fcinfo);\nstatic bool text_format_parse_digits(const char **ptr, const char *end_ptr,\n\t\t\t\t\t\t int *value);\n\nstatic text *\narray_to_text_internal(FunctionCallInfo fcinfo, ArrayType *v,\n\t\t\t\t\t   const char *fldsep, const char *null_string)\n{\n\ttext\t   *result;\n\tint\t\t\tnitems,\n\t\t\t   *dims,\n\t\t\t\tndims;\n\tOid\t\t\telement_type;\n\tint\t\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tStringInfoData buf;\n\tbool\t\tprinted = false;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\tArrayMetaState *my_extra;\n\n\tndims = ARR_NDIM(v);\n\tdims = ARR_DIMS(v);\n\tnitems = ArrayGetNItems(ndims, dims);\n\n\t/* if there are no elements, return an empty string */\n\tif (nitems == 0)\n\t\treturn cstring_to_text_with_len(\"\", 0);\n\n\telement_type = ARR_ELEMTYPE(v);\n\tinitStringInfo(&buf);\n\n\t/*\n\t * We arrange to look up info about element type, including its output\n\t * conversion proc, only once per series of calls, assuming the element\n\t * type doesn't change underneath us.\n\t */\n\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL)\n\t{\n\t\tfcinfo->flinfo->fn_extra = MemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  sizeof(ArrayMetaState));\n\t\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->element_type = ~element_type;\n\t}\n\n\tif (my_extra->element_type != element_type)\n\t{\n\t\t/*\n\t\t * Get info about element type, including its output conversion proc\n\t\t */\n\t\tget_type_io_data(element_type, IOFunc_output,\n\t\t\t\t\t\t &my_extra->typlen, &my_extra->typbyval,\n\t\t\t\t\t\t &my_extra->typalign, &my_extra->typdelim,\n\t\t\t\t\t\t &my_extra->typioparam, &my_extra->typiofunc);\n\t\tfmgr_info_cxt(my_extra->typiofunc, &my_extra->proc,\n\t\t\t\t\t  fcinfo->flinfo->fn_mcxt);\n\t\tmy_extra->element_type = element_type;\n\t}\n\ttyplen = my_extra->typlen;\n\ttypbyval = my_extra->typbyval;\n\ttypalign = my_extra->typalign;\n\n\tp = ARR_DATA_PTR(v);\n\tbitmap = ARR_NULLBITMAP(v);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tDatum\t\titemvalue;\n\t\tchar\t   *value;\n\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\t/* if null_string is NULL, we just ignore null elements */\n\t\t\tif (null_string != NULL)\n\t\t\t{\n\t\t\t\tif (printed)\n\t\t\t\t\tappendStringInfo(&buf, \"%s%s\", fldsep, null_string);\n\t\t\t\telse\n\t\t\t\t\tappendStringInfoString(&buf, null_string);\n\t\t\t\tprinted = true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\titemvalue = fetch_att(p, typbyval, typlen);\n\n\t\t\tvalue = OutputFunctionCall(&my_extra->proc, itemvalue);\n\n\t\t\tif (printed)\n\t\t\t\tappendStringInfo(&buf, \"%s%s\", fldsep, value);\n\t\t\telse\n\t\t\t\tappendStringInfoString(&buf, value);\n\t\t\tprinted = true;\n\n\t\t\tp = att_addlength_pointer(p, typlen, p);\n\t\t\tp = (char *) att_align_nominal(p, typalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tresult = cstring_to_text_with_len(buf.data, buf.len);\n\tpfree(buf.data);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "text_to_cstring",
          "args": [
            "PG_GETARG_TEXT_PP(1)"
          ],
          "line": 4501
        },
        "resolved": true,
        "details": {
          "function_name": "text_to_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "181-197",
          "snippet": "char *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nchar *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 4501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "0"
          ],
          "line": 4500
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\nstatic StringInfo makeStringAggState(FunctionCallInfo fcinfo);\n\nDatum\narray_to_text(PG_FUNCTION_ARGS)\n{\n\tArrayType  *v = PG_GETARG_ARRAYTYPE_P(0);\n\tchar\t   *fldsep = text_to_cstring(PG_GETARG_TEXT_PP(1));\n\n\tPG_RETURN_TEXT_P(array_to_text_internal(fcinfo, v, fldsep, NULL));\n}"
  },
  {
    "function_name": "text_to_array_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "4319-4490",
    "snippet": "static Datum\ntext_to_array_internal(PG_FUNCTION_ARGS)\n{\n\ttext\t   *inputstring;\n\ttext\t   *fldsep;\n\ttext\t   *null_string;\n\tint\t\t\tinputstring_len;\n\tint\t\t\tfldsep_len;\n\tchar\t   *start_ptr;\n\ttext\t   *result_text;\n\tbool\t\tis_null;\n\tArrayBuildState *astate = NULL;\n\n\t/* when input string is NULL, then result is NULL too */\n\tif (PG_ARGISNULL(0))\n\t\tPG_RETURN_NULL();\n\n\tinputstring = PG_GETARG_TEXT_PP(0);\n\n\t/* fldsep can be NULL */\n\tif (!PG_ARGISNULL(1))\n\t\tfldsep = PG_GETARG_TEXT_PP(1);\n\telse\n\t\tfldsep = NULL;\n\n\t/* null_string can be NULL or omitted */\n\tif (PG_NARGS() > 2 && !PG_ARGISNULL(2))\n\t\tnull_string = PG_GETARG_TEXT_PP(2);\n\telse\n\t\tnull_string = NULL;\n\n\tif (fldsep != NULL)\n\t{\n\t\t/*\n\t\t * Normal case with non-null fldsep.  Use the text_position machinery\n\t\t * to search for occurrences of fldsep.\n\t\t */\n\t\tTextPositionState state;\n\t\tint\t\t\tfldnum;\n\t\tint\t\t\tstart_posn;\n\t\tint\t\t\tend_posn;\n\t\tint\t\t\tchunk_len;\n\n\t\ttext_position_setup(inputstring, fldsep, &state);\n\n\t\t/*\n\t\t * Note: we check the converted string length, not the original,\n\t\t * because they could be different if the input contained invalid\n\t\t * encoding.\n\t\t */\n\t\tinputstring_len = state.len1;\n\t\tfldsep_len = state.len2;\n\n\t\t/* return empty array for empty input string */\n\t\tif (inputstring_len < 1)\n\t\t{\n\t\t\ttext_position_cleanup(&state);\n\t\t\tPG_RETURN_ARRAYTYPE_P(construct_empty_array(TEXTOID));\n\t\t}\n\n\t\t/*\n\t\t * empty field separator: return the input string as a one-element\n\t\t * array\n\t\t */\n\t\tif (fldsep_len < 1)\n\t\t{\n\t\t\tDatum\t\telems[1];\n\t\t\tbool\t\tnulls[1];\n\t\t\tint\t\t\tdims[1];\n\t\t\tint\t\t\tlbs[1];\n\n\t\t\ttext_position_cleanup(&state);\n\t\t\t/* single element can be a NULL too */\n\t\t\tis_null = null_string ? text_isequal(inputstring, null_string) : false;\n\n\t\t\telems[0] = PointerGetDatum(inputstring);\n\t\t\tnulls[0] = is_null;\n\t\t\tdims[0] = 1;\n\t\t\tlbs[0] = 1;\n\t\t\t/* XXX: this hardcodes assumptions about the text type */\n\t\t\tPG_RETURN_ARRAYTYPE_P(construct_md_array(elems, nulls,\n\t\t\t\t\t\t\t\t\t\t\t\t\t 1, dims, lbs,\n\t\t\t\t\t\t\t\t\t\t\t\t\t TEXTOID, -1, false, 'i'));\n\t\t}\n\n\t\tstart_posn = 1;\n\t\t/* start_ptr points to the start_posn'th character of inputstring */\n\t\tstart_ptr = VARDATA_ANY(inputstring);\n\n\t\tfor (fldnum = 1;; fldnum++) /* field number is 1 based */\n\t\t{\n\t\t\tCHECK_FOR_INTERRUPTS();\n\n\t\t\tend_posn = text_position_next(start_posn, &state);\n\n\t\t\tif (end_posn == 0)\n\t\t\t{\n\t\t\t\t/* fetch last field */\n\t\t\t\tchunk_len = ((char *) inputstring + VARSIZE_ANY(inputstring)) - start_ptr;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* fetch non-last field */\n\t\t\t\tchunk_len = charlen_to_bytelen(start_ptr, end_posn - start_posn);\n\t\t\t}\n\n\t\t\t/* must build a temp text datum to pass to accumArrayResult */\n\t\t\tresult_text = cstring_to_text_with_len(start_ptr, chunk_len);\n\t\t\tis_null = null_string ? text_isequal(result_text, null_string) : false;\n\n\t\t\t/* stash away this field */\n\t\t\tastate = accumArrayResult(astate,\n\t\t\t\t\t\t\t\t\t  PointerGetDatum(result_text),\n\t\t\t\t\t\t\t\t\t  is_null,\n\t\t\t\t\t\t\t\t\t  TEXTOID,\n\t\t\t\t\t\t\t\t\t  CurrentMemoryContext);\n\n\t\t\tpfree(result_text);\n\n\t\t\tif (end_posn == 0)\n\t\t\t\tbreak;\n\n\t\t\tstart_posn = end_posn;\n\t\t\tstart_ptr += chunk_len;\n\t\t\tstart_posn += fldsep_len;\n\t\t\tstart_ptr += charlen_to_bytelen(start_ptr, fldsep_len);\n\t\t}\n\n\t\ttext_position_cleanup(&state);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When fldsep is NULL, each character in the inputstring becomes an\n\t\t * element in the result array.  The separator is effectively the\n\t\t * space between characters.\n\t\t */\n\t\tinputstring_len = VARSIZE_ANY_EXHDR(inputstring);\n\n\t\t/* return empty array for empty input string */\n\t\tif (inputstring_len < 1)\n\t\t\tPG_RETURN_ARRAYTYPE_P(construct_empty_array(TEXTOID));\n\n\t\tstart_ptr = VARDATA_ANY(inputstring);\n\n\t\twhile (inputstring_len > 0)\n\t\t{\n\t\t\tint\t\t\tchunk_len = pg_mblen(start_ptr);\n\n\t\t\tCHECK_FOR_INTERRUPTS();\n\n\t\t\t/* must build a temp text datum to pass to accumArrayResult */\n\t\t\tresult_text = cstring_to_text_with_len(start_ptr, chunk_len);\n\t\t\tis_null = null_string ? text_isequal(result_text, null_string) : false;\n\n\t\t\t/* stash away this field */\n\t\t\tastate = accumArrayResult(astate,\n\t\t\t\t\t\t\t\t\t  PointerGetDatum(result_text),\n\t\t\t\t\t\t\t\t\t  is_null,\n\t\t\t\t\t\t\t\t\t  TEXTOID,\n\t\t\t\t\t\t\t\t\t  CurrentMemoryContext);\n\n\t\t\tpfree(result_text);\n\n\t\t\tstart_ptr += chunk_len;\n\t\t\tinputstring_len -= chunk_len;\n\t\t}\n\t}\n\n\tPG_RETURN_ARRAYTYPE_P(makeArrayResult(astate,\n\t\t\t\t\t\t\t\t\t\t  CurrentMemoryContext));\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void text_position_setup(text *t1, text *t2, TextPositionState *state);",
      "static int\ttext_position_next(int start_pos, TextPositionState *state);",
      "static void text_position_cleanup(TextPositionState *state);",
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);",
      "static text *array_to_text_internal(FunctionCallInfo fcinfo, ArrayType *v,\n\t\t\t\t\t   const char *fldsep, const char *null_string);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_ARRAYTYPE_P",
          "args": [
            "makeArrayResult(astate,\n\t\t\t\t\t\t\t\t\t\t  CurrentMemoryContext)"
          ],
          "line": 4488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeArrayResult",
          "args": [
            "astate",
            "CurrentMemoryContext"
          ],
          "line": 4488
        },
        "resolved": true,
        "details": {
          "function_name": "makeArrayResult",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "5117-5132",
          "snippet": "Datum\nmakeArrayResult(ArrayBuildState *astate,\n\t\t\t\tMemoryContext rcontext)\n{\n\tint\t\t\tndims;\n\tint\t\t\tdims[1];\n\tint\t\t\tlbs[1];\n\n\t/* If no elements were presented, we want to create an empty array */\n\tndims = (astate->nelems > 0) ? 1 : 0;\n\tdims[0] = astate->nelems;\n\tlbs[0] = 1;\n\n\treturn makeMdArrayResult(astate, ndims, dims, lbs, rcontext,\n\t\t\t\t\t\t\t astate->private_cxt);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nmakeArrayResult(ArrayBuildState *astate,\n\t\t\t\tMemoryContext rcontext)\n{\n\tint\t\t\tndims;\n\tint\t\t\tdims[1];\n\tint\t\t\tlbs[1];\n\n\t/* If no elements were presented, we want to create an empty array */\n\tndims = (astate->nelems > 0) ? 1 : 0;\n\tdims[0] = astate->nelems;\n\tlbs[0] = 1;\n\n\treturn makeMdArrayResult(astate, ndims, dims, lbs, rcontext,\n\t\t\t\t\t\t\t astate->private_cxt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "result_text"
          ],
          "line": 4481
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "accumArrayResult",
          "args": [
            "astate",
            "PointerGetDatum(result_text)",
            "is_null",
            "TEXTOID",
            "CurrentMemoryContext"
          ],
          "line": 4475
        },
        "resolved": true,
        "details": {
          "function_name": "accumArrayResultAny",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "5524-5543",
          "snippet": "ArrayBuildStateAny *\naccumArrayResultAny(ArrayBuildStateAny *astate,\n\t\t\t\t\tDatum dvalue, bool disnull,\n\t\t\t\t\tOid input_type,\n\t\t\t\t\tMemoryContext rcontext)\n{\n\tif (astate == NULL)\n\t\tastate = initArrayResultAny(input_type, rcontext, true);\n\n\tif (astate->scalarstate)\n\t\t(void) accumArrayResult(astate->scalarstate,\n\t\t\t\t\t\t\t\tdvalue, disnull,\n\t\t\t\t\t\t\t\tinput_type, rcontext);\n\telse\n\t\t(void) accumArrayResultArr(astate->arraystate,\n\t\t\t\t\t\t\t\t   dvalue, disnull,\n\t\t\t\t\t\t\t\t   input_type, rcontext);\n\n\treturn astate;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nArrayBuildStateAny *\naccumArrayResultAny(ArrayBuildStateAny *astate,\n\t\t\t\t\tDatum dvalue, bool disnull,\n\t\t\t\t\tOid input_type,\n\t\t\t\t\tMemoryContext rcontext)\n{\n\tif (astate == NULL)\n\t\tastate = initArrayResultAny(input_type, rcontext, true);\n\n\tif (astate->scalarstate)\n\t\t(void) accumArrayResult(astate->scalarstate,\n\t\t\t\t\t\t\t\tdvalue, disnull,\n\t\t\t\t\t\t\t\tinput_type, rcontext);\n\telse\n\t\t(void) accumArrayResultArr(astate->arraystate,\n\t\t\t\t\t\t\t\t   dvalue, disnull,\n\t\t\t\t\t\t\t\t   input_type, rcontext);\n\n\treturn astate;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "result_text"
          ],
          "line": 4476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text_isequal",
          "args": [
            "result_text",
            "null_string"
          ],
          "line": 4472
        },
        "resolved": true,
        "details": {
          "function_name": "text_isequal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "4281-4287",
          "snippet": "static bool\ntext_isequal(text *txt1, text *txt2)\n{\n\treturn DatumGetBool(DirectFunctionCall2(texteq,\n\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(txt1),\n\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(txt2)));\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool\ntext_isequal(text *txt1, text *txt2)\n{\n\treturn DatumGetBool(DirectFunctionCall2(texteq,\n\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(txt1),\n\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(txt2)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cstring_to_text_with_len",
          "args": [
            "start_ptr",
            "chunk_len"
          ],
          "line": 4471
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "160-169",
          "snippet": "text *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHECK_FOR_INTERRUPTS",
          "args": [],
          "line": 4468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_mblen",
          "args": [
            "start_ptr"
          ],
          "line": 4466
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mblen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "759-763",
          "snippet": "int\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nint\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "inputstring"
          ],
          "line": 4462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_ARRAYTYPE_P",
          "args": [
            "construct_empty_array(TEXTOID)"
          ],
          "line": 4460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "construct_empty_array",
          "args": [
            "TEXTOID"
          ],
          "line": 4460
        },
        "resolved": true,
        "details": {
          "function_name": "construct_empty_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3409-3420",
          "snippet": "ArrayType *\nconstruct_empty_array(Oid elmtype)\n{\n\tArrayType  *result;\n\n\tresult = (ArrayType *) palloc0(sizeof(ArrayType));\n\tSET_VARSIZE(result, sizeof(ArrayType));\n\tresult->ndim = 0;\n\tresult->dataoffset = 0;\n\tresult->elemtype = elmtype;\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);\n\nArrayType *\nconstruct_empty_array(Oid elmtype)\n{\n\tArrayType  *result;\n\n\tresult = (ArrayType *) palloc0(sizeof(ArrayType));\n\tSET_VARSIZE(result, sizeof(ArrayType));\n\tresult->ndim = 0;\n\tresult->dataoffset = 0;\n\tresult->elemtype = elmtype;\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "inputstring"
          ],
          "line": 4456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text_position_cleanup",
          "args": [
            "&state"
          ],
          "line": 4447
        },
        "resolved": true,
        "details": {
          "function_name": "text_position_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "1363-1371",
          "snippet": "static void\ntext_position_cleanup(TextPositionState *state)\n{\n\tif (state->use_wchar)\n\t{\n\t\tpfree(state->wstr1);\n\t\tpfree(state->wstr2);\n\t}\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void text_position_setup(text *t1, text *t2, TextPositionState *state);",
            "static int\ttext_position_next(int start_pos, TextPositionState *state);",
            "static void text_position_cleanup(TextPositionState *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void text_position_setup(text *t1, text *t2, TextPositionState *state);\nstatic int\ttext_position_next(int start_pos, TextPositionState *state);\nstatic void text_position_cleanup(TextPositionState *state);\n\nstatic void\ntext_position_cleanup(TextPositionState *state)\n{\n\tif (state->use_wchar)\n\t{\n\t\tpfree(state->wstr1);\n\t\tpfree(state->wstr2);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "charlen_to_bytelen",
          "args": [
            "start_ptr",
            "fldsep_len"
          ],
          "line": 4444
        },
        "resolved": true,
        "details": {
          "function_name": "charlen_to_bytelen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "734-751",
          "snippet": "static int\ncharlen_to_bytelen(const char *p, int n)\n{\n\tif (pg_database_encoding_max_length() == 1)\n\t{\n\t\t/* Optimization for single-byte encodings */\n\t\treturn n;\n\t}\n\telse\n\t{\n\t\tconst char *s;\n\n\t\tfor (s = p; n > 0; n--)\n\t\t\ts += pg_mblen(s);\n\n\t\treturn s - p;\n\t}\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ncharlen_to_bytelen(const char *p, int n)\n{\n\tif (pg_database_encoding_max_length() == 1)\n\t{\n\t\t/* Optimization for single-byte encodings */\n\t\treturn n;\n\t}\n\telse\n\t{\n\t\tconst char *s;\n\n\t\tfor (s = p; n > 0; n--)\n\t\t\ts += pg_mblen(s);\n\n\t\treturn s - p;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "result_text"
          ],
          "line": 4431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY",
          "args": [
            "inputstring"
          ],
          "line": 4417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text_position_next",
          "args": [
            "start_posn",
            "&state"
          ],
          "line": 4412
        },
        "resolved": true,
        "details": {
          "function_name": "text_position_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "1229-1361",
          "snippet": "static int\ntext_position_next(int start_pos, TextPositionState *state)\n{\n\tint\t\t\thaystack_len = state->len1;\n\tint\t\t\tneedle_len = state->len2;\n\tint\t\t\tskiptablemask = state->skiptablemask;\n\n\tAssert(start_pos > 0);\t\t/* else caller error */\n\n\tif (needle_len <= 0)\n\t\treturn start_pos;\t\t/* result for empty pattern */\n\n\tstart_pos--;\t\t\t\t/* adjust for zero based arrays */\n\n\t/* Done if the needle can't possibly fit */\n\tif (haystack_len < start_pos + needle_len)\n\t\treturn 0;\n\n\tif (!state->use_wchar)\n\t{\n\t\t/* simple case - single byte encoding */\n\t\tconst char *haystack = state->str1;\n\t\tconst char *needle = state->str2;\n\t\tconst char *haystack_end = &haystack[haystack_len];\n\t\tconst char *hptr;\n\n\t\tif (needle_len == 1)\n\t\t{\n\t\t\t/* No point in using B-M-H for a one-character needle */\n\t\t\tchar\t\tnchar = *needle;\n\n\t\t\thptr = &haystack[start_pos];\n\t\t\twhile (hptr < haystack_end)\n\t\t\t{\n\t\t\t\tif (*hptr == nchar)\n\t\t\t\t\treturn hptr - haystack + 1;\n\t\t\t\thptr++;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconst char *needle_last = &needle[needle_len - 1];\n\n\t\t\t/* Start at startpos plus the length of the needle */\n\t\t\thptr = &haystack[start_pos + needle_len - 1];\n\t\t\twhile (hptr < haystack_end)\n\t\t\t{\n\t\t\t\t/* Match the needle scanning *backward* */\n\t\t\t\tconst char *nptr;\n\t\t\t\tconst char *p;\n\n\t\t\t\tnptr = needle_last;\n\t\t\t\tp = hptr;\n\t\t\t\twhile (*nptr == *p)\n\t\t\t\t{\n\t\t\t\t\t/* Matched it all?\tIf so, return 1-based position */\n\t\t\t\t\tif (nptr == needle)\n\t\t\t\t\t\treturn p - haystack + 1;\n\t\t\t\t\tnptr--, p--;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * No match, so use the haystack char at hptr to decide how\n\t\t\t\t * far to advance.  If the needle had any occurrence of that\n\t\t\t\t * character (or more precisely, one sharing the same\n\t\t\t\t * skiptable entry) before its last character, then we advance\n\t\t\t\t * far enough to align the last such needle character with\n\t\t\t\t * that haystack position.  Otherwise we can advance by the\n\t\t\t\t * whole needle length.\n\t\t\t\t */\n\t\t\t\thptr += state->skiptable[(unsigned char) *hptr & skiptablemask];\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* The multibyte char version. This works exactly the same way. */\n\t\tconst pg_wchar *haystack = state->wstr1;\n\t\tconst pg_wchar *needle = state->wstr2;\n\t\tconst pg_wchar *haystack_end = &haystack[haystack_len];\n\t\tconst pg_wchar *hptr;\n\n\t\tif (needle_len == 1)\n\t\t{\n\t\t\t/* No point in using B-M-H for a one-character needle */\n\t\t\tpg_wchar\tnchar = *needle;\n\n\t\t\thptr = &haystack[start_pos];\n\t\t\twhile (hptr < haystack_end)\n\t\t\t{\n\t\t\t\tif (*hptr == nchar)\n\t\t\t\t\treturn hptr - haystack + 1;\n\t\t\t\thptr++;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconst pg_wchar *needle_last = &needle[needle_len - 1];\n\n\t\t\t/* Start at startpos plus the length of the needle */\n\t\t\thptr = &haystack[start_pos + needle_len - 1];\n\t\t\twhile (hptr < haystack_end)\n\t\t\t{\n\t\t\t\t/* Match the needle scanning *backward* */\n\t\t\t\tconst pg_wchar *nptr;\n\t\t\t\tconst pg_wchar *p;\n\n\t\t\t\tnptr = needle_last;\n\t\t\t\tp = hptr;\n\t\t\t\twhile (*nptr == *p)\n\t\t\t\t{\n\t\t\t\t\t/* Matched it all?\tIf so, return 1-based position */\n\t\t\t\t\tif (nptr == needle)\n\t\t\t\t\t\treturn p - haystack + 1;\n\t\t\t\t\tnptr--, p--;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * No match, so use the haystack char at hptr to decide how\n\t\t\t\t * far to advance.  If the needle had any occurrence of that\n\t\t\t\t * character (or more precisely, one sharing the same\n\t\t\t\t * skiptable entry) before its last character, then we advance\n\t\t\t\t * far enough to align the last such needle character with\n\t\t\t\t * that haystack position.  Otherwise we can advance by the\n\t\t\t\t * whole needle length.\n\t\t\t\t */\n\t\t\t\thptr += state->skiptable[*hptr & skiptablemask];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\t\t\t\t\t/* not found */\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void text_position_setup(text *t1, text *t2, TextPositionState *state);",
            "static int\ttext_position_next(int start_pos, TextPositionState *state);",
            "static void text_position_cleanup(TextPositionState *state);",
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void text_position_setup(text *t1, text *t2, TextPositionState *state);\nstatic int\ttext_position_next(int start_pos, TextPositionState *state);\nstatic void text_position_cleanup(TextPositionState *state);\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nstatic int\ntext_position_next(int start_pos, TextPositionState *state)\n{\n\tint\t\t\thaystack_len = state->len1;\n\tint\t\t\tneedle_len = state->len2;\n\tint\t\t\tskiptablemask = state->skiptablemask;\n\n\tAssert(start_pos > 0);\t\t/* else caller error */\n\n\tif (needle_len <= 0)\n\t\treturn start_pos;\t\t/* result for empty pattern */\n\n\tstart_pos--;\t\t\t\t/* adjust for zero based arrays */\n\n\t/* Done if the needle can't possibly fit */\n\tif (haystack_len < start_pos + needle_len)\n\t\treturn 0;\n\n\tif (!state->use_wchar)\n\t{\n\t\t/* simple case - single byte encoding */\n\t\tconst char *haystack = state->str1;\n\t\tconst char *needle = state->str2;\n\t\tconst char *haystack_end = &haystack[haystack_len];\n\t\tconst char *hptr;\n\n\t\tif (needle_len == 1)\n\t\t{\n\t\t\t/* No point in using B-M-H for a one-character needle */\n\t\t\tchar\t\tnchar = *needle;\n\n\t\t\thptr = &haystack[start_pos];\n\t\t\twhile (hptr < haystack_end)\n\t\t\t{\n\t\t\t\tif (*hptr == nchar)\n\t\t\t\t\treturn hptr - haystack + 1;\n\t\t\t\thptr++;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconst char *needle_last = &needle[needle_len - 1];\n\n\t\t\t/* Start at startpos plus the length of the needle */\n\t\t\thptr = &haystack[start_pos + needle_len - 1];\n\t\t\twhile (hptr < haystack_end)\n\t\t\t{\n\t\t\t\t/* Match the needle scanning *backward* */\n\t\t\t\tconst char *nptr;\n\t\t\t\tconst char *p;\n\n\t\t\t\tnptr = needle_last;\n\t\t\t\tp = hptr;\n\t\t\t\twhile (*nptr == *p)\n\t\t\t\t{\n\t\t\t\t\t/* Matched it all?\tIf so, return 1-based position */\n\t\t\t\t\tif (nptr == needle)\n\t\t\t\t\t\treturn p - haystack + 1;\n\t\t\t\t\tnptr--, p--;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * No match, so use the haystack char at hptr to decide how\n\t\t\t\t * far to advance.  If the needle had any occurrence of that\n\t\t\t\t * character (or more precisely, one sharing the same\n\t\t\t\t * skiptable entry) before its last character, then we advance\n\t\t\t\t * far enough to align the last such needle character with\n\t\t\t\t * that haystack position.  Otherwise we can advance by the\n\t\t\t\t * whole needle length.\n\t\t\t\t */\n\t\t\t\thptr += state->skiptable[(unsigned char) *hptr & skiptablemask];\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* The multibyte char version. This works exactly the same way. */\n\t\tconst pg_wchar *haystack = state->wstr1;\n\t\tconst pg_wchar *needle = state->wstr2;\n\t\tconst pg_wchar *haystack_end = &haystack[haystack_len];\n\t\tconst pg_wchar *hptr;\n\n\t\tif (needle_len == 1)\n\t\t{\n\t\t\t/* No point in using B-M-H for a one-character needle */\n\t\t\tpg_wchar\tnchar = *needle;\n\n\t\t\thptr = &haystack[start_pos];\n\t\t\twhile (hptr < haystack_end)\n\t\t\t{\n\t\t\t\tif (*hptr == nchar)\n\t\t\t\t\treturn hptr - haystack + 1;\n\t\t\t\thptr++;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconst pg_wchar *needle_last = &needle[needle_len - 1];\n\n\t\t\t/* Start at startpos plus the length of the needle */\n\t\t\thptr = &haystack[start_pos + needle_len - 1];\n\t\t\twhile (hptr < haystack_end)\n\t\t\t{\n\t\t\t\t/* Match the needle scanning *backward* */\n\t\t\t\tconst pg_wchar *nptr;\n\t\t\t\tconst pg_wchar *p;\n\n\t\t\t\tnptr = needle_last;\n\t\t\t\tp = hptr;\n\t\t\t\twhile (*nptr == *p)\n\t\t\t\t{\n\t\t\t\t\t/* Matched it all?\tIf so, return 1-based position */\n\t\t\t\t\tif (nptr == needle)\n\t\t\t\t\t\treturn p - haystack + 1;\n\t\t\t\t\tnptr--, p--;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * No match, so use the haystack char at hptr to decide how\n\t\t\t\t * far to advance.  If the needle had any occurrence of that\n\t\t\t\t * character (or more precisely, one sharing the same\n\t\t\t\t * skiptable entry) before its last character, then we advance\n\t\t\t\t * far enough to align the last such needle character with\n\t\t\t\t * that haystack position.  Otherwise we can advance by the\n\t\t\t\t * whole needle length.\n\t\t\t\t */\n\t\t\t\thptr += state->skiptable[*hptr & skiptablemask];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\t\t\t\t\t/* not found */\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHECK_FOR_INTERRUPTS",
          "args": [],
          "line": 4410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "inputstring"
          ],
          "line": 4406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_ARRAYTYPE_P",
          "args": [
            "construct_md_array(elems, nulls,\n\t\t\t\t\t\t\t\t\t\t\t\t\t 1, dims, lbs,\n\t\t\t\t\t\t\t\t\t\t\t\t\t TEXTOID, -1, false, 'i')"
          ],
          "line": 4399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "construct_md_array",
          "args": [
            "elems",
            "nulls",
            "1",
            "dims",
            "lbs",
            "TEXTOID",
            "-1",
            "false",
            "'i'"
          ],
          "line": 4399
        },
        "resolved": true,
        "details": {
          "function_name": "construct_md_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3325-3404",
          "snippet": "ArrayType *\nconstruct_md_array(Datum *elems,\n\t\t\t\t   bool *nulls,\n\t\t\t\t   int ndims,\n\t\t\t\t   int *dims,\n\t\t\t\t   int *lbs,\n\t\t\t\t   Oid elmtype, int elmlen, bool elmbyval, char elmalign)\n{\n\tArrayType  *result;\n\tbool\t\thasnulls;\n\tint32\t\tnbytes;\n\tint32\t\tdataoffset;\n\tint\t\t\ti;\n\tint\t\t\tnelems;\n\n\tif (ndims < 0)\t\t\t\t/* we do allow zero-dimension arrays */\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid number of dimensions: %d\", ndims)));\n\tif (ndims > MAXDIM)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"number of array dimensions (%d) exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\tndims, MAXDIM)));\n\n\tnelems = ArrayGetNItems(ndims, dims);\n\n\t/* if ndims <= 0 or any dims[i] == 0, return empty array */\n\tif (nelems <= 0)\n\t\treturn construct_empty_array(elmtype);\n\n\t/* compute required space */\n\tnbytes = 0;\n\thasnulls = false;\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\tif (nulls && nulls[i])\n\t\t{\n\t\t\thasnulls = true;\n\t\t\tcontinue;\n\t\t}\n\t\t/* make sure data is not toasted */\n\t\tif (elmlen == -1)\n\t\t\telems[i] = PointerGetDatum(PG_DETOAST_DATUM(elems[i]));\n\t\tnbytes = att_addlength_datum(nbytes, elmlen, elems[i]);\n\t\tnbytes = att_align_nominal(nbytes, elmalign);\n\t\t/* check for overflow of total request */\n\t\tif (!AllocSizeIsValid(nbytes))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxAllocSize)));\n\t}\n\n\t/* Allocate and initialize result array */\n\tif (hasnulls)\n\t{\n\t\tdataoffset = ARR_OVERHEAD_WITHNULLS(ndims, nelems);\n\t\tnbytes += dataoffset;\n\t}\n\telse\n\t{\n\t\tdataoffset = 0;\t\t\t/* marker for no null bitmap */\n\t\tnbytes += ARR_OVERHEAD_NONULLS(ndims);\n\t}\n\tresult = (ArrayType *) palloc0(nbytes);\n\tSET_VARSIZE(result, nbytes);\n\tresult->ndim = ndims;\n\tresult->dataoffset = dataoffset;\n\tresult->elemtype = elmtype;\n\tmemcpy(ARR_DIMS(result), dims, ndims * sizeof(int));\n\tmemcpy(ARR_LBOUND(result), lbs, ndims * sizeof(int));\n\n\tCopyArrayEls(result,\n\t\t\t\t elems, nulls, nelems,\n\t\t\t\t elmlen, elmbyval, elmalign,\n\t\t\t\t false);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ReadArrayStr(char *arrayStr, const char *origStr,\n\t\t\t int nitems, int ndim, int *dim,\n\t\t\t FmgrInfo *inputproc, Oid typioparam, int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen, bool typbyval, char typalign,\n\t\t\t Datum *values, bool *nulls,\n\t\t\t bool *hasnulls, int32 *nbytes);",
            "static void ReadArrayBinary(StringInfo buf, int nitems,\n\t\t\t\tFmgrInfo *receiveproc, Oid typioparam, int32 typmod,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tDatum *values, bool *nulls,\n\t\t\t\tbool *hasnulls, int32 *nbytes);",
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);",
            "static ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void ReadArrayStr(char *arrayStr, const char *origStr,\n\t\t\t int nitems, int ndim, int *dim,\n\t\t\t FmgrInfo *inputproc, Oid typioparam, int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen, bool typbyval, char typalign,\n\t\t\t Datum *values, bool *nulls,\n\t\t\t bool *hasnulls, int32 *nbytes);\nstatic void ReadArrayBinary(StringInfo buf, int nitems,\n\t\t\t\tFmgrInfo *receiveproc, Oid typioparam, int32 typmod,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tDatum *values, bool *nulls,\n\t\t\t\tbool *hasnulls, int32 *nbytes);\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\nstatic ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);\n\nArrayType *\nconstruct_md_array(Datum *elems,\n\t\t\t\t   bool *nulls,\n\t\t\t\t   int ndims,\n\t\t\t\t   int *dims,\n\t\t\t\t   int *lbs,\n\t\t\t\t   Oid elmtype, int elmlen, bool elmbyval, char elmalign)\n{\n\tArrayType  *result;\n\tbool\t\thasnulls;\n\tint32\t\tnbytes;\n\tint32\t\tdataoffset;\n\tint\t\t\ti;\n\tint\t\t\tnelems;\n\n\tif (ndims < 0)\t\t\t\t/* we do allow zero-dimension arrays */\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid number of dimensions: %d\", ndims)));\n\tif (ndims > MAXDIM)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"number of array dimensions (%d) exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\tndims, MAXDIM)));\n\n\tnelems = ArrayGetNItems(ndims, dims);\n\n\t/* if ndims <= 0 or any dims[i] == 0, return empty array */\n\tif (nelems <= 0)\n\t\treturn construct_empty_array(elmtype);\n\n\t/* compute required space */\n\tnbytes = 0;\n\thasnulls = false;\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\tif (nulls && nulls[i])\n\t\t{\n\t\t\thasnulls = true;\n\t\t\tcontinue;\n\t\t}\n\t\t/* make sure data is not toasted */\n\t\tif (elmlen == -1)\n\t\t\telems[i] = PointerGetDatum(PG_DETOAST_DATUM(elems[i]));\n\t\tnbytes = att_addlength_datum(nbytes, elmlen, elems[i]);\n\t\tnbytes = att_align_nominal(nbytes, elmalign);\n\t\t/* check for overflow of total request */\n\t\tif (!AllocSizeIsValid(nbytes))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxAllocSize)));\n\t}\n\n\t/* Allocate and initialize result array */\n\tif (hasnulls)\n\t{\n\t\tdataoffset = ARR_OVERHEAD_WITHNULLS(ndims, nelems);\n\t\tnbytes += dataoffset;\n\t}\n\telse\n\t{\n\t\tdataoffset = 0;\t\t\t/* marker for no null bitmap */\n\t\tnbytes += ARR_OVERHEAD_NONULLS(ndims);\n\t}\n\tresult = (ArrayType *) palloc0(nbytes);\n\tSET_VARSIZE(result, nbytes);\n\tresult->ndim = ndims;\n\tresult->dataoffset = dataoffset;\n\tresult->elemtype = elmtype;\n\tmemcpy(ARR_DIMS(result), dims, ndims * sizeof(int));\n\tmemcpy(ARR_LBOUND(result), lbs, ndims * sizeof(int));\n\n\tCopyArrayEls(result,\n\t\t\t\t elems, nulls, nelems,\n\t\t\t\t elmlen, elmbyval, elmalign,\n\t\t\t\t false);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "inputstring"
          ],
          "line": 4394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_ARRAYTYPE_P",
          "args": [
            "construct_empty_array(TEXTOID)"
          ],
          "line": 4376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text_position_setup",
          "args": [
            "inputstring",
            "fldsep",
            "&state"
          ],
          "line": 4362
        },
        "resolved": true,
        "details": {
          "function_name": "text_position_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "1117-1227",
          "snippet": "static void\ntext_position_setup(text *t1, text *t2, TextPositionState *state)\n{\n\tint\t\t\tlen1 = VARSIZE_ANY_EXHDR(t1);\n\tint\t\t\tlen2 = VARSIZE_ANY_EXHDR(t2);\n\n\tif (pg_database_encoding_max_length() == 1)\n\t{\n\t\t/* simple case - single byte encoding */\n\t\tstate->use_wchar = false;\n\t\tstate->str1 = VARDATA_ANY(t1);\n\t\tstate->str2 = VARDATA_ANY(t2);\n\t\tstate->len1 = len1;\n\t\tstate->len2 = len2;\n\t}\n\telse\n\t{\n\t\t/* not as simple - multibyte encoding */\n\t\tpg_wchar   *p1,\n\t\t\t\t   *p2;\n\n\t\tp1 = (pg_wchar *) palloc((len1 + 1) * sizeof(pg_wchar));\n\t\tlen1 = pg_mb2wchar_with_len(VARDATA_ANY(t1), p1, len1);\n\t\tp2 = (pg_wchar *) palloc((len2 + 1) * sizeof(pg_wchar));\n\t\tlen2 = pg_mb2wchar_with_len(VARDATA_ANY(t2), p2, len2);\n\n\t\tstate->use_wchar = true;\n\t\tstate->wstr1 = p1;\n\t\tstate->wstr2 = p2;\n\t\tstate->len1 = len1;\n\t\tstate->len2 = len2;\n\t}\n\n\t/*\n\t * Prepare the skip table for Boyer-Moore-Horspool searching.  In these\n\t * notes we use the terminology that the \"haystack\" is the string to be\n\t * searched (t1) and the \"needle\" is the pattern being sought (t2).\n\t *\n\t * If the needle is empty or bigger than the haystack then there is no\n\t * point in wasting cycles initializing the table.  We also choose not to\n\t * use B-M-H for needles of length 1, since the skip table can't possibly\n\t * save anything in that case.\n\t */\n\tif (len1 >= len2 && len2 > 1)\n\t{\n\t\tint\t\t\tsearchlength = len1 - len2;\n\t\tint\t\t\tskiptablemask;\n\t\tint\t\t\tlast;\n\t\tint\t\t\ti;\n\n\t\t/*\n\t\t * First we must determine how much of the skip table to use.  The\n\t\t * declaration of TextPositionState allows up to 256 elements, but for\n\t\t * short search problems we don't really want to have to initialize so\n\t\t * many elements --- it would take too long in comparison to the\n\t\t * actual search time.  So we choose a useful skip table size based on\n\t\t * the haystack length minus the needle length.  The closer the needle\n\t\t * length is to the haystack length the less useful skipping becomes.\n\t\t *\n\t\t * Note: since we use bit-masking to select table elements, the skip\n\t\t * table size MUST be a power of 2, and so the mask must be 2^N-1.\n\t\t */\n\t\tif (searchlength < 16)\n\t\t\tskiptablemask = 3;\n\t\telse if (searchlength < 64)\n\t\t\tskiptablemask = 7;\n\t\telse if (searchlength < 128)\n\t\t\tskiptablemask = 15;\n\t\telse if (searchlength < 512)\n\t\t\tskiptablemask = 31;\n\t\telse if (searchlength < 2048)\n\t\t\tskiptablemask = 63;\n\t\telse if (searchlength < 4096)\n\t\t\tskiptablemask = 127;\n\t\telse\n\t\t\tskiptablemask = 255;\n\t\tstate->skiptablemask = skiptablemask;\n\n\t\t/*\n\t\t * Initialize the skip table.  We set all elements to the needle\n\t\t * length, since this is the correct skip distance for any character\n\t\t * not found in the needle.\n\t\t */\n\t\tfor (i = 0; i <= skiptablemask; i++)\n\t\t\tstate->skiptable[i] = len2;\n\n\t\t/*\n\t\t * Now examine the needle.  For each character except the last one,\n\t\t * set the corresponding table element to the appropriate skip\n\t\t * distance.  Note that when two characters share the same skip table\n\t\t * entry, the one later in the needle must determine the skip\n\t\t * distance.\n\t\t */\n\t\tlast = len2 - 1;\n\n\t\tif (!state->use_wchar)\n\t\t{\n\t\t\tconst char *str2 = state->str2;\n\n\t\t\tfor (i = 0; i < last; i++)\n\t\t\t\tstate->skiptable[(unsigned char) str2[i] & skiptablemask] = last - i;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconst pg_wchar *wstr2 = state->wstr2;\n\n\t\t\tfor (i = 0; i < last; i++)\n\t\t\t\tstate->skiptable[wstr2[i] & skiptablemask] = last - i;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static text *text_catenate(text *t1, text *t2);",
            "static int\ttext_position(text *t1, text *t2);",
            "static void text_position_setup(text *t1, text *t2, TextPositionState *state);",
            "static int\ttext_position_next(int start_pos, TextPositionState *state);",
            "static void text_position_cleanup(TextPositionState *state);",
            "static bytea *bytea_catenate(bytea *t1, bytea *t2);",
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic text *text_catenate(text *t1, text *t2);\nstatic int\ttext_position(text *t1, text *t2);\nstatic void text_position_setup(text *t1, text *t2, TextPositionState *state);\nstatic int\ttext_position_next(int start_pos, TextPositionState *state);\nstatic void text_position_cleanup(TextPositionState *state);\nstatic bytea *bytea_catenate(bytea *t1, bytea *t2);\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nstatic void\ntext_position_setup(text *t1, text *t2, TextPositionState *state)\n{\n\tint\t\t\tlen1 = VARSIZE_ANY_EXHDR(t1);\n\tint\t\t\tlen2 = VARSIZE_ANY_EXHDR(t2);\n\n\tif (pg_database_encoding_max_length() == 1)\n\t{\n\t\t/* simple case - single byte encoding */\n\t\tstate->use_wchar = false;\n\t\tstate->str1 = VARDATA_ANY(t1);\n\t\tstate->str2 = VARDATA_ANY(t2);\n\t\tstate->len1 = len1;\n\t\tstate->len2 = len2;\n\t}\n\telse\n\t{\n\t\t/* not as simple - multibyte encoding */\n\t\tpg_wchar   *p1,\n\t\t\t\t   *p2;\n\n\t\tp1 = (pg_wchar *) palloc((len1 + 1) * sizeof(pg_wchar));\n\t\tlen1 = pg_mb2wchar_with_len(VARDATA_ANY(t1), p1, len1);\n\t\tp2 = (pg_wchar *) palloc((len2 + 1) * sizeof(pg_wchar));\n\t\tlen2 = pg_mb2wchar_with_len(VARDATA_ANY(t2), p2, len2);\n\n\t\tstate->use_wchar = true;\n\t\tstate->wstr1 = p1;\n\t\tstate->wstr2 = p2;\n\t\tstate->len1 = len1;\n\t\tstate->len2 = len2;\n\t}\n\n\t/*\n\t * Prepare the skip table for Boyer-Moore-Horspool searching.  In these\n\t * notes we use the terminology that the \"haystack\" is the string to be\n\t * searched (t1) and the \"needle\" is the pattern being sought (t2).\n\t *\n\t * If the needle is empty or bigger than the haystack then there is no\n\t * point in wasting cycles initializing the table.  We also choose not to\n\t * use B-M-H for needles of length 1, since the skip table can't possibly\n\t * save anything in that case.\n\t */\n\tif (len1 >= len2 && len2 > 1)\n\t{\n\t\tint\t\t\tsearchlength = len1 - len2;\n\t\tint\t\t\tskiptablemask;\n\t\tint\t\t\tlast;\n\t\tint\t\t\ti;\n\n\t\t/*\n\t\t * First we must determine how much of the skip table to use.  The\n\t\t * declaration of TextPositionState allows up to 256 elements, but for\n\t\t * short search problems we don't really want to have to initialize so\n\t\t * many elements --- it would take too long in comparison to the\n\t\t * actual search time.  So we choose a useful skip table size based on\n\t\t * the haystack length minus the needle length.  The closer the needle\n\t\t * length is to the haystack length the less useful skipping becomes.\n\t\t *\n\t\t * Note: since we use bit-masking to select table elements, the skip\n\t\t * table size MUST be a power of 2, and so the mask must be 2^N-1.\n\t\t */\n\t\tif (searchlength < 16)\n\t\t\tskiptablemask = 3;\n\t\telse if (searchlength < 64)\n\t\t\tskiptablemask = 7;\n\t\telse if (searchlength < 128)\n\t\t\tskiptablemask = 15;\n\t\telse if (searchlength < 512)\n\t\t\tskiptablemask = 31;\n\t\telse if (searchlength < 2048)\n\t\t\tskiptablemask = 63;\n\t\telse if (searchlength < 4096)\n\t\t\tskiptablemask = 127;\n\t\telse\n\t\t\tskiptablemask = 255;\n\t\tstate->skiptablemask = skiptablemask;\n\n\t\t/*\n\t\t * Initialize the skip table.  We set all elements to the needle\n\t\t * length, since this is the correct skip distance for any character\n\t\t * not found in the needle.\n\t\t */\n\t\tfor (i = 0; i <= skiptablemask; i++)\n\t\t\tstate->skiptable[i] = len2;\n\n\t\t/*\n\t\t * Now examine the needle.  For each character except the last one,\n\t\t * set the corresponding table element to the appropriate skip\n\t\t * distance.  Note that when two characters share the same skip table\n\t\t * entry, the one later in the needle must determine the skip\n\t\t * distance.\n\t\t */\n\t\tlast = len2 - 1;\n\n\t\tif (!state->use_wchar)\n\t\t{\n\t\t\tconst char *str2 = state->str2;\n\n\t\t\tfor (i = 0; i < last; i++)\n\t\t\t\tstate->skiptable[(unsigned char) str2[i] & skiptablemask] = last - i;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconst pg_wchar *wstr2 = state->wstr2;\n\n\t\t\tfor (i = 0; i < last; i++)\n\t\t\t\tstate->skiptable[wstr2[i] & skiptablemask] = last - i;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "2"
          ],
          "line": 4346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "2"
          ],
          "line": 4345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_NARGS",
          "args": [],
          "line": 4345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 4340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "1"
          ],
          "line": 4339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 4336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 4334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "0"
          ],
          "line": 4333
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void text_position_setup(text *t1, text *t2, TextPositionState *state);\nstatic int\ttext_position_next(int start_pos, TextPositionState *state);\nstatic void text_position_cleanup(TextPositionState *state);\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\nstatic text *array_to_text_internal(FunctionCallInfo fcinfo, ArrayType *v,\n\t\t\t\t\t   const char *fldsep, const char *null_string);\n\nstatic Datum\ntext_to_array_internal(PG_FUNCTION_ARGS)\n{\n\ttext\t   *inputstring;\n\ttext\t   *fldsep;\n\ttext\t   *null_string;\n\tint\t\t\tinputstring_len;\n\tint\t\t\tfldsep_len;\n\tchar\t   *start_ptr;\n\ttext\t   *result_text;\n\tbool\t\tis_null;\n\tArrayBuildState *astate = NULL;\n\n\t/* when input string is NULL, then result is NULL too */\n\tif (PG_ARGISNULL(0))\n\t\tPG_RETURN_NULL();\n\n\tinputstring = PG_GETARG_TEXT_PP(0);\n\n\t/* fldsep can be NULL */\n\tif (!PG_ARGISNULL(1))\n\t\tfldsep = PG_GETARG_TEXT_PP(1);\n\telse\n\t\tfldsep = NULL;\n\n\t/* null_string can be NULL or omitted */\n\tif (PG_NARGS() > 2 && !PG_ARGISNULL(2))\n\t\tnull_string = PG_GETARG_TEXT_PP(2);\n\telse\n\t\tnull_string = NULL;\n\n\tif (fldsep != NULL)\n\t{\n\t\t/*\n\t\t * Normal case with non-null fldsep.  Use the text_position machinery\n\t\t * to search for occurrences of fldsep.\n\t\t */\n\t\tTextPositionState state;\n\t\tint\t\t\tfldnum;\n\t\tint\t\t\tstart_posn;\n\t\tint\t\t\tend_posn;\n\t\tint\t\t\tchunk_len;\n\n\t\ttext_position_setup(inputstring, fldsep, &state);\n\n\t\t/*\n\t\t * Note: we check the converted string length, not the original,\n\t\t * because they could be different if the input contained invalid\n\t\t * encoding.\n\t\t */\n\t\tinputstring_len = state.len1;\n\t\tfldsep_len = state.len2;\n\n\t\t/* return empty array for empty input string */\n\t\tif (inputstring_len < 1)\n\t\t{\n\t\t\ttext_position_cleanup(&state);\n\t\t\tPG_RETURN_ARRAYTYPE_P(construct_empty_array(TEXTOID));\n\t\t}\n\n\t\t/*\n\t\t * empty field separator: return the input string as a one-element\n\t\t * array\n\t\t */\n\t\tif (fldsep_len < 1)\n\t\t{\n\t\t\tDatum\t\telems[1];\n\t\t\tbool\t\tnulls[1];\n\t\t\tint\t\t\tdims[1];\n\t\t\tint\t\t\tlbs[1];\n\n\t\t\ttext_position_cleanup(&state);\n\t\t\t/* single element can be a NULL too */\n\t\t\tis_null = null_string ? text_isequal(inputstring, null_string) : false;\n\n\t\t\telems[0] = PointerGetDatum(inputstring);\n\t\t\tnulls[0] = is_null;\n\t\t\tdims[0] = 1;\n\t\t\tlbs[0] = 1;\n\t\t\t/* XXX: this hardcodes assumptions about the text type */\n\t\t\tPG_RETURN_ARRAYTYPE_P(construct_md_array(elems, nulls,\n\t\t\t\t\t\t\t\t\t\t\t\t\t 1, dims, lbs,\n\t\t\t\t\t\t\t\t\t\t\t\t\t TEXTOID, -1, false, 'i'));\n\t\t}\n\n\t\tstart_posn = 1;\n\t\t/* start_ptr points to the start_posn'th character of inputstring */\n\t\tstart_ptr = VARDATA_ANY(inputstring);\n\n\t\tfor (fldnum = 1;; fldnum++) /* field number is 1 based */\n\t\t{\n\t\t\tCHECK_FOR_INTERRUPTS();\n\n\t\t\tend_posn = text_position_next(start_posn, &state);\n\n\t\t\tif (end_posn == 0)\n\t\t\t{\n\t\t\t\t/* fetch last field */\n\t\t\t\tchunk_len = ((char *) inputstring + VARSIZE_ANY(inputstring)) - start_ptr;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* fetch non-last field */\n\t\t\t\tchunk_len = charlen_to_bytelen(start_ptr, end_posn - start_posn);\n\t\t\t}\n\n\t\t\t/* must build a temp text datum to pass to accumArrayResult */\n\t\t\tresult_text = cstring_to_text_with_len(start_ptr, chunk_len);\n\t\t\tis_null = null_string ? text_isequal(result_text, null_string) : false;\n\n\t\t\t/* stash away this field */\n\t\t\tastate = accumArrayResult(astate,\n\t\t\t\t\t\t\t\t\t  PointerGetDatum(result_text),\n\t\t\t\t\t\t\t\t\t  is_null,\n\t\t\t\t\t\t\t\t\t  TEXTOID,\n\t\t\t\t\t\t\t\t\t  CurrentMemoryContext);\n\n\t\t\tpfree(result_text);\n\n\t\t\tif (end_posn == 0)\n\t\t\t\tbreak;\n\n\t\t\tstart_posn = end_posn;\n\t\t\tstart_ptr += chunk_len;\n\t\t\tstart_posn += fldsep_len;\n\t\t\tstart_ptr += charlen_to_bytelen(start_ptr, fldsep_len);\n\t\t}\n\n\t\ttext_position_cleanup(&state);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When fldsep is NULL, each character in the inputstring becomes an\n\t\t * element in the result array.  The separator is effectively the\n\t\t * space between characters.\n\t\t */\n\t\tinputstring_len = VARSIZE_ANY_EXHDR(inputstring);\n\n\t\t/* return empty array for empty input string */\n\t\tif (inputstring_len < 1)\n\t\t\tPG_RETURN_ARRAYTYPE_P(construct_empty_array(TEXTOID));\n\n\t\tstart_ptr = VARDATA_ANY(inputstring);\n\n\t\twhile (inputstring_len > 0)\n\t\t{\n\t\t\tint\t\t\tchunk_len = pg_mblen(start_ptr);\n\n\t\t\tCHECK_FOR_INTERRUPTS();\n\n\t\t\t/* must build a temp text datum to pass to accumArrayResult */\n\t\t\tresult_text = cstring_to_text_with_len(start_ptr, chunk_len);\n\t\t\tis_null = null_string ? text_isequal(result_text, null_string) : false;\n\n\t\t\t/* stash away this field */\n\t\t\tastate = accumArrayResult(astate,\n\t\t\t\t\t\t\t\t\t  PointerGetDatum(result_text),\n\t\t\t\t\t\t\t\t\t  is_null,\n\t\t\t\t\t\t\t\t\t  TEXTOID,\n\t\t\t\t\t\t\t\t\t  CurrentMemoryContext);\n\n\t\t\tpfree(result_text);\n\n\t\t\tstart_ptr += chunk_len;\n\t\t\tinputstring_len -= chunk_len;\n\t\t}\n\t}\n\n\tPG_RETURN_ARRAYTYPE_P(makeArrayResult(astate,\n\t\t\t\t\t\t\t\t\t\t  CurrentMemoryContext));\n}"
  },
  {
    "function_name": "text_to_array_null",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "4308-4312",
    "snippet": "Datum\ntext_to_array_null(PG_FUNCTION_ARGS)\n{\n\treturn text_to_array_internal(fcinfo);\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);",
      "static StringInfo makeStringAggState(FunctionCallInfo fcinfo);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "text_to_array_internal",
          "args": [
            "fcinfo"
          ],
          "line": 4311
        },
        "resolved": true,
        "details": {
          "function_name": "text_to_array_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "4319-4490",
          "snippet": "static Datum\ntext_to_array_internal(PG_FUNCTION_ARGS)\n{\n\ttext\t   *inputstring;\n\ttext\t   *fldsep;\n\ttext\t   *null_string;\n\tint\t\t\tinputstring_len;\n\tint\t\t\tfldsep_len;\n\tchar\t   *start_ptr;\n\ttext\t   *result_text;\n\tbool\t\tis_null;\n\tArrayBuildState *astate = NULL;\n\n\t/* when input string is NULL, then result is NULL too */\n\tif (PG_ARGISNULL(0))\n\t\tPG_RETURN_NULL();\n\n\tinputstring = PG_GETARG_TEXT_PP(0);\n\n\t/* fldsep can be NULL */\n\tif (!PG_ARGISNULL(1))\n\t\tfldsep = PG_GETARG_TEXT_PP(1);\n\telse\n\t\tfldsep = NULL;\n\n\t/* null_string can be NULL or omitted */\n\tif (PG_NARGS() > 2 && !PG_ARGISNULL(2))\n\t\tnull_string = PG_GETARG_TEXT_PP(2);\n\telse\n\t\tnull_string = NULL;\n\n\tif (fldsep != NULL)\n\t{\n\t\t/*\n\t\t * Normal case with non-null fldsep.  Use the text_position machinery\n\t\t * to search for occurrences of fldsep.\n\t\t */\n\t\tTextPositionState state;\n\t\tint\t\t\tfldnum;\n\t\tint\t\t\tstart_posn;\n\t\tint\t\t\tend_posn;\n\t\tint\t\t\tchunk_len;\n\n\t\ttext_position_setup(inputstring, fldsep, &state);\n\n\t\t/*\n\t\t * Note: we check the converted string length, not the original,\n\t\t * because they could be different if the input contained invalid\n\t\t * encoding.\n\t\t */\n\t\tinputstring_len = state.len1;\n\t\tfldsep_len = state.len2;\n\n\t\t/* return empty array for empty input string */\n\t\tif (inputstring_len < 1)\n\t\t{\n\t\t\ttext_position_cleanup(&state);\n\t\t\tPG_RETURN_ARRAYTYPE_P(construct_empty_array(TEXTOID));\n\t\t}\n\n\t\t/*\n\t\t * empty field separator: return the input string as a one-element\n\t\t * array\n\t\t */\n\t\tif (fldsep_len < 1)\n\t\t{\n\t\t\tDatum\t\telems[1];\n\t\t\tbool\t\tnulls[1];\n\t\t\tint\t\t\tdims[1];\n\t\t\tint\t\t\tlbs[1];\n\n\t\t\ttext_position_cleanup(&state);\n\t\t\t/* single element can be a NULL too */\n\t\t\tis_null = null_string ? text_isequal(inputstring, null_string) : false;\n\n\t\t\telems[0] = PointerGetDatum(inputstring);\n\t\t\tnulls[0] = is_null;\n\t\t\tdims[0] = 1;\n\t\t\tlbs[0] = 1;\n\t\t\t/* XXX: this hardcodes assumptions about the text type */\n\t\t\tPG_RETURN_ARRAYTYPE_P(construct_md_array(elems, nulls,\n\t\t\t\t\t\t\t\t\t\t\t\t\t 1, dims, lbs,\n\t\t\t\t\t\t\t\t\t\t\t\t\t TEXTOID, -1, false, 'i'));\n\t\t}\n\n\t\tstart_posn = 1;\n\t\t/* start_ptr points to the start_posn'th character of inputstring */\n\t\tstart_ptr = VARDATA_ANY(inputstring);\n\n\t\tfor (fldnum = 1;; fldnum++) /* field number is 1 based */\n\t\t{\n\t\t\tCHECK_FOR_INTERRUPTS();\n\n\t\t\tend_posn = text_position_next(start_posn, &state);\n\n\t\t\tif (end_posn == 0)\n\t\t\t{\n\t\t\t\t/* fetch last field */\n\t\t\t\tchunk_len = ((char *) inputstring + VARSIZE_ANY(inputstring)) - start_ptr;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* fetch non-last field */\n\t\t\t\tchunk_len = charlen_to_bytelen(start_ptr, end_posn - start_posn);\n\t\t\t}\n\n\t\t\t/* must build a temp text datum to pass to accumArrayResult */\n\t\t\tresult_text = cstring_to_text_with_len(start_ptr, chunk_len);\n\t\t\tis_null = null_string ? text_isequal(result_text, null_string) : false;\n\n\t\t\t/* stash away this field */\n\t\t\tastate = accumArrayResult(astate,\n\t\t\t\t\t\t\t\t\t  PointerGetDatum(result_text),\n\t\t\t\t\t\t\t\t\t  is_null,\n\t\t\t\t\t\t\t\t\t  TEXTOID,\n\t\t\t\t\t\t\t\t\t  CurrentMemoryContext);\n\n\t\t\tpfree(result_text);\n\n\t\t\tif (end_posn == 0)\n\t\t\t\tbreak;\n\n\t\t\tstart_posn = end_posn;\n\t\t\tstart_ptr += chunk_len;\n\t\t\tstart_posn += fldsep_len;\n\t\t\tstart_ptr += charlen_to_bytelen(start_ptr, fldsep_len);\n\t\t}\n\n\t\ttext_position_cleanup(&state);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When fldsep is NULL, each character in the inputstring becomes an\n\t\t * element in the result array.  The separator is effectively the\n\t\t * space between characters.\n\t\t */\n\t\tinputstring_len = VARSIZE_ANY_EXHDR(inputstring);\n\n\t\t/* return empty array for empty input string */\n\t\tif (inputstring_len < 1)\n\t\t\tPG_RETURN_ARRAYTYPE_P(construct_empty_array(TEXTOID));\n\n\t\tstart_ptr = VARDATA_ANY(inputstring);\n\n\t\twhile (inputstring_len > 0)\n\t\t{\n\t\t\tint\t\t\tchunk_len = pg_mblen(start_ptr);\n\n\t\t\tCHECK_FOR_INTERRUPTS();\n\n\t\t\t/* must build a temp text datum to pass to accumArrayResult */\n\t\t\tresult_text = cstring_to_text_with_len(start_ptr, chunk_len);\n\t\t\tis_null = null_string ? text_isequal(result_text, null_string) : false;\n\n\t\t\t/* stash away this field */\n\t\t\tastate = accumArrayResult(astate,\n\t\t\t\t\t\t\t\t\t  PointerGetDatum(result_text),\n\t\t\t\t\t\t\t\t\t  is_null,\n\t\t\t\t\t\t\t\t\t  TEXTOID,\n\t\t\t\t\t\t\t\t\t  CurrentMemoryContext);\n\n\t\t\tpfree(result_text);\n\n\t\t\tstart_ptr += chunk_len;\n\t\t\tinputstring_len -= chunk_len;\n\t\t}\n\t}\n\n\tPG_RETURN_ARRAYTYPE_P(makeArrayResult(astate,\n\t\t\t\t\t\t\t\t\t\t  CurrentMemoryContext));\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void text_position_setup(text *t1, text *t2, TextPositionState *state);",
            "static int\ttext_position_next(int start_pos, TextPositionState *state);",
            "static void text_position_cleanup(TextPositionState *state);",
            "static Datum text_to_array_internal(PG_FUNCTION_ARGS);",
            "static text *array_to_text_internal(FunctionCallInfo fcinfo, ArrayType *v,\n\t\t\t\t\t   const char *fldsep, const char *null_string);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void text_position_setup(text *t1, text *t2, TextPositionState *state);\nstatic int\ttext_position_next(int start_pos, TextPositionState *state);\nstatic void text_position_cleanup(TextPositionState *state);\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\nstatic text *array_to_text_internal(FunctionCallInfo fcinfo, ArrayType *v,\n\t\t\t\t\t   const char *fldsep, const char *null_string);\n\nstatic Datum\ntext_to_array_internal(PG_FUNCTION_ARGS)\n{\n\ttext\t   *inputstring;\n\ttext\t   *fldsep;\n\ttext\t   *null_string;\n\tint\t\t\tinputstring_len;\n\tint\t\t\tfldsep_len;\n\tchar\t   *start_ptr;\n\ttext\t   *result_text;\n\tbool\t\tis_null;\n\tArrayBuildState *astate = NULL;\n\n\t/* when input string is NULL, then result is NULL too */\n\tif (PG_ARGISNULL(0))\n\t\tPG_RETURN_NULL();\n\n\tinputstring = PG_GETARG_TEXT_PP(0);\n\n\t/* fldsep can be NULL */\n\tif (!PG_ARGISNULL(1))\n\t\tfldsep = PG_GETARG_TEXT_PP(1);\n\telse\n\t\tfldsep = NULL;\n\n\t/* null_string can be NULL or omitted */\n\tif (PG_NARGS() > 2 && !PG_ARGISNULL(2))\n\t\tnull_string = PG_GETARG_TEXT_PP(2);\n\telse\n\t\tnull_string = NULL;\n\n\tif (fldsep != NULL)\n\t{\n\t\t/*\n\t\t * Normal case with non-null fldsep.  Use the text_position machinery\n\t\t * to search for occurrences of fldsep.\n\t\t */\n\t\tTextPositionState state;\n\t\tint\t\t\tfldnum;\n\t\tint\t\t\tstart_posn;\n\t\tint\t\t\tend_posn;\n\t\tint\t\t\tchunk_len;\n\n\t\ttext_position_setup(inputstring, fldsep, &state);\n\n\t\t/*\n\t\t * Note: we check the converted string length, not the original,\n\t\t * because they could be different if the input contained invalid\n\t\t * encoding.\n\t\t */\n\t\tinputstring_len = state.len1;\n\t\tfldsep_len = state.len2;\n\n\t\t/* return empty array for empty input string */\n\t\tif (inputstring_len < 1)\n\t\t{\n\t\t\ttext_position_cleanup(&state);\n\t\t\tPG_RETURN_ARRAYTYPE_P(construct_empty_array(TEXTOID));\n\t\t}\n\n\t\t/*\n\t\t * empty field separator: return the input string as a one-element\n\t\t * array\n\t\t */\n\t\tif (fldsep_len < 1)\n\t\t{\n\t\t\tDatum\t\telems[1];\n\t\t\tbool\t\tnulls[1];\n\t\t\tint\t\t\tdims[1];\n\t\t\tint\t\t\tlbs[1];\n\n\t\t\ttext_position_cleanup(&state);\n\t\t\t/* single element can be a NULL too */\n\t\t\tis_null = null_string ? text_isequal(inputstring, null_string) : false;\n\n\t\t\telems[0] = PointerGetDatum(inputstring);\n\t\t\tnulls[0] = is_null;\n\t\t\tdims[0] = 1;\n\t\t\tlbs[0] = 1;\n\t\t\t/* XXX: this hardcodes assumptions about the text type */\n\t\t\tPG_RETURN_ARRAYTYPE_P(construct_md_array(elems, nulls,\n\t\t\t\t\t\t\t\t\t\t\t\t\t 1, dims, lbs,\n\t\t\t\t\t\t\t\t\t\t\t\t\t TEXTOID, -1, false, 'i'));\n\t\t}\n\n\t\tstart_posn = 1;\n\t\t/* start_ptr points to the start_posn'th character of inputstring */\n\t\tstart_ptr = VARDATA_ANY(inputstring);\n\n\t\tfor (fldnum = 1;; fldnum++) /* field number is 1 based */\n\t\t{\n\t\t\tCHECK_FOR_INTERRUPTS();\n\n\t\t\tend_posn = text_position_next(start_posn, &state);\n\n\t\t\tif (end_posn == 0)\n\t\t\t{\n\t\t\t\t/* fetch last field */\n\t\t\t\tchunk_len = ((char *) inputstring + VARSIZE_ANY(inputstring)) - start_ptr;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* fetch non-last field */\n\t\t\t\tchunk_len = charlen_to_bytelen(start_ptr, end_posn - start_posn);\n\t\t\t}\n\n\t\t\t/* must build a temp text datum to pass to accumArrayResult */\n\t\t\tresult_text = cstring_to_text_with_len(start_ptr, chunk_len);\n\t\t\tis_null = null_string ? text_isequal(result_text, null_string) : false;\n\n\t\t\t/* stash away this field */\n\t\t\tastate = accumArrayResult(astate,\n\t\t\t\t\t\t\t\t\t  PointerGetDatum(result_text),\n\t\t\t\t\t\t\t\t\t  is_null,\n\t\t\t\t\t\t\t\t\t  TEXTOID,\n\t\t\t\t\t\t\t\t\t  CurrentMemoryContext);\n\n\t\t\tpfree(result_text);\n\n\t\t\tif (end_posn == 0)\n\t\t\t\tbreak;\n\n\t\t\tstart_posn = end_posn;\n\t\t\tstart_ptr += chunk_len;\n\t\t\tstart_posn += fldsep_len;\n\t\t\tstart_ptr += charlen_to_bytelen(start_ptr, fldsep_len);\n\t\t}\n\n\t\ttext_position_cleanup(&state);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When fldsep is NULL, each character in the inputstring becomes an\n\t\t * element in the result array.  The separator is effectively the\n\t\t * space between characters.\n\t\t */\n\t\tinputstring_len = VARSIZE_ANY_EXHDR(inputstring);\n\n\t\t/* return empty array for empty input string */\n\t\tif (inputstring_len < 1)\n\t\t\tPG_RETURN_ARRAYTYPE_P(construct_empty_array(TEXTOID));\n\n\t\tstart_ptr = VARDATA_ANY(inputstring);\n\n\t\twhile (inputstring_len > 0)\n\t\t{\n\t\t\tint\t\t\tchunk_len = pg_mblen(start_ptr);\n\n\t\t\tCHECK_FOR_INTERRUPTS();\n\n\t\t\t/* must build a temp text datum to pass to accumArrayResult */\n\t\t\tresult_text = cstring_to_text_with_len(start_ptr, chunk_len);\n\t\t\tis_null = null_string ? text_isequal(result_text, null_string) : false;\n\n\t\t\t/* stash away this field */\n\t\t\tastate = accumArrayResult(astate,\n\t\t\t\t\t\t\t\t\t  PointerGetDatum(result_text),\n\t\t\t\t\t\t\t\t\t  is_null,\n\t\t\t\t\t\t\t\t\t  TEXTOID,\n\t\t\t\t\t\t\t\t\t  CurrentMemoryContext);\n\n\t\t\tpfree(result_text);\n\n\t\t\tstart_ptr += chunk_len;\n\t\t\tinputstring_len -= chunk_len;\n\t\t}\n\t}\n\n\tPG_RETURN_ARRAYTYPE_P(makeArrayResult(astate,\n\t\t\t\t\t\t\t\t\t\t  CurrentMemoryContext));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\nstatic StringInfo makeStringAggState(FunctionCallInfo fcinfo);\n\nDatum\ntext_to_array_null(PG_FUNCTION_ARGS)\n{\n\treturn text_to_array_internal(fcinfo);\n}"
  },
  {
    "function_name": "text_to_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "4294-4298",
    "snippet": "Datum\ntext_to_array(PG_FUNCTION_ARGS)\n{\n\treturn text_to_array_internal(fcinfo);\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);",
      "static StringInfo makeStringAggState(FunctionCallInfo fcinfo);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "text_to_array_internal",
          "args": [
            "fcinfo"
          ],
          "line": 4297
        },
        "resolved": true,
        "details": {
          "function_name": "text_to_array_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "4319-4490",
          "snippet": "static Datum\ntext_to_array_internal(PG_FUNCTION_ARGS)\n{\n\ttext\t   *inputstring;\n\ttext\t   *fldsep;\n\ttext\t   *null_string;\n\tint\t\t\tinputstring_len;\n\tint\t\t\tfldsep_len;\n\tchar\t   *start_ptr;\n\ttext\t   *result_text;\n\tbool\t\tis_null;\n\tArrayBuildState *astate = NULL;\n\n\t/* when input string is NULL, then result is NULL too */\n\tif (PG_ARGISNULL(0))\n\t\tPG_RETURN_NULL();\n\n\tinputstring = PG_GETARG_TEXT_PP(0);\n\n\t/* fldsep can be NULL */\n\tif (!PG_ARGISNULL(1))\n\t\tfldsep = PG_GETARG_TEXT_PP(1);\n\telse\n\t\tfldsep = NULL;\n\n\t/* null_string can be NULL or omitted */\n\tif (PG_NARGS() > 2 && !PG_ARGISNULL(2))\n\t\tnull_string = PG_GETARG_TEXT_PP(2);\n\telse\n\t\tnull_string = NULL;\n\n\tif (fldsep != NULL)\n\t{\n\t\t/*\n\t\t * Normal case with non-null fldsep.  Use the text_position machinery\n\t\t * to search for occurrences of fldsep.\n\t\t */\n\t\tTextPositionState state;\n\t\tint\t\t\tfldnum;\n\t\tint\t\t\tstart_posn;\n\t\tint\t\t\tend_posn;\n\t\tint\t\t\tchunk_len;\n\n\t\ttext_position_setup(inputstring, fldsep, &state);\n\n\t\t/*\n\t\t * Note: we check the converted string length, not the original,\n\t\t * because they could be different if the input contained invalid\n\t\t * encoding.\n\t\t */\n\t\tinputstring_len = state.len1;\n\t\tfldsep_len = state.len2;\n\n\t\t/* return empty array for empty input string */\n\t\tif (inputstring_len < 1)\n\t\t{\n\t\t\ttext_position_cleanup(&state);\n\t\t\tPG_RETURN_ARRAYTYPE_P(construct_empty_array(TEXTOID));\n\t\t}\n\n\t\t/*\n\t\t * empty field separator: return the input string as a one-element\n\t\t * array\n\t\t */\n\t\tif (fldsep_len < 1)\n\t\t{\n\t\t\tDatum\t\telems[1];\n\t\t\tbool\t\tnulls[1];\n\t\t\tint\t\t\tdims[1];\n\t\t\tint\t\t\tlbs[1];\n\n\t\t\ttext_position_cleanup(&state);\n\t\t\t/* single element can be a NULL too */\n\t\t\tis_null = null_string ? text_isequal(inputstring, null_string) : false;\n\n\t\t\telems[0] = PointerGetDatum(inputstring);\n\t\t\tnulls[0] = is_null;\n\t\t\tdims[0] = 1;\n\t\t\tlbs[0] = 1;\n\t\t\t/* XXX: this hardcodes assumptions about the text type */\n\t\t\tPG_RETURN_ARRAYTYPE_P(construct_md_array(elems, nulls,\n\t\t\t\t\t\t\t\t\t\t\t\t\t 1, dims, lbs,\n\t\t\t\t\t\t\t\t\t\t\t\t\t TEXTOID, -1, false, 'i'));\n\t\t}\n\n\t\tstart_posn = 1;\n\t\t/* start_ptr points to the start_posn'th character of inputstring */\n\t\tstart_ptr = VARDATA_ANY(inputstring);\n\n\t\tfor (fldnum = 1;; fldnum++) /* field number is 1 based */\n\t\t{\n\t\t\tCHECK_FOR_INTERRUPTS();\n\n\t\t\tend_posn = text_position_next(start_posn, &state);\n\n\t\t\tif (end_posn == 0)\n\t\t\t{\n\t\t\t\t/* fetch last field */\n\t\t\t\tchunk_len = ((char *) inputstring + VARSIZE_ANY(inputstring)) - start_ptr;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* fetch non-last field */\n\t\t\t\tchunk_len = charlen_to_bytelen(start_ptr, end_posn - start_posn);\n\t\t\t}\n\n\t\t\t/* must build a temp text datum to pass to accumArrayResult */\n\t\t\tresult_text = cstring_to_text_with_len(start_ptr, chunk_len);\n\t\t\tis_null = null_string ? text_isequal(result_text, null_string) : false;\n\n\t\t\t/* stash away this field */\n\t\t\tastate = accumArrayResult(astate,\n\t\t\t\t\t\t\t\t\t  PointerGetDatum(result_text),\n\t\t\t\t\t\t\t\t\t  is_null,\n\t\t\t\t\t\t\t\t\t  TEXTOID,\n\t\t\t\t\t\t\t\t\t  CurrentMemoryContext);\n\n\t\t\tpfree(result_text);\n\n\t\t\tif (end_posn == 0)\n\t\t\t\tbreak;\n\n\t\t\tstart_posn = end_posn;\n\t\t\tstart_ptr += chunk_len;\n\t\t\tstart_posn += fldsep_len;\n\t\t\tstart_ptr += charlen_to_bytelen(start_ptr, fldsep_len);\n\t\t}\n\n\t\ttext_position_cleanup(&state);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When fldsep is NULL, each character in the inputstring becomes an\n\t\t * element in the result array.  The separator is effectively the\n\t\t * space between characters.\n\t\t */\n\t\tinputstring_len = VARSIZE_ANY_EXHDR(inputstring);\n\n\t\t/* return empty array for empty input string */\n\t\tif (inputstring_len < 1)\n\t\t\tPG_RETURN_ARRAYTYPE_P(construct_empty_array(TEXTOID));\n\n\t\tstart_ptr = VARDATA_ANY(inputstring);\n\n\t\twhile (inputstring_len > 0)\n\t\t{\n\t\t\tint\t\t\tchunk_len = pg_mblen(start_ptr);\n\n\t\t\tCHECK_FOR_INTERRUPTS();\n\n\t\t\t/* must build a temp text datum to pass to accumArrayResult */\n\t\t\tresult_text = cstring_to_text_with_len(start_ptr, chunk_len);\n\t\t\tis_null = null_string ? text_isequal(result_text, null_string) : false;\n\n\t\t\t/* stash away this field */\n\t\t\tastate = accumArrayResult(astate,\n\t\t\t\t\t\t\t\t\t  PointerGetDatum(result_text),\n\t\t\t\t\t\t\t\t\t  is_null,\n\t\t\t\t\t\t\t\t\t  TEXTOID,\n\t\t\t\t\t\t\t\t\t  CurrentMemoryContext);\n\n\t\t\tpfree(result_text);\n\n\t\t\tstart_ptr += chunk_len;\n\t\t\tinputstring_len -= chunk_len;\n\t\t}\n\t}\n\n\tPG_RETURN_ARRAYTYPE_P(makeArrayResult(astate,\n\t\t\t\t\t\t\t\t\t\t  CurrentMemoryContext));\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void text_position_setup(text *t1, text *t2, TextPositionState *state);",
            "static int\ttext_position_next(int start_pos, TextPositionState *state);",
            "static void text_position_cleanup(TextPositionState *state);",
            "static Datum text_to_array_internal(PG_FUNCTION_ARGS);",
            "static text *array_to_text_internal(FunctionCallInfo fcinfo, ArrayType *v,\n\t\t\t\t\t   const char *fldsep, const char *null_string);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void text_position_setup(text *t1, text *t2, TextPositionState *state);\nstatic int\ttext_position_next(int start_pos, TextPositionState *state);\nstatic void text_position_cleanup(TextPositionState *state);\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\nstatic text *array_to_text_internal(FunctionCallInfo fcinfo, ArrayType *v,\n\t\t\t\t\t   const char *fldsep, const char *null_string);\n\nstatic Datum\ntext_to_array_internal(PG_FUNCTION_ARGS)\n{\n\ttext\t   *inputstring;\n\ttext\t   *fldsep;\n\ttext\t   *null_string;\n\tint\t\t\tinputstring_len;\n\tint\t\t\tfldsep_len;\n\tchar\t   *start_ptr;\n\ttext\t   *result_text;\n\tbool\t\tis_null;\n\tArrayBuildState *astate = NULL;\n\n\t/* when input string is NULL, then result is NULL too */\n\tif (PG_ARGISNULL(0))\n\t\tPG_RETURN_NULL();\n\n\tinputstring = PG_GETARG_TEXT_PP(0);\n\n\t/* fldsep can be NULL */\n\tif (!PG_ARGISNULL(1))\n\t\tfldsep = PG_GETARG_TEXT_PP(1);\n\telse\n\t\tfldsep = NULL;\n\n\t/* null_string can be NULL or omitted */\n\tif (PG_NARGS() > 2 && !PG_ARGISNULL(2))\n\t\tnull_string = PG_GETARG_TEXT_PP(2);\n\telse\n\t\tnull_string = NULL;\n\n\tif (fldsep != NULL)\n\t{\n\t\t/*\n\t\t * Normal case with non-null fldsep.  Use the text_position machinery\n\t\t * to search for occurrences of fldsep.\n\t\t */\n\t\tTextPositionState state;\n\t\tint\t\t\tfldnum;\n\t\tint\t\t\tstart_posn;\n\t\tint\t\t\tend_posn;\n\t\tint\t\t\tchunk_len;\n\n\t\ttext_position_setup(inputstring, fldsep, &state);\n\n\t\t/*\n\t\t * Note: we check the converted string length, not the original,\n\t\t * because they could be different if the input contained invalid\n\t\t * encoding.\n\t\t */\n\t\tinputstring_len = state.len1;\n\t\tfldsep_len = state.len2;\n\n\t\t/* return empty array for empty input string */\n\t\tif (inputstring_len < 1)\n\t\t{\n\t\t\ttext_position_cleanup(&state);\n\t\t\tPG_RETURN_ARRAYTYPE_P(construct_empty_array(TEXTOID));\n\t\t}\n\n\t\t/*\n\t\t * empty field separator: return the input string as a one-element\n\t\t * array\n\t\t */\n\t\tif (fldsep_len < 1)\n\t\t{\n\t\t\tDatum\t\telems[1];\n\t\t\tbool\t\tnulls[1];\n\t\t\tint\t\t\tdims[1];\n\t\t\tint\t\t\tlbs[1];\n\n\t\t\ttext_position_cleanup(&state);\n\t\t\t/* single element can be a NULL too */\n\t\t\tis_null = null_string ? text_isequal(inputstring, null_string) : false;\n\n\t\t\telems[0] = PointerGetDatum(inputstring);\n\t\t\tnulls[0] = is_null;\n\t\t\tdims[0] = 1;\n\t\t\tlbs[0] = 1;\n\t\t\t/* XXX: this hardcodes assumptions about the text type */\n\t\t\tPG_RETURN_ARRAYTYPE_P(construct_md_array(elems, nulls,\n\t\t\t\t\t\t\t\t\t\t\t\t\t 1, dims, lbs,\n\t\t\t\t\t\t\t\t\t\t\t\t\t TEXTOID, -1, false, 'i'));\n\t\t}\n\n\t\tstart_posn = 1;\n\t\t/* start_ptr points to the start_posn'th character of inputstring */\n\t\tstart_ptr = VARDATA_ANY(inputstring);\n\n\t\tfor (fldnum = 1;; fldnum++) /* field number is 1 based */\n\t\t{\n\t\t\tCHECK_FOR_INTERRUPTS();\n\n\t\t\tend_posn = text_position_next(start_posn, &state);\n\n\t\t\tif (end_posn == 0)\n\t\t\t{\n\t\t\t\t/* fetch last field */\n\t\t\t\tchunk_len = ((char *) inputstring + VARSIZE_ANY(inputstring)) - start_ptr;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* fetch non-last field */\n\t\t\t\tchunk_len = charlen_to_bytelen(start_ptr, end_posn - start_posn);\n\t\t\t}\n\n\t\t\t/* must build a temp text datum to pass to accumArrayResult */\n\t\t\tresult_text = cstring_to_text_with_len(start_ptr, chunk_len);\n\t\t\tis_null = null_string ? text_isequal(result_text, null_string) : false;\n\n\t\t\t/* stash away this field */\n\t\t\tastate = accumArrayResult(astate,\n\t\t\t\t\t\t\t\t\t  PointerGetDatum(result_text),\n\t\t\t\t\t\t\t\t\t  is_null,\n\t\t\t\t\t\t\t\t\t  TEXTOID,\n\t\t\t\t\t\t\t\t\t  CurrentMemoryContext);\n\n\t\t\tpfree(result_text);\n\n\t\t\tif (end_posn == 0)\n\t\t\t\tbreak;\n\n\t\t\tstart_posn = end_posn;\n\t\t\tstart_ptr += chunk_len;\n\t\t\tstart_posn += fldsep_len;\n\t\t\tstart_ptr += charlen_to_bytelen(start_ptr, fldsep_len);\n\t\t}\n\n\t\ttext_position_cleanup(&state);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When fldsep is NULL, each character in the inputstring becomes an\n\t\t * element in the result array.  The separator is effectively the\n\t\t * space between characters.\n\t\t */\n\t\tinputstring_len = VARSIZE_ANY_EXHDR(inputstring);\n\n\t\t/* return empty array for empty input string */\n\t\tif (inputstring_len < 1)\n\t\t\tPG_RETURN_ARRAYTYPE_P(construct_empty_array(TEXTOID));\n\n\t\tstart_ptr = VARDATA_ANY(inputstring);\n\n\t\twhile (inputstring_len > 0)\n\t\t{\n\t\t\tint\t\t\tchunk_len = pg_mblen(start_ptr);\n\n\t\t\tCHECK_FOR_INTERRUPTS();\n\n\t\t\t/* must build a temp text datum to pass to accumArrayResult */\n\t\t\tresult_text = cstring_to_text_with_len(start_ptr, chunk_len);\n\t\t\tis_null = null_string ? text_isequal(result_text, null_string) : false;\n\n\t\t\t/* stash away this field */\n\t\t\tastate = accumArrayResult(astate,\n\t\t\t\t\t\t\t\t\t  PointerGetDatum(result_text),\n\t\t\t\t\t\t\t\t\t  is_null,\n\t\t\t\t\t\t\t\t\t  TEXTOID,\n\t\t\t\t\t\t\t\t\t  CurrentMemoryContext);\n\n\t\t\tpfree(result_text);\n\n\t\t\tstart_ptr += chunk_len;\n\t\t\tinputstring_len -= chunk_len;\n\t\t}\n\t}\n\n\tPG_RETURN_ARRAYTYPE_P(makeArrayResult(astate,\n\t\t\t\t\t\t\t\t\t\t  CurrentMemoryContext));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\nstatic StringInfo makeStringAggState(FunctionCallInfo fcinfo);\n\nDatum\ntext_to_array(PG_FUNCTION_ARGS)\n{\n\treturn text_to_array_internal(fcinfo);\n}"
  },
  {
    "function_name": "text_isequal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "4281-4287",
    "snippet": "static bool\ntext_isequal(text *txt1, text *txt2)\n{\n\treturn DatumGetBool(DirectFunctionCall2(texteq,\n\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(txt1),\n\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(txt2)));\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DatumGetBool",
          "args": [
            "DirectFunctionCall2(texteq,\n\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(txt1),\n\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(txt2))"
          ],
          "line": 4284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "texteq",
            "PointerGetDatum(txt1)",
            "PointerGetDatum(txt2)"
          ],
          "line": 4284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "txt2"
          ],
          "line": 4286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "txt1"
          ],
          "line": 4285
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool\ntext_isequal(text *txt1, text *txt2)\n{\n\treturn DatumGetBool(DirectFunctionCall2(texteq,\n\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(txt1),\n\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(txt2)));\n}"
  },
  {
    "function_name": "split_text",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "4184-4276",
    "snippet": "Datum\nsplit_text(PG_FUNCTION_ARGS)\n{\n\ttext\t   *inputstring = PG_GETARG_TEXT_PP(0);\n\ttext\t   *fldsep = PG_GETARG_TEXT_PP(1);\n\tint\t\t\tfldnum = PG_GETARG_INT32(2);\n\tint\t\t\tinputstring_len;\n\tint\t\t\tfldsep_len;\n\tTextPositionState state;\n\tint\t\t\tstart_posn;\n\tint\t\t\tend_posn;\n\ttext\t   *result_text;\n\n\t/* field number is 1 based */\n\tif (fldnum < 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"field position must be greater than zero\")));\n\n\ttext_position_setup(inputstring, fldsep, &state);\n\n\t/*\n\t * Note: we check the converted string length, not the original, because\n\t * they could be different if the input contained invalid encoding.\n\t */\n\tinputstring_len = state.len1;\n\tfldsep_len = state.len2;\n\n\t/* return empty string for empty input string */\n\tif (inputstring_len < 1)\n\t{\n\t\ttext_position_cleanup(&state);\n\t\tPG_RETURN_TEXT_P(cstring_to_text(\"\"));\n\t}\n\n\t/* empty field separator */\n\tif (fldsep_len < 1)\n\t{\n\t\ttext_position_cleanup(&state);\n\t\t/* if first field, return input string, else empty string */\n\t\tif (fldnum == 1)\n\t\t\tPG_RETURN_TEXT_P(inputstring);\n\t\telse\n\t\t\tPG_RETURN_TEXT_P(cstring_to_text(\"\"));\n\t}\n\n\t/* identify bounds of first field */\n\tstart_posn = 1;\n\tend_posn = text_position_next(1, &state);\n\n\t/* special case if fldsep not found at all */\n\tif (end_posn == 0)\n\t{\n\t\ttext_position_cleanup(&state);\n\t\t/* if field 1 requested, return input string, else empty string */\n\t\tif (fldnum == 1)\n\t\t\tPG_RETURN_TEXT_P(inputstring);\n\t\telse\n\t\t\tPG_RETURN_TEXT_P(cstring_to_text(\"\"));\n\t}\n\n\twhile (end_posn > 0 && --fldnum > 0)\n\t{\n\t\t/* identify bounds of next field */\n\t\tstart_posn = end_posn + fldsep_len;\n\t\tend_posn = text_position_next(start_posn, &state);\n\t}\n\n\ttext_position_cleanup(&state);\n\n\tif (fldnum > 0)\n\t{\n\t\t/* N'th field separator not found */\n\t\t/* if last field requested, return it, else empty string */\n\t\tif (fldnum == 1)\n\t\t\tresult_text = text_substring(PointerGetDatum(inputstring),\n\t\t\t\t\t\t\t\t\t\t start_posn,\n\t\t\t\t\t\t\t\t\t\t -1,\n\t\t\t\t\t\t\t\t\t\t true);\n\t\telse\n\t\t\tresult_text = cstring_to_text(\"\");\n\t}\n\telse\n\t{\n\t\t/* non-last field requested */\n\t\tresult_text = text_substring(PointerGetDatum(inputstring),\n\t\t\t\t\t\t\t\t\t start_posn,\n\t\t\t\t\t\t\t\t\t end_posn - start_posn,\n\t\t\t\t\t\t\t\t\t false);\n\t}\n\n\tPG_RETURN_TEXT_P(result_text);\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void text_position_setup(text *t1, text *t2, TextPositionState *state);",
      "static int\ttext_position_next(int start_pos, TextPositionState *state);",
      "static void text_position_cleanup(TextPositionState *state);",
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "result_text"
          ],
          "line": 4275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text_substring",
          "args": [
            "PointerGetDatum(inputstring)",
            "start_posn",
            "end_posn - start_posn",
            "false"
          ],
          "line": 4269
        },
        "resolved": true,
        "details": {
          "function_name": "text_substring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "813-1001",
          "snippet": "static text *\ntext_substring(Datum str, int32 start, int32 length, bool length_not_specified)\n{\n\tint32\t\teml = pg_database_encoding_max_length();\n\tint32\t\tS = start;\t\t/* start position */\n\tint32\t\tS1;\t\t\t\t/* adjusted start position */\n\tint32\t\tL1;\t\t\t\t/* adjusted substring length */\n\n\t/* life is easy if the encoding max length is 1 */\n\tif (eml == 1)\n\t{\n\t\tS1 = Max(S, 1);\n\n\t\tif (length_not_specified)\t/* special case - get length to end of\n\t\t\t\t\t\t\t\t\t * string */\n\t\t\tL1 = -1;\n\t\telse\n\t\t{\n\t\t\t/* end position */\n\t\t\tint\t\t\tE = S + length;\n\n\t\t\t/*\n\t\t\t * A negative value for L is the only way for the end position to\n\t\t\t * be before the start. SQL99 says to throw an error.\n\t\t\t */\n\t\t\tif (E < S)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SUBSTRING_ERROR),\n\t\t\t\t\t\t errmsg(\"negative substring length not allowed\")));\n\n\t\t\t/*\n\t\t\t * A zero or negative value for the end position can happen if the\n\t\t\t * start was negative or one. SQL99 says to return a zero-length\n\t\t\t * string.\n\t\t\t */\n\t\t\tif (E < 1)\n\t\t\t\treturn cstring_to_text(\"\");\n\n\t\t\tL1 = E - S1;\n\t\t}\n\n\t\t/*\n\t\t * If the start position is past the end of the string, SQL99 says to\n\t\t * return a zero-length string -- PG_GETARG_TEXT_P_SLICE() will do\n\t\t * that for us. Convert to zero-based starting position\n\t\t */\n\t\treturn DatumGetTextPSlice(str, S1 - 1, L1);\n\t}\n\telse if (eml > 1)\n\t{\n\t\t/*\n\t\t * When encoding max length is > 1, we can't get LC without\n\t\t * detoasting, so we'll grab a conservatively large slice now and go\n\t\t * back later to do the right thing\n\t\t */\n\t\tint32\t\tslice_start;\n\t\tint32\t\tslice_size;\n\t\tint32\t\tslice_strlen;\n\t\ttext\t   *slice;\n\t\tint32\t\tE1;\n\t\tint32\t\ti;\n\t\tchar\t   *p;\n\t\tchar\t   *s;\n\t\ttext\t   *ret;\n\n\t\t/*\n\t\t * if S is past the end of the string, the tuple toaster will return a\n\t\t * zero-length string to us\n\t\t */\n\t\tS1 = Max(S, 1);\n\n\t\t/*\n\t\t * We need to start at position zero because there is no way to know\n\t\t * in advance which byte offset corresponds to the supplied start\n\t\t * position.\n\t\t */\n\t\tslice_start = 0;\n\n\t\tif (length_not_specified)\t/* special case - get length to end of\n\t\t\t\t\t\t\t\t\t * string */\n\t\t\tslice_size = L1 = -1;\n\t\telse\n\t\t{\n\t\t\tint\t\t\tE = S + length;\n\n\t\t\t/*\n\t\t\t * A negative value for L is the only way for the end position to\n\t\t\t * be before the start. SQL99 says to throw an error.\n\t\t\t */\n\t\t\tif (E < S)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SUBSTRING_ERROR),\n\t\t\t\t\t\t errmsg(\"negative substring length not allowed\")));\n\n\t\t\t/*\n\t\t\t * A zero or negative value for the end position can happen if the\n\t\t\t * start was negative or one. SQL99 says to return a zero-length\n\t\t\t * string.\n\t\t\t */\n\t\t\tif (E < 1)\n\t\t\t\treturn cstring_to_text(\"\");\n\n\t\t\t/*\n\t\t\t * if E is past the end of the string, the tuple toaster will\n\t\t\t * truncate the length for us\n\t\t\t */\n\t\t\tL1 = E - S1;\n\n\t\t\t/*\n\t\t\t * Total slice size in bytes can't be any longer than the start\n\t\t\t * position plus substring length times the encoding max length.\n\t\t\t */\n\t\t\tslice_size = (S1 + L1) * eml;\n\t\t}\n\n\t\t/*\n\t\t * If we're working with an untoasted source, no need to do an extra\n\t\t * copying step.\n\t\t */\n\t\tif (VARATT_IS_COMPRESSED(DatumGetPointer(str)) ||\n\t\t\tVARATT_IS_EXTERNAL(DatumGetPointer(str)))\n\t\t\tslice = DatumGetTextPSlice(str, slice_start, slice_size);\n\t\telse\n\t\t\tslice = (text *) DatumGetPointer(str);\n\n\t\t/* see if we got back an empty string */\n\t\tif (VARSIZE_ANY_EXHDR(slice) == 0)\n\t\t{\n\t\t\tif (slice != (text *) DatumGetPointer(str))\n\t\t\t\tpfree(slice);\n\t\t\treturn cstring_to_text(\"\");\n\t\t}\n\n\t\t/* Now we can get the actual length of the slice in MB characters */\n\t\tslice_strlen = pg_mbstrlen_with_len(VARDATA_ANY(slice),\n\t\t\t\t\t\t\t\t\t\t\tVARSIZE_ANY_EXHDR(slice));\n\n\t\t/*\n\t\t * Check that the start position wasn't > slice_strlen. If so, SQL99\n\t\t * says to return a zero-length string.\n\t\t */\n\t\tif (S1 > slice_strlen)\n\t\t{\n\t\t\tif (slice != (text *) DatumGetPointer(str))\n\t\t\t\tpfree(slice);\n\t\t\treturn cstring_to_text(\"\");\n\t\t}\n\n\t\t/*\n\t\t * Adjust L1 and E1 now that we know the slice string length. Again\n\t\t * remember that S1 is one based, and slice_start is zero based.\n\t\t */\n\t\tif (L1 > -1)\n\t\t\tE1 = Min(S1 + L1, slice_start + 1 + slice_strlen);\n\t\telse\n\t\t\tE1 = slice_start + 1 + slice_strlen;\n\n\t\t/*\n\t\t * Find the start position in the slice; remember S1 is not zero based\n\t\t */\n\t\tp = VARDATA_ANY(slice);\n\t\tfor (i = 0; i < S1 - 1; i++)\n\t\t\tp += pg_mblen(p);\n\n\t\t/* hang onto a pointer to our start position */\n\t\ts = p;\n\n\t\t/*\n\t\t * Count the actual bytes used by the substring of the requested\n\t\t * length.\n\t\t */\n\t\tfor (i = S1; i < E1; i++)\n\t\t\tp += pg_mblen(p);\n\n\t\tret = (text *) palloc(VARHDRSZ + (p - s));\n\t\tSET_VARSIZE(ret, VARHDRSZ + (p - s));\n\t\tmemcpy(VARDATA(ret), s, (p - s));\n\n\t\tif (slice != (text *) DatumGetPointer(str))\n\t\t\tpfree(slice);\n\n\t\treturn ret;\n\t}\n\telse\n\t\telog(ERROR, \"invalid backend encoding: encoding max length < 1\");\n\n\t/* not reached: suppress compiler warning */\n\treturn NULL;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int32 text_length(Datum str);",
            "static text *text_substring(Datum str,\n\t\t\t   int32 start,\n\t\t\t   int32 length,\n\t\t\t   bool length_not_specified);",
            "static bytea *bytea_substring(Datum str,\n\t\t\t\tint S,\n\t\t\t\tint L,\n\t\t\t\tbool length_not_specified);",
            "static void appendStringInfoText(StringInfo str, const text *t);",
            "static bool text_format_parse_digits(const char **ptr, const char *end_ptr,\n\t\t\t\t\t\t int *value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int32 text_length(Datum str);\nstatic text *text_substring(Datum str,\n\t\t\t   int32 start,\n\t\t\t   int32 length,\n\t\t\t   bool length_not_specified);\nstatic bytea *bytea_substring(Datum str,\n\t\t\t\tint S,\n\t\t\t\tint L,\n\t\t\t\tbool length_not_specified);\nstatic void appendStringInfoText(StringInfo str, const text *t);\nstatic bool text_format_parse_digits(const char **ptr, const char *end_ptr,\n\t\t\t\t\t\t int *value);\n\nstatic text *\ntext_substring(Datum str, int32 start, int32 length, bool length_not_specified)\n{\n\tint32\t\teml = pg_database_encoding_max_length();\n\tint32\t\tS = start;\t\t/* start position */\n\tint32\t\tS1;\t\t\t\t/* adjusted start position */\n\tint32\t\tL1;\t\t\t\t/* adjusted substring length */\n\n\t/* life is easy if the encoding max length is 1 */\n\tif (eml == 1)\n\t{\n\t\tS1 = Max(S, 1);\n\n\t\tif (length_not_specified)\t/* special case - get length to end of\n\t\t\t\t\t\t\t\t\t * string */\n\t\t\tL1 = -1;\n\t\telse\n\t\t{\n\t\t\t/* end position */\n\t\t\tint\t\t\tE = S + length;\n\n\t\t\t/*\n\t\t\t * A negative value for L is the only way for the end position to\n\t\t\t * be before the start. SQL99 says to throw an error.\n\t\t\t */\n\t\t\tif (E < S)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SUBSTRING_ERROR),\n\t\t\t\t\t\t errmsg(\"negative substring length not allowed\")));\n\n\t\t\t/*\n\t\t\t * A zero or negative value for the end position can happen if the\n\t\t\t * start was negative or one. SQL99 says to return a zero-length\n\t\t\t * string.\n\t\t\t */\n\t\t\tif (E < 1)\n\t\t\t\treturn cstring_to_text(\"\");\n\n\t\t\tL1 = E - S1;\n\t\t}\n\n\t\t/*\n\t\t * If the start position is past the end of the string, SQL99 says to\n\t\t * return a zero-length string -- PG_GETARG_TEXT_P_SLICE() will do\n\t\t * that for us. Convert to zero-based starting position\n\t\t */\n\t\treturn DatumGetTextPSlice(str, S1 - 1, L1);\n\t}\n\telse if (eml > 1)\n\t{\n\t\t/*\n\t\t * When encoding max length is > 1, we can't get LC without\n\t\t * detoasting, so we'll grab a conservatively large slice now and go\n\t\t * back later to do the right thing\n\t\t */\n\t\tint32\t\tslice_start;\n\t\tint32\t\tslice_size;\n\t\tint32\t\tslice_strlen;\n\t\ttext\t   *slice;\n\t\tint32\t\tE1;\n\t\tint32\t\ti;\n\t\tchar\t   *p;\n\t\tchar\t   *s;\n\t\ttext\t   *ret;\n\n\t\t/*\n\t\t * if S is past the end of the string, the tuple toaster will return a\n\t\t * zero-length string to us\n\t\t */\n\t\tS1 = Max(S, 1);\n\n\t\t/*\n\t\t * We need to start at position zero because there is no way to know\n\t\t * in advance which byte offset corresponds to the supplied start\n\t\t * position.\n\t\t */\n\t\tslice_start = 0;\n\n\t\tif (length_not_specified)\t/* special case - get length to end of\n\t\t\t\t\t\t\t\t\t * string */\n\t\t\tslice_size = L1 = -1;\n\t\telse\n\t\t{\n\t\t\tint\t\t\tE = S + length;\n\n\t\t\t/*\n\t\t\t * A negative value for L is the only way for the end position to\n\t\t\t * be before the start. SQL99 says to throw an error.\n\t\t\t */\n\t\t\tif (E < S)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SUBSTRING_ERROR),\n\t\t\t\t\t\t errmsg(\"negative substring length not allowed\")));\n\n\t\t\t/*\n\t\t\t * A zero or negative value for the end position can happen if the\n\t\t\t * start was negative or one. SQL99 says to return a zero-length\n\t\t\t * string.\n\t\t\t */\n\t\t\tif (E < 1)\n\t\t\t\treturn cstring_to_text(\"\");\n\n\t\t\t/*\n\t\t\t * if E is past the end of the string, the tuple toaster will\n\t\t\t * truncate the length for us\n\t\t\t */\n\t\t\tL1 = E - S1;\n\n\t\t\t/*\n\t\t\t * Total slice size in bytes can't be any longer than the start\n\t\t\t * position plus substring length times the encoding max length.\n\t\t\t */\n\t\t\tslice_size = (S1 + L1) * eml;\n\t\t}\n\n\t\t/*\n\t\t * If we're working with an untoasted source, no need to do an extra\n\t\t * copying step.\n\t\t */\n\t\tif (VARATT_IS_COMPRESSED(DatumGetPointer(str)) ||\n\t\t\tVARATT_IS_EXTERNAL(DatumGetPointer(str)))\n\t\t\tslice = DatumGetTextPSlice(str, slice_start, slice_size);\n\t\telse\n\t\t\tslice = (text *) DatumGetPointer(str);\n\n\t\t/* see if we got back an empty string */\n\t\tif (VARSIZE_ANY_EXHDR(slice) == 0)\n\t\t{\n\t\t\tif (slice != (text *) DatumGetPointer(str))\n\t\t\t\tpfree(slice);\n\t\t\treturn cstring_to_text(\"\");\n\t\t}\n\n\t\t/* Now we can get the actual length of the slice in MB characters */\n\t\tslice_strlen = pg_mbstrlen_with_len(VARDATA_ANY(slice),\n\t\t\t\t\t\t\t\t\t\t\tVARSIZE_ANY_EXHDR(slice));\n\n\t\t/*\n\t\t * Check that the start position wasn't > slice_strlen. If so, SQL99\n\t\t * says to return a zero-length string.\n\t\t */\n\t\tif (S1 > slice_strlen)\n\t\t{\n\t\t\tif (slice != (text *) DatumGetPointer(str))\n\t\t\t\tpfree(slice);\n\t\t\treturn cstring_to_text(\"\");\n\t\t}\n\n\t\t/*\n\t\t * Adjust L1 and E1 now that we know the slice string length. Again\n\t\t * remember that S1 is one based, and slice_start is zero based.\n\t\t */\n\t\tif (L1 > -1)\n\t\t\tE1 = Min(S1 + L1, slice_start + 1 + slice_strlen);\n\t\telse\n\t\t\tE1 = slice_start + 1 + slice_strlen;\n\n\t\t/*\n\t\t * Find the start position in the slice; remember S1 is not zero based\n\t\t */\n\t\tp = VARDATA_ANY(slice);\n\t\tfor (i = 0; i < S1 - 1; i++)\n\t\t\tp += pg_mblen(p);\n\n\t\t/* hang onto a pointer to our start position */\n\t\ts = p;\n\n\t\t/*\n\t\t * Count the actual bytes used by the substring of the requested\n\t\t * length.\n\t\t */\n\t\tfor (i = S1; i < E1; i++)\n\t\t\tp += pg_mblen(p);\n\n\t\tret = (text *) palloc(VARHDRSZ + (p - s));\n\t\tSET_VARSIZE(ret, VARHDRSZ + (p - s));\n\t\tmemcpy(VARDATA(ret), s, (p - s));\n\n\t\tif (slice != (text *) DatumGetPointer(str))\n\t\t\tpfree(slice);\n\n\t\treturn ret;\n\t}\n\telse\n\t\telog(ERROR, \"invalid backend encoding: encoding max length < 1\");\n\n\t/* not reached: suppress compiler warning */\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "inputstring"
          ],
          "line": 4269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cstring_to_text",
          "args": [
            "\"\""
          ],
          "line": 4264
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "148-152",
          "snippet": "text *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "inputstring"
          ],
          "line": 4259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text_position_cleanup",
          "args": [
            "&state"
          ],
          "line": 4252
        },
        "resolved": true,
        "details": {
          "function_name": "text_position_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "1363-1371",
          "snippet": "static void\ntext_position_cleanup(TextPositionState *state)\n{\n\tif (state->use_wchar)\n\t{\n\t\tpfree(state->wstr1);\n\t\tpfree(state->wstr2);\n\t}\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void text_position_setup(text *t1, text *t2, TextPositionState *state);",
            "static int\ttext_position_next(int start_pos, TextPositionState *state);",
            "static void text_position_cleanup(TextPositionState *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void text_position_setup(text *t1, text *t2, TextPositionState *state);\nstatic int\ttext_position_next(int start_pos, TextPositionState *state);\nstatic void text_position_cleanup(TextPositionState *state);\n\nstatic void\ntext_position_cleanup(TextPositionState *state)\n{\n\tif (state->use_wchar)\n\t{\n\t\tpfree(state->wstr1);\n\t\tpfree(state->wstr2);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "text_position_next",
          "args": [
            "start_posn",
            "&state"
          ],
          "line": 4249
        },
        "resolved": true,
        "details": {
          "function_name": "text_position_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "1229-1361",
          "snippet": "static int\ntext_position_next(int start_pos, TextPositionState *state)\n{\n\tint\t\t\thaystack_len = state->len1;\n\tint\t\t\tneedle_len = state->len2;\n\tint\t\t\tskiptablemask = state->skiptablemask;\n\n\tAssert(start_pos > 0);\t\t/* else caller error */\n\n\tif (needle_len <= 0)\n\t\treturn start_pos;\t\t/* result for empty pattern */\n\n\tstart_pos--;\t\t\t\t/* adjust for zero based arrays */\n\n\t/* Done if the needle can't possibly fit */\n\tif (haystack_len < start_pos + needle_len)\n\t\treturn 0;\n\n\tif (!state->use_wchar)\n\t{\n\t\t/* simple case - single byte encoding */\n\t\tconst char *haystack = state->str1;\n\t\tconst char *needle = state->str2;\n\t\tconst char *haystack_end = &haystack[haystack_len];\n\t\tconst char *hptr;\n\n\t\tif (needle_len == 1)\n\t\t{\n\t\t\t/* No point in using B-M-H for a one-character needle */\n\t\t\tchar\t\tnchar = *needle;\n\n\t\t\thptr = &haystack[start_pos];\n\t\t\twhile (hptr < haystack_end)\n\t\t\t{\n\t\t\t\tif (*hptr == nchar)\n\t\t\t\t\treturn hptr - haystack + 1;\n\t\t\t\thptr++;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconst char *needle_last = &needle[needle_len - 1];\n\n\t\t\t/* Start at startpos plus the length of the needle */\n\t\t\thptr = &haystack[start_pos + needle_len - 1];\n\t\t\twhile (hptr < haystack_end)\n\t\t\t{\n\t\t\t\t/* Match the needle scanning *backward* */\n\t\t\t\tconst char *nptr;\n\t\t\t\tconst char *p;\n\n\t\t\t\tnptr = needle_last;\n\t\t\t\tp = hptr;\n\t\t\t\twhile (*nptr == *p)\n\t\t\t\t{\n\t\t\t\t\t/* Matched it all?\tIf so, return 1-based position */\n\t\t\t\t\tif (nptr == needle)\n\t\t\t\t\t\treturn p - haystack + 1;\n\t\t\t\t\tnptr--, p--;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * No match, so use the haystack char at hptr to decide how\n\t\t\t\t * far to advance.  If the needle had any occurrence of that\n\t\t\t\t * character (or more precisely, one sharing the same\n\t\t\t\t * skiptable entry) before its last character, then we advance\n\t\t\t\t * far enough to align the last such needle character with\n\t\t\t\t * that haystack position.  Otherwise we can advance by the\n\t\t\t\t * whole needle length.\n\t\t\t\t */\n\t\t\t\thptr += state->skiptable[(unsigned char) *hptr & skiptablemask];\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* The multibyte char version. This works exactly the same way. */\n\t\tconst pg_wchar *haystack = state->wstr1;\n\t\tconst pg_wchar *needle = state->wstr2;\n\t\tconst pg_wchar *haystack_end = &haystack[haystack_len];\n\t\tconst pg_wchar *hptr;\n\n\t\tif (needle_len == 1)\n\t\t{\n\t\t\t/* No point in using B-M-H for a one-character needle */\n\t\t\tpg_wchar\tnchar = *needle;\n\n\t\t\thptr = &haystack[start_pos];\n\t\t\twhile (hptr < haystack_end)\n\t\t\t{\n\t\t\t\tif (*hptr == nchar)\n\t\t\t\t\treturn hptr - haystack + 1;\n\t\t\t\thptr++;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconst pg_wchar *needle_last = &needle[needle_len - 1];\n\n\t\t\t/* Start at startpos plus the length of the needle */\n\t\t\thptr = &haystack[start_pos + needle_len - 1];\n\t\t\twhile (hptr < haystack_end)\n\t\t\t{\n\t\t\t\t/* Match the needle scanning *backward* */\n\t\t\t\tconst pg_wchar *nptr;\n\t\t\t\tconst pg_wchar *p;\n\n\t\t\t\tnptr = needle_last;\n\t\t\t\tp = hptr;\n\t\t\t\twhile (*nptr == *p)\n\t\t\t\t{\n\t\t\t\t\t/* Matched it all?\tIf so, return 1-based position */\n\t\t\t\t\tif (nptr == needle)\n\t\t\t\t\t\treturn p - haystack + 1;\n\t\t\t\t\tnptr--, p--;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * No match, so use the haystack char at hptr to decide how\n\t\t\t\t * far to advance.  If the needle had any occurrence of that\n\t\t\t\t * character (or more precisely, one sharing the same\n\t\t\t\t * skiptable entry) before its last character, then we advance\n\t\t\t\t * far enough to align the last such needle character with\n\t\t\t\t * that haystack position.  Otherwise we can advance by the\n\t\t\t\t * whole needle length.\n\t\t\t\t */\n\t\t\t\thptr += state->skiptable[*hptr & skiptablemask];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\t\t\t\t\t/* not found */\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void text_position_setup(text *t1, text *t2, TextPositionState *state);",
            "static int\ttext_position_next(int start_pos, TextPositionState *state);",
            "static void text_position_cleanup(TextPositionState *state);",
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void text_position_setup(text *t1, text *t2, TextPositionState *state);\nstatic int\ttext_position_next(int start_pos, TextPositionState *state);\nstatic void text_position_cleanup(TextPositionState *state);\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nstatic int\ntext_position_next(int start_pos, TextPositionState *state)\n{\n\tint\t\t\thaystack_len = state->len1;\n\tint\t\t\tneedle_len = state->len2;\n\tint\t\t\tskiptablemask = state->skiptablemask;\n\n\tAssert(start_pos > 0);\t\t/* else caller error */\n\n\tif (needle_len <= 0)\n\t\treturn start_pos;\t\t/* result for empty pattern */\n\n\tstart_pos--;\t\t\t\t/* adjust for zero based arrays */\n\n\t/* Done if the needle can't possibly fit */\n\tif (haystack_len < start_pos + needle_len)\n\t\treturn 0;\n\n\tif (!state->use_wchar)\n\t{\n\t\t/* simple case - single byte encoding */\n\t\tconst char *haystack = state->str1;\n\t\tconst char *needle = state->str2;\n\t\tconst char *haystack_end = &haystack[haystack_len];\n\t\tconst char *hptr;\n\n\t\tif (needle_len == 1)\n\t\t{\n\t\t\t/* No point in using B-M-H for a one-character needle */\n\t\t\tchar\t\tnchar = *needle;\n\n\t\t\thptr = &haystack[start_pos];\n\t\t\twhile (hptr < haystack_end)\n\t\t\t{\n\t\t\t\tif (*hptr == nchar)\n\t\t\t\t\treturn hptr - haystack + 1;\n\t\t\t\thptr++;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconst char *needle_last = &needle[needle_len - 1];\n\n\t\t\t/* Start at startpos plus the length of the needle */\n\t\t\thptr = &haystack[start_pos + needle_len - 1];\n\t\t\twhile (hptr < haystack_end)\n\t\t\t{\n\t\t\t\t/* Match the needle scanning *backward* */\n\t\t\t\tconst char *nptr;\n\t\t\t\tconst char *p;\n\n\t\t\t\tnptr = needle_last;\n\t\t\t\tp = hptr;\n\t\t\t\twhile (*nptr == *p)\n\t\t\t\t{\n\t\t\t\t\t/* Matched it all?\tIf so, return 1-based position */\n\t\t\t\t\tif (nptr == needle)\n\t\t\t\t\t\treturn p - haystack + 1;\n\t\t\t\t\tnptr--, p--;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * No match, so use the haystack char at hptr to decide how\n\t\t\t\t * far to advance.  If the needle had any occurrence of that\n\t\t\t\t * character (or more precisely, one sharing the same\n\t\t\t\t * skiptable entry) before its last character, then we advance\n\t\t\t\t * far enough to align the last such needle character with\n\t\t\t\t * that haystack position.  Otherwise we can advance by the\n\t\t\t\t * whole needle length.\n\t\t\t\t */\n\t\t\t\thptr += state->skiptable[(unsigned char) *hptr & skiptablemask];\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* The multibyte char version. This works exactly the same way. */\n\t\tconst pg_wchar *haystack = state->wstr1;\n\t\tconst pg_wchar *needle = state->wstr2;\n\t\tconst pg_wchar *haystack_end = &haystack[haystack_len];\n\t\tconst pg_wchar *hptr;\n\n\t\tif (needle_len == 1)\n\t\t{\n\t\t\t/* No point in using B-M-H for a one-character needle */\n\t\t\tpg_wchar\tnchar = *needle;\n\n\t\t\thptr = &haystack[start_pos];\n\t\t\twhile (hptr < haystack_end)\n\t\t\t{\n\t\t\t\tif (*hptr == nchar)\n\t\t\t\t\treturn hptr - haystack + 1;\n\t\t\t\thptr++;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconst pg_wchar *needle_last = &needle[needle_len - 1];\n\n\t\t\t/* Start at startpos plus the length of the needle */\n\t\t\thptr = &haystack[start_pos + needle_len - 1];\n\t\t\twhile (hptr < haystack_end)\n\t\t\t{\n\t\t\t\t/* Match the needle scanning *backward* */\n\t\t\t\tconst pg_wchar *nptr;\n\t\t\t\tconst pg_wchar *p;\n\n\t\t\t\tnptr = needle_last;\n\t\t\t\tp = hptr;\n\t\t\t\twhile (*nptr == *p)\n\t\t\t\t{\n\t\t\t\t\t/* Matched it all?\tIf so, return 1-based position */\n\t\t\t\t\tif (nptr == needle)\n\t\t\t\t\t\treturn p - haystack + 1;\n\t\t\t\t\tnptr--, p--;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * No match, so use the haystack char at hptr to decide how\n\t\t\t\t * far to advance.  If the needle had any occurrence of that\n\t\t\t\t * character (or more precisely, one sharing the same\n\t\t\t\t * skiptable entry) before its last character, then we advance\n\t\t\t\t * far enough to align the last such needle character with\n\t\t\t\t * that haystack position.  Otherwise we can advance by the\n\t\t\t\t * whole needle length.\n\t\t\t\t */\n\t\t\t\thptr += state->skiptable[*hptr & skiptablemask];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\t\t\t\t\t/* not found */\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "cstring_to_text(\"\")"
          ],
          "line": 4242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "inputstring"
          ],
          "line": 4240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "cstring_to_text(\"\")"
          ],
          "line": 4227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "inputstring"
          ],
          "line": 4225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "cstring_to_text(\"\")"
          ],
          "line": 4216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text_position_setup",
          "args": [
            "inputstring",
            "fldsep",
            "&state"
          ],
          "line": 4203
        },
        "resolved": true,
        "details": {
          "function_name": "text_position_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "1117-1227",
          "snippet": "static void\ntext_position_setup(text *t1, text *t2, TextPositionState *state)\n{\n\tint\t\t\tlen1 = VARSIZE_ANY_EXHDR(t1);\n\tint\t\t\tlen2 = VARSIZE_ANY_EXHDR(t2);\n\n\tif (pg_database_encoding_max_length() == 1)\n\t{\n\t\t/* simple case - single byte encoding */\n\t\tstate->use_wchar = false;\n\t\tstate->str1 = VARDATA_ANY(t1);\n\t\tstate->str2 = VARDATA_ANY(t2);\n\t\tstate->len1 = len1;\n\t\tstate->len2 = len2;\n\t}\n\telse\n\t{\n\t\t/* not as simple - multibyte encoding */\n\t\tpg_wchar   *p1,\n\t\t\t\t   *p2;\n\n\t\tp1 = (pg_wchar *) palloc((len1 + 1) * sizeof(pg_wchar));\n\t\tlen1 = pg_mb2wchar_with_len(VARDATA_ANY(t1), p1, len1);\n\t\tp2 = (pg_wchar *) palloc((len2 + 1) * sizeof(pg_wchar));\n\t\tlen2 = pg_mb2wchar_with_len(VARDATA_ANY(t2), p2, len2);\n\n\t\tstate->use_wchar = true;\n\t\tstate->wstr1 = p1;\n\t\tstate->wstr2 = p2;\n\t\tstate->len1 = len1;\n\t\tstate->len2 = len2;\n\t}\n\n\t/*\n\t * Prepare the skip table for Boyer-Moore-Horspool searching.  In these\n\t * notes we use the terminology that the \"haystack\" is the string to be\n\t * searched (t1) and the \"needle\" is the pattern being sought (t2).\n\t *\n\t * If the needle is empty or bigger than the haystack then there is no\n\t * point in wasting cycles initializing the table.  We also choose not to\n\t * use B-M-H for needles of length 1, since the skip table can't possibly\n\t * save anything in that case.\n\t */\n\tif (len1 >= len2 && len2 > 1)\n\t{\n\t\tint\t\t\tsearchlength = len1 - len2;\n\t\tint\t\t\tskiptablemask;\n\t\tint\t\t\tlast;\n\t\tint\t\t\ti;\n\n\t\t/*\n\t\t * First we must determine how much of the skip table to use.  The\n\t\t * declaration of TextPositionState allows up to 256 elements, but for\n\t\t * short search problems we don't really want to have to initialize so\n\t\t * many elements --- it would take too long in comparison to the\n\t\t * actual search time.  So we choose a useful skip table size based on\n\t\t * the haystack length minus the needle length.  The closer the needle\n\t\t * length is to the haystack length the less useful skipping becomes.\n\t\t *\n\t\t * Note: since we use bit-masking to select table elements, the skip\n\t\t * table size MUST be a power of 2, and so the mask must be 2^N-1.\n\t\t */\n\t\tif (searchlength < 16)\n\t\t\tskiptablemask = 3;\n\t\telse if (searchlength < 64)\n\t\t\tskiptablemask = 7;\n\t\telse if (searchlength < 128)\n\t\t\tskiptablemask = 15;\n\t\telse if (searchlength < 512)\n\t\t\tskiptablemask = 31;\n\t\telse if (searchlength < 2048)\n\t\t\tskiptablemask = 63;\n\t\telse if (searchlength < 4096)\n\t\t\tskiptablemask = 127;\n\t\telse\n\t\t\tskiptablemask = 255;\n\t\tstate->skiptablemask = skiptablemask;\n\n\t\t/*\n\t\t * Initialize the skip table.  We set all elements to the needle\n\t\t * length, since this is the correct skip distance for any character\n\t\t * not found in the needle.\n\t\t */\n\t\tfor (i = 0; i <= skiptablemask; i++)\n\t\t\tstate->skiptable[i] = len2;\n\n\t\t/*\n\t\t * Now examine the needle.  For each character except the last one,\n\t\t * set the corresponding table element to the appropriate skip\n\t\t * distance.  Note that when two characters share the same skip table\n\t\t * entry, the one later in the needle must determine the skip\n\t\t * distance.\n\t\t */\n\t\tlast = len2 - 1;\n\n\t\tif (!state->use_wchar)\n\t\t{\n\t\t\tconst char *str2 = state->str2;\n\n\t\t\tfor (i = 0; i < last; i++)\n\t\t\t\tstate->skiptable[(unsigned char) str2[i] & skiptablemask] = last - i;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconst pg_wchar *wstr2 = state->wstr2;\n\n\t\t\tfor (i = 0; i < last; i++)\n\t\t\t\tstate->skiptable[wstr2[i] & skiptablemask] = last - i;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static text *text_catenate(text *t1, text *t2);",
            "static int\ttext_position(text *t1, text *t2);",
            "static void text_position_setup(text *t1, text *t2, TextPositionState *state);",
            "static int\ttext_position_next(int start_pos, TextPositionState *state);",
            "static void text_position_cleanup(TextPositionState *state);",
            "static bytea *bytea_catenate(bytea *t1, bytea *t2);",
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic text *text_catenate(text *t1, text *t2);\nstatic int\ttext_position(text *t1, text *t2);\nstatic void text_position_setup(text *t1, text *t2, TextPositionState *state);\nstatic int\ttext_position_next(int start_pos, TextPositionState *state);\nstatic void text_position_cleanup(TextPositionState *state);\nstatic bytea *bytea_catenate(bytea *t1, bytea *t2);\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nstatic void\ntext_position_setup(text *t1, text *t2, TextPositionState *state)\n{\n\tint\t\t\tlen1 = VARSIZE_ANY_EXHDR(t1);\n\tint\t\t\tlen2 = VARSIZE_ANY_EXHDR(t2);\n\n\tif (pg_database_encoding_max_length() == 1)\n\t{\n\t\t/* simple case - single byte encoding */\n\t\tstate->use_wchar = false;\n\t\tstate->str1 = VARDATA_ANY(t1);\n\t\tstate->str2 = VARDATA_ANY(t2);\n\t\tstate->len1 = len1;\n\t\tstate->len2 = len2;\n\t}\n\telse\n\t{\n\t\t/* not as simple - multibyte encoding */\n\t\tpg_wchar   *p1,\n\t\t\t\t   *p2;\n\n\t\tp1 = (pg_wchar *) palloc((len1 + 1) * sizeof(pg_wchar));\n\t\tlen1 = pg_mb2wchar_with_len(VARDATA_ANY(t1), p1, len1);\n\t\tp2 = (pg_wchar *) palloc((len2 + 1) * sizeof(pg_wchar));\n\t\tlen2 = pg_mb2wchar_with_len(VARDATA_ANY(t2), p2, len2);\n\n\t\tstate->use_wchar = true;\n\t\tstate->wstr1 = p1;\n\t\tstate->wstr2 = p2;\n\t\tstate->len1 = len1;\n\t\tstate->len2 = len2;\n\t}\n\n\t/*\n\t * Prepare the skip table for Boyer-Moore-Horspool searching.  In these\n\t * notes we use the terminology that the \"haystack\" is the string to be\n\t * searched (t1) and the \"needle\" is the pattern being sought (t2).\n\t *\n\t * If the needle is empty or bigger than the haystack then there is no\n\t * point in wasting cycles initializing the table.  We also choose not to\n\t * use B-M-H for needles of length 1, since the skip table can't possibly\n\t * save anything in that case.\n\t */\n\tif (len1 >= len2 && len2 > 1)\n\t{\n\t\tint\t\t\tsearchlength = len1 - len2;\n\t\tint\t\t\tskiptablemask;\n\t\tint\t\t\tlast;\n\t\tint\t\t\ti;\n\n\t\t/*\n\t\t * First we must determine how much of the skip table to use.  The\n\t\t * declaration of TextPositionState allows up to 256 elements, but for\n\t\t * short search problems we don't really want to have to initialize so\n\t\t * many elements --- it would take too long in comparison to the\n\t\t * actual search time.  So we choose a useful skip table size based on\n\t\t * the haystack length minus the needle length.  The closer the needle\n\t\t * length is to the haystack length the less useful skipping becomes.\n\t\t *\n\t\t * Note: since we use bit-masking to select table elements, the skip\n\t\t * table size MUST be a power of 2, and so the mask must be 2^N-1.\n\t\t */\n\t\tif (searchlength < 16)\n\t\t\tskiptablemask = 3;\n\t\telse if (searchlength < 64)\n\t\t\tskiptablemask = 7;\n\t\telse if (searchlength < 128)\n\t\t\tskiptablemask = 15;\n\t\telse if (searchlength < 512)\n\t\t\tskiptablemask = 31;\n\t\telse if (searchlength < 2048)\n\t\t\tskiptablemask = 63;\n\t\telse if (searchlength < 4096)\n\t\t\tskiptablemask = 127;\n\t\telse\n\t\t\tskiptablemask = 255;\n\t\tstate->skiptablemask = skiptablemask;\n\n\t\t/*\n\t\t * Initialize the skip table.  We set all elements to the needle\n\t\t * length, since this is the correct skip distance for any character\n\t\t * not found in the needle.\n\t\t */\n\t\tfor (i = 0; i <= skiptablemask; i++)\n\t\t\tstate->skiptable[i] = len2;\n\n\t\t/*\n\t\t * Now examine the needle.  For each character except the last one,\n\t\t * set the corresponding table element to the appropriate skip\n\t\t * distance.  Note that when two characters share the same skip table\n\t\t * entry, the one later in the needle must determine the skip\n\t\t * distance.\n\t\t */\n\t\tlast = len2 - 1;\n\n\t\tif (!state->use_wchar)\n\t\t{\n\t\t\tconst char *str2 = state->str2;\n\n\t\t\tfor (i = 0; i < last; i++)\n\t\t\t\tstate->skiptable[(unsigned char) str2[i] & skiptablemask] = last - i;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconst pg_wchar *wstr2 = state->wstr2;\n\n\t\t\tfor (i = 0; i < last; i++)\n\t\t\t\tstate->skiptable[wstr2[i] & skiptablemask] = last - i;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"field position must be greater than zero\"))"
          ],
          "line": 4199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"field position must be greater than zero\""
          ],
          "line": 4201
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 4200
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "2"
          ],
          "line": 4189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 4188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 4187
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void text_position_setup(text *t1, text *t2, TextPositionState *state);\nstatic int\ttext_position_next(int start_pos, TextPositionState *state);\nstatic void text_position_cleanup(TextPositionState *state);\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\n\nDatum\nsplit_text(PG_FUNCTION_ARGS)\n{\n\ttext\t   *inputstring = PG_GETARG_TEXT_PP(0);\n\ttext\t   *fldsep = PG_GETARG_TEXT_PP(1);\n\tint\t\t\tfldnum = PG_GETARG_INT32(2);\n\tint\t\t\tinputstring_len;\n\tint\t\t\tfldsep_len;\n\tTextPositionState state;\n\tint\t\t\tstart_posn;\n\tint\t\t\tend_posn;\n\ttext\t   *result_text;\n\n\t/* field number is 1 based */\n\tif (fldnum < 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"field position must be greater than zero\")));\n\n\ttext_position_setup(inputstring, fldsep, &state);\n\n\t/*\n\t * Note: we check the converted string length, not the original, because\n\t * they could be different if the input contained invalid encoding.\n\t */\n\tinputstring_len = state.len1;\n\tfldsep_len = state.len2;\n\n\t/* return empty string for empty input string */\n\tif (inputstring_len < 1)\n\t{\n\t\ttext_position_cleanup(&state);\n\t\tPG_RETURN_TEXT_P(cstring_to_text(\"\"));\n\t}\n\n\t/* empty field separator */\n\tif (fldsep_len < 1)\n\t{\n\t\ttext_position_cleanup(&state);\n\t\t/* if first field, return input string, else empty string */\n\t\tif (fldnum == 1)\n\t\t\tPG_RETURN_TEXT_P(inputstring);\n\t\telse\n\t\t\tPG_RETURN_TEXT_P(cstring_to_text(\"\"));\n\t}\n\n\t/* identify bounds of first field */\n\tstart_posn = 1;\n\tend_posn = text_position_next(1, &state);\n\n\t/* special case if fldsep not found at all */\n\tif (end_posn == 0)\n\t{\n\t\ttext_position_cleanup(&state);\n\t\t/* if field 1 requested, return input string, else empty string */\n\t\tif (fldnum == 1)\n\t\t\tPG_RETURN_TEXT_P(inputstring);\n\t\telse\n\t\t\tPG_RETURN_TEXT_P(cstring_to_text(\"\"));\n\t}\n\n\twhile (end_posn > 0 && --fldnum > 0)\n\t{\n\t\t/* identify bounds of next field */\n\t\tstart_posn = end_posn + fldsep_len;\n\t\tend_posn = text_position_next(start_posn, &state);\n\t}\n\n\ttext_position_cleanup(&state);\n\n\tif (fldnum > 0)\n\t{\n\t\t/* N'th field separator not found */\n\t\t/* if last field requested, return it, else empty string */\n\t\tif (fldnum == 1)\n\t\t\tresult_text = text_substring(PointerGetDatum(inputstring),\n\t\t\t\t\t\t\t\t\t\t start_posn,\n\t\t\t\t\t\t\t\t\t\t -1,\n\t\t\t\t\t\t\t\t\t\t true);\n\t\telse\n\t\t\tresult_text = cstring_to_text(\"\");\n\t}\n\telse\n\t{\n\t\t/* non-last field requested */\n\t\tresult_text = text_substring(PointerGetDatum(inputstring),\n\t\t\t\t\t\t\t\t\t start_posn,\n\t\t\t\t\t\t\t\t\t end_posn - start_posn,\n\t\t\t\t\t\t\t\t\t false);\n\t}\n\n\tPG_RETURN_TEXT_P(result_text);\n}"
  },
  {
    "function_name": "replace_text_regexp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "4049-4176",
    "snippet": "text *\nreplace_text_regexp(text *src_text, void *regexp,\n\t\t\t\t\ttext *replace_text, bool glob)\n{\n\ttext\t   *ret_text;\n\tregex_t    *re = (regex_t *) regexp;\n\tint\t\t\tsrc_text_len = VARSIZE_ANY_EXHDR(src_text);\n\tStringInfoData buf;\n\tregmatch_t\tpmatch[REGEXP_REPLACE_BACKREF_CNT];\n\tpg_wchar   *data;\n\tsize_t\t\tdata_len;\n\tint\t\t\tsearch_start;\n\tint\t\t\tdata_pos;\n\tchar\t   *start_ptr;\n\tbool\t\thave_escape;\n\n\tinitStringInfo(&buf);\n\n\t/* Convert data string to wide characters. */\n\tdata = (pg_wchar *) palloc((src_text_len + 1) * sizeof(pg_wchar));\n\tdata_len = pg_mb2wchar_with_len(VARDATA_ANY(src_text), data, src_text_len);\n\n\t/* Check whether replace_text has escape char. */\n\thave_escape = check_replace_text_has_escape_char(replace_text);\n\n\t/* start_ptr points to the data_pos'th character of src_text */\n\tstart_ptr = (char *) VARDATA_ANY(src_text);\n\tdata_pos = 0;\n\n\tsearch_start = 0;\n\twhile (search_start <= data_len)\n\t{\n\t\tint\t\t\tregexec_result;\n\n\t\tCHECK_FOR_INTERRUPTS();\n\n\t\tregexec_result = pg_regexec(re,\n\t\t\t\t\t\t\t\t\tdata,\n\t\t\t\t\t\t\t\t\tdata_len,\n\t\t\t\t\t\t\t\t\tsearch_start,\n\t\t\t\t\t\t\t\t\tNULL,\t/* no details */\n\t\t\t\t\t\t\t\t\tREGEXP_REPLACE_BACKREF_CNT,\n\t\t\t\t\t\t\t\t\tpmatch,\n\t\t\t\t\t\t\t\t\t0);\n\n\t\tif (regexec_result == REG_NOMATCH)\n\t\t\tbreak;\n\n\t\tif (regexec_result != REG_OKAY)\n\t\t{\n\t\t\tchar\t\terrMsg[100];\n\n\t\t\tCHECK_FOR_INTERRUPTS();\n\t\t\tpg_regerror(regexec_result, re, errMsg, sizeof(errMsg));\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_REGULAR_EXPRESSION),\n\t\t\t\t\t errmsg(\"regular expression failed: %s\", errMsg)));\n\t\t}\n\n\t\t/*\n\t\t * Copy the text to the left of the match position.  Note we are given\n\t\t * character not byte indexes.\n\t\t */\n\t\tif (pmatch[0].rm_so - data_pos > 0)\n\t\t{\n\t\t\tint\t\t\tchunk_len;\n\n\t\t\tchunk_len = charlen_to_bytelen(start_ptr,\n\t\t\t\t\t\t\t\t\t\t   pmatch[0].rm_so - data_pos);\n\t\t\tappendBinaryStringInfo(&buf, start_ptr, chunk_len);\n\n\t\t\t/*\n\t\t\t * Advance start_ptr over that text, to avoid multiple rescans of\n\t\t\t * it if the replace_text contains multiple back-references.\n\t\t\t */\n\t\t\tstart_ptr += chunk_len;\n\t\t\tdata_pos = pmatch[0].rm_so;\n\t\t}\n\n\t\t/*\n\t\t * Copy the replace_text. Process back references when the\n\t\t * replace_text has escape characters.\n\t\t */\n\t\tif (have_escape)\n\t\t\tappendStringInfoRegexpSubstr(&buf, replace_text, pmatch,\n\t\t\t\t\t\t\t\t\t\t start_ptr, data_pos);\n\t\telse\n\t\t\tappendStringInfoText(&buf, replace_text);\n\n\t\t/* Advance start_ptr and data_pos over the matched text. */\n\t\tstart_ptr += charlen_to_bytelen(start_ptr,\n\t\t\t\t\t\t\t\t\t\tpmatch[0].rm_eo - data_pos);\n\t\tdata_pos = pmatch[0].rm_eo;\n\n\t\t/*\n\t\t * When global option is off, replace the first instance only.\n\t\t */\n\t\tif (!glob)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Advance search position.  Normally we start the next search at the\n\t\t * end of the previous match; but if the match was of zero length, we\n\t\t * have to advance by one character, or we'd just find the same match\n\t\t * again.\n\t\t */\n\t\tsearch_start = data_pos;\n\t\tif (pmatch[0].rm_so == pmatch[0].rm_eo)\n\t\t\tsearch_start++;\n\t}\n\n\t/*\n\t * Copy the text to the right of the last match.\n\t */\n\tif (data_pos < data_len)\n\t{\n\t\tint\t\t\tchunk_len;\n\n\t\tchunk_len = ((char *) src_text + VARSIZE_ANY(src_text)) - start_ptr;\n\t\tappendBinaryStringInfo(&buf, start_ptr, chunk_len);\n\t}\n\n\tret_text = cstring_to_text_with_len(buf.data, buf.len);\n\tpfree(buf.data);\n\tpfree(data);\n\n\treturn ret_text;\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define REGEXP_REPLACE_BACKREF_CNT\t\t10"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "data"
          ],
          "line": 4173
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cstring_to_text_with_len",
          "args": [
            "buf.data",
            "buf.len"
          ],
          "line": 4171
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "160-169",
          "snippet": "text *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendBinaryStringInfo",
          "args": [
            "&buf",
            "start_ptr",
            "chunk_len"
          ],
          "line": 4168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY",
          "args": [
            "src_text"
          ],
          "line": 4167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "charlen_to_bytelen",
          "args": [
            "start_ptr",
            "pmatch[0].rm_eo - data_pos"
          ],
          "line": 4139
        },
        "resolved": true,
        "details": {
          "function_name": "charlen_to_bytelen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "734-751",
          "snippet": "static int\ncharlen_to_bytelen(const char *p, int n)\n{\n\tif (pg_database_encoding_max_length() == 1)\n\t{\n\t\t/* Optimization for single-byte encodings */\n\t\treturn n;\n\t}\n\telse\n\t{\n\t\tconst char *s;\n\n\t\tfor (s = p; n > 0; n--)\n\t\t\ts += pg_mblen(s);\n\n\t\treturn s - p;\n\t}\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ncharlen_to_bytelen(const char *p, int n)\n{\n\tif (pg_database_encoding_max_length() == 1)\n\t{\n\t\t/* Optimization for single-byte encodings */\n\t\treturn n;\n\t}\n\telse\n\t{\n\t\tconst char *s;\n\n\t\tfor (s = p; n > 0; n--)\n\t\t\ts += pg_mblen(s);\n\n\t\treturn s - p;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoText",
          "args": [
            "&buf",
            "replace_text"
          ],
          "line": 4136
        },
        "resolved": true,
        "details": {
          "function_name": "appendStringInfoText",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "3814-3818",
          "snippet": "static void\nappendStringInfoText(StringInfo str, const text *t)\n{\n\tappendBinaryStringInfo(str, VARDATA_ANY(t), VARSIZE_ANY_EXHDR(t));\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int32 text_length(Datum str);",
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int32 text_length(Datum str);\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nstatic void\nappendStringInfoText(StringInfo str, const text *t)\n{\n\tappendBinaryStringInfo(str, VARDATA_ANY(t), VARSIZE_ANY_EXHDR(t));\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoRegexpSubstr",
          "args": [
            "&buf",
            "replace_text",
            "pmatch",
            "start_ptr",
            "data_pos"
          ],
          "line": 4133
        },
        "resolved": true,
        "details": {
          "function_name": "appendStringInfoRegexpSubstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "3944-4037",
          "snippet": "static void\nappendStringInfoRegexpSubstr(StringInfo str, text *replace_text,\n\t\t\t\t\t\t\t regmatch_t *pmatch,\n\t\t\t\t\t\t\t char *start_ptr, int data_pos)\n{\n\tconst char *p = VARDATA_ANY(replace_text);\n\tconst char *p_end = p + VARSIZE_ANY_EXHDR(replace_text);\n\tint\t\t\teml = pg_database_encoding_max_length();\n\n\tfor (;;)\n\t{\n\t\tconst char *chunk_start = p;\n\t\tint\t\t\tso;\n\t\tint\t\t\teo;\n\n\t\t/* Find next escape char. */\n\t\tif (eml == 1)\n\t\t{\n\t\t\tfor (; p < p_end && *p != '\\\\'; p++)\n\t\t\t\t /* nothing */ ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (; p < p_end && *p != '\\\\'; p += pg_mblen(p))\n\t\t\t\t /* nothing */ ;\n\t\t}\n\n\t\t/* Copy the text we just scanned over, if any. */\n\t\tif (p > chunk_start)\n\t\t\tappendBinaryStringInfo(str, chunk_start, p - chunk_start);\n\n\t\t/* Done if at end of string, else advance over escape char. */\n\t\tif (p >= p_end)\n\t\t\tbreak;\n\t\tp++;\n\n\t\tif (p >= p_end)\n\t\t{\n\t\t\t/* Escape at very end of input.  Treat same as unexpected char */\n\t\t\tappendStringInfoChar(str, '\\\\');\n\t\t\tbreak;\n\t\t}\n\n\t\tif (*p >= '1' && *p <= '9')\n\t\t{\n\t\t\t/* Use the back reference of regexp. */\n\t\t\tint\t\t\tidx = *p - '0';\n\n\t\t\tso = pmatch[idx].rm_so;\n\t\t\teo = pmatch[idx].rm_eo;\n\t\t\tp++;\n\t\t}\n\t\telse if (*p == '&')\n\t\t{\n\t\t\t/* Use the entire matched string. */\n\t\t\tso = pmatch[0].rm_so;\n\t\t\teo = pmatch[0].rm_eo;\n\t\t\tp++;\n\t\t}\n\t\telse if (*p == '\\\\')\n\t\t{\n\t\t\t/* \\\\ means transfer one \\ to output. */\n\t\t\tappendStringInfoChar(str, '\\\\');\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * If escape char is not followed by any expected char, just treat\n\t\t\t * it as ordinary data to copy.  (XXX would it be better to throw\n\t\t\t * an error?)\n\t\t\t */\n\t\t\tappendStringInfoChar(str, '\\\\');\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (so != -1 && eo != -1)\n\t\t{\n\t\t\t/*\n\t\t\t * Copy the text that is back reference of regexp.  Note so and eo\n\t\t\t * are counted in characters not bytes.\n\t\t\t */\n\t\t\tchar\t   *chunk_start;\n\t\t\tint\t\t\tchunk_len;\n\n\t\t\tAssert(so >= data_pos);\n\t\t\tchunk_start = start_ptr;\n\t\t\tchunk_start += charlen_to_bytelen(chunk_start, so - data_pos);\n\t\t\tchunk_len = charlen_to_bytelen(chunk_start, eo - so);\n\t\t\tappendBinaryStringInfo(str, chunk_start, chunk_len);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int32 text_length(Datum str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int32 text_length(Datum str);\n\nstatic void\nappendStringInfoRegexpSubstr(StringInfo str, text *replace_text,\n\t\t\t\t\t\t\t regmatch_t *pmatch,\n\t\t\t\t\t\t\t char *start_ptr, int data_pos)\n{\n\tconst char *p = VARDATA_ANY(replace_text);\n\tconst char *p_end = p + VARSIZE_ANY_EXHDR(replace_text);\n\tint\t\t\teml = pg_database_encoding_max_length();\n\n\tfor (;;)\n\t{\n\t\tconst char *chunk_start = p;\n\t\tint\t\t\tso;\n\t\tint\t\t\teo;\n\n\t\t/* Find next escape char. */\n\t\tif (eml == 1)\n\t\t{\n\t\t\tfor (; p < p_end && *p != '\\\\'; p++)\n\t\t\t\t /* nothing */ ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (; p < p_end && *p != '\\\\'; p += pg_mblen(p))\n\t\t\t\t /* nothing */ ;\n\t\t}\n\n\t\t/* Copy the text we just scanned over, if any. */\n\t\tif (p > chunk_start)\n\t\t\tappendBinaryStringInfo(str, chunk_start, p - chunk_start);\n\n\t\t/* Done if at end of string, else advance over escape char. */\n\t\tif (p >= p_end)\n\t\t\tbreak;\n\t\tp++;\n\n\t\tif (p >= p_end)\n\t\t{\n\t\t\t/* Escape at very end of input.  Treat same as unexpected char */\n\t\t\tappendStringInfoChar(str, '\\\\');\n\t\t\tbreak;\n\t\t}\n\n\t\tif (*p >= '1' && *p <= '9')\n\t\t{\n\t\t\t/* Use the back reference of regexp. */\n\t\t\tint\t\t\tidx = *p - '0';\n\n\t\t\tso = pmatch[idx].rm_so;\n\t\t\teo = pmatch[idx].rm_eo;\n\t\t\tp++;\n\t\t}\n\t\telse if (*p == '&')\n\t\t{\n\t\t\t/* Use the entire matched string. */\n\t\t\tso = pmatch[0].rm_so;\n\t\t\teo = pmatch[0].rm_eo;\n\t\t\tp++;\n\t\t}\n\t\telse if (*p == '\\\\')\n\t\t{\n\t\t\t/* \\\\ means transfer one \\ to output. */\n\t\t\tappendStringInfoChar(str, '\\\\');\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * If escape char is not followed by any expected char, just treat\n\t\t\t * it as ordinary data to copy.  (XXX would it be better to throw\n\t\t\t * an error?)\n\t\t\t */\n\t\t\tappendStringInfoChar(str, '\\\\');\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (so != -1 && eo != -1)\n\t\t{\n\t\t\t/*\n\t\t\t * Copy the text that is back reference of regexp.  Note so and eo\n\t\t\t * are counted in characters not bytes.\n\t\t\t */\n\t\t\tchar\t   *chunk_start;\n\t\t\tint\t\t\tchunk_len;\n\n\t\t\tAssert(so >= data_pos);\n\t\t\tchunk_start = start_ptr;\n\t\t\tchunk_start += charlen_to_bytelen(chunk_start, so - data_pos);\n\t\t\tchunk_len = charlen_to_bytelen(chunk_start, eo - so);\n\t\t\tappendBinaryStringInfo(str, chunk_start, chunk_len);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendBinaryStringInfo",
          "args": [
            "&buf",
            "start_ptr",
            "chunk_len"
          ],
          "line": 4118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_REGULAR_EXPRESSION),\n\t\t\t\t\t errmsg(\"regular expression failed: %s\", errMsg))"
          ],
          "line": 4103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"regular expression failed: %s\"",
            "errMsg"
          ],
          "line": 4105
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_REGULAR_EXPRESSION"
          ],
          "line": 4104
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_regerror",
          "args": [
            "regexec_result",
            "re",
            "errMsg",
            "sizeof(errMsg)"
          ],
          "line": 4102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_FOR_INTERRUPTS",
          "args": [],
          "line": 4101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_regexec",
          "args": [
            "re",
            "data",
            "data_len",
            "search_start",
            "NULL",
            "/* no details */REGEXP_REPLACE_BACKREF_CNT",
            "pmatch",
            "0"
          ],
          "line": 4085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_FOR_INTERRUPTS",
          "args": [],
          "line": 4083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "src_text"
          ],
          "line": 4075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_replace_text_has_escape_char",
          "args": [
            "replace_text"
          ],
          "line": 4072
        },
        "resolved": true,
        "details": {
          "function_name": "check_replace_text_has_escape_char",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "3911-3935",
          "snippet": "static bool\ncheck_replace_text_has_escape_char(const text *replace_text)\n{\n\tconst char *p = VARDATA_ANY(replace_text);\n\tconst char *p_end = p + VARSIZE_ANY_EXHDR(replace_text);\n\n\tif (pg_database_encoding_max_length() == 1)\n\t{\n\t\tfor (; p < p_end; p++)\n\t\t{\n\t\t\tif (*p == '\\\\')\n\t\t\t\treturn true;\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor (; p < p_end; p += pg_mblen(p))\n\t\t{\n\t\t\tif (*p == '\\\\')\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool\ncheck_replace_text_has_escape_char(const text *replace_text)\n{\n\tconst char *p = VARDATA_ANY(replace_text);\n\tconst char *p_end = p + VARSIZE_ANY_EXHDR(replace_text);\n\n\tif (pg_database_encoding_max_length() == 1)\n\t{\n\t\tfor (; p < p_end; p++)\n\t\t{\n\t\t\tif (*p == '\\\\')\n\t\t\t\treturn true;\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor (; p < p_end; p += pg_mblen(p))\n\t\t{\n\t\t\tif (*p == '\\\\')\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_mb2wchar_with_len",
          "args": [
            "VARDATA_ANY(src_text)",
            "data",
            "src_text_len"
          ],
          "line": 4069
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mb2wchar_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "722-726",
          "snippet": "int\npg_mb2wchar_with_len(const char *from, pg_wchar *to, int len)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mb2wchar_with_len((const unsigned char *) from, to, len);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nint\npg_mb2wchar_with_len(const char *from, pg_wchar *to, int len)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mb2wchar_with_len((const unsigned char *) from, to, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "src_text"
          ],
          "line": 4069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "(src_text_len + 1) * sizeof(pg_wchar)"
          ],
          "line": 4068
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "initStringInfo",
          "args": [
            "&buf"
          ],
          "line": 4065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "src_text"
          ],
          "line": 4055
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define REGEXP_REPLACE_BACKREF_CNT\t\t10\n\ntext *\nreplace_text_regexp(text *src_text, void *regexp,\n\t\t\t\t\ttext *replace_text, bool glob)\n{\n\ttext\t   *ret_text;\n\tregex_t    *re = (regex_t *) regexp;\n\tint\t\t\tsrc_text_len = VARSIZE_ANY_EXHDR(src_text);\n\tStringInfoData buf;\n\tregmatch_t\tpmatch[REGEXP_REPLACE_BACKREF_CNT];\n\tpg_wchar   *data;\n\tsize_t\t\tdata_len;\n\tint\t\t\tsearch_start;\n\tint\t\t\tdata_pos;\n\tchar\t   *start_ptr;\n\tbool\t\thave_escape;\n\n\tinitStringInfo(&buf);\n\n\t/* Convert data string to wide characters. */\n\tdata = (pg_wchar *) palloc((src_text_len + 1) * sizeof(pg_wchar));\n\tdata_len = pg_mb2wchar_with_len(VARDATA_ANY(src_text), data, src_text_len);\n\n\t/* Check whether replace_text has escape char. */\n\thave_escape = check_replace_text_has_escape_char(replace_text);\n\n\t/* start_ptr points to the data_pos'th character of src_text */\n\tstart_ptr = (char *) VARDATA_ANY(src_text);\n\tdata_pos = 0;\n\n\tsearch_start = 0;\n\twhile (search_start <= data_len)\n\t{\n\t\tint\t\t\tregexec_result;\n\n\t\tCHECK_FOR_INTERRUPTS();\n\n\t\tregexec_result = pg_regexec(re,\n\t\t\t\t\t\t\t\t\tdata,\n\t\t\t\t\t\t\t\t\tdata_len,\n\t\t\t\t\t\t\t\t\tsearch_start,\n\t\t\t\t\t\t\t\t\tNULL,\t/* no details */\n\t\t\t\t\t\t\t\t\tREGEXP_REPLACE_BACKREF_CNT,\n\t\t\t\t\t\t\t\t\tpmatch,\n\t\t\t\t\t\t\t\t\t0);\n\n\t\tif (regexec_result == REG_NOMATCH)\n\t\t\tbreak;\n\n\t\tif (regexec_result != REG_OKAY)\n\t\t{\n\t\t\tchar\t\terrMsg[100];\n\n\t\t\tCHECK_FOR_INTERRUPTS();\n\t\t\tpg_regerror(regexec_result, re, errMsg, sizeof(errMsg));\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_REGULAR_EXPRESSION),\n\t\t\t\t\t errmsg(\"regular expression failed: %s\", errMsg)));\n\t\t}\n\n\t\t/*\n\t\t * Copy the text to the left of the match position.  Note we are given\n\t\t * character not byte indexes.\n\t\t */\n\t\tif (pmatch[0].rm_so - data_pos > 0)\n\t\t{\n\t\t\tint\t\t\tchunk_len;\n\n\t\t\tchunk_len = charlen_to_bytelen(start_ptr,\n\t\t\t\t\t\t\t\t\t\t   pmatch[0].rm_so - data_pos);\n\t\t\tappendBinaryStringInfo(&buf, start_ptr, chunk_len);\n\n\t\t\t/*\n\t\t\t * Advance start_ptr over that text, to avoid multiple rescans of\n\t\t\t * it if the replace_text contains multiple back-references.\n\t\t\t */\n\t\t\tstart_ptr += chunk_len;\n\t\t\tdata_pos = pmatch[0].rm_so;\n\t\t}\n\n\t\t/*\n\t\t * Copy the replace_text. Process back references when the\n\t\t * replace_text has escape characters.\n\t\t */\n\t\tif (have_escape)\n\t\t\tappendStringInfoRegexpSubstr(&buf, replace_text, pmatch,\n\t\t\t\t\t\t\t\t\t\t start_ptr, data_pos);\n\t\telse\n\t\t\tappendStringInfoText(&buf, replace_text);\n\n\t\t/* Advance start_ptr and data_pos over the matched text. */\n\t\tstart_ptr += charlen_to_bytelen(start_ptr,\n\t\t\t\t\t\t\t\t\t\tpmatch[0].rm_eo - data_pos);\n\t\tdata_pos = pmatch[0].rm_eo;\n\n\t\t/*\n\t\t * When global option is off, replace the first instance only.\n\t\t */\n\t\tif (!glob)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Advance search position.  Normally we start the next search at the\n\t\t * end of the previous match; but if the match was of zero length, we\n\t\t * have to advance by one character, or we'd just find the same match\n\t\t * again.\n\t\t */\n\t\tsearch_start = data_pos;\n\t\tif (pmatch[0].rm_so == pmatch[0].rm_eo)\n\t\t\tsearch_start++;\n\t}\n\n\t/*\n\t * Copy the text to the right of the last match.\n\t */\n\tif (data_pos < data_len)\n\t{\n\t\tint\t\t\tchunk_len;\n\n\t\tchunk_len = ((char *) src_text + VARSIZE_ANY(src_text)) - start_ptr;\n\t\tappendBinaryStringInfo(&buf, start_ptr, chunk_len);\n\t}\n\n\tret_text = cstring_to_text_with_len(buf.data, buf.len);\n\tpfree(buf.data);\n\tpfree(data);\n\n\treturn ret_text;\n}"
  },
  {
    "function_name": "appendStringInfoRegexpSubstr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "3944-4037",
    "snippet": "static void\nappendStringInfoRegexpSubstr(StringInfo str, text *replace_text,\n\t\t\t\t\t\t\t regmatch_t *pmatch,\n\t\t\t\t\t\t\t char *start_ptr, int data_pos)\n{\n\tconst char *p = VARDATA_ANY(replace_text);\n\tconst char *p_end = p + VARSIZE_ANY_EXHDR(replace_text);\n\tint\t\t\teml = pg_database_encoding_max_length();\n\n\tfor (;;)\n\t{\n\t\tconst char *chunk_start = p;\n\t\tint\t\t\tso;\n\t\tint\t\t\teo;\n\n\t\t/* Find next escape char. */\n\t\tif (eml == 1)\n\t\t{\n\t\t\tfor (; p < p_end && *p != '\\\\'; p++)\n\t\t\t\t /* nothing */ ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (; p < p_end && *p != '\\\\'; p += pg_mblen(p))\n\t\t\t\t /* nothing */ ;\n\t\t}\n\n\t\t/* Copy the text we just scanned over, if any. */\n\t\tif (p > chunk_start)\n\t\t\tappendBinaryStringInfo(str, chunk_start, p - chunk_start);\n\n\t\t/* Done if at end of string, else advance over escape char. */\n\t\tif (p >= p_end)\n\t\t\tbreak;\n\t\tp++;\n\n\t\tif (p >= p_end)\n\t\t{\n\t\t\t/* Escape at very end of input.  Treat same as unexpected char */\n\t\t\tappendStringInfoChar(str, '\\\\');\n\t\t\tbreak;\n\t\t}\n\n\t\tif (*p >= '1' && *p <= '9')\n\t\t{\n\t\t\t/* Use the back reference of regexp. */\n\t\t\tint\t\t\tidx = *p - '0';\n\n\t\t\tso = pmatch[idx].rm_so;\n\t\t\teo = pmatch[idx].rm_eo;\n\t\t\tp++;\n\t\t}\n\t\telse if (*p == '&')\n\t\t{\n\t\t\t/* Use the entire matched string. */\n\t\t\tso = pmatch[0].rm_so;\n\t\t\teo = pmatch[0].rm_eo;\n\t\t\tp++;\n\t\t}\n\t\telse if (*p == '\\\\')\n\t\t{\n\t\t\t/* \\\\ means transfer one \\ to output. */\n\t\t\tappendStringInfoChar(str, '\\\\');\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * If escape char is not followed by any expected char, just treat\n\t\t\t * it as ordinary data to copy.  (XXX would it be better to throw\n\t\t\t * an error?)\n\t\t\t */\n\t\t\tappendStringInfoChar(str, '\\\\');\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (so != -1 && eo != -1)\n\t\t{\n\t\t\t/*\n\t\t\t * Copy the text that is back reference of regexp.  Note so and eo\n\t\t\t * are counted in characters not bytes.\n\t\t\t */\n\t\t\tchar\t   *chunk_start;\n\t\t\tint\t\t\tchunk_len;\n\n\t\t\tAssert(so >= data_pos);\n\t\t\tchunk_start = start_ptr;\n\t\t\tchunk_start += charlen_to_bytelen(chunk_start, so - data_pos);\n\t\t\tchunk_len = charlen_to_bytelen(chunk_start, eo - so);\n\t\t\tappendBinaryStringInfo(str, chunk_start, chunk_len);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int32 text_length(Datum str);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "appendBinaryStringInfo",
          "args": [
            "str",
            "chunk_start",
            "chunk_len"
          ],
          "line": 4034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "charlen_to_bytelen",
          "args": [
            "chunk_start",
            "eo - so"
          ],
          "line": 4033
        },
        "resolved": true,
        "details": {
          "function_name": "charlen_to_bytelen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "734-751",
          "snippet": "static int\ncharlen_to_bytelen(const char *p, int n)\n{\n\tif (pg_database_encoding_max_length() == 1)\n\t{\n\t\t/* Optimization for single-byte encodings */\n\t\treturn n;\n\t}\n\telse\n\t{\n\t\tconst char *s;\n\n\t\tfor (s = p; n > 0; n--)\n\t\t\ts += pg_mblen(s);\n\n\t\treturn s - p;\n\t}\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ncharlen_to_bytelen(const char *p, int n)\n{\n\tif (pg_database_encoding_max_length() == 1)\n\t{\n\t\t/* Optimization for single-byte encodings */\n\t\treturn n;\n\t}\n\telse\n\t{\n\t\tconst char *s;\n\n\t\tfor (s = p; n > 0; n--)\n\t\t\ts += pg_mblen(s);\n\n\t\treturn s - p;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "so >= data_pos"
          ],
          "line": 4030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "str",
            "'\\\\'"
          ],
          "line": 4017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "str",
            "'\\\\'"
          ],
          "line": 4006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "str",
            "'\\\\'"
          ],
          "line": 3983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendBinaryStringInfo",
          "args": [
            "str",
            "chunk_start",
            "p - chunk_start"
          ],
          "line": 3973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_mblen",
          "args": [
            "p"
          ],
          "line": 3967
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mblen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "759-763",
          "snippet": "int\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nint\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_database_encoding_max_length",
          "args": [],
          "line": 3951
        },
        "resolved": true,
        "details": {
          "function_name": "pg_database_encoding_max_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "1832-1836",
          "snippet": "int\npg_database_encoding_max_length(void)\n{\n\treturn pg_wchar_table[GetDatabaseEncoding()].maxmblen;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nconst pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};\n\nint\npg_database_encoding_max_length(void)\n{\n\treturn pg_wchar_table[GetDatabaseEncoding()].maxmblen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "replace_text"
          ],
          "line": 3950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "replace_text"
          ],
          "line": 3949
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int32 text_length(Datum str);\n\nstatic void\nappendStringInfoRegexpSubstr(StringInfo str, text *replace_text,\n\t\t\t\t\t\t\t regmatch_t *pmatch,\n\t\t\t\t\t\t\t char *start_ptr, int data_pos)\n{\n\tconst char *p = VARDATA_ANY(replace_text);\n\tconst char *p_end = p + VARSIZE_ANY_EXHDR(replace_text);\n\tint\t\t\teml = pg_database_encoding_max_length();\n\n\tfor (;;)\n\t{\n\t\tconst char *chunk_start = p;\n\t\tint\t\t\tso;\n\t\tint\t\t\teo;\n\n\t\t/* Find next escape char. */\n\t\tif (eml == 1)\n\t\t{\n\t\t\tfor (; p < p_end && *p != '\\\\'; p++)\n\t\t\t\t /* nothing */ ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (; p < p_end && *p != '\\\\'; p += pg_mblen(p))\n\t\t\t\t /* nothing */ ;\n\t\t}\n\n\t\t/* Copy the text we just scanned over, if any. */\n\t\tif (p > chunk_start)\n\t\t\tappendBinaryStringInfo(str, chunk_start, p - chunk_start);\n\n\t\t/* Done if at end of string, else advance over escape char. */\n\t\tif (p >= p_end)\n\t\t\tbreak;\n\t\tp++;\n\n\t\tif (p >= p_end)\n\t\t{\n\t\t\t/* Escape at very end of input.  Treat same as unexpected char */\n\t\t\tappendStringInfoChar(str, '\\\\');\n\t\t\tbreak;\n\t\t}\n\n\t\tif (*p >= '1' && *p <= '9')\n\t\t{\n\t\t\t/* Use the back reference of regexp. */\n\t\t\tint\t\t\tidx = *p - '0';\n\n\t\t\tso = pmatch[idx].rm_so;\n\t\t\teo = pmatch[idx].rm_eo;\n\t\t\tp++;\n\t\t}\n\t\telse if (*p == '&')\n\t\t{\n\t\t\t/* Use the entire matched string. */\n\t\t\tso = pmatch[0].rm_so;\n\t\t\teo = pmatch[0].rm_eo;\n\t\t\tp++;\n\t\t}\n\t\telse if (*p == '\\\\')\n\t\t{\n\t\t\t/* \\\\ means transfer one \\ to output. */\n\t\t\tappendStringInfoChar(str, '\\\\');\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * If escape char is not followed by any expected char, just treat\n\t\t\t * it as ordinary data to copy.  (XXX would it be better to throw\n\t\t\t * an error?)\n\t\t\t */\n\t\t\tappendStringInfoChar(str, '\\\\');\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (so != -1 && eo != -1)\n\t\t{\n\t\t\t/*\n\t\t\t * Copy the text that is back reference of regexp.  Note so and eo\n\t\t\t * are counted in characters not bytes.\n\t\t\t */\n\t\t\tchar\t   *chunk_start;\n\t\t\tint\t\t\tchunk_len;\n\n\t\t\tAssert(so >= data_pos);\n\t\t\tchunk_start = start_ptr;\n\t\t\tchunk_start += charlen_to_bytelen(chunk_start, so - data_pos);\n\t\t\tchunk_len = charlen_to_bytelen(chunk_start, eo - so);\n\t\t\tappendBinaryStringInfo(str, chunk_start, chunk_len);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "check_replace_text_has_escape_char",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "3911-3935",
    "snippet": "static bool\ncheck_replace_text_has_escape_char(const text *replace_text)\n{\n\tconst char *p = VARDATA_ANY(replace_text);\n\tconst char *p_end = p + VARSIZE_ANY_EXHDR(replace_text);\n\n\tif (pg_database_encoding_max_length() == 1)\n\t{\n\t\tfor (; p < p_end; p++)\n\t\t{\n\t\t\tif (*p == '\\\\')\n\t\t\t\treturn true;\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor (; p < p_end; p += pg_mblen(p))\n\t\t{\n\t\t\tif (*p == '\\\\')\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pg_mblen",
          "args": [
            "p"
          ],
          "line": 3927
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mblen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "759-763",
          "snippet": "int\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nint\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_database_encoding_max_length",
          "args": [],
          "line": 3917
        },
        "resolved": true,
        "details": {
          "function_name": "pg_database_encoding_max_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "1832-1836",
          "snippet": "int\npg_database_encoding_max_length(void)\n{\n\treturn pg_wchar_table[GetDatabaseEncoding()].maxmblen;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nconst pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};\n\nint\npg_database_encoding_max_length(void)\n{\n\treturn pg_wchar_table[GetDatabaseEncoding()].maxmblen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "replace_text"
          ],
          "line": 3915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "replace_text"
          ],
          "line": 3914
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool\ncheck_replace_text_has_escape_char(const text *replace_text)\n{\n\tconst char *p = VARDATA_ANY(replace_text);\n\tconst char *p_end = p + VARSIZE_ANY_EXHDR(replace_text);\n\n\tif (pg_database_encoding_max_length() == 1)\n\t{\n\t\tfor (; p < p_end; p++)\n\t\t{\n\t\t\tif (*p == '\\\\')\n\t\t\t\treturn true;\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor (; p < p_end; p += pg_mblen(p))\n\t\t{\n\t\t\tif (*p == '\\\\')\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "replace_text",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "3828-3904",
    "snippet": "Datum\nreplace_text(PG_FUNCTION_ARGS)\n{\n\ttext\t   *src_text = PG_GETARG_TEXT_PP(0);\n\ttext\t   *from_sub_text = PG_GETARG_TEXT_PP(1);\n\ttext\t   *to_sub_text = PG_GETARG_TEXT_PP(2);\n\tint\t\t\tsrc_text_len;\n\tint\t\t\tfrom_sub_text_len;\n\tTextPositionState state;\n\ttext\t   *ret_text;\n\tint\t\t\tstart_posn;\n\tint\t\t\tcurr_posn;\n\tint\t\t\tchunk_len;\n\tchar\t   *start_ptr;\n\tStringInfoData str;\n\n\ttext_position_setup(src_text, from_sub_text, &state);\n\n\t/*\n\t * Note: we check the converted string length, not the original, because\n\t * they could be different if the input contained invalid encoding.\n\t */\n\tsrc_text_len = state.len1;\n\tfrom_sub_text_len = state.len2;\n\n\t/* Return unmodified source string if empty source or pattern */\n\tif (src_text_len < 1 || from_sub_text_len < 1)\n\t{\n\t\ttext_position_cleanup(&state);\n\t\tPG_RETURN_TEXT_P(src_text);\n\t}\n\n\tstart_posn = 1;\n\tcurr_posn = text_position_next(1, &state);\n\n\t/* When the from_sub_text is not found, there is nothing to do. */\n\tif (curr_posn == 0)\n\t{\n\t\ttext_position_cleanup(&state);\n\t\tPG_RETURN_TEXT_P(src_text);\n\t}\n\n\t/* start_ptr points to the start_posn'th character of src_text */\n\tstart_ptr = VARDATA_ANY(src_text);\n\n\tinitStringInfo(&str);\n\n\tdo\n\t{\n\t\tCHECK_FOR_INTERRUPTS();\n\n\t\t/* copy the data skipped over by last text_position_next() */\n\t\tchunk_len = charlen_to_bytelen(start_ptr, curr_posn - start_posn);\n\t\tappendBinaryStringInfo(&str, start_ptr, chunk_len);\n\n\t\tappendStringInfoText(&str, to_sub_text);\n\n\t\tstart_posn = curr_posn;\n\t\tstart_ptr += chunk_len;\n\t\tstart_posn += from_sub_text_len;\n\t\tstart_ptr += charlen_to_bytelen(start_ptr, from_sub_text_len);\n\n\t\tcurr_posn = text_position_next(start_posn, &state);\n\t}\n\twhile (curr_posn > 0);\n\n\t/* copy trailing data */\n\tchunk_len = ((char *) src_text + VARSIZE_ANY(src_text)) - start_ptr;\n\tappendBinaryStringInfo(&str, start_ptr, chunk_len);\n\n\ttext_position_cleanup(&state);\n\n\tret_text = cstring_to_text_with_len(str.data, str.len);\n\tpfree(str.data);\n\n\tPG_RETURN_TEXT_P(ret_text);\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int32 text_length(Datum str);",
      "static void text_position_setup(text *t1, text *t2, TextPositionState *state);",
      "static int\ttext_position_next(int start_pos, TextPositionState *state);",
      "static void text_position_cleanup(TextPositionState *state);",
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "ret_text"
          ],
          "line": 3903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "str.data"
          ],
          "line": 3901
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cstring_to_text_with_len",
          "args": [
            "str.data",
            "str.len"
          ],
          "line": 3900
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "160-169",
          "snippet": "text *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "text_position_cleanup",
          "args": [
            "&state"
          ],
          "line": 3898
        },
        "resolved": true,
        "details": {
          "function_name": "text_position_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "1363-1371",
          "snippet": "static void\ntext_position_cleanup(TextPositionState *state)\n{\n\tif (state->use_wchar)\n\t{\n\t\tpfree(state->wstr1);\n\t\tpfree(state->wstr2);\n\t}\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void text_position_setup(text *t1, text *t2, TextPositionState *state);",
            "static int\ttext_position_next(int start_pos, TextPositionState *state);",
            "static void text_position_cleanup(TextPositionState *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void text_position_setup(text *t1, text *t2, TextPositionState *state);\nstatic int\ttext_position_next(int start_pos, TextPositionState *state);\nstatic void text_position_cleanup(TextPositionState *state);\n\nstatic void\ntext_position_cleanup(TextPositionState *state)\n{\n\tif (state->use_wchar)\n\t{\n\t\tpfree(state->wstr1);\n\t\tpfree(state->wstr2);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendBinaryStringInfo",
          "args": [
            "&str",
            "start_ptr",
            "chunk_len"
          ],
          "line": 3896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY",
          "args": [
            "src_text"
          ],
          "line": 3895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text_position_next",
          "args": [
            "start_posn",
            "&state"
          ],
          "line": 3890
        },
        "resolved": true,
        "details": {
          "function_name": "text_position_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "1229-1361",
          "snippet": "static int\ntext_position_next(int start_pos, TextPositionState *state)\n{\n\tint\t\t\thaystack_len = state->len1;\n\tint\t\t\tneedle_len = state->len2;\n\tint\t\t\tskiptablemask = state->skiptablemask;\n\n\tAssert(start_pos > 0);\t\t/* else caller error */\n\n\tif (needle_len <= 0)\n\t\treturn start_pos;\t\t/* result for empty pattern */\n\n\tstart_pos--;\t\t\t\t/* adjust for zero based arrays */\n\n\t/* Done if the needle can't possibly fit */\n\tif (haystack_len < start_pos + needle_len)\n\t\treturn 0;\n\n\tif (!state->use_wchar)\n\t{\n\t\t/* simple case - single byte encoding */\n\t\tconst char *haystack = state->str1;\n\t\tconst char *needle = state->str2;\n\t\tconst char *haystack_end = &haystack[haystack_len];\n\t\tconst char *hptr;\n\n\t\tif (needle_len == 1)\n\t\t{\n\t\t\t/* No point in using B-M-H for a one-character needle */\n\t\t\tchar\t\tnchar = *needle;\n\n\t\t\thptr = &haystack[start_pos];\n\t\t\twhile (hptr < haystack_end)\n\t\t\t{\n\t\t\t\tif (*hptr == nchar)\n\t\t\t\t\treturn hptr - haystack + 1;\n\t\t\t\thptr++;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconst char *needle_last = &needle[needle_len - 1];\n\n\t\t\t/* Start at startpos plus the length of the needle */\n\t\t\thptr = &haystack[start_pos + needle_len - 1];\n\t\t\twhile (hptr < haystack_end)\n\t\t\t{\n\t\t\t\t/* Match the needle scanning *backward* */\n\t\t\t\tconst char *nptr;\n\t\t\t\tconst char *p;\n\n\t\t\t\tnptr = needle_last;\n\t\t\t\tp = hptr;\n\t\t\t\twhile (*nptr == *p)\n\t\t\t\t{\n\t\t\t\t\t/* Matched it all?\tIf so, return 1-based position */\n\t\t\t\t\tif (nptr == needle)\n\t\t\t\t\t\treturn p - haystack + 1;\n\t\t\t\t\tnptr--, p--;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * No match, so use the haystack char at hptr to decide how\n\t\t\t\t * far to advance.  If the needle had any occurrence of that\n\t\t\t\t * character (or more precisely, one sharing the same\n\t\t\t\t * skiptable entry) before its last character, then we advance\n\t\t\t\t * far enough to align the last such needle character with\n\t\t\t\t * that haystack position.  Otherwise we can advance by the\n\t\t\t\t * whole needle length.\n\t\t\t\t */\n\t\t\t\thptr += state->skiptable[(unsigned char) *hptr & skiptablemask];\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* The multibyte char version. This works exactly the same way. */\n\t\tconst pg_wchar *haystack = state->wstr1;\n\t\tconst pg_wchar *needle = state->wstr2;\n\t\tconst pg_wchar *haystack_end = &haystack[haystack_len];\n\t\tconst pg_wchar *hptr;\n\n\t\tif (needle_len == 1)\n\t\t{\n\t\t\t/* No point in using B-M-H for a one-character needle */\n\t\t\tpg_wchar\tnchar = *needle;\n\n\t\t\thptr = &haystack[start_pos];\n\t\t\twhile (hptr < haystack_end)\n\t\t\t{\n\t\t\t\tif (*hptr == nchar)\n\t\t\t\t\treturn hptr - haystack + 1;\n\t\t\t\thptr++;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconst pg_wchar *needle_last = &needle[needle_len - 1];\n\n\t\t\t/* Start at startpos plus the length of the needle */\n\t\t\thptr = &haystack[start_pos + needle_len - 1];\n\t\t\twhile (hptr < haystack_end)\n\t\t\t{\n\t\t\t\t/* Match the needle scanning *backward* */\n\t\t\t\tconst pg_wchar *nptr;\n\t\t\t\tconst pg_wchar *p;\n\n\t\t\t\tnptr = needle_last;\n\t\t\t\tp = hptr;\n\t\t\t\twhile (*nptr == *p)\n\t\t\t\t{\n\t\t\t\t\t/* Matched it all?\tIf so, return 1-based position */\n\t\t\t\t\tif (nptr == needle)\n\t\t\t\t\t\treturn p - haystack + 1;\n\t\t\t\t\tnptr--, p--;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * No match, so use the haystack char at hptr to decide how\n\t\t\t\t * far to advance.  If the needle had any occurrence of that\n\t\t\t\t * character (or more precisely, one sharing the same\n\t\t\t\t * skiptable entry) before its last character, then we advance\n\t\t\t\t * far enough to align the last such needle character with\n\t\t\t\t * that haystack position.  Otherwise we can advance by the\n\t\t\t\t * whole needle length.\n\t\t\t\t */\n\t\t\t\thptr += state->skiptable[*hptr & skiptablemask];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\t\t\t\t\t/* not found */\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void text_position_setup(text *t1, text *t2, TextPositionState *state);",
            "static int\ttext_position_next(int start_pos, TextPositionState *state);",
            "static void text_position_cleanup(TextPositionState *state);",
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void text_position_setup(text *t1, text *t2, TextPositionState *state);\nstatic int\ttext_position_next(int start_pos, TextPositionState *state);\nstatic void text_position_cleanup(TextPositionState *state);\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nstatic int\ntext_position_next(int start_pos, TextPositionState *state)\n{\n\tint\t\t\thaystack_len = state->len1;\n\tint\t\t\tneedle_len = state->len2;\n\tint\t\t\tskiptablemask = state->skiptablemask;\n\n\tAssert(start_pos > 0);\t\t/* else caller error */\n\n\tif (needle_len <= 0)\n\t\treturn start_pos;\t\t/* result for empty pattern */\n\n\tstart_pos--;\t\t\t\t/* adjust for zero based arrays */\n\n\t/* Done if the needle can't possibly fit */\n\tif (haystack_len < start_pos + needle_len)\n\t\treturn 0;\n\n\tif (!state->use_wchar)\n\t{\n\t\t/* simple case - single byte encoding */\n\t\tconst char *haystack = state->str1;\n\t\tconst char *needle = state->str2;\n\t\tconst char *haystack_end = &haystack[haystack_len];\n\t\tconst char *hptr;\n\n\t\tif (needle_len == 1)\n\t\t{\n\t\t\t/* No point in using B-M-H for a one-character needle */\n\t\t\tchar\t\tnchar = *needle;\n\n\t\t\thptr = &haystack[start_pos];\n\t\t\twhile (hptr < haystack_end)\n\t\t\t{\n\t\t\t\tif (*hptr == nchar)\n\t\t\t\t\treturn hptr - haystack + 1;\n\t\t\t\thptr++;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconst char *needle_last = &needle[needle_len - 1];\n\n\t\t\t/* Start at startpos plus the length of the needle */\n\t\t\thptr = &haystack[start_pos + needle_len - 1];\n\t\t\twhile (hptr < haystack_end)\n\t\t\t{\n\t\t\t\t/* Match the needle scanning *backward* */\n\t\t\t\tconst char *nptr;\n\t\t\t\tconst char *p;\n\n\t\t\t\tnptr = needle_last;\n\t\t\t\tp = hptr;\n\t\t\t\twhile (*nptr == *p)\n\t\t\t\t{\n\t\t\t\t\t/* Matched it all?\tIf so, return 1-based position */\n\t\t\t\t\tif (nptr == needle)\n\t\t\t\t\t\treturn p - haystack + 1;\n\t\t\t\t\tnptr--, p--;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * No match, so use the haystack char at hptr to decide how\n\t\t\t\t * far to advance.  If the needle had any occurrence of that\n\t\t\t\t * character (or more precisely, one sharing the same\n\t\t\t\t * skiptable entry) before its last character, then we advance\n\t\t\t\t * far enough to align the last such needle character with\n\t\t\t\t * that haystack position.  Otherwise we can advance by the\n\t\t\t\t * whole needle length.\n\t\t\t\t */\n\t\t\t\thptr += state->skiptable[(unsigned char) *hptr & skiptablemask];\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* The multibyte char version. This works exactly the same way. */\n\t\tconst pg_wchar *haystack = state->wstr1;\n\t\tconst pg_wchar *needle = state->wstr2;\n\t\tconst pg_wchar *haystack_end = &haystack[haystack_len];\n\t\tconst pg_wchar *hptr;\n\n\t\tif (needle_len == 1)\n\t\t{\n\t\t\t/* No point in using B-M-H for a one-character needle */\n\t\t\tpg_wchar\tnchar = *needle;\n\n\t\t\thptr = &haystack[start_pos];\n\t\t\twhile (hptr < haystack_end)\n\t\t\t{\n\t\t\t\tif (*hptr == nchar)\n\t\t\t\t\treturn hptr - haystack + 1;\n\t\t\t\thptr++;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconst pg_wchar *needle_last = &needle[needle_len - 1];\n\n\t\t\t/* Start at startpos plus the length of the needle */\n\t\t\thptr = &haystack[start_pos + needle_len - 1];\n\t\t\twhile (hptr < haystack_end)\n\t\t\t{\n\t\t\t\t/* Match the needle scanning *backward* */\n\t\t\t\tconst pg_wchar *nptr;\n\t\t\t\tconst pg_wchar *p;\n\n\t\t\t\tnptr = needle_last;\n\t\t\t\tp = hptr;\n\t\t\t\twhile (*nptr == *p)\n\t\t\t\t{\n\t\t\t\t\t/* Matched it all?\tIf so, return 1-based position */\n\t\t\t\t\tif (nptr == needle)\n\t\t\t\t\t\treturn p - haystack + 1;\n\t\t\t\t\tnptr--, p--;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * No match, so use the haystack char at hptr to decide how\n\t\t\t\t * far to advance.  If the needle had any occurrence of that\n\t\t\t\t * character (or more precisely, one sharing the same\n\t\t\t\t * skiptable entry) before its last character, then we advance\n\t\t\t\t * far enough to align the last such needle character with\n\t\t\t\t * that haystack position.  Otherwise we can advance by the\n\t\t\t\t * whole needle length.\n\t\t\t\t */\n\t\t\t\thptr += state->skiptable[*hptr & skiptablemask];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\t\t\t\t\t/* not found */\n}"
        }
      },
      {
        "call_info": {
          "callee": "charlen_to_bytelen",
          "args": [
            "start_ptr",
            "from_sub_text_len"
          ],
          "line": 3888
        },
        "resolved": true,
        "details": {
          "function_name": "charlen_to_bytelen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "734-751",
          "snippet": "static int\ncharlen_to_bytelen(const char *p, int n)\n{\n\tif (pg_database_encoding_max_length() == 1)\n\t{\n\t\t/* Optimization for single-byte encodings */\n\t\treturn n;\n\t}\n\telse\n\t{\n\t\tconst char *s;\n\n\t\tfor (s = p; n > 0; n--)\n\t\t\ts += pg_mblen(s);\n\n\t\treturn s - p;\n\t}\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ncharlen_to_bytelen(const char *p, int n)\n{\n\tif (pg_database_encoding_max_length() == 1)\n\t{\n\t\t/* Optimization for single-byte encodings */\n\t\treturn n;\n\t}\n\telse\n\t{\n\t\tconst char *s;\n\n\t\tfor (s = p; n > 0; n--)\n\t\t\ts += pg_mblen(s);\n\n\t\treturn s - p;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoText",
          "args": [
            "&str",
            "to_sub_text"
          ],
          "line": 3883
        },
        "resolved": true,
        "details": {
          "function_name": "appendStringInfoText",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "3814-3818",
          "snippet": "static void\nappendStringInfoText(StringInfo str, const text *t)\n{\n\tappendBinaryStringInfo(str, VARDATA_ANY(t), VARSIZE_ANY_EXHDR(t));\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int32 text_length(Datum str);",
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int32 text_length(Datum str);\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nstatic void\nappendStringInfoText(StringInfo str, const text *t)\n{\n\tappendBinaryStringInfo(str, VARDATA_ANY(t), VARSIZE_ANY_EXHDR(t));\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendBinaryStringInfo",
          "args": [
            "&str",
            "start_ptr",
            "chunk_len"
          ],
          "line": 3881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_FOR_INTERRUPTS",
          "args": [],
          "line": 3877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initStringInfo",
          "args": [
            "&str"
          ],
          "line": 3873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "src_text"
          ],
          "line": 3871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "src_text"
          ],
          "line": 3867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "src_text"
          ],
          "line": 3857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text_position_setup",
          "args": [
            "src_text",
            "from_sub_text",
            "&state"
          ],
          "line": 3844
        },
        "resolved": true,
        "details": {
          "function_name": "text_position_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "1117-1227",
          "snippet": "static void\ntext_position_setup(text *t1, text *t2, TextPositionState *state)\n{\n\tint\t\t\tlen1 = VARSIZE_ANY_EXHDR(t1);\n\tint\t\t\tlen2 = VARSIZE_ANY_EXHDR(t2);\n\n\tif (pg_database_encoding_max_length() == 1)\n\t{\n\t\t/* simple case - single byte encoding */\n\t\tstate->use_wchar = false;\n\t\tstate->str1 = VARDATA_ANY(t1);\n\t\tstate->str2 = VARDATA_ANY(t2);\n\t\tstate->len1 = len1;\n\t\tstate->len2 = len2;\n\t}\n\telse\n\t{\n\t\t/* not as simple - multibyte encoding */\n\t\tpg_wchar   *p1,\n\t\t\t\t   *p2;\n\n\t\tp1 = (pg_wchar *) palloc((len1 + 1) * sizeof(pg_wchar));\n\t\tlen1 = pg_mb2wchar_with_len(VARDATA_ANY(t1), p1, len1);\n\t\tp2 = (pg_wchar *) palloc((len2 + 1) * sizeof(pg_wchar));\n\t\tlen2 = pg_mb2wchar_with_len(VARDATA_ANY(t2), p2, len2);\n\n\t\tstate->use_wchar = true;\n\t\tstate->wstr1 = p1;\n\t\tstate->wstr2 = p2;\n\t\tstate->len1 = len1;\n\t\tstate->len2 = len2;\n\t}\n\n\t/*\n\t * Prepare the skip table for Boyer-Moore-Horspool searching.  In these\n\t * notes we use the terminology that the \"haystack\" is the string to be\n\t * searched (t1) and the \"needle\" is the pattern being sought (t2).\n\t *\n\t * If the needle is empty or bigger than the haystack then there is no\n\t * point in wasting cycles initializing the table.  We also choose not to\n\t * use B-M-H for needles of length 1, since the skip table can't possibly\n\t * save anything in that case.\n\t */\n\tif (len1 >= len2 && len2 > 1)\n\t{\n\t\tint\t\t\tsearchlength = len1 - len2;\n\t\tint\t\t\tskiptablemask;\n\t\tint\t\t\tlast;\n\t\tint\t\t\ti;\n\n\t\t/*\n\t\t * First we must determine how much of the skip table to use.  The\n\t\t * declaration of TextPositionState allows up to 256 elements, but for\n\t\t * short search problems we don't really want to have to initialize so\n\t\t * many elements --- it would take too long in comparison to the\n\t\t * actual search time.  So we choose a useful skip table size based on\n\t\t * the haystack length minus the needle length.  The closer the needle\n\t\t * length is to the haystack length the less useful skipping becomes.\n\t\t *\n\t\t * Note: since we use bit-masking to select table elements, the skip\n\t\t * table size MUST be a power of 2, and so the mask must be 2^N-1.\n\t\t */\n\t\tif (searchlength < 16)\n\t\t\tskiptablemask = 3;\n\t\telse if (searchlength < 64)\n\t\t\tskiptablemask = 7;\n\t\telse if (searchlength < 128)\n\t\t\tskiptablemask = 15;\n\t\telse if (searchlength < 512)\n\t\t\tskiptablemask = 31;\n\t\telse if (searchlength < 2048)\n\t\t\tskiptablemask = 63;\n\t\telse if (searchlength < 4096)\n\t\t\tskiptablemask = 127;\n\t\telse\n\t\t\tskiptablemask = 255;\n\t\tstate->skiptablemask = skiptablemask;\n\n\t\t/*\n\t\t * Initialize the skip table.  We set all elements to the needle\n\t\t * length, since this is the correct skip distance for any character\n\t\t * not found in the needle.\n\t\t */\n\t\tfor (i = 0; i <= skiptablemask; i++)\n\t\t\tstate->skiptable[i] = len2;\n\n\t\t/*\n\t\t * Now examine the needle.  For each character except the last one,\n\t\t * set the corresponding table element to the appropriate skip\n\t\t * distance.  Note that when two characters share the same skip table\n\t\t * entry, the one later in the needle must determine the skip\n\t\t * distance.\n\t\t */\n\t\tlast = len2 - 1;\n\n\t\tif (!state->use_wchar)\n\t\t{\n\t\t\tconst char *str2 = state->str2;\n\n\t\t\tfor (i = 0; i < last; i++)\n\t\t\t\tstate->skiptable[(unsigned char) str2[i] & skiptablemask] = last - i;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconst pg_wchar *wstr2 = state->wstr2;\n\n\t\t\tfor (i = 0; i < last; i++)\n\t\t\t\tstate->skiptable[wstr2[i] & skiptablemask] = last - i;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static text *text_catenate(text *t1, text *t2);",
            "static int\ttext_position(text *t1, text *t2);",
            "static void text_position_setup(text *t1, text *t2, TextPositionState *state);",
            "static int\ttext_position_next(int start_pos, TextPositionState *state);",
            "static void text_position_cleanup(TextPositionState *state);",
            "static bytea *bytea_catenate(bytea *t1, bytea *t2);",
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic text *text_catenate(text *t1, text *t2);\nstatic int\ttext_position(text *t1, text *t2);\nstatic void text_position_setup(text *t1, text *t2, TextPositionState *state);\nstatic int\ttext_position_next(int start_pos, TextPositionState *state);\nstatic void text_position_cleanup(TextPositionState *state);\nstatic bytea *bytea_catenate(bytea *t1, bytea *t2);\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nstatic void\ntext_position_setup(text *t1, text *t2, TextPositionState *state)\n{\n\tint\t\t\tlen1 = VARSIZE_ANY_EXHDR(t1);\n\tint\t\t\tlen2 = VARSIZE_ANY_EXHDR(t2);\n\n\tif (pg_database_encoding_max_length() == 1)\n\t{\n\t\t/* simple case - single byte encoding */\n\t\tstate->use_wchar = false;\n\t\tstate->str1 = VARDATA_ANY(t1);\n\t\tstate->str2 = VARDATA_ANY(t2);\n\t\tstate->len1 = len1;\n\t\tstate->len2 = len2;\n\t}\n\telse\n\t{\n\t\t/* not as simple - multibyte encoding */\n\t\tpg_wchar   *p1,\n\t\t\t\t   *p2;\n\n\t\tp1 = (pg_wchar *) palloc((len1 + 1) * sizeof(pg_wchar));\n\t\tlen1 = pg_mb2wchar_with_len(VARDATA_ANY(t1), p1, len1);\n\t\tp2 = (pg_wchar *) palloc((len2 + 1) * sizeof(pg_wchar));\n\t\tlen2 = pg_mb2wchar_with_len(VARDATA_ANY(t2), p2, len2);\n\n\t\tstate->use_wchar = true;\n\t\tstate->wstr1 = p1;\n\t\tstate->wstr2 = p2;\n\t\tstate->len1 = len1;\n\t\tstate->len2 = len2;\n\t}\n\n\t/*\n\t * Prepare the skip table for Boyer-Moore-Horspool searching.  In these\n\t * notes we use the terminology that the \"haystack\" is the string to be\n\t * searched (t1) and the \"needle\" is the pattern being sought (t2).\n\t *\n\t * If the needle is empty or bigger than the haystack then there is no\n\t * point in wasting cycles initializing the table.  We also choose not to\n\t * use B-M-H for needles of length 1, since the skip table can't possibly\n\t * save anything in that case.\n\t */\n\tif (len1 >= len2 && len2 > 1)\n\t{\n\t\tint\t\t\tsearchlength = len1 - len2;\n\t\tint\t\t\tskiptablemask;\n\t\tint\t\t\tlast;\n\t\tint\t\t\ti;\n\n\t\t/*\n\t\t * First we must determine how much of the skip table to use.  The\n\t\t * declaration of TextPositionState allows up to 256 elements, but for\n\t\t * short search problems we don't really want to have to initialize so\n\t\t * many elements --- it would take too long in comparison to the\n\t\t * actual search time.  So we choose a useful skip table size based on\n\t\t * the haystack length minus the needle length.  The closer the needle\n\t\t * length is to the haystack length the less useful skipping becomes.\n\t\t *\n\t\t * Note: since we use bit-masking to select table elements, the skip\n\t\t * table size MUST be a power of 2, and so the mask must be 2^N-1.\n\t\t */\n\t\tif (searchlength < 16)\n\t\t\tskiptablemask = 3;\n\t\telse if (searchlength < 64)\n\t\t\tskiptablemask = 7;\n\t\telse if (searchlength < 128)\n\t\t\tskiptablemask = 15;\n\t\telse if (searchlength < 512)\n\t\t\tskiptablemask = 31;\n\t\telse if (searchlength < 2048)\n\t\t\tskiptablemask = 63;\n\t\telse if (searchlength < 4096)\n\t\t\tskiptablemask = 127;\n\t\telse\n\t\t\tskiptablemask = 255;\n\t\tstate->skiptablemask = skiptablemask;\n\n\t\t/*\n\t\t * Initialize the skip table.  We set all elements to the needle\n\t\t * length, since this is the correct skip distance for any character\n\t\t * not found in the needle.\n\t\t */\n\t\tfor (i = 0; i <= skiptablemask; i++)\n\t\t\tstate->skiptable[i] = len2;\n\n\t\t/*\n\t\t * Now examine the needle.  For each character except the last one,\n\t\t * set the corresponding table element to the appropriate skip\n\t\t * distance.  Note that when two characters share the same skip table\n\t\t * entry, the one later in the needle must determine the skip\n\t\t * distance.\n\t\t */\n\t\tlast = len2 - 1;\n\n\t\tif (!state->use_wchar)\n\t\t{\n\t\t\tconst char *str2 = state->str2;\n\n\t\t\tfor (i = 0; i < last; i++)\n\t\t\t\tstate->skiptable[(unsigned char) str2[i] & skiptablemask] = last - i;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconst pg_wchar *wstr2 = state->wstr2;\n\n\t\t\tfor (i = 0; i < last; i++)\n\t\t\t\tstate->skiptable[wstr2[i] & skiptablemask] = last - i;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "2"
          ],
          "line": 3833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 3832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 3831
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int32 text_length(Datum str);\nstatic void text_position_setup(text *t1, text *t2, TextPositionState *state);\nstatic int\ttext_position_next(int start_pos, TextPositionState *state);\nstatic void text_position_cleanup(TextPositionState *state);\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\n\nDatum\nreplace_text(PG_FUNCTION_ARGS)\n{\n\ttext\t   *src_text = PG_GETARG_TEXT_PP(0);\n\ttext\t   *from_sub_text = PG_GETARG_TEXT_PP(1);\n\ttext\t   *to_sub_text = PG_GETARG_TEXT_PP(2);\n\tint\t\t\tsrc_text_len;\n\tint\t\t\tfrom_sub_text_len;\n\tTextPositionState state;\n\ttext\t   *ret_text;\n\tint\t\t\tstart_posn;\n\tint\t\t\tcurr_posn;\n\tint\t\t\tchunk_len;\n\tchar\t   *start_ptr;\n\tStringInfoData str;\n\n\ttext_position_setup(src_text, from_sub_text, &state);\n\n\t/*\n\t * Note: we check the converted string length, not the original, because\n\t * they could be different if the input contained invalid encoding.\n\t */\n\tsrc_text_len = state.len1;\n\tfrom_sub_text_len = state.len2;\n\n\t/* Return unmodified source string if empty source or pattern */\n\tif (src_text_len < 1 || from_sub_text_len < 1)\n\t{\n\t\ttext_position_cleanup(&state);\n\t\tPG_RETURN_TEXT_P(src_text);\n\t}\n\n\tstart_posn = 1;\n\tcurr_posn = text_position_next(1, &state);\n\n\t/* When the from_sub_text is not found, there is nothing to do. */\n\tif (curr_posn == 0)\n\t{\n\t\ttext_position_cleanup(&state);\n\t\tPG_RETURN_TEXT_P(src_text);\n\t}\n\n\t/* start_ptr points to the start_posn'th character of src_text */\n\tstart_ptr = VARDATA_ANY(src_text);\n\n\tinitStringInfo(&str);\n\n\tdo\n\t{\n\t\tCHECK_FOR_INTERRUPTS();\n\n\t\t/* copy the data skipped over by last text_position_next() */\n\t\tchunk_len = charlen_to_bytelen(start_ptr, curr_posn - start_posn);\n\t\tappendBinaryStringInfo(&str, start_ptr, chunk_len);\n\n\t\tappendStringInfoText(&str, to_sub_text);\n\n\t\tstart_posn = curr_posn;\n\t\tstart_ptr += chunk_len;\n\t\tstart_posn += from_sub_text_len;\n\t\tstart_ptr += charlen_to_bytelen(start_ptr, from_sub_text_len);\n\n\t\tcurr_posn = text_position_next(start_posn, &state);\n\t}\n\twhile (curr_posn > 0);\n\n\t/* copy trailing data */\n\tchunk_len = ((char *) src_text + VARSIZE_ANY(src_text)) - start_ptr;\n\tappendBinaryStringInfo(&str, start_ptr, chunk_len);\n\n\ttext_position_cleanup(&state);\n\n\tret_text = cstring_to_text_with_len(str.data, str.len);\n\tpfree(str.data);\n\n\tPG_RETURN_TEXT_P(ret_text);\n}"
  },
  {
    "function_name": "appendStringInfoText",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "3814-3818",
    "snippet": "static void\nappendStringInfoText(StringInfo str, const text *t)\n{\n\tappendBinaryStringInfo(str, VARDATA_ANY(t), VARSIZE_ANY_EXHDR(t));\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int32 text_length(Datum str);",
      "static void appendStringInfoText(StringInfo str, const text *t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "appendBinaryStringInfo",
          "args": [
            "str",
            "VARDATA_ANY(t)",
            "VARSIZE_ANY_EXHDR(t)"
          ],
          "line": 3817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "t"
          ],
          "line": 3817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "t"
          ],
          "line": 3817
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int32 text_length(Datum str);\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nstatic void\nappendStringInfoText(StringInfo str, const text *t)\n{\n\tappendBinaryStringInfo(str, VARDATA_ANY(t), VARSIZE_ANY_EXHDR(t));\n}"
  },
  {
    "function_name": "bytea_sortsupport",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "3792-3806",
    "snippet": "Datum\nbytea_sortsupport(PG_FUNCTION_ARGS)\n{\n\tSortSupport ssup = (SortSupport) PG_GETARG_POINTER(0);\n\tMemoryContext oldcontext;\n\n\toldcontext = MemoryContextSwitchTo(ssup->ssup_cxt);\n\n\t/* Use generic string SortSupport, forcing \"C\" collation */\n\tvarstr_sortsupport(ssup, C_COLLATION_OID, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\tPG_RETURN_VOID();\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tvarstrfastcmp_c(Datum x, Datum y, SortSupport ssup);",
      "static int\tbpcharfastcmp_c(Datum x, Datum y, SortSupport ssup);",
      "static int\tvarstrfastcmp_locale(Datum x, Datum y, SortSupport ssup);",
      "static int\tvarstrcmp_abbrev(Datum x, Datum y, SortSupport ssup);",
      "static Datum varstr_abbrev_convert(Datum original, SortSupport ssup);",
      "static bool varstr_abbrev_abort(int memtupcount, SortSupport ssup);",
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VOID",
          "args": [],
          "line": 3805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 3803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "varstr_sortsupport",
          "args": [
            "ssup",
            "C_COLLATION_OID",
            "false"
          ],
          "line": 3801
        },
        "resolved": true,
        "details": {
          "function_name": "varstr_sortsupport",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "1834-1985",
          "snippet": "void\nvarstr_sortsupport(SortSupport ssup, Oid collid, bool bpchar)\n{\n\tbool\t\tabbreviate = ssup->abbreviate;\n\tbool\t\tcollate_c = false;\n\tVarStringSortSupport *sss;\n\tpg_locale_t locale = 0;\n\n\t/*\n\t * If possible, set ssup->comparator to a function which can be used to\n\t * directly compare two datums.  If we can do this, we'll avoid the\n\t * overhead of a trip through the fmgr layer for every comparison, which\n\t * can be substantial.\n\t *\n\t * Most typically, we'll set the comparator to varstrfastcmp_locale, which\n\t * uses strcoll() to perform comparisons and knows about the special\n\t * requirements of BpChar callers.  However, if LC_COLLATE = C, we can\n\t * make things quite a bit faster with varstrfastcmp_c or bpcharfastcmp_c,\n\t * both of which use memcmp() rather than strcoll().\n\t */\n\tif (lc_collate_is_c(collid))\n\t{\n\t\tif (!bpchar)\n\t\t\tssup->comparator = varstrfastcmp_c;\n\t\telse\n\t\t\tssup->comparator = bpcharfastcmp_c;\n\n\t\tcollate_c = true;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * We need a collation-sensitive comparison.  To make things faster,\n\t\t * we'll figure out the collation based on the locale id and cache the\n\t\t * result.\n\t\t */\n\t\tif (collid != DEFAULT_COLLATION_OID)\n\t\t{\n\t\t\tif (!OidIsValid(collid))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This typically means that the parser could not resolve a\n\t\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t\t errmsg(\"could not determine which collation to use for string comparison\"),\n\t\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t\t}\n\t\t\tlocale = pg_newlocale_from_collation(collid);\n\t\t}\n\n\t\t/*\n\t\t * There is a further exception on Windows.  When the database\n\t\t * encoding is UTF-8 and we are not using the C collation, complex\n\t\t * hacks are required.  We don't currently have a comparator that\n\t\t * handles that case, so we fall back on the slow method of having the\n\t\t * sort code invoke bttextcmp() (in the case of text) via the fmgr\n\t\t * trampoline.  ICU locales work just the same on Windows, however.\n\t\t */\n#ifdef WIN32\n\t\tif (GetDatabaseEncoding() == PG_UTF8 &&\n\t\t\t!(locale && locale->provider == COLLPROVIDER_ICU))\n\t\t\treturn;\n#endif\n\n\t\tssup->comparator = varstrfastcmp_locale;\n\t}\n\n\t/*\n\t * Unfortunately, it seems that abbreviation for non-C collations is\n\t * broken on many common platforms; testing of multiple versions of glibc\n\t * reveals that, for many locales, strcoll() and strxfrm() do not return\n\t * consistent results, which is fatal to this optimization.  While no\n\t * other libc other than Cygwin has so far been shown to have a problem,\n\t * we take the conservative course of action for right now and disable\n\t * this categorically.  (Users who are certain this isn't a problem on\n\t * their system can define TRUST_STRXFRM.)\n\t *\n\t * Even apart from the risk of broken locales, it's possible that there\n\t * are platforms where the use of abbreviated keys should be disabled at\n\t * compile time.  Having only 4 byte datums could make worst-case\n\t * performance drastically more likely, for example.  Moreover, macOS's\n\t * strxfrm() implementation is known to not effectively concentrate a\n\t * significant amount of entropy from the original string in earlier\n\t * transformed blobs.  It's possible that other supported platforms are\n\t * similarly encumbered.  So, if we ever get past disabling this\n\t * categorically, we may still want or need to disable it for particular\n\t * platforms.\n\t */\n#ifndef TRUST_STRXFRM\n\tif (!collate_c && !(locale && locale->provider == COLLPROVIDER_ICU))\n\t\tabbreviate = false;\n#endif\n\n\t/*\n\t * If we're using abbreviated keys, or if we're using a locale-aware\n\t * comparison, we need to initialize a StringSortSupport object.  Both\n\t * cases will make use of the temporary buffers we initialize here for\n\t * scratch space (and to detect requirement for BpChar semantics from\n\t * caller), and the abbreviation case requires additional state.\n\t */\n\tif (abbreviate || !collate_c)\n\t{\n\t\tsss = palloc(sizeof(VarStringSortSupport));\n\t\tsss->buf1 = palloc(TEXTBUFLEN);\n\t\tsss->buflen1 = TEXTBUFLEN;\n\t\tsss->buf2 = palloc(TEXTBUFLEN);\n\t\tsss->buflen2 = TEXTBUFLEN;\n\t\t/* Start with invalid values */\n\t\tsss->last_len1 = -1;\n\t\tsss->last_len2 = -1;\n\t\t/* Initialize */\n\t\tsss->last_returned = 0;\n\t\tsss->locale = locale;\n\n\t\t/*\n\t\t * To avoid somehow confusing a strxfrm() blob and an original string,\n\t\t * constantly keep track of the variety of data that buf1 and buf2\n\t\t * currently contain.\n\t\t *\n\t\t * Comparisons may be interleaved with conversion calls.  Frequently,\n\t\t * conversions and comparisons are batched into two distinct phases,\n\t\t * but the correctness of caching cannot hinge upon this.  For\n\t\t * comparison caching, buffer state is only trusted if cache_blob is\n\t\t * found set to false, whereas strxfrm() caching only trusts the state\n\t\t * when cache_blob is found set to true.\n\t\t *\n\t\t * Arbitrarily initialize cache_blob to true.\n\t\t */\n\t\tsss->cache_blob = true;\n\t\tsss->collate_c = collate_c;\n\t\tsss->bpchar = bpchar;\n\t\tssup->ssup_extra = sss;\n\n\t\t/*\n\t\t * If possible, plan to use the abbreviated keys optimization.  The\n\t\t * core code may switch back to authoritative comparator should\n\t\t * abbreviation be aborted.\n\t\t */\n\t\tif (abbreviate)\n\t\t{\n\t\t\tsss->prop_card = 0.20;\n\t\t\tinitHyperLogLog(&sss->abbr_card, 10);\n\t\t\tinitHyperLogLog(&sss->full_card, 10);\n\t\t\tssup->abbrev_full_comparator = ssup->comparator;\n\t\t\tssup->comparator = varstrcmp_abbrev;\n\t\t\tssup->abbrev_converter = varstr_abbrev_convert;\n\t\t\tssup->abbrev_abort = varstr_abbrev_abort;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TEXTBUFLEN\t\t1024"
          ],
          "globals_used": [
            "static int\tvarstrfastcmp_c(Datum x, Datum y, SortSupport ssup);",
            "static int\tbpcharfastcmp_c(Datum x, Datum y, SortSupport ssup);",
            "static int\tvarstrfastcmp_locale(Datum x, Datum y, SortSupport ssup);",
            "static int\tvarstrcmp_abbrev(Datum x, Datum y, SortSupport ssup);",
            "static Datum varstr_abbrev_convert(Datum original, SortSupport ssup);",
            "static bool varstr_abbrev_abort(int memtupcount, SortSupport ssup);",
            "static void text_position_setup(text *t1, text *t2, TextPositionState *state);",
            "static int\ttext_position_next(int start_pos, TextPositionState *state);",
            "static void text_position_cleanup(TextPositionState *state);",
            "static int\ttext_cmp(text *arg1, text *arg2, Oid collid);",
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define TEXTBUFLEN\t\t1024\n\nstatic int\tvarstrfastcmp_c(Datum x, Datum y, SortSupport ssup);\nstatic int\tbpcharfastcmp_c(Datum x, Datum y, SortSupport ssup);\nstatic int\tvarstrfastcmp_locale(Datum x, Datum y, SortSupport ssup);\nstatic int\tvarstrcmp_abbrev(Datum x, Datum y, SortSupport ssup);\nstatic Datum varstr_abbrev_convert(Datum original, SortSupport ssup);\nstatic bool varstr_abbrev_abort(int memtupcount, SortSupport ssup);\nstatic void text_position_setup(text *t1, text *t2, TextPositionState *state);\nstatic int\ttext_position_next(int start_pos, TextPositionState *state);\nstatic void text_position_cleanup(TextPositionState *state);\nstatic int\ttext_cmp(text *arg1, text *arg2, Oid collid);\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nvoid\nvarstr_sortsupport(SortSupport ssup, Oid collid, bool bpchar)\n{\n\tbool\t\tabbreviate = ssup->abbreviate;\n\tbool\t\tcollate_c = false;\n\tVarStringSortSupport *sss;\n\tpg_locale_t locale = 0;\n\n\t/*\n\t * If possible, set ssup->comparator to a function which can be used to\n\t * directly compare two datums.  If we can do this, we'll avoid the\n\t * overhead of a trip through the fmgr layer for every comparison, which\n\t * can be substantial.\n\t *\n\t * Most typically, we'll set the comparator to varstrfastcmp_locale, which\n\t * uses strcoll() to perform comparisons and knows about the special\n\t * requirements of BpChar callers.  However, if LC_COLLATE = C, we can\n\t * make things quite a bit faster with varstrfastcmp_c or bpcharfastcmp_c,\n\t * both of which use memcmp() rather than strcoll().\n\t */\n\tif (lc_collate_is_c(collid))\n\t{\n\t\tif (!bpchar)\n\t\t\tssup->comparator = varstrfastcmp_c;\n\t\telse\n\t\t\tssup->comparator = bpcharfastcmp_c;\n\n\t\tcollate_c = true;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * We need a collation-sensitive comparison.  To make things faster,\n\t\t * we'll figure out the collation based on the locale id and cache the\n\t\t * result.\n\t\t */\n\t\tif (collid != DEFAULT_COLLATION_OID)\n\t\t{\n\t\t\tif (!OidIsValid(collid))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This typically means that the parser could not resolve a\n\t\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t\t errmsg(\"could not determine which collation to use for string comparison\"),\n\t\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t\t}\n\t\t\tlocale = pg_newlocale_from_collation(collid);\n\t\t}\n\n\t\t/*\n\t\t * There is a further exception on Windows.  When the database\n\t\t * encoding is UTF-8 and we are not using the C collation, complex\n\t\t * hacks are required.  We don't currently have a comparator that\n\t\t * handles that case, so we fall back on the slow method of having the\n\t\t * sort code invoke bttextcmp() (in the case of text) via the fmgr\n\t\t * trampoline.  ICU locales work just the same on Windows, however.\n\t\t */\n#ifdef WIN32\n\t\tif (GetDatabaseEncoding() == PG_UTF8 &&\n\t\t\t!(locale && locale->provider == COLLPROVIDER_ICU))\n\t\t\treturn;\n#endif\n\n\t\tssup->comparator = varstrfastcmp_locale;\n\t}\n\n\t/*\n\t * Unfortunately, it seems that abbreviation for non-C collations is\n\t * broken on many common platforms; testing of multiple versions of glibc\n\t * reveals that, for many locales, strcoll() and strxfrm() do not return\n\t * consistent results, which is fatal to this optimization.  While no\n\t * other libc other than Cygwin has so far been shown to have a problem,\n\t * we take the conservative course of action for right now and disable\n\t * this categorically.  (Users who are certain this isn't a problem on\n\t * their system can define TRUST_STRXFRM.)\n\t *\n\t * Even apart from the risk of broken locales, it's possible that there\n\t * are platforms where the use of abbreviated keys should be disabled at\n\t * compile time.  Having only 4 byte datums could make worst-case\n\t * performance drastically more likely, for example.  Moreover, macOS's\n\t * strxfrm() implementation is known to not effectively concentrate a\n\t * significant amount of entropy from the original string in earlier\n\t * transformed blobs.  It's possible that other supported platforms are\n\t * similarly encumbered.  So, if we ever get past disabling this\n\t * categorically, we may still want or need to disable it for particular\n\t * platforms.\n\t */\n#ifndef TRUST_STRXFRM\n\tif (!collate_c && !(locale && locale->provider == COLLPROVIDER_ICU))\n\t\tabbreviate = false;\n#endif\n\n\t/*\n\t * If we're using abbreviated keys, or if we're using a locale-aware\n\t * comparison, we need to initialize a StringSortSupport object.  Both\n\t * cases will make use of the temporary buffers we initialize here for\n\t * scratch space (and to detect requirement for BpChar semantics from\n\t * caller), and the abbreviation case requires additional state.\n\t */\n\tif (abbreviate || !collate_c)\n\t{\n\t\tsss = palloc(sizeof(VarStringSortSupport));\n\t\tsss->buf1 = palloc(TEXTBUFLEN);\n\t\tsss->buflen1 = TEXTBUFLEN;\n\t\tsss->buf2 = palloc(TEXTBUFLEN);\n\t\tsss->buflen2 = TEXTBUFLEN;\n\t\t/* Start with invalid values */\n\t\tsss->last_len1 = -1;\n\t\tsss->last_len2 = -1;\n\t\t/* Initialize */\n\t\tsss->last_returned = 0;\n\t\tsss->locale = locale;\n\n\t\t/*\n\t\t * To avoid somehow confusing a strxfrm() blob and an original string,\n\t\t * constantly keep track of the variety of data that buf1 and buf2\n\t\t * currently contain.\n\t\t *\n\t\t * Comparisons may be interleaved with conversion calls.  Frequently,\n\t\t * conversions and comparisons are batched into two distinct phases,\n\t\t * but the correctness of caching cannot hinge upon this.  For\n\t\t * comparison caching, buffer state is only trusted if cache_blob is\n\t\t * found set to false, whereas strxfrm() caching only trusts the state\n\t\t * when cache_blob is found set to true.\n\t\t *\n\t\t * Arbitrarily initialize cache_blob to true.\n\t\t */\n\t\tsss->cache_blob = true;\n\t\tsss->collate_c = collate_c;\n\t\tsss->bpchar = bpchar;\n\t\tssup->ssup_extra = sss;\n\n\t\t/*\n\t\t * If possible, plan to use the abbreviated keys optimization.  The\n\t\t * core code may switch back to authoritative comparator should\n\t\t * abbreviation be aborted.\n\t\t */\n\t\tif (abbreviate)\n\t\t{\n\t\t\tsss->prop_card = 0.20;\n\t\t\tinitHyperLogLog(&sss->abbr_card, 10);\n\t\t\tinitHyperLogLog(&sss->full_card, 10);\n\t\t\tssup->abbrev_full_comparator = ssup->comparator;\n\t\t\tssup->comparator = varstrcmp_abbrev;\n\t\t\tssup->abbrev_converter = varstr_abbrev_convert;\n\t\t\tssup->abbrev_abort = varstr_abbrev_abort;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "ssup->ssup_cxt"
          ],
          "line": 3798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 3795
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\tvarstrfastcmp_c(Datum x, Datum y, SortSupport ssup);\nstatic int\tbpcharfastcmp_c(Datum x, Datum y, SortSupport ssup);\nstatic int\tvarstrfastcmp_locale(Datum x, Datum y, SortSupport ssup);\nstatic int\tvarstrcmp_abbrev(Datum x, Datum y, SortSupport ssup);\nstatic Datum varstr_abbrev_convert(Datum original, SortSupport ssup);\nstatic bool varstr_abbrev_abort(int memtupcount, SortSupport ssup);\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\n\nDatum\nbytea_sortsupport(PG_FUNCTION_ARGS)\n{\n\tSortSupport ssup = (SortSupport) PG_GETARG_POINTER(0);\n\tMemoryContext oldcontext;\n\n\toldcontext = MemoryContextSwitchTo(ssup->ssup_cxt);\n\n\t/* Use generic string SortSupport, forcing \"C\" collation */\n\tvarstr_sortsupport(ssup, C_COLLATION_OID, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\tPG_RETURN_VOID();\n}"
  },
  {
    "function_name": "byteacmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "3770-3790",
    "snippet": "Datum\nbyteacmp(PG_FUNCTION_ARGS)\n{\n\tbytea\t   *arg1 = PG_GETARG_BYTEA_PP(0);\n\tbytea\t   *arg2 = PG_GETARG_BYTEA_PP(1);\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\tint\t\t\tcmp;\n\n\tlen1 = VARSIZE_ANY_EXHDR(arg1);\n\tlen2 = VARSIZE_ANY_EXHDR(arg2);\n\n\tcmp = memcmp(VARDATA_ANY(arg1), VARDATA_ANY(arg2), Min(len1, len2));\n\tif ((cmp == 0) && (len1 != len2))\n\t\tcmp = (len1 < len2) ? -1 : 1;\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_INT32(cmp);\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "cmp"
          ],
          "line": 3789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg2",
            "1"
          ],
          "line": 3787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg1",
            "0"
          ],
          "line": 3786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "VARDATA_ANY(arg1)",
            "VARDATA_ANY(arg2)",
            "Min(len1, len2)"
          ],
          "line": 3782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "len1",
            "len2"
          ],
          "line": 3782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "arg2"
          ],
          "line": 3782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "arg1"
          ],
          "line": 3782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "arg2"
          ],
          "line": 3780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "arg1"
          ],
          "line": 3779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BYTEA_PP",
          "args": [
            "1"
          ],
          "line": 3774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BYTEA_PP",
          "args": [
            "0"
          ],
          "line": 3773
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\n\nDatum\nbyteacmp(PG_FUNCTION_ARGS)\n{\n\tbytea\t   *arg1 = PG_GETARG_BYTEA_PP(0);\n\tbytea\t   *arg2 = PG_GETARG_BYTEA_PP(1);\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\tint\t\t\tcmp;\n\n\tlen1 = VARSIZE_ANY_EXHDR(arg1);\n\tlen2 = VARSIZE_ANY_EXHDR(arg2);\n\n\tcmp = memcmp(VARDATA_ANY(arg1), VARDATA_ANY(arg2), Min(len1, len2));\n\tif ((cmp == 0) && (len1 != len2))\n\t\tcmp = (len1 < len2) ? -1 : 1;\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_INT32(cmp);\n}"
  },
  {
    "function_name": "byteage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "3750-3768",
    "snippet": "Datum\nbyteage(PG_FUNCTION_ARGS)\n{\n\tbytea\t   *arg1 = PG_GETARG_BYTEA_PP(0);\n\tbytea\t   *arg2 = PG_GETARG_BYTEA_PP(1);\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\tint\t\t\tcmp;\n\n\tlen1 = VARSIZE_ANY_EXHDR(arg1);\n\tlen2 = VARSIZE_ANY_EXHDR(arg2);\n\n\tcmp = memcmp(VARDATA_ANY(arg1), VARDATA_ANY(arg2), Min(len1, len2));\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_BOOL((cmp > 0) || ((cmp == 0) && (len1 >= len2)));\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "(cmp > 0) || ((cmp == 0) && (len1 >= len2))"
          ],
          "line": 3767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg2",
            "1"
          ],
          "line": 3765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg1",
            "0"
          ],
          "line": 3764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "VARDATA_ANY(arg1)",
            "VARDATA_ANY(arg2)",
            "Min(len1, len2)"
          ],
          "line": 3762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "len1",
            "len2"
          ],
          "line": 3762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "arg2"
          ],
          "line": 3762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "arg1"
          ],
          "line": 3762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "arg2"
          ],
          "line": 3760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "arg1"
          ],
          "line": 3759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BYTEA_PP",
          "args": [
            "1"
          ],
          "line": 3754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BYTEA_PP",
          "args": [
            "0"
          ],
          "line": 3753
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\n\nDatum\nbyteage(PG_FUNCTION_ARGS)\n{\n\tbytea\t   *arg1 = PG_GETARG_BYTEA_PP(0);\n\tbytea\t   *arg2 = PG_GETARG_BYTEA_PP(1);\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\tint\t\t\tcmp;\n\n\tlen1 = VARSIZE_ANY_EXHDR(arg1);\n\tlen2 = VARSIZE_ANY_EXHDR(arg2);\n\n\tcmp = memcmp(VARDATA_ANY(arg1), VARDATA_ANY(arg2), Min(len1, len2));\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_BOOL((cmp > 0) || ((cmp == 0) && (len1 >= len2)));\n}"
  },
  {
    "function_name": "byteagt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "3730-3748",
    "snippet": "Datum\nbyteagt(PG_FUNCTION_ARGS)\n{\n\tbytea\t   *arg1 = PG_GETARG_BYTEA_PP(0);\n\tbytea\t   *arg2 = PG_GETARG_BYTEA_PP(1);\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\tint\t\t\tcmp;\n\n\tlen1 = VARSIZE_ANY_EXHDR(arg1);\n\tlen2 = VARSIZE_ANY_EXHDR(arg2);\n\n\tcmp = memcmp(VARDATA_ANY(arg1), VARDATA_ANY(arg2), Min(len1, len2));\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_BOOL((cmp > 0) || ((cmp == 0) && (len1 > len2)));\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "(cmp > 0) || ((cmp == 0) && (len1 > len2))"
          ],
          "line": 3747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg2",
            "1"
          ],
          "line": 3745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg1",
            "0"
          ],
          "line": 3744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "VARDATA_ANY(arg1)",
            "VARDATA_ANY(arg2)",
            "Min(len1, len2)"
          ],
          "line": 3742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "len1",
            "len2"
          ],
          "line": 3742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "arg2"
          ],
          "line": 3742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "arg1"
          ],
          "line": 3742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "arg2"
          ],
          "line": 3740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "arg1"
          ],
          "line": 3739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BYTEA_PP",
          "args": [
            "1"
          ],
          "line": 3734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BYTEA_PP",
          "args": [
            "0"
          ],
          "line": 3733
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\n\nDatum\nbyteagt(PG_FUNCTION_ARGS)\n{\n\tbytea\t   *arg1 = PG_GETARG_BYTEA_PP(0);\n\tbytea\t   *arg2 = PG_GETARG_BYTEA_PP(1);\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\tint\t\t\tcmp;\n\n\tlen1 = VARSIZE_ANY_EXHDR(arg1);\n\tlen2 = VARSIZE_ANY_EXHDR(arg2);\n\n\tcmp = memcmp(VARDATA_ANY(arg1), VARDATA_ANY(arg2), Min(len1, len2));\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_BOOL((cmp > 0) || ((cmp == 0) && (len1 > len2)));\n}"
  },
  {
    "function_name": "byteale",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "3710-3728",
    "snippet": "Datum\nbyteale(PG_FUNCTION_ARGS)\n{\n\tbytea\t   *arg1 = PG_GETARG_BYTEA_PP(0);\n\tbytea\t   *arg2 = PG_GETARG_BYTEA_PP(1);\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\tint\t\t\tcmp;\n\n\tlen1 = VARSIZE_ANY_EXHDR(arg1);\n\tlen2 = VARSIZE_ANY_EXHDR(arg2);\n\n\tcmp = memcmp(VARDATA_ANY(arg1), VARDATA_ANY(arg2), Min(len1, len2));\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_BOOL((cmp < 0) || ((cmp == 0) && (len1 <= len2)));\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "(cmp < 0) || ((cmp == 0) && (len1 <= len2))"
          ],
          "line": 3727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg2",
            "1"
          ],
          "line": 3725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg1",
            "0"
          ],
          "line": 3724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "VARDATA_ANY(arg1)",
            "VARDATA_ANY(arg2)",
            "Min(len1, len2)"
          ],
          "line": 3722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "len1",
            "len2"
          ],
          "line": 3722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "arg2"
          ],
          "line": 3722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "arg1"
          ],
          "line": 3722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "arg2"
          ],
          "line": 3720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "arg1"
          ],
          "line": 3719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BYTEA_PP",
          "args": [
            "1"
          ],
          "line": 3714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BYTEA_PP",
          "args": [
            "0"
          ],
          "line": 3713
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\n\nDatum\nbyteale(PG_FUNCTION_ARGS)\n{\n\tbytea\t   *arg1 = PG_GETARG_BYTEA_PP(0);\n\tbytea\t   *arg2 = PG_GETARG_BYTEA_PP(1);\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\tint\t\t\tcmp;\n\n\tlen1 = VARSIZE_ANY_EXHDR(arg1);\n\tlen2 = VARSIZE_ANY_EXHDR(arg2);\n\n\tcmp = memcmp(VARDATA_ANY(arg1), VARDATA_ANY(arg2), Min(len1, len2));\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_BOOL((cmp < 0) || ((cmp == 0) && (len1 <= len2)));\n}"
  },
  {
    "function_name": "bytealt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "3690-3708",
    "snippet": "Datum\nbytealt(PG_FUNCTION_ARGS)\n{\n\tbytea\t   *arg1 = PG_GETARG_BYTEA_PP(0);\n\tbytea\t   *arg2 = PG_GETARG_BYTEA_PP(1);\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\tint\t\t\tcmp;\n\n\tlen1 = VARSIZE_ANY_EXHDR(arg1);\n\tlen2 = VARSIZE_ANY_EXHDR(arg2);\n\n\tcmp = memcmp(VARDATA_ANY(arg1), VARDATA_ANY(arg2), Min(len1, len2));\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_BOOL((cmp < 0) || ((cmp == 0) && (len1 < len2)));\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "(cmp < 0) || ((cmp == 0) && (len1 < len2))"
          ],
          "line": 3707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg2",
            "1"
          ],
          "line": 3705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg1",
            "0"
          ],
          "line": 3704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "VARDATA_ANY(arg1)",
            "VARDATA_ANY(arg2)",
            "Min(len1, len2)"
          ],
          "line": 3702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "len1",
            "len2"
          ],
          "line": 3702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "arg2"
          ],
          "line": 3702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "arg1"
          ],
          "line": 3702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "arg2"
          ],
          "line": 3700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "arg1"
          ],
          "line": 3699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BYTEA_PP",
          "args": [
            "1"
          ],
          "line": 3694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BYTEA_PP",
          "args": [
            "0"
          ],
          "line": 3693
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\n\nDatum\nbytealt(PG_FUNCTION_ARGS)\n{\n\tbytea\t   *arg1 = PG_GETARG_BYTEA_PP(0);\n\tbytea\t   *arg2 = PG_GETARG_BYTEA_PP(1);\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\tint\t\t\tcmp;\n\n\tlen1 = VARSIZE_ANY_EXHDR(arg1);\n\tlen2 = VARSIZE_ANY_EXHDR(arg2);\n\n\tcmp = memcmp(VARDATA_ANY(arg1), VARDATA_ANY(arg2), Min(len1, len2));\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_BOOL((cmp < 0) || ((cmp == 0) && (len1 < len2)));\n}"
  },
  {
    "function_name": "byteane",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "3658-3688",
    "snippet": "Datum\nbyteane(PG_FUNCTION_ARGS)\n{\n\tDatum\t\targ1 = PG_GETARG_DATUM(0);\n\tDatum\t\targ2 = PG_GETARG_DATUM(1);\n\tbool\t\tresult;\n\tSize\t\tlen1,\n\t\t\t\tlen2;\n\n\t/*\n\t * We can use a fast path for unequal lengths, which might save us from\n\t * having to detoast one or both values.\n\t */\n\tlen1 = toast_raw_datum_size(arg1);\n\tlen2 = toast_raw_datum_size(arg2);\n\tif (len1 != len2)\n\t\tresult = true;\n\telse\n\t{\n\t\tbytea\t   *barg1 = DatumGetByteaPP(arg1);\n\t\tbytea\t   *barg2 = DatumGetByteaPP(arg2);\n\n\t\tresult = (memcmp(VARDATA_ANY(barg1), VARDATA_ANY(barg2),\n\t\t\t\t\t\t len1 - VARHDRSZ) != 0);\n\n\t\tPG_FREE_IF_COPY(barg1, 0);\n\t\tPG_FREE_IF_COPY(barg2, 1);\n\t}\n\n\tPG_RETURN_BOOL(result);\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "result"
          ],
          "line": 3687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "barg2",
            "1"
          ],
          "line": 3684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "barg1",
            "0"
          ],
          "line": 3683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "VARDATA_ANY(barg1)",
            "VARDATA_ANY(barg2)",
            "len1 - VARHDRSZ"
          ],
          "line": 3680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "barg2"
          ],
          "line": 3680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "barg1"
          ],
          "line": 3680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetByteaPP",
          "args": [
            "arg2"
          ],
          "line": 3678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetByteaPP",
          "args": [
            "arg1"
          ],
          "line": 3677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toast_raw_datum_size",
          "args": [
            "arg2"
          ],
          "line": 3672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toast_raw_datum_size",
          "args": [
            "arg1"
          ],
          "line": 3671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "1"
          ],
          "line": 3662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "0"
          ],
          "line": 3661
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\n\nDatum\nbyteane(PG_FUNCTION_ARGS)\n{\n\tDatum\t\targ1 = PG_GETARG_DATUM(0);\n\tDatum\t\targ2 = PG_GETARG_DATUM(1);\n\tbool\t\tresult;\n\tSize\t\tlen1,\n\t\t\t\tlen2;\n\n\t/*\n\t * We can use a fast path for unequal lengths, which might save us from\n\t * having to detoast one or both values.\n\t */\n\tlen1 = toast_raw_datum_size(arg1);\n\tlen2 = toast_raw_datum_size(arg2);\n\tif (len1 != len2)\n\t\tresult = true;\n\telse\n\t{\n\t\tbytea\t   *barg1 = DatumGetByteaPP(arg1);\n\t\tbytea\t   *barg2 = DatumGetByteaPP(arg2);\n\n\t\tresult = (memcmp(VARDATA_ANY(barg1), VARDATA_ANY(barg2),\n\t\t\t\t\t\t len1 - VARHDRSZ) != 0);\n\n\t\tPG_FREE_IF_COPY(barg1, 0);\n\t\tPG_FREE_IF_COPY(barg2, 1);\n\t}\n\n\tPG_RETURN_BOOL(result);\n}"
  },
  {
    "function_name": "byteaeq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "3626-3656",
    "snippet": "Datum\nbyteaeq(PG_FUNCTION_ARGS)\n{\n\tDatum\t\targ1 = PG_GETARG_DATUM(0);\n\tDatum\t\targ2 = PG_GETARG_DATUM(1);\n\tbool\t\tresult;\n\tSize\t\tlen1,\n\t\t\t\tlen2;\n\n\t/*\n\t * We can use a fast path for unequal lengths, which might save us from\n\t * having to detoast one or both values.\n\t */\n\tlen1 = toast_raw_datum_size(arg1);\n\tlen2 = toast_raw_datum_size(arg2);\n\tif (len1 != len2)\n\t\tresult = false;\n\telse\n\t{\n\t\tbytea\t   *barg1 = DatumGetByteaPP(arg1);\n\t\tbytea\t   *barg2 = DatumGetByteaPP(arg2);\n\n\t\tresult = (memcmp(VARDATA_ANY(barg1), VARDATA_ANY(barg2),\n\t\t\t\t\t\t len1 - VARHDRSZ) == 0);\n\n\t\tPG_FREE_IF_COPY(barg1, 0);\n\t\tPG_FREE_IF_COPY(barg2, 1);\n\t}\n\n\tPG_RETURN_BOOL(result);\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "result"
          ],
          "line": 3655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "barg2",
            "1"
          ],
          "line": 3652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "barg1",
            "0"
          ],
          "line": 3651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "VARDATA_ANY(barg1)",
            "VARDATA_ANY(barg2)",
            "len1 - VARHDRSZ"
          ],
          "line": 3648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "barg2"
          ],
          "line": 3648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "barg1"
          ],
          "line": 3648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetByteaPP",
          "args": [
            "arg2"
          ],
          "line": 3646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetByteaPP",
          "args": [
            "arg1"
          ],
          "line": 3645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toast_raw_datum_size",
          "args": [
            "arg2"
          ],
          "line": 3640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toast_raw_datum_size",
          "args": [
            "arg1"
          ],
          "line": 3639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "1"
          ],
          "line": 3630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "0"
          ],
          "line": 3629
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\n\nDatum\nbyteaeq(PG_FUNCTION_ARGS)\n{\n\tDatum\t\targ1 = PG_GETARG_DATUM(0);\n\tDatum\t\targ2 = PG_GETARG_DATUM(1);\n\tbool\t\tresult;\n\tSize\t\tlen1,\n\t\t\t\tlen2;\n\n\t/*\n\t * We can use a fast path for unequal lengths, which might save us from\n\t * having to detoast one or both values.\n\t */\n\tlen1 = toast_raw_datum_size(arg1);\n\tlen2 = toast_raw_datum_size(arg2);\n\tif (len1 != len2)\n\t\tresult = false;\n\telse\n\t{\n\t\tbytea\t   *barg1 = DatumGetByteaPP(arg1);\n\t\tbytea\t   *barg2 = DatumGetByteaPP(arg2);\n\n\t\tresult = (memcmp(VARDATA_ANY(barg1), VARDATA_ANY(barg2),\n\t\t\t\t\t\t len1 - VARHDRSZ) == 0);\n\n\t\tPG_FREE_IF_COPY(barg1, 0);\n\t\tPG_FREE_IF_COPY(barg2, 1);\n\t}\n\n\tPG_RETURN_BOOL(result);\n}"
  },
  {
    "function_name": "SplitGUCList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "3537-3615",
    "snippet": "bool\nSplitGUCList(char *rawstring, char separator,\n\t\t\t List **namelist)\n{\n\tchar\t   *nextp = rawstring;\n\tbool\t\tdone = false;\n\n\t*namelist = NIL;\n\n\twhile (scanner_isspace(*nextp))\n\t\tnextp++;\t\t\t\t/* skip leading whitespace */\n\n\tif (*nextp == '\\0')\n\t\treturn true;\t\t\t/* allow empty string */\n\n\t/* At the top of the loop, we are at start of a new identifier. */\n\tdo\n\t{\n\t\tchar\t   *curname;\n\t\tchar\t   *endp;\n\n\t\tif (*nextp == '\"')\n\t\t{\n\t\t\t/* Quoted name --- collapse quote-quote pairs */\n\t\t\tcurname = nextp + 1;\n\t\t\tfor (;;)\n\t\t\t{\n\t\t\t\tendp = strchr(nextp + 1, '\"');\n\t\t\t\tif (endp == NULL)\n\t\t\t\t\treturn false;\t/* mismatched quotes */\n\t\t\t\tif (endp[1] != '\"')\n\t\t\t\t\tbreak;\t\t/* found end of quoted name */\n\t\t\t\t/* Collapse adjacent quotes into one quote, and look again */\n\t\t\t\tmemmove(endp, endp + 1, strlen(endp));\n\t\t\t\tnextp = endp;\n\t\t\t}\n\t\t\t/* endp now points at the terminating quote */\n\t\t\tnextp = endp + 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Unquoted name --- extends to separator or whitespace */\n\t\t\tcurname = nextp;\n\t\t\twhile (*nextp && *nextp != separator &&\n\t\t\t\t   !scanner_isspace(*nextp))\n\t\t\t\tnextp++;\n\t\t\tendp = nextp;\n\t\t\tif (curname == nextp)\n\t\t\t\treturn false;\t/* empty unquoted name not allowed */\n\t\t}\n\n\t\twhile (scanner_isspace(*nextp))\n\t\t\tnextp++;\t\t\t/* skip trailing whitespace */\n\n\t\tif (*nextp == separator)\n\t\t{\n\t\t\tnextp++;\n\t\t\twhile (scanner_isspace(*nextp))\n\t\t\t\tnextp++;\t\t/* skip leading whitespace for next */\n\t\t\t/* we expect another name, so done remains false */\n\t\t}\n\t\telse if (*nextp == '\\0')\n\t\t\tdone = true;\n\t\telse\n\t\t\treturn false;\t\t/* invalid syntax */\n\n\t\t/* Now safe to overwrite separator with a null */\n\t\t*endp = '\\0';\n\n\t\t/*\n\t\t * Finished isolating current name --- add it to list\n\t\t */\n\t\t*namelist = lappend(*namelist, curname);\n\n\t\t/* Loop back if we didn't reach end of string */\n\t} while (!done);\n\n\treturn true;\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void appendStringInfoText(StringInfo str, const text *t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lappend",
          "args": [
            "*namelist",
            "curname"
          ],
          "line": 3609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scanner_isspace",
          "args": [
            "*nextp"
          ],
          "line": 3594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scanner_isspace",
          "args": [
            "*nextp"
          ],
          "line": 3588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scanner_isspace",
          "args": [
            "*nextp"
          ],
          "line": 3581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "endp",
            "endp + 1",
            "strlen(endp)"
          ],
          "line": 3570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "endp"
          ],
          "line": 3570
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "nextp + 1",
            "'\"'"
          ],
          "line": 3564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scanner_isspace",
          "args": [
            "*nextp"
          ],
          "line": 3546
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nbool\nSplitGUCList(char *rawstring, char separator,\n\t\t\t List **namelist)\n{\n\tchar\t   *nextp = rawstring;\n\tbool\t\tdone = false;\n\n\t*namelist = NIL;\n\n\twhile (scanner_isspace(*nextp))\n\t\tnextp++;\t\t\t\t/* skip leading whitespace */\n\n\tif (*nextp == '\\0')\n\t\treturn true;\t\t\t/* allow empty string */\n\n\t/* At the top of the loop, we are at start of a new identifier. */\n\tdo\n\t{\n\t\tchar\t   *curname;\n\t\tchar\t   *endp;\n\n\t\tif (*nextp == '\"')\n\t\t{\n\t\t\t/* Quoted name --- collapse quote-quote pairs */\n\t\t\tcurname = nextp + 1;\n\t\t\tfor (;;)\n\t\t\t{\n\t\t\t\tendp = strchr(nextp + 1, '\"');\n\t\t\t\tif (endp == NULL)\n\t\t\t\t\treturn false;\t/* mismatched quotes */\n\t\t\t\tif (endp[1] != '\"')\n\t\t\t\t\tbreak;\t\t/* found end of quoted name */\n\t\t\t\t/* Collapse adjacent quotes into one quote, and look again */\n\t\t\t\tmemmove(endp, endp + 1, strlen(endp));\n\t\t\t\tnextp = endp;\n\t\t\t}\n\t\t\t/* endp now points at the terminating quote */\n\t\t\tnextp = endp + 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Unquoted name --- extends to separator or whitespace */\n\t\t\tcurname = nextp;\n\t\t\twhile (*nextp && *nextp != separator &&\n\t\t\t\t   !scanner_isspace(*nextp))\n\t\t\t\tnextp++;\n\t\t\tendp = nextp;\n\t\t\tif (curname == nextp)\n\t\t\t\treturn false;\t/* empty unquoted name not allowed */\n\t\t}\n\n\t\twhile (scanner_isspace(*nextp))\n\t\t\tnextp++;\t\t\t/* skip trailing whitespace */\n\n\t\tif (*nextp == separator)\n\t\t{\n\t\t\tnextp++;\n\t\t\twhile (scanner_isspace(*nextp))\n\t\t\t\tnextp++;\t\t/* skip leading whitespace for next */\n\t\t\t/* we expect another name, so done remains false */\n\t\t}\n\t\telse if (*nextp == '\\0')\n\t\t\tdone = true;\n\t\telse\n\t\t\treturn false;\t\t/* invalid syntax */\n\n\t\t/* Now safe to overwrite separator with a null */\n\t\t*endp = '\\0';\n\n\t\t/*\n\t\t * Finished isolating current name --- add it to list\n\t\t */\n\t\t*namelist = lappend(*namelist, curname);\n\n\t\t/* Loop back if we didn't reach end of string */\n\t} while (!done);\n\n\treturn true;\n}"
  },
  {
    "function_name": "SplitDirectoriesString",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "3416-3503",
    "snippet": "bool\nSplitDirectoriesString(char *rawstring, char separator,\n\t\t\t\t\t   List **namelist)\n{\n\tchar\t   *nextp = rawstring;\n\tbool\t\tdone = false;\n\n\t*namelist = NIL;\n\n\twhile (scanner_isspace(*nextp))\n\t\tnextp++;\t\t\t\t/* skip leading whitespace */\n\n\tif (*nextp == '\\0')\n\t\treturn true;\t\t\t/* allow empty string */\n\n\t/* At the top of the loop, we are at start of a new directory. */\n\tdo\n\t{\n\t\tchar\t   *curname;\n\t\tchar\t   *endp;\n\n\t\tif (*nextp == '\"')\n\t\t{\n\t\t\t/* Quoted name --- collapse quote-quote pairs */\n\t\t\tcurname = nextp + 1;\n\t\t\tfor (;;)\n\t\t\t{\n\t\t\t\tendp = strchr(nextp + 1, '\"');\n\t\t\t\tif (endp == NULL)\n\t\t\t\t\treturn false;\t/* mismatched quotes */\n\t\t\t\tif (endp[1] != '\"')\n\t\t\t\t\tbreak;\t\t/* found end of quoted name */\n\t\t\t\t/* Collapse adjacent quotes into one quote, and look again */\n\t\t\t\tmemmove(endp, endp + 1, strlen(endp));\n\t\t\t\tnextp = endp;\n\t\t\t}\n\t\t\t/* endp now points at the terminating quote */\n\t\t\tnextp = endp + 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Unquoted name --- extends to separator or end of string */\n\t\t\tcurname = endp = nextp;\n\t\t\twhile (*nextp && *nextp != separator)\n\t\t\t{\n\t\t\t\t/* trailing whitespace should not be included in name */\n\t\t\t\tif (!scanner_isspace(*nextp))\n\t\t\t\t\tendp = nextp + 1;\n\t\t\t\tnextp++;\n\t\t\t}\n\t\t\tif (curname == endp)\n\t\t\t\treturn false;\t/* empty unquoted name not allowed */\n\t\t}\n\n\t\twhile (scanner_isspace(*nextp))\n\t\t\tnextp++;\t\t\t/* skip trailing whitespace */\n\n\t\tif (*nextp == separator)\n\t\t{\n\t\t\tnextp++;\n\t\t\twhile (scanner_isspace(*nextp))\n\t\t\t\tnextp++;\t\t/* skip leading whitespace for next */\n\t\t\t/* we expect another name, so done remains false */\n\t\t}\n\t\telse if (*nextp == '\\0')\n\t\t\tdone = true;\n\t\telse\n\t\t\treturn false;\t\t/* invalid syntax */\n\n\t\t/* Now safe to overwrite separator with a null */\n\t\t*endp = '\\0';\n\n\t\t/* Truncate path if it's overlength */\n\t\tif (strlen(curname) >= MAXPGPATH)\n\t\t\tcurname[MAXPGPATH - 1] = '\\0';\n\n\t\t/*\n\t\t * Finished isolating current name --- add it to list\n\t\t */\n\t\tcurname = pstrdup(curname);\n\t\tcanonicalize_path(curname);\n\t\t*namelist = lappend(*namelist, curname);\n\n\t\t/* Loop back if we didn't reach end of string */\n\t} while (!done);\n\n\treturn true;\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void appendStringInfoText(StringInfo str, const text *t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lappend",
          "args": [
            "*namelist",
            "curname"
          ],
          "line": 3497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "canonicalize_path",
          "args": [
            "curname"
          ],
          "line": 3496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pstrdup",
          "args": [
            "curname"
          ],
          "line": 3495
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1658-1662",
          "snippet": "static char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "curname"
          ],
          "line": 3489
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "scanner_isspace",
          "args": [
            "*nextp"
          ],
          "line": 3476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scanner_isspace",
          "args": [
            "*nextp"
          ],
          "line": 3470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scanner_isspace",
          "args": [
            "*nextp"
          ],
          "line": 3462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "endp",
            "endp + 1",
            "strlen(endp)"
          ],
          "line": 3449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "nextp + 1",
            "'\"'"
          ],
          "line": 3443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scanner_isspace",
          "args": [
            "*nextp"
          ],
          "line": 3425
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nbool\nSplitDirectoriesString(char *rawstring, char separator,\n\t\t\t\t\t   List **namelist)\n{\n\tchar\t   *nextp = rawstring;\n\tbool\t\tdone = false;\n\n\t*namelist = NIL;\n\n\twhile (scanner_isspace(*nextp))\n\t\tnextp++;\t\t\t\t/* skip leading whitespace */\n\n\tif (*nextp == '\\0')\n\t\treturn true;\t\t\t/* allow empty string */\n\n\t/* At the top of the loop, we are at start of a new directory. */\n\tdo\n\t{\n\t\tchar\t   *curname;\n\t\tchar\t   *endp;\n\n\t\tif (*nextp == '\"')\n\t\t{\n\t\t\t/* Quoted name --- collapse quote-quote pairs */\n\t\t\tcurname = nextp + 1;\n\t\t\tfor (;;)\n\t\t\t{\n\t\t\t\tendp = strchr(nextp + 1, '\"');\n\t\t\t\tif (endp == NULL)\n\t\t\t\t\treturn false;\t/* mismatched quotes */\n\t\t\t\tif (endp[1] != '\"')\n\t\t\t\t\tbreak;\t\t/* found end of quoted name */\n\t\t\t\t/* Collapse adjacent quotes into one quote, and look again */\n\t\t\t\tmemmove(endp, endp + 1, strlen(endp));\n\t\t\t\tnextp = endp;\n\t\t\t}\n\t\t\t/* endp now points at the terminating quote */\n\t\t\tnextp = endp + 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Unquoted name --- extends to separator or end of string */\n\t\t\tcurname = endp = nextp;\n\t\t\twhile (*nextp && *nextp != separator)\n\t\t\t{\n\t\t\t\t/* trailing whitespace should not be included in name */\n\t\t\t\tif (!scanner_isspace(*nextp))\n\t\t\t\t\tendp = nextp + 1;\n\t\t\t\tnextp++;\n\t\t\t}\n\t\t\tif (curname == endp)\n\t\t\t\treturn false;\t/* empty unquoted name not allowed */\n\t\t}\n\n\t\twhile (scanner_isspace(*nextp))\n\t\t\tnextp++;\t\t\t/* skip trailing whitespace */\n\n\t\tif (*nextp == separator)\n\t\t{\n\t\t\tnextp++;\n\t\t\twhile (scanner_isspace(*nextp))\n\t\t\t\tnextp++;\t\t/* skip leading whitespace for next */\n\t\t\t/* we expect another name, so done remains false */\n\t\t}\n\t\telse if (*nextp == '\\0')\n\t\t\tdone = true;\n\t\telse\n\t\t\treturn false;\t\t/* invalid syntax */\n\n\t\t/* Now safe to overwrite separator with a null */\n\t\t*endp = '\\0';\n\n\t\t/* Truncate path if it's overlength */\n\t\tif (strlen(curname) >= MAXPGPATH)\n\t\t\tcurname[MAXPGPATH - 1] = '\\0';\n\n\t\t/*\n\t\t * Finished isolating current name --- add it to list\n\t\t */\n\t\tcurname = pstrdup(curname);\n\t\tcanonicalize_path(curname);\n\t\t*namelist = lappend(*namelist, curname);\n\n\t\t/* Loop back if we didn't reach end of string */\n\t} while (!done);\n\n\treturn true;\n}"
  },
  {
    "function_name": "SplitIdentifierString",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "3289-3388",
    "snippet": "bool\nSplitIdentifierString(char *rawstring, char separator,\n\t\t\t\t\t  List **namelist)\n{\n\tchar\t   *nextp = rawstring;\n\tbool\t\tdone = false;\n\n\t*namelist = NIL;\n\n\twhile (scanner_isspace(*nextp))\n\t\tnextp++;\t\t\t\t/* skip leading whitespace */\n\n\tif (*nextp == '\\0')\n\t\treturn true;\t\t\t/* allow empty string */\n\n\t/* At the top of the loop, we are at start of a new identifier. */\n\tdo\n\t{\n\t\tchar\t   *curname;\n\t\tchar\t   *endp;\n\n\t\tif (*nextp == '\"')\n\t\t{\n\t\t\t/* Quoted name --- collapse quote-quote pairs, no downcasing */\n\t\t\tcurname = nextp + 1;\n\t\t\tfor (;;)\n\t\t\t{\n\t\t\t\tendp = strchr(nextp + 1, '\"');\n\t\t\t\tif (endp == NULL)\n\t\t\t\t\treturn false;\t/* mismatched quotes */\n\t\t\t\tif (endp[1] != '\"')\n\t\t\t\t\tbreak;\t\t/* found end of quoted name */\n\t\t\t\t/* Collapse adjacent quotes into one quote, and look again */\n\t\t\t\tmemmove(endp, endp + 1, strlen(endp));\n\t\t\t\tnextp = endp;\n\t\t\t}\n\t\t\t/* endp now points at the terminating quote */\n\t\t\tnextp = endp + 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Unquoted name --- extends to separator or whitespace */\n\t\t\tchar\t   *downname;\n\t\t\tint\t\t\tlen;\n\n\t\t\tcurname = nextp;\n\t\t\twhile (*nextp && *nextp != separator &&\n\t\t\t\t   !scanner_isspace(*nextp))\n\t\t\t\tnextp++;\n\t\t\tendp = nextp;\n\t\t\tif (curname == nextp)\n\t\t\t\treturn false;\t/* empty unquoted name not allowed */\n\n\t\t\t/*\n\t\t\t * Downcase the identifier, using same code as main lexer does.\n\t\t\t *\n\t\t\t * XXX because we want to overwrite the input in-place, we cannot\n\t\t\t * support a downcasing transformation that increases the string\n\t\t\t * length.  This is not a problem given the current implementation\n\t\t\t * of downcase_truncate_identifier, but we'll probably have to do\n\t\t\t * something about this someday.\n\t\t\t */\n\t\t\tlen = endp - curname;\n\t\t\tdownname = downcase_truncate_identifier(curname, len, false);\n\t\t\tAssert(strlen(downname) <= len);\n\t\t\tstrncpy(curname, downname, len);\t/* strncpy is required here */\n\t\t\tpfree(downname);\n\t\t}\n\n\t\twhile (scanner_isspace(*nextp))\n\t\t\tnextp++;\t\t\t/* skip trailing whitespace */\n\n\t\tif (*nextp == separator)\n\t\t{\n\t\t\tnextp++;\n\t\t\twhile (scanner_isspace(*nextp))\n\t\t\t\tnextp++;\t\t/* skip leading whitespace for next */\n\t\t\t/* we expect another name, so done remains false */\n\t\t}\n\t\telse if (*nextp == '\\0')\n\t\t\tdone = true;\n\t\telse\n\t\t\treturn false;\t\t/* invalid syntax */\n\n\t\t/* Now safe to overwrite separator with a null */\n\t\t*endp = '\\0';\n\n\t\t/* Truncate name if it's overlength */\n\t\ttruncate_identifier(curname, strlen(curname), false);\n\n\t\t/*\n\t\t * Finished isolating current name --- add it to list\n\t\t */\n\t\t*namelist = lappend(*namelist, curname);\n\n\t\t/* Loop back if we didn't reach end of string */\n\t} while (!done);\n\n\treturn true;\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void appendStringInfoText(StringInfo str, const text *t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lappend",
          "args": [
            "*namelist",
            "curname"
          ],
          "line": 3382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "truncate_identifier",
          "args": [
            "curname",
            "strlen(curname)",
            "false"
          ],
          "line": 3377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "curname"
          ],
          "line": 3377
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "scanner_isspace",
          "args": [
            "*nextp"
          ],
          "line": 3364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scanner_isspace",
          "args": [
            "*nextp"
          ],
          "line": 3358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "downname"
          ],
          "line": 3355
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "curname",
            "downname",
            "len"
          ],
          "line": 3354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "strlen(downname) <= len"
          ],
          "line": 3353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "downcase_truncate_identifier",
          "args": [
            "curname",
            "len",
            "false"
          ],
          "line": 3352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scanner_isspace",
          "args": [
            "*nextp"
          ],
          "line": 3336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "endp",
            "endp + 1",
            "strlen(endp)"
          ],
          "line": 3322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "nextp + 1",
            "'\"'"
          ],
          "line": 3316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scanner_isspace",
          "args": [
            "*nextp"
          ],
          "line": 3298
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nbool\nSplitIdentifierString(char *rawstring, char separator,\n\t\t\t\t\t  List **namelist)\n{\n\tchar\t   *nextp = rawstring;\n\tbool\t\tdone = false;\n\n\t*namelist = NIL;\n\n\twhile (scanner_isspace(*nextp))\n\t\tnextp++;\t\t\t\t/* skip leading whitespace */\n\n\tif (*nextp == '\\0')\n\t\treturn true;\t\t\t/* allow empty string */\n\n\t/* At the top of the loop, we are at start of a new identifier. */\n\tdo\n\t{\n\t\tchar\t   *curname;\n\t\tchar\t   *endp;\n\n\t\tif (*nextp == '\"')\n\t\t{\n\t\t\t/* Quoted name --- collapse quote-quote pairs, no downcasing */\n\t\t\tcurname = nextp + 1;\n\t\t\tfor (;;)\n\t\t\t{\n\t\t\t\tendp = strchr(nextp + 1, '\"');\n\t\t\t\tif (endp == NULL)\n\t\t\t\t\treturn false;\t/* mismatched quotes */\n\t\t\t\tif (endp[1] != '\"')\n\t\t\t\t\tbreak;\t\t/* found end of quoted name */\n\t\t\t\t/* Collapse adjacent quotes into one quote, and look again */\n\t\t\t\tmemmove(endp, endp + 1, strlen(endp));\n\t\t\t\tnextp = endp;\n\t\t\t}\n\t\t\t/* endp now points at the terminating quote */\n\t\t\tnextp = endp + 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Unquoted name --- extends to separator or whitespace */\n\t\t\tchar\t   *downname;\n\t\t\tint\t\t\tlen;\n\n\t\t\tcurname = nextp;\n\t\t\twhile (*nextp && *nextp != separator &&\n\t\t\t\t   !scanner_isspace(*nextp))\n\t\t\t\tnextp++;\n\t\t\tendp = nextp;\n\t\t\tif (curname == nextp)\n\t\t\t\treturn false;\t/* empty unquoted name not allowed */\n\n\t\t\t/*\n\t\t\t * Downcase the identifier, using same code as main lexer does.\n\t\t\t *\n\t\t\t * XXX because we want to overwrite the input in-place, we cannot\n\t\t\t * support a downcasing transformation that increases the string\n\t\t\t * length.  This is not a problem given the current implementation\n\t\t\t * of downcase_truncate_identifier, but we'll probably have to do\n\t\t\t * something about this someday.\n\t\t\t */\n\t\t\tlen = endp - curname;\n\t\t\tdownname = downcase_truncate_identifier(curname, len, false);\n\t\t\tAssert(strlen(downname) <= len);\n\t\t\tstrncpy(curname, downname, len);\t/* strncpy is required here */\n\t\t\tpfree(downname);\n\t\t}\n\n\t\twhile (scanner_isspace(*nextp))\n\t\t\tnextp++;\t\t\t/* skip trailing whitespace */\n\n\t\tif (*nextp == separator)\n\t\t{\n\t\t\tnextp++;\n\t\t\twhile (scanner_isspace(*nextp))\n\t\t\t\tnextp++;\t\t/* skip leading whitespace for next */\n\t\t\t/* we expect another name, so done remains false */\n\t\t}\n\t\telse if (*nextp == '\\0')\n\t\t\tdone = true;\n\t\telse\n\t\t\treturn false;\t\t/* invalid syntax */\n\n\t\t/* Now safe to overwrite separator with a null */\n\t\t*endp = '\\0';\n\n\t\t/* Truncate name if it's overlength */\n\t\ttruncate_identifier(curname, strlen(curname), false);\n\n\t\t/*\n\t\t * Finished isolating current name --- add it to list\n\t\t */\n\t\t*namelist = lappend(*namelist, curname);\n\n\t\t/* Loop back if we didn't reach end of string */\n\t} while (!done);\n\n\treturn true;\n}"
  },
  {
    "function_name": "textToQualifiedNameList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "3231-3264",
    "snippet": "List *\ntextToQualifiedNameList(text *textval)\n{\n\tchar\t   *rawname;\n\tList\t   *result = NIL;\n\tList\t   *namelist;\n\tListCell   *l;\n\n\t/* Convert to C string (handles possible detoasting). */\n\t/* Note we rely on being able to modify rawname below. */\n\trawname = text_to_cstring(textval);\n\n\tif (!SplitIdentifierString(rawname, '.', &namelist))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tif (namelist == NIL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tforeach(l, namelist)\n\t{\n\t\tchar\t   *curname = (char *) lfirst(l);\n\n\t\tresult = lappend(result, makeString(pstrdup(curname)));\n\t}\n\n\tpfree(rawname);\n\tlist_free(namelist);\n\n\treturn result;\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_free",
          "args": [
            "namelist"
          ],
          "line": 3261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "rawname"
          ],
          "line": 3260
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lappend",
          "args": [
            "result",
            "makeString(pstrdup(curname))"
          ],
          "line": 3257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeString",
          "args": [
            "pstrdup(curname)"
          ],
          "line": 3257
        },
        "resolved": true,
        "details": {
          "function_name": "makeStringAggState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "4765-4787",
          "snippet": "static StringInfo\nmakeStringAggState(FunctionCallInfo fcinfo)\n{\n\tStringInfo\tstate;\n\tMemoryContext aggcontext;\n\tMemoryContext oldcontext;\n\n\tif (!AggCheckCallContext(fcinfo, &aggcontext))\n\t{\n\t\t/* cannot be called directly because of internal-type argument */\n\t\telog(ERROR, \"string_agg_transfn called in non-aggregate context\");\n\t}\n\n\t/*\n\t * Create state in aggregate context.  It'll stay there across subsequent\n\t * calls.\n\t */\n\toldcontext = MemoryContextSwitchTo(aggcontext);\n\tstate = makeStringInfo();\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn state;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void text_position_setup(text *t1, text *t2, TextPositionState *state);",
            "static int\ttext_position_next(int start_pos, TextPositionState *state);",
            "static void text_position_cleanup(TextPositionState *state);",
            "static StringInfo makeStringAggState(FunctionCallInfo fcinfo);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void text_position_setup(text *t1, text *t2, TextPositionState *state);\nstatic int\ttext_position_next(int start_pos, TextPositionState *state);\nstatic void text_position_cleanup(TextPositionState *state);\nstatic StringInfo makeStringAggState(FunctionCallInfo fcinfo);\n\nstatic StringInfo\nmakeStringAggState(FunctionCallInfo fcinfo)\n{\n\tStringInfo\tstate;\n\tMemoryContext aggcontext;\n\tMemoryContext oldcontext;\n\n\tif (!AggCheckCallContext(fcinfo, &aggcontext))\n\t{\n\t\t/* cannot be called directly because of internal-type argument */\n\t\telog(ERROR, \"string_agg_transfn called in non-aggregate context\");\n\t}\n\n\t/*\n\t * Create state in aggregate context.  It'll stay there across subsequent\n\t * calls.\n\t */\n\toldcontext = MemoryContextSwitchTo(aggcontext);\n\tstate = makeStringInfo();\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pstrdup",
          "args": [
            "curname"
          ],
          "line": 3257
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1658-1662",
          "snippet": "static char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lfirst",
          "args": [
            "l"
          ],
          "line": 3255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "l",
            "namelist"
          ],
          "line": 3253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\"))"
          ],
          "line": 3249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid name syntax\""
          ],
          "line": 3251
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_NAME"
          ],
          "line": 3250
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\"))"
          ],
          "line": 3244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SplitIdentifierString",
          "args": [
            "rawname",
            "'.'",
            "&namelist"
          ],
          "line": 3243
        },
        "resolved": true,
        "details": {
          "function_name": "SplitIdentifierString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "3289-3388",
          "snippet": "bool\nSplitIdentifierString(char *rawstring, char separator,\n\t\t\t\t\t  List **namelist)\n{\n\tchar\t   *nextp = rawstring;\n\tbool\t\tdone = false;\n\n\t*namelist = NIL;\n\n\twhile (scanner_isspace(*nextp))\n\t\tnextp++;\t\t\t\t/* skip leading whitespace */\n\n\tif (*nextp == '\\0')\n\t\treturn true;\t\t\t/* allow empty string */\n\n\t/* At the top of the loop, we are at start of a new identifier. */\n\tdo\n\t{\n\t\tchar\t   *curname;\n\t\tchar\t   *endp;\n\n\t\tif (*nextp == '\"')\n\t\t{\n\t\t\t/* Quoted name --- collapse quote-quote pairs, no downcasing */\n\t\t\tcurname = nextp + 1;\n\t\t\tfor (;;)\n\t\t\t{\n\t\t\t\tendp = strchr(nextp + 1, '\"');\n\t\t\t\tif (endp == NULL)\n\t\t\t\t\treturn false;\t/* mismatched quotes */\n\t\t\t\tif (endp[1] != '\"')\n\t\t\t\t\tbreak;\t\t/* found end of quoted name */\n\t\t\t\t/* Collapse adjacent quotes into one quote, and look again */\n\t\t\t\tmemmove(endp, endp + 1, strlen(endp));\n\t\t\t\tnextp = endp;\n\t\t\t}\n\t\t\t/* endp now points at the terminating quote */\n\t\t\tnextp = endp + 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Unquoted name --- extends to separator or whitespace */\n\t\t\tchar\t   *downname;\n\t\t\tint\t\t\tlen;\n\n\t\t\tcurname = nextp;\n\t\t\twhile (*nextp && *nextp != separator &&\n\t\t\t\t   !scanner_isspace(*nextp))\n\t\t\t\tnextp++;\n\t\t\tendp = nextp;\n\t\t\tif (curname == nextp)\n\t\t\t\treturn false;\t/* empty unquoted name not allowed */\n\n\t\t\t/*\n\t\t\t * Downcase the identifier, using same code as main lexer does.\n\t\t\t *\n\t\t\t * XXX because we want to overwrite the input in-place, we cannot\n\t\t\t * support a downcasing transformation that increases the string\n\t\t\t * length.  This is not a problem given the current implementation\n\t\t\t * of downcase_truncate_identifier, but we'll probably have to do\n\t\t\t * something about this someday.\n\t\t\t */\n\t\t\tlen = endp - curname;\n\t\t\tdownname = downcase_truncate_identifier(curname, len, false);\n\t\t\tAssert(strlen(downname) <= len);\n\t\t\tstrncpy(curname, downname, len);\t/* strncpy is required here */\n\t\t\tpfree(downname);\n\t\t}\n\n\t\twhile (scanner_isspace(*nextp))\n\t\t\tnextp++;\t\t\t/* skip trailing whitespace */\n\n\t\tif (*nextp == separator)\n\t\t{\n\t\t\tnextp++;\n\t\t\twhile (scanner_isspace(*nextp))\n\t\t\t\tnextp++;\t\t/* skip leading whitespace for next */\n\t\t\t/* we expect another name, so done remains false */\n\t\t}\n\t\telse if (*nextp == '\\0')\n\t\t\tdone = true;\n\t\telse\n\t\t\treturn false;\t\t/* invalid syntax */\n\n\t\t/* Now safe to overwrite separator with a null */\n\t\t*endp = '\\0';\n\n\t\t/* Truncate name if it's overlength */\n\t\ttruncate_identifier(curname, strlen(curname), false);\n\n\t\t/*\n\t\t * Finished isolating current name --- add it to list\n\t\t */\n\t\t*namelist = lappend(*namelist, curname);\n\n\t\t/* Loop back if we didn't reach end of string */\n\t} while (!done);\n\n\treturn true;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nbool\nSplitIdentifierString(char *rawstring, char separator,\n\t\t\t\t\t  List **namelist)\n{\n\tchar\t   *nextp = rawstring;\n\tbool\t\tdone = false;\n\n\t*namelist = NIL;\n\n\twhile (scanner_isspace(*nextp))\n\t\tnextp++;\t\t\t\t/* skip leading whitespace */\n\n\tif (*nextp == '\\0')\n\t\treturn true;\t\t\t/* allow empty string */\n\n\t/* At the top of the loop, we are at start of a new identifier. */\n\tdo\n\t{\n\t\tchar\t   *curname;\n\t\tchar\t   *endp;\n\n\t\tif (*nextp == '\"')\n\t\t{\n\t\t\t/* Quoted name --- collapse quote-quote pairs, no downcasing */\n\t\t\tcurname = nextp + 1;\n\t\t\tfor (;;)\n\t\t\t{\n\t\t\t\tendp = strchr(nextp + 1, '\"');\n\t\t\t\tif (endp == NULL)\n\t\t\t\t\treturn false;\t/* mismatched quotes */\n\t\t\t\tif (endp[1] != '\"')\n\t\t\t\t\tbreak;\t\t/* found end of quoted name */\n\t\t\t\t/* Collapse adjacent quotes into one quote, and look again */\n\t\t\t\tmemmove(endp, endp + 1, strlen(endp));\n\t\t\t\tnextp = endp;\n\t\t\t}\n\t\t\t/* endp now points at the terminating quote */\n\t\t\tnextp = endp + 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Unquoted name --- extends to separator or whitespace */\n\t\t\tchar\t   *downname;\n\t\t\tint\t\t\tlen;\n\n\t\t\tcurname = nextp;\n\t\t\twhile (*nextp && *nextp != separator &&\n\t\t\t\t   !scanner_isspace(*nextp))\n\t\t\t\tnextp++;\n\t\t\tendp = nextp;\n\t\t\tif (curname == nextp)\n\t\t\t\treturn false;\t/* empty unquoted name not allowed */\n\n\t\t\t/*\n\t\t\t * Downcase the identifier, using same code as main lexer does.\n\t\t\t *\n\t\t\t * XXX because we want to overwrite the input in-place, we cannot\n\t\t\t * support a downcasing transformation that increases the string\n\t\t\t * length.  This is not a problem given the current implementation\n\t\t\t * of downcase_truncate_identifier, but we'll probably have to do\n\t\t\t * something about this someday.\n\t\t\t */\n\t\t\tlen = endp - curname;\n\t\t\tdownname = downcase_truncate_identifier(curname, len, false);\n\t\t\tAssert(strlen(downname) <= len);\n\t\t\tstrncpy(curname, downname, len);\t/* strncpy is required here */\n\t\t\tpfree(downname);\n\t\t}\n\n\t\twhile (scanner_isspace(*nextp))\n\t\t\tnextp++;\t\t\t/* skip trailing whitespace */\n\n\t\tif (*nextp == separator)\n\t\t{\n\t\t\tnextp++;\n\t\t\twhile (scanner_isspace(*nextp))\n\t\t\t\tnextp++;\t\t/* skip leading whitespace for next */\n\t\t\t/* we expect another name, so done remains false */\n\t\t}\n\t\telse if (*nextp == '\\0')\n\t\t\tdone = true;\n\t\telse\n\t\t\treturn false;\t\t/* invalid syntax */\n\n\t\t/* Now safe to overwrite separator with a null */\n\t\t*endp = '\\0';\n\n\t\t/* Truncate name if it's overlength */\n\t\ttruncate_identifier(curname, strlen(curname), false);\n\n\t\t/*\n\t\t * Finished isolating current name --- add it to list\n\t\t */\n\t\t*namelist = lappend(*namelist, curname);\n\n\t\t/* Loop back if we didn't reach end of string */\n\t} while (!done);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "text_to_cstring",
          "args": [
            "textval"
          ],
          "line": 3241
        },
        "resolved": true,
        "details": {
          "function_name": "text_to_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "181-197",
          "snippet": "char *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nchar *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nList *\ntextToQualifiedNameList(text *textval)\n{\n\tchar\t   *rawname;\n\tList\t   *result = NIL;\n\tList\t   *namelist;\n\tListCell   *l;\n\n\t/* Convert to C string (handles possible detoasting). */\n\t/* Note we rely on being able to modify rawname below. */\n\trawname = text_to_cstring(textval);\n\n\tif (!SplitIdentifierString(rawname, '.', &namelist))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tif (namelist == NIL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tforeach(l, namelist)\n\t{\n\t\tchar\t   *curname = (char *) lfirst(l);\n\n\t\tresult = lappend(result, makeString(pstrdup(curname)));\n\t}\n\n\tpfree(rawname);\n\tlist_free(namelist);\n\n\treturn result;\n}"
  },
  {
    "function_name": "name_text",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "3214-3220",
    "snippet": "Datum\nname_text(PG_FUNCTION_ARGS)\n{\n\tName\t\ts = PG_GETARG_NAME(0);\n\n\tPG_RETURN_TEXT_P(cstring_to_text(NameStr(*s)));\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "cstring_to_text(NameStr(*s))"
          ],
          "line": 3219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cstring_to_text",
          "args": [
            "NameStr(*s)"
          ],
          "line": 3219
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "148-152",
          "snippet": "text *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}"
        }
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "*s"
          ],
          "line": 3219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_NAME",
          "args": [
            "0"
          ],
          "line": 3217
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\n\nDatum\nname_text(PG_FUNCTION_ARGS)\n{\n\tName\t\ts = PG_GETARG_NAME(0);\n\n\tPG_RETURN_TEXT_P(cstring_to_text(NameStr(*s)));\n}"
  },
  {
    "function_name": "text_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "3191-3209",
    "snippet": "Datum\ntext_name(PG_FUNCTION_ARGS)\n{\n\ttext\t   *s = PG_GETARG_TEXT_PP(0);\n\tName\t\tresult;\n\tint\t\t\tlen;\n\n\tlen = VARSIZE_ANY_EXHDR(s);\n\n\t/* Truncate oversize input */\n\tif (len >= NAMEDATALEN)\n\t\tlen = pg_mbcliplen(VARDATA_ANY(s), len, NAMEDATALEN - 1);\n\n\t/* We use palloc0 here to ensure result is zero-padded */\n\tresult = (Name) palloc0(NAMEDATALEN);\n\tmemcpy(NameStr(*result), VARDATA_ANY(s), len);\n\n\tPG_RETURN_NAME(result);\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_NAME",
          "args": [
            "result"
          ],
          "line": 3208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "NameStr(*result)",
            "VARDATA_ANY(s)",
            "len"
          ],
          "line": 3206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "s"
          ],
          "line": 3206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "*result"
          ],
          "line": 3206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "NAMEDATALEN"
          ],
          "line": 3205
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_mbcliplen",
          "args": [
            "VARDATA_ANY(s)",
            "len",
            "NAMEDATALEN - 1"
          ],
          "line": 3202
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mbcliplen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "819-824",
          "snippet": "int\npg_mbcliplen(const char *mbstr, int len, int limit)\n{\n\treturn pg_encoding_mbcliplen(DatabaseEncoding->encoding, mbstr,\n\t\t\t\t\t\t\t\t len, limit);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];",
            "static int\tcliplen(const char *str, int len, int limit);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\nstatic int\tcliplen(const char *str, int len, int limit);\n\nint\npg_mbcliplen(const char *mbstr, int len, int limit)\n{\n\treturn pg_encoding_mbcliplen(DatabaseEncoding->encoding, mbstr,\n\t\t\t\t\t\t\t\t len, limit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "s"
          ],
          "line": 3202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "s"
          ],
          "line": 3198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 3194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\n\nDatum\ntext_name(PG_FUNCTION_ARGS)\n{\n\ttext\t   *s = PG_GETARG_TEXT_PP(0);\n\tName\t\tresult;\n\tint\t\t\tlen;\n\n\tlen = VARSIZE_ANY_EXHDR(s);\n\n\t/* Truncate oversize input */\n\tif (len >= NAMEDATALEN)\n\t\tlen = pg_mbcliplen(VARDATA_ANY(s), len, NAMEDATALEN - 1);\n\n\t/* We use palloc0 here to ensure result is zero-padded */\n\tresult = (Name) palloc0(NAMEDATALEN);\n\tmemcpy(NameStr(*result), VARDATA_ANY(s), len);\n\n\tPG_RETURN_NAME(result);\n}"
  },
  {
    "function_name": "byteaSetBit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "3141-3185",
    "snippet": "Datum\nbyteaSetBit(PG_FUNCTION_ARGS)\n{\n\tbytea\t   *res = PG_GETARG_BYTEA_P_COPY(0);\n\tint32\t\tn = PG_GETARG_INT32(1);\n\tint32\t\tnewBit = PG_GETARG_INT32(2);\n\tint\t\t\tlen;\n\tint\t\t\toldByte,\n\t\t\t\tnewByte;\n\tint\t\t\tbyteNo,\n\t\t\t\tbitNo;\n\n\tlen = VARSIZE(res) - VARHDRSZ;\n\n\tif (n < 0 || n >= len * 8)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"index %d out of valid range, 0..%d\",\n\t\t\t\t\t\tn, len * 8 - 1)));\n\n\tbyteNo = n / 8;\n\tbitNo = n % 8;\n\n\t/*\n\t * sanity check!\n\t */\n\tif (newBit != 0 && newBit != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"new bit must be 0 or 1\")));\n\n\t/*\n\t * Update the byte.\n\t */\n\toldByte = ((unsigned char *) VARDATA(res))[byteNo];\n\n\tif (newBit == 0)\n\t\tnewByte = oldByte & (~(1 << bitNo));\n\telse\n\t\tnewByte = oldByte | (1 << bitNo);\n\n\t((unsigned char *) VARDATA(res))[byteNo] = newByte;\n\n\tPG_RETURN_BYTEA_P(res);\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BYTEA_P",
          "args": [
            "res"
          ],
          "line": 3184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA",
          "args": [
            "res"
          ],
          "line": 3182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA",
          "args": [
            "res"
          ],
          "line": 3175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"new bit must be 0 or 1\"))"
          ],
          "line": 3168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"new bit must be 0 or 1\""
          ],
          "line": 3170
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 3169
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"index %d out of valid range, 0..%d\",\n\t\t\t\t\t\tn, len * 8 - 1))"
          ],
          "line": 3156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "res"
          ],
          "line": 3153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "2"
          ],
          "line": 3146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "1"
          ],
          "line": 3145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BYTEA_P_COPY",
          "args": [
            "0"
          ],
          "line": 3144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\n\nDatum\nbyteaSetBit(PG_FUNCTION_ARGS)\n{\n\tbytea\t   *res = PG_GETARG_BYTEA_P_COPY(0);\n\tint32\t\tn = PG_GETARG_INT32(1);\n\tint32\t\tnewBit = PG_GETARG_INT32(2);\n\tint\t\t\tlen;\n\tint\t\t\toldByte,\n\t\t\t\tnewByte;\n\tint\t\t\tbyteNo,\n\t\t\t\tbitNo;\n\n\tlen = VARSIZE(res) - VARHDRSZ;\n\n\tif (n < 0 || n >= len * 8)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"index %d out of valid range, 0..%d\",\n\t\t\t\t\t\tn, len * 8 - 1)));\n\n\tbyteNo = n / 8;\n\tbitNo = n % 8;\n\n\t/*\n\t * sanity check!\n\t */\n\tif (newBit != 0 && newBit != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"new bit must be 0 or 1\")));\n\n\t/*\n\t * Update the byte.\n\t */\n\toldByte = ((unsigned char *) VARDATA(res))[byteNo];\n\n\tif (newBit == 0)\n\t\tnewByte = oldByte & (~(1 << bitNo));\n\telse\n\t\tnewByte = oldByte | (1 << bitNo);\n\n\t((unsigned char *) VARDATA(res))[byteNo] = newByte;\n\n\tPG_RETURN_BYTEA_P(res);\n}"
  },
  {
    "function_name": "byteaSetByte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "3109-3131",
    "snippet": "Datum\nbyteaSetByte(PG_FUNCTION_ARGS)\n{\n\tbytea\t   *res = PG_GETARG_BYTEA_P_COPY(0);\n\tint32\t\tn = PG_GETARG_INT32(1);\n\tint32\t\tnewByte = PG_GETARG_INT32(2);\n\tint\t\t\tlen;\n\n\tlen = VARSIZE(res) - VARHDRSZ;\n\n\tif (n < 0 || n >= len)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"index %d out of valid range, 0..%d\",\n\t\t\t\t\t\tn, len - 1)));\n\n\t/*\n\t * Now set the byte.\n\t */\n\t((unsigned char *) VARDATA(res))[n] = newByte;\n\n\tPG_RETURN_BYTEA_P(res);\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BYTEA_P",
          "args": [
            "res"
          ],
          "line": 3130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA",
          "args": [
            "res"
          ],
          "line": 3128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"index %d out of valid range, 0..%d\",\n\t\t\t\t\t\tn, len - 1))"
          ],
          "line": 3120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"index %d out of valid range, 0..%d\"",
            "n",
            "len - 1"
          ],
          "line": 3122
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_ARRAY_SUBSCRIPT_ERROR"
          ],
          "line": 3121
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "res"
          ],
          "line": 3117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "2"
          ],
          "line": 3114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "1"
          ],
          "line": 3113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BYTEA_P_COPY",
          "args": [
            "0"
          ],
          "line": 3112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\n\nDatum\nbyteaSetByte(PG_FUNCTION_ARGS)\n{\n\tbytea\t   *res = PG_GETARG_BYTEA_P_COPY(0);\n\tint32\t\tn = PG_GETARG_INT32(1);\n\tint32\t\tnewByte = PG_GETARG_INT32(2);\n\tint\t\t\tlen;\n\n\tlen = VARSIZE(res) - VARHDRSZ;\n\n\tif (n < 0 || n >= len)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"index %d out of valid range, 0..%d\",\n\t\t\t\t\t\tn, len - 1)));\n\n\t/*\n\t * Now set the byte.\n\t */\n\t((unsigned char *) VARDATA(res))[n] = newByte;\n\n\tPG_RETURN_BYTEA_P(res);\n}"
  },
  {
    "function_name": "byteaGetBit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "3072-3099",
    "snippet": "Datum\nbyteaGetBit(PG_FUNCTION_ARGS)\n{\n\tbytea\t   *v = PG_GETARG_BYTEA_PP(0);\n\tint32\t\tn = PG_GETARG_INT32(1);\n\tint\t\t\tbyteNo,\n\t\t\t\tbitNo;\n\tint\t\t\tlen;\n\tint\t\t\tbyte;\n\n\tlen = VARSIZE_ANY_EXHDR(v);\n\n\tif (n < 0 || n >= len * 8)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"index %d out of valid range, 0..%d\",\n\t\t\t\t\t\tn, len * 8 - 1)));\n\n\tbyteNo = n / 8;\n\tbitNo = n % 8;\n\n\tbyte = ((unsigned char *) VARDATA_ANY(v))[byteNo];\n\n\tif (byte & (1 << bitNo))\n\t\tPG_RETURN_INT32(1);\n\telse\n\t\tPG_RETURN_INT32(0);\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "0"
          ],
          "line": 3098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "1"
          ],
          "line": 3096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "v"
          ],
          "line": 3093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"index %d out of valid range, 0..%d\",\n\t\t\t\t\t\tn, len * 8 - 1))"
          ],
          "line": 3085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"index %d out of valid range, 0..%d\"",
            "n",
            "len * 8 - 1"
          ],
          "line": 3087
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_ARRAY_SUBSCRIPT_ERROR"
          ],
          "line": 3086
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "v"
          ],
          "line": 3082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "1"
          ],
          "line": 3076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BYTEA_PP",
          "args": [
            "0"
          ],
          "line": 3075
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\n\nDatum\nbyteaGetBit(PG_FUNCTION_ARGS)\n{\n\tbytea\t   *v = PG_GETARG_BYTEA_PP(0);\n\tint32\t\tn = PG_GETARG_INT32(1);\n\tint\t\t\tbyteNo,\n\t\t\t\tbitNo;\n\tint\t\t\tlen;\n\tint\t\t\tbyte;\n\n\tlen = VARSIZE_ANY_EXHDR(v);\n\n\tif (n < 0 || n >= len * 8)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"index %d out of valid range, 0..%d\",\n\t\t\t\t\t\tn, len * 8 - 1)));\n\n\tbyteNo = n / 8;\n\tbitNo = n % 8;\n\n\tbyte = ((unsigned char *) VARDATA_ANY(v))[byteNo];\n\n\tif (byte & (1 << bitNo))\n\t\tPG_RETURN_INT32(1);\n\telse\n\t\tPG_RETURN_INT32(0);\n}"
  },
  {
    "function_name": "byteaGetByte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "3043-3062",
    "snippet": "Datum\nbyteaGetByte(PG_FUNCTION_ARGS)\n{\n\tbytea\t   *v = PG_GETARG_BYTEA_PP(0);\n\tint32\t\tn = PG_GETARG_INT32(1);\n\tint\t\t\tlen;\n\tint\t\t\tbyte;\n\n\tlen = VARSIZE_ANY_EXHDR(v);\n\n\tif (n < 0 || n >= len)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"index %d out of valid range, 0..%d\",\n\t\t\t\t\t\tn, len - 1)));\n\n\tbyte = ((unsigned char *) VARDATA_ANY(v))[n];\n\n\tPG_RETURN_INT32(byte);\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "byte"
          ],
          "line": 3061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "v"
          ],
          "line": 3059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"index %d out of valid range, 0..%d\",\n\t\t\t\t\t\tn, len - 1))"
          ],
          "line": 3054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"index %d out of valid range, 0..%d\"",
            "n",
            "len - 1"
          ],
          "line": 3056
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_ARRAY_SUBSCRIPT_ERROR"
          ],
          "line": 3055
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "v"
          ],
          "line": 3051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "1"
          ],
          "line": 3047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BYTEA_PP",
          "args": [
            "0"
          ],
          "line": 3046
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\n\nDatum\nbyteaGetByte(PG_FUNCTION_ARGS)\n{\n\tbytea\t   *v = PG_GETARG_BYTEA_PP(0);\n\tint32\t\tn = PG_GETARG_INT32(1);\n\tint\t\t\tlen;\n\tint\t\t\tbyte;\n\n\tlen = VARSIZE_ANY_EXHDR(v);\n\n\tif (n < 0 || n >= len)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"index %d out of valid range, 0..%d\",\n\t\t\t\t\t\tn, len - 1)));\n\n\tbyte = ((unsigned char *) VARDATA_ANY(v))[n];\n\n\tPG_RETURN_INT32(byte);\n}"
  },
  {
    "function_name": "byteapos",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "2999-3034",
    "snippet": "Datum\nbyteapos(PG_FUNCTION_ARGS)\n{\n\tbytea\t   *t1 = PG_GETARG_BYTEA_PP(0);\n\tbytea\t   *t2 = PG_GETARG_BYTEA_PP(1);\n\tint\t\t\tpos;\n\tint\t\t\tpx,\n\t\t\t\tp;\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\tchar\t   *p1,\n\t\t\t   *p2;\n\n\tlen1 = VARSIZE_ANY_EXHDR(t1);\n\tlen2 = VARSIZE_ANY_EXHDR(t2);\n\n\tif (len2 <= 0)\n\t\tPG_RETURN_INT32(1);\t\t/* result for empty pattern */\n\n\tp1 = VARDATA_ANY(t1);\n\tp2 = VARDATA_ANY(t2);\n\n\tpos = 0;\n\tpx = (len1 - len2);\n\tfor (p = 0; p <= px; p++)\n\t{\n\t\tif ((*p2 == *p1) && (memcmp(p1, p2, len2) == 0))\n\t\t{\n\t\t\tpos = p + 1;\n\t\t\tbreak;\n\t\t};\n\t\tp1++;\n\t};\n\n\tPG_RETURN_INT32(pos);\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static text *text_catenate(text *t1, text *t2);",
      "static int\ttext_position(text *t1, text *t2);",
      "static bytea *bytea_catenate(bytea *t1, bytea *t2);",
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "pos"
          ],
          "line": 3033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "p1",
            "p2",
            "len2"
          ],
          "line": 3025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "t2"
          ],
          "line": 3019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "t1"
          ],
          "line": 3018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "1"
          ],
          "line": 3016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "t2"
          ],
          "line": 3013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "t1"
          ],
          "line": 3012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BYTEA_PP",
          "args": [
            "1"
          ],
          "line": 3003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BYTEA_PP",
          "args": [
            "0"
          ],
          "line": 3002
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic text *text_catenate(text *t1, text *t2);\nstatic int\ttext_position(text *t1, text *t2);\nstatic bytea *bytea_catenate(bytea *t1, bytea *t2);\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\n\nDatum\nbyteapos(PG_FUNCTION_ARGS)\n{\n\tbytea\t   *t1 = PG_GETARG_BYTEA_PP(0);\n\tbytea\t   *t2 = PG_GETARG_BYTEA_PP(1);\n\tint\t\t\tpos;\n\tint\t\t\tpx,\n\t\t\t\tp;\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\tchar\t   *p1,\n\t\t\t   *p2;\n\n\tlen1 = VARSIZE_ANY_EXHDR(t1);\n\tlen2 = VARSIZE_ANY_EXHDR(t2);\n\n\tif (len2 <= 0)\n\t\tPG_RETURN_INT32(1);\t\t/* result for empty pattern */\n\n\tp1 = VARDATA_ANY(t1);\n\tp2 = VARDATA_ANY(t2);\n\n\tpos = 0;\n\tpx = (len1 - len2);\n\tfor (p = 0; p <= px; p++)\n\t{\n\t\tif ((*p2 == *p1) && (memcmp(p1, p2, len2) == 0))\n\t\t{\n\t\t\tpos = p + 1;\n\t\t\tbreak;\n\t\t};\n\t\tp1++;\n\t};\n\n\tPG_RETURN_INT32(pos);\n}"
  },
  {
    "function_name": "bytea_overlay",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "2963-2991",
    "snippet": "static bytea *\nbytea_overlay(bytea *t1, bytea *t2, int sp, int sl)\n{\n\tbytea\t   *result;\n\tbytea\t   *s1;\n\tbytea\t   *s2;\n\tint\t\t\tsp_pl_sl;\n\n\t/*\n\t * Check for possible integer-overflow cases.  For negative sp, throw a\n\t * \"substring length\" error because that's what should be expected\n\t * according to the spec's definition of OVERLAY().\n\t */\n\tif (sp <= 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_SUBSTRING_ERROR),\n\t\t\t\t errmsg(\"negative substring length not allowed\")));\n\tif (pg_add_s32_overflow(sp, sl, &sp_pl_sl))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"integer out of range\")));\n\n\ts1 = bytea_substring(PointerGetDatum(t1), 1, sp - 1, false);\n\ts2 = bytea_substring(PointerGetDatum(t1), sp_pl_sl, -1, true);\n\tresult = bytea_catenate(s1, t2);\n\tresult = bytea_catenate(result, s2);\n\n\treturn result;\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static text *text_catenate(text *t1, text *t2);",
      "static text *text_overlay(text *t1, text *t2, int sp, int sl);",
      "static int\ttext_position(text *t1, text *t2);",
      "static bytea *bytea_catenate(bytea *t1, bytea *t2);",
      "static bytea *bytea_overlay(bytea *t1, bytea *t2, int sp, int sl);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bytea_catenate",
          "args": [
            "result",
            "s2"
          ],
          "line": 2988
        },
        "resolved": true,
        "details": {
          "function_name": "bytea_catenate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "2806-2838",
          "snippet": "static bytea *\nbytea_catenate(bytea *t1, bytea *t2)\n{\n\tbytea\t   *result;\n\tint\t\t\tlen1,\n\t\t\t\tlen2,\n\t\t\t\tlen;\n\tchar\t   *ptr;\n\n\tlen1 = VARSIZE_ANY_EXHDR(t1);\n\tlen2 = VARSIZE_ANY_EXHDR(t2);\n\n\t/* paranoia ... probably should throw error instead? */\n\tif (len1 < 0)\n\t\tlen1 = 0;\n\tif (len2 < 0)\n\t\tlen2 = 0;\n\n\tlen = len1 + len2 + VARHDRSZ;\n\tresult = (bytea *) palloc(len);\n\n\t/* Set size of result string... */\n\tSET_VARSIZE(result, len);\n\n\t/* Fill data field of result string... */\n\tptr = VARDATA(result);\n\tif (len1 > 0)\n\t\tmemcpy(ptr, VARDATA_ANY(t1), len1);\n\tif (len2 > 0)\n\t\tmemcpy(ptr + len1, VARDATA_ANY(t2), len2);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static text *text_catenate(text *t1, text *t2);",
            "static int\ttext_position(text *t1, text *t2);",
            "static bytea *bytea_catenate(bytea *t1, bytea *t2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic text *text_catenate(text *t1, text *t2);\nstatic int\ttext_position(text *t1, text *t2);\nstatic bytea *bytea_catenate(bytea *t1, bytea *t2);\n\nstatic bytea *\nbytea_catenate(bytea *t1, bytea *t2)\n{\n\tbytea\t   *result;\n\tint\t\t\tlen1,\n\t\t\t\tlen2,\n\t\t\t\tlen;\n\tchar\t   *ptr;\n\n\tlen1 = VARSIZE_ANY_EXHDR(t1);\n\tlen2 = VARSIZE_ANY_EXHDR(t2);\n\n\t/* paranoia ... probably should throw error instead? */\n\tif (len1 < 0)\n\t\tlen1 = 0;\n\tif (len2 < 0)\n\t\tlen2 = 0;\n\n\tlen = len1 + len2 + VARHDRSZ;\n\tresult = (bytea *) palloc(len);\n\n\t/* Set size of result string... */\n\tSET_VARSIZE(result, len);\n\n\t/* Fill data field of result string... */\n\tptr = VARDATA(result);\n\tif (len1 > 0)\n\t\tmemcpy(ptr, VARDATA_ANY(t1), len1);\n\tif (len2 > 0)\n\t\tmemcpy(ptr + len1, VARDATA_ANY(t2), len2);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bytea_substring",
          "args": [
            "PointerGetDatum(t1)",
            "sp_pl_sl",
            "-1",
            "true"
          ],
          "line": 2986
        },
        "resolved": true,
        "details": {
          "function_name": "bytea_substring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "2881-2931",
          "snippet": "static bytea *\nbytea_substring(Datum str,\n\t\t\t\tint S,\n\t\t\t\tint L,\n\t\t\t\tbool length_not_specified)\n{\n\tint\t\t\tS1;\t\t\t\t/* adjusted start position */\n\tint\t\t\tL1;\t\t\t\t/* adjusted substring length */\n\n\tS1 = Max(S, 1);\n\n\tif (length_not_specified)\n\t{\n\t\t/*\n\t\t * Not passed a length - DatumGetByteaPSlice() grabs everything to the\n\t\t * end of the string if we pass it a negative value for length.\n\t\t */\n\t\tL1 = -1;\n\t}\n\telse\n\t{\n\t\t/* end position */\n\t\tint\t\t\tE = S + L;\n\n\t\t/*\n\t\t * A negative value for L is the only way for the end position to be\n\t\t * before the start. SQL99 says to throw an error.\n\t\t */\n\t\tif (E < S)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_SUBSTRING_ERROR),\n\t\t\t\t\t errmsg(\"negative substring length not allowed\")));\n\n\t\t/*\n\t\t * A zero or negative value for the end position can happen if the\n\t\t * start was negative or one. SQL99 says to return a zero-length\n\t\t * string.\n\t\t */\n\t\tif (E < 1)\n\t\t\treturn PG_STR_GET_BYTEA(\"\");\n\n\t\tL1 = E - S1;\n\t}\n\n\t/*\n\t * If the start position is past the end of the string, SQL99 says to\n\t * return a zero-length string -- DatumGetByteaPSlice() will do that for\n\t * us. Convert to zero-based starting position\n\t */\n\treturn DatumGetByteaPSlice(str, S1 - 1, L1);\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int32 text_length(Datum str);",
            "static text *text_substring(Datum str,\n\t\t\t   int32 start,\n\t\t\t   int32 length,\n\t\t\t   bool length_not_specified);",
            "static bytea *bytea_substring(Datum str,\n\t\t\t\tint S,\n\t\t\t\tint L,\n\t\t\t\tbool length_not_specified);",
            "static bool text_format_parse_digits(const char **ptr, const char *end_ptr,\n\t\t\t\t\t\t int *value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int32 text_length(Datum str);\nstatic text *text_substring(Datum str,\n\t\t\t   int32 start,\n\t\t\t   int32 length,\n\t\t\t   bool length_not_specified);\nstatic bytea *bytea_substring(Datum str,\n\t\t\t\tint S,\n\t\t\t\tint L,\n\t\t\t\tbool length_not_specified);\nstatic bool text_format_parse_digits(const char **ptr, const char *end_ptr,\n\t\t\t\t\t\t int *value);\n\nstatic bytea *\nbytea_substring(Datum str,\n\t\t\t\tint S,\n\t\t\t\tint L,\n\t\t\t\tbool length_not_specified)\n{\n\tint\t\t\tS1;\t\t\t\t/* adjusted start position */\n\tint\t\t\tL1;\t\t\t\t/* adjusted substring length */\n\n\tS1 = Max(S, 1);\n\n\tif (length_not_specified)\n\t{\n\t\t/*\n\t\t * Not passed a length - DatumGetByteaPSlice() grabs everything to the\n\t\t * end of the string if we pass it a negative value for length.\n\t\t */\n\t\tL1 = -1;\n\t}\n\telse\n\t{\n\t\t/* end position */\n\t\tint\t\t\tE = S + L;\n\n\t\t/*\n\t\t * A negative value for L is the only way for the end position to be\n\t\t * before the start. SQL99 says to throw an error.\n\t\t */\n\t\tif (E < S)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_SUBSTRING_ERROR),\n\t\t\t\t\t errmsg(\"negative substring length not allowed\")));\n\n\t\t/*\n\t\t * A zero or negative value for the end position can happen if the\n\t\t * start was negative or one. SQL99 says to return a zero-length\n\t\t * string.\n\t\t */\n\t\tif (E < 1)\n\t\t\treturn PG_STR_GET_BYTEA(\"\");\n\n\t\tL1 = E - S1;\n\t}\n\n\t/*\n\t * If the start position is past the end of the string, SQL99 says to\n\t * return a zero-length string -- DatumGetByteaPSlice() will do that for\n\t * us. Convert to zero-based starting position\n\t */\n\treturn DatumGetByteaPSlice(str, S1 - 1, L1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "t1"
          ],
          "line": 2986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "t1"
          ],
          "line": 2985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"integer out of range\"))"
          ],
          "line": 2981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"integer out of range\""
          ],
          "line": 2983
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE"
          ],
          "line": 2982
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_add_s32_overflow",
          "args": [
            "sp",
            "sl",
            "&sp_pl_sl"
          ],
          "line": 2980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_SUBSTRING_ERROR),\n\t\t\t\t errmsg(\"negative substring length not allowed\"))"
          ],
          "line": 2977
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic text *text_catenate(text *t1, text *t2);\nstatic text *text_overlay(text *t1, text *t2, int sp, int sl);\nstatic int\ttext_position(text *t1, text *t2);\nstatic bytea *bytea_catenate(bytea *t1, bytea *t2);\nstatic bytea *bytea_overlay(bytea *t1, bytea *t2, int sp, int sl);\n\nstatic bytea *\nbytea_overlay(bytea *t1, bytea *t2, int sp, int sl)\n{\n\tbytea\t   *result;\n\tbytea\t   *s1;\n\tbytea\t   *s2;\n\tint\t\t\tsp_pl_sl;\n\n\t/*\n\t * Check for possible integer-overflow cases.  For negative sp, throw a\n\t * \"substring length\" error because that's what should be expected\n\t * according to the spec's definition of OVERLAY().\n\t */\n\tif (sp <= 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_SUBSTRING_ERROR),\n\t\t\t\t errmsg(\"negative substring length not allowed\")));\n\tif (pg_add_s32_overflow(sp, sl, &sp_pl_sl))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"integer out of range\")));\n\n\ts1 = bytea_substring(PointerGetDatum(t1), 1, sp - 1, false);\n\ts2 = bytea_substring(PointerGetDatum(t1), sp_pl_sl, -1, true);\n\tresult = bytea_catenate(s1, t2);\n\tresult = bytea_catenate(result, s2);\n\n\treturn result;\n}"
  },
  {
    "function_name": "byteaoverlay_no_len",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "2951-2961",
    "snippet": "Datum\nbyteaoverlay_no_len(PG_FUNCTION_ARGS)\n{\n\tbytea\t   *t1 = PG_GETARG_BYTEA_PP(0);\n\tbytea\t   *t2 = PG_GETARG_BYTEA_PP(1);\n\tint\t\t\tsp = PG_GETARG_INT32(2);\t/* substring start position */\n\tint\t\t\tsl;\n\n\tsl = VARSIZE_ANY_EXHDR(t2); /* defaults to length(t2) */\n\tPG_RETURN_BYTEA_P(bytea_overlay(t1, t2, sp, sl));\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static text *text_catenate(text *t1, text *t2);",
      "static text *text_overlay(text *t1, text *t2, int sp, int sl);",
      "static int\ttext_position(text *t1, text *t2);",
      "static bytea *bytea_catenate(bytea *t1, bytea *t2);",
      "static bytea *bytea_overlay(bytea *t1, bytea *t2, int sp, int sl);",
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BYTEA_P",
          "args": [
            "bytea_overlay(t1, t2, sp, sl)"
          ],
          "line": 2960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bytea_overlay",
          "args": [
            "t1",
            "t2",
            "sp",
            "sl"
          ],
          "line": 2960
        },
        "resolved": true,
        "details": {
          "function_name": "bytea_overlay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "2963-2991",
          "snippet": "static bytea *\nbytea_overlay(bytea *t1, bytea *t2, int sp, int sl)\n{\n\tbytea\t   *result;\n\tbytea\t   *s1;\n\tbytea\t   *s2;\n\tint\t\t\tsp_pl_sl;\n\n\t/*\n\t * Check for possible integer-overflow cases.  For negative sp, throw a\n\t * \"substring length\" error because that's what should be expected\n\t * according to the spec's definition of OVERLAY().\n\t */\n\tif (sp <= 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_SUBSTRING_ERROR),\n\t\t\t\t errmsg(\"negative substring length not allowed\")));\n\tif (pg_add_s32_overflow(sp, sl, &sp_pl_sl))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"integer out of range\")));\n\n\ts1 = bytea_substring(PointerGetDatum(t1), 1, sp - 1, false);\n\ts2 = bytea_substring(PointerGetDatum(t1), sp_pl_sl, -1, true);\n\tresult = bytea_catenate(s1, t2);\n\tresult = bytea_catenate(result, s2);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static text *text_catenate(text *t1, text *t2);",
            "static text *text_overlay(text *t1, text *t2, int sp, int sl);",
            "static int\ttext_position(text *t1, text *t2);",
            "static bytea *bytea_catenate(bytea *t1, bytea *t2);",
            "static bytea *bytea_overlay(bytea *t1, bytea *t2, int sp, int sl);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic text *text_catenate(text *t1, text *t2);\nstatic text *text_overlay(text *t1, text *t2, int sp, int sl);\nstatic int\ttext_position(text *t1, text *t2);\nstatic bytea *bytea_catenate(bytea *t1, bytea *t2);\nstatic bytea *bytea_overlay(bytea *t1, bytea *t2, int sp, int sl);\n\nstatic bytea *\nbytea_overlay(bytea *t1, bytea *t2, int sp, int sl)\n{\n\tbytea\t   *result;\n\tbytea\t   *s1;\n\tbytea\t   *s2;\n\tint\t\t\tsp_pl_sl;\n\n\t/*\n\t * Check for possible integer-overflow cases.  For negative sp, throw a\n\t * \"substring length\" error because that's what should be expected\n\t * according to the spec's definition of OVERLAY().\n\t */\n\tif (sp <= 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_SUBSTRING_ERROR),\n\t\t\t\t errmsg(\"negative substring length not allowed\")));\n\tif (pg_add_s32_overflow(sp, sl, &sp_pl_sl))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"integer out of range\")));\n\n\ts1 = bytea_substring(PointerGetDatum(t1), 1, sp - 1, false);\n\ts2 = bytea_substring(PointerGetDatum(t1), sp_pl_sl, -1, true);\n\tresult = bytea_catenate(s1, t2);\n\tresult = bytea_catenate(result, s2);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "t2"
          ],
          "line": 2959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "2"
          ],
          "line": 2956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BYTEA_PP",
          "args": [
            "1"
          ],
          "line": 2955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BYTEA_PP",
          "args": [
            "0"
          ],
          "line": 2954
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic text *text_catenate(text *t1, text *t2);\nstatic text *text_overlay(text *t1, text *t2, int sp, int sl);\nstatic int\ttext_position(text *t1, text *t2);\nstatic bytea *bytea_catenate(bytea *t1, bytea *t2);\nstatic bytea *bytea_overlay(bytea *t1, bytea *t2, int sp, int sl);\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\n\nDatum\nbyteaoverlay_no_len(PG_FUNCTION_ARGS)\n{\n\tbytea\t   *t1 = PG_GETARG_BYTEA_PP(0);\n\tbytea\t   *t2 = PG_GETARG_BYTEA_PP(1);\n\tint\t\t\tsp = PG_GETARG_INT32(2);\t/* substring start position */\n\tint\t\t\tsl;\n\n\tsl = VARSIZE_ANY_EXHDR(t2); /* defaults to length(t2) */\n\tPG_RETURN_BYTEA_P(bytea_overlay(t1, t2, sp, sl));\n}"
  },
  {
    "function_name": "byteaoverlay",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "2940-2949",
    "snippet": "Datum\nbyteaoverlay(PG_FUNCTION_ARGS)\n{\n\tbytea\t   *t1 = PG_GETARG_BYTEA_PP(0);\n\tbytea\t   *t2 = PG_GETARG_BYTEA_PP(1);\n\tint\t\t\tsp = PG_GETARG_INT32(2);\t/* substring start position */\n\tint\t\t\tsl = PG_GETARG_INT32(3);\t/* substring length */\n\n\tPG_RETURN_BYTEA_P(bytea_overlay(t1, t2, sp, sl));\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static text *text_catenate(text *t1, text *t2);",
      "static text *text_overlay(text *t1, text *t2, int sp, int sl);",
      "static int\ttext_position(text *t1, text *t2);",
      "static bytea *bytea_catenate(bytea *t1, bytea *t2);",
      "static bytea *bytea_overlay(bytea *t1, bytea *t2, int sp, int sl);",
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BYTEA_P",
          "args": [
            "bytea_overlay(t1, t2, sp, sl)"
          ],
          "line": 2948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bytea_overlay",
          "args": [
            "t1",
            "t2",
            "sp",
            "sl"
          ],
          "line": 2948
        },
        "resolved": true,
        "details": {
          "function_name": "bytea_overlay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "2963-2991",
          "snippet": "static bytea *\nbytea_overlay(bytea *t1, bytea *t2, int sp, int sl)\n{\n\tbytea\t   *result;\n\tbytea\t   *s1;\n\tbytea\t   *s2;\n\tint\t\t\tsp_pl_sl;\n\n\t/*\n\t * Check for possible integer-overflow cases.  For negative sp, throw a\n\t * \"substring length\" error because that's what should be expected\n\t * according to the spec's definition of OVERLAY().\n\t */\n\tif (sp <= 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_SUBSTRING_ERROR),\n\t\t\t\t errmsg(\"negative substring length not allowed\")));\n\tif (pg_add_s32_overflow(sp, sl, &sp_pl_sl))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"integer out of range\")));\n\n\ts1 = bytea_substring(PointerGetDatum(t1), 1, sp - 1, false);\n\ts2 = bytea_substring(PointerGetDatum(t1), sp_pl_sl, -1, true);\n\tresult = bytea_catenate(s1, t2);\n\tresult = bytea_catenate(result, s2);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static text *text_catenate(text *t1, text *t2);",
            "static text *text_overlay(text *t1, text *t2, int sp, int sl);",
            "static int\ttext_position(text *t1, text *t2);",
            "static bytea *bytea_catenate(bytea *t1, bytea *t2);",
            "static bytea *bytea_overlay(bytea *t1, bytea *t2, int sp, int sl);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic text *text_catenate(text *t1, text *t2);\nstatic text *text_overlay(text *t1, text *t2, int sp, int sl);\nstatic int\ttext_position(text *t1, text *t2);\nstatic bytea *bytea_catenate(bytea *t1, bytea *t2);\nstatic bytea *bytea_overlay(bytea *t1, bytea *t2, int sp, int sl);\n\nstatic bytea *\nbytea_overlay(bytea *t1, bytea *t2, int sp, int sl)\n{\n\tbytea\t   *result;\n\tbytea\t   *s1;\n\tbytea\t   *s2;\n\tint\t\t\tsp_pl_sl;\n\n\t/*\n\t * Check for possible integer-overflow cases.  For negative sp, throw a\n\t * \"substring length\" error because that's what should be expected\n\t * according to the spec's definition of OVERLAY().\n\t */\n\tif (sp <= 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_SUBSTRING_ERROR),\n\t\t\t\t errmsg(\"negative substring length not allowed\")));\n\tif (pg_add_s32_overflow(sp, sl, &sp_pl_sl))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"integer out of range\")));\n\n\ts1 = bytea_substring(PointerGetDatum(t1), 1, sp - 1, false);\n\ts2 = bytea_substring(PointerGetDatum(t1), sp_pl_sl, -1, true);\n\tresult = bytea_catenate(s1, t2);\n\tresult = bytea_catenate(result, s2);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "3"
          ],
          "line": 2946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "2"
          ],
          "line": 2945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BYTEA_PP",
          "args": [
            "1"
          ],
          "line": 2944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BYTEA_PP",
          "args": [
            "0"
          ],
          "line": 2943
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic text *text_catenate(text *t1, text *t2);\nstatic text *text_overlay(text *t1, text *t2, int sp, int sl);\nstatic int\ttext_position(text *t1, text *t2);\nstatic bytea *bytea_catenate(bytea *t1, bytea *t2);\nstatic bytea *bytea_overlay(bytea *t1, bytea *t2, int sp, int sl);\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\n\nDatum\nbyteaoverlay(PG_FUNCTION_ARGS)\n{\n\tbytea\t   *t1 = PG_GETARG_BYTEA_PP(0);\n\tbytea\t   *t2 = PG_GETARG_BYTEA_PP(1);\n\tint\t\t\tsp = PG_GETARG_INT32(2);\t/* substring start position */\n\tint\t\t\tsl = PG_GETARG_INT32(3);\t/* substring length */\n\n\tPG_RETURN_BYTEA_P(bytea_overlay(t1, t2, sp, sl));\n}"
  },
  {
    "function_name": "bytea_substring",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "2881-2931",
    "snippet": "static bytea *\nbytea_substring(Datum str,\n\t\t\t\tint S,\n\t\t\t\tint L,\n\t\t\t\tbool length_not_specified)\n{\n\tint\t\t\tS1;\t\t\t\t/* adjusted start position */\n\tint\t\t\tL1;\t\t\t\t/* adjusted substring length */\n\n\tS1 = Max(S, 1);\n\n\tif (length_not_specified)\n\t{\n\t\t/*\n\t\t * Not passed a length - DatumGetByteaPSlice() grabs everything to the\n\t\t * end of the string if we pass it a negative value for length.\n\t\t */\n\t\tL1 = -1;\n\t}\n\telse\n\t{\n\t\t/* end position */\n\t\tint\t\t\tE = S + L;\n\n\t\t/*\n\t\t * A negative value for L is the only way for the end position to be\n\t\t * before the start. SQL99 says to throw an error.\n\t\t */\n\t\tif (E < S)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_SUBSTRING_ERROR),\n\t\t\t\t\t errmsg(\"negative substring length not allowed\")));\n\n\t\t/*\n\t\t * A zero or negative value for the end position can happen if the\n\t\t * start was negative or one. SQL99 says to return a zero-length\n\t\t * string.\n\t\t */\n\t\tif (E < 1)\n\t\t\treturn PG_STR_GET_BYTEA(\"\");\n\n\t\tL1 = E - S1;\n\t}\n\n\t/*\n\t * If the start position is past the end of the string, SQL99 says to\n\t * return a zero-length string -- DatumGetByteaPSlice() will do that for\n\t * us. Convert to zero-based starting position\n\t */\n\treturn DatumGetByteaPSlice(str, S1 - 1, L1);\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int32 text_length(Datum str);",
      "static text *text_substring(Datum str,\n\t\t\t   int32 start,\n\t\t\t   int32 length,\n\t\t\t   bool length_not_specified);",
      "static bytea *bytea_substring(Datum str,\n\t\t\t\tint S,\n\t\t\t\tint L,\n\t\t\t\tbool length_not_specified);",
      "static bool text_format_parse_digits(const char **ptr, const char *end_ptr,\n\t\t\t\t\t\t int *value);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DatumGetByteaPSlice",
          "args": [
            "str",
            "S1 - 1",
            "L1"
          ],
          "line": 2930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_STR_GET_BYTEA",
          "args": [
            "\"\""
          ],
          "line": 2920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_SUBSTRING_ERROR),\n\t\t\t\t\t errmsg(\"negative substring length not allowed\"))"
          ],
          "line": 2910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"negative substring length not allowed\""
          ],
          "line": 2912
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_SUBSTRING_ERROR"
          ],
          "line": 2911
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "Max",
          "args": [
            "S",
            "1"
          ],
          "line": 2890
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int32 text_length(Datum str);\nstatic text *text_substring(Datum str,\n\t\t\t   int32 start,\n\t\t\t   int32 length,\n\t\t\t   bool length_not_specified);\nstatic bytea *bytea_substring(Datum str,\n\t\t\t\tint S,\n\t\t\t\tint L,\n\t\t\t\tbool length_not_specified);\nstatic bool text_format_parse_digits(const char **ptr, const char *end_ptr,\n\t\t\t\t\t\t int *value);\n\nstatic bytea *\nbytea_substring(Datum str,\n\t\t\t\tint S,\n\t\t\t\tint L,\n\t\t\t\tbool length_not_specified)\n{\n\tint\t\t\tS1;\t\t\t\t/* adjusted start position */\n\tint\t\t\tL1;\t\t\t\t/* adjusted substring length */\n\n\tS1 = Max(S, 1);\n\n\tif (length_not_specified)\n\t{\n\t\t/*\n\t\t * Not passed a length - DatumGetByteaPSlice() grabs everything to the\n\t\t * end of the string if we pass it a negative value for length.\n\t\t */\n\t\tL1 = -1;\n\t}\n\telse\n\t{\n\t\t/* end position */\n\t\tint\t\t\tE = S + L;\n\n\t\t/*\n\t\t * A negative value for L is the only way for the end position to be\n\t\t * before the start. SQL99 says to throw an error.\n\t\t */\n\t\tif (E < S)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_SUBSTRING_ERROR),\n\t\t\t\t\t errmsg(\"negative substring length not allowed\")));\n\n\t\t/*\n\t\t * A zero or negative value for the end position can happen if the\n\t\t * start was negative or one. SQL99 says to return a zero-length\n\t\t * string.\n\t\t */\n\t\tif (E < 1)\n\t\t\treturn PG_STR_GET_BYTEA(\"\");\n\n\t\tL1 = E - S1;\n\t}\n\n\t/*\n\t * If the start position is past the end of the string, SQL99 says to\n\t * return a zero-length string -- DatumGetByteaPSlice() will do that for\n\t * us. Convert to zero-based starting position\n\t */\n\treturn DatumGetByteaPSlice(str, S1 - 1, L1);\n}"
  },
  {
    "function_name": "bytea_substr_no_len",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "2872-2879",
    "snippet": "Datum\nbytea_substr_no_len(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_BYTEA_P(bytea_substring(PG_GETARG_DATUM(0),\n\t\t\t\t\t\t\t\t\t  PG_GETARG_INT32(1),\n\t\t\t\t\t\t\t\t\t  -1,\n\t\t\t\t\t\t\t\t\t  true));\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BYTEA_P",
          "args": [
            "bytea_substring(PG_GETARG_DATUM(0),\n\t\t\t\t\t\t\t\t\t  PG_GETARG_INT32(1),\n\t\t\t\t\t\t\t\t\t  -1,\n\t\t\t\t\t\t\t\t\t  true)"
          ],
          "line": 2875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bytea_substring",
          "args": [
            "PG_GETARG_DATUM(0)",
            "PG_GETARG_INT32(1)",
            "-1",
            "true"
          ],
          "line": 2875
        },
        "resolved": true,
        "details": {
          "function_name": "bytea_substring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "2881-2931",
          "snippet": "static bytea *\nbytea_substring(Datum str,\n\t\t\t\tint S,\n\t\t\t\tint L,\n\t\t\t\tbool length_not_specified)\n{\n\tint\t\t\tS1;\t\t\t\t/* adjusted start position */\n\tint\t\t\tL1;\t\t\t\t/* adjusted substring length */\n\n\tS1 = Max(S, 1);\n\n\tif (length_not_specified)\n\t{\n\t\t/*\n\t\t * Not passed a length - DatumGetByteaPSlice() grabs everything to the\n\t\t * end of the string if we pass it a negative value for length.\n\t\t */\n\t\tL1 = -1;\n\t}\n\telse\n\t{\n\t\t/* end position */\n\t\tint\t\t\tE = S + L;\n\n\t\t/*\n\t\t * A negative value for L is the only way for the end position to be\n\t\t * before the start. SQL99 says to throw an error.\n\t\t */\n\t\tif (E < S)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_SUBSTRING_ERROR),\n\t\t\t\t\t errmsg(\"negative substring length not allowed\")));\n\n\t\t/*\n\t\t * A zero or negative value for the end position can happen if the\n\t\t * start was negative or one. SQL99 says to return a zero-length\n\t\t * string.\n\t\t */\n\t\tif (E < 1)\n\t\t\treturn PG_STR_GET_BYTEA(\"\");\n\n\t\tL1 = E - S1;\n\t}\n\n\t/*\n\t * If the start position is past the end of the string, SQL99 says to\n\t * return a zero-length string -- DatumGetByteaPSlice() will do that for\n\t * us. Convert to zero-based starting position\n\t */\n\treturn DatumGetByteaPSlice(str, S1 - 1, L1);\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int32 text_length(Datum str);",
            "static text *text_substring(Datum str,\n\t\t\t   int32 start,\n\t\t\t   int32 length,\n\t\t\t   bool length_not_specified);",
            "static bytea *bytea_substring(Datum str,\n\t\t\t\tint S,\n\t\t\t\tint L,\n\t\t\t\tbool length_not_specified);",
            "static bool text_format_parse_digits(const char **ptr, const char *end_ptr,\n\t\t\t\t\t\t int *value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int32 text_length(Datum str);\nstatic text *text_substring(Datum str,\n\t\t\t   int32 start,\n\t\t\t   int32 length,\n\t\t\t   bool length_not_specified);\nstatic bytea *bytea_substring(Datum str,\n\t\t\t\tint S,\n\t\t\t\tint L,\n\t\t\t\tbool length_not_specified);\nstatic bool text_format_parse_digits(const char **ptr, const char *end_ptr,\n\t\t\t\t\t\t int *value);\n\nstatic bytea *\nbytea_substring(Datum str,\n\t\t\t\tint S,\n\t\t\t\tint L,\n\t\t\t\tbool length_not_specified)\n{\n\tint\t\t\tS1;\t\t\t\t/* adjusted start position */\n\tint\t\t\tL1;\t\t\t\t/* adjusted substring length */\n\n\tS1 = Max(S, 1);\n\n\tif (length_not_specified)\n\t{\n\t\t/*\n\t\t * Not passed a length - DatumGetByteaPSlice() grabs everything to the\n\t\t * end of the string if we pass it a negative value for length.\n\t\t */\n\t\tL1 = -1;\n\t}\n\telse\n\t{\n\t\t/* end position */\n\t\tint\t\t\tE = S + L;\n\n\t\t/*\n\t\t * A negative value for L is the only way for the end position to be\n\t\t * before the start. SQL99 says to throw an error.\n\t\t */\n\t\tif (E < S)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_SUBSTRING_ERROR),\n\t\t\t\t\t errmsg(\"negative substring length not allowed\")));\n\n\t\t/*\n\t\t * A zero or negative value for the end position can happen if the\n\t\t * start was negative or one. SQL99 says to return a zero-length\n\t\t * string.\n\t\t */\n\t\tif (E < 1)\n\t\t\treturn PG_STR_GET_BYTEA(\"\");\n\n\t\tL1 = E - S1;\n\t}\n\n\t/*\n\t * If the start position is past the end of the string, SQL99 says to\n\t * return a zero-length string -- DatumGetByteaPSlice() will do that for\n\t * us. Convert to zero-based starting position\n\t */\n\treturn DatumGetByteaPSlice(str, S1 - 1, L1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "1"
          ],
          "line": 2876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "0"
          ],
          "line": 2875
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\n\nDatum\nbytea_substr_no_len(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_BYTEA_P(bytea_substring(PG_GETARG_DATUM(0),\n\t\t\t\t\t\t\t\t\t  PG_GETARG_INT32(1),\n\t\t\t\t\t\t\t\t\t  -1,\n\t\t\t\t\t\t\t\t\t  true));\n}"
  },
  {
    "function_name": "bytea_substr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "2858-2865",
    "snippet": "Datum\nbytea_substr(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_BYTEA_P(bytea_substring(PG_GETARG_DATUM(0),\n\t\t\t\t\t\t\t\t\t  PG_GETARG_INT32(1),\n\t\t\t\t\t\t\t\t\t  PG_GETARG_INT32(2),\n\t\t\t\t\t\t\t\t\t  false));\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BYTEA_P",
          "args": [
            "bytea_substring(PG_GETARG_DATUM(0),\n\t\t\t\t\t\t\t\t\t  PG_GETARG_INT32(1),\n\t\t\t\t\t\t\t\t\t  PG_GETARG_INT32(2),\n\t\t\t\t\t\t\t\t\t  false)"
          ],
          "line": 2861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bytea_substring",
          "args": [
            "PG_GETARG_DATUM(0)",
            "PG_GETARG_INT32(1)",
            "PG_GETARG_INT32(2)",
            "false"
          ],
          "line": 2861
        },
        "resolved": true,
        "details": {
          "function_name": "bytea_substring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "2881-2931",
          "snippet": "static bytea *\nbytea_substring(Datum str,\n\t\t\t\tint S,\n\t\t\t\tint L,\n\t\t\t\tbool length_not_specified)\n{\n\tint\t\t\tS1;\t\t\t\t/* adjusted start position */\n\tint\t\t\tL1;\t\t\t\t/* adjusted substring length */\n\n\tS1 = Max(S, 1);\n\n\tif (length_not_specified)\n\t{\n\t\t/*\n\t\t * Not passed a length - DatumGetByteaPSlice() grabs everything to the\n\t\t * end of the string if we pass it a negative value for length.\n\t\t */\n\t\tL1 = -1;\n\t}\n\telse\n\t{\n\t\t/* end position */\n\t\tint\t\t\tE = S + L;\n\n\t\t/*\n\t\t * A negative value for L is the only way for the end position to be\n\t\t * before the start. SQL99 says to throw an error.\n\t\t */\n\t\tif (E < S)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_SUBSTRING_ERROR),\n\t\t\t\t\t errmsg(\"negative substring length not allowed\")));\n\n\t\t/*\n\t\t * A zero or negative value for the end position can happen if the\n\t\t * start was negative or one. SQL99 says to return a zero-length\n\t\t * string.\n\t\t */\n\t\tif (E < 1)\n\t\t\treturn PG_STR_GET_BYTEA(\"\");\n\n\t\tL1 = E - S1;\n\t}\n\n\t/*\n\t * If the start position is past the end of the string, SQL99 says to\n\t * return a zero-length string -- DatumGetByteaPSlice() will do that for\n\t * us. Convert to zero-based starting position\n\t */\n\treturn DatumGetByteaPSlice(str, S1 - 1, L1);\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int32 text_length(Datum str);",
            "static text *text_substring(Datum str,\n\t\t\t   int32 start,\n\t\t\t   int32 length,\n\t\t\t   bool length_not_specified);",
            "static bytea *bytea_substring(Datum str,\n\t\t\t\tint S,\n\t\t\t\tint L,\n\t\t\t\tbool length_not_specified);",
            "static bool text_format_parse_digits(const char **ptr, const char *end_ptr,\n\t\t\t\t\t\t int *value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int32 text_length(Datum str);\nstatic text *text_substring(Datum str,\n\t\t\t   int32 start,\n\t\t\t   int32 length,\n\t\t\t   bool length_not_specified);\nstatic bytea *bytea_substring(Datum str,\n\t\t\t\tint S,\n\t\t\t\tint L,\n\t\t\t\tbool length_not_specified);\nstatic bool text_format_parse_digits(const char **ptr, const char *end_ptr,\n\t\t\t\t\t\t int *value);\n\nstatic bytea *\nbytea_substring(Datum str,\n\t\t\t\tint S,\n\t\t\t\tint L,\n\t\t\t\tbool length_not_specified)\n{\n\tint\t\t\tS1;\t\t\t\t/* adjusted start position */\n\tint\t\t\tL1;\t\t\t\t/* adjusted substring length */\n\n\tS1 = Max(S, 1);\n\n\tif (length_not_specified)\n\t{\n\t\t/*\n\t\t * Not passed a length - DatumGetByteaPSlice() grabs everything to the\n\t\t * end of the string if we pass it a negative value for length.\n\t\t */\n\t\tL1 = -1;\n\t}\n\telse\n\t{\n\t\t/* end position */\n\t\tint\t\t\tE = S + L;\n\n\t\t/*\n\t\t * A negative value for L is the only way for the end position to be\n\t\t * before the start. SQL99 says to throw an error.\n\t\t */\n\t\tif (E < S)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_SUBSTRING_ERROR),\n\t\t\t\t\t errmsg(\"negative substring length not allowed\")));\n\n\t\t/*\n\t\t * A zero or negative value for the end position can happen if the\n\t\t * start was negative or one. SQL99 says to return a zero-length\n\t\t * string.\n\t\t */\n\t\tif (E < 1)\n\t\t\treturn PG_STR_GET_BYTEA(\"\");\n\n\t\tL1 = E - S1;\n\t}\n\n\t/*\n\t * If the start position is past the end of the string, SQL99 says to\n\t * return a zero-length string -- DatumGetByteaPSlice() will do that for\n\t * us. Convert to zero-based starting position\n\t */\n\treturn DatumGetByteaPSlice(str, S1 - 1, L1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "2"
          ],
          "line": 2863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "1"
          ],
          "line": 2862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "0"
          ],
          "line": 2861
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\n\nDatum\nbytea_substr(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_BYTEA_P(bytea_substring(PG_GETARG_DATUM(0),\n\t\t\t\t\t\t\t\t\t  PG_GETARG_INT32(1),\n\t\t\t\t\t\t\t\t\t  PG_GETARG_INT32(2),\n\t\t\t\t\t\t\t\t\t  false));\n}"
  },
  {
    "function_name": "bytea_catenate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "2806-2838",
    "snippet": "static bytea *\nbytea_catenate(bytea *t1, bytea *t2)\n{\n\tbytea\t   *result;\n\tint\t\t\tlen1,\n\t\t\t\tlen2,\n\t\t\t\tlen;\n\tchar\t   *ptr;\n\n\tlen1 = VARSIZE_ANY_EXHDR(t1);\n\tlen2 = VARSIZE_ANY_EXHDR(t2);\n\n\t/* paranoia ... probably should throw error instead? */\n\tif (len1 < 0)\n\t\tlen1 = 0;\n\tif (len2 < 0)\n\t\tlen2 = 0;\n\n\tlen = len1 + len2 + VARHDRSZ;\n\tresult = (bytea *) palloc(len);\n\n\t/* Set size of result string... */\n\tSET_VARSIZE(result, len);\n\n\t/* Fill data field of result string... */\n\tptr = VARDATA(result);\n\tif (len1 > 0)\n\t\tmemcpy(ptr, VARDATA_ANY(t1), len1);\n\tif (len2 > 0)\n\t\tmemcpy(ptr + len1, VARDATA_ANY(t2), len2);\n\n\treturn result;\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static text *text_catenate(text *t1, text *t2);",
      "static int\ttext_position(text *t1, text *t2);",
      "static bytea *bytea_catenate(bytea *t1, bytea *t2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ptr + len1",
            "VARDATA_ANY(t2)",
            "len2"
          ],
          "line": 2835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "t2"
          ],
          "line": 2835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ptr",
            "VARDATA_ANY(t1)",
            "len1"
          ],
          "line": 2833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "t1"
          ],
          "line": 2833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA",
          "args": [
            "result"
          ],
          "line": 2831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "result",
            "len"
          ],
          "line": 2828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "len"
          ],
          "line": 2825
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "t2"
          ],
          "line": 2816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "t1"
          ],
          "line": 2815
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic text *text_catenate(text *t1, text *t2);\nstatic int\ttext_position(text *t1, text *t2);\nstatic bytea *bytea_catenate(bytea *t1, bytea *t2);\n\nstatic bytea *\nbytea_catenate(bytea *t1, bytea *t2)\n{\n\tbytea\t   *result;\n\tint\t\t\tlen1,\n\t\t\t\tlen2,\n\t\t\t\tlen;\n\tchar\t   *ptr;\n\n\tlen1 = VARSIZE_ANY_EXHDR(t1);\n\tlen2 = VARSIZE_ANY_EXHDR(t2);\n\n\t/* paranoia ... probably should throw error instead? */\n\tif (len1 < 0)\n\t\tlen1 = 0;\n\tif (len2 < 0)\n\t\tlen2 = 0;\n\n\tlen = len1 + len2 + VARHDRSZ;\n\tresult = (bytea *) palloc(len);\n\n\t/* Set size of result string... */\n\tSET_VARSIZE(result, len);\n\n\t/* Fill data field of result string... */\n\tptr = VARDATA(result);\n\tif (len1 > 0)\n\t\tmemcpy(ptr, VARDATA_ANY(t1), len1);\n\tif (len2 > 0)\n\t\tmemcpy(ptr + len1, VARDATA_ANY(t2), len2);\n\n\treturn result;\n}"
  },
  {
    "function_name": "byteacat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "2791-2798",
    "snippet": "Datum\nbyteacat(PG_FUNCTION_ARGS)\n{\n\tbytea\t   *t1 = PG_GETARG_BYTEA_PP(0);\n\tbytea\t   *t2 = PG_GETARG_BYTEA_PP(1);\n\n\tPG_RETURN_BYTEA_P(bytea_catenate(t1, t2));\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static text *text_catenate(text *t1, text *t2);",
      "static int\ttext_position(text *t1, text *t2);",
      "static bytea *bytea_catenate(bytea *t1, bytea *t2);",
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BYTEA_P",
          "args": [
            "bytea_catenate(t1, t2)"
          ],
          "line": 2797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bytea_catenate",
          "args": [
            "t1",
            "t2"
          ],
          "line": 2797
        },
        "resolved": true,
        "details": {
          "function_name": "bytea_catenate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "2806-2838",
          "snippet": "static bytea *\nbytea_catenate(bytea *t1, bytea *t2)\n{\n\tbytea\t   *result;\n\tint\t\t\tlen1,\n\t\t\t\tlen2,\n\t\t\t\tlen;\n\tchar\t   *ptr;\n\n\tlen1 = VARSIZE_ANY_EXHDR(t1);\n\tlen2 = VARSIZE_ANY_EXHDR(t2);\n\n\t/* paranoia ... probably should throw error instead? */\n\tif (len1 < 0)\n\t\tlen1 = 0;\n\tif (len2 < 0)\n\t\tlen2 = 0;\n\n\tlen = len1 + len2 + VARHDRSZ;\n\tresult = (bytea *) palloc(len);\n\n\t/* Set size of result string... */\n\tSET_VARSIZE(result, len);\n\n\t/* Fill data field of result string... */\n\tptr = VARDATA(result);\n\tif (len1 > 0)\n\t\tmemcpy(ptr, VARDATA_ANY(t1), len1);\n\tif (len2 > 0)\n\t\tmemcpy(ptr + len1, VARDATA_ANY(t2), len2);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static text *text_catenate(text *t1, text *t2);",
            "static int\ttext_position(text *t1, text *t2);",
            "static bytea *bytea_catenate(bytea *t1, bytea *t2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic text *text_catenate(text *t1, text *t2);\nstatic int\ttext_position(text *t1, text *t2);\nstatic bytea *bytea_catenate(bytea *t1, bytea *t2);\n\nstatic bytea *\nbytea_catenate(bytea *t1, bytea *t2)\n{\n\tbytea\t   *result;\n\tint\t\t\tlen1,\n\t\t\t\tlen2,\n\t\t\t\tlen;\n\tchar\t   *ptr;\n\n\tlen1 = VARSIZE_ANY_EXHDR(t1);\n\tlen2 = VARSIZE_ANY_EXHDR(t2);\n\n\t/* paranoia ... probably should throw error instead? */\n\tif (len1 < 0)\n\t\tlen1 = 0;\n\tif (len2 < 0)\n\t\tlen2 = 0;\n\n\tlen = len1 + len2 + VARHDRSZ;\n\tresult = (bytea *) palloc(len);\n\n\t/* Set size of result string... */\n\tSET_VARSIZE(result, len);\n\n\t/* Fill data field of result string... */\n\tptr = VARDATA(result);\n\tif (len1 > 0)\n\t\tmemcpy(ptr, VARDATA_ANY(t1), len1);\n\tif (len2 > 0)\n\t\tmemcpy(ptr + len1, VARDATA_ANY(t2), len2);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BYTEA_PP",
          "args": [
            "1"
          ],
          "line": 2795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BYTEA_PP",
          "args": [
            "0"
          ],
          "line": 2794
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic text *text_catenate(text *t1, text *t2);\nstatic int\ttext_position(text *t1, text *t2);\nstatic bytea *bytea_catenate(bytea *t1, bytea *t2);\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\n\nDatum\nbyteacat(PG_FUNCTION_ARGS)\n{\n\tbytea\t   *t1 = PG_GETARG_BYTEA_PP(0);\n\tbytea\t   *t2 = PG_GETARG_BYTEA_PP(1);\n\n\tPG_RETURN_BYTEA_P(bytea_catenate(t1, t2));\n}"
  },
  {
    "function_name": "byteaoctetlen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "2775-2782",
    "snippet": "Datum\nbyteaoctetlen(PG_FUNCTION_ARGS)\n{\n\tDatum\t\tstr = PG_GETARG_DATUM(0);\n\n\t/* We need not detoast the input at all */\n\tPG_RETURN_INT32(toast_raw_datum_size(str) - VARHDRSZ);\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int32 text_length(Datum str);",
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "toast_raw_datum_size(str) - VARHDRSZ"
          ],
          "line": 2781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toast_raw_datum_size",
          "args": [
            "str"
          ],
          "line": 2781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "0"
          ],
          "line": 2778
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int32 text_length(Datum str);\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\n\nDatum\nbyteaoctetlen(PG_FUNCTION_ARGS)\n{\n\tDatum\t\tstr = PG_GETARG_DATUM(0);\n\n\t/* We need not detoast the input at all */\n\tPG_RETURN_INT32(toast_raw_datum_size(str) - VARHDRSZ);\n}"
  },
  {
    "function_name": "bttext_pattern_sortsupport",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "2752-2766",
    "snippet": "Datum\nbttext_pattern_sortsupport(PG_FUNCTION_ARGS)\n{\n\tSortSupport ssup = (SortSupport) PG_GETARG_POINTER(0);\n\tMemoryContext oldcontext;\n\n\toldcontext = MemoryContextSwitchTo(ssup->ssup_cxt);\n\n\t/* Use generic string SortSupport, forcing \"C\" collation */\n\tvarstr_sortsupport(ssup, C_COLLATION_OID, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\tPG_RETURN_VOID();\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tvarstrfastcmp_c(Datum x, Datum y, SortSupport ssup);",
      "static int\tbpcharfastcmp_c(Datum x, Datum y, SortSupport ssup);",
      "static int\tvarstrfastcmp_locale(Datum x, Datum y, SortSupport ssup);",
      "static int\tvarstrcmp_abbrev(Datum x, Datum y, SortSupport ssup);",
      "static Datum varstr_abbrev_convert(Datum original, SortSupport ssup);",
      "static bool varstr_abbrev_abort(int memtupcount, SortSupport ssup);",
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VOID",
          "args": [],
          "line": 2765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 2763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "varstr_sortsupport",
          "args": [
            "ssup",
            "C_COLLATION_OID",
            "false"
          ],
          "line": 2761
        },
        "resolved": true,
        "details": {
          "function_name": "varstr_sortsupport",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "1834-1985",
          "snippet": "void\nvarstr_sortsupport(SortSupport ssup, Oid collid, bool bpchar)\n{\n\tbool\t\tabbreviate = ssup->abbreviate;\n\tbool\t\tcollate_c = false;\n\tVarStringSortSupport *sss;\n\tpg_locale_t locale = 0;\n\n\t/*\n\t * If possible, set ssup->comparator to a function which can be used to\n\t * directly compare two datums.  If we can do this, we'll avoid the\n\t * overhead of a trip through the fmgr layer for every comparison, which\n\t * can be substantial.\n\t *\n\t * Most typically, we'll set the comparator to varstrfastcmp_locale, which\n\t * uses strcoll() to perform comparisons and knows about the special\n\t * requirements of BpChar callers.  However, if LC_COLLATE = C, we can\n\t * make things quite a bit faster with varstrfastcmp_c or bpcharfastcmp_c,\n\t * both of which use memcmp() rather than strcoll().\n\t */\n\tif (lc_collate_is_c(collid))\n\t{\n\t\tif (!bpchar)\n\t\t\tssup->comparator = varstrfastcmp_c;\n\t\telse\n\t\t\tssup->comparator = bpcharfastcmp_c;\n\n\t\tcollate_c = true;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * We need a collation-sensitive comparison.  To make things faster,\n\t\t * we'll figure out the collation based on the locale id and cache the\n\t\t * result.\n\t\t */\n\t\tif (collid != DEFAULT_COLLATION_OID)\n\t\t{\n\t\t\tif (!OidIsValid(collid))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This typically means that the parser could not resolve a\n\t\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t\t errmsg(\"could not determine which collation to use for string comparison\"),\n\t\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t\t}\n\t\t\tlocale = pg_newlocale_from_collation(collid);\n\t\t}\n\n\t\t/*\n\t\t * There is a further exception on Windows.  When the database\n\t\t * encoding is UTF-8 and we are not using the C collation, complex\n\t\t * hacks are required.  We don't currently have a comparator that\n\t\t * handles that case, so we fall back on the slow method of having the\n\t\t * sort code invoke bttextcmp() (in the case of text) via the fmgr\n\t\t * trampoline.  ICU locales work just the same on Windows, however.\n\t\t */\n#ifdef WIN32\n\t\tif (GetDatabaseEncoding() == PG_UTF8 &&\n\t\t\t!(locale && locale->provider == COLLPROVIDER_ICU))\n\t\t\treturn;\n#endif\n\n\t\tssup->comparator = varstrfastcmp_locale;\n\t}\n\n\t/*\n\t * Unfortunately, it seems that abbreviation for non-C collations is\n\t * broken on many common platforms; testing of multiple versions of glibc\n\t * reveals that, for many locales, strcoll() and strxfrm() do not return\n\t * consistent results, which is fatal to this optimization.  While no\n\t * other libc other than Cygwin has so far been shown to have a problem,\n\t * we take the conservative course of action for right now and disable\n\t * this categorically.  (Users who are certain this isn't a problem on\n\t * their system can define TRUST_STRXFRM.)\n\t *\n\t * Even apart from the risk of broken locales, it's possible that there\n\t * are platforms where the use of abbreviated keys should be disabled at\n\t * compile time.  Having only 4 byte datums could make worst-case\n\t * performance drastically more likely, for example.  Moreover, macOS's\n\t * strxfrm() implementation is known to not effectively concentrate a\n\t * significant amount of entropy from the original string in earlier\n\t * transformed blobs.  It's possible that other supported platforms are\n\t * similarly encumbered.  So, if we ever get past disabling this\n\t * categorically, we may still want or need to disable it for particular\n\t * platforms.\n\t */\n#ifndef TRUST_STRXFRM\n\tif (!collate_c && !(locale && locale->provider == COLLPROVIDER_ICU))\n\t\tabbreviate = false;\n#endif\n\n\t/*\n\t * If we're using abbreviated keys, or if we're using a locale-aware\n\t * comparison, we need to initialize a StringSortSupport object.  Both\n\t * cases will make use of the temporary buffers we initialize here for\n\t * scratch space (and to detect requirement for BpChar semantics from\n\t * caller), and the abbreviation case requires additional state.\n\t */\n\tif (abbreviate || !collate_c)\n\t{\n\t\tsss = palloc(sizeof(VarStringSortSupport));\n\t\tsss->buf1 = palloc(TEXTBUFLEN);\n\t\tsss->buflen1 = TEXTBUFLEN;\n\t\tsss->buf2 = palloc(TEXTBUFLEN);\n\t\tsss->buflen2 = TEXTBUFLEN;\n\t\t/* Start with invalid values */\n\t\tsss->last_len1 = -1;\n\t\tsss->last_len2 = -1;\n\t\t/* Initialize */\n\t\tsss->last_returned = 0;\n\t\tsss->locale = locale;\n\n\t\t/*\n\t\t * To avoid somehow confusing a strxfrm() blob and an original string,\n\t\t * constantly keep track of the variety of data that buf1 and buf2\n\t\t * currently contain.\n\t\t *\n\t\t * Comparisons may be interleaved with conversion calls.  Frequently,\n\t\t * conversions and comparisons are batched into two distinct phases,\n\t\t * but the correctness of caching cannot hinge upon this.  For\n\t\t * comparison caching, buffer state is only trusted if cache_blob is\n\t\t * found set to false, whereas strxfrm() caching only trusts the state\n\t\t * when cache_blob is found set to true.\n\t\t *\n\t\t * Arbitrarily initialize cache_blob to true.\n\t\t */\n\t\tsss->cache_blob = true;\n\t\tsss->collate_c = collate_c;\n\t\tsss->bpchar = bpchar;\n\t\tssup->ssup_extra = sss;\n\n\t\t/*\n\t\t * If possible, plan to use the abbreviated keys optimization.  The\n\t\t * core code may switch back to authoritative comparator should\n\t\t * abbreviation be aborted.\n\t\t */\n\t\tif (abbreviate)\n\t\t{\n\t\t\tsss->prop_card = 0.20;\n\t\t\tinitHyperLogLog(&sss->abbr_card, 10);\n\t\t\tinitHyperLogLog(&sss->full_card, 10);\n\t\t\tssup->abbrev_full_comparator = ssup->comparator;\n\t\t\tssup->comparator = varstrcmp_abbrev;\n\t\t\tssup->abbrev_converter = varstr_abbrev_convert;\n\t\t\tssup->abbrev_abort = varstr_abbrev_abort;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TEXTBUFLEN\t\t1024"
          ],
          "globals_used": [
            "static int\tvarstrfastcmp_c(Datum x, Datum y, SortSupport ssup);",
            "static int\tbpcharfastcmp_c(Datum x, Datum y, SortSupport ssup);",
            "static int\tvarstrfastcmp_locale(Datum x, Datum y, SortSupport ssup);",
            "static int\tvarstrcmp_abbrev(Datum x, Datum y, SortSupport ssup);",
            "static Datum varstr_abbrev_convert(Datum original, SortSupport ssup);",
            "static bool varstr_abbrev_abort(int memtupcount, SortSupport ssup);",
            "static void text_position_setup(text *t1, text *t2, TextPositionState *state);",
            "static int\ttext_position_next(int start_pos, TextPositionState *state);",
            "static void text_position_cleanup(TextPositionState *state);",
            "static int\ttext_cmp(text *arg1, text *arg2, Oid collid);",
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define TEXTBUFLEN\t\t1024\n\nstatic int\tvarstrfastcmp_c(Datum x, Datum y, SortSupport ssup);\nstatic int\tbpcharfastcmp_c(Datum x, Datum y, SortSupport ssup);\nstatic int\tvarstrfastcmp_locale(Datum x, Datum y, SortSupport ssup);\nstatic int\tvarstrcmp_abbrev(Datum x, Datum y, SortSupport ssup);\nstatic Datum varstr_abbrev_convert(Datum original, SortSupport ssup);\nstatic bool varstr_abbrev_abort(int memtupcount, SortSupport ssup);\nstatic void text_position_setup(text *t1, text *t2, TextPositionState *state);\nstatic int\ttext_position_next(int start_pos, TextPositionState *state);\nstatic void text_position_cleanup(TextPositionState *state);\nstatic int\ttext_cmp(text *arg1, text *arg2, Oid collid);\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nvoid\nvarstr_sortsupport(SortSupport ssup, Oid collid, bool bpchar)\n{\n\tbool\t\tabbreviate = ssup->abbreviate;\n\tbool\t\tcollate_c = false;\n\tVarStringSortSupport *sss;\n\tpg_locale_t locale = 0;\n\n\t/*\n\t * If possible, set ssup->comparator to a function which can be used to\n\t * directly compare two datums.  If we can do this, we'll avoid the\n\t * overhead of a trip through the fmgr layer for every comparison, which\n\t * can be substantial.\n\t *\n\t * Most typically, we'll set the comparator to varstrfastcmp_locale, which\n\t * uses strcoll() to perform comparisons and knows about the special\n\t * requirements of BpChar callers.  However, if LC_COLLATE = C, we can\n\t * make things quite a bit faster with varstrfastcmp_c or bpcharfastcmp_c,\n\t * both of which use memcmp() rather than strcoll().\n\t */\n\tif (lc_collate_is_c(collid))\n\t{\n\t\tif (!bpchar)\n\t\t\tssup->comparator = varstrfastcmp_c;\n\t\telse\n\t\t\tssup->comparator = bpcharfastcmp_c;\n\n\t\tcollate_c = true;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * We need a collation-sensitive comparison.  To make things faster,\n\t\t * we'll figure out the collation based on the locale id and cache the\n\t\t * result.\n\t\t */\n\t\tif (collid != DEFAULT_COLLATION_OID)\n\t\t{\n\t\t\tif (!OidIsValid(collid))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This typically means that the parser could not resolve a\n\t\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t\t errmsg(\"could not determine which collation to use for string comparison\"),\n\t\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t\t}\n\t\t\tlocale = pg_newlocale_from_collation(collid);\n\t\t}\n\n\t\t/*\n\t\t * There is a further exception on Windows.  When the database\n\t\t * encoding is UTF-8 and we are not using the C collation, complex\n\t\t * hacks are required.  We don't currently have a comparator that\n\t\t * handles that case, so we fall back on the slow method of having the\n\t\t * sort code invoke bttextcmp() (in the case of text) via the fmgr\n\t\t * trampoline.  ICU locales work just the same on Windows, however.\n\t\t */\n#ifdef WIN32\n\t\tif (GetDatabaseEncoding() == PG_UTF8 &&\n\t\t\t!(locale && locale->provider == COLLPROVIDER_ICU))\n\t\t\treturn;\n#endif\n\n\t\tssup->comparator = varstrfastcmp_locale;\n\t}\n\n\t/*\n\t * Unfortunately, it seems that abbreviation for non-C collations is\n\t * broken on many common platforms; testing of multiple versions of glibc\n\t * reveals that, for many locales, strcoll() and strxfrm() do not return\n\t * consistent results, which is fatal to this optimization.  While no\n\t * other libc other than Cygwin has so far been shown to have a problem,\n\t * we take the conservative course of action for right now and disable\n\t * this categorically.  (Users who are certain this isn't a problem on\n\t * their system can define TRUST_STRXFRM.)\n\t *\n\t * Even apart from the risk of broken locales, it's possible that there\n\t * are platforms where the use of abbreviated keys should be disabled at\n\t * compile time.  Having only 4 byte datums could make worst-case\n\t * performance drastically more likely, for example.  Moreover, macOS's\n\t * strxfrm() implementation is known to not effectively concentrate a\n\t * significant amount of entropy from the original string in earlier\n\t * transformed blobs.  It's possible that other supported platforms are\n\t * similarly encumbered.  So, if we ever get past disabling this\n\t * categorically, we may still want or need to disable it for particular\n\t * platforms.\n\t */\n#ifndef TRUST_STRXFRM\n\tif (!collate_c && !(locale && locale->provider == COLLPROVIDER_ICU))\n\t\tabbreviate = false;\n#endif\n\n\t/*\n\t * If we're using abbreviated keys, or if we're using a locale-aware\n\t * comparison, we need to initialize a StringSortSupport object.  Both\n\t * cases will make use of the temporary buffers we initialize here for\n\t * scratch space (and to detect requirement for BpChar semantics from\n\t * caller), and the abbreviation case requires additional state.\n\t */\n\tif (abbreviate || !collate_c)\n\t{\n\t\tsss = palloc(sizeof(VarStringSortSupport));\n\t\tsss->buf1 = palloc(TEXTBUFLEN);\n\t\tsss->buflen1 = TEXTBUFLEN;\n\t\tsss->buf2 = palloc(TEXTBUFLEN);\n\t\tsss->buflen2 = TEXTBUFLEN;\n\t\t/* Start with invalid values */\n\t\tsss->last_len1 = -1;\n\t\tsss->last_len2 = -1;\n\t\t/* Initialize */\n\t\tsss->last_returned = 0;\n\t\tsss->locale = locale;\n\n\t\t/*\n\t\t * To avoid somehow confusing a strxfrm() blob and an original string,\n\t\t * constantly keep track of the variety of data that buf1 and buf2\n\t\t * currently contain.\n\t\t *\n\t\t * Comparisons may be interleaved with conversion calls.  Frequently,\n\t\t * conversions and comparisons are batched into two distinct phases,\n\t\t * but the correctness of caching cannot hinge upon this.  For\n\t\t * comparison caching, buffer state is only trusted if cache_blob is\n\t\t * found set to false, whereas strxfrm() caching only trusts the state\n\t\t * when cache_blob is found set to true.\n\t\t *\n\t\t * Arbitrarily initialize cache_blob to true.\n\t\t */\n\t\tsss->cache_blob = true;\n\t\tsss->collate_c = collate_c;\n\t\tsss->bpchar = bpchar;\n\t\tssup->ssup_extra = sss;\n\n\t\t/*\n\t\t * If possible, plan to use the abbreviated keys optimization.  The\n\t\t * core code may switch back to authoritative comparator should\n\t\t * abbreviation be aborted.\n\t\t */\n\t\tif (abbreviate)\n\t\t{\n\t\t\tsss->prop_card = 0.20;\n\t\t\tinitHyperLogLog(&sss->abbr_card, 10);\n\t\t\tinitHyperLogLog(&sss->full_card, 10);\n\t\t\tssup->abbrev_full_comparator = ssup->comparator;\n\t\t\tssup->comparator = varstrcmp_abbrev;\n\t\t\tssup->abbrev_converter = varstr_abbrev_convert;\n\t\t\tssup->abbrev_abort = varstr_abbrev_abort;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "ssup->ssup_cxt"
          ],
          "line": 2758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 2755
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\tvarstrfastcmp_c(Datum x, Datum y, SortSupport ssup);\nstatic int\tbpcharfastcmp_c(Datum x, Datum y, SortSupport ssup);\nstatic int\tvarstrfastcmp_locale(Datum x, Datum y, SortSupport ssup);\nstatic int\tvarstrcmp_abbrev(Datum x, Datum y, SortSupport ssup);\nstatic Datum varstr_abbrev_convert(Datum original, SortSupport ssup);\nstatic bool varstr_abbrev_abort(int memtupcount, SortSupport ssup);\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\n\nDatum\nbttext_pattern_sortsupport(PG_FUNCTION_ARGS)\n{\n\tSortSupport ssup = (SortSupport) PG_GETARG_POINTER(0);\n\tMemoryContext oldcontext;\n\n\toldcontext = MemoryContextSwitchTo(ssup->ssup_cxt);\n\n\t/* Use generic string SortSupport, forcing \"C\" collation */\n\tvarstr_sortsupport(ssup, C_COLLATION_OID, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\tPG_RETURN_VOID();\n}"
  },
  {
    "function_name": "bttext_pattern_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "2736-2749",
    "snippet": "Datum\nbttext_pattern_cmp(PG_FUNCTION_ARGS)\n{\n\ttext\t   *arg1 = PG_GETARG_TEXT_PP(0);\n\ttext\t   *arg2 = PG_GETARG_TEXT_PP(1);\n\tint\t\t\tresult;\n\n\tresult = internal_text_pattern_compare(arg1, arg2);\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_INT32(result);\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "result"
          ],
          "line": 2748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg2",
            "1"
          ],
          "line": 2746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg1",
            "0"
          ],
          "line": 2745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "internal_text_pattern_compare",
          "args": [
            "arg1",
            "arg2"
          ],
          "line": 2743
        },
        "resolved": true,
        "details": {
          "function_name": "internal_text_pattern_compare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "2650-2669",
          "snippet": "static int\ninternal_text_pattern_compare(text *arg1, text *arg2)\n{\n\tint\t\t\tresult;\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\n\tlen1 = VARSIZE_ANY_EXHDR(arg1);\n\tlen2 = VARSIZE_ANY_EXHDR(arg2);\n\n\tresult = memcmp(VARDATA_ANY(arg1), VARDATA_ANY(arg2), Min(len1, len2));\n\tif (result != 0)\n\t\treturn result;\n\telse if (len1 < len2)\n\t\treturn -1;\n\telse if (len1 > len2)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ninternal_text_pattern_compare(text *arg1, text *arg2)\n{\n\tint\t\t\tresult;\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\n\tlen1 = VARSIZE_ANY_EXHDR(arg1);\n\tlen2 = VARSIZE_ANY_EXHDR(arg2);\n\n\tresult = memcmp(VARDATA_ANY(arg1), VARDATA_ANY(arg2), Min(len1, len2));\n\tif (result != 0)\n\t\treturn result;\n\telse if (len1 < len2)\n\t\treturn -1;\n\telse if (len1 > len2)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 2740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 2739
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\n\nDatum\nbttext_pattern_cmp(PG_FUNCTION_ARGS)\n{\n\ttext\t   *arg1 = PG_GETARG_TEXT_PP(0);\n\ttext\t   *arg2 = PG_GETARG_TEXT_PP(1);\n\tint\t\t\tresult;\n\n\tresult = internal_text_pattern_compare(arg1, arg2);\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_INT32(result);\n}"
  },
  {
    "function_name": "text_pattern_gt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "2720-2733",
    "snippet": "Datum\ntext_pattern_gt(PG_FUNCTION_ARGS)\n{\n\ttext\t   *arg1 = PG_GETARG_TEXT_PP(0);\n\ttext\t   *arg2 = PG_GETARG_TEXT_PP(1);\n\tint\t\t\tresult;\n\n\tresult = internal_text_pattern_compare(arg1, arg2);\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_BOOL(result > 0);\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "result > 0"
          ],
          "line": 2732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg2",
            "1"
          ],
          "line": 2730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg1",
            "0"
          ],
          "line": 2729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "internal_text_pattern_compare",
          "args": [
            "arg1",
            "arg2"
          ],
          "line": 2727
        },
        "resolved": true,
        "details": {
          "function_name": "internal_text_pattern_compare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "2650-2669",
          "snippet": "static int\ninternal_text_pattern_compare(text *arg1, text *arg2)\n{\n\tint\t\t\tresult;\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\n\tlen1 = VARSIZE_ANY_EXHDR(arg1);\n\tlen2 = VARSIZE_ANY_EXHDR(arg2);\n\n\tresult = memcmp(VARDATA_ANY(arg1), VARDATA_ANY(arg2), Min(len1, len2));\n\tif (result != 0)\n\t\treturn result;\n\telse if (len1 < len2)\n\t\treturn -1;\n\telse if (len1 > len2)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ninternal_text_pattern_compare(text *arg1, text *arg2)\n{\n\tint\t\t\tresult;\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\n\tlen1 = VARSIZE_ANY_EXHDR(arg1);\n\tlen2 = VARSIZE_ANY_EXHDR(arg2);\n\n\tresult = memcmp(VARDATA_ANY(arg1), VARDATA_ANY(arg2), Min(len1, len2));\n\tif (result != 0)\n\t\treturn result;\n\telse if (len1 < len2)\n\t\treturn -1;\n\telse if (len1 > len2)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 2724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 2723
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\n\nDatum\ntext_pattern_gt(PG_FUNCTION_ARGS)\n{\n\ttext\t   *arg1 = PG_GETARG_TEXT_PP(0);\n\ttext\t   *arg2 = PG_GETARG_TEXT_PP(1);\n\tint\t\t\tresult;\n\n\tresult = internal_text_pattern_compare(arg1, arg2);\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_BOOL(result > 0);\n}"
  },
  {
    "function_name": "text_pattern_ge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "2704-2717",
    "snippet": "Datum\ntext_pattern_ge(PG_FUNCTION_ARGS)\n{\n\ttext\t   *arg1 = PG_GETARG_TEXT_PP(0);\n\ttext\t   *arg2 = PG_GETARG_TEXT_PP(1);\n\tint\t\t\tresult;\n\n\tresult = internal_text_pattern_compare(arg1, arg2);\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_BOOL(result >= 0);\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "result >= 0"
          ],
          "line": 2716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg2",
            "1"
          ],
          "line": 2714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg1",
            "0"
          ],
          "line": 2713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "internal_text_pattern_compare",
          "args": [
            "arg1",
            "arg2"
          ],
          "line": 2711
        },
        "resolved": true,
        "details": {
          "function_name": "internal_text_pattern_compare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "2650-2669",
          "snippet": "static int\ninternal_text_pattern_compare(text *arg1, text *arg2)\n{\n\tint\t\t\tresult;\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\n\tlen1 = VARSIZE_ANY_EXHDR(arg1);\n\tlen2 = VARSIZE_ANY_EXHDR(arg2);\n\n\tresult = memcmp(VARDATA_ANY(arg1), VARDATA_ANY(arg2), Min(len1, len2));\n\tif (result != 0)\n\t\treturn result;\n\telse if (len1 < len2)\n\t\treturn -1;\n\telse if (len1 > len2)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ninternal_text_pattern_compare(text *arg1, text *arg2)\n{\n\tint\t\t\tresult;\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\n\tlen1 = VARSIZE_ANY_EXHDR(arg1);\n\tlen2 = VARSIZE_ANY_EXHDR(arg2);\n\n\tresult = memcmp(VARDATA_ANY(arg1), VARDATA_ANY(arg2), Min(len1, len2));\n\tif (result != 0)\n\t\treturn result;\n\telse if (len1 < len2)\n\t\treturn -1;\n\telse if (len1 > len2)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 2708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 2707
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\n\nDatum\ntext_pattern_ge(PG_FUNCTION_ARGS)\n{\n\ttext\t   *arg1 = PG_GETARG_TEXT_PP(0);\n\ttext\t   *arg2 = PG_GETARG_TEXT_PP(1);\n\tint\t\t\tresult;\n\n\tresult = internal_text_pattern_compare(arg1, arg2);\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_BOOL(result >= 0);\n}"
  },
  {
    "function_name": "text_pattern_le",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "2688-2701",
    "snippet": "Datum\ntext_pattern_le(PG_FUNCTION_ARGS)\n{\n\ttext\t   *arg1 = PG_GETARG_TEXT_PP(0);\n\ttext\t   *arg2 = PG_GETARG_TEXT_PP(1);\n\tint\t\t\tresult;\n\n\tresult = internal_text_pattern_compare(arg1, arg2);\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_BOOL(result <= 0);\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "result <= 0"
          ],
          "line": 2700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg2",
            "1"
          ],
          "line": 2698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg1",
            "0"
          ],
          "line": 2697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "internal_text_pattern_compare",
          "args": [
            "arg1",
            "arg2"
          ],
          "line": 2695
        },
        "resolved": true,
        "details": {
          "function_name": "internal_text_pattern_compare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "2650-2669",
          "snippet": "static int\ninternal_text_pattern_compare(text *arg1, text *arg2)\n{\n\tint\t\t\tresult;\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\n\tlen1 = VARSIZE_ANY_EXHDR(arg1);\n\tlen2 = VARSIZE_ANY_EXHDR(arg2);\n\n\tresult = memcmp(VARDATA_ANY(arg1), VARDATA_ANY(arg2), Min(len1, len2));\n\tif (result != 0)\n\t\treturn result;\n\telse if (len1 < len2)\n\t\treturn -1;\n\telse if (len1 > len2)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ninternal_text_pattern_compare(text *arg1, text *arg2)\n{\n\tint\t\t\tresult;\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\n\tlen1 = VARSIZE_ANY_EXHDR(arg1);\n\tlen2 = VARSIZE_ANY_EXHDR(arg2);\n\n\tresult = memcmp(VARDATA_ANY(arg1), VARDATA_ANY(arg2), Min(len1, len2));\n\tif (result != 0)\n\t\treturn result;\n\telse if (len1 < len2)\n\t\treturn -1;\n\telse if (len1 > len2)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 2692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 2691
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\n\nDatum\ntext_pattern_le(PG_FUNCTION_ARGS)\n{\n\ttext\t   *arg1 = PG_GETARG_TEXT_PP(0);\n\ttext\t   *arg2 = PG_GETARG_TEXT_PP(1);\n\tint\t\t\tresult;\n\n\tresult = internal_text_pattern_compare(arg1, arg2);\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_BOOL(result <= 0);\n}"
  },
  {
    "function_name": "text_pattern_lt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "2672-2685",
    "snippet": "Datum\ntext_pattern_lt(PG_FUNCTION_ARGS)\n{\n\ttext\t   *arg1 = PG_GETARG_TEXT_PP(0);\n\ttext\t   *arg2 = PG_GETARG_TEXT_PP(1);\n\tint\t\t\tresult;\n\n\tresult = internal_text_pattern_compare(arg1, arg2);\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_BOOL(result < 0);\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "result < 0"
          ],
          "line": 2684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg2",
            "1"
          ],
          "line": 2682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg1",
            "0"
          ],
          "line": 2681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "internal_text_pattern_compare",
          "args": [
            "arg1",
            "arg2"
          ],
          "line": 2679
        },
        "resolved": true,
        "details": {
          "function_name": "internal_text_pattern_compare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "2650-2669",
          "snippet": "static int\ninternal_text_pattern_compare(text *arg1, text *arg2)\n{\n\tint\t\t\tresult;\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\n\tlen1 = VARSIZE_ANY_EXHDR(arg1);\n\tlen2 = VARSIZE_ANY_EXHDR(arg2);\n\n\tresult = memcmp(VARDATA_ANY(arg1), VARDATA_ANY(arg2), Min(len1, len2));\n\tif (result != 0)\n\t\treturn result;\n\telse if (len1 < len2)\n\t\treturn -1;\n\telse if (len1 > len2)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ninternal_text_pattern_compare(text *arg1, text *arg2)\n{\n\tint\t\t\tresult;\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\n\tlen1 = VARSIZE_ANY_EXHDR(arg1);\n\tlen2 = VARSIZE_ANY_EXHDR(arg2);\n\n\tresult = memcmp(VARDATA_ANY(arg1), VARDATA_ANY(arg2), Min(len1, len2));\n\tif (result != 0)\n\t\treturn result;\n\telse if (len1 < len2)\n\t\treturn -1;\n\telse if (len1 > len2)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 2676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 2675
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\n\nDatum\ntext_pattern_lt(PG_FUNCTION_ARGS)\n{\n\ttext\t   *arg1 = PG_GETARG_TEXT_PP(0);\n\ttext\t   *arg2 = PG_GETARG_TEXT_PP(1);\n\tint\t\t\tresult;\n\n\tresult = internal_text_pattern_compare(arg1, arg2);\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_BOOL(result < 0);\n}"
  },
  {
    "function_name": "internal_text_pattern_compare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "2650-2669",
    "snippet": "static int\ninternal_text_pattern_compare(text *arg1, text *arg2)\n{\n\tint\t\t\tresult;\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\n\tlen1 = VARSIZE_ANY_EXHDR(arg1);\n\tlen2 = VARSIZE_ANY_EXHDR(arg2);\n\n\tresult = memcmp(VARDATA_ANY(arg1), VARDATA_ANY(arg2), Min(len1, len2));\n\tif (result != 0)\n\t\treturn result;\n\telse if (len1 < len2)\n\t\treturn -1;\n\telse if (len1 > len2)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "VARDATA_ANY(arg1)",
            "VARDATA_ANY(arg2)",
            "Min(len1, len2)"
          ],
          "line": 2660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "len1",
            "len2"
          ],
          "line": 2660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "arg2"
          ],
          "line": 2660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "arg1"
          ],
          "line": 2660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "arg2"
          ],
          "line": 2658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "arg1"
          ],
          "line": 2657
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ninternal_text_pattern_compare(text *arg1, text *arg2)\n{\n\tint\t\t\tresult;\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\n\tlen1 = VARSIZE_ANY_EXHDR(arg1);\n\tlen2 = VARSIZE_ANY_EXHDR(arg2);\n\n\tresult = memcmp(VARDATA_ANY(arg1), VARDATA_ANY(arg2), Min(len1, len2));\n\tif (result != 0)\n\t\treturn result;\n\telse if (len1 < len2)\n\t\treturn -1;\n\telse if (len1 > len2)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}"
  },
  {
    "function_name": "text_smaller",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "2629-2639",
    "snippet": "Datum\ntext_smaller(PG_FUNCTION_ARGS)\n{\n\ttext\t   *arg1 = PG_GETARG_TEXT_PP(0);\n\ttext\t   *arg2 = PG_GETARG_TEXT_PP(1);\n\ttext\t   *result;\n\n\tresult = ((text_cmp(arg1, arg2, PG_GET_COLLATION()) < 0) ? arg1 : arg2);\n\n\tPG_RETURN_TEXT_P(result);\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "result"
          ],
          "line": 2638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text_cmp",
          "args": [
            "arg1",
            "arg2",
            "PG_GET_COLLATION()"
          ],
          "line": 2636
        },
        "resolved": true,
        "details": {
          "function_name": "text_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "1615-1630",
          "snippet": "static int\ntext_cmp(text *arg1, text *arg2, Oid collid)\n{\n\tchar\t   *a1p,\n\t\t\t   *a2p;\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\n\ta1p = VARDATA_ANY(arg1);\n\ta2p = VARDATA_ANY(arg2);\n\n\tlen1 = VARSIZE_ANY_EXHDR(arg1);\n\tlen2 = VARSIZE_ANY_EXHDR(arg2);\n\n\treturn varstr_cmp(a1p, len1, a2p, len2, collid);\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ttext_cmp(text *arg1, text *arg2, Oid collid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttext_cmp(text *arg1, text *arg2, Oid collid);\n\nstatic int\ntext_cmp(text *arg1, text *arg2, Oid collid)\n{\n\tchar\t   *a1p,\n\t\t\t   *a2p;\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\n\ta1p = VARDATA_ANY(arg1);\n\ta2p = VARDATA_ANY(arg2);\n\n\tlen1 = VARSIZE_ANY_EXHDR(arg1);\n\tlen2 = VARSIZE_ANY_EXHDR(arg2);\n\n\treturn varstr_cmp(a1p, len1, a2p, len2, collid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GET_COLLATION",
          "args": [],
          "line": 2636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 2633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 2632
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\n\nDatum\ntext_smaller(PG_FUNCTION_ARGS)\n{\n\ttext\t   *arg1 = PG_GETARG_TEXT_PP(0);\n\ttext\t   *arg2 = PG_GETARG_TEXT_PP(1);\n\ttext\t   *result;\n\n\tresult = ((text_cmp(arg1, arg2, PG_GET_COLLATION()) < 0) ? arg1 : arg2);\n\n\tPG_RETURN_TEXT_P(result);\n}"
  },
  {
    "function_name": "text_larger",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "2617-2627",
    "snippet": "Datum\ntext_larger(PG_FUNCTION_ARGS)\n{\n\ttext\t   *arg1 = PG_GETARG_TEXT_PP(0);\n\ttext\t   *arg2 = PG_GETARG_TEXT_PP(1);\n\ttext\t   *result;\n\n\tresult = ((text_cmp(arg1, arg2, PG_GET_COLLATION()) > 0) ? arg1 : arg2);\n\n\tPG_RETURN_TEXT_P(result);\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "result"
          ],
          "line": 2626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text_cmp",
          "args": [
            "arg1",
            "arg2",
            "PG_GET_COLLATION()"
          ],
          "line": 2624
        },
        "resolved": true,
        "details": {
          "function_name": "text_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "1615-1630",
          "snippet": "static int\ntext_cmp(text *arg1, text *arg2, Oid collid)\n{\n\tchar\t   *a1p,\n\t\t\t   *a2p;\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\n\ta1p = VARDATA_ANY(arg1);\n\ta2p = VARDATA_ANY(arg2);\n\n\tlen1 = VARSIZE_ANY_EXHDR(arg1);\n\tlen2 = VARSIZE_ANY_EXHDR(arg2);\n\n\treturn varstr_cmp(a1p, len1, a2p, len2, collid);\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ttext_cmp(text *arg1, text *arg2, Oid collid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttext_cmp(text *arg1, text *arg2, Oid collid);\n\nstatic int\ntext_cmp(text *arg1, text *arg2, Oid collid)\n{\n\tchar\t   *a1p,\n\t\t\t   *a2p;\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\n\ta1p = VARDATA_ANY(arg1);\n\ta2p = VARDATA_ANY(arg2);\n\n\tlen1 = VARSIZE_ANY_EXHDR(arg1);\n\tlen2 = VARSIZE_ANY_EXHDR(arg2);\n\n\treturn varstr_cmp(a1p, len1, a2p, len2, collid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GET_COLLATION",
          "args": [],
          "line": 2624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 2621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 2620
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\n\nDatum\ntext_larger(PG_FUNCTION_ARGS)\n{\n\ttext\t   *arg1 = PG_GETARG_TEXT_PP(0);\n\ttext\t   *arg2 = PG_GETARG_TEXT_PP(1);\n\ttext\t   *result;\n\n\tresult = ((text_cmp(arg1, arg2, PG_GET_COLLATION()) > 0) ? arg1 : arg2);\n\n\tPG_RETURN_TEXT_P(result);\n}"
  },
  {
    "function_name": "varstr_abbrev_abort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "2503-2615",
    "snippet": "static bool\nvarstr_abbrev_abort(int memtupcount, SortSupport ssup)\n{\n\tVarStringSortSupport *sss = (VarStringSortSupport *) ssup->ssup_extra;\n\tdouble\t\tabbrev_distinct,\n\t\t\t\tkey_distinct;\n\n\tAssert(ssup->abbreviate);\n\n\t/* Have a little patience */\n\tif (memtupcount < 100)\n\t\treturn false;\n\n\tabbrev_distinct = estimateHyperLogLog(&sss->abbr_card);\n\tkey_distinct = estimateHyperLogLog(&sss->full_card);\n\n\t/*\n\t * Clamp cardinality estimates to at least one distinct value.  While\n\t * NULLs are generally disregarded, if only NULL values were seen so far,\n\t * that might misrepresent costs if we failed to clamp.\n\t */\n\tif (abbrev_distinct <= 1.0)\n\t\tabbrev_distinct = 1.0;\n\n\tif (key_distinct <= 1.0)\n\t\tkey_distinct = 1.0;\n\n\t/*\n\t * In the worst case all abbreviated keys are identical, while at the same\n\t * time there are differences within full key strings not captured in\n\t * abbreviations.\n\t */\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t{\n\t\tdouble\t\tnorm_abbrev_card = abbrev_distinct / (double) memtupcount;\n\n\t\telog(LOG, \"varstr_abbrev: abbrev_distinct after %d: %f \"\n\t\t\t \"(key_distinct: %f, norm_abbrev_card: %f, prop_card: %f)\",\n\t\t\t memtupcount, abbrev_distinct, key_distinct, norm_abbrev_card,\n\t\t\t sss->prop_card);\n\t}\n#endif\n\n\t/*\n\t * If the number of distinct abbreviated keys approximately matches the\n\t * number of distinct authoritative original keys, that's reason enough to\n\t * proceed.  We can win even with a very low cardinality set if most\n\t * tie-breakers only memcmp().  This is by far the most important\n\t * consideration.\n\t *\n\t * While comparisons that are resolved at the abbreviated key level are\n\t * considerably cheaper than tie-breakers resolved with memcmp(), both of\n\t * those two outcomes are so much cheaper than a full strcoll() once\n\t * sorting is underway that it doesn't seem worth it to weigh abbreviated\n\t * cardinality against the overall size of the set in order to more\n\t * accurately model costs.  Assume that an abbreviated comparison, and an\n\t * abbreviated comparison with a cheap memcmp()-based authoritative\n\t * resolution are equivalent.\n\t */\n\tif (abbrev_distinct > key_distinct * sss->prop_card)\n\t{\n\t\t/*\n\t\t * When we have exceeded 10,000 tuples, decay required cardinality\n\t\t * aggressively for next call.\n\t\t *\n\t\t * This is useful because the number of comparisons required on\n\t\t * average increases at a linearithmic rate, and at roughly 10,000\n\t\t * tuples that factor will start to dominate over the linear costs of\n\t\t * string transformation (this is a conservative estimate).  The decay\n\t\t * rate is chosen to be a little less aggressive than halving -- which\n\t\t * (since we're called at points at which memtupcount has doubled)\n\t\t * would never see the cost model actually abort past the first call\n\t\t * following a decay.  This decay rate is mostly a precaution against\n\t\t * a sudden, violent swing in how well abbreviated cardinality tracks\n\t\t * full key cardinality.  The decay also serves to prevent a marginal\n\t\t * case from being aborted too late, when too much has already been\n\t\t * invested in string transformation.\n\t\t *\n\t\t * It's possible for sets of several million distinct strings with\n\t\t * mere tens of thousands of distinct abbreviated keys to still\n\t\t * benefit very significantly.  This will generally occur provided\n\t\t * each abbreviated key is a proxy for a roughly uniform number of the\n\t\t * set's full keys. If it isn't so, we hope to catch that early and\n\t\t * abort.  If it isn't caught early, by the time the problem is\n\t\t * apparent it's probably not worth aborting.\n\t\t */\n\t\tif (memtupcount > 10000)\n\t\t\tsss->prop_card *= 0.65;\n\n\t\treturn false;\n\t}\n\n\t/*\n\t * Abort abbreviation strategy.\n\t *\n\t * The worst case, where all abbreviated keys are identical while all\n\t * original strings differ will typically only see a regression of about\n\t * 10% in execution time for small to medium sized lists of strings.\n\t * Whereas on modern CPUs where cache stalls are the dominant cost, we can\n\t * often expect very large improvements, particularly with sets of strings\n\t * of moderately high to high abbreviated cardinality.  There is little to\n\t * lose but much to gain, which our strategy reflects.\n\t */\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\telog(LOG, \"varstr_abbrev: aborted abbreviation at %d \"\n\t\t\t \"(abbrev_distinct: %f, key_distinct: %f, prop_card: %f)\",\n\t\t\t memtupcount, abbrev_distinct, key_distinct, sss->prop_card);\n#endif\n\n\treturn true;\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tvarstrfastcmp_c(Datum x, Datum y, SortSupport ssup);",
      "static int\tbpcharfastcmp_c(Datum x, Datum y, SortSupport ssup);",
      "static int\tvarstrfastcmp_locale(Datum x, Datum y, SortSupport ssup);",
      "static int\tvarstrcmp_abbrev(Datum x, Datum y, SortSupport ssup);",
      "static Datum varstr_abbrev_convert(Datum original, SortSupport ssup);",
      "static bool varstr_abbrev_abort(int memtupcount, SortSupport ssup);",
      "static void appendStringInfoText(StringInfo str, const text *t);",
      "static bool text_format_parse_digits(const char **ptr, const char *end_ptr,\n\t\t\t\t\t\t int *value);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "LOG",
            "\"varstr_abbrev: aborted abbreviation at %d \"\n\t\t\t \"(abbrev_distinct: %f, key_distinct: %f, prop_card: %f)\"",
            "memtupcount",
            "abbrev_distinct",
            "key_distinct",
            "sss->prop_card"
          ],
          "line": 2609
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "estimateHyperLogLog",
          "args": [
            "&sss->full_card"
          ],
          "line": 2517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "estimateHyperLogLog",
          "args": [
            "&sss->abbr_card"
          ],
          "line": 2516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "ssup->abbreviate"
          ],
          "line": 2510
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\tvarstrfastcmp_c(Datum x, Datum y, SortSupport ssup);\nstatic int\tbpcharfastcmp_c(Datum x, Datum y, SortSupport ssup);\nstatic int\tvarstrfastcmp_locale(Datum x, Datum y, SortSupport ssup);\nstatic int\tvarstrcmp_abbrev(Datum x, Datum y, SortSupport ssup);\nstatic Datum varstr_abbrev_convert(Datum original, SortSupport ssup);\nstatic bool varstr_abbrev_abort(int memtupcount, SortSupport ssup);\nstatic void appendStringInfoText(StringInfo str, const text *t);\nstatic bool text_format_parse_digits(const char **ptr, const char *end_ptr,\n\t\t\t\t\t\t int *value);\n\nstatic bool\nvarstr_abbrev_abort(int memtupcount, SortSupport ssup)\n{\n\tVarStringSortSupport *sss = (VarStringSortSupport *) ssup->ssup_extra;\n\tdouble\t\tabbrev_distinct,\n\t\t\t\tkey_distinct;\n\n\tAssert(ssup->abbreviate);\n\n\t/* Have a little patience */\n\tif (memtupcount < 100)\n\t\treturn false;\n\n\tabbrev_distinct = estimateHyperLogLog(&sss->abbr_card);\n\tkey_distinct = estimateHyperLogLog(&sss->full_card);\n\n\t/*\n\t * Clamp cardinality estimates to at least one distinct value.  While\n\t * NULLs are generally disregarded, if only NULL values were seen so far,\n\t * that might misrepresent costs if we failed to clamp.\n\t */\n\tif (abbrev_distinct <= 1.0)\n\t\tabbrev_distinct = 1.0;\n\n\tif (key_distinct <= 1.0)\n\t\tkey_distinct = 1.0;\n\n\t/*\n\t * In the worst case all abbreviated keys are identical, while at the same\n\t * time there are differences within full key strings not captured in\n\t * abbreviations.\n\t */\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t{\n\t\tdouble\t\tnorm_abbrev_card = abbrev_distinct / (double) memtupcount;\n\n\t\telog(LOG, \"varstr_abbrev: abbrev_distinct after %d: %f \"\n\t\t\t \"(key_distinct: %f, norm_abbrev_card: %f, prop_card: %f)\",\n\t\t\t memtupcount, abbrev_distinct, key_distinct, norm_abbrev_card,\n\t\t\t sss->prop_card);\n\t}\n#endif\n\n\t/*\n\t * If the number of distinct abbreviated keys approximately matches the\n\t * number of distinct authoritative original keys, that's reason enough to\n\t * proceed.  We can win even with a very low cardinality set if most\n\t * tie-breakers only memcmp().  This is by far the most important\n\t * consideration.\n\t *\n\t * While comparisons that are resolved at the abbreviated key level are\n\t * considerably cheaper than tie-breakers resolved with memcmp(), both of\n\t * those two outcomes are so much cheaper than a full strcoll() once\n\t * sorting is underway that it doesn't seem worth it to weigh abbreviated\n\t * cardinality against the overall size of the set in order to more\n\t * accurately model costs.  Assume that an abbreviated comparison, and an\n\t * abbreviated comparison with a cheap memcmp()-based authoritative\n\t * resolution are equivalent.\n\t */\n\tif (abbrev_distinct > key_distinct * sss->prop_card)\n\t{\n\t\t/*\n\t\t * When we have exceeded 10,000 tuples, decay required cardinality\n\t\t * aggressively for next call.\n\t\t *\n\t\t * This is useful because the number of comparisons required on\n\t\t * average increases at a linearithmic rate, and at roughly 10,000\n\t\t * tuples that factor will start to dominate over the linear costs of\n\t\t * string transformation (this is a conservative estimate).  The decay\n\t\t * rate is chosen to be a little less aggressive than halving -- which\n\t\t * (since we're called at points at which memtupcount has doubled)\n\t\t * would never see the cost model actually abort past the first call\n\t\t * following a decay.  This decay rate is mostly a precaution against\n\t\t * a sudden, violent swing in how well abbreviated cardinality tracks\n\t\t * full key cardinality.  The decay also serves to prevent a marginal\n\t\t * case from being aborted too late, when too much has already been\n\t\t * invested in string transformation.\n\t\t *\n\t\t * It's possible for sets of several million distinct strings with\n\t\t * mere tens of thousands of distinct abbreviated keys to still\n\t\t * benefit very significantly.  This will generally occur provided\n\t\t * each abbreviated key is a proxy for a roughly uniform number of the\n\t\t * set's full keys. If it isn't so, we hope to catch that early and\n\t\t * abort.  If it isn't caught early, by the time the problem is\n\t\t * apparent it's probably not worth aborting.\n\t\t */\n\t\tif (memtupcount > 10000)\n\t\t\tsss->prop_card *= 0.65;\n\n\t\treturn false;\n\t}\n\n\t/*\n\t * Abort abbreviation strategy.\n\t *\n\t * The worst case, where all abbreviated keys are identical while all\n\t * original strings differ will typically only see a regression of about\n\t * 10% in execution time for small to medium sized lists of strings.\n\t * Whereas on modern CPUs where cache stalls are the dominant cost, we can\n\t * often expect very large improvements, particularly with sets of strings\n\t * of moderately high to high abbreviated cardinality.  There is little to\n\t * lose but much to gain, which our strategy reflects.\n\t */\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\telog(LOG, \"varstr_abbrev: aborted abbreviation at %d \"\n\t\t\t \"(abbrev_distinct: %f, key_distinct: %f, prop_card: %f)\",\n\t\t\t memtupcount, abbrev_distinct, key_distinct, sss->prop_card);\n#endif\n\n\treturn true;\n}"
  },
  {
    "function_name": "varstr_abbrev_convert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "2263-2496",
    "snippet": "static Datum\nvarstr_abbrev_convert(Datum original, SortSupport ssup)\n{\n\tVarStringSortSupport *sss = (VarStringSortSupport *) ssup->ssup_extra;\n\tVarString  *authoritative = DatumGetVarStringPP(original);\n\tchar\t   *authoritative_data = VARDATA_ANY(authoritative);\n\n\t/* working state */\n\tDatum\t\tres;\n\tchar\t   *pres;\n\tint\t\t\tlen;\n\tuint32\t\thash;\n\n\tpres = (char *) &res;\n\t/* memset(), so any non-overwritten bytes are NUL */\n\tmemset(pres, 0, sizeof(Datum));\n\tlen = VARSIZE_ANY_EXHDR(authoritative);\n\n\t/* Get number of bytes, ignoring trailing spaces */\n\tif (sss->bpchar)\n\t\tlen = bpchartruelen(authoritative_data, len);\n\n\t/*\n\t * If we're using the C collation, use memcpy(), rather than strxfrm(), to\n\t * abbreviate keys.  The full comparator for the C locale is always\n\t * memcmp().  It would be incorrect to allow bytea callers (callers that\n\t * always force the C collation -- bytea isn't a collatable type, but this\n\t * approach is convenient) to use strxfrm().  This is because bytea\n\t * strings may contain NUL bytes.  Besides, this should be faster, too.\n\t *\n\t * More generally, it's okay that bytea callers can have NUL bytes in\n\t * strings because varstrcmp_abbrev() need not make a distinction between\n\t * terminating NUL bytes, and NUL bytes representing actual NULs in the\n\t * authoritative representation.  Hopefully a comparison at or past one\n\t * abbreviated key's terminating NUL byte will resolve the comparison\n\t * without consulting the authoritative representation; specifically, some\n\t * later non-NUL byte in the longer string can resolve the comparison\n\t * against a subsequent terminating NUL in the shorter string.  There will\n\t * usually be what is effectively a \"length-wise\" resolution there and\n\t * then.\n\t *\n\t * If that doesn't work out -- if all bytes in the longer string\n\t * positioned at or past the offset of the smaller string's (first)\n\t * terminating NUL are actually representative of NUL bytes in the\n\t * authoritative binary string (perhaps with some *terminating* NUL bytes\n\t * towards the end of the longer string iff it happens to still be small)\n\t * -- then an authoritative tie-breaker will happen, and do the right\n\t * thing: explicitly consider string length.\n\t */\n\tif (sss->collate_c)\n\t\tmemcpy(pres, authoritative_data, Min(len, sizeof(Datum)));\n\telse\n\t{\n\t\tSize\t\tbsize;\n#ifdef USE_ICU\n\t\tint32_t\t\tulen = -1;\n\t\tUChar\t   *uchar = NULL;\n#endif\n\n\t\t/*\n\t\t * We're not using the C collation, so fall back on strxfrm or ICU\n\t\t * analogs.\n\t\t */\n\n\t\t/* By convention, we use buffer 1 to store and NUL-terminate */\n\t\tif (len >= sss->buflen1)\n\t\t{\n\t\t\tpfree(sss->buf1);\n\t\t\tsss->buflen1 = Max(len + 1, Min(sss->buflen1 * 2, MaxAllocSize));\n\t\t\tsss->buf1 = palloc(sss->buflen1);\n\t\t}\n\n\t\t/* Might be able to reuse strxfrm() blob from last call */\n\t\tif (sss->last_len1 == len && sss->cache_blob &&\n\t\t\tmemcmp(sss->buf1, authoritative_data, len) == 0)\n\t\t{\n\t\t\tmemcpy(pres, sss->buf2, Min(sizeof(Datum), sss->last_len2));\n\t\t\t/* No change affecting cardinality, so no hashing required */\n\t\t\tgoto done;\n\t\t}\n\n\t\tmemcpy(sss->buf1, authoritative_data, len);\n\n\t\t/*\n\t\t * Just like strcoll(), strxfrm() expects a NUL-terminated string. Not\n\t\t * necessary for ICU, but doesn't hurt.\n\t\t */\n\t\tsss->buf1[len] = '\\0';\n\t\tsss->last_len1 = len;\n\n#ifdef USE_ICU\n\t\t/* When using ICU and not UTF8, convert string to UChar. */\n\t\tif (sss->locale && sss->locale->provider == COLLPROVIDER_ICU &&\n\t\t\tGetDatabaseEncoding() != PG_UTF8)\n\t\t\tulen = icu_to_uchar(&uchar, sss->buf1, len);\n#endif\n\n\t\t/*\n\t\t * Loop: Call strxfrm() or ucol_getSortKey(), possibly enlarge buffer,\n\t\t * and try again.  Both of these functions have the result buffer\n\t\t * content undefined if the result did not fit, so we need to retry\n\t\t * until everything fits, even though we only need the first few bytes\n\t\t * in the end.  When using ucol_nextSortKeyPart(), however, we only\n\t\t * ask for as many bytes as we actually need.\n\t\t */\n\t\tfor (;;)\n\t\t{\n#ifdef USE_ICU\n\t\t\tif (sss->locale && sss->locale->provider == COLLPROVIDER_ICU)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * When using UTF8, use the iteration interface so we only\n\t\t\t\t * need to produce as many bytes as we actually need.\n\t\t\t\t */\n\t\t\t\tif (GetDatabaseEncoding() == PG_UTF8)\n\t\t\t\t{\n\t\t\t\t\tUCharIterator iter;\n\t\t\t\t\tuint32_t\tstate[2];\n\t\t\t\t\tUErrorCode\tstatus;\n\n\t\t\t\t\tuiter_setUTF8(&iter, sss->buf1, len);\n\t\t\t\t\tstate[0] = state[1] = 0;\t/* won't need that again */\n\t\t\t\t\tstatus = U_ZERO_ERROR;\n\t\t\t\t\tbsize = ucol_nextSortKeyPart(sss->locale->info.icu.ucol,\n\t\t\t\t\t\t\t\t\t\t\t\t &iter,\n\t\t\t\t\t\t\t\t\t\t\t\t state,\n\t\t\t\t\t\t\t\t\t\t\t\t (uint8_t *) sss->buf2,\n\t\t\t\t\t\t\t\t\t\t\t\t Min(sizeof(Datum), sss->buflen2),\n\t\t\t\t\t\t\t\t\t\t\t\t &status);\n\t\t\t\t\tif (U_FAILURE(status))\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errmsg(\"sort key generation failed: %s\",\n\t\t\t\t\t\t\t\t\t\tu_errorName(status))));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tbsize = ucol_getSortKey(sss->locale->info.icu.ucol,\n\t\t\t\t\t\t\t\t\t\t\tuchar, ulen,\n\t\t\t\t\t\t\t\t\t\t\t(uint8_t *) sss->buf2, sss->buflen2);\n\t\t\t}\n\t\t\telse\n#endif\n#ifdef HAVE_LOCALE_T\n\t\t\tif (sss->locale && sss->locale->provider == COLLPROVIDER_LIBC)\n\t\t\t\tbsize = strxfrm_l(sss->buf2, sss->buf1,\n\t\t\t\t\t\t\t\t  sss->buflen2, sss->locale->info.lt);\n\t\t\telse\n#endif\n\t\t\t\tbsize = strxfrm(sss->buf2, sss->buf1, sss->buflen2);\n\n\t\t\tsss->last_len2 = bsize;\n\t\t\tif (bsize < sss->buflen2)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * Grow buffer and retry.\n\t\t\t */\n\t\t\tpfree(sss->buf2);\n\t\t\tsss->buflen2 = Max(bsize + 1,\n\t\t\t\t\t\t\t   Min(sss->buflen2 * 2, MaxAllocSize));\n\t\t\tsss->buf2 = palloc(sss->buflen2);\n\t\t}\n\n\t\t/*\n\t\t * Every Datum byte is always compared.  This is safe because the\n\t\t * strxfrm() blob is itself NUL terminated, leaving no danger of\n\t\t * misinterpreting any NUL bytes not intended to be interpreted as\n\t\t * logically representing termination.\n\t\t *\n\t\t * (Actually, even if there were NUL bytes in the blob it would be\n\t\t * okay.  See remarks on bytea case above.)\n\t\t */\n\t\tmemcpy(pres, sss->buf2, Min(sizeof(Datum), bsize));\n\n#ifdef USE_ICU\n\t\tif (uchar)\n\t\t\tpfree(uchar);\n#endif\n\t}\n\n\t/*\n\t * Maintain approximate cardinality of both abbreviated keys and original,\n\t * authoritative keys using HyperLogLog.  Used as cheap insurance against\n\t * the worst case, where we do many string transformations for no saving\n\t * in full strcoll()-based comparisons.  These statistics are used by\n\t * varstr_abbrev_abort().\n\t *\n\t * First, Hash key proper, or a significant fraction of it.  Mix in length\n\t * in order to compensate for cases where differences are past\n\t * PG_CACHE_LINE_SIZE bytes, so as to limit the overhead of hashing.\n\t */\n\thash = DatumGetUInt32(hash_any((unsigned char *) authoritative_data,\n\t\t\t\t\t\t\t\t   Min(len, PG_CACHE_LINE_SIZE)));\n\n\tif (len > PG_CACHE_LINE_SIZE)\n\t\thash ^= DatumGetUInt32(hash_uint32((uint32) len));\n\n\taddHyperLogLog(&sss->full_card, hash);\n\n\t/* Hash abbreviated key */\n#if SIZEOF_DATUM == 8\n\t{\n\t\tuint32\t\tlohalf,\n\t\t\t\t\thihalf;\n\n\t\tlohalf = (uint32) res;\n\t\thihalf = (uint32) (res >> 32);\n\t\thash = DatumGetUInt32(hash_uint32(lohalf ^ hihalf));\n\t}\n#else\t\t\t\t\t\t\t/* SIZEOF_DATUM != 8 */\n\thash = DatumGetUInt32(hash_uint32((uint32) res));\n#endif\n\n\taddHyperLogLog(&sss->abbr_card, hash);\n\n\t/* Cache result, perhaps saving an expensive strxfrm() call next time */\n\tsss->cache_blob = true;\ndone:\n\n\t/*\n\t * Byteswap on little-endian machines.\n\t *\n\t * This is needed so that varstrcmp_abbrev() (an unsigned integer 3-way\n\t * comparator) works correctly on all platforms.  If we didn't do this,\n\t * the comparator would have to call memcmp() with a pair of pointers to\n\t * the first byte of each abbreviated key, which is slower.\n\t */\n\tres = DatumBigEndianToNative(res);\n\n\t/* Don't leak memory here */\n\tif (PointerGetDatum(authoritative) != original)\n\t\tpfree(authoritative);\n\n\treturn res;\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tvarstrfastcmp_c(Datum x, Datum y, SortSupport ssup);",
      "static int\tbpcharfastcmp_c(Datum x, Datum y, SortSupport ssup);",
      "static int\tvarstrfastcmp_locale(Datum x, Datum y, SortSupport ssup);",
      "static int\tvarstrcmp_abbrev(Datum x, Datum y, SortSupport ssup);",
      "static Datum varstr_abbrev_convert(Datum original, SortSupport ssup);",
      "static bool varstr_abbrev_abort(int memtupcount, SortSupport ssup);",
      "static void text_position_setup(text *t1, text *t2, TextPositionState *state);",
      "static int\ttext_position_next(int start_pos, TextPositionState *state);",
      "static void text_position_cleanup(TextPositionState *state);",
      "static void appendStringInfoText(StringInfo str, const text *t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "authoritative"
          ],
          "line": 2493
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "authoritative"
          ],
          "line": 2492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumBigEndianToNative",
          "args": [
            "res"
          ],
          "line": 2489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addHyperLogLog",
          "args": [
            "&sss->abbr_card",
            "hash"
          ],
          "line": 2475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetUInt32",
          "args": [
            "hash_uint32((uint32) res)"
          ],
          "line": 2472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_uint32",
          "args": [
            "(uint32) res"
          ],
          "line": 2472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetUInt32",
          "args": [
            "hash_uint32(lohalf ^ hihalf)"
          ],
          "line": 2469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_uint32",
          "args": [
            "lohalf ^ hihalf"
          ],
          "line": 2469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "res >> 32"
          ],
          "line": 2468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addHyperLogLog",
          "args": [
            "&sss->full_card",
            "hash"
          ],
          "line": 2459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetUInt32",
          "args": [
            "hash_uint32((uint32) len)"
          ],
          "line": 2457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_uint32",
          "args": [
            "(uint32) len"
          ],
          "line": 2457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetUInt32",
          "args": [
            "hash_any((unsigned char *) authoritative_data,\n\t\t\t\t\t\t\t\t   Min(len, PG_CACHE_LINE_SIZE))"
          ],
          "line": 2453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_any",
          "args": [
            "(unsigned char *) authoritative_data",
            "Min(len, PG_CACHE_LINE_SIZE)"
          ],
          "line": 2453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "len",
            "PG_CACHE_LINE_SIZE"
          ],
          "line": 2454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "pres",
            "sss->buf2",
            "Min(sizeof(Datum), bsize)"
          ],
          "line": 2434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "sizeof(Datum)",
            "bsize"
          ],
          "line": 2434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sss->buflen2"
          ],
          "line": 2422
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Max",
          "args": [
            "bsize + 1",
            "Min(sss->buflen2 * 2, MaxAllocSize)"
          ],
          "line": 2420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "sss->buflen2 * 2",
            "MaxAllocSize"
          ],
          "line": 2421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strxfrm",
          "args": [
            "sss->buf2",
            "sss->buf1",
            "sss->buflen2"
          ],
          "line": 2410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strxfrm_l",
          "args": [
            "sss->buf2",
            "sss->buf1",
            "sss->buflen2",
            "sss->locale->info.lt"
          ],
          "line": 2406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ucol_getSortKey",
          "args": [
            "sss->locale->info.icu.ucol",
            "uchar",
            "ulen",
            "(uint8_t *) sss->buf2",
            "sss->buflen2"
          ],
          "line": 2398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errmsg(\"sort key generation failed: %s\",\n\t\t\t\t\t\t\t\t\t\tu_errorName(status)))"
          ],
          "line": 2393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"sort key generation failed: %s\"",
            "u_errorName(status)"
          ],
          "line": 2394
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "u_errorName",
          "args": [
            "status"
          ],
          "line": 2395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "U_FAILURE",
          "args": [
            "status"
          ],
          "line": 2392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ucol_nextSortKeyPart",
          "args": [
            "sss->locale->info.icu.ucol",
            "&iter",
            "state",
            "(uint8_t *) sss->buf2",
            "Min(sizeof(Datum), sss->buflen2)",
            "&status"
          ],
          "line": 2386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "sizeof(Datum)",
            "sss->buflen2"
          ],
          "line": 2390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uiter_setUTF8",
          "args": [
            "&iter",
            "sss->buf1",
            "len"
          ],
          "line": 2383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetDatabaseEncoding",
          "args": [],
          "line": 2377
        },
        "resolved": true,
        "details": {
          "function_name": "GetDatabaseEncodingName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "1009-1013",
          "snippet": "const char *\nGetDatabaseEncodingName(void)\n{\n\treturn DatabaseEncoding->name;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nconst char *\nGetDatabaseEncodingName(void)\n{\n\treturn DatabaseEncoding->name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "icu_to_uchar",
          "args": [
            "&uchar",
            "sss->buf1",
            "len"
          ],
          "line": 2357
        },
        "resolved": true,
        "details": {
          "function_name": "icu_to_uchar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "1585-1610",
          "snippet": "int32_t\nicu_to_uchar(UChar **buff_uchar, const char *buff, size_t nbytes)\n{\n\tUErrorCode\tstatus;\n\tint32_t\t\tlen_uchar;\n\n\tinit_icu_converter();\n\n\tstatus = U_ZERO_ERROR;\n\tlen_uchar = ucnv_toUChars(icu_converter, NULL, 0,\n\t\t\t\t\t\t\t  buff, nbytes, &status);\n\tif (U_FAILURE(status) && status != U_BUFFER_OVERFLOW_ERROR)\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"ucnv_toUChars failed: %s\", u_errorName(status))));\n\n\t*buff_uchar = palloc((len_uchar + 1) * sizeof(**buff_uchar));\n\n\tstatus = U_ZERO_ERROR;\n\tlen_uchar = ucnv_toUChars(icu_converter, *buff_uchar, len_uchar + 1,\n\t\t\t\t\t\t\t  buff, nbytes, &status);\n\tif (U_FAILURE(status))\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"ucnv_toUChars failed: %s\", u_errorName(status))));\n\n\treturn len_uchar;\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nint32_t\nicu_to_uchar(UChar **buff_uchar, const char *buff, size_t nbytes)\n{\n\tUErrorCode\tstatus;\n\tint32_t\t\tlen_uchar;\n\n\tinit_icu_converter();\n\n\tstatus = U_ZERO_ERROR;\n\tlen_uchar = ucnv_toUChars(icu_converter, NULL, 0,\n\t\t\t\t\t\t\t  buff, nbytes, &status);\n\tif (U_FAILURE(status) && status != U_BUFFER_OVERFLOW_ERROR)\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"ucnv_toUChars failed: %s\", u_errorName(status))));\n\n\t*buff_uchar = palloc((len_uchar + 1) * sizeof(**buff_uchar));\n\n\tstatus = U_ZERO_ERROR;\n\tlen_uchar = ucnv_toUChars(icu_converter, *buff_uchar, len_uchar + 1,\n\t\t\t\t\t\t\t  buff, nbytes, &status);\n\tif (U_FAILURE(status))\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"ucnv_toUChars failed: %s\", u_errorName(status))));\n\n\treturn len_uchar;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sss->buf1",
            "authoritative_data",
            "len"
          ],
          "line": 2344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "pres",
            "sss->buf2",
            "Min(sizeof(Datum), sss->last_len2)"
          ],
          "line": 2339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "sizeof(Datum)",
            "sss->last_len2"
          ],
          "line": 2339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "sss->buf1",
            "authoritative_data",
            "len"
          ],
          "line": 2337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Max",
          "args": [
            "len + 1",
            "Min(sss->buflen1 * 2, MaxAllocSize)"
          ],
          "line": 2331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "sss->buflen1 * 2",
            "MaxAllocSize"
          ],
          "line": 2331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "pres",
            "authoritative_data",
            "Min(len, sizeof(Datum))"
          ],
          "line": 2313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "len",
            "sizeof(Datum)"
          ],
          "line": 2313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpchartruelen",
          "args": [
            "authoritative_data",
            "len"
          ],
          "line": 2283
        },
        "resolved": true,
        "details": {
          "function_name": "bpchartruelen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
          "lines": "659-674",
          "snippet": "int\nbpchartruelen(char *s, int len)\n{\n\tint\t\t\ti;\n\n\t/*\n\t * Note that we rely on the assumption that ' ' is a singleton unit on\n\t * every supported multibyte server encoding.\n\t */\n\tfor (i = len - 1; i >= 0; i--)\n\t{\n\t\tif (s[i] != ' ')\n\t\t\tbreak;\n\t}\n\treturn i + 1;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nint\nbpchartruelen(char *s, int len)\n{\n\tint\t\t\ti;\n\n\t/*\n\t * Note that we rely on the assumption that ' ' is a singleton unit on\n\t * every supported multibyte server encoding.\n\t */\n\tfor (i = len - 1; i >= 0; i--)\n\t{\n\t\tif (s[i] != ' ')\n\t\t\tbreak;\n\t}\n\treturn i + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "authoritative"
          ],
          "line": 2279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "pres",
            "0",
            "sizeof(Datum)"
          ],
          "line": 2278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "authoritative"
          ],
          "line": 2268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetVarStringPP",
          "args": [
            "original"
          ],
          "line": 2267
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\tvarstrfastcmp_c(Datum x, Datum y, SortSupport ssup);\nstatic int\tbpcharfastcmp_c(Datum x, Datum y, SortSupport ssup);\nstatic int\tvarstrfastcmp_locale(Datum x, Datum y, SortSupport ssup);\nstatic int\tvarstrcmp_abbrev(Datum x, Datum y, SortSupport ssup);\nstatic Datum varstr_abbrev_convert(Datum original, SortSupport ssup);\nstatic bool varstr_abbrev_abort(int memtupcount, SortSupport ssup);\nstatic void text_position_setup(text *t1, text *t2, TextPositionState *state);\nstatic int\ttext_position_next(int start_pos, TextPositionState *state);\nstatic void text_position_cleanup(TextPositionState *state);\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nstatic Datum\nvarstr_abbrev_convert(Datum original, SortSupport ssup)\n{\n\tVarStringSortSupport *sss = (VarStringSortSupport *) ssup->ssup_extra;\n\tVarString  *authoritative = DatumGetVarStringPP(original);\n\tchar\t   *authoritative_data = VARDATA_ANY(authoritative);\n\n\t/* working state */\n\tDatum\t\tres;\n\tchar\t   *pres;\n\tint\t\t\tlen;\n\tuint32\t\thash;\n\n\tpres = (char *) &res;\n\t/* memset(), so any non-overwritten bytes are NUL */\n\tmemset(pres, 0, sizeof(Datum));\n\tlen = VARSIZE_ANY_EXHDR(authoritative);\n\n\t/* Get number of bytes, ignoring trailing spaces */\n\tif (sss->bpchar)\n\t\tlen = bpchartruelen(authoritative_data, len);\n\n\t/*\n\t * If we're using the C collation, use memcpy(), rather than strxfrm(), to\n\t * abbreviate keys.  The full comparator for the C locale is always\n\t * memcmp().  It would be incorrect to allow bytea callers (callers that\n\t * always force the C collation -- bytea isn't a collatable type, but this\n\t * approach is convenient) to use strxfrm().  This is because bytea\n\t * strings may contain NUL bytes.  Besides, this should be faster, too.\n\t *\n\t * More generally, it's okay that bytea callers can have NUL bytes in\n\t * strings because varstrcmp_abbrev() need not make a distinction between\n\t * terminating NUL bytes, and NUL bytes representing actual NULs in the\n\t * authoritative representation.  Hopefully a comparison at or past one\n\t * abbreviated key's terminating NUL byte will resolve the comparison\n\t * without consulting the authoritative representation; specifically, some\n\t * later non-NUL byte in the longer string can resolve the comparison\n\t * against a subsequent terminating NUL in the shorter string.  There will\n\t * usually be what is effectively a \"length-wise\" resolution there and\n\t * then.\n\t *\n\t * If that doesn't work out -- if all bytes in the longer string\n\t * positioned at or past the offset of the smaller string's (first)\n\t * terminating NUL are actually representative of NUL bytes in the\n\t * authoritative binary string (perhaps with some *terminating* NUL bytes\n\t * towards the end of the longer string iff it happens to still be small)\n\t * -- then an authoritative tie-breaker will happen, and do the right\n\t * thing: explicitly consider string length.\n\t */\n\tif (sss->collate_c)\n\t\tmemcpy(pres, authoritative_data, Min(len, sizeof(Datum)));\n\telse\n\t{\n\t\tSize\t\tbsize;\n#ifdef USE_ICU\n\t\tint32_t\t\tulen = -1;\n\t\tUChar\t   *uchar = NULL;\n#endif\n\n\t\t/*\n\t\t * We're not using the C collation, so fall back on strxfrm or ICU\n\t\t * analogs.\n\t\t */\n\n\t\t/* By convention, we use buffer 1 to store and NUL-terminate */\n\t\tif (len >= sss->buflen1)\n\t\t{\n\t\t\tpfree(sss->buf1);\n\t\t\tsss->buflen1 = Max(len + 1, Min(sss->buflen1 * 2, MaxAllocSize));\n\t\t\tsss->buf1 = palloc(sss->buflen1);\n\t\t}\n\n\t\t/* Might be able to reuse strxfrm() blob from last call */\n\t\tif (sss->last_len1 == len && sss->cache_blob &&\n\t\t\tmemcmp(sss->buf1, authoritative_data, len) == 0)\n\t\t{\n\t\t\tmemcpy(pres, sss->buf2, Min(sizeof(Datum), sss->last_len2));\n\t\t\t/* No change affecting cardinality, so no hashing required */\n\t\t\tgoto done;\n\t\t}\n\n\t\tmemcpy(sss->buf1, authoritative_data, len);\n\n\t\t/*\n\t\t * Just like strcoll(), strxfrm() expects a NUL-terminated string. Not\n\t\t * necessary for ICU, but doesn't hurt.\n\t\t */\n\t\tsss->buf1[len] = '\\0';\n\t\tsss->last_len1 = len;\n\n#ifdef USE_ICU\n\t\t/* When using ICU and not UTF8, convert string to UChar. */\n\t\tif (sss->locale && sss->locale->provider == COLLPROVIDER_ICU &&\n\t\t\tGetDatabaseEncoding() != PG_UTF8)\n\t\t\tulen = icu_to_uchar(&uchar, sss->buf1, len);\n#endif\n\n\t\t/*\n\t\t * Loop: Call strxfrm() or ucol_getSortKey(), possibly enlarge buffer,\n\t\t * and try again.  Both of these functions have the result buffer\n\t\t * content undefined if the result did not fit, so we need to retry\n\t\t * until everything fits, even though we only need the first few bytes\n\t\t * in the end.  When using ucol_nextSortKeyPart(), however, we only\n\t\t * ask for as many bytes as we actually need.\n\t\t */\n\t\tfor (;;)\n\t\t{\n#ifdef USE_ICU\n\t\t\tif (sss->locale && sss->locale->provider == COLLPROVIDER_ICU)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * When using UTF8, use the iteration interface so we only\n\t\t\t\t * need to produce as many bytes as we actually need.\n\t\t\t\t */\n\t\t\t\tif (GetDatabaseEncoding() == PG_UTF8)\n\t\t\t\t{\n\t\t\t\t\tUCharIterator iter;\n\t\t\t\t\tuint32_t\tstate[2];\n\t\t\t\t\tUErrorCode\tstatus;\n\n\t\t\t\t\tuiter_setUTF8(&iter, sss->buf1, len);\n\t\t\t\t\tstate[0] = state[1] = 0;\t/* won't need that again */\n\t\t\t\t\tstatus = U_ZERO_ERROR;\n\t\t\t\t\tbsize = ucol_nextSortKeyPart(sss->locale->info.icu.ucol,\n\t\t\t\t\t\t\t\t\t\t\t\t &iter,\n\t\t\t\t\t\t\t\t\t\t\t\t state,\n\t\t\t\t\t\t\t\t\t\t\t\t (uint8_t *) sss->buf2,\n\t\t\t\t\t\t\t\t\t\t\t\t Min(sizeof(Datum), sss->buflen2),\n\t\t\t\t\t\t\t\t\t\t\t\t &status);\n\t\t\t\t\tif (U_FAILURE(status))\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errmsg(\"sort key generation failed: %s\",\n\t\t\t\t\t\t\t\t\t\tu_errorName(status))));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tbsize = ucol_getSortKey(sss->locale->info.icu.ucol,\n\t\t\t\t\t\t\t\t\t\t\tuchar, ulen,\n\t\t\t\t\t\t\t\t\t\t\t(uint8_t *) sss->buf2, sss->buflen2);\n\t\t\t}\n\t\t\telse\n#endif\n#ifdef HAVE_LOCALE_T\n\t\t\tif (sss->locale && sss->locale->provider == COLLPROVIDER_LIBC)\n\t\t\t\tbsize = strxfrm_l(sss->buf2, sss->buf1,\n\t\t\t\t\t\t\t\t  sss->buflen2, sss->locale->info.lt);\n\t\t\telse\n#endif\n\t\t\t\tbsize = strxfrm(sss->buf2, sss->buf1, sss->buflen2);\n\n\t\t\tsss->last_len2 = bsize;\n\t\t\tif (bsize < sss->buflen2)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * Grow buffer and retry.\n\t\t\t */\n\t\t\tpfree(sss->buf2);\n\t\t\tsss->buflen2 = Max(bsize + 1,\n\t\t\t\t\t\t\t   Min(sss->buflen2 * 2, MaxAllocSize));\n\t\t\tsss->buf2 = palloc(sss->buflen2);\n\t\t}\n\n\t\t/*\n\t\t * Every Datum byte is always compared.  This is safe because the\n\t\t * strxfrm() blob is itself NUL terminated, leaving no danger of\n\t\t * misinterpreting any NUL bytes not intended to be interpreted as\n\t\t * logically representing termination.\n\t\t *\n\t\t * (Actually, even if there were NUL bytes in the blob it would be\n\t\t * okay.  See remarks on bytea case above.)\n\t\t */\n\t\tmemcpy(pres, sss->buf2, Min(sizeof(Datum), bsize));\n\n#ifdef USE_ICU\n\t\tif (uchar)\n\t\t\tpfree(uchar);\n#endif\n\t}\n\n\t/*\n\t * Maintain approximate cardinality of both abbreviated keys and original,\n\t * authoritative keys using HyperLogLog.  Used as cheap insurance against\n\t * the worst case, where we do many string transformations for no saving\n\t * in full strcoll()-based comparisons.  These statistics are used by\n\t * varstr_abbrev_abort().\n\t *\n\t * First, Hash key proper, or a significant fraction of it.  Mix in length\n\t * in order to compensate for cases where differences are past\n\t * PG_CACHE_LINE_SIZE bytes, so as to limit the overhead of hashing.\n\t */\n\thash = DatumGetUInt32(hash_any((unsigned char *) authoritative_data,\n\t\t\t\t\t\t\t\t   Min(len, PG_CACHE_LINE_SIZE)));\n\n\tif (len > PG_CACHE_LINE_SIZE)\n\t\thash ^= DatumGetUInt32(hash_uint32((uint32) len));\n\n\taddHyperLogLog(&sss->full_card, hash);\n\n\t/* Hash abbreviated key */\n#if SIZEOF_DATUM == 8\n\t{\n\t\tuint32\t\tlohalf,\n\t\t\t\t\thihalf;\n\n\t\tlohalf = (uint32) res;\n\t\thihalf = (uint32) (res >> 32);\n\t\thash = DatumGetUInt32(hash_uint32(lohalf ^ hihalf));\n\t}\n#else\t\t\t\t\t\t\t/* SIZEOF_DATUM != 8 */\n\thash = DatumGetUInt32(hash_uint32((uint32) res));\n#endif\n\n\taddHyperLogLog(&sss->abbr_card, hash);\n\n\t/* Cache result, perhaps saving an expensive strxfrm() call next time */\n\tsss->cache_blob = true;\ndone:\n\n\t/*\n\t * Byteswap on little-endian machines.\n\t *\n\t * This is needed so that varstrcmp_abbrev() (an unsigned integer 3-way\n\t * comparator) works correctly on all platforms.  If we didn't do this,\n\t * the comparator would have to call memcmp() with a pair of pointers to\n\t * the first byte of each abbreviated key, which is slower.\n\t */\n\tres = DatumBigEndianToNative(res);\n\n\t/* Don't leak memory here */\n\tif (PointerGetDatum(authoritative) != original)\n\t\tpfree(authoritative);\n\n\treturn res;\n}"
  },
  {
    "function_name": "varstrcmp_abbrev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "2238-2254",
    "snippet": "static int\nvarstrcmp_abbrev(Datum x, Datum y, SortSupport ssup)\n{\n\t/*\n\t * When 0 is returned, the core system will call varstrfastcmp_c()\n\t * (bpcharfastcmp_c() in BpChar case) or varstrfastcmp_locale().  Even a\n\t * strcmp() on two non-truncated strxfrm() blobs cannot indicate *equality*\n\t * authoritatively, for the same reason that there is a strcoll()\n\t * tie-breaker call to strcmp() in varstr_cmp().\n\t */\n\tif (x > y)\n\t\treturn 1;\n\telse if (x == y)\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tvarstrfastcmp_c(Datum x, Datum y, SortSupport ssup);",
      "static int\tbpcharfastcmp_c(Datum x, Datum y, SortSupport ssup);",
      "static int\tvarstrfastcmp_locale(Datum x, Datum y, SortSupport ssup);",
      "static int\tvarstrcmp_abbrev(Datum x, Datum y, SortSupport ssup);",
      "static Datum varstr_abbrev_convert(Datum original, SortSupport ssup);",
      "static bool varstr_abbrev_abort(int memtupcount, SortSupport ssup);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\tvarstrfastcmp_c(Datum x, Datum y, SortSupport ssup);\nstatic int\tbpcharfastcmp_c(Datum x, Datum y, SortSupport ssup);\nstatic int\tvarstrfastcmp_locale(Datum x, Datum y, SortSupport ssup);\nstatic int\tvarstrcmp_abbrev(Datum x, Datum y, SortSupport ssup);\nstatic Datum varstr_abbrev_convert(Datum original, SortSupport ssup);\nstatic bool varstr_abbrev_abort(int memtupcount, SortSupport ssup);\n\nstatic int\nvarstrcmp_abbrev(Datum x, Datum y, SortSupport ssup)\n{\n\t/*\n\t * When 0 is returned, the core system will call varstrfastcmp_c()\n\t * (bpcharfastcmp_c() in BpChar case) or varstrfastcmp_locale().  Even a\n\t * strcmp() on two non-truncated strxfrm() blobs cannot indicate *equality*\n\t * authoritatively, for the same reason that there is a strcoll()\n\t * tie-breaker call to strcmp() in varstr_cmp().\n\t */\n\tif (x > y)\n\t\treturn 1;\n\telse if (x == y)\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}"
  },
  {
    "function_name": "varstrfastcmp_locale",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "2060-2233",
    "snippet": "static int\nvarstrfastcmp_locale(Datum x, Datum y, SortSupport ssup)\n{\n\tVarString  *arg1 = DatumGetVarStringPP(x);\n\tVarString  *arg2 = DatumGetVarStringPP(y);\n\tbool\t\targ1_match;\n\tVarStringSortSupport *sss = (VarStringSortSupport *) ssup->ssup_extra;\n\n\t/* working state */\n\tchar\t   *a1p,\n\t\t\t   *a2p;\n\tint\t\t\tlen1,\n\t\t\t\tlen2,\n\t\t\t\tresult;\n\n\ta1p = VARDATA_ANY(arg1);\n\ta2p = VARDATA_ANY(arg2);\n\n\tlen1 = VARSIZE_ANY_EXHDR(arg1);\n\tlen2 = VARSIZE_ANY_EXHDR(arg2);\n\n\t/* Fast pre-check for equality, as discussed in varstr_cmp() */\n\tif (len1 == len2 && memcmp(a1p, a2p, len1) == 0)\n\t{\n\t\t/*\n\t\t * No change in buf1 or buf2 contents, so avoid changing last_len1 or\n\t\t * last_len2.  Existing contents of buffers might still be used by\n\t\t * next call.\n\t\t *\n\t\t * It's fine to allow the comparison of BpChar padding bytes here,\n\t\t * even though that implies that the memcmp() will usually be\n\t\t * performed for BpChar callers (though multibyte characters could\n\t\t * still prevent that from occurring).  The memcmp() is still very\n\t\t * cheap, and BpChar's funny semantics have us remove trailing spaces\n\t\t * (not limited to padding), so we need make no distinction between\n\t\t * padding space characters and \"real\" space characters.\n\t\t */\n\t\tresult = 0;\n\t\tgoto done;\n\t}\n\n\tif (sss->bpchar)\n\t{\n\t\t/* Get true number of bytes, ignoring trailing spaces */\n\t\tlen1 = bpchartruelen(a1p, len1);\n\t\tlen2 = bpchartruelen(a2p, len2);\n\t}\n\n\tif (len1 >= sss->buflen1)\n\t{\n\t\tpfree(sss->buf1);\n\t\tsss->buflen1 = Max(len1 + 1, Min(sss->buflen1 * 2, MaxAllocSize));\n\t\tsss->buf1 = MemoryContextAlloc(ssup->ssup_cxt, sss->buflen1);\n\t}\n\tif (len2 >= sss->buflen2)\n\t{\n\t\tpfree(sss->buf2);\n\t\tsss->buflen2 = Max(len2 + 1, Min(sss->buflen2 * 2, MaxAllocSize));\n\t\tsss->buf2 = MemoryContextAlloc(ssup->ssup_cxt, sss->buflen2);\n\t}\n\n\t/*\n\t * We're likely to be asked to compare the same strings repeatedly, and\n\t * memcmp() is so much cheaper than strcoll() that it pays to try to cache\n\t * comparisons, even though in general there is no reason to think that\n\t * that will work out (every string datum may be unique).  Caching does\n\t * not slow things down measurably when it doesn't work out, and can speed\n\t * things up by rather a lot when it does.  In part, this is because the\n\t * memcmp() compares data from cachelines that are needed in L1 cache even\n\t * when the last comparison's result cannot be reused.\n\t */\n\targ1_match = true;\n\tif (len1 != sss->last_len1 || memcmp(sss->buf1, a1p, len1) != 0)\n\t{\n\t\targ1_match = false;\n\t\tmemcpy(sss->buf1, a1p, len1);\n\t\tsss->buf1[len1] = '\\0';\n\t\tsss->last_len1 = len1;\n\t}\n\n\t/*\n\t * If we're comparing the same two strings as last time, we can return the\n\t * same answer without calling strcoll() again.  This is more likely than\n\t * it seems (at least with moderate to low cardinality sets), because\n\t * quicksort compares the same pivot against many values.\n\t */\n\tif (len2 != sss->last_len2 || memcmp(sss->buf2, a2p, len2) != 0)\n\t{\n\t\tmemcpy(sss->buf2, a2p, len2);\n\t\tsss->buf2[len2] = '\\0';\n\t\tsss->last_len2 = len2;\n\t}\n\telse if (arg1_match && !sss->cache_blob)\n\t{\n\t\t/* Use result cached following last actual strcoll() call */\n\t\tresult = sss->last_returned;\n\t\tgoto done;\n\t}\n\n\tif (sss->locale)\n\t{\n\t\tif (sss->locale->provider == COLLPROVIDER_ICU)\n\t\t{\n#ifdef USE_ICU\n#ifdef HAVE_UCOL_STRCOLLUTF8\n\t\t\tif (GetDatabaseEncoding() == PG_UTF8)\n\t\t\t{\n\t\t\t\tUErrorCode\tstatus;\n\n\t\t\t\tstatus = U_ZERO_ERROR;\n\t\t\t\tresult = ucol_strcollUTF8(sss->locale->info.icu.ucol,\n\t\t\t\t\t\t\t\t\t\t  a1p, len1,\n\t\t\t\t\t\t\t\t\t\t  a2p, len2,\n\t\t\t\t\t\t\t\t\t\t  &status);\n\t\t\t\tif (U_FAILURE(status))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errmsg(\"collation failed: %s\", u_errorName(status))));\n\t\t\t}\n\t\t\telse\n#endif\n\t\t\t{\n\t\t\t\tint32_t\t\tulen1,\n\t\t\t\t\t\t\tulen2;\n\t\t\t\tUChar\t   *uchar1,\n\t\t\t\t\t\t   *uchar2;\n\n\t\t\t\tulen1 = icu_to_uchar(&uchar1, a1p, len1);\n\t\t\t\tulen2 = icu_to_uchar(&uchar2, a2p, len2);\n\n\t\t\t\tresult = ucol_strcoll(sss->locale->info.icu.ucol,\n\t\t\t\t\t\t\t\t\t  uchar1, ulen1,\n\t\t\t\t\t\t\t\t\t  uchar2, ulen2);\n\n\t\t\t\tpfree(uchar1);\n\t\t\t\tpfree(uchar2);\n\t\t\t}\n#else\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t/* shouldn't happen */\n\t\t\telog(ERROR, \"unsupported collprovider: %c\", sss->locale->provider);\n#endif\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t}\n\t\telse\n\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\tresult = strcoll_l(sss->buf1, sss->buf2, sss->locale->info.lt);\n#else\n\t\t\t/* shouldn't happen */\n\t\t\telog(ERROR, \"unsupported collprovider: %c\", sss->locale->provider);\n#endif\n\t\t}\n\t}\n\telse\n\t\tresult = strcoll(sss->buf1, sss->buf2);\n\n\t/*\n\t * In some locales strcoll() can claim that nonidentical strings are\n\t * equal. Believing that would be bad news for a number of reasons, so we\n\t * follow Perl's lead and sort \"equal\" strings according to strcmp().\n\t */\n\tif (result == 0)\n\t\tresult = strcmp(sss->buf1, sss->buf2);\n\n\t/* Cache result, perhaps saving an expensive strcoll() call next time */\n\tsss->cache_blob = false;\n\tsss->last_returned = result;\ndone:\n\t/* We can't afford to leak memory here. */\n\tif (PointerGetDatum(arg1) != x)\n\t\tpfree(arg1);\n\tif (PointerGetDatum(arg2) != y)\n\t\tpfree(arg2);\n\n\treturn result;\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tvarstrfastcmp_c(Datum x, Datum y, SortSupport ssup);",
      "static int\tbpcharfastcmp_c(Datum x, Datum y, SortSupport ssup);",
      "static int\tvarstrfastcmp_locale(Datum x, Datum y, SortSupport ssup);",
      "static int\tvarstrcmp_abbrev(Datum x, Datum y, SortSupport ssup);",
      "static Datum varstr_abbrev_convert(Datum original, SortSupport ssup);",
      "static bool varstr_abbrev_abort(int memtupcount, SortSupport ssup);",
      "static void text_position_setup(text *t1, text *t2, TextPositionState *state);",
      "static int\ttext_position_next(int start_pos, TextPositionState *state);",
      "static void text_position_cleanup(TextPositionState *state);",
      "static void appendStringInfoText(StringInfo str, const text *t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "arg2"
          ],
          "line": 2230
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "arg2"
          ],
          "line": 2229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "arg1"
          ],
          "line": 2227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "sss->buf1",
            "sss->buf2"
          ],
          "line": 2220
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "246-256",
          "snippet": "int\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcoll",
          "args": [
            "sss->buf1",
            "sss->buf2"
          ],
          "line": 2212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unsupported collprovider: %c\"",
            "sss->locale->provider"
          ],
          "line": 2207
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcoll_l",
          "args": [
            "sss->buf1",
            "sss->buf2",
            "sss->locale->info.lt"
          ],
          "line": 2204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ucol_strcoll",
          "args": [
            "sss->locale->info.icu.ucol",
            "uchar1",
            "ulen1",
            "uchar2",
            "ulen2"
          ],
          "line": 2189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "icu_to_uchar",
          "args": [
            "&uchar2",
            "a2p",
            "len2"
          ],
          "line": 2187
        },
        "resolved": true,
        "details": {
          "function_name": "icu_to_uchar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "1585-1610",
          "snippet": "int32_t\nicu_to_uchar(UChar **buff_uchar, const char *buff, size_t nbytes)\n{\n\tUErrorCode\tstatus;\n\tint32_t\t\tlen_uchar;\n\n\tinit_icu_converter();\n\n\tstatus = U_ZERO_ERROR;\n\tlen_uchar = ucnv_toUChars(icu_converter, NULL, 0,\n\t\t\t\t\t\t\t  buff, nbytes, &status);\n\tif (U_FAILURE(status) && status != U_BUFFER_OVERFLOW_ERROR)\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"ucnv_toUChars failed: %s\", u_errorName(status))));\n\n\t*buff_uchar = palloc((len_uchar + 1) * sizeof(**buff_uchar));\n\n\tstatus = U_ZERO_ERROR;\n\tlen_uchar = ucnv_toUChars(icu_converter, *buff_uchar, len_uchar + 1,\n\t\t\t\t\t\t\t  buff, nbytes, &status);\n\tif (U_FAILURE(status))\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"ucnv_toUChars failed: %s\", u_errorName(status))));\n\n\treturn len_uchar;\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nint32_t\nicu_to_uchar(UChar **buff_uchar, const char *buff, size_t nbytes)\n{\n\tUErrorCode\tstatus;\n\tint32_t\t\tlen_uchar;\n\n\tinit_icu_converter();\n\n\tstatus = U_ZERO_ERROR;\n\tlen_uchar = ucnv_toUChars(icu_converter, NULL, 0,\n\t\t\t\t\t\t\t  buff, nbytes, &status);\n\tif (U_FAILURE(status) && status != U_BUFFER_OVERFLOW_ERROR)\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"ucnv_toUChars failed: %s\", u_errorName(status))));\n\n\t*buff_uchar = palloc((len_uchar + 1) * sizeof(**buff_uchar));\n\n\tstatus = U_ZERO_ERROR;\n\tlen_uchar = ucnv_toUChars(icu_converter, *buff_uchar, len_uchar + 1,\n\t\t\t\t\t\t\t  buff, nbytes, &status);\n\tif (U_FAILURE(status))\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"ucnv_toUChars failed: %s\", u_errorName(status))));\n\n\treturn len_uchar;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errmsg(\"collation failed: %s\", u_errorName(status)))"
          ],
          "line": 2175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"collation failed: %s\"",
            "u_errorName(status)"
          ],
          "line": 2176
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "u_errorName",
          "args": [
            "status"
          ],
          "line": 2176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "U_FAILURE",
          "args": [
            "status"
          ],
          "line": 2174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ucol_strcollUTF8",
          "args": [
            "sss->locale->info.icu.ucol",
            "a1p",
            "len1",
            "a2p",
            "len2",
            "&status"
          ],
          "line": 2170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetDatabaseEncoding",
          "args": [],
          "line": 2165
        },
        "resolved": true,
        "details": {
          "function_name": "GetDatabaseEncodingName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "1009-1013",
          "snippet": "const char *\nGetDatabaseEncodingName(void)\n{\n\treturn DatabaseEncoding->name;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nconst char *\nGetDatabaseEncodingName(void)\n{\n\treturn DatabaseEncoding->name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sss->buf2",
            "a2p",
            "len2"
          ],
          "line": 2148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "sss->buf2",
            "a2p",
            "len2"
          ],
          "line": 2146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sss->buf1",
            "a1p",
            "len1"
          ],
          "line": 2135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "sss->buf1",
            "a1p",
            "len1"
          ],
          "line": 2132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextAlloc",
          "args": [
            "ssup->ssup_cxt",
            "sss->buflen2"
          ],
          "line": 2118
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1079-1106",
          "snippet": "void *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Max",
          "args": [
            "len2 + 1",
            "Min(sss->buflen2 * 2, MaxAllocSize)"
          ],
          "line": 2117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "sss->buflen2 * 2",
            "MaxAllocSize"
          ],
          "line": 2117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Max",
          "args": [
            "len1 + 1",
            "Min(sss->buflen1 * 2, MaxAllocSize)"
          ],
          "line": 2111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "sss->buflen1 * 2",
            "MaxAllocSize"
          ],
          "line": 2111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpchartruelen",
          "args": [
            "a2p",
            "len2"
          ],
          "line": 2105
        },
        "resolved": true,
        "details": {
          "function_name": "bpchartruelen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
          "lines": "659-674",
          "snippet": "int\nbpchartruelen(char *s, int len)\n{\n\tint\t\t\ti;\n\n\t/*\n\t * Note that we rely on the assumption that ' ' is a singleton unit on\n\t * every supported multibyte server encoding.\n\t */\n\tfor (i = len - 1; i >= 0; i--)\n\t{\n\t\tif (s[i] != ' ')\n\t\t\tbreak;\n\t}\n\treturn i + 1;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nint\nbpchartruelen(char *s, int len)\n{\n\tint\t\t\ti;\n\n\t/*\n\t * Note that we rely on the assumption that ' ' is a singleton unit on\n\t * every supported multibyte server encoding.\n\t */\n\tfor (i = len - 1; i >= 0; i--)\n\t{\n\t\tif (s[i] != ' ')\n\t\t\tbreak;\n\t}\n\treturn i + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "a1p",
            "a2p",
            "len1"
          ],
          "line": 2082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "arg2"
          ],
          "line": 2079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "arg1"
          ],
          "line": 2078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "arg2"
          ],
          "line": 2076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "arg1"
          ],
          "line": 2075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetVarStringPP",
          "args": [
            "y"
          ],
          "line": 2064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetVarStringPP",
          "args": [
            "x"
          ],
          "line": 2063
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\tvarstrfastcmp_c(Datum x, Datum y, SortSupport ssup);\nstatic int\tbpcharfastcmp_c(Datum x, Datum y, SortSupport ssup);\nstatic int\tvarstrfastcmp_locale(Datum x, Datum y, SortSupport ssup);\nstatic int\tvarstrcmp_abbrev(Datum x, Datum y, SortSupport ssup);\nstatic Datum varstr_abbrev_convert(Datum original, SortSupport ssup);\nstatic bool varstr_abbrev_abort(int memtupcount, SortSupport ssup);\nstatic void text_position_setup(text *t1, text *t2, TextPositionState *state);\nstatic int\ttext_position_next(int start_pos, TextPositionState *state);\nstatic void text_position_cleanup(TextPositionState *state);\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nstatic int\nvarstrfastcmp_locale(Datum x, Datum y, SortSupport ssup)\n{\n\tVarString  *arg1 = DatumGetVarStringPP(x);\n\tVarString  *arg2 = DatumGetVarStringPP(y);\n\tbool\t\targ1_match;\n\tVarStringSortSupport *sss = (VarStringSortSupport *) ssup->ssup_extra;\n\n\t/* working state */\n\tchar\t   *a1p,\n\t\t\t   *a2p;\n\tint\t\t\tlen1,\n\t\t\t\tlen2,\n\t\t\t\tresult;\n\n\ta1p = VARDATA_ANY(arg1);\n\ta2p = VARDATA_ANY(arg2);\n\n\tlen1 = VARSIZE_ANY_EXHDR(arg1);\n\tlen2 = VARSIZE_ANY_EXHDR(arg2);\n\n\t/* Fast pre-check for equality, as discussed in varstr_cmp() */\n\tif (len1 == len2 && memcmp(a1p, a2p, len1) == 0)\n\t{\n\t\t/*\n\t\t * No change in buf1 or buf2 contents, so avoid changing last_len1 or\n\t\t * last_len2.  Existing contents of buffers might still be used by\n\t\t * next call.\n\t\t *\n\t\t * It's fine to allow the comparison of BpChar padding bytes here,\n\t\t * even though that implies that the memcmp() will usually be\n\t\t * performed for BpChar callers (though multibyte characters could\n\t\t * still prevent that from occurring).  The memcmp() is still very\n\t\t * cheap, and BpChar's funny semantics have us remove trailing spaces\n\t\t * (not limited to padding), so we need make no distinction between\n\t\t * padding space characters and \"real\" space characters.\n\t\t */\n\t\tresult = 0;\n\t\tgoto done;\n\t}\n\n\tif (sss->bpchar)\n\t{\n\t\t/* Get true number of bytes, ignoring trailing spaces */\n\t\tlen1 = bpchartruelen(a1p, len1);\n\t\tlen2 = bpchartruelen(a2p, len2);\n\t}\n\n\tif (len1 >= sss->buflen1)\n\t{\n\t\tpfree(sss->buf1);\n\t\tsss->buflen1 = Max(len1 + 1, Min(sss->buflen1 * 2, MaxAllocSize));\n\t\tsss->buf1 = MemoryContextAlloc(ssup->ssup_cxt, sss->buflen1);\n\t}\n\tif (len2 >= sss->buflen2)\n\t{\n\t\tpfree(sss->buf2);\n\t\tsss->buflen2 = Max(len2 + 1, Min(sss->buflen2 * 2, MaxAllocSize));\n\t\tsss->buf2 = MemoryContextAlloc(ssup->ssup_cxt, sss->buflen2);\n\t}\n\n\t/*\n\t * We're likely to be asked to compare the same strings repeatedly, and\n\t * memcmp() is so much cheaper than strcoll() that it pays to try to cache\n\t * comparisons, even though in general there is no reason to think that\n\t * that will work out (every string datum may be unique).  Caching does\n\t * not slow things down measurably when it doesn't work out, and can speed\n\t * things up by rather a lot when it does.  In part, this is because the\n\t * memcmp() compares data from cachelines that are needed in L1 cache even\n\t * when the last comparison's result cannot be reused.\n\t */\n\targ1_match = true;\n\tif (len1 != sss->last_len1 || memcmp(sss->buf1, a1p, len1) != 0)\n\t{\n\t\targ1_match = false;\n\t\tmemcpy(sss->buf1, a1p, len1);\n\t\tsss->buf1[len1] = '\\0';\n\t\tsss->last_len1 = len1;\n\t}\n\n\t/*\n\t * If we're comparing the same two strings as last time, we can return the\n\t * same answer without calling strcoll() again.  This is more likely than\n\t * it seems (at least with moderate to low cardinality sets), because\n\t * quicksort compares the same pivot against many values.\n\t */\n\tif (len2 != sss->last_len2 || memcmp(sss->buf2, a2p, len2) != 0)\n\t{\n\t\tmemcpy(sss->buf2, a2p, len2);\n\t\tsss->buf2[len2] = '\\0';\n\t\tsss->last_len2 = len2;\n\t}\n\telse if (arg1_match && !sss->cache_blob)\n\t{\n\t\t/* Use result cached following last actual strcoll() call */\n\t\tresult = sss->last_returned;\n\t\tgoto done;\n\t}\n\n\tif (sss->locale)\n\t{\n\t\tif (sss->locale->provider == COLLPROVIDER_ICU)\n\t\t{\n#ifdef USE_ICU\n#ifdef HAVE_UCOL_STRCOLLUTF8\n\t\t\tif (GetDatabaseEncoding() == PG_UTF8)\n\t\t\t{\n\t\t\t\tUErrorCode\tstatus;\n\n\t\t\t\tstatus = U_ZERO_ERROR;\n\t\t\t\tresult = ucol_strcollUTF8(sss->locale->info.icu.ucol,\n\t\t\t\t\t\t\t\t\t\t  a1p, len1,\n\t\t\t\t\t\t\t\t\t\t  a2p, len2,\n\t\t\t\t\t\t\t\t\t\t  &status);\n\t\t\t\tif (U_FAILURE(status))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errmsg(\"collation failed: %s\", u_errorName(status))));\n\t\t\t}\n\t\t\telse\n#endif\n\t\t\t{\n\t\t\t\tint32_t\t\tulen1,\n\t\t\t\t\t\t\tulen2;\n\t\t\t\tUChar\t   *uchar1,\n\t\t\t\t\t\t   *uchar2;\n\n\t\t\t\tulen1 = icu_to_uchar(&uchar1, a1p, len1);\n\t\t\t\tulen2 = icu_to_uchar(&uchar2, a2p, len2);\n\n\t\t\t\tresult = ucol_strcoll(sss->locale->info.icu.ucol,\n\t\t\t\t\t\t\t\t\t  uchar1, ulen1,\n\t\t\t\t\t\t\t\t\t  uchar2, ulen2);\n\n\t\t\t\tpfree(uchar1);\n\t\t\t\tpfree(uchar2);\n\t\t\t}\n#else\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t/* shouldn't happen */\n\t\t\telog(ERROR, \"unsupported collprovider: %c\", sss->locale->provider);\n#endif\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t}\n\t\telse\n\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\tresult = strcoll_l(sss->buf1, sss->buf2, sss->locale->info.lt);\n#else\n\t\t\t/* shouldn't happen */\n\t\t\telog(ERROR, \"unsupported collprovider: %c\", sss->locale->provider);\n#endif\n\t\t}\n\t}\n\telse\n\t\tresult = strcoll(sss->buf1, sss->buf2);\n\n\t/*\n\t * In some locales strcoll() can claim that nonidentical strings are\n\t * equal. Believing that would be bad news for a number of reasons, so we\n\t * follow Perl's lead and sort \"equal\" strings according to strcmp().\n\t */\n\tif (result == 0)\n\t\tresult = strcmp(sss->buf1, sss->buf2);\n\n\t/* Cache result, perhaps saving an expensive strcoll() call next time */\n\tsss->cache_blob = false;\n\tsss->last_returned = result;\ndone:\n\t/* We can't afford to leak memory here. */\n\tif (PointerGetDatum(arg1) != x)\n\t\tpfree(arg1);\n\tif (PointerGetDatum(arg2) != y)\n\t\tpfree(arg2);\n\n\treturn result;\n}"
  },
  {
    "function_name": "bpcharfastcmp_c",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "2027-2055",
    "snippet": "static int\nbpcharfastcmp_c(Datum x, Datum y, SortSupport ssup)\n{\n\tBpChar\t   *arg1 = DatumGetBpCharPP(x);\n\tBpChar\t   *arg2 = DatumGetBpCharPP(y);\n\tchar\t   *a1p,\n\t\t\t   *a2p;\n\tint\t\t\tlen1,\n\t\t\t\tlen2,\n\t\t\t\tresult;\n\n\ta1p = VARDATA_ANY(arg1);\n\ta2p = VARDATA_ANY(arg2);\n\n\tlen1 = bpchartruelen(a1p, VARSIZE_ANY_EXHDR(arg1));\n\tlen2 = bpchartruelen(a2p, VARSIZE_ANY_EXHDR(arg2));\n\n\tresult = memcmp(a1p, a2p, Min(len1, len2));\n\tif ((result == 0) && (len1 != len2))\n\t\tresult = (len1 < len2) ? -1 : 1;\n\n\t/* We can't afford to leak memory here. */\n\tif (PointerGetDatum(arg1) != x)\n\t\tpfree(arg1);\n\tif (PointerGetDatum(arg2) != y)\n\t\tpfree(arg2);\n\n\treturn result;\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tvarstrfastcmp_c(Datum x, Datum y, SortSupport ssup);",
      "static int\tbpcharfastcmp_c(Datum x, Datum y, SortSupport ssup);",
      "static int\tvarstrfastcmp_locale(Datum x, Datum y, SortSupport ssup);",
      "static int\tvarstrcmp_abbrev(Datum x, Datum y, SortSupport ssup);",
      "static Datum varstr_abbrev_convert(Datum original, SortSupport ssup);",
      "static bool varstr_abbrev_abort(int memtupcount, SortSupport ssup);",
      "static void appendStringInfoText(StringInfo str, const text *t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "arg2"
          ],
          "line": 2052
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "arg2"
          ],
          "line": 2051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "arg1"
          ],
          "line": 2049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "a1p",
            "a2p",
            "Min(len1, len2)"
          ],
          "line": 2044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "len1",
            "len2"
          ],
          "line": 2044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpchartruelen",
          "args": [
            "a2p",
            "VARSIZE_ANY_EXHDR(arg2)"
          ],
          "line": 2042
        },
        "resolved": true,
        "details": {
          "function_name": "bpchartruelen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
          "lines": "659-674",
          "snippet": "int\nbpchartruelen(char *s, int len)\n{\n\tint\t\t\ti;\n\n\t/*\n\t * Note that we rely on the assumption that ' ' is a singleton unit on\n\t * every supported multibyte server encoding.\n\t */\n\tfor (i = len - 1; i >= 0; i--)\n\t{\n\t\tif (s[i] != ' ')\n\t\t\tbreak;\n\t}\n\treturn i + 1;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nint\nbpchartruelen(char *s, int len)\n{\n\tint\t\t\ti;\n\n\t/*\n\t * Note that we rely on the assumption that ' ' is a singleton unit on\n\t * every supported multibyte server encoding.\n\t */\n\tfor (i = len - 1; i >= 0; i--)\n\t{\n\t\tif (s[i] != ' ')\n\t\t\tbreak;\n\t}\n\treturn i + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "arg2"
          ],
          "line": 2042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "arg1"
          ],
          "line": 2041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "arg2"
          ],
          "line": 2039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "arg1"
          ],
          "line": 2038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetBpCharPP",
          "args": [
            "y"
          ],
          "line": 2031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetBpCharPP",
          "args": [
            "x"
          ],
          "line": 2030
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\tvarstrfastcmp_c(Datum x, Datum y, SortSupport ssup);\nstatic int\tbpcharfastcmp_c(Datum x, Datum y, SortSupport ssup);\nstatic int\tvarstrfastcmp_locale(Datum x, Datum y, SortSupport ssup);\nstatic int\tvarstrcmp_abbrev(Datum x, Datum y, SortSupport ssup);\nstatic Datum varstr_abbrev_convert(Datum original, SortSupport ssup);\nstatic bool varstr_abbrev_abort(int memtupcount, SortSupport ssup);\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nstatic int\nbpcharfastcmp_c(Datum x, Datum y, SortSupport ssup)\n{\n\tBpChar\t   *arg1 = DatumGetBpCharPP(x);\n\tBpChar\t   *arg2 = DatumGetBpCharPP(y);\n\tchar\t   *a1p,\n\t\t\t   *a2p;\n\tint\t\t\tlen1,\n\t\t\t\tlen2,\n\t\t\t\tresult;\n\n\ta1p = VARDATA_ANY(arg1);\n\ta2p = VARDATA_ANY(arg2);\n\n\tlen1 = bpchartruelen(a1p, VARSIZE_ANY_EXHDR(arg1));\n\tlen2 = bpchartruelen(a2p, VARSIZE_ANY_EXHDR(arg2));\n\n\tresult = memcmp(a1p, a2p, Min(len1, len2));\n\tif ((result == 0) && (len1 != len2))\n\t\tresult = (len1 < len2) ? -1 : 1;\n\n\t/* We can't afford to leak memory here. */\n\tif (PointerGetDatum(arg1) != x)\n\t\tpfree(arg1);\n\tif (PointerGetDatum(arg2) != y)\n\t\tpfree(arg2);\n\n\treturn result;\n}"
  },
  {
    "function_name": "varstrfastcmp_c",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "1990-2018",
    "snippet": "static int\nvarstrfastcmp_c(Datum x, Datum y, SortSupport ssup)\n{\n\tVarString  *arg1 = DatumGetVarStringPP(x);\n\tVarString  *arg2 = DatumGetVarStringPP(y);\n\tchar\t   *a1p,\n\t\t\t   *a2p;\n\tint\t\t\tlen1,\n\t\t\t\tlen2,\n\t\t\t\tresult;\n\n\ta1p = VARDATA_ANY(arg1);\n\ta2p = VARDATA_ANY(arg2);\n\n\tlen1 = VARSIZE_ANY_EXHDR(arg1);\n\tlen2 = VARSIZE_ANY_EXHDR(arg2);\n\n\tresult = memcmp(a1p, a2p, Min(len1, len2));\n\tif ((result == 0) && (len1 != len2))\n\t\tresult = (len1 < len2) ? -1 : 1;\n\n\t/* We can't afford to leak memory here. */\n\tif (PointerGetDatum(arg1) != x)\n\t\tpfree(arg1);\n\tif (PointerGetDatum(arg2) != y)\n\t\tpfree(arg2);\n\n\treturn result;\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tvarstrfastcmp_c(Datum x, Datum y, SortSupport ssup);",
      "static int\tbpcharfastcmp_c(Datum x, Datum y, SortSupport ssup);",
      "static int\tvarstrfastcmp_locale(Datum x, Datum y, SortSupport ssup);",
      "static int\tvarstrcmp_abbrev(Datum x, Datum y, SortSupport ssup);",
      "static Datum varstr_abbrev_convert(Datum original, SortSupport ssup);",
      "static bool varstr_abbrev_abort(int memtupcount, SortSupport ssup);",
      "static void appendStringInfoText(StringInfo str, const text *t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "arg2"
          ],
          "line": 2015
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "arg2"
          ],
          "line": 2014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "arg1"
          ],
          "line": 2012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "a1p",
            "a2p",
            "Min(len1, len2)"
          ],
          "line": 2007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "len1",
            "len2"
          ],
          "line": 2007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "arg2"
          ],
          "line": 2005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "arg1"
          ],
          "line": 2004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "arg2"
          ],
          "line": 2002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "arg1"
          ],
          "line": 2001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetVarStringPP",
          "args": [
            "y"
          ],
          "line": 1994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetVarStringPP",
          "args": [
            "x"
          ],
          "line": 1993
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\tvarstrfastcmp_c(Datum x, Datum y, SortSupport ssup);\nstatic int\tbpcharfastcmp_c(Datum x, Datum y, SortSupport ssup);\nstatic int\tvarstrfastcmp_locale(Datum x, Datum y, SortSupport ssup);\nstatic int\tvarstrcmp_abbrev(Datum x, Datum y, SortSupport ssup);\nstatic Datum varstr_abbrev_convert(Datum original, SortSupport ssup);\nstatic bool varstr_abbrev_abort(int memtupcount, SortSupport ssup);\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nstatic int\nvarstrfastcmp_c(Datum x, Datum y, SortSupport ssup)\n{\n\tVarString  *arg1 = DatumGetVarStringPP(x);\n\tVarString  *arg2 = DatumGetVarStringPP(y);\n\tchar\t   *a1p,\n\t\t\t   *a2p;\n\tint\t\t\tlen1,\n\t\t\t\tlen2,\n\t\t\t\tresult;\n\n\ta1p = VARDATA_ANY(arg1);\n\ta2p = VARDATA_ANY(arg2);\n\n\tlen1 = VARSIZE_ANY_EXHDR(arg1);\n\tlen2 = VARSIZE_ANY_EXHDR(arg2);\n\n\tresult = memcmp(a1p, a2p, Min(len1, len2));\n\tif ((result == 0) && (len1 != len2))\n\t\tresult = (len1 < len2) ? -1 : 1;\n\n\t/* We can't afford to leak memory here. */\n\tif (PointerGetDatum(arg1) != x)\n\t\tpfree(arg1);\n\tif (PointerGetDatum(arg2) != y)\n\t\tpfree(arg2);\n\n\treturn result;\n}"
  },
  {
    "function_name": "varstr_sortsupport",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "1834-1985",
    "snippet": "void\nvarstr_sortsupport(SortSupport ssup, Oid collid, bool bpchar)\n{\n\tbool\t\tabbreviate = ssup->abbreviate;\n\tbool\t\tcollate_c = false;\n\tVarStringSortSupport *sss;\n\tpg_locale_t locale = 0;\n\n\t/*\n\t * If possible, set ssup->comparator to a function which can be used to\n\t * directly compare two datums.  If we can do this, we'll avoid the\n\t * overhead of a trip through the fmgr layer for every comparison, which\n\t * can be substantial.\n\t *\n\t * Most typically, we'll set the comparator to varstrfastcmp_locale, which\n\t * uses strcoll() to perform comparisons and knows about the special\n\t * requirements of BpChar callers.  However, if LC_COLLATE = C, we can\n\t * make things quite a bit faster with varstrfastcmp_c or bpcharfastcmp_c,\n\t * both of which use memcmp() rather than strcoll().\n\t */\n\tif (lc_collate_is_c(collid))\n\t{\n\t\tif (!bpchar)\n\t\t\tssup->comparator = varstrfastcmp_c;\n\t\telse\n\t\t\tssup->comparator = bpcharfastcmp_c;\n\n\t\tcollate_c = true;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * We need a collation-sensitive comparison.  To make things faster,\n\t\t * we'll figure out the collation based on the locale id and cache the\n\t\t * result.\n\t\t */\n\t\tif (collid != DEFAULT_COLLATION_OID)\n\t\t{\n\t\t\tif (!OidIsValid(collid))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This typically means that the parser could not resolve a\n\t\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t\t errmsg(\"could not determine which collation to use for string comparison\"),\n\t\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t\t}\n\t\t\tlocale = pg_newlocale_from_collation(collid);\n\t\t}\n\n\t\t/*\n\t\t * There is a further exception on Windows.  When the database\n\t\t * encoding is UTF-8 and we are not using the C collation, complex\n\t\t * hacks are required.  We don't currently have a comparator that\n\t\t * handles that case, so we fall back on the slow method of having the\n\t\t * sort code invoke bttextcmp() (in the case of text) via the fmgr\n\t\t * trampoline.  ICU locales work just the same on Windows, however.\n\t\t */\n#ifdef WIN32\n\t\tif (GetDatabaseEncoding() == PG_UTF8 &&\n\t\t\t!(locale && locale->provider == COLLPROVIDER_ICU))\n\t\t\treturn;\n#endif\n\n\t\tssup->comparator = varstrfastcmp_locale;\n\t}\n\n\t/*\n\t * Unfortunately, it seems that abbreviation for non-C collations is\n\t * broken on many common platforms; testing of multiple versions of glibc\n\t * reveals that, for many locales, strcoll() and strxfrm() do not return\n\t * consistent results, which is fatal to this optimization.  While no\n\t * other libc other than Cygwin has so far been shown to have a problem,\n\t * we take the conservative course of action for right now and disable\n\t * this categorically.  (Users who are certain this isn't a problem on\n\t * their system can define TRUST_STRXFRM.)\n\t *\n\t * Even apart from the risk of broken locales, it's possible that there\n\t * are platforms where the use of abbreviated keys should be disabled at\n\t * compile time.  Having only 4 byte datums could make worst-case\n\t * performance drastically more likely, for example.  Moreover, macOS's\n\t * strxfrm() implementation is known to not effectively concentrate a\n\t * significant amount of entropy from the original string in earlier\n\t * transformed blobs.  It's possible that other supported platforms are\n\t * similarly encumbered.  So, if we ever get past disabling this\n\t * categorically, we may still want or need to disable it for particular\n\t * platforms.\n\t */\n#ifndef TRUST_STRXFRM\n\tif (!collate_c && !(locale && locale->provider == COLLPROVIDER_ICU))\n\t\tabbreviate = false;\n#endif\n\n\t/*\n\t * If we're using abbreviated keys, or if we're using a locale-aware\n\t * comparison, we need to initialize a StringSortSupport object.  Both\n\t * cases will make use of the temporary buffers we initialize here for\n\t * scratch space (and to detect requirement for BpChar semantics from\n\t * caller), and the abbreviation case requires additional state.\n\t */\n\tif (abbreviate || !collate_c)\n\t{\n\t\tsss = palloc(sizeof(VarStringSortSupport));\n\t\tsss->buf1 = palloc(TEXTBUFLEN);\n\t\tsss->buflen1 = TEXTBUFLEN;\n\t\tsss->buf2 = palloc(TEXTBUFLEN);\n\t\tsss->buflen2 = TEXTBUFLEN;\n\t\t/* Start with invalid values */\n\t\tsss->last_len1 = -1;\n\t\tsss->last_len2 = -1;\n\t\t/* Initialize */\n\t\tsss->last_returned = 0;\n\t\tsss->locale = locale;\n\n\t\t/*\n\t\t * To avoid somehow confusing a strxfrm() blob and an original string,\n\t\t * constantly keep track of the variety of data that buf1 and buf2\n\t\t * currently contain.\n\t\t *\n\t\t * Comparisons may be interleaved with conversion calls.  Frequently,\n\t\t * conversions and comparisons are batched into two distinct phases,\n\t\t * but the correctness of caching cannot hinge upon this.  For\n\t\t * comparison caching, buffer state is only trusted if cache_blob is\n\t\t * found set to false, whereas strxfrm() caching only trusts the state\n\t\t * when cache_blob is found set to true.\n\t\t *\n\t\t * Arbitrarily initialize cache_blob to true.\n\t\t */\n\t\tsss->cache_blob = true;\n\t\tsss->collate_c = collate_c;\n\t\tsss->bpchar = bpchar;\n\t\tssup->ssup_extra = sss;\n\n\t\t/*\n\t\t * If possible, plan to use the abbreviated keys optimization.  The\n\t\t * core code may switch back to authoritative comparator should\n\t\t * abbreviation be aborted.\n\t\t */\n\t\tif (abbreviate)\n\t\t{\n\t\t\tsss->prop_card = 0.20;\n\t\t\tinitHyperLogLog(&sss->abbr_card, 10);\n\t\t\tinitHyperLogLog(&sss->full_card, 10);\n\t\t\tssup->abbrev_full_comparator = ssup->comparator;\n\t\t\tssup->comparator = varstrcmp_abbrev;\n\t\t\tssup->abbrev_converter = varstr_abbrev_convert;\n\t\t\tssup->abbrev_abort = varstr_abbrev_abort;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define TEXTBUFLEN\t\t1024"
    ],
    "globals_used": [
      "static int\tvarstrfastcmp_c(Datum x, Datum y, SortSupport ssup);",
      "static int\tbpcharfastcmp_c(Datum x, Datum y, SortSupport ssup);",
      "static int\tvarstrfastcmp_locale(Datum x, Datum y, SortSupport ssup);",
      "static int\tvarstrcmp_abbrev(Datum x, Datum y, SortSupport ssup);",
      "static Datum varstr_abbrev_convert(Datum original, SortSupport ssup);",
      "static bool varstr_abbrev_abort(int memtupcount, SortSupport ssup);",
      "static void text_position_setup(text *t1, text *t2, TextPositionState *state);",
      "static int\ttext_position_next(int start_pos, TextPositionState *state);",
      "static void text_position_cleanup(TextPositionState *state);",
      "static int\ttext_cmp(text *arg1, text *arg2, Oid collid);",
      "static void appendStringInfoText(StringInfo str, const text *t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "initHyperLogLog",
          "args": [
            "&sss->full_card",
            "10"
          ],
          "line": 1978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initHyperLogLog",
          "args": [
            "&sss->abbr_card",
            "10"
          ],
          "line": 1977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "TEXTBUFLEN"
          ],
          "line": 1941
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetDatabaseEncoding",
          "args": [],
          "line": 1895
        },
        "resolved": true,
        "details": {
          "function_name": "GetDatabaseEncodingName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "1009-1013",
          "snippet": "const char *\nGetDatabaseEncodingName(void)\n{\n\treturn DatabaseEncoding->name;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nconst char *\nGetDatabaseEncodingName(void)\n{\n\treturn DatabaseEncoding->name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_newlocale_from_collation",
          "args": [
            "collid"
          ],
          "line": 1883
        },
        "resolved": true,
        "details": {
          "function_name": "pg_newlocale_from_collation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "1333-1500",
          "snippet": "pg_locale_t\npg_newlocale_from_collation(Oid collid)\n{\n\tcollation_cache_entry *cache_entry;\n\n\t/* Callers must pass a valid OID */\n\tAssert(OidIsValid(collid));\n\n\t/* Return 0 for \"default\" collation, just in case caller forgets */\n\tif (collid == DEFAULT_COLLATION_OID)\n\t\treturn (pg_locale_t) 0;\n\n\tcache_entry = lookup_collation_cache(collid, false);\n\n\tif (cache_entry->locale == 0)\n\t{\n\t\t/* We haven't computed this yet in this session, so do it */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_collation collform;\n\t\tconst char *collcollate;\n\t\tconst char *collctype pg_attribute_unused();\n\t\tstruct pg_locale_struct result;\n\t\tpg_locale_t resultp;\n\t\tDatum\t\tcollversion;\n\t\tbool\t\tisnull;\n\n\t\ttp = SearchSysCache1(COLLOID, ObjectIdGetDatum(collid));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\telog(ERROR, \"cache lookup failed for collation %u\", collid);\n\t\tcollform = (Form_pg_collation) GETSTRUCT(tp);\n\n\t\tcollcollate = NameStr(collform->collcollate);\n\t\tcollctype = NameStr(collform->collctype);\n\n\t\t/* We'll fill in the result struct locally before allocating memory */\n\t\tmemset(&result, 0, sizeof(result));\n\t\tresult.provider = collform->collprovider;\n\n\t\tif (collform->collprovider == COLLPROVIDER_LIBC)\n\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\tlocale_t\tloc;\n\n\t\t\tif (strcmp(collcollate, collctype) == 0)\n\t\t\t{\n\t\t\t\t/* Normal case where they're the same */\n\t\t\t\terrno = 0;\n#ifndef WIN32\n\t\t\t\tloc = newlocale(LC_COLLATE_MASK | LC_CTYPE_MASK, collcollate,\n\t\t\t\t\t\t\t\tNULL);\n#else\n\t\t\t\tloc = _create_locale(LC_ALL, collcollate);\n#endif\n\t\t\t\tif (!loc)\n\t\t\t\t\treport_newlocale_failure(collcollate);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n#ifndef WIN32\n\t\t\t\t/* We need two newlocale() steps */\n\t\t\t\tlocale_t\tloc1;\n\n\t\t\t\terrno = 0;\n\t\t\t\tloc1 = newlocale(LC_COLLATE_MASK, collcollate, NULL);\n\t\t\t\tif (!loc1)\n\t\t\t\t\treport_newlocale_failure(collcollate);\n\t\t\t\terrno = 0;\n\t\t\t\tloc = newlocale(LC_CTYPE_MASK, collctype, loc1);\n\t\t\t\tif (!loc)\n\t\t\t\t\treport_newlocale_failure(collctype);\n#else\n\n\t\t\t\t/*\n\t\t\t\t * XXX The _create_locale() API doesn't appear to support\n\t\t\t\t * this. Could perhaps be worked around by changing\n\t\t\t\t * pg_locale_t to contain two separate fields.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"collations with different collate and ctype values are not supported on this platform\")));\n#endif\n\t\t\t}\n\n\t\t\tresult.info.lt = loc;\n#else\t\t\t\t\t\t\t/* not HAVE_LOCALE_T */\n\t\t\t/* platform that doesn't support locale_t */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"collation provider LIBC is not supported on this platform\")));\n#endif\t\t\t\t\t\t\t/* not HAVE_LOCALE_T */\n\t\t}\n\t\telse if (collform->collprovider == COLLPROVIDER_ICU)\n\t\t{\n#ifdef USE_ICU\n\t\t\tUCollator  *collator;\n\t\t\tUErrorCode\tstatus;\n\n\t\t\tif (strcmp(collcollate, collctype) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"collations with different collate and ctype values are not supported by ICU\")));\n\n\t\t\tstatus = U_ZERO_ERROR;\n\t\t\tcollator = ucol_open(collcollate, &status);\n\t\t\tif (U_FAILURE(status))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errmsg(\"could not open collator for locale \\\"%s\\\": %s\",\n\t\t\t\t\t\t\t\tcollcollate, u_errorName(status))));\n\n\t\t\t/* We will leak this string if we get an error below :-( */\n\t\t\tresult.info.icu.locale = MemoryContextStrdup(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t collcollate);\n\t\t\tresult.info.icu.ucol = collator;\n#else\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t/* could get here if a collation was created by a build with ICU */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"ICU is not supported in this build\"), \\\n\t\t\t\t\t errhint(\"You need to rebuild PostgreSQL using --with-icu.\")));\n#endif\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t}\n\n\t\tcollversion = SysCacheGetAttr(COLLOID, tp, Anum_pg_collation_collversion,\n\t\t\t\t\t\t\t\t\t  &isnull);\n\t\tif (!isnull)\n\t\t{\n\t\t\tchar\t   *actual_versionstr;\n\t\t\tchar\t   *collversionstr;\n\n\t\t\tactual_versionstr = get_collation_actual_version(collform->collprovider, collcollate);\n\t\t\tif (!actual_versionstr)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This could happen when specifying a version in CREATE\n\t\t\t\t * COLLATION for a libc locale, or manually creating a mess in\n\t\t\t\t * the catalogs.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errmsg(\"collation \\\"%s\\\" has no actual version, but a version was specified\",\n\t\t\t\t\t\t\t\tNameStr(collform->collname))));\n\t\t\t}\n\t\t\tcollversionstr = TextDatumGetCString(collversion);\n\n\t\t\tif (strcmp(actual_versionstr, collversionstr) != 0)\n\t\t\t\tereport(WARNING,\n\t\t\t\t\t\t(errmsg(\"collation \\\"%s\\\" has version mismatch\",\n\t\t\t\t\t\t\t\tNameStr(collform->collname)),\n\t\t\t\t\t\t errdetail(\"The collation in the database was created using version %s, \"\n\t\t\t\t\t\t\t\t   \"but the operating system provides version %s.\",\n\t\t\t\t\t\t\t\t   collversionstr, actual_versionstr),\n\t\t\t\t\t\t errhint(\"Rebuild all objects affected by this collation and run \"\n\t\t\t\t\t\t\t\t \"ALTER COLLATION %s REFRESH VERSION, \"\n\t\t\t\t\t\t\t\t \"or build PostgreSQL with the right library version.\",\n\t\t\t\t\t\t\t\t quote_qualified_identifier(get_namespace_name(collform->collnamespace),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tNameStr(collform->collname)))));\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\n\t\t/* We'll keep the pg_locale_t structures in TopMemoryContext */\n\t\tresultp = MemoryContextAlloc(TopMemoryContext, sizeof(*resultp));\n\t\t*resultp = result;\n\n\t\tcache_entry->locale = resultp;\n\t}\n\n\treturn cache_entry->locale;\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\npg_locale_t\npg_newlocale_from_collation(Oid collid)\n{\n\tcollation_cache_entry *cache_entry;\n\n\t/* Callers must pass a valid OID */\n\tAssert(OidIsValid(collid));\n\n\t/* Return 0 for \"default\" collation, just in case caller forgets */\n\tif (collid == DEFAULT_COLLATION_OID)\n\t\treturn (pg_locale_t) 0;\n\n\tcache_entry = lookup_collation_cache(collid, false);\n\n\tif (cache_entry->locale == 0)\n\t{\n\t\t/* We haven't computed this yet in this session, so do it */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_collation collform;\n\t\tconst char *collcollate;\n\t\tconst char *collctype pg_attribute_unused();\n\t\tstruct pg_locale_struct result;\n\t\tpg_locale_t resultp;\n\t\tDatum\t\tcollversion;\n\t\tbool\t\tisnull;\n\n\t\ttp = SearchSysCache1(COLLOID, ObjectIdGetDatum(collid));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\telog(ERROR, \"cache lookup failed for collation %u\", collid);\n\t\tcollform = (Form_pg_collation) GETSTRUCT(tp);\n\n\t\tcollcollate = NameStr(collform->collcollate);\n\t\tcollctype = NameStr(collform->collctype);\n\n\t\t/* We'll fill in the result struct locally before allocating memory */\n\t\tmemset(&result, 0, sizeof(result));\n\t\tresult.provider = collform->collprovider;\n\n\t\tif (collform->collprovider == COLLPROVIDER_LIBC)\n\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\tlocale_t\tloc;\n\n\t\t\tif (strcmp(collcollate, collctype) == 0)\n\t\t\t{\n\t\t\t\t/* Normal case where they're the same */\n\t\t\t\terrno = 0;\n#ifndef WIN32\n\t\t\t\tloc = newlocale(LC_COLLATE_MASK | LC_CTYPE_MASK, collcollate,\n\t\t\t\t\t\t\t\tNULL);\n#else\n\t\t\t\tloc = _create_locale(LC_ALL, collcollate);\n#endif\n\t\t\t\tif (!loc)\n\t\t\t\t\treport_newlocale_failure(collcollate);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n#ifndef WIN32\n\t\t\t\t/* We need two newlocale() steps */\n\t\t\t\tlocale_t\tloc1;\n\n\t\t\t\terrno = 0;\n\t\t\t\tloc1 = newlocale(LC_COLLATE_MASK, collcollate, NULL);\n\t\t\t\tif (!loc1)\n\t\t\t\t\treport_newlocale_failure(collcollate);\n\t\t\t\terrno = 0;\n\t\t\t\tloc = newlocale(LC_CTYPE_MASK, collctype, loc1);\n\t\t\t\tif (!loc)\n\t\t\t\t\treport_newlocale_failure(collctype);\n#else\n\n\t\t\t\t/*\n\t\t\t\t * XXX The _create_locale() API doesn't appear to support\n\t\t\t\t * this. Could perhaps be worked around by changing\n\t\t\t\t * pg_locale_t to contain two separate fields.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"collations with different collate and ctype values are not supported on this platform\")));\n#endif\n\t\t\t}\n\n\t\t\tresult.info.lt = loc;\n#else\t\t\t\t\t\t\t/* not HAVE_LOCALE_T */\n\t\t\t/* platform that doesn't support locale_t */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"collation provider LIBC is not supported on this platform\")));\n#endif\t\t\t\t\t\t\t/* not HAVE_LOCALE_T */\n\t\t}\n\t\telse if (collform->collprovider == COLLPROVIDER_ICU)\n\t\t{\n#ifdef USE_ICU\n\t\t\tUCollator  *collator;\n\t\t\tUErrorCode\tstatus;\n\n\t\t\tif (strcmp(collcollate, collctype) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"collations with different collate and ctype values are not supported by ICU\")));\n\n\t\t\tstatus = U_ZERO_ERROR;\n\t\t\tcollator = ucol_open(collcollate, &status);\n\t\t\tif (U_FAILURE(status))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errmsg(\"could not open collator for locale \\\"%s\\\": %s\",\n\t\t\t\t\t\t\t\tcollcollate, u_errorName(status))));\n\n\t\t\t/* We will leak this string if we get an error below :-( */\n\t\t\tresult.info.icu.locale = MemoryContextStrdup(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t collcollate);\n\t\t\tresult.info.icu.ucol = collator;\n#else\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t/* could get here if a collation was created by a build with ICU */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"ICU is not supported in this build\"), \\\n\t\t\t\t\t errhint(\"You need to rebuild PostgreSQL using --with-icu.\")));\n#endif\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t}\n\n\t\tcollversion = SysCacheGetAttr(COLLOID, tp, Anum_pg_collation_collversion,\n\t\t\t\t\t\t\t\t\t  &isnull);\n\t\tif (!isnull)\n\t\t{\n\t\t\tchar\t   *actual_versionstr;\n\t\t\tchar\t   *collversionstr;\n\n\t\t\tactual_versionstr = get_collation_actual_version(collform->collprovider, collcollate);\n\t\t\tif (!actual_versionstr)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This could happen when specifying a version in CREATE\n\t\t\t\t * COLLATION for a libc locale, or manually creating a mess in\n\t\t\t\t * the catalogs.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errmsg(\"collation \\\"%s\\\" has no actual version, but a version was specified\",\n\t\t\t\t\t\t\t\tNameStr(collform->collname))));\n\t\t\t}\n\t\t\tcollversionstr = TextDatumGetCString(collversion);\n\n\t\t\tif (strcmp(actual_versionstr, collversionstr) != 0)\n\t\t\t\tereport(WARNING,\n\t\t\t\t\t\t(errmsg(\"collation \\\"%s\\\" has version mismatch\",\n\t\t\t\t\t\t\t\tNameStr(collform->collname)),\n\t\t\t\t\t\t errdetail(\"The collation in the database was created using version %s, \"\n\t\t\t\t\t\t\t\t   \"but the operating system provides version %s.\",\n\t\t\t\t\t\t\t\t   collversionstr, actual_versionstr),\n\t\t\t\t\t\t errhint(\"Rebuild all objects affected by this collation and run \"\n\t\t\t\t\t\t\t\t \"ALTER COLLATION %s REFRESH VERSION, \"\n\t\t\t\t\t\t\t\t \"or build PostgreSQL with the right library version.\",\n\t\t\t\t\t\t\t\t quote_qualified_identifier(get_namespace_name(collform->collnamespace),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tNameStr(collform->collname)))));\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\n\t\t/* We'll keep the pg_locale_t structures in TopMemoryContext */\n\t\tresultp = MemoryContextAlloc(TopMemoryContext, sizeof(*resultp));\n\t\t*resultp = result;\n\n\t\tcache_entry->locale = resultp;\n\t}\n\n\treturn cache_entry->locale;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t\t errmsg(\"could not determine which collation to use for string comparison\"),\n\t\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\"))"
          ],
          "line": 1878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errhint",
          "args": [
            "\"Use the COLLATE clause to set the collation explicitly.\""
          ],
          "line": 1881
        },
        "resolved": true,
        "details": {
          "function_name": "errhint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "984-999",
          "snippet": "int\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not determine which collation to use for string comparison\""
          ],
          "line": 1880
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INDETERMINATE_COLLATION"
          ],
          "line": 1879
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "collid"
          ],
          "line": 1872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lc_collate_is_c",
          "args": [
            "collid"
          ],
          "line": 1854
        },
        "resolved": true,
        "details": {
          "function_name": "lc_collate_is_c",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "1186-1231",
          "snippet": "bool\nlc_collate_is_c(Oid collation)\n{\n\t/*\n\t * If we're asked about \"collation 0\", return false, so that the code will\n\t * go into the non-C path and report that the collation is bogus.\n\t */\n\tif (!OidIsValid(collation))\n\t\treturn false;\n\n\t/*\n\t * If we're asked about the default collation, we have to inquire of the C\n\t * library.  Cache the result so we only have to compute it once.\n\t */\n\tif (collation == DEFAULT_COLLATION_OID)\n\t{\n\t\tstatic int\tresult = -1;\n\t\tchar\t   *localeptr;\n\n\t\tif (result >= 0)\n\t\t\treturn (bool) result;\n\t\tlocaleptr = setlocale(LC_COLLATE, NULL);\n\t\tif (!localeptr)\n\t\t\telog(ERROR, \"invalid LC_COLLATE setting\");\n\n\t\tif (strcmp(localeptr, \"C\") == 0)\n\t\t\tresult = true;\n\t\telse if (strcmp(localeptr, \"POSIX\") == 0)\n\t\t\tresult = true;\n\t\telse\n\t\t\tresult = false;\n\t\treturn (bool) result;\n\t}\n\n\t/*\n\t * If we're asked about the built-in C/POSIX collations, we know that.\n\t */\n\tif (collation == C_COLLATION_OID ||\n\t\tcollation == POSIX_COLLATION_OID)\n\t\treturn true;\n\n\t/*\n\t * Otherwise, we have to consult pg_collation, but we cache that.\n\t */\n\treturn (lookup_collation_cache(collation, true))->collate_is_c;\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nbool\nlc_collate_is_c(Oid collation)\n{\n\t/*\n\t * If we're asked about \"collation 0\", return false, so that the code will\n\t * go into the non-C path and report that the collation is bogus.\n\t */\n\tif (!OidIsValid(collation))\n\t\treturn false;\n\n\t/*\n\t * If we're asked about the default collation, we have to inquire of the C\n\t * library.  Cache the result so we only have to compute it once.\n\t */\n\tif (collation == DEFAULT_COLLATION_OID)\n\t{\n\t\tstatic int\tresult = -1;\n\t\tchar\t   *localeptr;\n\n\t\tif (result >= 0)\n\t\t\treturn (bool) result;\n\t\tlocaleptr = setlocale(LC_COLLATE, NULL);\n\t\tif (!localeptr)\n\t\t\telog(ERROR, \"invalid LC_COLLATE setting\");\n\n\t\tif (strcmp(localeptr, \"C\") == 0)\n\t\t\tresult = true;\n\t\telse if (strcmp(localeptr, \"POSIX\") == 0)\n\t\t\tresult = true;\n\t\telse\n\t\t\tresult = false;\n\t\treturn (bool) result;\n\t}\n\n\t/*\n\t * If we're asked about the built-in C/POSIX collations, we know that.\n\t */\n\tif (collation == C_COLLATION_OID ||\n\t\tcollation == POSIX_COLLATION_OID)\n\t\treturn true;\n\n\t/*\n\t * Otherwise, we have to consult pg_collation, but we cache that.\n\t */\n\treturn (lookup_collation_cache(collation, true))->collate_is_c;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define TEXTBUFLEN\t\t1024\n\nstatic int\tvarstrfastcmp_c(Datum x, Datum y, SortSupport ssup);\nstatic int\tbpcharfastcmp_c(Datum x, Datum y, SortSupport ssup);\nstatic int\tvarstrfastcmp_locale(Datum x, Datum y, SortSupport ssup);\nstatic int\tvarstrcmp_abbrev(Datum x, Datum y, SortSupport ssup);\nstatic Datum varstr_abbrev_convert(Datum original, SortSupport ssup);\nstatic bool varstr_abbrev_abort(int memtupcount, SortSupport ssup);\nstatic void text_position_setup(text *t1, text *t2, TextPositionState *state);\nstatic int\ttext_position_next(int start_pos, TextPositionState *state);\nstatic void text_position_cleanup(TextPositionState *state);\nstatic int\ttext_cmp(text *arg1, text *arg2, Oid collid);\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nvoid\nvarstr_sortsupport(SortSupport ssup, Oid collid, bool bpchar)\n{\n\tbool\t\tabbreviate = ssup->abbreviate;\n\tbool\t\tcollate_c = false;\n\tVarStringSortSupport *sss;\n\tpg_locale_t locale = 0;\n\n\t/*\n\t * If possible, set ssup->comparator to a function which can be used to\n\t * directly compare two datums.  If we can do this, we'll avoid the\n\t * overhead of a trip through the fmgr layer for every comparison, which\n\t * can be substantial.\n\t *\n\t * Most typically, we'll set the comparator to varstrfastcmp_locale, which\n\t * uses strcoll() to perform comparisons and knows about the special\n\t * requirements of BpChar callers.  However, if LC_COLLATE = C, we can\n\t * make things quite a bit faster with varstrfastcmp_c or bpcharfastcmp_c,\n\t * both of which use memcmp() rather than strcoll().\n\t */\n\tif (lc_collate_is_c(collid))\n\t{\n\t\tif (!bpchar)\n\t\t\tssup->comparator = varstrfastcmp_c;\n\t\telse\n\t\t\tssup->comparator = bpcharfastcmp_c;\n\n\t\tcollate_c = true;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * We need a collation-sensitive comparison.  To make things faster,\n\t\t * we'll figure out the collation based on the locale id and cache the\n\t\t * result.\n\t\t */\n\t\tif (collid != DEFAULT_COLLATION_OID)\n\t\t{\n\t\t\tif (!OidIsValid(collid))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This typically means that the parser could not resolve a\n\t\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t\t errmsg(\"could not determine which collation to use for string comparison\"),\n\t\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t\t}\n\t\t\tlocale = pg_newlocale_from_collation(collid);\n\t\t}\n\n\t\t/*\n\t\t * There is a further exception on Windows.  When the database\n\t\t * encoding is UTF-8 and we are not using the C collation, complex\n\t\t * hacks are required.  We don't currently have a comparator that\n\t\t * handles that case, so we fall back on the slow method of having the\n\t\t * sort code invoke bttextcmp() (in the case of text) via the fmgr\n\t\t * trampoline.  ICU locales work just the same on Windows, however.\n\t\t */\n#ifdef WIN32\n\t\tif (GetDatabaseEncoding() == PG_UTF8 &&\n\t\t\t!(locale && locale->provider == COLLPROVIDER_ICU))\n\t\t\treturn;\n#endif\n\n\t\tssup->comparator = varstrfastcmp_locale;\n\t}\n\n\t/*\n\t * Unfortunately, it seems that abbreviation for non-C collations is\n\t * broken on many common platforms; testing of multiple versions of glibc\n\t * reveals that, for many locales, strcoll() and strxfrm() do not return\n\t * consistent results, which is fatal to this optimization.  While no\n\t * other libc other than Cygwin has so far been shown to have a problem,\n\t * we take the conservative course of action for right now and disable\n\t * this categorically.  (Users who are certain this isn't a problem on\n\t * their system can define TRUST_STRXFRM.)\n\t *\n\t * Even apart from the risk of broken locales, it's possible that there\n\t * are platforms where the use of abbreviated keys should be disabled at\n\t * compile time.  Having only 4 byte datums could make worst-case\n\t * performance drastically more likely, for example.  Moreover, macOS's\n\t * strxfrm() implementation is known to not effectively concentrate a\n\t * significant amount of entropy from the original string in earlier\n\t * transformed blobs.  It's possible that other supported platforms are\n\t * similarly encumbered.  So, if we ever get past disabling this\n\t * categorically, we may still want or need to disable it for particular\n\t * platforms.\n\t */\n#ifndef TRUST_STRXFRM\n\tif (!collate_c && !(locale && locale->provider == COLLPROVIDER_ICU))\n\t\tabbreviate = false;\n#endif\n\n\t/*\n\t * If we're using abbreviated keys, or if we're using a locale-aware\n\t * comparison, we need to initialize a StringSortSupport object.  Both\n\t * cases will make use of the temporary buffers we initialize here for\n\t * scratch space (and to detect requirement for BpChar semantics from\n\t * caller), and the abbreviation case requires additional state.\n\t */\n\tif (abbreviate || !collate_c)\n\t{\n\t\tsss = palloc(sizeof(VarStringSortSupport));\n\t\tsss->buf1 = palloc(TEXTBUFLEN);\n\t\tsss->buflen1 = TEXTBUFLEN;\n\t\tsss->buf2 = palloc(TEXTBUFLEN);\n\t\tsss->buflen2 = TEXTBUFLEN;\n\t\t/* Start with invalid values */\n\t\tsss->last_len1 = -1;\n\t\tsss->last_len2 = -1;\n\t\t/* Initialize */\n\t\tsss->last_returned = 0;\n\t\tsss->locale = locale;\n\n\t\t/*\n\t\t * To avoid somehow confusing a strxfrm() blob and an original string,\n\t\t * constantly keep track of the variety of data that buf1 and buf2\n\t\t * currently contain.\n\t\t *\n\t\t * Comparisons may be interleaved with conversion calls.  Frequently,\n\t\t * conversions and comparisons are batched into two distinct phases,\n\t\t * but the correctness of caching cannot hinge upon this.  For\n\t\t * comparison caching, buffer state is only trusted if cache_blob is\n\t\t * found set to false, whereas strxfrm() caching only trusts the state\n\t\t * when cache_blob is found set to true.\n\t\t *\n\t\t * Arbitrarily initialize cache_blob to true.\n\t\t */\n\t\tsss->cache_blob = true;\n\t\tsss->collate_c = collate_c;\n\t\tsss->bpchar = bpchar;\n\t\tssup->ssup_extra = sss;\n\n\t\t/*\n\t\t * If possible, plan to use the abbreviated keys optimization.  The\n\t\t * core code may switch back to authoritative comparator should\n\t\t * abbreviation be aborted.\n\t\t */\n\t\tif (abbreviate)\n\t\t{\n\t\t\tsss->prop_card = 0.20;\n\t\t\tinitHyperLogLog(&sss->abbr_card, 10);\n\t\t\tinitHyperLogLog(&sss->full_card, 10);\n\t\t\tssup->abbrev_full_comparator = ssup->comparator;\n\t\t\tssup->comparator = varstrcmp_abbrev;\n\t\t\tssup->abbrev_converter = varstr_abbrev_convert;\n\t\t\tssup->abbrev_abort = varstr_abbrev_abort;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "bttextsortsupport",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "1807-1822",
    "snippet": "Datum\nbttextsortsupport(PG_FUNCTION_ARGS)\n{\n\tSortSupport ssup = (SortSupport) PG_GETARG_POINTER(0);\n\tOid\t\t\tcollid = ssup->ssup_collation;\n\tMemoryContext oldcontext;\n\n\toldcontext = MemoryContextSwitchTo(ssup->ssup_cxt);\n\n\t/* Use generic string SortSupport */\n\tvarstr_sortsupport(ssup, collid, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\tPG_RETURN_VOID();\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tvarstrfastcmp_c(Datum x, Datum y, SortSupport ssup);",
      "static int\tbpcharfastcmp_c(Datum x, Datum y, SortSupport ssup);",
      "static int\tvarstrfastcmp_locale(Datum x, Datum y, SortSupport ssup);",
      "static int\tvarstrcmp_abbrev(Datum x, Datum y, SortSupport ssup);",
      "static Datum varstr_abbrev_convert(Datum original, SortSupport ssup);",
      "static bool varstr_abbrev_abort(int memtupcount, SortSupport ssup);",
      "static int\ttext_cmp(text *arg1, text *arg2, Oid collid);",
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VOID",
          "args": [],
          "line": 1821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 1819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "varstr_sortsupport",
          "args": [
            "ssup",
            "collid",
            "false"
          ],
          "line": 1817
        },
        "resolved": true,
        "details": {
          "function_name": "varstr_sortsupport",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "1834-1985",
          "snippet": "void\nvarstr_sortsupport(SortSupport ssup, Oid collid, bool bpchar)\n{\n\tbool\t\tabbreviate = ssup->abbreviate;\n\tbool\t\tcollate_c = false;\n\tVarStringSortSupport *sss;\n\tpg_locale_t locale = 0;\n\n\t/*\n\t * If possible, set ssup->comparator to a function which can be used to\n\t * directly compare two datums.  If we can do this, we'll avoid the\n\t * overhead of a trip through the fmgr layer for every comparison, which\n\t * can be substantial.\n\t *\n\t * Most typically, we'll set the comparator to varstrfastcmp_locale, which\n\t * uses strcoll() to perform comparisons and knows about the special\n\t * requirements of BpChar callers.  However, if LC_COLLATE = C, we can\n\t * make things quite a bit faster with varstrfastcmp_c or bpcharfastcmp_c,\n\t * both of which use memcmp() rather than strcoll().\n\t */\n\tif (lc_collate_is_c(collid))\n\t{\n\t\tif (!bpchar)\n\t\t\tssup->comparator = varstrfastcmp_c;\n\t\telse\n\t\t\tssup->comparator = bpcharfastcmp_c;\n\n\t\tcollate_c = true;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * We need a collation-sensitive comparison.  To make things faster,\n\t\t * we'll figure out the collation based on the locale id and cache the\n\t\t * result.\n\t\t */\n\t\tif (collid != DEFAULT_COLLATION_OID)\n\t\t{\n\t\t\tif (!OidIsValid(collid))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This typically means that the parser could not resolve a\n\t\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t\t errmsg(\"could not determine which collation to use for string comparison\"),\n\t\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t\t}\n\t\t\tlocale = pg_newlocale_from_collation(collid);\n\t\t}\n\n\t\t/*\n\t\t * There is a further exception on Windows.  When the database\n\t\t * encoding is UTF-8 and we are not using the C collation, complex\n\t\t * hacks are required.  We don't currently have a comparator that\n\t\t * handles that case, so we fall back on the slow method of having the\n\t\t * sort code invoke bttextcmp() (in the case of text) via the fmgr\n\t\t * trampoline.  ICU locales work just the same on Windows, however.\n\t\t */\n#ifdef WIN32\n\t\tif (GetDatabaseEncoding() == PG_UTF8 &&\n\t\t\t!(locale && locale->provider == COLLPROVIDER_ICU))\n\t\t\treturn;\n#endif\n\n\t\tssup->comparator = varstrfastcmp_locale;\n\t}\n\n\t/*\n\t * Unfortunately, it seems that abbreviation for non-C collations is\n\t * broken on many common platforms; testing of multiple versions of glibc\n\t * reveals that, for many locales, strcoll() and strxfrm() do not return\n\t * consistent results, which is fatal to this optimization.  While no\n\t * other libc other than Cygwin has so far been shown to have a problem,\n\t * we take the conservative course of action for right now and disable\n\t * this categorically.  (Users who are certain this isn't a problem on\n\t * their system can define TRUST_STRXFRM.)\n\t *\n\t * Even apart from the risk of broken locales, it's possible that there\n\t * are platforms where the use of abbreviated keys should be disabled at\n\t * compile time.  Having only 4 byte datums could make worst-case\n\t * performance drastically more likely, for example.  Moreover, macOS's\n\t * strxfrm() implementation is known to not effectively concentrate a\n\t * significant amount of entropy from the original string in earlier\n\t * transformed blobs.  It's possible that other supported platforms are\n\t * similarly encumbered.  So, if we ever get past disabling this\n\t * categorically, we may still want or need to disable it for particular\n\t * platforms.\n\t */\n#ifndef TRUST_STRXFRM\n\tif (!collate_c && !(locale && locale->provider == COLLPROVIDER_ICU))\n\t\tabbreviate = false;\n#endif\n\n\t/*\n\t * If we're using abbreviated keys, or if we're using a locale-aware\n\t * comparison, we need to initialize a StringSortSupport object.  Both\n\t * cases will make use of the temporary buffers we initialize here for\n\t * scratch space (and to detect requirement for BpChar semantics from\n\t * caller), and the abbreviation case requires additional state.\n\t */\n\tif (abbreviate || !collate_c)\n\t{\n\t\tsss = palloc(sizeof(VarStringSortSupport));\n\t\tsss->buf1 = palloc(TEXTBUFLEN);\n\t\tsss->buflen1 = TEXTBUFLEN;\n\t\tsss->buf2 = palloc(TEXTBUFLEN);\n\t\tsss->buflen2 = TEXTBUFLEN;\n\t\t/* Start with invalid values */\n\t\tsss->last_len1 = -1;\n\t\tsss->last_len2 = -1;\n\t\t/* Initialize */\n\t\tsss->last_returned = 0;\n\t\tsss->locale = locale;\n\n\t\t/*\n\t\t * To avoid somehow confusing a strxfrm() blob and an original string,\n\t\t * constantly keep track of the variety of data that buf1 and buf2\n\t\t * currently contain.\n\t\t *\n\t\t * Comparisons may be interleaved with conversion calls.  Frequently,\n\t\t * conversions and comparisons are batched into two distinct phases,\n\t\t * but the correctness of caching cannot hinge upon this.  For\n\t\t * comparison caching, buffer state is only trusted if cache_blob is\n\t\t * found set to false, whereas strxfrm() caching only trusts the state\n\t\t * when cache_blob is found set to true.\n\t\t *\n\t\t * Arbitrarily initialize cache_blob to true.\n\t\t */\n\t\tsss->cache_blob = true;\n\t\tsss->collate_c = collate_c;\n\t\tsss->bpchar = bpchar;\n\t\tssup->ssup_extra = sss;\n\n\t\t/*\n\t\t * If possible, plan to use the abbreviated keys optimization.  The\n\t\t * core code may switch back to authoritative comparator should\n\t\t * abbreviation be aborted.\n\t\t */\n\t\tif (abbreviate)\n\t\t{\n\t\t\tsss->prop_card = 0.20;\n\t\t\tinitHyperLogLog(&sss->abbr_card, 10);\n\t\t\tinitHyperLogLog(&sss->full_card, 10);\n\t\t\tssup->abbrev_full_comparator = ssup->comparator;\n\t\t\tssup->comparator = varstrcmp_abbrev;\n\t\t\tssup->abbrev_converter = varstr_abbrev_convert;\n\t\t\tssup->abbrev_abort = varstr_abbrev_abort;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TEXTBUFLEN\t\t1024"
          ],
          "globals_used": [
            "static int\tvarstrfastcmp_c(Datum x, Datum y, SortSupport ssup);",
            "static int\tbpcharfastcmp_c(Datum x, Datum y, SortSupport ssup);",
            "static int\tvarstrfastcmp_locale(Datum x, Datum y, SortSupport ssup);",
            "static int\tvarstrcmp_abbrev(Datum x, Datum y, SortSupport ssup);",
            "static Datum varstr_abbrev_convert(Datum original, SortSupport ssup);",
            "static bool varstr_abbrev_abort(int memtupcount, SortSupport ssup);",
            "static void text_position_setup(text *t1, text *t2, TextPositionState *state);",
            "static int\ttext_position_next(int start_pos, TextPositionState *state);",
            "static void text_position_cleanup(TextPositionState *state);",
            "static int\ttext_cmp(text *arg1, text *arg2, Oid collid);",
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define TEXTBUFLEN\t\t1024\n\nstatic int\tvarstrfastcmp_c(Datum x, Datum y, SortSupport ssup);\nstatic int\tbpcharfastcmp_c(Datum x, Datum y, SortSupport ssup);\nstatic int\tvarstrfastcmp_locale(Datum x, Datum y, SortSupport ssup);\nstatic int\tvarstrcmp_abbrev(Datum x, Datum y, SortSupport ssup);\nstatic Datum varstr_abbrev_convert(Datum original, SortSupport ssup);\nstatic bool varstr_abbrev_abort(int memtupcount, SortSupport ssup);\nstatic void text_position_setup(text *t1, text *t2, TextPositionState *state);\nstatic int\ttext_position_next(int start_pos, TextPositionState *state);\nstatic void text_position_cleanup(TextPositionState *state);\nstatic int\ttext_cmp(text *arg1, text *arg2, Oid collid);\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nvoid\nvarstr_sortsupport(SortSupport ssup, Oid collid, bool bpchar)\n{\n\tbool\t\tabbreviate = ssup->abbreviate;\n\tbool\t\tcollate_c = false;\n\tVarStringSortSupport *sss;\n\tpg_locale_t locale = 0;\n\n\t/*\n\t * If possible, set ssup->comparator to a function which can be used to\n\t * directly compare two datums.  If we can do this, we'll avoid the\n\t * overhead of a trip through the fmgr layer for every comparison, which\n\t * can be substantial.\n\t *\n\t * Most typically, we'll set the comparator to varstrfastcmp_locale, which\n\t * uses strcoll() to perform comparisons and knows about the special\n\t * requirements of BpChar callers.  However, if LC_COLLATE = C, we can\n\t * make things quite a bit faster with varstrfastcmp_c or bpcharfastcmp_c,\n\t * both of which use memcmp() rather than strcoll().\n\t */\n\tif (lc_collate_is_c(collid))\n\t{\n\t\tif (!bpchar)\n\t\t\tssup->comparator = varstrfastcmp_c;\n\t\telse\n\t\t\tssup->comparator = bpcharfastcmp_c;\n\n\t\tcollate_c = true;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * We need a collation-sensitive comparison.  To make things faster,\n\t\t * we'll figure out the collation based on the locale id and cache the\n\t\t * result.\n\t\t */\n\t\tif (collid != DEFAULT_COLLATION_OID)\n\t\t{\n\t\t\tif (!OidIsValid(collid))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This typically means that the parser could not resolve a\n\t\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t\t errmsg(\"could not determine which collation to use for string comparison\"),\n\t\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t\t}\n\t\t\tlocale = pg_newlocale_from_collation(collid);\n\t\t}\n\n\t\t/*\n\t\t * There is a further exception on Windows.  When the database\n\t\t * encoding is UTF-8 and we are not using the C collation, complex\n\t\t * hacks are required.  We don't currently have a comparator that\n\t\t * handles that case, so we fall back on the slow method of having the\n\t\t * sort code invoke bttextcmp() (in the case of text) via the fmgr\n\t\t * trampoline.  ICU locales work just the same on Windows, however.\n\t\t */\n#ifdef WIN32\n\t\tif (GetDatabaseEncoding() == PG_UTF8 &&\n\t\t\t!(locale && locale->provider == COLLPROVIDER_ICU))\n\t\t\treturn;\n#endif\n\n\t\tssup->comparator = varstrfastcmp_locale;\n\t}\n\n\t/*\n\t * Unfortunately, it seems that abbreviation for non-C collations is\n\t * broken on many common platforms; testing of multiple versions of glibc\n\t * reveals that, for many locales, strcoll() and strxfrm() do not return\n\t * consistent results, which is fatal to this optimization.  While no\n\t * other libc other than Cygwin has so far been shown to have a problem,\n\t * we take the conservative course of action for right now and disable\n\t * this categorically.  (Users who are certain this isn't a problem on\n\t * their system can define TRUST_STRXFRM.)\n\t *\n\t * Even apart from the risk of broken locales, it's possible that there\n\t * are platforms where the use of abbreviated keys should be disabled at\n\t * compile time.  Having only 4 byte datums could make worst-case\n\t * performance drastically more likely, for example.  Moreover, macOS's\n\t * strxfrm() implementation is known to not effectively concentrate a\n\t * significant amount of entropy from the original string in earlier\n\t * transformed blobs.  It's possible that other supported platforms are\n\t * similarly encumbered.  So, if we ever get past disabling this\n\t * categorically, we may still want or need to disable it for particular\n\t * platforms.\n\t */\n#ifndef TRUST_STRXFRM\n\tif (!collate_c && !(locale && locale->provider == COLLPROVIDER_ICU))\n\t\tabbreviate = false;\n#endif\n\n\t/*\n\t * If we're using abbreviated keys, or if we're using a locale-aware\n\t * comparison, we need to initialize a StringSortSupport object.  Both\n\t * cases will make use of the temporary buffers we initialize here for\n\t * scratch space (and to detect requirement for BpChar semantics from\n\t * caller), and the abbreviation case requires additional state.\n\t */\n\tif (abbreviate || !collate_c)\n\t{\n\t\tsss = palloc(sizeof(VarStringSortSupport));\n\t\tsss->buf1 = palloc(TEXTBUFLEN);\n\t\tsss->buflen1 = TEXTBUFLEN;\n\t\tsss->buf2 = palloc(TEXTBUFLEN);\n\t\tsss->buflen2 = TEXTBUFLEN;\n\t\t/* Start with invalid values */\n\t\tsss->last_len1 = -1;\n\t\tsss->last_len2 = -1;\n\t\t/* Initialize */\n\t\tsss->last_returned = 0;\n\t\tsss->locale = locale;\n\n\t\t/*\n\t\t * To avoid somehow confusing a strxfrm() blob and an original string,\n\t\t * constantly keep track of the variety of data that buf1 and buf2\n\t\t * currently contain.\n\t\t *\n\t\t * Comparisons may be interleaved with conversion calls.  Frequently,\n\t\t * conversions and comparisons are batched into two distinct phases,\n\t\t * but the correctness of caching cannot hinge upon this.  For\n\t\t * comparison caching, buffer state is only trusted if cache_blob is\n\t\t * found set to false, whereas strxfrm() caching only trusts the state\n\t\t * when cache_blob is found set to true.\n\t\t *\n\t\t * Arbitrarily initialize cache_blob to true.\n\t\t */\n\t\tsss->cache_blob = true;\n\t\tsss->collate_c = collate_c;\n\t\tsss->bpchar = bpchar;\n\t\tssup->ssup_extra = sss;\n\n\t\t/*\n\t\t * If possible, plan to use the abbreviated keys optimization.  The\n\t\t * core code may switch back to authoritative comparator should\n\t\t * abbreviation be aborted.\n\t\t */\n\t\tif (abbreviate)\n\t\t{\n\t\t\tsss->prop_card = 0.20;\n\t\t\tinitHyperLogLog(&sss->abbr_card, 10);\n\t\t\tinitHyperLogLog(&sss->full_card, 10);\n\t\t\tssup->abbrev_full_comparator = ssup->comparator;\n\t\t\tssup->comparator = varstrcmp_abbrev;\n\t\t\tssup->abbrev_converter = varstr_abbrev_convert;\n\t\t\tssup->abbrev_abort = varstr_abbrev_abort;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "ssup->ssup_cxt"
          ],
          "line": 1814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 1810
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\tvarstrfastcmp_c(Datum x, Datum y, SortSupport ssup);\nstatic int\tbpcharfastcmp_c(Datum x, Datum y, SortSupport ssup);\nstatic int\tvarstrfastcmp_locale(Datum x, Datum y, SortSupport ssup);\nstatic int\tvarstrcmp_abbrev(Datum x, Datum y, SortSupport ssup);\nstatic Datum varstr_abbrev_convert(Datum original, SortSupport ssup);\nstatic bool varstr_abbrev_abort(int memtupcount, SortSupport ssup);\nstatic int\ttext_cmp(text *arg1, text *arg2, Oid collid);\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\n\nDatum\nbttextsortsupport(PG_FUNCTION_ARGS)\n{\n\tSortSupport ssup = (SortSupport) PG_GETARG_POINTER(0);\n\tOid\t\t\tcollid = ssup->ssup_collation;\n\tMemoryContext oldcontext;\n\n\toldcontext = MemoryContextSwitchTo(ssup->ssup_cxt);\n\n\t/* Use generic string SortSupport */\n\tvarstr_sortsupport(ssup, collid, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\tPG_RETURN_VOID();\n}"
  },
  {
    "function_name": "bttextcmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "1792-1805",
    "snippet": "Datum\nbttextcmp(PG_FUNCTION_ARGS)\n{\n\ttext\t   *arg1 = PG_GETARG_TEXT_PP(0);\n\ttext\t   *arg2 = PG_GETARG_TEXT_PP(1);\n\tint32\t\tresult;\n\n\tresult = text_cmp(arg1, arg2, PG_GET_COLLATION());\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_INT32(result);\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "result"
          ],
          "line": 1804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg2",
            "1"
          ],
          "line": 1802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg1",
            "0"
          ],
          "line": 1801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text_cmp",
          "args": [
            "arg1",
            "arg2",
            "PG_GET_COLLATION()"
          ],
          "line": 1799
        },
        "resolved": true,
        "details": {
          "function_name": "text_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "1615-1630",
          "snippet": "static int\ntext_cmp(text *arg1, text *arg2, Oid collid)\n{\n\tchar\t   *a1p,\n\t\t\t   *a2p;\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\n\ta1p = VARDATA_ANY(arg1);\n\ta2p = VARDATA_ANY(arg2);\n\n\tlen1 = VARSIZE_ANY_EXHDR(arg1);\n\tlen2 = VARSIZE_ANY_EXHDR(arg2);\n\n\treturn varstr_cmp(a1p, len1, a2p, len2, collid);\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ttext_cmp(text *arg1, text *arg2, Oid collid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttext_cmp(text *arg1, text *arg2, Oid collid);\n\nstatic int\ntext_cmp(text *arg1, text *arg2, Oid collid)\n{\n\tchar\t   *a1p,\n\t\t\t   *a2p;\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\n\ta1p = VARDATA_ANY(arg1);\n\ta2p = VARDATA_ANY(arg2);\n\n\tlen1 = VARSIZE_ANY_EXHDR(arg1);\n\tlen2 = VARSIZE_ANY_EXHDR(arg2);\n\n\treturn varstr_cmp(a1p, len1, a2p, len2, collid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GET_COLLATION",
          "args": [],
          "line": 1799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 1796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 1795
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\n\nDatum\nbttextcmp(PG_FUNCTION_ARGS)\n{\n\ttext\t   *arg1 = PG_GETARG_TEXT_PP(0);\n\ttext\t   *arg2 = PG_GETARG_TEXT_PP(1);\n\tint32\t\tresult;\n\n\tresult = text_cmp(arg1, arg2, PG_GET_COLLATION());\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_INT32(result);\n}"
  },
  {
    "function_name": "text_starts_with",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "1764-1790",
    "snippet": "Datum\ntext_starts_with(PG_FUNCTION_ARGS)\n{\n\tDatum\t\targ1 = PG_GETARG_DATUM(0);\n\tDatum\t\targ2 = PG_GETARG_DATUM(1);\n\tbool\t\tresult;\n\tSize\t\tlen1,\n\t\t\t\tlen2;\n\n\tlen1 = toast_raw_datum_size(arg1);\n\tlen2 = toast_raw_datum_size(arg2);\n\tif (len2 > len1)\n\t\tresult = false;\n\telse\n\t{\n\t\ttext\t   *targ1 = DatumGetTextPP(arg1);\n\t\ttext\t   *targ2 = DatumGetTextPP(arg2);\n\n\t\tresult = (memcmp(VARDATA_ANY(targ1), VARDATA_ANY(targ2),\n\t\t\t\t\t\t VARSIZE_ANY_EXHDR(targ2)) == 0);\n\n\t\tPG_FREE_IF_COPY(targ1, 0);\n\t\tPG_FREE_IF_COPY(targ2, 1);\n\t}\n\n\tPG_RETURN_BOOL(result);\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "result"
          ],
          "line": 1789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "targ2",
            "1"
          ],
          "line": 1786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "targ1",
            "0"
          ],
          "line": 1785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "VARDATA_ANY(targ1)",
            "VARDATA_ANY(targ2)",
            "VARSIZE_ANY_EXHDR(targ2)"
          ],
          "line": 1782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "targ2"
          ],
          "line": 1783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "targ2"
          ],
          "line": 1782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "targ1"
          ],
          "line": 1782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetTextPP",
          "args": [
            "arg2"
          ],
          "line": 1780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetTextPP",
          "args": [
            "arg1"
          ],
          "line": 1779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toast_raw_datum_size",
          "args": [
            "arg2"
          ],
          "line": 1774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toast_raw_datum_size",
          "args": [
            "arg1"
          ],
          "line": 1773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "1"
          ],
          "line": 1768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "0"
          ],
          "line": 1767
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\n\nDatum\ntext_starts_with(PG_FUNCTION_ARGS)\n{\n\tDatum\t\targ1 = PG_GETARG_DATUM(0);\n\tDatum\t\targ2 = PG_GETARG_DATUM(1);\n\tbool\t\tresult;\n\tSize\t\tlen1,\n\t\t\t\tlen2;\n\n\tlen1 = toast_raw_datum_size(arg1);\n\tlen2 = toast_raw_datum_size(arg2);\n\tif (len2 > len1)\n\t\tresult = false;\n\telse\n\t{\n\t\ttext\t   *targ1 = DatumGetTextPP(arg1);\n\t\ttext\t   *targ2 = DatumGetTextPP(arg2);\n\n\t\tresult = (memcmp(VARDATA_ANY(targ1), VARDATA_ANY(targ2),\n\t\t\t\t\t\t VARSIZE_ANY_EXHDR(targ2)) == 0);\n\n\t\tPG_FREE_IF_COPY(targ1, 0);\n\t\tPG_FREE_IF_COPY(targ2, 1);\n\t}\n\n\tPG_RETURN_BOOL(result);\n}"
  },
  {
    "function_name": "text_ge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "1749-1762",
    "snippet": "Datum\ntext_ge(PG_FUNCTION_ARGS)\n{\n\ttext\t   *arg1 = PG_GETARG_TEXT_PP(0);\n\ttext\t   *arg2 = PG_GETARG_TEXT_PP(1);\n\tbool\t\tresult;\n\n\tresult = (text_cmp(arg1, arg2, PG_GET_COLLATION()) >= 0);\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_BOOL(result);\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "result"
          ],
          "line": 1761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg2",
            "1"
          ],
          "line": 1759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg1",
            "0"
          ],
          "line": 1758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text_cmp",
          "args": [
            "arg1",
            "arg2",
            "PG_GET_COLLATION()"
          ],
          "line": 1756
        },
        "resolved": true,
        "details": {
          "function_name": "text_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "1615-1630",
          "snippet": "static int\ntext_cmp(text *arg1, text *arg2, Oid collid)\n{\n\tchar\t   *a1p,\n\t\t\t   *a2p;\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\n\ta1p = VARDATA_ANY(arg1);\n\ta2p = VARDATA_ANY(arg2);\n\n\tlen1 = VARSIZE_ANY_EXHDR(arg1);\n\tlen2 = VARSIZE_ANY_EXHDR(arg2);\n\n\treturn varstr_cmp(a1p, len1, a2p, len2, collid);\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ttext_cmp(text *arg1, text *arg2, Oid collid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttext_cmp(text *arg1, text *arg2, Oid collid);\n\nstatic int\ntext_cmp(text *arg1, text *arg2, Oid collid)\n{\n\tchar\t   *a1p,\n\t\t\t   *a2p;\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\n\ta1p = VARDATA_ANY(arg1);\n\ta2p = VARDATA_ANY(arg2);\n\n\tlen1 = VARSIZE_ANY_EXHDR(arg1);\n\tlen2 = VARSIZE_ANY_EXHDR(arg2);\n\n\treturn varstr_cmp(a1p, len1, a2p, len2, collid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GET_COLLATION",
          "args": [],
          "line": 1756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 1753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 1752
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\n\nDatum\ntext_ge(PG_FUNCTION_ARGS)\n{\n\ttext\t   *arg1 = PG_GETARG_TEXT_PP(0);\n\ttext\t   *arg2 = PG_GETARG_TEXT_PP(1);\n\tbool\t\tresult;\n\n\tresult = (text_cmp(arg1, arg2, PG_GET_COLLATION()) >= 0);\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_BOOL(result);\n}"
  },
  {
    "function_name": "text_gt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "1734-1747",
    "snippet": "Datum\ntext_gt(PG_FUNCTION_ARGS)\n{\n\ttext\t   *arg1 = PG_GETARG_TEXT_PP(0);\n\ttext\t   *arg2 = PG_GETARG_TEXT_PP(1);\n\tbool\t\tresult;\n\n\tresult = (text_cmp(arg1, arg2, PG_GET_COLLATION()) > 0);\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_BOOL(result);\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "result"
          ],
          "line": 1746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg2",
            "1"
          ],
          "line": 1744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg1",
            "0"
          ],
          "line": 1743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text_cmp",
          "args": [
            "arg1",
            "arg2",
            "PG_GET_COLLATION()"
          ],
          "line": 1741
        },
        "resolved": true,
        "details": {
          "function_name": "text_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "1615-1630",
          "snippet": "static int\ntext_cmp(text *arg1, text *arg2, Oid collid)\n{\n\tchar\t   *a1p,\n\t\t\t   *a2p;\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\n\ta1p = VARDATA_ANY(arg1);\n\ta2p = VARDATA_ANY(arg2);\n\n\tlen1 = VARSIZE_ANY_EXHDR(arg1);\n\tlen2 = VARSIZE_ANY_EXHDR(arg2);\n\n\treturn varstr_cmp(a1p, len1, a2p, len2, collid);\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ttext_cmp(text *arg1, text *arg2, Oid collid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttext_cmp(text *arg1, text *arg2, Oid collid);\n\nstatic int\ntext_cmp(text *arg1, text *arg2, Oid collid)\n{\n\tchar\t   *a1p,\n\t\t\t   *a2p;\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\n\ta1p = VARDATA_ANY(arg1);\n\ta2p = VARDATA_ANY(arg2);\n\n\tlen1 = VARSIZE_ANY_EXHDR(arg1);\n\tlen2 = VARSIZE_ANY_EXHDR(arg2);\n\n\treturn varstr_cmp(a1p, len1, a2p, len2, collid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GET_COLLATION",
          "args": [],
          "line": 1741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 1738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 1737
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\n\nDatum\ntext_gt(PG_FUNCTION_ARGS)\n{\n\ttext\t   *arg1 = PG_GETARG_TEXT_PP(0);\n\ttext\t   *arg2 = PG_GETARG_TEXT_PP(1);\n\tbool\t\tresult;\n\n\tresult = (text_cmp(arg1, arg2, PG_GET_COLLATION()) > 0);\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_BOOL(result);\n}"
  },
  {
    "function_name": "text_le",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "1719-1732",
    "snippet": "Datum\ntext_le(PG_FUNCTION_ARGS)\n{\n\ttext\t   *arg1 = PG_GETARG_TEXT_PP(0);\n\ttext\t   *arg2 = PG_GETARG_TEXT_PP(1);\n\tbool\t\tresult;\n\n\tresult = (text_cmp(arg1, arg2, PG_GET_COLLATION()) <= 0);\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_BOOL(result);\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "result"
          ],
          "line": 1731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg2",
            "1"
          ],
          "line": 1729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg1",
            "0"
          ],
          "line": 1728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text_cmp",
          "args": [
            "arg1",
            "arg2",
            "PG_GET_COLLATION()"
          ],
          "line": 1726
        },
        "resolved": true,
        "details": {
          "function_name": "text_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "1615-1630",
          "snippet": "static int\ntext_cmp(text *arg1, text *arg2, Oid collid)\n{\n\tchar\t   *a1p,\n\t\t\t   *a2p;\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\n\ta1p = VARDATA_ANY(arg1);\n\ta2p = VARDATA_ANY(arg2);\n\n\tlen1 = VARSIZE_ANY_EXHDR(arg1);\n\tlen2 = VARSIZE_ANY_EXHDR(arg2);\n\n\treturn varstr_cmp(a1p, len1, a2p, len2, collid);\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ttext_cmp(text *arg1, text *arg2, Oid collid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttext_cmp(text *arg1, text *arg2, Oid collid);\n\nstatic int\ntext_cmp(text *arg1, text *arg2, Oid collid)\n{\n\tchar\t   *a1p,\n\t\t\t   *a2p;\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\n\ta1p = VARDATA_ANY(arg1);\n\ta2p = VARDATA_ANY(arg2);\n\n\tlen1 = VARSIZE_ANY_EXHDR(arg1);\n\tlen2 = VARSIZE_ANY_EXHDR(arg2);\n\n\treturn varstr_cmp(a1p, len1, a2p, len2, collid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GET_COLLATION",
          "args": [],
          "line": 1726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 1722
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\n\nDatum\ntext_le(PG_FUNCTION_ARGS)\n{\n\ttext\t   *arg1 = PG_GETARG_TEXT_PP(0);\n\ttext\t   *arg2 = PG_GETARG_TEXT_PP(1);\n\tbool\t\tresult;\n\n\tresult = (text_cmp(arg1, arg2, PG_GET_COLLATION()) <= 0);\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_BOOL(result);\n}"
  },
  {
    "function_name": "text_lt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "1704-1717",
    "snippet": "Datum\ntext_lt(PG_FUNCTION_ARGS)\n{\n\ttext\t   *arg1 = PG_GETARG_TEXT_PP(0);\n\ttext\t   *arg2 = PG_GETARG_TEXT_PP(1);\n\tbool\t\tresult;\n\n\tresult = (text_cmp(arg1, arg2, PG_GET_COLLATION()) < 0);\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_BOOL(result);\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "result"
          ],
          "line": 1716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg2",
            "1"
          ],
          "line": 1714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg1",
            "0"
          ],
          "line": 1713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text_cmp",
          "args": [
            "arg1",
            "arg2",
            "PG_GET_COLLATION()"
          ],
          "line": 1711
        },
        "resolved": true,
        "details": {
          "function_name": "text_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "1615-1630",
          "snippet": "static int\ntext_cmp(text *arg1, text *arg2, Oid collid)\n{\n\tchar\t   *a1p,\n\t\t\t   *a2p;\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\n\ta1p = VARDATA_ANY(arg1);\n\ta2p = VARDATA_ANY(arg2);\n\n\tlen1 = VARSIZE_ANY_EXHDR(arg1);\n\tlen2 = VARSIZE_ANY_EXHDR(arg2);\n\n\treturn varstr_cmp(a1p, len1, a2p, len2, collid);\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ttext_cmp(text *arg1, text *arg2, Oid collid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttext_cmp(text *arg1, text *arg2, Oid collid);\n\nstatic int\ntext_cmp(text *arg1, text *arg2, Oid collid)\n{\n\tchar\t   *a1p,\n\t\t\t   *a2p;\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\n\ta1p = VARDATA_ANY(arg1);\n\ta2p = VARDATA_ANY(arg2);\n\n\tlen1 = VARSIZE_ANY_EXHDR(arg1);\n\tlen2 = VARSIZE_ANY_EXHDR(arg2);\n\n\treturn varstr_cmp(a1p, len1, a2p, len2, collid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GET_COLLATION",
          "args": [],
          "line": 1711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 1708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 1707
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\n\nDatum\ntext_lt(PG_FUNCTION_ARGS)\n{\n\ttext\t   *arg1 = PG_GETARG_TEXT_PP(0);\n\ttext\t   *arg2 = PG_GETARG_TEXT_PP(1);\n\tbool\t\tresult;\n\n\tresult = (text_cmp(arg1, arg2, PG_GET_COLLATION()) < 0);\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_BOOL(result);\n}"
  },
  {
    "function_name": "textne",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "1675-1702",
    "snippet": "Datum\ntextne(PG_FUNCTION_ARGS)\n{\n\tDatum\t\targ1 = PG_GETARG_DATUM(0);\n\tDatum\t\targ2 = PG_GETARG_DATUM(1);\n\tbool\t\tresult;\n\tSize\t\tlen1,\n\t\t\t\tlen2;\n\n\t/* See comment in texteq() */\n\tlen1 = toast_raw_datum_size(arg1);\n\tlen2 = toast_raw_datum_size(arg2);\n\tif (len1 != len2)\n\t\tresult = true;\n\telse\n\t{\n\t\ttext\t   *targ1 = DatumGetTextPP(arg1);\n\t\ttext\t   *targ2 = DatumGetTextPP(arg2);\n\n\t\tresult = (memcmp(VARDATA_ANY(targ1), VARDATA_ANY(targ2),\n\t\t\t\t\t\t len1 - VARHDRSZ) != 0);\n\n\t\tPG_FREE_IF_COPY(targ1, 0);\n\t\tPG_FREE_IF_COPY(targ2, 1);\n\t}\n\n\tPG_RETURN_BOOL(result);\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "result"
          ],
          "line": 1701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "targ2",
            "1"
          ],
          "line": 1698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "targ1",
            "0"
          ],
          "line": 1697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "VARDATA_ANY(targ1)",
            "VARDATA_ANY(targ2)",
            "len1 - VARHDRSZ"
          ],
          "line": 1694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "targ2"
          ],
          "line": 1694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "targ1"
          ],
          "line": 1694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetTextPP",
          "args": [
            "arg2"
          ],
          "line": 1692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetTextPP",
          "args": [
            "arg1"
          ],
          "line": 1691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toast_raw_datum_size",
          "args": [
            "arg2"
          ],
          "line": 1686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toast_raw_datum_size",
          "args": [
            "arg1"
          ],
          "line": 1685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "1"
          ],
          "line": 1679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "0"
          ],
          "line": 1678
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\n\nDatum\ntextne(PG_FUNCTION_ARGS)\n{\n\tDatum\t\targ1 = PG_GETARG_DATUM(0);\n\tDatum\t\targ2 = PG_GETARG_DATUM(1);\n\tbool\t\tresult;\n\tSize\t\tlen1,\n\t\t\t\tlen2;\n\n\t/* See comment in texteq() */\n\tlen1 = toast_raw_datum_size(arg1);\n\tlen2 = toast_raw_datum_size(arg2);\n\tif (len1 != len2)\n\t\tresult = true;\n\telse\n\t{\n\t\ttext\t   *targ1 = DatumGetTextPP(arg1);\n\t\ttext\t   *targ2 = DatumGetTextPP(arg2);\n\n\t\tresult = (memcmp(VARDATA_ANY(targ1), VARDATA_ANY(targ2),\n\t\t\t\t\t\t len1 - VARHDRSZ) != 0);\n\n\t\tPG_FREE_IF_COPY(targ1, 0);\n\t\tPG_FREE_IF_COPY(targ2, 1);\n\t}\n\n\tPG_RETURN_BOOL(result);\n}"
  },
  {
    "function_name": "texteq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "1640-1673",
    "snippet": "Datum\ntexteq(PG_FUNCTION_ARGS)\n{\n\tDatum\t\targ1 = PG_GETARG_DATUM(0);\n\tDatum\t\targ2 = PG_GETARG_DATUM(1);\n\tbool\t\tresult;\n\tSize\t\tlen1,\n\t\t\t\tlen2;\n\n\t/*\n\t * Since we only care about equality or not-equality, we can avoid all the\n\t * expense of strcoll() here, and just do bitwise comparison.  In fact, we\n\t * don't even have to do a bitwise comparison if we can show the lengths\n\t * of the strings are unequal; which might save us from having to detoast\n\t * one or both values.\n\t */\n\tlen1 = toast_raw_datum_size(arg1);\n\tlen2 = toast_raw_datum_size(arg2);\n\tif (len1 != len2)\n\t\tresult = false;\n\telse\n\t{\n\t\ttext\t   *targ1 = DatumGetTextPP(arg1);\n\t\ttext\t   *targ2 = DatumGetTextPP(arg2);\n\n\t\tresult = (memcmp(VARDATA_ANY(targ1), VARDATA_ANY(targ2),\n\t\t\t\t\t\t len1 - VARHDRSZ) == 0);\n\n\t\tPG_FREE_IF_COPY(targ1, 0);\n\t\tPG_FREE_IF_COPY(targ2, 1);\n\t}\n\n\tPG_RETURN_BOOL(result);\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void appendStringInfoText(StringInfo str, const text *t);",
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "result"
          ],
          "line": 1672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "targ2",
            "1"
          ],
          "line": 1669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "targ1",
            "0"
          ],
          "line": 1668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "VARDATA_ANY(targ1)",
            "VARDATA_ANY(targ2)",
            "len1 - VARHDRSZ"
          ],
          "line": 1665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "targ2"
          ],
          "line": 1665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "targ1"
          ],
          "line": 1665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetTextPP",
          "args": [
            "arg2"
          ],
          "line": 1663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetTextPP",
          "args": [
            "arg1"
          ],
          "line": 1662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toast_raw_datum_size",
          "args": [
            "arg2"
          ],
          "line": 1657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toast_raw_datum_size",
          "args": [
            "arg1"
          ],
          "line": 1656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "1"
          ],
          "line": 1644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "0"
          ],
          "line": 1643
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\n\nDatum\ntexteq(PG_FUNCTION_ARGS)\n{\n\tDatum\t\targ1 = PG_GETARG_DATUM(0);\n\tDatum\t\targ2 = PG_GETARG_DATUM(1);\n\tbool\t\tresult;\n\tSize\t\tlen1,\n\t\t\t\tlen2;\n\n\t/*\n\t * Since we only care about equality or not-equality, we can avoid all the\n\t * expense of strcoll() here, and just do bitwise comparison.  In fact, we\n\t * don't even have to do a bitwise comparison if we can show the lengths\n\t * of the strings are unequal; which might save us from having to detoast\n\t * one or both values.\n\t */\n\tlen1 = toast_raw_datum_size(arg1);\n\tlen2 = toast_raw_datum_size(arg2);\n\tif (len1 != len2)\n\t\tresult = false;\n\telse\n\t{\n\t\ttext\t   *targ1 = DatumGetTextPP(arg1);\n\t\ttext\t   *targ2 = DatumGetTextPP(arg2);\n\n\t\tresult = (memcmp(VARDATA_ANY(targ1), VARDATA_ANY(targ2),\n\t\t\t\t\t\t len1 - VARHDRSZ) == 0);\n\n\t\tPG_FREE_IF_COPY(targ1, 0);\n\t\tPG_FREE_IF_COPY(targ2, 1);\n\t}\n\n\tPG_RETURN_BOOL(result);\n}"
  },
  {
    "function_name": "text_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "1615-1630",
    "snippet": "static int\ntext_cmp(text *arg1, text *arg2, Oid collid)\n{\n\tchar\t   *a1p,\n\t\t\t   *a2p;\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\n\ta1p = VARDATA_ANY(arg1);\n\ta2p = VARDATA_ANY(arg2);\n\n\tlen1 = VARSIZE_ANY_EXHDR(arg1);\n\tlen2 = VARSIZE_ANY_EXHDR(arg2);\n\n\treturn varstr_cmp(a1p, len1, a2p, len2, collid);\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\ttext_cmp(text *arg1, text *arg2, Oid collid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "varstr_cmp",
          "args": [
            "a1p",
            "len1",
            "a2p",
            "len2",
            "collid"
          ],
          "line": 1629
        },
        "resolved": true,
        "details": {
          "function_name": "varstr_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "1380-1609",
          "snippet": "int\nvarstr_cmp(const char *arg1, int len1, const char *arg2, int len2, Oid collid)\n{\n\tint\t\t\tresult;\n\n\t/*\n\t * Unfortunately, there is no strncoll(), so in the non-C locale case we\n\t * have to do some memory copying.  This turns out to be significantly\n\t * slower, so we optimize the case where LC_COLLATE is C.  We also try to\n\t * optimize relatively-short strings by avoiding palloc/pfree overhead.\n\t */\n\tif (lc_collate_is_c(collid))\n\t{\n\t\tresult = memcmp(arg1, arg2, Min(len1, len2));\n\t\tif ((result == 0) && (len1 != len2))\n\t\t\tresult = (len1 < len2) ? -1 : 1;\n\t}\n\telse\n\t{\n\t\tchar\t\ta1buf[TEXTBUFLEN];\n\t\tchar\t\ta2buf[TEXTBUFLEN];\n\t\tchar\t   *a1p,\n\t\t\t\t   *a2p;\n\t\tpg_locale_t mylocale = 0;\n\n\t\tif (collid != DEFAULT_COLLATION_OID)\n\t\t{\n\t\t\tif (!OidIsValid(collid))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This typically means that the parser could not resolve a\n\t\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t\t errmsg(\"could not determine which collation to use for string comparison\"),\n\t\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t\t}\n\t\t\tmylocale = pg_newlocale_from_collation(collid);\n\t\t}\n\n\t\t/*\n\t\t * memcmp() can't tell us which of two unequal strings sorts first,\n\t\t * but it's a cheap way to tell if they're equal.  Testing shows that\n\t\t * memcmp() followed by strcoll() is only trivially slower than\n\t\t * strcoll() by itself, so we don't lose much if this doesn't work out\n\t\t * very often, and if it does - for example, because there are many\n\t\t * equal strings in the input - then we win big by avoiding expensive\n\t\t * collation-aware comparisons.\n\t\t */\n\t\tif (len1 == len2 && memcmp(arg1, arg2, len1) == 0)\n\t\t\treturn 0;\n\n#ifdef WIN32\n\t\t/* Win32 does not have UTF-8, so we need to map to UTF-16 */\n\t\tif (GetDatabaseEncoding() == PG_UTF8\n\t\t\t&& (!mylocale || mylocale->provider == COLLPROVIDER_LIBC))\n\t\t{\n\t\t\tint\t\t\ta1len;\n\t\t\tint\t\t\ta2len;\n\t\t\tint\t\t\tr;\n\n\t\t\tif (len1 >= TEXTBUFLEN / 2)\n\t\t\t{\n\t\t\t\ta1len = len1 * 2 + 2;\n\t\t\t\ta1p = palloc(a1len);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta1len = TEXTBUFLEN;\n\t\t\t\ta1p = a1buf;\n\t\t\t}\n\t\t\tif (len2 >= TEXTBUFLEN / 2)\n\t\t\t{\n\t\t\t\ta2len = len2 * 2 + 2;\n\t\t\t\ta2p = palloc(a2len);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta2len = TEXTBUFLEN;\n\t\t\t\ta2p = a2buf;\n\t\t\t}\n\n\t\t\t/* stupid Microsloth API does not work for zero-length input */\n\t\t\tif (len1 == 0)\n\t\t\t\tr = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = MultiByteToWideChar(CP_UTF8, 0, arg1, len1,\n\t\t\t\t\t\t\t\t\t\t(LPWSTR) a1p, a1len / 2);\n\t\t\t\tif (!r)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errmsg(\"could not convert string to UTF-16: error code %lu\",\n\t\t\t\t\t\t\t\t\tGetLastError())));\n\t\t\t}\n\t\t\t((LPWSTR) a1p)[r] = 0;\n\n\t\t\tif (len2 == 0)\n\t\t\t\tr = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = MultiByteToWideChar(CP_UTF8, 0, arg2, len2,\n\t\t\t\t\t\t\t\t\t\t(LPWSTR) a2p, a2len / 2);\n\t\t\t\tif (!r)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errmsg(\"could not convert string to UTF-16: error code %lu\",\n\t\t\t\t\t\t\t\t\tGetLastError())));\n\t\t\t}\n\t\t\t((LPWSTR) a2p)[r] = 0;\n\n\t\t\terrno = 0;\n#ifdef HAVE_LOCALE_T\n\t\t\tif (mylocale)\n\t\t\t\tresult = wcscoll_l((LPWSTR) a1p, (LPWSTR) a2p, mylocale->info.lt);\n\t\t\telse\n#endif\n\t\t\t\tresult = wcscoll((LPWSTR) a1p, (LPWSTR) a2p);\n\t\t\tif (result == 2147483647)\t/* _NLSCMPERROR; missing from mingw\n\t\t\t\t\t\t\t\t\t\t * headers */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errmsg(\"could not compare Unicode strings: %m\")));\n\n\t\t\t/*\n\t\t\t * In some locales wcscoll() can claim that nonidentical strings\n\t\t\t * are equal.  Believing that would be bad news for a number of\n\t\t\t * reasons, so we follow Perl's lead and sort \"equal\" strings\n\t\t\t * according to strcmp (on the UTF-8 representation).\n\t\t\t */\n\t\t\tif (result == 0)\n\t\t\t{\n\t\t\t\tresult = memcmp(arg1, arg2, Min(len1, len2));\n\t\t\t\tif ((result == 0) && (len1 != len2))\n\t\t\t\t\tresult = (len1 < len2) ? -1 : 1;\n\t\t\t}\n\n\t\t\tif (a1p != a1buf)\n\t\t\t\tpfree(a1p);\n\t\t\tif (a2p != a2buf)\n\t\t\t\tpfree(a2p);\n\n\t\t\treturn result;\n\t\t}\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\n\t\tif (len1 >= TEXTBUFLEN)\n\t\t\ta1p = (char *) palloc(len1 + 1);\n\t\telse\n\t\t\ta1p = a1buf;\n\t\tif (len2 >= TEXTBUFLEN)\n\t\t\ta2p = (char *) palloc(len2 + 1);\n\t\telse\n\t\t\ta2p = a2buf;\n\n\t\tmemcpy(a1p, arg1, len1);\n\t\ta1p[len1] = '\\0';\n\t\tmemcpy(a2p, arg2, len2);\n\t\ta2p[len2] = '\\0';\n\n\t\tif (mylocale)\n\t\t{\n\t\t\tif (mylocale->provider == COLLPROVIDER_ICU)\n\t\t\t{\n#ifdef USE_ICU\n#ifdef HAVE_UCOL_STRCOLLUTF8\n\t\t\t\tif (GetDatabaseEncoding() == PG_UTF8)\n\t\t\t\t{\n\t\t\t\t\tUErrorCode\tstatus;\n\n\t\t\t\t\tstatus = U_ZERO_ERROR;\n\t\t\t\t\tresult = ucol_strcollUTF8(mylocale->info.icu.ucol,\n\t\t\t\t\t\t\t\t\t\t\t  arg1, len1,\n\t\t\t\t\t\t\t\t\t\t\t  arg2, len2,\n\t\t\t\t\t\t\t\t\t\t\t  &status);\n\t\t\t\t\tif (U_FAILURE(status))\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errmsg(\"collation failed: %s\", u_errorName(status))));\n\t\t\t\t}\n\t\t\t\telse\n#endif\n\t\t\t\t{\n\t\t\t\t\tint32_t\t\tulen1,\n\t\t\t\t\t\t\t\tulen2;\n\t\t\t\t\tUChar\t   *uchar1,\n\t\t\t\t\t\t\t   *uchar2;\n\n\t\t\t\t\tulen1 = icu_to_uchar(&uchar1, arg1, len1);\n\t\t\t\t\tulen2 = icu_to_uchar(&uchar2, arg2, len2);\n\n\t\t\t\t\tresult = ucol_strcoll(mylocale->info.icu.ucol,\n\t\t\t\t\t\t\t\t\t\t  uchar1, ulen1,\n\t\t\t\t\t\t\t\t\t\t  uchar2, ulen2);\n\n\t\t\t\t\tpfree(uchar1);\n\t\t\t\t\tpfree(uchar2);\n\t\t\t\t}\n#else\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t\t/* shouldn't happen */\n\t\t\t\telog(ERROR, \"unsupported collprovider: %c\", mylocale->provider);\n#endif\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t}\n\t\t\telse\n\t\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\t\tresult = strcoll_l(a1p, a2p, mylocale->info.lt);\n#else\n\t\t\t\t/* shouldn't happen */\n\t\t\t\telog(ERROR, \"unsupported collprovider: %c\", mylocale->provider);\n#endif\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tresult = strcoll(a1p, a2p);\n\n\t\t/*\n\t\t * In some locales strcoll() can claim that nonidentical strings are\n\t\t * equal.  Believing that would be bad news for a number of reasons,\n\t\t * so we follow Perl's lead and sort \"equal\" strings according to\n\t\t * strcmp().\n\t\t */\n\t\tif (result == 0)\n\t\t\tresult = strcmp(a1p, a2p);\n\n\t\tif (a1p != a1buf)\n\t\t\tpfree(a1p);\n\t\tif (a2p != a2buf)\n\t\t\tpfree(a2p);\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TEXTBUFLEN\t\t1024"
          ],
          "globals_used": [
            "static int\ttext_cmp(text *arg1, text *arg2, Oid collid);",
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define TEXTBUFLEN\t\t1024\n\nstatic int\ttext_cmp(text *arg1, text *arg2, Oid collid);\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nint\nvarstr_cmp(const char *arg1, int len1, const char *arg2, int len2, Oid collid)\n{\n\tint\t\t\tresult;\n\n\t/*\n\t * Unfortunately, there is no strncoll(), so in the non-C locale case we\n\t * have to do some memory copying.  This turns out to be significantly\n\t * slower, so we optimize the case where LC_COLLATE is C.  We also try to\n\t * optimize relatively-short strings by avoiding palloc/pfree overhead.\n\t */\n\tif (lc_collate_is_c(collid))\n\t{\n\t\tresult = memcmp(arg1, arg2, Min(len1, len2));\n\t\tif ((result == 0) && (len1 != len2))\n\t\t\tresult = (len1 < len2) ? -1 : 1;\n\t}\n\telse\n\t{\n\t\tchar\t\ta1buf[TEXTBUFLEN];\n\t\tchar\t\ta2buf[TEXTBUFLEN];\n\t\tchar\t   *a1p,\n\t\t\t\t   *a2p;\n\t\tpg_locale_t mylocale = 0;\n\n\t\tif (collid != DEFAULT_COLLATION_OID)\n\t\t{\n\t\t\tif (!OidIsValid(collid))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This typically means that the parser could not resolve a\n\t\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t\t errmsg(\"could not determine which collation to use for string comparison\"),\n\t\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t\t}\n\t\t\tmylocale = pg_newlocale_from_collation(collid);\n\t\t}\n\n\t\t/*\n\t\t * memcmp() can't tell us which of two unequal strings sorts first,\n\t\t * but it's a cheap way to tell if they're equal.  Testing shows that\n\t\t * memcmp() followed by strcoll() is only trivially slower than\n\t\t * strcoll() by itself, so we don't lose much if this doesn't work out\n\t\t * very often, and if it does - for example, because there are many\n\t\t * equal strings in the input - then we win big by avoiding expensive\n\t\t * collation-aware comparisons.\n\t\t */\n\t\tif (len1 == len2 && memcmp(arg1, arg2, len1) == 0)\n\t\t\treturn 0;\n\n#ifdef WIN32\n\t\t/* Win32 does not have UTF-8, so we need to map to UTF-16 */\n\t\tif (GetDatabaseEncoding() == PG_UTF8\n\t\t\t&& (!mylocale || mylocale->provider == COLLPROVIDER_LIBC))\n\t\t{\n\t\t\tint\t\t\ta1len;\n\t\t\tint\t\t\ta2len;\n\t\t\tint\t\t\tr;\n\n\t\t\tif (len1 >= TEXTBUFLEN / 2)\n\t\t\t{\n\t\t\t\ta1len = len1 * 2 + 2;\n\t\t\t\ta1p = palloc(a1len);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta1len = TEXTBUFLEN;\n\t\t\t\ta1p = a1buf;\n\t\t\t}\n\t\t\tif (len2 >= TEXTBUFLEN / 2)\n\t\t\t{\n\t\t\t\ta2len = len2 * 2 + 2;\n\t\t\t\ta2p = palloc(a2len);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta2len = TEXTBUFLEN;\n\t\t\t\ta2p = a2buf;\n\t\t\t}\n\n\t\t\t/* stupid Microsloth API does not work for zero-length input */\n\t\t\tif (len1 == 0)\n\t\t\t\tr = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = MultiByteToWideChar(CP_UTF8, 0, arg1, len1,\n\t\t\t\t\t\t\t\t\t\t(LPWSTR) a1p, a1len / 2);\n\t\t\t\tif (!r)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errmsg(\"could not convert string to UTF-16: error code %lu\",\n\t\t\t\t\t\t\t\t\tGetLastError())));\n\t\t\t}\n\t\t\t((LPWSTR) a1p)[r] = 0;\n\n\t\t\tif (len2 == 0)\n\t\t\t\tr = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = MultiByteToWideChar(CP_UTF8, 0, arg2, len2,\n\t\t\t\t\t\t\t\t\t\t(LPWSTR) a2p, a2len / 2);\n\t\t\t\tif (!r)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errmsg(\"could not convert string to UTF-16: error code %lu\",\n\t\t\t\t\t\t\t\t\tGetLastError())));\n\t\t\t}\n\t\t\t((LPWSTR) a2p)[r] = 0;\n\n\t\t\terrno = 0;\n#ifdef HAVE_LOCALE_T\n\t\t\tif (mylocale)\n\t\t\t\tresult = wcscoll_l((LPWSTR) a1p, (LPWSTR) a2p, mylocale->info.lt);\n\t\t\telse\n#endif\n\t\t\t\tresult = wcscoll((LPWSTR) a1p, (LPWSTR) a2p);\n\t\t\tif (result == 2147483647)\t/* _NLSCMPERROR; missing from mingw\n\t\t\t\t\t\t\t\t\t\t * headers */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errmsg(\"could not compare Unicode strings: %m\")));\n\n\t\t\t/*\n\t\t\t * In some locales wcscoll() can claim that nonidentical strings\n\t\t\t * are equal.  Believing that would be bad news for a number of\n\t\t\t * reasons, so we follow Perl's lead and sort \"equal\" strings\n\t\t\t * according to strcmp (on the UTF-8 representation).\n\t\t\t */\n\t\t\tif (result == 0)\n\t\t\t{\n\t\t\t\tresult = memcmp(arg1, arg2, Min(len1, len2));\n\t\t\t\tif ((result == 0) && (len1 != len2))\n\t\t\t\t\tresult = (len1 < len2) ? -1 : 1;\n\t\t\t}\n\n\t\t\tif (a1p != a1buf)\n\t\t\t\tpfree(a1p);\n\t\t\tif (a2p != a2buf)\n\t\t\t\tpfree(a2p);\n\n\t\t\treturn result;\n\t\t}\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\n\t\tif (len1 >= TEXTBUFLEN)\n\t\t\ta1p = (char *) palloc(len1 + 1);\n\t\telse\n\t\t\ta1p = a1buf;\n\t\tif (len2 >= TEXTBUFLEN)\n\t\t\ta2p = (char *) palloc(len2 + 1);\n\t\telse\n\t\t\ta2p = a2buf;\n\n\t\tmemcpy(a1p, arg1, len1);\n\t\ta1p[len1] = '\\0';\n\t\tmemcpy(a2p, arg2, len2);\n\t\ta2p[len2] = '\\0';\n\n\t\tif (mylocale)\n\t\t{\n\t\t\tif (mylocale->provider == COLLPROVIDER_ICU)\n\t\t\t{\n#ifdef USE_ICU\n#ifdef HAVE_UCOL_STRCOLLUTF8\n\t\t\t\tif (GetDatabaseEncoding() == PG_UTF8)\n\t\t\t\t{\n\t\t\t\t\tUErrorCode\tstatus;\n\n\t\t\t\t\tstatus = U_ZERO_ERROR;\n\t\t\t\t\tresult = ucol_strcollUTF8(mylocale->info.icu.ucol,\n\t\t\t\t\t\t\t\t\t\t\t  arg1, len1,\n\t\t\t\t\t\t\t\t\t\t\t  arg2, len2,\n\t\t\t\t\t\t\t\t\t\t\t  &status);\n\t\t\t\t\tif (U_FAILURE(status))\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errmsg(\"collation failed: %s\", u_errorName(status))));\n\t\t\t\t}\n\t\t\t\telse\n#endif\n\t\t\t\t{\n\t\t\t\t\tint32_t\t\tulen1,\n\t\t\t\t\t\t\t\tulen2;\n\t\t\t\t\tUChar\t   *uchar1,\n\t\t\t\t\t\t\t   *uchar2;\n\n\t\t\t\t\tulen1 = icu_to_uchar(&uchar1, arg1, len1);\n\t\t\t\t\tulen2 = icu_to_uchar(&uchar2, arg2, len2);\n\n\t\t\t\t\tresult = ucol_strcoll(mylocale->info.icu.ucol,\n\t\t\t\t\t\t\t\t\t\t  uchar1, ulen1,\n\t\t\t\t\t\t\t\t\t\t  uchar2, ulen2);\n\n\t\t\t\t\tpfree(uchar1);\n\t\t\t\t\tpfree(uchar2);\n\t\t\t\t}\n#else\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t\t/* shouldn't happen */\n\t\t\t\telog(ERROR, \"unsupported collprovider: %c\", mylocale->provider);\n#endif\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t}\n\t\t\telse\n\t\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\t\tresult = strcoll_l(a1p, a2p, mylocale->info.lt);\n#else\n\t\t\t\t/* shouldn't happen */\n\t\t\t\telog(ERROR, \"unsupported collprovider: %c\", mylocale->provider);\n#endif\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tresult = strcoll(a1p, a2p);\n\n\t\t/*\n\t\t * In some locales strcoll() can claim that nonidentical strings are\n\t\t * equal.  Believing that would be bad news for a number of reasons,\n\t\t * so we follow Perl's lead and sort \"equal\" strings according to\n\t\t * strcmp().\n\t\t */\n\t\tif (result == 0)\n\t\t\tresult = strcmp(a1p, a2p);\n\n\t\tif (a1p != a1buf)\n\t\t\tpfree(a1p);\n\t\tif (a2p != a2buf)\n\t\t\tpfree(a2p);\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "arg2"
          ],
          "line": 1627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "arg1"
          ],
          "line": 1626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "arg2"
          ],
          "line": 1624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "arg1"
          ],
          "line": 1623
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttext_cmp(text *arg1, text *arg2, Oid collid);\n\nstatic int\ntext_cmp(text *arg1, text *arg2, Oid collid)\n{\n\tchar\t   *a1p,\n\t\t\t   *a2p;\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\n\ta1p = VARDATA_ANY(arg1);\n\ta2p = VARDATA_ANY(arg2);\n\n\tlen1 = VARSIZE_ANY_EXHDR(arg1);\n\tlen2 = VARSIZE_ANY_EXHDR(arg2);\n\n\treturn varstr_cmp(a1p, len1, a2p, len2, collid);\n}"
  },
  {
    "function_name": "varstr_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "1380-1609",
    "snippet": "int\nvarstr_cmp(const char *arg1, int len1, const char *arg2, int len2, Oid collid)\n{\n\tint\t\t\tresult;\n\n\t/*\n\t * Unfortunately, there is no strncoll(), so in the non-C locale case we\n\t * have to do some memory copying.  This turns out to be significantly\n\t * slower, so we optimize the case where LC_COLLATE is C.  We also try to\n\t * optimize relatively-short strings by avoiding palloc/pfree overhead.\n\t */\n\tif (lc_collate_is_c(collid))\n\t{\n\t\tresult = memcmp(arg1, arg2, Min(len1, len2));\n\t\tif ((result == 0) && (len1 != len2))\n\t\t\tresult = (len1 < len2) ? -1 : 1;\n\t}\n\telse\n\t{\n\t\tchar\t\ta1buf[TEXTBUFLEN];\n\t\tchar\t\ta2buf[TEXTBUFLEN];\n\t\tchar\t   *a1p,\n\t\t\t\t   *a2p;\n\t\tpg_locale_t mylocale = 0;\n\n\t\tif (collid != DEFAULT_COLLATION_OID)\n\t\t{\n\t\t\tif (!OidIsValid(collid))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This typically means that the parser could not resolve a\n\t\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t\t errmsg(\"could not determine which collation to use for string comparison\"),\n\t\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t\t}\n\t\t\tmylocale = pg_newlocale_from_collation(collid);\n\t\t}\n\n\t\t/*\n\t\t * memcmp() can't tell us which of two unequal strings sorts first,\n\t\t * but it's a cheap way to tell if they're equal.  Testing shows that\n\t\t * memcmp() followed by strcoll() is only trivially slower than\n\t\t * strcoll() by itself, so we don't lose much if this doesn't work out\n\t\t * very often, and if it does - for example, because there are many\n\t\t * equal strings in the input - then we win big by avoiding expensive\n\t\t * collation-aware comparisons.\n\t\t */\n\t\tif (len1 == len2 && memcmp(arg1, arg2, len1) == 0)\n\t\t\treturn 0;\n\n#ifdef WIN32\n\t\t/* Win32 does not have UTF-8, so we need to map to UTF-16 */\n\t\tif (GetDatabaseEncoding() == PG_UTF8\n\t\t\t&& (!mylocale || mylocale->provider == COLLPROVIDER_LIBC))\n\t\t{\n\t\t\tint\t\t\ta1len;\n\t\t\tint\t\t\ta2len;\n\t\t\tint\t\t\tr;\n\n\t\t\tif (len1 >= TEXTBUFLEN / 2)\n\t\t\t{\n\t\t\t\ta1len = len1 * 2 + 2;\n\t\t\t\ta1p = palloc(a1len);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta1len = TEXTBUFLEN;\n\t\t\t\ta1p = a1buf;\n\t\t\t}\n\t\t\tif (len2 >= TEXTBUFLEN / 2)\n\t\t\t{\n\t\t\t\ta2len = len2 * 2 + 2;\n\t\t\t\ta2p = palloc(a2len);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta2len = TEXTBUFLEN;\n\t\t\t\ta2p = a2buf;\n\t\t\t}\n\n\t\t\t/* stupid Microsloth API does not work for zero-length input */\n\t\t\tif (len1 == 0)\n\t\t\t\tr = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = MultiByteToWideChar(CP_UTF8, 0, arg1, len1,\n\t\t\t\t\t\t\t\t\t\t(LPWSTR) a1p, a1len / 2);\n\t\t\t\tif (!r)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errmsg(\"could not convert string to UTF-16: error code %lu\",\n\t\t\t\t\t\t\t\t\tGetLastError())));\n\t\t\t}\n\t\t\t((LPWSTR) a1p)[r] = 0;\n\n\t\t\tif (len2 == 0)\n\t\t\t\tr = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = MultiByteToWideChar(CP_UTF8, 0, arg2, len2,\n\t\t\t\t\t\t\t\t\t\t(LPWSTR) a2p, a2len / 2);\n\t\t\t\tif (!r)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errmsg(\"could not convert string to UTF-16: error code %lu\",\n\t\t\t\t\t\t\t\t\tGetLastError())));\n\t\t\t}\n\t\t\t((LPWSTR) a2p)[r] = 0;\n\n\t\t\terrno = 0;\n#ifdef HAVE_LOCALE_T\n\t\t\tif (mylocale)\n\t\t\t\tresult = wcscoll_l((LPWSTR) a1p, (LPWSTR) a2p, mylocale->info.lt);\n\t\t\telse\n#endif\n\t\t\t\tresult = wcscoll((LPWSTR) a1p, (LPWSTR) a2p);\n\t\t\tif (result == 2147483647)\t/* _NLSCMPERROR; missing from mingw\n\t\t\t\t\t\t\t\t\t\t * headers */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errmsg(\"could not compare Unicode strings: %m\")));\n\n\t\t\t/*\n\t\t\t * In some locales wcscoll() can claim that nonidentical strings\n\t\t\t * are equal.  Believing that would be bad news for a number of\n\t\t\t * reasons, so we follow Perl's lead and sort \"equal\" strings\n\t\t\t * according to strcmp (on the UTF-8 representation).\n\t\t\t */\n\t\t\tif (result == 0)\n\t\t\t{\n\t\t\t\tresult = memcmp(arg1, arg2, Min(len1, len2));\n\t\t\t\tif ((result == 0) && (len1 != len2))\n\t\t\t\t\tresult = (len1 < len2) ? -1 : 1;\n\t\t\t}\n\n\t\t\tif (a1p != a1buf)\n\t\t\t\tpfree(a1p);\n\t\t\tif (a2p != a2buf)\n\t\t\t\tpfree(a2p);\n\n\t\t\treturn result;\n\t\t}\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\n\t\tif (len1 >= TEXTBUFLEN)\n\t\t\ta1p = (char *) palloc(len1 + 1);\n\t\telse\n\t\t\ta1p = a1buf;\n\t\tif (len2 >= TEXTBUFLEN)\n\t\t\ta2p = (char *) palloc(len2 + 1);\n\t\telse\n\t\t\ta2p = a2buf;\n\n\t\tmemcpy(a1p, arg1, len1);\n\t\ta1p[len1] = '\\0';\n\t\tmemcpy(a2p, arg2, len2);\n\t\ta2p[len2] = '\\0';\n\n\t\tif (mylocale)\n\t\t{\n\t\t\tif (mylocale->provider == COLLPROVIDER_ICU)\n\t\t\t{\n#ifdef USE_ICU\n#ifdef HAVE_UCOL_STRCOLLUTF8\n\t\t\t\tif (GetDatabaseEncoding() == PG_UTF8)\n\t\t\t\t{\n\t\t\t\t\tUErrorCode\tstatus;\n\n\t\t\t\t\tstatus = U_ZERO_ERROR;\n\t\t\t\t\tresult = ucol_strcollUTF8(mylocale->info.icu.ucol,\n\t\t\t\t\t\t\t\t\t\t\t  arg1, len1,\n\t\t\t\t\t\t\t\t\t\t\t  arg2, len2,\n\t\t\t\t\t\t\t\t\t\t\t  &status);\n\t\t\t\t\tif (U_FAILURE(status))\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errmsg(\"collation failed: %s\", u_errorName(status))));\n\t\t\t\t}\n\t\t\t\telse\n#endif\n\t\t\t\t{\n\t\t\t\t\tint32_t\t\tulen1,\n\t\t\t\t\t\t\t\tulen2;\n\t\t\t\t\tUChar\t   *uchar1,\n\t\t\t\t\t\t\t   *uchar2;\n\n\t\t\t\t\tulen1 = icu_to_uchar(&uchar1, arg1, len1);\n\t\t\t\t\tulen2 = icu_to_uchar(&uchar2, arg2, len2);\n\n\t\t\t\t\tresult = ucol_strcoll(mylocale->info.icu.ucol,\n\t\t\t\t\t\t\t\t\t\t  uchar1, ulen1,\n\t\t\t\t\t\t\t\t\t\t  uchar2, ulen2);\n\n\t\t\t\t\tpfree(uchar1);\n\t\t\t\t\tpfree(uchar2);\n\t\t\t\t}\n#else\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t\t/* shouldn't happen */\n\t\t\t\telog(ERROR, \"unsupported collprovider: %c\", mylocale->provider);\n#endif\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t}\n\t\t\telse\n\t\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\t\tresult = strcoll_l(a1p, a2p, mylocale->info.lt);\n#else\n\t\t\t\t/* shouldn't happen */\n\t\t\t\telog(ERROR, \"unsupported collprovider: %c\", mylocale->provider);\n#endif\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tresult = strcoll(a1p, a2p);\n\n\t\t/*\n\t\t * In some locales strcoll() can claim that nonidentical strings are\n\t\t * equal.  Believing that would be bad news for a number of reasons,\n\t\t * so we follow Perl's lead and sort \"equal\" strings according to\n\t\t * strcmp().\n\t\t */\n\t\tif (result == 0)\n\t\t\tresult = strcmp(a1p, a2p);\n\n\t\tif (a1p != a1buf)\n\t\t\tpfree(a1p);\n\t\tif (a2p != a2buf)\n\t\t\tpfree(a2p);\n\t}\n\n\treturn result;\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define TEXTBUFLEN\t\t1024"
    ],
    "globals_used": [
      "static int\ttext_cmp(text *arg1, text *arg2, Oid collid);",
      "static void appendStringInfoText(StringInfo str, const text *t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "a2p"
          ],
          "line": 1605
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "a1p",
            "a2p"
          ],
          "line": 1600
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "246-256",
          "snippet": "int\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcoll",
          "args": [
            "a1p",
            "a2p"
          ],
          "line": 1591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unsupported collprovider: %c\"",
            "mylocale->provider"
          ],
          "line": 1586
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcoll_l",
          "args": [
            "a1p",
            "a2p",
            "mylocale->info.lt"
          ],
          "line": 1583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ucol_strcoll",
          "args": [
            "mylocale->info.icu.ucol",
            "uchar1",
            "ulen1",
            "uchar2",
            "ulen2"
          ],
          "line": 1568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "icu_to_uchar",
          "args": [
            "&uchar2",
            "arg2",
            "len2"
          ],
          "line": 1566
        },
        "resolved": true,
        "details": {
          "function_name": "icu_to_uchar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "1585-1610",
          "snippet": "int32_t\nicu_to_uchar(UChar **buff_uchar, const char *buff, size_t nbytes)\n{\n\tUErrorCode\tstatus;\n\tint32_t\t\tlen_uchar;\n\n\tinit_icu_converter();\n\n\tstatus = U_ZERO_ERROR;\n\tlen_uchar = ucnv_toUChars(icu_converter, NULL, 0,\n\t\t\t\t\t\t\t  buff, nbytes, &status);\n\tif (U_FAILURE(status) && status != U_BUFFER_OVERFLOW_ERROR)\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"ucnv_toUChars failed: %s\", u_errorName(status))));\n\n\t*buff_uchar = palloc((len_uchar + 1) * sizeof(**buff_uchar));\n\n\tstatus = U_ZERO_ERROR;\n\tlen_uchar = ucnv_toUChars(icu_converter, *buff_uchar, len_uchar + 1,\n\t\t\t\t\t\t\t  buff, nbytes, &status);\n\tif (U_FAILURE(status))\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"ucnv_toUChars failed: %s\", u_errorName(status))));\n\n\treturn len_uchar;\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nint32_t\nicu_to_uchar(UChar **buff_uchar, const char *buff, size_t nbytes)\n{\n\tUErrorCode\tstatus;\n\tint32_t\t\tlen_uchar;\n\n\tinit_icu_converter();\n\n\tstatus = U_ZERO_ERROR;\n\tlen_uchar = ucnv_toUChars(icu_converter, NULL, 0,\n\t\t\t\t\t\t\t  buff, nbytes, &status);\n\tif (U_FAILURE(status) && status != U_BUFFER_OVERFLOW_ERROR)\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"ucnv_toUChars failed: %s\", u_errorName(status))));\n\n\t*buff_uchar = palloc((len_uchar + 1) * sizeof(**buff_uchar));\n\n\tstatus = U_ZERO_ERROR;\n\tlen_uchar = ucnv_toUChars(icu_converter, *buff_uchar, len_uchar + 1,\n\t\t\t\t\t\t\t  buff, nbytes, &status);\n\tif (U_FAILURE(status))\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"ucnv_toUChars failed: %s\", u_errorName(status))));\n\n\treturn len_uchar;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errmsg(\"collation failed: %s\", u_errorName(status)))"
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"collation failed: %s\"",
            "u_errorName(status)"
          ],
          "line": 1555
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "u_errorName",
          "args": [
            "status"
          ],
          "line": 1555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "U_FAILURE",
          "args": [
            "status"
          ],
          "line": 1553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ucol_strcollUTF8",
          "args": [
            "mylocale->info.icu.ucol",
            "arg1",
            "len1",
            "arg2",
            "len2",
            "&status"
          ],
          "line": 1549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetDatabaseEncoding",
          "args": [],
          "line": 1544
        },
        "resolved": true,
        "details": {
          "function_name": "GetDatabaseEncodingName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "1009-1013",
          "snippet": "const char *\nGetDatabaseEncodingName(void)\n{\n\treturn DatabaseEncoding->name;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nconst char *\nGetDatabaseEncodingName(void)\n{\n\treturn DatabaseEncoding->name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "a2p",
            "arg2",
            "len2"
          ],
          "line": 1535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "a1p",
            "arg1",
            "len1"
          ],
          "line": 1533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "len2 + 1"
          ],
          "line": 1529
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "arg1",
            "arg2",
            "Min(len1, len2)"
          ],
          "line": 1510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "len1",
            "len2"
          ],
          "line": 1510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errmsg(\"could not compare Unicode strings: %m\"))"
          ],
          "line": 1499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wcscoll",
          "args": [
            "(LPWSTR) a1p",
            "(LPWSTR) a2p"
          ],
          "line": 1496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wcscoll_l",
          "args": [
            "(LPWSTR) a1p",
            "(LPWSTR) a2p",
            "mylocale->info.lt"
          ],
          "line": 1493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errmsg(\"could not convert string to UTF-16: error code %lu\",\n\t\t\t\t\t\t\t\t\tGetLastError()))"
          ],
          "line": 1484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetLastError",
          "args": [],
          "line": 1486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MultiByteToWideChar",
          "args": [
            "CP_UTF8",
            "0",
            "arg2",
            "len2",
            "(LPWSTR) a2p",
            "a2len / 2"
          ],
          "line": 1481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errmsg(\"could not convert string to UTF-16: error code %lu\",\n\t\t\t\t\t\t\t\t\tGetLastError()))"
          ],
          "line": 1471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetLastError",
          "args": [],
          "line": 1473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MultiByteToWideChar",
          "args": [
            "CP_UTF8",
            "0",
            "arg1",
            "len1",
            "(LPWSTR) a1p",
            "a1len / 2"
          ],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "arg1",
            "arg2",
            "len1"
          ],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_newlocale_from_collation",
          "args": [
            "collid"
          ],
          "line": 1418
        },
        "resolved": true,
        "details": {
          "function_name": "pg_newlocale_from_collation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "1333-1500",
          "snippet": "pg_locale_t\npg_newlocale_from_collation(Oid collid)\n{\n\tcollation_cache_entry *cache_entry;\n\n\t/* Callers must pass a valid OID */\n\tAssert(OidIsValid(collid));\n\n\t/* Return 0 for \"default\" collation, just in case caller forgets */\n\tif (collid == DEFAULT_COLLATION_OID)\n\t\treturn (pg_locale_t) 0;\n\n\tcache_entry = lookup_collation_cache(collid, false);\n\n\tif (cache_entry->locale == 0)\n\t{\n\t\t/* We haven't computed this yet in this session, so do it */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_collation collform;\n\t\tconst char *collcollate;\n\t\tconst char *collctype pg_attribute_unused();\n\t\tstruct pg_locale_struct result;\n\t\tpg_locale_t resultp;\n\t\tDatum\t\tcollversion;\n\t\tbool\t\tisnull;\n\n\t\ttp = SearchSysCache1(COLLOID, ObjectIdGetDatum(collid));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\telog(ERROR, \"cache lookup failed for collation %u\", collid);\n\t\tcollform = (Form_pg_collation) GETSTRUCT(tp);\n\n\t\tcollcollate = NameStr(collform->collcollate);\n\t\tcollctype = NameStr(collform->collctype);\n\n\t\t/* We'll fill in the result struct locally before allocating memory */\n\t\tmemset(&result, 0, sizeof(result));\n\t\tresult.provider = collform->collprovider;\n\n\t\tif (collform->collprovider == COLLPROVIDER_LIBC)\n\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\tlocale_t\tloc;\n\n\t\t\tif (strcmp(collcollate, collctype) == 0)\n\t\t\t{\n\t\t\t\t/* Normal case where they're the same */\n\t\t\t\terrno = 0;\n#ifndef WIN32\n\t\t\t\tloc = newlocale(LC_COLLATE_MASK | LC_CTYPE_MASK, collcollate,\n\t\t\t\t\t\t\t\tNULL);\n#else\n\t\t\t\tloc = _create_locale(LC_ALL, collcollate);\n#endif\n\t\t\t\tif (!loc)\n\t\t\t\t\treport_newlocale_failure(collcollate);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n#ifndef WIN32\n\t\t\t\t/* We need two newlocale() steps */\n\t\t\t\tlocale_t\tloc1;\n\n\t\t\t\terrno = 0;\n\t\t\t\tloc1 = newlocale(LC_COLLATE_MASK, collcollate, NULL);\n\t\t\t\tif (!loc1)\n\t\t\t\t\treport_newlocale_failure(collcollate);\n\t\t\t\terrno = 0;\n\t\t\t\tloc = newlocale(LC_CTYPE_MASK, collctype, loc1);\n\t\t\t\tif (!loc)\n\t\t\t\t\treport_newlocale_failure(collctype);\n#else\n\n\t\t\t\t/*\n\t\t\t\t * XXX The _create_locale() API doesn't appear to support\n\t\t\t\t * this. Could perhaps be worked around by changing\n\t\t\t\t * pg_locale_t to contain two separate fields.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"collations with different collate and ctype values are not supported on this platform\")));\n#endif\n\t\t\t}\n\n\t\t\tresult.info.lt = loc;\n#else\t\t\t\t\t\t\t/* not HAVE_LOCALE_T */\n\t\t\t/* platform that doesn't support locale_t */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"collation provider LIBC is not supported on this platform\")));\n#endif\t\t\t\t\t\t\t/* not HAVE_LOCALE_T */\n\t\t}\n\t\telse if (collform->collprovider == COLLPROVIDER_ICU)\n\t\t{\n#ifdef USE_ICU\n\t\t\tUCollator  *collator;\n\t\t\tUErrorCode\tstatus;\n\n\t\t\tif (strcmp(collcollate, collctype) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"collations with different collate and ctype values are not supported by ICU\")));\n\n\t\t\tstatus = U_ZERO_ERROR;\n\t\t\tcollator = ucol_open(collcollate, &status);\n\t\t\tif (U_FAILURE(status))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errmsg(\"could not open collator for locale \\\"%s\\\": %s\",\n\t\t\t\t\t\t\t\tcollcollate, u_errorName(status))));\n\n\t\t\t/* We will leak this string if we get an error below :-( */\n\t\t\tresult.info.icu.locale = MemoryContextStrdup(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t collcollate);\n\t\t\tresult.info.icu.ucol = collator;\n#else\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t/* could get here if a collation was created by a build with ICU */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"ICU is not supported in this build\"), \\\n\t\t\t\t\t errhint(\"You need to rebuild PostgreSQL using --with-icu.\")));\n#endif\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t}\n\n\t\tcollversion = SysCacheGetAttr(COLLOID, tp, Anum_pg_collation_collversion,\n\t\t\t\t\t\t\t\t\t  &isnull);\n\t\tif (!isnull)\n\t\t{\n\t\t\tchar\t   *actual_versionstr;\n\t\t\tchar\t   *collversionstr;\n\n\t\t\tactual_versionstr = get_collation_actual_version(collform->collprovider, collcollate);\n\t\t\tif (!actual_versionstr)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This could happen when specifying a version in CREATE\n\t\t\t\t * COLLATION for a libc locale, or manually creating a mess in\n\t\t\t\t * the catalogs.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errmsg(\"collation \\\"%s\\\" has no actual version, but a version was specified\",\n\t\t\t\t\t\t\t\tNameStr(collform->collname))));\n\t\t\t}\n\t\t\tcollversionstr = TextDatumGetCString(collversion);\n\n\t\t\tif (strcmp(actual_versionstr, collversionstr) != 0)\n\t\t\t\tereport(WARNING,\n\t\t\t\t\t\t(errmsg(\"collation \\\"%s\\\" has version mismatch\",\n\t\t\t\t\t\t\t\tNameStr(collform->collname)),\n\t\t\t\t\t\t errdetail(\"The collation in the database was created using version %s, \"\n\t\t\t\t\t\t\t\t   \"but the operating system provides version %s.\",\n\t\t\t\t\t\t\t\t   collversionstr, actual_versionstr),\n\t\t\t\t\t\t errhint(\"Rebuild all objects affected by this collation and run \"\n\t\t\t\t\t\t\t\t \"ALTER COLLATION %s REFRESH VERSION, \"\n\t\t\t\t\t\t\t\t \"or build PostgreSQL with the right library version.\",\n\t\t\t\t\t\t\t\t quote_qualified_identifier(get_namespace_name(collform->collnamespace),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tNameStr(collform->collname)))));\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\n\t\t/* We'll keep the pg_locale_t structures in TopMemoryContext */\n\t\tresultp = MemoryContextAlloc(TopMemoryContext, sizeof(*resultp));\n\t\t*resultp = result;\n\n\t\tcache_entry->locale = resultp;\n\t}\n\n\treturn cache_entry->locale;\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\npg_locale_t\npg_newlocale_from_collation(Oid collid)\n{\n\tcollation_cache_entry *cache_entry;\n\n\t/* Callers must pass a valid OID */\n\tAssert(OidIsValid(collid));\n\n\t/* Return 0 for \"default\" collation, just in case caller forgets */\n\tif (collid == DEFAULT_COLLATION_OID)\n\t\treturn (pg_locale_t) 0;\n\n\tcache_entry = lookup_collation_cache(collid, false);\n\n\tif (cache_entry->locale == 0)\n\t{\n\t\t/* We haven't computed this yet in this session, so do it */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_collation collform;\n\t\tconst char *collcollate;\n\t\tconst char *collctype pg_attribute_unused();\n\t\tstruct pg_locale_struct result;\n\t\tpg_locale_t resultp;\n\t\tDatum\t\tcollversion;\n\t\tbool\t\tisnull;\n\n\t\ttp = SearchSysCache1(COLLOID, ObjectIdGetDatum(collid));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\telog(ERROR, \"cache lookup failed for collation %u\", collid);\n\t\tcollform = (Form_pg_collation) GETSTRUCT(tp);\n\n\t\tcollcollate = NameStr(collform->collcollate);\n\t\tcollctype = NameStr(collform->collctype);\n\n\t\t/* We'll fill in the result struct locally before allocating memory */\n\t\tmemset(&result, 0, sizeof(result));\n\t\tresult.provider = collform->collprovider;\n\n\t\tif (collform->collprovider == COLLPROVIDER_LIBC)\n\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\tlocale_t\tloc;\n\n\t\t\tif (strcmp(collcollate, collctype) == 0)\n\t\t\t{\n\t\t\t\t/* Normal case where they're the same */\n\t\t\t\terrno = 0;\n#ifndef WIN32\n\t\t\t\tloc = newlocale(LC_COLLATE_MASK | LC_CTYPE_MASK, collcollate,\n\t\t\t\t\t\t\t\tNULL);\n#else\n\t\t\t\tloc = _create_locale(LC_ALL, collcollate);\n#endif\n\t\t\t\tif (!loc)\n\t\t\t\t\treport_newlocale_failure(collcollate);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n#ifndef WIN32\n\t\t\t\t/* We need two newlocale() steps */\n\t\t\t\tlocale_t\tloc1;\n\n\t\t\t\terrno = 0;\n\t\t\t\tloc1 = newlocale(LC_COLLATE_MASK, collcollate, NULL);\n\t\t\t\tif (!loc1)\n\t\t\t\t\treport_newlocale_failure(collcollate);\n\t\t\t\terrno = 0;\n\t\t\t\tloc = newlocale(LC_CTYPE_MASK, collctype, loc1);\n\t\t\t\tif (!loc)\n\t\t\t\t\treport_newlocale_failure(collctype);\n#else\n\n\t\t\t\t/*\n\t\t\t\t * XXX The _create_locale() API doesn't appear to support\n\t\t\t\t * this. Could perhaps be worked around by changing\n\t\t\t\t * pg_locale_t to contain two separate fields.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"collations with different collate and ctype values are not supported on this platform\")));\n#endif\n\t\t\t}\n\n\t\t\tresult.info.lt = loc;\n#else\t\t\t\t\t\t\t/* not HAVE_LOCALE_T */\n\t\t\t/* platform that doesn't support locale_t */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"collation provider LIBC is not supported on this platform\")));\n#endif\t\t\t\t\t\t\t/* not HAVE_LOCALE_T */\n\t\t}\n\t\telse if (collform->collprovider == COLLPROVIDER_ICU)\n\t\t{\n#ifdef USE_ICU\n\t\t\tUCollator  *collator;\n\t\t\tUErrorCode\tstatus;\n\n\t\t\tif (strcmp(collcollate, collctype) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"collations with different collate and ctype values are not supported by ICU\")));\n\n\t\t\tstatus = U_ZERO_ERROR;\n\t\t\tcollator = ucol_open(collcollate, &status);\n\t\t\tif (U_FAILURE(status))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errmsg(\"could not open collator for locale \\\"%s\\\": %s\",\n\t\t\t\t\t\t\t\tcollcollate, u_errorName(status))));\n\n\t\t\t/* We will leak this string if we get an error below :-( */\n\t\t\tresult.info.icu.locale = MemoryContextStrdup(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t collcollate);\n\t\t\tresult.info.icu.ucol = collator;\n#else\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t/* could get here if a collation was created by a build with ICU */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"ICU is not supported in this build\"), \\\n\t\t\t\t\t errhint(\"You need to rebuild PostgreSQL using --with-icu.\")));\n#endif\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t}\n\n\t\tcollversion = SysCacheGetAttr(COLLOID, tp, Anum_pg_collation_collversion,\n\t\t\t\t\t\t\t\t\t  &isnull);\n\t\tif (!isnull)\n\t\t{\n\t\t\tchar\t   *actual_versionstr;\n\t\t\tchar\t   *collversionstr;\n\n\t\t\tactual_versionstr = get_collation_actual_version(collform->collprovider, collcollate);\n\t\t\tif (!actual_versionstr)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This could happen when specifying a version in CREATE\n\t\t\t\t * COLLATION for a libc locale, or manually creating a mess in\n\t\t\t\t * the catalogs.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errmsg(\"collation \\\"%s\\\" has no actual version, but a version was specified\",\n\t\t\t\t\t\t\t\tNameStr(collform->collname))));\n\t\t\t}\n\t\t\tcollversionstr = TextDatumGetCString(collversion);\n\n\t\t\tif (strcmp(actual_versionstr, collversionstr) != 0)\n\t\t\t\tereport(WARNING,\n\t\t\t\t\t\t(errmsg(\"collation \\\"%s\\\" has version mismatch\",\n\t\t\t\t\t\t\t\tNameStr(collform->collname)),\n\t\t\t\t\t\t errdetail(\"The collation in the database was created using version %s, \"\n\t\t\t\t\t\t\t\t   \"but the operating system provides version %s.\",\n\t\t\t\t\t\t\t\t   collversionstr, actual_versionstr),\n\t\t\t\t\t\t errhint(\"Rebuild all objects affected by this collation and run \"\n\t\t\t\t\t\t\t\t \"ALTER COLLATION %s REFRESH VERSION, \"\n\t\t\t\t\t\t\t\t \"or build PostgreSQL with the right library version.\",\n\t\t\t\t\t\t\t\t quote_qualified_identifier(get_namespace_name(collform->collnamespace),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tNameStr(collform->collname)))));\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\n\t\t/* We'll keep the pg_locale_t structures in TopMemoryContext */\n\t\tresultp = MemoryContextAlloc(TopMemoryContext, sizeof(*resultp));\n\t\t*resultp = result;\n\n\t\tcache_entry->locale = resultp;\n\t}\n\n\treturn cache_entry->locale;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t\t errmsg(\"could not determine which collation to use for string comparison\"),\n\t\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\"))"
          ],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errhint",
          "args": [
            "\"Use the COLLATE clause to set the collation explicitly.\""
          ],
          "line": 1416
        },
        "resolved": true,
        "details": {
          "function_name": "errhint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "984-999",
          "snippet": "int\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INDETERMINATE_COLLATION"
          ],
          "line": 1414
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "collid"
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "arg1",
            "arg2",
            "Min(len1, len2)"
          ],
          "line": 1393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "len1",
            "len2"
          ],
          "line": 1393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lc_collate_is_c",
          "args": [
            "collid"
          ],
          "line": 1391
        },
        "resolved": true,
        "details": {
          "function_name": "lc_collate_is_c",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "1186-1231",
          "snippet": "bool\nlc_collate_is_c(Oid collation)\n{\n\t/*\n\t * If we're asked about \"collation 0\", return false, so that the code will\n\t * go into the non-C path and report that the collation is bogus.\n\t */\n\tif (!OidIsValid(collation))\n\t\treturn false;\n\n\t/*\n\t * If we're asked about the default collation, we have to inquire of the C\n\t * library.  Cache the result so we only have to compute it once.\n\t */\n\tif (collation == DEFAULT_COLLATION_OID)\n\t{\n\t\tstatic int\tresult = -1;\n\t\tchar\t   *localeptr;\n\n\t\tif (result >= 0)\n\t\t\treturn (bool) result;\n\t\tlocaleptr = setlocale(LC_COLLATE, NULL);\n\t\tif (!localeptr)\n\t\t\telog(ERROR, \"invalid LC_COLLATE setting\");\n\n\t\tif (strcmp(localeptr, \"C\") == 0)\n\t\t\tresult = true;\n\t\telse if (strcmp(localeptr, \"POSIX\") == 0)\n\t\t\tresult = true;\n\t\telse\n\t\t\tresult = false;\n\t\treturn (bool) result;\n\t}\n\n\t/*\n\t * If we're asked about the built-in C/POSIX collations, we know that.\n\t */\n\tif (collation == C_COLLATION_OID ||\n\t\tcollation == POSIX_COLLATION_OID)\n\t\treturn true;\n\n\t/*\n\t * Otherwise, we have to consult pg_collation, but we cache that.\n\t */\n\treturn (lookup_collation_cache(collation, true))->collate_is_c;\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nbool\nlc_collate_is_c(Oid collation)\n{\n\t/*\n\t * If we're asked about \"collation 0\", return false, so that the code will\n\t * go into the non-C path and report that the collation is bogus.\n\t */\n\tif (!OidIsValid(collation))\n\t\treturn false;\n\n\t/*\n\t * If we're asked about the default collation, we have to inquire of the C\n\t * library.  Cache the result so we only have to compute it once.\n\t */\n\tif (collation == DEFAULT_COLLATION_OID)\n\t{\n\t\tstatic int\tresult = -1;\n\t\tchar\t   *localeptr;\n\n\t\tif (result >= 0)\n\t\t\treturn (bool) result;\n\t\tlocaleptr = setlocale(LC_COLLATE, NULL);\n\t\tif (!localeptr)\n\t\t\telog(ERROR, \"invalid LC_COLLATE setting\");\n\n\t\tif (strcmp(localeptr, \"C\") == 0)\n\t\t\tresult = true;\n\t\telse if (strcmp(localeptr, \"POSIX\") == 0)\n\t\t\tresult = true;\n\t\telse\n\t\t\tresult = false;\n\t\treturn (bool) result;\n\t}\n\n\t/*\n\t * If we're asked about the built-in C/POSIX collations, we know that.\n\t */\n\tif (collation == C_COLLATION_OID ||\n\t\tcollation == POSIX_COLLATION_OID)\n\t\treturn true;\n\n\t/*\n\t * Otherwise, we have to consult pg_collation, but we cache that.\n\t */\n\treturn (lookup_collation_cache(collation, true))->collate_is_c;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define TEXTBUFLEN\t\t1024\n\nstatic int\ttext_cmp(text *arg1, text *arg2, Oid collid);\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nint\nvarstr_cmp(const char *arg1, int len1, const char *arg2, int len2, Oid collid)\n{\n\tint\t\t\tresult;\n\n\t/*\n\t * Unfortunately, there is no strncoll(), so in the non-C locale case we\n\t * have to do some memory copying.  This turns out to be significantly\n\t * slower, so we optimize the case where LC_COLLATE is C.  We also try to\n\t * optimize relatively-short strings by avoiding palloc/pfree overhead.\n\t */\n\tif (lc_collate_is_c(collid))\n\t{\n\t\tresult = memcmp(arg1, arg2, Min(len1, len2));\n\t\tif ((result == 0) && (len1 != len2))\n\t\t\tresult = (len1 < len2) ? -1 : 1;\n\t}\n\telse\n\t{\n\t\tchar\t\ta1buf[TEXTBUFLEN];\n\t\tchar\t\ta2buf[TEXTBUFLEN];\n\t\tchar\t   *a1p,\n\t\t\t\t   *a2p;\n\t\tpg_locale_t mylocale = 0;\n\n\t\tif (collid != DEFAULT_COLLATION_OID)\n\t\t{\n\t\t\tif (!OidIsValid(collid))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This typically means that the parser could not resolve a\n\t\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t\t errmsg(\"could not determine which collation to use for string comparison\"),\n\t\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t\t}\n\t\t\tmylocale = pg_newlocale_from_collation(collid);\n\t\t}\n\n\t\t/*\n\t\t * memcmp() can't tell us which of two unequal strings sorts first,\n\t\t * but it's a cheap way to tell if they're equal.  Testing shows that\n\t\t * memcmp() followed by strcoll() is only trivially slower than\n\t\t * strcoll() by itself, so we don't lose much if this doesn't work out\n\t\t * very often, and if it does - for example, because there are many\n\t\t * equal strings in the input - then we win big by avoiding expensive\n\t\t * collation-aware comparisons.\n\t\t */\n\t\tif (len1 == len2 && memcmp(arg1, arg2, len1) == 0)\n\t\t\treturn 0;\n\n#ifdef WIN32\n\t\t/* Win32 does not have UTF-8, so we need to map to UTF-16 */\n\t\tif (GetDatabaseEncoding() == PG_UTF8\n\t\t\t&& (!mylocale || mylocale->provider == COLLPROVIDER_LIBC))\n\t\t{\n\t\t\tint\t\t\ta1len;\n\t\t\tint\t\t\ta2len;\n\t\t\tint\t\t\tr;\n\n\t\t\tif (len1 >= TEXTBUFLEN / 2)\n\t\t\t{\n\t\t\t\ta1len = len1 * 2 + 2;\n\t\t\t\ta1p = palloc(a1len);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta1len = TEXTBUFLEN;\n\t\t\t\ta1p = a1buf;\n\t\t\t}\n\t\t\tif (len2 >= TEXTBUFLEN / 2)\n\t\t\t{\n\t\t\t\ta2len = len2 * 2 + 2;\n\t\t\t\ta2p = palloc(a2len);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta2len = TEXTBUFLEN;\n\t\t\t\ta2p = a2buf;\n\t\t\t}\n\n\t\t\t/* stupid Microsloth API does not work for zero-length input */\n\t\t\tif (len1 == 0)\n\t\t\t\tr = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = MultiByteToWideChar(CP_UTF8, 0, arg1, len1,\n\t\t\t\t\t\t\t\t\t\t(LPWSTR) a1p, a1len / 2);\n\t\t\t\tif (!r)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errmsg(\"could not convert string to UTF-16: error code %lu\",\n\t\t\t\t\t\t\t\t\tGetLastError())));\n\t\t\t}\n\t\t\t((LPWSTR) a1p)[r] = 0;\n\n\t\t\tif (len2 == 0)\n\t\t\t\tr = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = MultiByteToWideChar(CP_UTF8, 0, arg2, len2,\n\t\t\t\t\t\t\t\t\t\t(LPWSTR) a2p, a2len / 2);\n\t\t\t\tif (!r)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errmsg(\"could not convert string to UTF-16: error code %lu\",\n\t\t\t\t\t\t\t\t\tGetLastError())));\n\t\t\t}\n\t\t\t((LPWSTR) a2p)[r] = 0;\n\n\t\t\terrno = 0;\n#ifdef HAVE_LOCALE_T\n\t\t\tif (mylocale)\n\t\t\t\tresult = wcscoll_l((LPWSTR) a1p, (LPWSTR) a2p, mylocale->info.lt);\n\t\t\telse\n#endif\n\t\t\t\tresult = wcscoll((LPWSTR) a1p, (LPWSTR) a2p);\n\t\t\tif (result == 2147483647)\t/* _NLSCMPERROR; missing from mingw\n\t\t\t\t\t\t\t\t\t\t * headers */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errmsg(\"could not compare Unicode strings: %m\")));\n\n\t\t\t/*\n\t\t\t * In some locales wcscoll() can claim that nonidentical strings\n\t\t\t * are equal.  Believing that would be bad news for a number of\n\t\t\t * reasons, so we follow Perl's lead and sort \"equal\" strings\n\t\t\t * according to strcmp (on the UTF-8 representation).\n\t\t\t */\n\t\t\tif (result == 0)\n\t\t\t{\n\t\t\t\tresult = memcmp(arg1, arg2, Min(len1, len2));\n\t\t\t\tif ((result == 0) && (len1 != len2))\n\t\t\t\t\tresult = (len1 < len2) ? -1 : 1;\n\t\t\t}\n\n\t\t\tif (a1p != a1buf)\n\t\t\t\tpfree(a1p);\n\t\t\tif (a2p != a2buf)\n\t\t\t\tpfree(a2p);\n\n\t\t\treturn result;\n\t\t}\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\n\t\tif (len1 >= TEXTBUFLEN)\n\t\t\ta1p = (char *) palloc(len1 + 1);\n\t\telse\n\t\t\ta1p = a1buf;\n\t\tif (len2 >= TEXTBUFLEN)\n\t\t\ta2p = (char *) palloc(len2 + 1);\n\t\telse\n\t\t\ta2p = a2buf;\n\n\t\tmemcpy(a1p, arg1, len1);\n\t\ta1p[len1] = '\\0';\n\t\tmemcpy(a2p, arg2, len2);\n\t\ta2p[len2] = '\\0';\n\n\t\tif (mylocale)\n\t\t{\n\t\t\tif (mylocale->provider == COLLPROVIDER_ICU)\n\t\t\t{\n#ifdef USE_ICU\n#ifdef HAVE_UCOL_STRCOLLUTF8\n\t\t\t\tif (GetDatabaseEncoding() == PG_UTF8)\n\t\t\t\t{\n\t\t\t\t\tUErrorCode\tstatus;\n\n\t\t\t\t\tstatus = U_ZERO_ERROR;\n\t\t\t\t\tresult = ucol_strcollUTF8(mylocale->info.icu.ucol,\n\t\t\t\t\t\t\t\t\t\t\t  arg1, len1,\n\t\t\t\t\t\t\t\t\t\t\t  arg2, len2,\n\t\t\t\t\t\t\t\t\t\t\t  &status);\n\t\t\t\t\tif (U_FAILURE(status))\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errmsg(\"collation failed: %s\", u_errorName(status))));\n\t\t\t\t}\n\t\t\t\telse\n#endif\n\t\t\t\t{\n\t\t\t\t\tint32_t\t\tulen1,\n\t\t\t\t\t\t\t\tulen2;\n\t\t\t\t\tUChar\t   *uchar1,\n\t\t\t\t\t\t\t   *uchar2;\n\n\t\t\t\t\tulen1 = icu_to_uchar(&uchar1, arg1, len1);\n\t\t\t\t\tulen2 = icu_to_uchar(&uchar2, arg2, len2);\n\n\t\t\t\t\tresult = ucol_strcoll(mylocale->info.icu.ucol,\n\t\t\t\t\t\t\t\t\t\t  uchar1, ulen1,\n\t\t\t\t\t\t\t\t\t\t  uchar2, ulen2);\n\n\t\t\t\t\tpfree(uchar1);\n\t\t\t\t\tpfree(uchar2);\n\t\t\t\t}\n#else\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t\t/* shouldn't happen */\n\t\t\t\telog(ERROR, \"unsupported collprovider: %c\", mylocale->provider);\n#endif\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t}\n\t\t\telse\n\t\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\t\tresult = strcoll_l(a1p, a2p, mylocale->info.lt);\n#else\n\t\t\t\t/* shouldn't happen */\n\t\t\t\telog(ERROR, \"unsupported collprovider: %c\", mylocale->provider);\n#endif\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tresult = strcoll(a1p, a2p);\n\n\t\t/*\n\t\t * In some locales strcoll() can claim that nonidentical strings are\n\t\t * equal.  Believing that would be bad news for a number of reasons,\n\t\t * so we follow Perl's lead and sort \"equal\" strings according to\n\t\t * strcmp().\n\t\t */\n\t\tif (result == 0)\n\t\t\tresult = strcmp(a1p, a2p);\n\n\t\tif (a1p != a1buf)\n\t\t\tpfree(a1p);\n\t\tif (a2p != a2buf)\n\t\t\tpfree(a2p);\n\t}\n\n\treturn result;\n}"
  },
  {
    "function_name": "text_position_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "1363-1371",
    "snippet": "static void\ntext_position_cleanup(TextPositionState *state)\n{\n\tif (state->use_wchar)\n\t{\n\t\tpfree(state->wstr1);\n\t\tpfree(state->wstr2);\n\t}\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void text_position_setup(text *t1, text *t2, TextPositionState *state);",
      "static int\ttext_position_next(int start_pos, TextPositionState *state);",
      "static void text_position_cleanup(TextPositionState *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "state->wstr2"
          ],
          "line": 1369
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void text_position_setup(text *t1, text *t2, TextPositionState *state);\nstatic int\ttext_position_next(int start_pos, TextPositionState *state);\nstatic void text_position_cleanup(TextPositionState *state);\n\nstatic void\ntext_position_cleanup(TextPositionState *state)\n{\n\tif (state->use_wchar)\n\t{\n\t\tpfree(state->wstr1);\n\t\tpfree(state->wstr2);\n\t}\n}"
  },
  {
    "function_name": "text_position_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "1229-1361",
    "snippet": "static int\ntext_position_next(int start_pos, TextPositionState *state)\n{\n\tint\t\t\thaystack_len = state->len1;\n\tint\t\t\tneedle_len = state->len2;\n\tint\t\t\tskiptablemask = state->skiptablemask;\n\n\tAssert(start_pos > 0);\t\t/* else caller error */\n\n\tif (needle_len <= 0)\n\t\treturn start_pos;\t\t/* result for empty pattern */\n\n\tstart_pos--;\t\t\t\t/* adjust for zero based arrays */\n\n\t/* Done if the needle can't possibly fit */\n\tif (haystack_len < start_pos + needle_len)\n\t\treturn 0;\n\n\tif (!state->use_wchar)\n\t{\n\t\t/* simple case - single byte encoding */\n\t\tconst char *haystack = state->str1;\n\t\tconst char *needle = state->str2;\n\t\tconst char *haystack_end = &haystack[haystack_len];\n\t\tconst char *hptr;\n\n\t\tif (needle_len == 1)\n\t\t{\n\t\t\t/* No point in using B-M-H for a one-character needle */\n\t\t\tchar\t\tnchar = *needle;\n\n\t\t\thptr = &haystack[start_pos];\n\t\t\twhile (hptr < haystack_end)\n\t\t\t{\n\t\t\t\tif (*hptr == nchar)\n\t\t\t\t\treturn hptr - haystack + 1;\n\t\t\t\thptr++;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconst char *needle_last = &needle[needle_len - 1];\n\n\t\t\t/* Start at startpos plus the length of the needle */\n\t\t\thptr = &haystack[start_pos + needle_len - 1];\n\t\t\twhile (hptr < haystack_end)\n\t\t\t{\n\t\t\t\t/* Match the needle scanning *backward* */\n\t\t\t\tconst char *nptr;\n\t\t\t\tconst char *p;\n\n\t\t\t\tnptr = needle_last;\n\t\t\t\tp = hptr;\n\t\t\t\twhile (*nptr == *p)\n\t\t\t\t{\n\t\t\t\t\t/* Matched it all?\tIf so, return 1-based position */\n\t\t\t\t\tif (nptr == needle)\n\t\t\t\t\t\treturn p - haystack + 1;\n\t\t\t\t\tnptr--, p--;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * No match, so use the haystack char at hptr to decide how\n\t\t\t\t * far to advance.  If the needle had any occurrence of that\n\t\t\t\t * character (or more precisely, one sharing the same\n\t\t\t\t * skiptable entry) before its last character, then we advance\n\t\t\t\t * far enough to align the last such needle character with\n\t\t\t\t * that haystack position.  Otherwise we can advance by the\n\t\t\t\t * whole needle length.\n\t\t\t\t */\n\t\t\t\thptr += state->skiptable[(unsigned char) *hptr & skiptablemask];\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* The multibyte char version. This works exactly the same way. */\n\t\tconst pg_wchar *haystack = state->wstr1;\n\t\tconst pg_wchar *needle = state->wstr2;\n\t\tconst pg_wchar *haystack_end = &haystack[haystack_len];\n\t\tconst pg_wchar *hptr;\n\n\t\tif (needle_len == 1)\n\t\t{\n\t\t\t/* No point in using B-M-H for a one-character needle */\n\t\t\tpg_wchar\tnchar = *needle;\n\n\t\t\thptr = &haystack[start_pos];\n\t\t\twhile (hptr < haystack_end)\n\t\t\t{\n\t\t\t\tif (*hptr == nchar)\n\t\t\t\t\treturn hptr - haystack + 1;\n\t\t\t\thptr++;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconst pg_wchar *needle_last = &needle[needle_len - 1];\n\n\t\t\t/* Start at startpos plus the length of the needle */\n\t\t\thptr = &haystack[start_pos + needle_len - 1];\n\t\t\twhile (hptr < haystack_end)\n\t\t\t{\n\t\t\t\t/* Match the needle scanning *backward* */\n\t\t\t\tconst pg_wchar *nptr;\n\t\t\t\tconst pg_wchar *p;\n\n\t\t\t\tnptr = needle_last;\n\t\t\t\tp = hptr;\n\t\t\t\twhile (*nptr == *p)\n\t\t\t\t{\n\t\t\t\t\t/* Matched it all?\tIf so, return 1-based position */\n\t\t\t\t\tif (nptr == needle)\n\t\t\t\t\t\treturn p - haystack + 1;\n\t\t\t\t\tnptr--, p--;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * No match, so use the haystack char at hptr to decide how\n\t\t\t\t * far to advance.  If the needle had any occurrence of that\n\t\t\t\t * character (or more precisely, one sharing the same\n\t\t\t\t * skiptable entry) before its last character, then we advance\n\t\t\t\t * far enough to align the last such needle character with\n\t\t\t\t * that haystack position.  Otherwise we can advance by the\n\t\t\t\t * whole needle length.\n\t\t\t\t */\n\t\t\t\thptr += state->skiptable[*hptr & skiptablemask];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\t\t\t\t\t/* not found */\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void text_position_setup(text *t1, text *t2, TextPositionState *state);",
      "static int\ttext_position_next(int start_pos, TextPositionState *state);",
      "static void text_position_cleanup(TextPositionState *state);",
      "static void appendStringInfoText(StringInfo str, const text *t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "start_pos > 0"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void text_position_setup(text *t1, text *t2, TextPositionState *state);\nstatic int\ttext_position_next(int start_pos, TextPositionState *state);\nstatic void text_position_cleanup(TextPositionState *state);\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nstatic int\ntext_position_next(int start_pos, TextPositionState *state)\n{\n\tint\t\t\thaystack_len = state->len1;\n\tint\t\t\tneedle_len = state->len2;\n\tint\t\t\tskiptablemask = state->skiptablemask;\n\n\tAssert(start_pos > 0);\t\t/* else caller error */\n\n\tif (needle_len <= 0)\n\t\treturn start_pos;\t\t/* result for empty pattern */\n\n\tstart_pos--;\t\t\t\t/* adjust for zero based arrays */\n\n\t/* Done if the needle can't possibly fit */\n\tif (haystack_len < start_pos + needle_len)\n\t\treturn 0;\n\n\tif (!state->use_wchar)\n\t{\n\t\t/* simple case - single byte encoding */\n\t\tconst char *haystack = state->str1;\n\t\tconst char *needle = state->str2;\n\t\tconst char *haystack_end = &haystack[haystack_len];\n\t\tconst char *hptr;\n\n\t\tif (needle_len == 1)\n\t\t{\n\t\t\t/* No point in using B-M-H for a one-character needle */\n\t\t\tchar\t\tnchar = *needle;\n\n\t\t\thptr = &haystack[start_pos];\n\t\t\twhile (hptr < haystack_end)\n\t\t\t{\n\t\t\t\tif (*hptr == nchar)\n\t\t\t\t\treturn hptr - haystack + 1;\n\t\t\t\thptr++;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconst char *needle_last = &needle[needle_len - 1];\n\n\t\t\t/* Start at startpos plus the length of the needle */\n\t\t\thptr = &haystack[start_pos + needle_len - 1];\n\t\t\twhile (hptr < haystack_end)\n\t\t\t{\n\t\t\t\t/* Match the needle scanning *backward* */\n\t\t\t\tconst char *nptr;\n\t\t\t\tconst char *p;\n\n\t\t\t\tnptr = needle_last;\n\t\t\t\tp = hptr;\n\t\t\t\twhile (*nptr == *p)\n\t\t\t\t{\n\t\t\t\t\t/* Matched it all?\tIf so, return 1-based position */\n\t\t\t\t\tif (nptr == needle)\n\t\t\t\t\t\treturn p - haystack + 1;\n\t\t\t\t\tnptr--, p--;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * No match, so use the haystack char at hptr to decide how\n\t\t\t\t * far to advance.  If the needle had any occurrence of that\n\t\t\t\t * character (or more precisely, one sharing the same\n\t\t\t\t * skiptable entry) before its last character, then we advance\n\t\t\t\t * far enough to align the last such needle character with\n\t\t\t\t * that haystack position.  Otherwise we can advance by the\n\t\t\t\t * whole needle length.\n\t\t\t\t */\n\t\t\t\thptr += state->skiptable[(unsigned char) *hptr & skiptablemask];\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* The multibyte char version. This works exactly the same way. */\n\t\tconst pg_wchar *haystack = state->wstr1;\n\t\tconst pg_wchar *needle = state->wstr2;\n\t\tconst pg_wchar *haystack_end = &haystack[haystack_len];\n\t\tconst pg_wchar *hptr;\n\n\t\tif (needle_len == 1)\n\t\t{\n\t\t\t/* No point in using B-M-H for a one-character needle */\n\t\t\tpg_wchar\tnchar = *needle;\n\n\t\t\thptr = &haystack[start_pos];\n\t\t\twhile (hptr < haystack_end)\n\t\t\t{\n\t\t\t\tif (*hptr == nchar)\n\t\t\t\t\treturn hptr - haystack + 1;\n\t\t\t\thptr++;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconst pg_wchar *needle_last = &needle[needle_len - 1];\n\n\t\t\t/* Start at startpos plus the length of the needle */\n\t\t\thptr = &haystack[start_pos + needle_len - 1];\n\t\t\twhile (hptr < haystack_end)\n\t\t\t{\n\t\t\t\t/* Match the needle scanning *backward* */\n\t\t\t\tconst pg_wchar *nptr;\n\t\t\t\tconst pg_wchar *p;\n\n\t\t\t\tnptr = needle_last;\n\t\t\t\tp = hptr;\n\t\t\t\twhile (*nptr == *p)\n\t\t\t\t{\n\t\t\t\t\t/* Matched it all?\tIf so, return 1-based position */\n\t\t\t\t\tif (nptr == needle)\n\t\t\t\t\t\treturn p - haystack + 1;\n\t\t\t\t\tnptr--, p--;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * No match, so use the haystack char at hptr to decide how\n\t\t\t\t * far to advance.  If the needle had any occurrence of that\n\t\t\t\t * character (or more precisely, one sharing the same\n\t\t\t\t * skiptable entry) before its last character, then we advance\n\t\t\t\t * far enough to align the last such needle character with\n\t\t\t\t * that haystack position.  Otherwise we can advance by the\n\t\t\t\t * whole needle length.\n\t\t\t\t */\n\t\t\t\thptr += state->skiptable[*hptr & skiptablemask];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\t\t\t\t\t/* not found */\n}"
  },
  {
    "function_name": "text_position_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "1117-1227",
    "snippet": "static void\ntext_position_setup(text *t1, text *t2, TextPositionState *state)\n{\n\tint\t\t\tlen1 = VARSIZE_ANY_EXHDR(t1);\n\tint\t\t\tlen2 = VARSIZE_ANY_EXHDR(t2);\n\n\tif (pg_database_encoding_max_length() == 1)\n\t{\n\t\t/* simple case - single byte encoding */\n\t\tstate->use_wchar = false;\n\t\tstate->str1 = VARDATA_ANY(t1);\n\t\tstate->str2 = VARDATA_ANY(t2);\n\t\tstate->len1 = len1;\n\t\tstate->len2 = len2;\n\t}\n\telse\n\t{\n\t\t/* not as simple - multibyte encoding */\n\t\tpg_wchar   *p1,\n\t\t\t\t   *p2;\n\n\t\tp1 = (pg_wchar *) palloc((len1 + 1) * sizeof(pg_wchar));\n\t\tlen1 = pg_mb2wchar_with_len(VARDATA_ANY(t1), p1, len1);\n\t\tp2 = (pg_wchar *) palloc((len2 + 1) * sizeof(pg_wchar));\n\t\tlen2 = pg_mb2wchar_with_len(VARDATA_ANY(t2), p2, len2);\n\n\t\tstate->use_wchar = true;\n\t\tstate->wstr1 = p1;\n\t\tstate->wstr2 = p2;\n\t\tstate->len1 = len1;\n\t\tstate->len2 = len2;\n\t}\n\n\t/*\n\t * Prepare the skip table for Boyer-Moore-Horspool searching.  In these\n\t * notes we use the terminology that the \"haystack\" is the string to be\n\t * searched (t1) and the \"needle\" is the pattern being sought (t2).\n\t *\n\t * If the needle is empty or bigger than the haystack then there is no\n\t * point in wasting cycles initializing the table.  We also choose not to\n\t * use B-M-H for needles of length 1, since the skip table can't possibly\n\t * save anything in that case.\n\t */\n\tif (len1 >= len2 && len2 > 1)\n\t{\n\t\tint\t\t\tsearchlength = len1 - len2;\n\t\tint\t\t\tskiptablemask;\n\t\tint\t\t\tlast;\n\t\tint\t\t\ti;\n\n\t\t/*\n\t\t * First we must determine how much of the skip table to use.  The\n\t\t * declaration of TextPositionState allows up to 256 elements, but for\n\t\t * short search problems we don't really want to have to initialize so\n\t\t * many elements --- it would take too long in comparison to the\n\t\t * actual search time.  So we choose a useful skip table size based on\n\t\t * the haystack length minus the needle length.  The closer the needle\n\t\t * length is to the haystack length the less useful skipping becomes.\n\t\t *\n\t\t * Note: since we use bit-masking to select table elements, the skip\n\t\t * table size MUST be a power of 2, and so the mask must be 2^N-1.\n\t\t */\n\t\tif (searchlength < 16)\n\t\t\tskiptablemask = 3;\n\t\telse if (searchlength < 64)\n\t\t\tskiptablemask = 7;\n\t\telse if (searchlength < 128)\n\t\t\tskiptablemask = 15;\n\t\telse if (searchlength < 512)\n\t\t\tskiptablemask = 31;\n\t\telse if (searchlength < 2048)\n\t\t\tskiptablemask = 63;\n\t\telse if (searchlength < 4096)\n\t\t\tskiptablemask = 127;\n\t\telse\n\t\t\tskiptablemask = 255;\n\t\tstate->skiptablemask = skiptablemask;\n\n\t\t/*\n\t\t * Initialize the skip table.  We set all elements to the needle\n\t\t * length, since this is the correct skip distance for any character\n\t\t * not found in the needle.\n\t\t */\n\t\tfor (i = 0; i <= skiptablemask; i++)\n\t\t\tstate->skiptable[i] = len2;\n\n\t\t/*\n\t\t * Now examine the needle.  For each character except the last one,\n\t\t * set the corresponding table element to the appropriate skip\n\t\t * distance.  Note that when two characters share the same skip table\n\t\t * entry, the one later in the needle must determine the skip\n\t\t * distance.\n\t\t */\n\t\tlast = len2 - 1;\n\n\t\tif (!state->use_wchar)\n\t\t{\n\t\t\tconst char *str2 = state->str2;\n\n\t\t\tfor (i = 0; i < last; i++)\n\t\t\t\tstate->skiptable[(unsigned char) str2[i] & skiptablemask] = last - i;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconst pg_wchar *wstr2 = state->wstr2;\n\n\t\t\tfor (i = 0; i < last; i++)\n\t\t\t\tstate->skiptable[wstr2[i] & skiptablemask] = last - i;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static text *text_catenate(text *t1, text *t2);",
      "static int\ttext_position(text *t1, text *t2);",
      "static void text_position_setup(text *t1, text *t2, TextPositionState *state);",
      "static int\ttext_position_next(int start_pos, TextPositionState *state);",
      "static void text_position_cleanup(TextPositionState *state);",
      "static bytea *bytea_catenate(bytea *t1, bytea *t2);",
      "static void appendStringInfoText(StringInfo str, const text *t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pg_mb2wchar_with_len",
          "args": [
            "VARDATA_ANY(t2)",
            "p2",
            "len2"
          ],
          "line": 1141
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mb2wchar_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "722-726",
          "snippet": "int\npg_mb2wchar_with_len(const char *from, pg_wchar *to, int len)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mb2wchar_with_len((const unsigned char *) from, to, len);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nint\npg_mb2wchar_with_len(const char *from, pg_wchar *to, int len)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mb2wchar_with_len((const unsigned char *) from, to, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "t2"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "(len2 + 1) * sizeof(pg_wchar)"
          ],
          "line": 1140
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "t1"
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "t2"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "t1"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_database_encoding_max_length",
          "args": [],
          "line": 1123
        },
        "resolved": true,
        "details": {
          "function_name": "pg_database_encoding_max_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "1832-1836",
          "snippet": "int\npg_database_encoding_max_length(void)\n{\n\treturn pg_wchar_table[GetDatabaseEncoding()].maxmblen;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nconst pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};\n\nint\npg_database_encoding_max_length(void)\n{\n\treturn pg_wchar_table[GetDatabaseEncoding()].maxmblen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "t2"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "t1"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic text *text_catenate(text *t1, text *t2);\nstatic int\ttext_position(text *t1, text *t2);\nstatic void text_position_setup(text *t1, text *t2, TextPositionState *state);\nstatic int\ttext_position_next(int start_pos, TextPositionState *state);\nstatic void text_position_cleanup(TextPositionState *state);\nstatic bytea *bytea_catenate(bytea *t1, bytea *t2);\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nstatic void\ntext_position_setup(text *t1, text *t2, TextPositionState *state)\n{\n\tint\t\t\tlen1 = VARSIZE_ANY_EXHDR(t1);\n\tint\t\t\tlen2 = VARSIZE_ANY_EXHDR(t2);\n\n\tif (pg_database_encoding_max_length() == 1)\n\t{\n\t\t/* simple case - single byte encoding */\n\t\tstate->use_wchar = false;\n\t\tstate->str1 = VARDATA_ANY(t1);\n\t\tstate->str2 = VARDATA_ANY(t2);\n\t\tstate->len1 = len1;\n\t\tstate->len2 = len2;\n\t}\n\telse\n\t{\n\t\t/* not as simple - multibyte encoding */\n\t\tpg_wchar   *p1,\n\t\t\t\t   *p2;\n\n\t\tp1 = (pg_wchar *) palloc((len1 + 1) * sizeof(pg_wchar));\n\t\tlen1 = pg_mb2wchar_with_len(VARDATA_ANY(t1), p1, len1);\n\t\tp2 = (pg_wchar *) palloc((len2 + 1) * sizeof(pg_wchar));\n\t\tlen2 = pg_mb2wchar_with_len(VARDATA_ANY(t2), p2, len2);\n\n\t\tstate->use_wchar = true;\n\t\tstate->wstr1 = p1;\n\t\tstate->wstr2 = p2;\n\t\tstate->len1 = len1;\n\t\tstate->len2 = len2;\n\t}\n\n\t/*\n\t * Prepare the skip table for Boyer-Moore-Horspool searching.  In these\n\t * notes we use the terminology that the \"haystack\" is the string to be\n\t * searched (t1) and the \"needle\" is the pattern being sought (t2).\n\t *\n\t * If the needle is empty or bigger than the haystack then there is no\n\t * point in wasting cycles initializing the table.  We also choose not to\n\t * use B-M-H for needles of length 1, since the skip table can't possibly\n\t * save anything in that case.\n\t */\n\tif (len1 >= len2 && len2 > 1)\n\t{\n\t\tint\t\t\tsearchlength = len1 - len2;\n\t\tint\t\t\tskiptablemask;\n\t\tint\t\t\tlast;\n\t\tint\t\t\ti;\n\n\t\t/*\n\t\t * First we must determine how much of the skip table to use.  The\n\t\t * declaration of TextPositionState allows up to 256 elements, but for\n\t\t * short search problems we don't really want to have to initialize so\n\t\t * many elements --- it would take too long in comparison to the\n\t\t * actual search time.  So we choose a useful skip table size based on\n\t\t * the haystack length minus the needle length.  The closer the needle\n\t\t * length is to the haystack length the less useful skipping becomes.\n\t\t *\n\t\t * Note: since we use bit-masking to select table elements, the skip\n\t\t * table size MUST be a power of 2, and so the mask must be 2^N-1.\n\t\t */\n\t\tif (searchlength < 16)\n\t\t\tskiptablemask = 3;\n\t\telse if (searchlength < 64)\n\t\t\tskiptablemask = 7;\n\t\telse if (searchlength < 128)\n\t\t\tskiptablemask = 15;\n\t\telse if (searchlength < 512)\n\t\t\tskiptablemask = 31;\n\t\telse if (searchlength < 2048)\n\t\t\tskiptablemask = 63;\n\t\telse if (searchlength < 4096)\n\t\t\tskiptablemask = 127;\n\t\telse\n\t\t\tskiptablemask = 255;\n\t\tstate->skiptablemask = skiptablemask;\n\n\t\t/*\n\t\t * Initialize the skip table.  We set all elements to the needle\n\t\t * length, since this is the correct skip distance for any character\n\t\t * not found in the needle.\n\t\t */\n\t\tfor (i = 0; i <= skiptablemask; i++)\n\t\t\tstate->skiptable[i] = len2;\n\n\t\t/*\n\t\t * Now examine the needle.  For each character except the last one,\n\t\t * set the corresponding table element to the appropriate skip\n\t\t * distance.  Note that when two characters share the same skip table\n\t\t * entry, the one later in the needle must determine the skip\n\t\t * distance.\n\t\t */\n\t\tlast = len2 - 1;\n\n\t\tif (!state->use_wchar)\n\t\t{\n\t\t\tconst char *str2 = state->str2;\n\n\t\t\tfor (i = 0; i < last; i++)\n\t\t\t\tstate->skiptable[(unsigned char) str2[i] & skiptablemask] = last - i;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconst pg_wchar *wstr2 = state->wstr2;\n\n\t\t\tfor (i = 0; i < last; i++)\n\t\t\t\tstate->skiptable[wstr2[i] & skiptablemask] = last - i;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "text_position",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "1093-1103",
    "snippet": "static int\ntext_position(text *t1, text *t2)\n{\n\tTextPositionState state;\n\tint\t\t\tresult;\n\n\ttext_position_setup(t1, t2, &state);\n\tresult = text_position_next(1, &state);\n\ttext_position_cleanup(&state);\n\treturn result;\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static text *text_catenate(text *t1, text *t2);",
      "static int\ttext_position(text *t1, text *t2);",
      "static void text_position_setup(text *t1, text *t2, TextPositionState *state);",
      "static int\ttext_position_next(int start_pos, TextPositionState *state);",
      "static void text_position_cleanup(TextPositionState *state);",
      "static bytea *bytea_catenate(bytea *t1, bytea *t2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "text_position_cleanup",
          "args": [
            "&state"
          ],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "text_position_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "1363-1371",
          "snippet": "static void\ntext_position_cleanup(TextPositionState *state)\n{\n\tif (state->use_wchar)\n\t{\n\t\tpfree(state->wstr1);\n\t\tpfree(state->wstr2);\n\t}\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void text_position_setup(text *t1, text *t2, TextPositionState *state);",
            "static int\ttext_position_next(int start_pos, TextPositionState *state);",
            "static void text_position_cleanup(TextPositionState *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void text_position_setup(text *t1, text *t2, TextPositionState *state);\nstatic int\ttext_position_next(int start_pos, TextPositionState *state);\nstatic void text_position_cleanup(TextPositionState *state);\n\nstatic void\ntext_position_cleanup(TextPositionState *state)\n{\n\tif (state->use_wchar)\n\t{\n\t\tpfree(state->wstr1);\n\t\tpfree(state->wstr2);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "text_position_next",
          "args": [
            "1",
            "&state"
          ],
          "line": 1100
        },
        "resolved": true,
        "details": {
          "function_name": "text_position_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "1229-1361",
          "snippet": "static int\ntext_position_next(int start_pos, TextPositionState *state)\n{\n\tint\t\t\thaystack_len = state->len1;\n\tint\t\t\tneedle_len = state->len2;\n\tint\t\t\tskiptablemask = state->skiptablemask;\n\n\tAssert(start_pos > 0);\t\t/* else caller error */\n\n\tif (needle_len <= 0)\n\t\treturn start_pos;\t\t/* result for empty pattern */\n\n\tstart_pos--;\t\t\t\t/* adjust for zero based arrays */\n\n\t/* Done if the needle can't possibly fit */\n\tif (haystack_len < start_pos + needle_len)\n\t\treturn 0;\n\n\tif (!state->use_wchar)\n\t{\n\t\t/* simple case - single byte encoding */\n\t\tconst char *haystack = state->str1;\n\t\tconst char *needle = state->str2;\n\t\tconst char *haystack_end = &haystack[haystack_len];\n\t\tconst char *hptr;\n\n\t\tif (needle_len == 1)\n\t\t{\n\t\t\t/* No point in using B-M-H for a one-character needle */\n\t\t\tchar\t\tnchar = *needle;\n\n\t\t\thptr = &haystack[start_pos];\n\t\t\twhile (hptr < haystack_end)\n\t\t\t{\n\t\t\t\tif (*hptr == nchar)\n\t\t\t\t\treturn hptr - haystack + 1;\n\t\t\t\thptr++;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconst char *needle_last = &needle[needle_len - 1];\n\n\t\t\t/* Start at startpos plus the length of the needle */\n\t\t\thptr = &haystack[start_pos + needle_len - 1];\n\t\t\twhile (hptr < haystack_end)\n\t\t\t{\n\t\t\t\t/* Match the needle scanning *backward* */\n\t\t\t\tconst char *nptr;\n\t\t\t\tconst char *p;\n\n\t\t\t\tnptr = needle_last;\n\t\t\t\tp = hptr;\n\t\t\t\twhile (*nptr == *p)\n\t\t\t\t{\n\t\t\t\t\t/* Matched it all?\tIf so, return 1-based position */\n\t\t\t\t\tif (nptr == needle)\n\t\t\t\t\t\treturn p - haystack + 1;\n\t\t\t\t\tnptr--, p--;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * No match, so use the haystack char at hptr to decide how\n\t\t\t\t * far to advance.  If the needle had any occurrence of that\n\t\t\t\t * character (or more precisely, one sharing the same\n\t\t\t\t * skiptable entry) before its last character, then we advance\n\t\t\t\t * far enough to align the last such needle character with\n\t\t\t\t * that haystack position.  Otherwise we can advance by the\n\t\t\t\t * whole needle length.\n\t\t\t\t */\n\t\t\t\thptr += state->skiptable[(unsigned char) *hptr & skiptablemask];\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* The multibyte char version. This works exactly the same way. */\n\t\tconst pg_wchar *haystack = state->wstr1;\n\t\tconst pg_wchar *needle = state->wstr2;\n\t\tconst pg_wchar *haystack_end = &haystack[haystack_len];\n\t\tconst pg_wchar *hptr;\n\n\t\tif (needle_len == 1)\n\t\t{\n\t\t\t/* No point in using B-M-H for a one-character needle */\n\t\t\tpg_wchar\tnchar = *needle;\n\n\t\t\thptr = &haystack[start_pos];\n\t\t\twhile (hptr < haystack_end)\n\t\t\t{\n\t\t\t\tif (*hptr == nchar)\n\t\t\t\t\treturn hptr - haystack + 1;\n\t\t\t\thptr++;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconst pg_wchar *needle_last = &needle[needle_len - 1];\n\n\t\t\t/* Start at startpos plus the length of the needle */\n\t\t\thptr = &haystack[start_pos + needle_len - 1];\n\t\t\twhile (hptr < haystack_end)\n\t\t\t{\n\t\t\t\t/* Match the needle scanning *backward* */\n\t\t\t\tconst pg_wchar *nptr;\n\t\t\t\tconst pg_wchar *p;\n\n\t\t\t\tnptr = needle_last;\n\t\t\t\tp = hptr;\n\t\t\t\twhile (*nptr == *p)\n\t\t\t\t{\n\t\t\t\t\t/* Matched it all?\tIf so, return 1-based position */\n\t\t\t\t\tif (nptr == needle)\n\t\t\t\t\t\treturn p - haystack + 1;\n\t\t\t\t\tnptr--, p--;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * No match, so use the haystack char at hptr to decide how\n\t\t\t\t * far to advance.  If the needle had any occurrence of that\n\t\t\t\t * character (or more precisely, one sharing the same\n\t\t\t\t * skiptable entry) before its last character, then we advance\n\t\t\t\t * far enough to align the last such needle character with\n\t\t\t\t * that haystack position.  Otherwise we can advance by the\n\t\t\t\t * whole needle length.\n\t\t\t\t */\n\t\t\t\thptr += state->skiptable[*hptr & skiptablemask];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\t\t\t\t\t/* not found */\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void text_position_setup(text *t1, text *t2, TextPositionState *state);",
            "static int\ttext_position_next(int start_pos, TextPositionState *state);",
            "static void text_position_cleanup(TextPositionState *state);",
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void text_position_setup(text *t1, text *t2, TextPositionState *state);\nstatic int\ttext_position_next(int start_pos, TextPositionState *state);\nstatic void text_position_cleanup(TextPositionState *state);\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nstatic int\ntext_position_next(int start_pos, TextPositionState *state)\n{\n\tint\t\t\thaystack_len = state->len1;\n\tint\t\t\tneedle_len = state->len2;\n\tint\t\t\tskiptablemask = state->skiptablemask;\n\n\tAssert(start_pos > 0);\t\t/* else caller error */\n\n\tif (needle_len <= 0)\n\t\treturn start_pos;\t\t/* result for empty pattern */\n\n\tstart_pos--;\t\t\t\t/* adjust for zero based arrays */\n\n\t/* Done if the needle can't possibly fit */\n\tif (haystack_len < start_pos + needle_len)\n\t\treturn 0;\n\n\tif (!state->use_wchar)\n\t{\n\t\t/* simple case - single byte encoding */\n\t\tconst char *haystack = state->str1;\n\t\tconst char *needle = state->str2;\n\t\tconst char *haystack_end = &haystack[haystack_len];\n\t\tconst char *hptr;\n\n\t\tif (needle_len == 1)\n\t\t{\n\t\t\t/* No point in using B-M-H for a one-character needle */\n\t\t\tchar\t\tnchar = *needle;\n\n\t\t\thptr = &haystack[start_pos];\n\t\t\twhile (hptr < haystack_end)\n\t\t\t{\n\t\t\t\tif (*hptr == nchar)\n\t\t\t\t\treturn hptr - haystack + 1;\n\t\t\t\thptr++;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconst char *needle_last = &needle[needle_len - 1];\n\n\t\t\t/* Start at startpos plus the length of the needle */\n\t\t\thptr = &haystack[start_pos + needle_len - 1];\n\t\t\twhile (hptr < haystack_end)\n\t\t\t{\n\t\t\t\t/* Match the needle scanning *backward* */\n\t\t\t\tconst char *nptr;\n\t\t\t\tconst char *p;\n\n\t\t\t\tnptr = needle_last;\n\t\t\t\tp = hptr;\n\t\t\t\twhile (*nptr == *p)\n\t\t\t\t{\n\t\t\t\t\t/* Matched it all?\tIf so, return 1-based position */\n\t\t\t\t\tif (nptr == needle)\n\t\t\t\t\t\treturn p - haystack + 1;\n\t\t\t\t\tnptr--, p--;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * No match, so use the haystack char at hptr to decide how\n\t\t\t\t * far to advance.  If the needle had any occurrence of that\n\t\t\t\t * character (or more precisely, one sharing the same\n\t\t\t\t * skiptable entry) before its last character, then we advance\n\t\t\t\t * far enough to align the last such needle character with\n\t\t\t\t * that haystack position.  Otherwise we can advance by the\n\t\t\t\t * whole needle length.\n\t\t\t\t */\n\t\t\t\thptr += state->skiptable[(unsigned char) *hptr & skiptablemask];\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* The multibyte char version. This works exactly the same way. */\n\t\tconst pg_wchar *haystack = state->wstr1;\n\t\tconst pg_wchar *needle = state->wstr2;\n\t\tconst pg_wchar *haystack_end = &haystack[haystack_len];\n\t\tconst pg_wchar *hptr;\n\n\t\tif (needle_len == 1)\n\t\t{\n\t\t\t/* No point in using B-M-H for a one-character needle */\n\t\t\tpg_wchar\tnchar = *needle;\n\n\t\t\thptr = &haystack[start_pos];\n\t\t\twhile (hptr < haystack_end)\n\t\t\t{\n\t\t\t\tif (*hptr == nchar)\n\t\t\t\t\treturn hptr - haystack + 1;\n\t\t\t\thptr++;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconst pg_wchar *needle_last = &needle[needle_len - 1];\n\n\t\t\t/* Start at startpos plus the length of the needle */\n\t\t\thptr = &haystack[start_pos + needle_len - 1];\n\t\t\twhile (hptr < haystack_end)\n\t\t\t{\n\t\t\t\t/* Match the needle scanning *backward* */\n\t\t\t\tconst pg_wchar *nptr;\n\t\t\t\tconst pg_wchar *p;\n\n\t\t\t\tnptr = needle_last;\n\t\t\t\tp = hptr;\n\t\t\t\twhile (*nptr == *p)\n\t\t\t\t{\n\t\t\t\t\t/* Matched it all?\tIf so, return 1-based position */\n\t\t\t\t\tif (nptr == needle)\n\t\t\t\t\t\treturn p - haystack + 1;\n\t\t\t\t\tnptr--, p--;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * No match, so use the haystack char at hptr to decide how\n\t\t\t\t * far to advance.  If the needle had any occurrence of that\n\t\t\t\t * character (or more precisely, one sharing the same\n\t\t\t\t * skiptable entry) before its last character, then we advance\n\t\t\t\t * far enough to align the last such needle character with\n\t\t\t\t * that haystack position.  Otherwise we can advance by the\n\t\t\t\t * whole needle length.\n\t\t\t\t */\n\t\t\t\thptr += state->skiptable[*hptr & skiptablemask];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\t\t\t\t\t/* not found */\n}"
        }
      },
      {
        "call_info": {
          "callee": "text_position_setup",
          "args": [
            "t1",
            "t2",
            "&state"
          ],
          "line": 1099
        },
        "resolved": true,
        "details": {
          "function_name": "text_position_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "1117-1227",
          "snippet": "static void\ntext_position_setup(text *t1, text *t2, TextPositionState *state)\n{\n\tint\t\t\tlen1 = VARSIZE_ANY_EXHDR(t1);\n\tint\t\t\tlen2 = VARSIZE_ANY_EXHDR(t2);\n\n\tif (pg_database_encoding_max_length() == 1)\n\t{\n\t\t/* simple case - single byte encoding */\n\t\tstate->use_wchar = false;\n\t\tstate->str1 = VARDATA_ANY(t1);\n\t\tstate->str2 = VARDATA_ANY(t2);\n\t\tstate->len1 = len1;\n\t\tstate->len2 = len2;\n\t}\n\telse\n\t{\n\t\t/* not as simple - multibyte encoding */\n\t\tpg_wchar   *p1,\n\t\t\t\t   *p2;\n\n\t\tp1 = (pg_wchar *) palloc((len1 + 1) * sizeof(pg_wchar));\n\t\tlen1 = pg_mb2wchar_with_len(VARDATA_ANY(t1), p1, len1);\n\t\tp2 = (pg_wchar *) palloc((len2 + 1) * sizeof(pg_wchar));\n\t\tlen2 = pg_mb2wchar_with_len(VARDATA_ANY(t2), p2, len2);\n\n\t\tstate->use_wchar = true;\n\t\tstate->wstr1 = p1;\n\t\tstate->wstr2 = p2;\n\t\tstate->len1 = len1;\n\t\tstate->len2 = len2;\n\t}\n\n\t/*\n\t * Prepare the skip table for Boyer-Moore-Horspool searching.  In these\n\t * notes we use the terminology that the \"haystack\" is the string to be\n\t * searched (t1) and the \"needle\" is the pattern being sought (t2).\n\t *\n\t * If the needle is empty or bigger than the haystack then there is no\n\t * point in wasting cycles initializing the table.  We also choose not to\n\t * use B-M-H for needles of length 1, since the skip table can't possibly\n\t * save anything in that case.\n\t */\n\tif (len1 >= len2 && len2 > 1)\n\t{\n\t\tint\t\t\tsearchlength = len1 - len2;\n\t\tint\t\t\tskiptablemask;\n\t\tint\t\t\tlast;\n\t\tint\t\t\ti;\n\n\t\t/*\n\t\t * First we must determine how much of the skip table to use.  The\n\t\t * declaration of TextPositionState allows up to 256 elements, but for\n\t\t * short search problems we don't really want to have to initialize so\n\t\t * many elements --- it would take too long in comparison to the\n\t\t * actual search time.  So we choose a useful skip table size based on\n\t\t * the haystack length minus the needle length.  The closer the needle\n\t\t * length is to the haystack length the less useful skipping becomes.\n\t\t *\n\t\t * Note: since we use bit-masking to select table elements, the skip\n\t\t * table size MUST be a power of 2, and so the mask must be 2^N-1.\n\t\t */\n\t\tif (searchlength < 16)\n\t\t\tskiptablemask = 3;\n\t\telse if (searchlength < 64)\n\t\t\tskiptablemask = 7;\n\t\telse if (searchlength < 128)\n\t\t\tskiptablemask = 15;\n\t\telse if (searchlength < 512)\n\t\t\tskiptablemask = 31;\n\t\telse if (searchlength < 2048)\n\t\t\tskiptablemask = 63;\n\t\telse if (searchlength < 4096)\n\t\t\tskiptablemask = 127;\n\t\telse\n\t\t\tskiptablemask = 255;\n\t\tstate->skiptablemask = skiptablemask;\n\n\t\t/*\n\t\t * Initialize the skip table.  We set all elements to the needle\n\t\t * length, since this is the correct skip distance for any character\n\t\t * not found in the needle.\n\t\t */\n\t\tfor (i = 0; i <= skiptablemask; i++)\n\t\t\tstate->skiptable[i] = len2;\n\n\t\t/*\n\t\t * Now examine the needle.  For each character except the last one,\n\t\t * set the corresponding table element to the appropriate skip\n\t\t * distance.  Note that when two characters share the same skip table\n\t\t * entry, the one later in the needle must determine the skip\n\t\t * distance.\n\t\t */\n\t\tlast = len2 - 1;\n\n\t\tif (!state->use_wchar)\n\t\t{\n\t\t\tconst char *str2 = state->str2;\n\n\t\t\tfor (i = 0; i < last; i++)\n\t\t\t\tstate->skiptable[(unsigned char) str2[i] & skiptablemask] = last - i;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconst pg_wchar *wstr2 = state->wstr2;\n\n\t\t\tfor (i = 0; i < last; i++)\n\t\t\t\tstate->skiptable[wstr2[i] & skiptablemask] = last - i;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static text *text_catenate(text *t1, text *t2);",
            "static int\ttext_position(text *t1, text *t2);",
            "static void text_position_setup(text *t1, text *t2, TextPositionState *state);",
            "static int\ttext_position_next(int start_pos, TextPositionState *state);",
            "static void text_position_cleanup(TextPositionState *state);",
            "static bytea *bytea_catenate(bytea *t1, bytea *t2);",
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic text *text_catenate(text *t1, text *t2);\nstatic int\ttext_position(text *t1, text *t2);\nstatic void text_position_setup(text *t1, text *t2, TextPositionState *state);\nstatic int\ttext_position_next(int start_pos, TextPositionState *state);\nstatic void text_position_cleanup(TextPositionState *state);\nstatic bytea *bytea_catenate(bytea *t1, bytea *t2);\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nstatic void\ntext_position_setup(text *t1, text *t2, TextPositionState *state)\n{\n\tint\t\t\tlen1 = VARSIZE_ANY_EXHDR(t1);\n\tint\t\t\tlen2 = VARSIZE_ANY_EXHDR(t2);\n\n\tif (pg_database_encoding_max_length() == 1)\n\t{\n\t\t/* simple case - single byte encoding */\n\t\tstate->use_wchar = false;\n\t\tstate->str1 = VARDATA_ANY(t1);\n\t\tstate->str2 = VARDATA_ANY(t2);\n\t\tstate->len1 = len1;\n\t\tstate->len2 = len2;\n\t}\n\telse\n\t{\n\t\t/* not as simple - multibyte encoding */\n\t\tpg_wchar   *p1,\n\t\t\t\t   *p2;\n\n\t\tp1 = (pg_wchar *) palloc((len1 + 1) * sizeof(pg_wchar));\n\t\tlen1 = pg_mb2wchar_with_len(VARDATA_ANY(t1), p1, len1);\n\t\tp2 = (pg_wchar *) palloc((len2 + 1) * sizeof(pg_wchar));\n\t\tlen2 = pg_mb2wchar_with_len(VARDATA_ANY(t2), p2, len2);\n\n\t\tstate->use_wchar = true;\n\t\tstate->wstr1 = p1;\n\t\tstate->wstr2 = p2;\n\t\tstate->len1 = len1;\n\t\tstate->len2 = len2;\n\t}\n\n\t/*\n\t * Prepare the skip table for Boyer-Moore-Horspool searching.  In these\n\t * notes we use the terminology that the \"haystack\" is the string to be\n\t * searched (t1) and the \"needle\" is the pattern being sought (t2).\n\t *\n\t * If the needle is empty or bigger than the haystack then there is no\n\t * point in wasting cycles initializing the table.  We also choose not to\n\t * use B-M-H for needles of length 1, since the skip table can't possibly\n\t * save anything in that case.\n\t */\n\tif (len1 >= len2 && len2 > 1)\n\t{\n\t\tint\t\t\tsearchlength = len1 - len2;\n\t\tint\t\t\tskiptablemask;\n\t\tint\t\t\tlast;\n\t\tint\t\t\ti;\n\n\t\t/*\n\t\t * First we must determine how much of the skip table to use.  The\n\t\t * declaration of TextPositionState allows up to 256 elements, but for\n\t\t * short search problems we don't really want to have to initialize so\n\t\t * many elements --- it would take too long in comparison to the\n\t\t * actual search time.  So we choose a useful skip table size based on\n\t\t * the haystack length minus the needle length.  The closer the needle\n\t\t * length is to the haystack length the less useful skipping becomes.\n\t\t *\n\t\t * Note: since we use bit-masking to select table elements, the skip\n\t\t * table size MUST be a power of 2, and so the mask must be 2^N-1.\n\t\t */\n\t\tif (searchlength < 16)\n\t\t\tskiptablemask = 3;\n\t\telse if (searchlength < 64)\n\t\t\tskiptablemask = 7;\n\t\telse if (searchlength < 128)\n\t\t\tskiptablemask = 15;\n\t\telse if (searchlength < 512)\n\t\t\tskiptablemask = 31;\n\t\telse if (searchlength < 2048)\n\t\t\tskiptablemask = 63;\n\t\telse if (searchlength < 4096)\n\t\t\tskiptablemask = 127;\n\t\telse\n\t\t\tskiptablemask = 255;\n\t\tstate->skiptablemask = skiptablemask;\n\n\t\t/*\n\t\t * Initialize the skip table.  We set all elements to the needle\n\t\t * length, since this is the correct skip distance for any character\n\t\t * not found in the needle.\n\t\t */\n\t\tfor (i = 0; i <= skiptablemask; i++)\n\t\t\tstate->skiptable[i] = len2;\n\n\t\t/*\n\t\t * Now examine the needle.  For each character except the last one,\n\t\t * set the corresponding table element to the appropriate skip\n\t\t * distance.  Note that when two characters share the same skip table\n\t\t * entry, the one later in the needle must determine the skip\n\t\t * distance.\n\t\t */\n\t\tlast = len2 - 1;\n\n\t\tif (!state->use_wchar)\n\t\t{\n\t\t\tconst char *str2 = state->str2;\n\n\t\t\tfor (i = 0; i < last; i++)\n\t\t\t\tstate->skiptable[(unsigned char) str2[i] & skiptablemask] = last - i;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconst pg_wchar *wstr2 = state->wstr2;\n\n\t\t\tfor (i = 0; i < last; i++)\n\t\t\t\tstate->skiptable[wstr2[i] & skiptablemask] = last - i;\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic text *text_catenate(text *t1, text *t2);\nstatic int\ttext_position(text *t1, text *t2);\nstatic void text_position_setup(text *t1, text *t2, TextPositionState *state);\nstatic int\ttext_position_next(int start_pos, TextPositionState *state);\nstatic void text_position_cleanup(TextPositionState *state);\nstatic bytea *bytea_catenate(bytea *t1, bytea *t2);\n\nstatic int\ntext_position(text *t1, text *t2)\n{\n\tTextPositionState state;\n\tint\t\t\tresult;\n\n\ttext_position_setup(t1, t2, &state);\n\tresult = text_position_next(1, &state);\n\ttext_position_cleanup(&state);\n\treturn result;\n}"
  },
  {
    "function_name": "textpos",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "1070-1077",
    "snippet": "Datum\ntextpos(PG_FUNCTION_ARGS)\n{\n\ttext\t   *str = PG_GETARG_TEXT_PP(0);\n\ttext\t   *search_str = PG_GETARG_TEXT_PP(1);\n\n\tPG_RETURN_INT32((int32) text_position(str, search_str));\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int32 text_length(Datum str);",
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "(int32) text_position(str, search_str)"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text_position",
          "args": [
            "str",
            "search_str"
          ],
          "line": 1076
        },
        "resolved": true,
        "details": {
          "function_name": "text_position_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "1229-1361",
          "snippet": "static int\ntext_position_next(int start_pos, TextPositionState *state)\n{\n\tint\t\t\thaystack_len = state->len1;\n\tint\t\t\tneedle_len = state->len2;\n\tint\t\t\tskiptablemask = state->skiptablemask;\n\n\tAssert(start_pos > 0);\t\t/* else caller error */\n\n\tif (needle_len <= 0)\n\t\treturn start_pos;\t\t/* result for empty pattern */\n\n\tstart_pos--;\t\t\t\t/* adjust for zero based arrays */\n\n\t/* Done if the needle can't possibly fit */\n\tif (haystack_len < start_pos + needle_len)\n\t\treturn 0;\n\n\tif (!state->use_wchar)\n\t{\n\t\t/* simple case - single byte encoding */\n\t\tconst char *haystack = state->str1;\n\t\tconst char *needle = state->str2;\n\t\tconst char *haystack_end = &haystack[haystack_len];\n\t\tconst char *hptr;\n\n\t\tif (needle_len == 1)\n\t\t{\n\t\t\t/* No point in using B-M-H for a one-character needle */\n\t\t\tchar\t\tnchar = *needle;\n\n\t\t\thptr = &haystack[start_pos];\n\t\t\twhile (hptr < haystack_end)\n\t\t\t{\n\t\t\t\tif (*hptr == nchar)\n\t\t\t\t\treturn hptr - haystack + 1;\n\t\t\t\thptr++;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconst char *needle_last = &needle[needle_len - 1];\n\n\t\t\t/* Start at startpos plus the length of the needle */\n\t\t\thptr = &haystack[start_pos + needle_len - 1];\n\t\t\twhile (hptr < haystack_end)\n\t\t\t{\n\t\t\t\t/* Match the needle scanning *backward* */\n\t\t\t\tconst char *nptr;\n\t\t\t\tconst char *p;\n\n\t\t\t\tnptr = needle_last;\n\t\t\t\tp = hptr;\n\t\t\t\twhile (*nptr == *p)\n\t\t\t\t{\n\t\t\t\t\t/* Matched it all?\tIf so, return 1-based position */\n\t\t\t\t\tif (nptr == needle)\n\t\t\t\t\t\treturn p - haystack + 1;\n\t\t\t\t\tnptr--, p--;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * No match, so use the haystack char at hptr to decide how\n\t\t\t\t * far to advance.  If the needle had any occurrence of that\n\t\t\t\t * character (or more precisely, one sharing the same\n\t\t\t\t * skiptable entry) before its last character, then we advance\n\t\t\t\t * far enough to align the last such needle character with\n\t\t\t\t * that haystack position.  Otherwise we can advance by the\n\t\t\t\t * whole needle length.\n\t\t\t\t */\n\t\t\t\thptr += state->skiptable[(unsigned char) *hptr & skiptablemask];\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* The multibyte char version. This works exactly the same way. */\n\t\tconst pg_wchar *haystack = state->wstr1;\n\t\tconst pg_wchar *needle = state->wstr2;\n\t\tconst pg_wchar *haystack_end = &haystack[haystack_len];\n\t\tconst pg_wchar *hptr;\n\n\t\tif (needle_len == 1)\n\t\t{\n\t\t\t/* No point in using B-M-H for a one-character needle */\n\t\t\tpg_wchar\tnchar = *needle;\n\n\t\t\thptr = &haystack[start_pos];\n\t\t\twhile (hptr < haystack_end)\n\t\t\t{\n\t\t\t\tif (*hptr == nchar)\n\t\t\t\t\treturn hptr - haystack + 1;\n\t\t\t\thptr++;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconst pg_wchar *needle_last = &needle[needle_len - 1];\n\n\t\t\t/* Start at startpos plus the length of the needle */\n\t\t\thptr = &haystack[start_pos + needle_len - 1];\n\t\t\twhile (hptr < haystack_end)\n\t\t\t{\n\t\t\t\t/* Match the needle scanning *backward* */\n\t\t\t\tconst pg_wchar *nptr;\n\t\t\t\tconst pg_wchar *p;\n\n\t\t\t\tnptr = needle_last;\n\t\t\t\tp = hptr;\n\t\t\t\twhile (*nptr == *p)\n\t\t\t\t{\n\t\t\t\t\t/* Matched it all?\tIf so, return 1-based position */\n\t\t\t\t\tif (nptr == needle)\n\t\t\t\t\t\treturn p - haystack + 1;\n\t\t\t\t\tnptr--, p--;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * No match, so use the haystack char at hptr to decide how\n\t\t\t\t * far to advance.  If the needle had any occurrence of that\n\t\t\t\t * character (or more precisely, one sharing the same\n\t\t\t\t * skiptable entry) before its last character, then we advance\n\t\t\t\t * far enough to align the last such needle character with\n\t\t\t\t * that haystack position.  Otherwise we can advance by the\n\t\t\t\t * whole needle length.\n\t\t\t\t */\n\t\t\t\thptr += state->skiptable[*hptr & skiptablemask];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\t\t\t\t\t/* not found */\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void text_position_setup(text *t1, text *t2, TextPositionState *state);",
            "static int\ttext_position_next(int start_pos, TextPositionState *state);",
            "static void text_position_cleanup(TextPositionState *state);",
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void text_position_setup(text *t1, text *t2, TextPositionState *state);\nstatic int\ttext_position_next(int start_pos, TextPositionState *state);\nstatic void text_position_cleanup(TextPositionState *state);\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nstatic int\ntext_position_next(int start_pos, TextPositionState *state)\n{\n\tint\t\t\thaystack_len = state->len1;\n\tint\t\t\tneedle_len = state->len2;\n\tint\t\t\tskiptablemask = state->skiptablemask;\n\n\tAssert(start_pos > 0);\t\t/* else caller error */\n\n\tif (needle_len <= 0)\n\t\treturn start_pos;\t\t/* result for empty pattern */\n\n\tstart_pos--;\t\t\t\t/* adjust for zero based arrays */\n\n\t/* Done if the needle can't possibly fit */\n\tif (haystack_len < start_pos + needle_len)\n\t\treturn 0;\n\n\tif (!state->use_wchar)\n\t{\n\t\t/* simple case - single byte encoding */\n\t\tconst char *haystack = state->str1;\n\t\tconst char *needle = state->str2;\n\t\tconst char *haystack_end = &haystack[haystack_len];\n\t\tconst char *hptr;\n\n\t\tif (needle_len == 1)\n\t\t{\n\t\t\t/* No point in using B-M-H for a one-character needle */\n\t\t\tchar\t\tnchar = *needle;\n\n\t\t\thptr = &haystack[start_pos];\n\t\t\twhile (hptr < haystack_end)\n\t\t\t{\n\t\t\t\tif (*hptr == nchar)\n\t\t\t\t\treturn hptr - haystack + 1;\n\t\t\t\thptr++;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconst char *needle_last = &needle[needle_len - 1];\n\n\t\t\t/* Start at startpos plus the length of the needle */\n\t\t\thptr = &haystack[start_pos + needle_len - 1];\n\t\t\twhile (hptr < haystack_end)\n\t\t\t{\n\t\t\t\t/* Match the needle scanning *backward* */\n\t\t\t\tconst char *nptr;\n\t\t\t\tconst char *p;\n\n\t\t\t\tnptr = needle_last;\n\t\t\t\tp = hptr;\n\t\t\t\twhile (*nptr == *p)\n\t\t\t\t{\n\t\t\t\t\t/* Matched it all?\tIf so, return 1-based position */\n\t\t\t\t\tif (nptr == needle)\n\t\t\t\t\t\treturn p - haystack + 1;\n\t\t\t\t\tnptr--, p--;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * No match, so use the haystack char at hptr to decide how\n\t\t\t\t * far to advance.  If the needle had any occurrence of that\n\t\t\t\t * character (or more precisely, one sharing the same\n\t\t\t\t * skiptable entry) before its last character, then we advance\n\t\t\t\t * far enough to align the last such needle character with\n\t\t\t\t * that haystack position.  Otherwise we can advance by the\n\t\t\t\t * whole needle length.\n\t\t\t\t */\n\t\t\t\thptr += state->skiptable[(unsigned char) *hptr & skiptablemask];\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* The multibyte char version. This works exactly the same way. */\n\t\tconst pg_wchar *haystack = state->wstr1;\n\t\tconst pg_wchar *needle = state->wstr2;\n\t\tconst pg_wchar *haystack_end = &haystack[haystack_len];\n\t\tconst pg_wchar *hptr;\n\n\t\tif (needle_len == 1)\n\t\t{\n\t\t\t/* No point in using B-M-H for a one-character needle */\n\t\t\tpg_wchar\tnchar = *needle;\n\n\t\t\thptr = &haystack[start_pos];\n\t\t\twhile (hptr < haystack_end)\n\t\t\t{\n\t\t\t\tif (*hptr == nchar)\n\t\t\t\t\treturn hptr - haystack + 1;\n\t\t\t\thptr++;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconst pg_wchar *needle_last = &needle[needle_len - 1];\n\n\t\t\t/* Start at startpos plus the length of the needle */\n\t\t\thptr = &haystack[start_pos + needle_len - 1];\n\t\t\twhile (hptr < haystack_end)\n\t\t\t{\n\t\t\t\t/* Match the needle scanning *backward* */\n\t\t\t\tconst pg_wchar *nptr;\n\t\t\t\tconst pg_wchar *p;\n\n\t\t\t\tnptr = needle_last;\n\t\t\t\tp = hptr;\n\t\t\t\twhile (*nptr == *p)\n\t\t\t\t{\n\t\t\t\t\t/* Matched it all?\tIf so, return 1-based position */\n\t\t\t\t\tif (nptr == needle)\n\t\t\t\t\t\treturn p - haystack + 1;\n\t\t\t\t\tnptr--, p--;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * No match, so use the haystack char at hptr to decide how\n\t\t\t\t * far to advance.  If the needle had any occurrence of that\n\t\t\t\t * character (or more precisely, one sharing the same\n\t\t\t\t * skiptable entry) before its last character, then we advance\n\t\t\t\t * far enough to align the last such needle character with\n\t\t\t\t * that haystack position.  Otherwise we can advance by the\n\t\t\t\t * whole needle length.\n\t\t\t\t */\n\t\t\t\thptr += state->skiptable[*hptr & skiptablemask];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\t\t\t\t\t/* not found */\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int32 text_length(Datum str);\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\n\nDatum\ntextpos(PG_FUNCTION_ARGS)\n{\n\ttext\t   *str = PG_GETARG_TEXT_PP(0);\n\ttext\t   *search_str = PG_GETARG_TEXT_PP(1);\n\n\tPG_RETURN_INT32((int32) text_position(str, search_str));\n}"
  },
  {
    "function_name": "text_overlay",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "1033-1061",
    "snippet": "static text *\ntext_overlay(text *t1, text *t2, int sp, int sl)\n{\n\ttext\t   *result;\n\ttext\t   *s1;\n\ttext\t   *s2;\n\tint\t\t\tsp_pl_sl;\n\n\t/*\n\t * Check for possible integer-overflow cases.  For negative sp, throw a\n\t * \"substring length\" error because that's what should be expected\n\t * according to the spec's definition of OVERLAY().\n\t */\n\tif (sp <= 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_SUBSTRING_ERROR),\n\t\t\t\t errmsg(\"negative substring length not allowed\")));\n\tif (pg_add_s32_overflow(sp, sl, &sp_pl_sl))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"integer out of range\")));\n\n\ts1 = text_substring(PointerGetDatum(t1), 1, sp - 1, false);\n\ts2 = text_substring(PointerGetDatum(t1), sp_pl_sl, -1, true);\n\tresult = text_catenate(s1, t2);\n\tresult = text_catenate(result, s2);\n\n\treturn result;\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static text *text_catenate(text *t1, text *t2);",
      "static text *text_overlay(text *t1, text *t2, int sp, int sl);",
      "static int\ttext_position(text *t1, text *t2);",
      "static bytea *bytea_catenate(bytea *t1, bytea *t2);",
      "static bytea *bytea_overlay(bytea *t1, bytea *t2, int sp, int sl);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "text_catenate",
          "args": [
            "result",
            "s2"
          ],
          "line": 1058
        },
        "resolved": true,
        "details": {
          "function_name": "text_catenate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "693-725",
          "snippet": "static text *\ntext_catenate(text *t1, text *t2)\n{\n\ttext\t   *result;\n\tint\t\t\tlen1,\n\t\t\t\tlen2,\n\t\t\t\tlen;\n\tchar\t   *ptr;\n\n\tlen1 = VARSIZE_ANY_EXHDR(t1);\n\tlen2 = VARSIZE_ANY_EXHDR(t2);\n\n\t/* paranoia ... probably should throw error instead? */\n\tif (len1 < 0)\n\t\tlen1 = 0;\n\tif (len2 < 0)\n\t\tlen2 = 0;\n\n\tlen = len1 + len2 + VARHDRSZ;\n\tresult = (text *) palloc(len);\n\n\t/* Set size of result string... */\n\tSET_VARSIZE(result, len);\n\n\t/* Fill data field of result string... */\n\tptr = VARDATA(result);\n\tif (len1 > 0)\n\t\tmemcpy(ptr, VARDATA_ANY(t1), len1);\n\tif (len2 > 0)\n\t\tmemcpy(ptr + len1, VARDATA_ANY(t2), len2);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static text *text_catenate(text *t1, text *t2);",
            "static int\ttext_position(text *t1, text *t2);",
            "static bytea *bytea_catenate(bytea *t1, bytea *t2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic text *text_catenate(text *t1, text *t2);\nstatic int\ttext_position(text *t1, text *t2);\nstatic bytea *bytea_catenate(bytea *t1, bytea *t2);\n\nstatic text *\ntext_catenate(text *t1, text *t2)\n{\n\ttext\t   *result;\n\tint\t\t\tlen1,\n\t\t\t\tlen2,\n\t\t\t\tlen;\n\tchar\t   *ptr;\n\n\tlen1 = VARSIZE_ANY_EXHDR(t1);\n\tlen2 = VARSIZE_ANY_EXHDR(t2);\n\n\t/* paranoia ... probably should throw error instead? */\n\tif (len1 < 0)\n\t\tlen1 = 0;\n\tif (len2 < 0)\n\t\tlen2 = 0;\n\n\tlen = len1 + len2 + VARHDRSZ;\n\tresult = (text *) palloc(len);\n\n\t/* Set size of result string... */\n\tSET_VARSIZE(result, len);\n\n\t/* Fill data field of result string... */\n\tptr = VARDATA(result);\n\tif (len1 > 0)\n\t\tmemcpy(ptr, VARDATA_ANY(t1), len1);\n\tif (len2 > 0)\n\t\tmemcpy(ptr + len1, VARDATA_ANY(t2), len2);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "text_substring",
          "args": [
            "PointerGetDatum(t1)",
            "sp_pl_sl",
            "-1",
            "true"
          ],
          "line": 1056
        },
        "resolved": true,
        "details": {
          "function_name": "text_substring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "813-1001",
          "snippet": "static text *\ntext_substring(Datum str, int32 start, int32 length, bool length_not_specified)\n{\n\tint32\t\teml = pg_database_encoding_max_length();\n\tint32\t\tS = start;\t\t/* start position */\n\tint32\t\tS1;\t\t\t\t/* adjusted start position */\n\tint32\t\tL1;\t\t\t\t/* adjusted substring length */\n\n\t/* life is easy if the encoding max length is 1 */\n\tif (eml == 1)\n\t{\n\t\tS1 = Max(S, 1);\n\n\t\tif (length_not_specified)\t/* special case - get length to end of\n\t\t\t\t\t\t\t\t\t * string */\n\t\t\tL1 = -1;\n\t\telse\n\t\t{\n\t\t\t/* end position */\n\t\t\tint\t\t\tE = S + length;\n\n\t\t\t/*\n\t\t\t * A negative value for L is the only way for the end position to\n\t\t\t * be before the start. SQL99 says to throw an error.\n\t\t\t */\n\t\t\tif (E < S)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SUBSTRING_ERROR),\n\t\t\t\t\t\t errmsg(\"negative substring length not allowed\")));\n\n\t\t\t/*\n\t\t\t * A zero or negative value for the end position can happen if the\n\t\t\t * start was negative or one. SQL99 says to return a zero-length\n\t\t\t * string.\n\t\t\t */\n\t\t\tif (E < 1)\n\t\t\t\treturn cstring_to_text(\"\");\n\n\t\t\tL1 = E - S1;\n\t\t}\n\n\t\t/*\n\t\t * If the start position is past the end of the string, SQL99 says to\n\t\t * return a zero-length string -- PG_GETARG_TEXT_P_SLICE() will do\n\t\t * that for us. Convert to zero-based starting position\n\t\t */\n\t\treturn DatumGetTextPSlice(str, S1 - 1, L1);\n\t}\n\telse if (eml > 1)\n\t{\n\t\t/*\n\t\t * When encoding max length is > 1, we can't get LC without\n\t\t * detoasting, so we'll grab a conservatively large slice now and go\n\t\t * back later to do the right thing\n\t\t */\n\t\tint32\t\tslice_start;\n\t\tint32\t\tslice_size;\n\t\tint32\t\tslice_strlen;\n\t\ttext\t   *slice;\n\t\tint32\t\tE1;\n\t\tint32\t\ti;\n\t\tchar\t   *p;\n\t\tchar\t   *s;\n\t\ttext\t   *ret;\n\n\t\t/*\n\t\t * if S is past the end of the string, the tuple toaster will return a\n\t\t * zero-length string to us\n\t\t */\n\t\tS1 = Max(S, 1);\n\n\t\t/*\n\t\t * We need to start at position zero because there is no way to know\n\t\t * in advance which byte offset corresponds to the supplied start\n\t\t * position.\n\t\t */\n\t\tslice_start = 0;\n\n\t\tif (length_not_specified)\t/* special case - get length to end of\n\t\t\t\t\t\t\t\t\t * string */\n\t\t\tslice_size = L1 = -1;\n\t\telse\n\t\t{\n\t\t\tint\t\t\tE = S + length;\n\n\t\t\t/*\n\t\t\t * A negative value for L is the only way for the end position to\n\t\t\t * be before the start. SQL99 says to throw an error.\n\t\t\t */\n\t\t\tif (E < S)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SUBSTRING_ERROR),\n\t\t\t\t\t\t errmsg(\"negative substring length not allowed\")));\n\n\t\t\t/*\n\t\t\t * A zero or negative value for the end position can happen if the\n\t\t\t * start was negative or one. SQL99 says to return a zero-length\n\t\t\t * string.\n\t\t\t */\n\t\t\tif (E < 1)\n\t\t\t\treturn cstring_to_text(\"\");\n\n\t\t\t/*\n\t\t\t * if E is past the end of the string, the tuple toaster will\n\t\t\t * truncate the length for us\n\t\t\t */\n\t\t\tL1 = E - S1;\n\n\t\t\t/*\n\t\t\t * Total slice size in bytes can't be any longer than the start\n\t\t\t * position plus substring length times the encoding max length.\n\t\t\t */\n\t\t\tslice_size = (S1 + L1) * eml;\n\t\t}\n\n\t\t/*\n\t\t * If we're working with an untoasted source, no need to do an extra\n\t\t * copying step.\n\t\t */\n\t\tif (VARATT_IS_COMPRESSED(DatumGetPointer(str)) ||\n\t\t\tVARATT_IS_EXTERNAL(DatumGetPointer(str)))\n\t\t\tslice = DatumGetTextPSlice(str, slice_start, slice_size);\n\t\telse\n\t\t\tslice = (text *) DatumGetPointer(str);\n\n\t\t/* see if we got back an empty string */\n\t\tif (VARSIZE_ANY_EXHDR(slice) == 0)\n\t\t{\n\t\t\tif (slice != (text *) DatumGetPointer(str))\n\t\t\t\tpfree(slice);\n\t\t\treturn cstring_to_text(\"\");\n\t\t}\n\n\t\t/* Now we can get the actual length of the slice in MB characters */\n\t\tslice_strlen = pg_mbstrlen_with_len(VARDATA_ANY(slice),\n\t\t\t\t\t\t\t\t\t\t\tVARSIZE_ANY_EXHDR(slice));\n\n\t\t/*\n\t\t * Check that the start position wasn't > slice_strlen. If so, SQL99\n\t\t * says to return a zero-length string.\n\t\t */\n\t\tif (S1 > slice_strlen)\n\t\t{\n\t\t\tif (slice != (text *) DatumGetPointer(str))\n\t\t\t\tpfree(slice);\n\t\t\treturn cstring_to_text(\"\");\n\t\t}\n\n\t\t/*\n\t\t * Adjust L1 and E1 now that we know the slice string length. Again\n\t\t * remember that S1 is one based, and slice_start is zero based.\n\t\t */\n\t\tif (L1 > -1)\n\t\t\tE1 = Min(S1 + L1, slice_start + 1 + slice_strlen);\n\t\telse\n\t\t\tE1 = slice_start + 1 + slice_strlen;\n\n\t\t/*\n\t\t * Find the start position in the slice; remember S1 is not zero based\n\t\t */\n\t\tp = VARDATA_ANY(slice);\n\t\tfor (i = 0; i < S1 - 1; i++)\n\t\t\tp += pg_mblen(p);\n\n\t\t/* hang onto a pointer to our start position */\n\t\ts = p;\n\n\t\t/*\n\t\t * Count the actual bytes used by the substring of the requested\n\t\t * length.\n\t\t */\n\t\tfor (i = S1; i < E1; i++)\n\t\t\tp += pg_mblen(p);\n\n\t\tret = (text *) palloc(VARHDRSZ + (p - s));\n\t\tSET_VARSIZE(ret, VARHDRSZ + (p - s));\n\t\tmemcpy(VARDATA(ret), s, (p - s));\n\n\t\tif (slice != (text *) DatumGetPointer(str))\n\t\t\tpfree(slice);\n\n\t\treturn ret;\n\t}\n\telse\n\t\telog(ERROR, \"invalid backend encoding: encoding max length < 1\");\n\n\t/* not reached: suppress compiler warning */\n\treturn NULL;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int32 text_length(Datum str);",
            "static text *text_substring(Datum str,\n\t\t\t   int32 start,\n\t\t\t   int32 length,\n\t\t\t   bool length_not_specified);",
            "static bytea *bytea_substring(Datum str,\n\t\t\t\tint S,\n\t\t\t\tint L,\n\t\t\t\tbool length_not_specified);",
            "static void appendStringInfoText(StringInfo str, const text *t);",
            "static bool text_format_parse_digits(const char **ptr, const char *end_ptr,\n\t\t\t\t\t\t int *value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int32 text_length(Datum str);\nstatic text *text_substring(Datum str,\n\t\t\t   int32 start,\n\t\t\t   int32 length,\n\t\t\t   bool length_not_specified);\nstatic bytea *bytea_substring(Datum str,\n\t\t\t\tint S,\n\t\t\t\tint L,\n\t\t\t\tbool length_not_specified);\nstatic void appendStringInfoText(StringInfo str, const text *t);\nstatic bool text_format_parse_digits(const char **ptr, const char *end_ptr,\n\t\t\t\t\t\t int *value);\n\nstatic text *\ntext_substring(Datum str, int32 start, int32 length, bool length_not_specified)\n{\n\tint32\t\teml = pg_database_encoding_max_length();\n\tint32\t\tS = start;\t\t/* start position */\n\tint32\t\tS1;\t\t\t\t/* adjusted start position */\n\tint32\t\tL1;\t\t\t\t/* adjusted substring length */\n\n\t/* life is easy if the encoding max length is 1 */\n\tif (eml == 1)\n\t{\n\t\tS1 = Max(S, 1);\n\n\t\tif (length_not_specified)\t/* special case - get length to end of\n\t\t\t\t\t\t\t\t\t * string */\n\t\t\tL1 = -1;\n\t\telse\n\t\t{\n\t\t\t/* end position */\n\t\t\tint\t\t\tE = S + length;\n\n\t\t\t/*\n\t\t\t * A negative value for L is the only way for the end position to\n\t\t\t * be before the start. SQL99 says to throw an error.\n\t\t\t */\n\t\t\tif (E < S)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SUBSTRING_ERROR),\n\t\t\t\t\t\t errmsg(\"negative substring length not allowed\")));\n\n\t\t\t/*\n\t\t\t * A zero or negative value for the end position can happen if the\n\t\t\t * start was negative or one. SQL99 says to return a zero-length\n\t\t\t * string.\n\t\t\t */\n\t\t\tif (E < 1)\n\t\t\t\treturn cstring_to_text(\"\");\n\n\t\t\tL1 = E - S1;\n\t\t}\n\n\t\t/*\n\t\t * If the start position is past the end of the string, SQL99 says to\n\t\t * return a zero-length string -- PG_GETARG_TEXT_P_SLICE() will do\n\t\t * that for us. Convert to zero-based starting position\n\t\t */\n\t\treturn DatumGetTextPSlice(str, S1 - 1, L1);\n\t}\n\telse if (eml > 1)\n\t{\n\t\t/*\n\t\t * When encoding max length is > 1, we can't get LC without\n\t\t * detoasting, so we'll grab a conservatively large slice now and go\n\t\t * back later to do the right thing\n\t\t */\n\t\tint32\t\tslice_start;\n\t\tint32\t\tslice_size;\n\t\tint32\t\tslice_strlen;\n\t\ttext\t   *slice;\n\t\tint32\t\tE1;\n\t\tint32\t\ti;\n\t\tchar\t   *p;\n\t\tchar\t   *s;\n\t\ttext\t   *ret;\n\n\t\t/*\n\t\t * if S is past the end of the string, the tuple toaster will return a\n\t\t * zero-length string to us\n\t\t */\n\t\tS1 = Max(S, 1);\n\n\t\t/*\n\t\t * We need to start at position zero because there is no way to know\n\t\t * in advance which byte offset corresponds to the supplied start\n\t\t * position.\n\t\t */\n\t\tslice_start = 0;\n\n\t\tif (length_not_specified)\t/* special case - get length to end of\n\t\t\t\t\t\t\t\t\t * string */\n\t\t\tslice_size = L1 = -1;\n\t\telse\n\t\t{\n\t\t\tint\t\t\tE = S + length;\n\n\t\t\t/*\n\t\t\t * A negative value for L is the only way for the end position to\n\t\t\t * be before the start. SQL99 says to throw an error.\n\t\t\t */\n\t\t\tif (E < S)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SUBSTRING_ERROR),\n\t\t\t\t\t\t errmsg(\"negative substring length not allowed\")));\n\n\t\t\t/*\n\t\t\t * A zero or negative value for the end position can happen if the\n\t\t\t * start was negative or one. SQL99 says to return a zero-length\n\t\t\t * string.\n\t\t\t */\n\t\t\tif (E < 1)\n\t\t\t\treturn cstring_to_text(\"\");\n\n\t\t\t/*\n\t\t\t * if E is past the end of the string, the tuple toaster will\n\t\t\t * truncate the length for us\n\t\t\t */\n\t\t\tL1 = E - S1;\n\n\t\t\t/*\n\t\t\t * Total slice size in bytes can't be any longer than the start\n\t\t\t * position plus substring length times the encoding max length.\n\t\t\t */\n\t\t\tslice_size = (S1 + L1) * eml;\n\t\t}\n\n\t\t/*\n\t\t * If we're working with an untoasted source, no need to do an extra\n\t\t * copying step.\n\t\t */\n\t\tif (VARATT_IS_COMPRESSED(DatumGetPointer(str)) ||\n\t\t\tVARATT_IS_EXTERNAL(DatumGetPointer(str)))\n\t\t\tslice = DatumGetTextPSlice(str, slice_start, slice_size);\n\t\telse\n\t\t\tslice = (text *) DatumGetPointer(str);\n\n\t\t/* see if we got back an empty string */\n\t\tif (VARSIZE_ANY_EXHDR(slice) == 0)\n\t\t{\n\t\t\tif (slice != (text *) DatumGetPointer(str))\n\t\t\t\tpfree(slice);\n\t\t\treturn cstring_to_text(\"\");\n\t\t}\n\n\t\t/* Now we can get the actual length of the slice in MB characters */\n\t\tslice_strlen = pg_mbstrlen_with_len(VARDATA_ANY(slice),\n\t\t\t\t\t\t\t\t\t\t\tVARSIZE_ANY_EXHDR(slice));\n\n\t\t/*\n\t\t * Check that the start position wasn't > slice_strlen. If so, SQL99\n\t\t * says to return a zero-length string.\n\t\t */\n\t\tif (S1 > slice_strlen)\n\t\t{\n\t\t\tif (slice != (text *) DatumGetPointer(str))\n\t\t\t\tpfree(slice);\n\t\t\treturn cstring_to_text(\"\");\n\t\t}\n\n\t\t/*\n\t\t * Adjust L1 and E1 now that we know the slice string length. Again\n\t\t * remember that S1 is one based, and slice_start is zero based.\n\t\t */\n\t\tif (L1 > -1)\n\t\t\tE1 = Min(S1 + L1, slice_start + 1 + slice_strlen);\n\t\telse\n\t\t\tE1 = slice_start + 1 + slice_strlen;\n\n\t\t/*\n\t\t * Find the start position in the slice; remember S1 is not zero based\n\t\t */\n\t\tp = VARDATA_ANY(slice);\n\t\tfor (i = 0; i < S1 - 1; i++)\n\t\t\tp += pg_mblen(p);\n\n\t\t/* hang onto a pointer to our start position */\n\t\ts = p;\n\n\t\t/*\n\t\t * Count the actual bytes used by the substring of the requested\n\t\t * length.\n\t\t */\n\t\tfor (i = S1; i < E1; i++)\n\t\t\tp += pg_mblen(p);\n\n\t\tret = (text *) palloc(VARHDRSZ + (p - s));\n\t\tSET_VARSIZE(ret, VARHDRSZ + (p - s));\n\t\tmemcpy(VARDATA(ret), s, (p - s));\n\n\t\tif (slice != (text *) DatumGetPointer(str))\n\t\t\tpfree(slice);\n\n\t\treturn ret;\n\t}\n\telse\n\t\telog(ERROR, \"invalid backend encoding: encoding max length < 1\");\n\n\t/* not reached: suppress compiler warning */\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "t1"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "t1"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"integer out of range\"))"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"integer out of range\""
          ],
          "line": 1053
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE"
          ],
          "line": 1052
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_add_s32_overflow",
          "args": [
            "sp",
            "sl",
            "&sp_pl_sl"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_SUBSTRING_ERROR),\n\t\t\t\t errmsg(\"negative substring length not allowed\"))"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic text *text_catenate(text *t1, text *t2);\nstatic text *text_overlay(text *t1, text *t2, int sp, int sl);\nstatic int\ttext_position(text *t1, text *t2);\nstatic bytea *bytea_catenate(bytea *t1, bytea *t2);\nstatic bytea *bytea_overlay(bytea *t1, bytea *t2, int sp, int sl);\n\nstatic text *\ntext_overlay(text *t1, text *t2, int sp, int sl)\n{\n\ttext\t   *result;\n\ttext\t   *s1;\n\ttext\t   *s2;\n\tint\t\t\tsp_pl_sl;\n\n\t/*\n\t * Check for possible integer-overflow cases.  For negative sp, throw a\n\t * \"substring length\" error because that's what should be expected\n\t * according to the spec's definition of OVERLAY().\n\t */\n\tif (sp <= 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_SUBSTRING_ERROR),\n\t\t\t\t errmsg(\"negative substring length not allowed\")));\n\tif (pg_add_s32_overflow(sp, sl, &sp_pl_sl))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"integer out of range\")));\n\n\ts1 = text_substring(PointerGetDatum(t1), 1, sp - 1, false);\n\ts2 = text_substring(PointerGetDatum(t1), sp_pl_sl, -1, true);\n\tresult = text_catenate(s1, t2);\n\tresult = text_catenate(result, s2);\n\n\treturn result;\n}"
  },
  {
    "function_name": "textoverlay_no_len",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "1021-1031",
    "snippet": "Datum\ntextoverlay_no_len(PG_FUNCTION_ARGS)\n{\n\ttext\t   *t1 = PG_GETARG_TEXT_PP(0);\n\ttext\t   *t2 = PG_GETARG_TEXT_PP(1);\n\tint\t\t\tsp = PG_GETARG_INT32(2);\t/* substring start position */\n\tint\t\t\tsl;\n\n\tsl = text_length(PointerGetDatum(t2));\t/* defaults to length(t2) */\n\tPG_RETURN_TEXT_P(text_overlay(t1, t2, sp, sl));\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static text *text_catenate(text *t1, text *t2);",
      "static text *text_overlay(text *t1, text *t2, int sp, int sl);",
      "static int\ttext_position(text *t1, text *t2);",
      "static bytea *bytea_catenate(bytea *t1, bytea *t2);",
      "static bytea *bytea_overlay(bytea *t1, bytea *t2, int sp, int sl);",
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "text_overlay(t1, t2, sp, sl)"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text_overlay",
          "args": [
            "t1",
            "t2",
            "sp",
            "sl"
          ],
          "line": 1030
        },
        "resolved": true,
        "details": {
          "function_name": "text_overlay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "1033-1061",
          "snippet": "static text *\ntext_overlay(text *t1, text *t2, int sp, int sl)\n{\n\ttext\t   *result;\n\ttext\t   *s1;\n\ttext\t   *s2;\n\tint\t\t\tsp_pl_sl;\n\n\t/*\n\t * Check for possible integer-overflow cases.  For negative sp, throw a\n\t * \"substring length\" error because that's what should be expected\n\t * according to the spec's definition of OVERLAY().\n\t */\n\tif (sp <= 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_SUBSTRING_ERROR),\n\t\t\t\t errmsg(\"negative substring length not allowed\")));\n\tif (pg_add_s32_overflow(sp, sl, &sp_pl_sl))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"integer out of range\")));\n\n\ts1 = text_substring(PointerGetDatum(t1), 1, sp - 1, false);\n\ts2 = text_substring(PointerGetDatum(t1), sp_pl_sl, -1, true);\n\tresult = text_catenate(s1, t2);\n\tresult = text_catenate(result, s2);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static text *text_catenate(text *t1, text *t2);",
            "static text *text_overlay(text *t1, text *t2, int sp, int sl);",
            "static int\ttext_position(text *t1, text *t2);",
            "static bytea *bytea_catenate(bytea *t1, bytea *t2);",
            "static bytea *bytea_overlay(bytea *t1, bytea *t2, int sp, int sl);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic text *text_catenate(text *t1, text *t2);\nstatic text *text_overlay(text *t1, text *t2, int sp, int sl);\nstatic int\ttext_position(text *t1, text *t2);\nstatic bytea *bytea_catenate(bytea *t1, bytea *t2);\nstatic bytea *bytea_overlay(bytea *t1, bytea *t2, int sp, int sl);\n\nstatic text *\ntext_overlay(text *t1, text *t2, int sp, int sl)\n{\n\ttext\t   *result;\n\ttext\t   *s1;\n\ttext\t   *s2;\n\tint\t\t\tsp_pl_sl;\n\n\t/*\n\t * Check for possible integer-overflow cases.  For negative sp, throw a\n\t * \"substring length\" error because that's what should be expected\n\t * according to the spec's definition of OVERLAY().\n\t */\n\tif (sp <= 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_SUBSTRING_ERROR),\n\t\t\t\t errmsg(\"negative substring length not allowed\")));\n\tif (pg_add_s32_overflow(sp, sl, &sp_pl_sl))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"integer out of range\")));\n\n\ts1 = text_substring(PointerGetDatum(t1), 1, sp - 1, false);\n\ts2 = text_substring(PointerGetDatum(t1), sp_pl_sl, -1, true);\n\tresult = text_catenate(s1, t2);\n\tresult = text_catenate(result, s2);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "text_length",
          "args": [
            "PointerGetDatum(t2)"
          ],
          "line": 1029
        },
        "resolved": true,
        "details": {
          "function_name": "text_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "639-652",
          "snippet": "static int32\ntext_length(Datum str)\n{\n\t/* fastpath when max encoding length is one */\n\tif (pg_database_encoding_max_length() == 1)\n\t\tPG_RETURN_INT32(toast_raw_datum_size(str) - VARHDRSZ);\n\telse\n\t{\n\t\ttext\t   *t = DatumGetTextPP(str);\n\n\t\tPG_RETURN_INT32(pg_mbstrlen_with_len(VARDATA_ANY(t),\n\t\t\t\t\t\t\t\t\t\t\t VARSIZE_ANY_EXHDR(t)));\n\t}\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int32 text_length(Datum str);",
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int32 text_length(Datum str);\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nstatic int32\ntext_length(Datum str)\n{\n\t/* fastpath when max encoding length is one */\n\tif (pg_database_encoding_max_length() == 1)\n\t\tPG_RETURN_INT32(toast_raw_datum_size(str) - VARHDRSZ);\n\telse\n\t{\n\t\ttext\t   *t = DatumGetTextPP(str);\n\n\t\tPG_RETURN_INT32(pg_mbstrlen_with_len(VARDATA_ANY(t),\n\t\t\t\t\t\t\t\t\t\t\t VARSIZE_ANY_EXHDR(t)));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "t2"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "2"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic text *text_catenate(text *t1, text *t2);\nstatic text *text_overlay(text *t1, text *t2, int sp, int sl);\nstatic int\ttext_position(text *t1, text *t2);\nstatic bytea *bytea_catenate(bytea *t1, bytea *t2);\nstatic bytea *bytea_overlay(bytea *t1, bytea *t2, int sp, int sl);\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\n\nDatum\ntextoverlay_no_len(PG_FUNCTION_ARGS)\n{\n\ttext\t   *t1 = PG_GETARG_TEXT_PP(0);\n\ttext\t   *t2 = PG_GETARG_TEXT_PP(1);\n\tint\t\t\tsp = PG_GETARG_INT32(2);\t/* substring start position */\n\tint\t\t\tsl;\n\n\tsl = text_length(PointerGetDatum(t2));\t/* defaults to length(t2) */\n\tPG_RETURN_TEXT_P(text_overlay(t1, t2, sp, sl));\n}"
  },
  {
    "function_name": "textoverlay",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "1010-1019",
    "snippet": "Datum\ntextoverlay(PG_FUNCTION_ARGS)\n{\n\ttext\t   *t1 = PG_GETARG_TEXT_PP(0);\n\ttext\t   *t2 = PG_GETARG_TEXT_PP(1);\n\tint\t\t\tsp = PG_GETARG_INT32(2);\t/* substring start position */\n\tint\t\t\tsl = PG_GETARG_INT32(3);\t/* substring length */\n\n\tPG_RETURN_TEXT_P(text_overlay(t1, t2, sp, sl));\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static text *text_catenate(text *t1, text *t2);",
      "static text *text_overlay(text *t1, text *t2, int sp, int sl);",
      "static int\ttext_position(text *t1, text *t2);",
      "static bytea *bytea_catenate(bytea *t1, bytea *t2);",
      "static bytea *bytea_overlay(bytea *t1, bytea *t2, int sp, int sl);",
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "text_overlay(t1, t2, sp, sl)"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text_overlay",
          "args": [
            "t1",
            "t2",
            "sp",
            "sl"
          ],
          "line": 1018
        },
        "resolved": true,
        "details": {
          "function_name": "text_overlay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "1033-1061",
          "snippet": "static text *\ntext_overlay(text *t1, text *t2, int sp, int sl)\n{\n\ttext\t   *result;\n\ttext\t   *s1;\n\ttext\t   *s2;\n\tint\t\t\tsp_pl_sl;\n\n\t/*\n\t * Check for possible integer-overflow cases.  For negative sp, throw a\n\t * \"substring length\" error because that's what should be expected\n\t * according to the spec's definition of OVERLAY().\n\t */\n\tif (sp <= 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_SUBSTRING_ERROR),\n\t\t\t\t errmsg(\"negative substring length not allowed\")));\n\tif (pg_add_s32_overflow(sp, sl, &sp_pl_sl))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"integer out of range\")));\n\n\ts1 = text_substring(PointerGetDatum(t1), 1, sp - 1, false);\n\ts2 = text_substring(PointerGetDatum(t1), sp_pl_sl, -1, true);\n\tresult = text_catenate(s1, t2);\n\tresult = text_catenate(result, s2);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static text *text_catenate(text *t1, text *t2);",
            "static text *text_overlay(text *t1, text *t2, int sp, int sl);",
            "static int\ttext_position(text *t1, text *t2);",
            "static bytea *bytea_catenate(bytea *t1, bytea *t2);",
            "static bytea *bytea_overlay(bytea *t1, bytea *t2, int sp, int sl);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic text *text_catenate(text *t1, text *t2);\nstatic text *text_overlay(text *t1, text *t2, int sp, int sl);\nstatic int\ttext_position(text *t1, text *t2);\nstatic bytea *bytea_catenate(bytea *t1, bytea *t2);\nstatic bytea *bytea_overlay(bytea *t1, bytea *t2, int sp, int sl);\n\nstatic text *\ntext_overlay(text *t1, text *t2, int sp, int sl)\n{\n\ttext\t   *result;\n\ttext\t   *s1;\n\ttext\t   *s2;\n\tint\t\t\tsp_pl_sl;\n\n\t/*\n\t * Check for possible integer-overflow cases.  For negative sp, throw a\n\t * \"substring length\" error because that's what should be expected\n\t * according to the spec's definition of OVERLAY().\n\t */\n\tif (sp <= 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_SUBSTRING_ERROR),\n\t\t\t\t errmsg(\"negative substring length not allowed\")));\n\tif (pg_add_s32_overflow(sp, sl, &sp_pl_sl))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"integer out of range\")));\n\n\ts1 = text_substring(PointerGetDatum(t1), 1, sp - 1, false);\n\ts2 = text_substring(PointerGetDatum(t1), sp_pl_sl, -1, true);\n\tresult = text_catenate(s1, t2);\n\tresult = text_catenate(result, s2);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "3"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "2"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic text *text_catenate(text *t1, text *t2);\nstatic text *text_overlay(text *t1, text *t2, int sp, int sl);\nstatic int\ttext_position(text *t1, text *t2);\nstatic bytea *bytea_catenate(bytea *t1, bytea *t2);\nstatic bytea *bytea_overlay(bytea *t1, bytea *t2, int sp, int sl);\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\n\nDatum\ntextoverlay(PG_FUNCTION_ARGS)\n{\n\ttext\t   *t1 = PG_GETARG_TEXT_PP(0);\n\ttext\t   *t2 = PG_GETARG_TEXT_PP(1);\n\tint\t\t\tsp = PG_GETARG_INT32(2);\t/* substring start position */\n\tint\t\t\tsl = PG_GETARG_INT32(3);\t/* substring length */\n\n\tPG_RETURN_TEXT_P(text_overlay(t1, t2, sp, sl));\n}"
  },
  {
    "function_name": "text_substring",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "813-1001",
    "snippet": "static text *\ntext_substring(Datum str, int32 start, int32 length, bool length_not_specified)\n{\n\tint32\t\teml = pg_database_encoding_max_length();\n\tint32\t\tS = start;\t\t/* start position */\n\tint32\t\tS1;\t\t\t\t/* adjusted start position */\n\tint32\t\tL1;\t\t\t\t/* adjusted substring length */\n\n\t/* life is easy if the encoding max length is 1 */\n\tif (eml == 1)\n\t{\n\t\tS1 = Max(S, 1);\n\n\t\tif (length_not_specified)\t/* special case - get length to end of\n\t\t\t\t\t\t\t\t\t * string */\n\t\t\tL1 = -1;\n\t\telse\n\t\t{\n\t\t\t/* end position */\n\t\t\tint\t\t\tE = S + length;\n\n\t\t\t/*\n\t\t\t * A negative value for L is the only way for the end position to\n\t\t\t * be before the start. SQL99 says to throw an error.\n\t\t\t */\n\t\t\tif (E < S)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SUBSTRING_ERROR),\n\t\t\t\t\t\t errmsg(\"negative substring length not allowed\")));\n\n\t\t\t/*\n\t\t\t * A zero or negative value for the end position can happen if the\n\t\t\t * start was negative or one. SQL99 says to return a zero-length\n\t\t\t * string.\n\t\t\t */\n\t\t\tif (E < 1)\n\t\t\t\treturn cstring_to_text(\"\");\n\n\t\t\tL1 = E - S1;\n\t\t}\n\n\t\t/*\n\t\t * If the start position is past the end of the string, SQL99 says to\n\t\t * return a zero-length string -- PG_GETARG_TEXT_P_SLICE() will do\n\t\t * that for us. Convert to zero-based starting position\n\t\t */\n\t\treturn DatumGetTextPSlice(str, S1 - 1, L1);\n\t}\n\telse if (eml > 1)\n\t{\n\t\t/*\n\t\t * When encoding max length is > 1, we can't get LC without\n\t\t * detoasting, so we'll grab a conservatively large slice now and go\n\t\t * back later to do the right thing\n\t\t */\n\t\tint32\t\tslice_start;\n\t\tint32\t\tslice_size;\n\t\tint32\t\tslice_strlen;\n\t\ttext\t   *slice;\n\t\tint32\t\tE1;\n\t\tint32\t\ti;\n\t\tchar\t   *p;\n\t\tchar\t   *s;\n\t\ttext\t   *ret;\n\n\t\t/*\n\t\t * if S is past the end of the string, the tuple toaster will return a\n\t\t * zero-length string to us\n\t\t */\n\t\tS1 = Max(S, 1);\n\n\t\t/*\n\t\t * We need to start at position zero because there is no way to know\n\t\t * in advance which byte offset corresponds to the supplied start\n\t\t * position.\n\t\t */\n\t\tslice_start = 0;\n\n\t\tif (length_not_specified)\t/* special case - get length to end of\n\t\t\t\t\t\t\t\t\t * string */\n\t\t\tslice_size = L1 = -1;\n\t\telse\n\t\t{\n\t\t\tint\t\t\tE = S + length;\n\n\t\t\t/*\n\t\t\t * A negative value for L is the only way for the end position to\n\t\t\t * be before the start. SQL99 says to throw an error.\n\t\t\t */\n\t\t\tif (E < S)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SUBSTRING_ERROR),\n\t\t\t\t\t\t errmsg(\"negative substring length not allowed\")));\n\n\t\t\t/*\n\t\t\t * A zero or negative value for the end position can happen if the\n\t\t\t * start was negative or one. SQL99 says to return a zero-length\n\t\t\t * string.\n\t\t\t */\n\t\t\tif (E < 1)\n\t\t\t\treturn cstring_to_text(\"\");\n\n\t\t\t/*\n\t\t\t * if E is past the end of the string, the tuple toaster will\n\t\t\t * truncate the length for us\n\t\t\t */\n\t\t\tL1 = E - S1;\n\n\t\t\t/*\n\t\t\t * Total slice size in bytes can't be any longer than the start\n\t\t\t * position plus substring length times the encoding max length.\n\t\t\t */\n\t\t\tslice_size = (S1 + L1) * eml;\n\t\t}\n\n\t\t/*\n\t\t * If we're working with an untoasted source, no need to do an extra\n\t\t * copying step.\n\t\t */\n\t\tif (VARATT_IS_COMPRESSED(DatumGetPointer(str)) ||\n\t\t\tVARATT_IS_EXTERNAL(DatumGetPointer(str)))\n\t\t\tslice = DatumGetTextPSlice(str, slice_start, slice_size);\n\t\telse\n\t\t\tslice = (text *) DatumGetPointer(str);\n\n\t\t/* see if we got back an empty string */\n\t\tif (VARSIZE_ANY_EXHDR(slice) == 0)\n\t\t{\n\t\t\tif (slice != (text *) DatumGetPointer(str))\n\t\t\t\tpfree(slice);\n\t\t\treturn cstring_to_text(\"\");\n\t\t}\n\n\t\t/* Now we can get the actual length of the slice in MB characters */\n\t\tslice_strlen = pg_mbstrlen_with_len(VARDATA_ANY(slice),\n\t\t\t\t\t\t\t\t\t\t\tVARSIZE_ANY_EXHDR(slice));\n\n\t\t/*\n\t\t * Check that the start position wasn't > slice_strlen. If so, SQL99\n\t\t * says to return a zero-length string.\n\t\t */\n\t\tif (S1 > slice_strlen)\n\t\t{\n\t\t\tif (slice != (text *) DatumGetPointer(str))\n\t\t\t\tpfree(slice);\n\t\t\treturn cstring_to_text(\"\");\n\t\t}\n\n\t\t/*\n\t\t * Adjust L1 and E1 now that we know the slice string length. Again\n\t\t * remember that S1 is one based, and slice_start is zero based.\n\t\t */\n\t\tif (L1 > -1)\n\t\t\tE1 = Min(S1 + L1, slice_start + 1 + slice_strlen);\n\t\telse\n\t\t\tE1 = slice_start + 1 + slice_strlen;\n\n\t\t/*\n\t\t * Find the start position in the slice; remember S1 is not zero based\n\t\t */\n\t\tp = VARDATA_ANY(slice);\n\t\tfor (i = 0; i < S1 - 1; i++)\n\t\t\tp += pg_mblen(p);\n\n\t\t/* hang onto a pointer to our start position */\n\t\ts = p;\n\n\t\t/*\n\t\t * Count the actual bytes used by the substring of the requested\n\t\t * length.\n\t\t */\n\t\tfor (i = S1; i < E1; i++)\n\t\t\tp += pg_mblen(p);\n\n\t\tret = (text *) palloc(VARHDRSZ + (p - s));\n\t\tSET_VARSIZE(ret, VARHDRSZ + (p - s));\n\t\tmemcpy(VARDATA(ret), s, (p - s));\n\n\t\tif (slice != (text *) DatumGetPointer(str))\n\t\t\tpfree(slice);\n\n\t\treturn ret;\n\t}\n\telse\n\t\telog(ERROR, \"invalid backend encoding: encoding max length < 1\");\n\n\t/* not reached: suppress compiler warning */\n\treturn NULL;\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int32 text_length(Datum str);",
      "static text *text_substring(Datum str,\n\t\t\t   int32 start,\n\t\t\t   int32 length,\n\t\t\t   bool length_not_specified);",
      "static bytea *bytea_substring(Datum str,\n\t\t\t\tint S,\n\t\t\t\tint L,\n\t\t\t\tbool length_not_specified);",
      "static void appendStringInfoText(StringInfo str, const text *t);",
      "static bool text_format_parse_digits(const char **ptr, const char *end_ptr,\n\t\t\t\t\t\t int *value);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"invalid backend encoding: encoding max length < 1\""
          ],
          "line": 997
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "slice"
          ],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "str"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "VARDATA(ret)",
            "s",
            "(p - s)"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA",
          "args": [
            "ret"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "ret",
            "VARHDRSZ + (p - s)"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "VARHDRSZ + (p - s)"
          ],
          "line": 987
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_mblen",
          "args": [
            "p"
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mblen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "759-763",
          "snippet": "int\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nint\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "slice"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "S1 + L1",
            "slice_start + 1 + slice_strlen"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cstring_to_text",
          "args": [
            "\"\""
          ],
          "line": 958
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "148-152",
          "snippet": "text *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "str"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_mbstrlen_with_len",
          "args": [
            "VARDATA_ANY(slice)",
            "VARSIZE_ANY_EXHDR(slice)"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mbstrlen_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "793-811",
          "snippet": "int\npg_mbstrlen_with_len(const char *mbstr, int limit)\n{\n\tint\t\t\tlen = 0;\n\n\t/* optimization for single byte encoding */\n\tif (pg_database_encoding_max_length() == 1)\n\t\treturn limit;\n\n\twhile (limit > 0 && *mbstr)\n\t{\n\t\tint\t\t\tl = pg_mblen(mbstr);\n\n\t\tlimit -= l;\n\t\tmbstr += l;\n\t\tlen++;\n\t}\n\treturn len;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tcliplen(const char *str, int len, int limit);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic int\tcliplen(const char *str, int len, int limit);\n\nint\npg_mbstrlen_with_len(const char *mbstr, int limit)\n{\n\tint\t\t\tlen = 0;\n\n\t/* optimization for single byte encoding */\n\tif (pg_database_encoding_max_length() == 1)\n\t\treturn limit;\n\n\twhile (limit > 0 && *mbstr)\n\t{\n\t\tint\t\t\tl = pg_mblen(mbstr);\n\n\t\tlimit -= l;\n\t\tmbstr += l;\n\t\tlen++;\n\t}\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "slice"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "slice"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "str"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "slice"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "str"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetTextPSlice",
          "args": [
            "str",
            "slice_start",
            "slice_size"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARATT_IS_EXTERNAL",
          "args": [
            "DatumGetPointer(str)"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "str"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARATT_IS_COMPRESSED",
          "args": [
            "DatumGetPointer(str)"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "str"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_SUBSTRING_ERROR),\n\t\t\t\t\t\t errmsg(\"negative substring length not allowed\"))"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"negative substring length not allowed\""
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_SUBSTRING_ERROR"
          ],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "Max",
          "args": [
            "S",
            "1"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetTextPSlice",
          "args": [
            "str",
            "S1 - 1",
            "L1"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_SUBSTRING_ERROR),\n\t\t\t\t\t\t errmsg(\"negative substring length not allowed\"))"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Max",
          "args": [
            "S",
            "1"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_database_encoding_max_length",
          "args": [],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "pg_database_encoding_max_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "1832-1836",
          "snippet": "int\npg_database_encoding_max_length(void)\n{\n\treturn pg_wchar_table[GetDatabaseEncoding()].maxmblen;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nconst pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};\n\nint\npg_database_encoding_max_length(void)\n{\n\treturn pg_wchar_table[GetDatabaseEncoding()].maxmblen;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int32 text_length(Datum str);\nstatic text *text_substring(Datum str,\n\t\t\t   int32 start,\n\t\t\t   int32 length,\n\t\t\t   bool length_not_specified);\nstatic bytea *bytea_substring(Datum str,\n\t\t\t\tint S,\n\t\t\t\tint L,\n\t\t\t\tbool length_not_specified);\nstatic void appendStringInfoText(StringInfo str, const text *t);\nstatic bool text_format_parse_digits(const char **ptr, const char *end_ptr,\n\t\t\t\t\t\t int *value);\n\nstatic text *\ntext_substring(Datum str, int32 start, int32 length, bool length_not_specified)\n{\n\tint32\t\teml = pg_database_encoding_max_length();\n\tint32\t\tS = start;\t\t/* start position */\n\tint32\t\tS1;\t\t\t\t/* adjusted start position */\n\tint32\t\tL1;\t\t\t\t/* adjusted substring length */\n\n\t/* life is easy if the encoding max length is 1 */\n\tif (eml == 1)\n\t{\n\t\tS1 = Max(S, 1);\n\n\t\tif (length_not_specified)\t/* special case - get length to end of\n\t\t\t\t\t\t\t\t\t * string */\n\t\t\tL1 = -1;\n\t\telse\n\t\t{\n\t\t\t/* end position */\n\t\t\tint\t\t\tE = S + length;\n\n\t\t\t/*\n\t\t\t * A negative value for L is the only way for the end position to\n\t\t\t * be before the start. SQL99 says to throw an error.\n\t\t\t */\n\t\t\tif (E < S)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SUBSTRING_ERROR),\n\t\t\t\t\t\t errmsg(\"negative substring length not allowed\")));\n\n\t\t\t/*\n\t\t\t * A zero or negative value for the end position can happen if the\n\t\t\t * start was negative or one. SQL99 says to return a zero-length\n\t\t\t * string.\n\t\t\t */\n\t\t\tif (E < 1)\n\t\t\t\treturn cstring_to_text(\"\");\n\n\t\t\tL1 = E - S1;\n\t\t}\n\n\t\t/*\n\t\t * If the start position is past the end of the string, SQL99 says to\n\t\t * return a zero-length string -- PG_GETARG_TEXT_P_SLICE() will do\n\t\t * that for us. Convert to zero-based starting position\n\t\t */\n\t\treturn DatumGetTextPSlice(str, S1 - 1, L1);\n\t}\n\telse if (eml > 1)\n\t{\n\t\t/*\n\t\t * When encoding max length is > 1, we can't get LC without\n\t\t * detoasting, so we'll grab a conservatively large slice now and go\n\t\t * back later to do the right thing\n\t\t */\n\t\tint32\t\tslice_start;\n\t\tint32\t\tslice_size;\n\t\tint32\t\tslice_strlen;\n\t\ttext\t   *slice;\n\t\tint32\t\tE1;\n\t\tint32\t\ti;\n\t\tchar\t   *p;\n\t\tchar\t   *s;\n\t\ttext\t   *ret;\n\n\t\t/*\n\t\t * if S is past the end of the string, the tuple toaster will return a\n\t\t * zero-length string to us\n\t\t */\n\t\tS1 = Max(S, 1);\n\n\t\t/*\n\t\t * We need to start at position zero because there is no way to know\n\t\t * in advance which byte offset corresponds to the supplied start\n\t\t * position.\n\t\t */\n\t\tslice_start = 0;\n\n\t\tif (length_not_specified)\t/* special case - get length to end of\n\t\t\t\t\t\t\t\t\t * string */\n\t\t\tslice_size = L1 = -1;\n\t\telse\n\t\t{\n\t\t\tint\t\t\tE = S + length;\n\n\t\t\t/*\n\t\t\t * A negative value for L is the only way for the end position to\n\t\t\t * be before the start. SQL99 says to throw an error.\n\t\t\t */\n\t\t\tif (E < S)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SUBSTRING_ERROR),\n\t\t\t\t\t\t errmsg(\"negative substring length not allowed\")));\n\n\t\t\t/*\n\t\t\t * A zero or negative value for the end position can happen if the\n\t\t\t * start was negative or one. SQL99 says to return a zero-length\n\t\t\t * string.\n\t\t\t */\n\t\t\tif (E < 1)\n\t\t\t\treturn cstring_to_text(\"\");\n\n\t\t\t/*\n\t\t\t * if E is past the end of the string, the tuple toaster will\n\t\t\t * truncate the length for us\n\t\t\t */\n\t\t\tL1 = E - S1;\n\n\t\t\t/*\n\t\t\t * Total slice size in bytes can't be any longer than the start\n\t\t\t * position plus substring length times the encoding max length.\n\t\t\t */\n\t\t\tslice_size = (S1 + L1) * eml;\n\t\t}\n\n\t\t/*\n\t\t * If we're working with an untoasted source, no need to do an extra\n\t\t * copying step.\n\t\t */\n\t\tif (VARATT_IS_COMPRESSED(DatumGetPointer(str)) ||\n\t\t\tVARATT_IS_EXTERNAL(DatumGetPointer(str)))\n\t\t\tslice = DatumGetTextPSlice(str, slice_start, slice_size);\n\t\telse\n\t\t\tslice = (text *) DatumGetPointer(str);\n\n\t\t/* see if we got back an empty string */\n\t\tif (VARSIZE_ANY_EXHDR(slice) == 0)\n\t\t{\n\t\t\tif (slice != (text *) DatumGetPointer(str))\n\t\t\t\tpfree(slice);\n\t\t\treturn cstring_to_text(\"\");\n\t\t}\n\n\t\t/* Now we can get the actual length of the slice in MB characters */\n\t\tslice_strlen = pg_mbstrlen_with_len(VARDATA_ANY(slice),\n\t\t\t\t\t\t\t\t\t\t\tVARSIZE_ANY_EXHDR(slice));\n\n\t\t/*\n\t\t * Check that the start position wasn't > slice_strlen. If so, SQL99\n\t\t * says to return a zero-length string.\n\t\t */\n\t\tif (S1 > slice_strlen)\n\t\t{\n\t\t\tif (slice != (text *) DatumGetPointer(str))\n\t\t\t\tpfree(slice);\n\t\t\treturn cstring_to_text(\"\");\n\t\t}\n\n\t\t/*\n\t\t * Adjust L1 and E1 now that we know the slice string length. Again\n\t\t * remember that S1 is one based, and slice_start is zero based.\n\t\t */\n\t\tif (L1 > -1)\n\t\t\tE1 = Min(S1 + L1, slice_start + 1 + slice_strlen);\n\t\telse\n\t\t\tE1 = slice_start + 1 + slice_strlen;\n\n\t\t/*\n\t\t * Find the start position in the slice; remember S1 is not zero based\n\t\t */\n\t\tp = VARDATA_ANY(slice);\n\t\tfor (i = 0; i < S1 - 1; i++)\n\t\t\tp += pg_mblen(p);\n\n\t\t/* hang onto a pointer to our start position */\n\t\ts = p;\n\n\t\t/*\n\t\t * Count the actual bytes used by the substring of the requested\n\t\t * length.\n\t\t */\n\t\tfor (i = S1; i < E1; i++)\n\t\t\tp += pg_mblen(p);\n\n\t\tret = (text *) palloc(VARHDRSZ + (p - s));\n\t\tSET_VARSIZE(ret, VARHDRSZ + (p - s));\n\t\tmemcpy(VARDATA(ret), s, (p - s));\n\n\t\tif (slice != (text *) DatumGetPointer(str))\n\t\t\tpfree(slice);\n\n\t\treturn ret;\n\t}\n\telse\n\t\telog(ERROR, \"invalid backend encoding: encoding max length < 1\");\n\n\t/* not reached: suppress compiler warning */\n\treturn NULL;\n}"
  },
  {
    "function_name": "text_substr_no_len",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "794-800",
    "snippet": "Datum\ntext_substr_no_len(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_TEXT_P(text_substring(PG_GETARG_DATUM(0),\n\t\t\t\t\t\t\t\t\tPG_GETARG_INT32(1),\n\t\t\t\t\t\t\t\t\t-1, true));\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "text_substring(PG_GETARG_DATUM(0),\n\t\t\t\t\t\t\t\t\tPG_GETARG_INT32(1),\n\t\t\t\t\t\t\t\t\t-1, true)"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text_substring",
          "args": [
            "PG_GETARG_DATUM(0)",
            "PG_GETARG_INT32(1)",
            "-1",
            "true"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "text_substring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "813-1001",
          "snippet": "static text *\ntext_substring(Datum str, int32 start, int32 length, bool length_not_specified)\n{\n\tint32\t\teml = pg_database_encoding_max_length();\n\tint32\t\tS = start;\t\t/* start position */\n\tint32\t\tS1;\t\t\t\t/* adjusted start position */\n\tint32\t\tL1;\t\t\t\t/* adjusted substring length */\n\n\t/* life is easy if the encoding max length is 1 */\n\tif (eml == 1)\n\t{\n\t\tS1 = Max(S, 1);\n\n\t\tif (length_not_specified)\t/* special case - get length to end of\n\t\t\t\t\t\t\t\t\t * string */\n\t\t\tL1 = -1;\n\t\telse\n\t\t{\n\t\t\t/* end position */\n\t\t\tint\t\t\tE = S + length;\n\n\t\t\t/*\n\t\t\t * A negative value for L is the only way for the end position to\n\t\t\t * be before the start. SQL99 says to throw an error.\n\t\t\t */\n\t\t\tif (E < S)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SUBSTRING_ERROR),\n\t\t\t\t\t\t errmsg(\"negative substring length not allowed\")));\n\n\t\t\t/*\n\t\t\t * A zero or negative value for the end position can happen if the\n\t\t\t * start was negative or one. SQL99 says to return a zero-length\n\t\t\t * string.\n\t\t\t */\n\t\t\tif (E < 1)\n\t\t\t\treturn cstring_to_text(\"\");\n\n\t\t\tL1 = E - S1;\n\t\t}\n\n\t\t/*\n\t\t * If the start position is past the end of the string, SQL99 says to\n\t\t * return a zero-length string -- PG_GETARG_TEXT_P_SLICE() will do\n\t\t * that for us. Convert to zero-based starting position\n\t\t */\n\t\treturn DatumGetTextPSlice(str, S1 - 1, L1);\n\t}\n\telse if (eml > 1)\n\t{\n\t\t/*\n\t\t * When encoding max length is > 1, we can't get LC without\n\t\t * detoasting, so we'll grab a conservatively large slice now and go\n\t\t * back later to do the right thing\n\t\t */\n\t\tint32\t\tslice_start;\n\t\tint32\t\tslice_size;\n\t\tint32\t\tslice_strlen;\n\t\ttext\t   *slice;\n\t\tint32\t\tE1;\n\t\tint32\t\ti;\n\t\tchar\t   *p;\n\t\tchar\t   *s;\n\t\ttext\t   *ret;\n\n\t\t/*\n\t\t * if S is past the end of the string, the tuple toaster will return a\n\t\t * zero-length string to us\n\t\t */\n\t\tS1 = Max(S, 1);\n\n\t\t/*\n\t\t * We need to start at position zero because there is no way to know\n\t\t * in advance which byte offset corresponds to the supplied start\n\t\t * position.\n\t\t */\n\t\tslice_start = 0;\n\n\t\tif (length_not_specified)\t/* special case - get length to end of\n\t\t\t\t\t\t\t\t\t * string */\n\t\t\tslice_size = L1 = -1;\n\t\telse\n\t\t{\n\t\t\tint\t\t\tE = S + length;\n\n\t\t\t/*\n\t\t\t * A negative value for L is the only way for the end position to\n\t\t\t * be before the start. SQL99 says to throw an error.\n\t\t\t */\n\t\t\tif (E < S)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SUBSTRING_ERROR),\n\t\t\t\t\t\t errmsg(\"negative substring length not allowed\")));\n\n\t\t\t/*\n\t\t\t * A zero or negative value for the end position can happen if the\n\t\t\t * start was negative or one. SQL99 says to return a zero-length\n\t\t\t * string.\n\t\t\t */\n\t\t\tif (E < 1)\n\t\t\t\treturn cstring_to_text(\"\");\n\n\t\t\t/*\n\t\t\t * if E is past the end of the string, the tuple toaster will\n\t\t\t * truncate the length for us\n\t\t\t */\n\t\t\tL1 = E - S1;\n\n\t\t\t/*\n\t\t\t * Total slice size in bytes can't be any longer than the start\n\t\t\t * position plus substring length times the encoding max length.\n\t\t\t */\n\t\t\tslice_size = (S1 + L1) * eml;\n\t\t}\n\n\t\t/*\n\t\t * If we're working with an untoasted source, no need to do an extra\n\t\t * copying step.\n\t\t */\n\t\tif (VARATT_IS_COMPRESSED(DatumGetPointer(str)) ||\n\t\t\tVARATT_IS_EXTERNAL(DatumGetPointer(str)))\n\t\t\tslice = DatumGetTextPSlice(str, slice_start, slice_size);\n\t\telse\n\t\t\tslice = (text *) DatumGetPointer(str);\n\n\t\t/* see if we got back an empty string */\n\t\tif (VARSIZE_ANY_EXHDR(slice) == 0)\n\t\t{\n\t\t\tif (slice != (text *) DatumGetPointer(str))\n\t\t\t\tpfree(slice);\n\t\t\treturn cstring_to_text(\"\");\n\t\t}\n\n\t\t/* Now we can get the actual length of the slice in MB characters */\n\t\tslice_strlen = pg_mbstrlen_with_len(VARDATA_ANY(slice),\n\t\t\t\t\t\t\t\t\t\t\tVARSIZE_ANY_EXHDR(slice));\n\n\t\t/*\n\t\t * Check that the start position wasn't > slice_strlen. If so, SQL99\n\t\t * says to return a zero-length string.\n\t\t */\n\t\tif (S1 > slice_strlen)\n\t\t{\n\t\t\tif (slice != (text *) DatumGetPointer(str))\n\t\t\t\tpfree(slice);\n\t\t\treturn cstring_to_text(\"\");\n\t\t}\n\n\t\t/*\n\t\t * Adjust L1 and E1 now that we know the slice string length. Again\n\t\t * remember that S1 is one based, and slice_start is zero based.\n\t\t */\n\t\tif (L1 > -1)\n\t\t\tE1 = Min(S1 + L1, slice_start + 1 + slice_strlen);\n\t\telse\n\t\t\tE1 = slice_start + 1 + slice_strlen;\n\n\t\t/*\n\t\t * Find the start position in the slice; remember S1 is not zero based\n\t\t */\n\t\tp = VARDATA_ANY(slice);\n\t\tfor (i = 0; i < S1 - 1; i++)\n\t\t\tp += pg_mblen(p);\n\n\t\t/* hang onto a pointer to our start position */\n\t\ts = p;\n\n\t\t/*\n\t\t * Count the actual bytes used by the substring of the requested\n\t\t * length.\n\t\t */\n\t\tfor (i = S1; i < E1; i++)\n\t\t\tp += pg_mblen(p);\n\n\t\tret = (text *) palloc(VARHDRSZ + (p - s));\n\t\tSET_VARSIZE(ret, VARHDRSZ + (p - s));\n\t\tmemcpy(VARDATA(ret), s, (p - s));\n\n\t\tif (slice != (text *) DatumGetPointer(str))\n\t\t\tpfree(slice);\n\n\t\treturn ret;\n\t}\n\telse\n\t\telog(ERROR, \"invalid backend encoding: encoding max length < 1\");\n\n\t/* not reached: suppress compiler warning */\n\treturn NULL;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int32 text_length(Datum str);",
            "static text *text_substring(Datum str,\n\t\t\t   int32 start,\n\t\t\t   int32 length,\n\t\t\t   bool length_not_specified);",
            "static bytea *bytea_substring(Datum str,\n\t\t\t\tint S,\n\t\t\t\tint L,\n\t\t\t\tbool length_not_specified);",
            "static void appendStringInfoText(StringInfo str, const text *t);",
            "static bool text_format_parse_digits(const char **ptr, const char *end_ptr,\n\t\t\t\t\t\t int *value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int32 text_length(Datum str);\nstatic text *text_substring(Datum str,\n\t\t\t   int32 start,\n\t\t\t   int32 length,\n\t\t\t   bool length_not_specified);\nstatic bytea *bytea_substring(Datum str,\n\t\t\t\tint S,\n\t\t\t\tint L,\n\t\t\t\tbool length_not_specified);\nstatic void appendStringInfoText(StringInfo str, const text *t);\nstatic bool text_format_parse_digits(const char **ptr, const char *end_ptr,\n\t\t\t\t\t\t int *value);\n\nstatic text *\ntext_substring(Datum str, int32 start, int32 length, bool length_not_specified)\n{\n\tint32\t\teml = pg_database_encoding_max_length();\n\tint32\t\tS = start;\t\t/* start position */\n\tint32\t\tS1;\t\t\t\t/* adjusted start position */\n\tint32\t\tL1;\t\t\t\t/* adjusted substring length */\n\n\t/* life is easy if the encoding max length is 1 */\n\tif (eml == 1)\n\t{\n\t\tS1 = Max(S, 1);\n\n\t\tif (length_not_specified)\t/* special case - get length to end of\n\t\t\t\t\t\t\t\t\t * string */\n\t\t\tL1 = -1;\n\t\telse\n\t\t{\n\t\t\t/* end position */\n\t\t\tint\t\t\tE = S + length;\n\n\t\t\t/*\n\t\t\t * A negative value for L is the only way for the end position to\n\t\t\t * be before the start. SQL99 says to throw an error.\n\t\t\t */\n\t\t\tif (E < S)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SUBSTRING_ERROR),\n\t\t\t\t\t\t errmsg(\"negative substring length not allowed\")));\n\n\t\t\t/*\n\t\t\t * A zero or negative value for the end position can happen if the\n\t\t\t * start was negative or one. SQL99 says to return a zero-length\n\t\t\t * string.\n\t\t\t */\n\t\t\tif (E < 1)\n\t\t\t\treturn cstring_to_text(\"\");\n\n\t\t\tL1 = E - S1;\n\t\t}\n\n\t\t/*\n\t\t * If the start position is past the end of the string, SQL99 says to\n\t\t * return a zero-length string -- PG_GETARG_TEXT_P_SLICE() will do\n\t\t * that for us. Convert to zero-based starting position\n\t\t */\n\t\treturn DatumGetTextPSlice(str, S1 - 1, L1);\n\t}\n\telse if (eml > 1)\n\t{\n\t\t/*\n\t\t * When encoding max length is > 1, we can't get LC without\n\t\t * detoasting, so we'll grab a conservatively large slice now and go\n\t\t * back later to do the right thing\n\t\t */\n\t\tint32\t\tslice_start;\n\t\tint32\t\tslice_size;\n\t\tint32\t\tslice_strlen;\n\t\ttext\t   *slice;\n\t\tint32\t\tE1;\n\t\tint32\t\ti;\n\t\tchar\t   *p;\n\t\tchar\t   *s;\n\t\ttext\t   *ret;\n\n\t\t/*\n\t\t * if S is past the end of the string, the tuple toaster will return a\n\t\t * zero-length string to us\n\t\t */\n\t\tS1 = Max(S, 1);\n\n\t\t/*\n\t\t * We need to start at position zero because there is no way to know\n\t\t * in advance which byte offset corresponds to the supplied start\n\t\t * position.\n\t\t */\n\t\tslice_start = 0;\n\n\t\tif (length_not_specified)\t/* special case - get length to end of\n\t\t\t\t\t\t\t\t\t * string */\n\t\t\tslice_size = L1 = -1;\n\t\telse\n\t\t{\n\t\t\tint\t\t\tE = S + length;\n\n\t\t\t/*\n\t\t\t * A negative value for L is the only way for the end position to\n\t\t\t * be before the start. SQL99 says to throw an error.\n\t\t\t */\n\t\t\tif (E < S)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SUBSTRING_ERROR),\n\t\t\t\t\t\t errmsg(\"negative substring length not allowed\")));\n\n\t\t\t/*\n\t\t\t * A zero or negative value for the end position can happen if the\n\t\t\t * start was negative or one. SQL99 says to return a zero-length\n\t\t\t * string.\n\t\t\t */\n\t\t\tif (E < 1)\n\t\t\t\treturn cstring_to_text(\"\");\n\n\t\t\t/*\n\t\t\t * if E is past the end of the string, the tuple toaster will\n\t\t\t * truncate the length for us\n\t\t\t */\n\t\t\tL1 = E - S1;\n\n\t\t\t/*\n\t\t\t * Total slice size in bytes can't be any longer than the start\n\t\t\t * position plus substring length times the encoding max length.\n\t\t\t */\n\t\t\tslice_size = (S1 + L1) * eml;\n\t\t}\n\n\t\t/*\n\t\t * If we're working with an untoasted source, no need to do an extra\n\t\t * copying step.\n\t\t */\n\t\tif (VARATT_IS_COMPRESSED(DatumGetPointer(str)) ||\n\t\t\tVARATT_IS_EXTERNAL(DatumGetPointer(str)))\n\t\t\tslice = DatumGetTextPSlice(str, slice_start, slice_size);\n\t\telse\n\t\t\tslice = (text *) DatumGetPointer(str);\n\n\t\t/* see if we got back an empty string */\n\t\tif (VARSIZE_ANY_EXHDR(slice) == 0)\n\t\t{\n\t\t\tif (slice != (text *) DatumGetPointer(str))\n\t\t\t\tpfree(slice);\n\t\t\treturn cstring_to_text(\"\");\n\t\t}\n\n\t\t/* Now we can get the actual length of the slice in MB characters */\n\t\tslice_strlen = pg_mbstrlen_with_len(VARDATA_ANY(slice),\n\t\t\t\t\t\t\t\t\t\t\tVARSIZE_ANY_EXHDR(slice));\n\n\t\t/*\n\t\t * Check that the start position wasn't > slice_strlen. If so, SQL99\n\t\t * says to return a zero-length string.\n\t\t */\n\t\tif (S1 > slice_strlen)\n\t\t{\n\t\t\tif (slice != (text *) DatumGetPointer(str))\n\t\t\t\tpfree(slice);\n\t\t\treturn cstring_to_text(\"\");\n\t\t}\n\n\t\t/*\n\t\t * Adjust L1 and E1 now that we know the slice string length. Again\n\t\t * remember that S1 is one based, and slice_start is zero based.\n\t\t */\n\t\tif (L1 > -1)\n\t\t\tE1 = Min(S1 + L1, slice_start + 1 + slice_strlen);\n\t\telse\n\t\t\tE1 = slice_start + 1 + slice_strlen;\n\n\t\t/*\n\t\t * Find the start position in the slice; remember S1 is not zero based\n\t\t */\n\t\tp = VARDATA_ANY(slice);\n\t\tfor (i = 0; i < S1 - 1; i++)\n\t\t\tp += pg_mblen(p);\n\n\t\t/* hang onto a pointer to our start position */\n\t\ts = p;\n\n\t\t/*\n\t\t * Count the actual bytes used by the substring of the requested\n\t\t * length.\n\t\t */\n\t\tfor (i = S1; i < E1; i++)\n\t\t\tp += pg_mblen(p);\n\n\t\tret = (text *) palloc(VARHDRSZ + (p - s));\n\t\tSET_VARSIZE(ret, VARHDRSZ + (p - s));\n\t\tmemcpy(VARDATA(ret), s, (p - s));\n\n\t\tif (slice != (text *) DatumGetPointer(str))\n\t\t\tpfree(slice);\n\n\t\treturn ret;\n\t}\n\telse\n\t\telog(ERROR, \"invalid backend encoding: encoding max length < 1\");\n\n\t/* not reached: suppress compiler warning */\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "1"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "0"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\n\nDatum\ntext_substr_no_len(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_TEXT_P(text_substring(PG_GETARG_DATUM(0),\n\t\t\t\t\t\t\t\t\tPG_GETARG_INT32(1),\n\t\t\t\t\t\t\t\t\t-1, true));\n}"
  },
  {
    "function_name": "text_substr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "780-787",
    "snippet": "Datum\ntext_substr(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_TEXT_P(text_substring(PG_GETARG_DATUM(0),\n\t\t\t\t\t\t\t\t\tPG_GETARG_INT32(1),\n\t\t\t\t\t\t\t\t\tPG_GETARG_INT32(2),\n\t\t\t\t\t\t\t\t\tfalse));\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "text_substring(PG_GETARG_DATUM(0),\n\t\t\t\t\t\t\t\t\tPG_GETARG_INT32(1),\n\t\t\t\t\t\t\t\t\tPG_GETARG_INT32(2),\n\t\t\t\t\t\t\t\t\tfalse)"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text_substring",
          "args": [
            "PG_GETARG_DATUM(0)",
            "PG_GETARG_INT32(1)",
            "PG_GETARG_INT32(2)",
            "false"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "text_substring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "813-1001",
          "snippet": "static text *\ntext_substring(Datum str, int32 start, int32 length, bool length_not_specified)\n{\n\tint32\t\teml = pg_database_encoding_max_length();\n\tint32\t\tS = start;\t\t/* start position */\n\tint32\t\tS1;\t\t\t\t/* adjusted start position */\n\tint32\t\tL1;\t\t\t\t/* adjusted substring length */\n\n\t/* life is easy if the encoding max length is 1 */\n\tif (eml == 1)\n\t{\n\t\tS1 = Max(S, 1);\n\n\t\tif (length_not_specified)\t/* special case - get length to end of\n\t\t\t\t\t\t\t\t\t * string */\n\t\t\tL1 = -1;\n\t\telse\n\t\t{\n\t\t\t/* end position */\n\t\t\tint\t\t\tE = S + length;\n\n\t\t\t/*\n\t\t\t * A negative value for L is the only way for the end position to\n\t\t\t * be before the start. SQL99 says to throw an error.\n\t\t\t */\n\t\t\tif (E < S)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SUBSTRING_ERROR),\n\t\t\t\t\t\t errmsg(\"negative substring length not allowed\")));\n\n\t\t\t/*\n\t\t\t * A zero or negative value for the end position can happen if the\n\t\t\t * start was negative or one. SQL99 says to return a zero-length\n\t\t\t * string.\n\t\t\t */\n\t\t\tif (E < 1)\n\t\t\t\treturn cstring_to_text(\"\");\n\n\t\t\tL1 = E - S1;\n\t\t}\n\n\t\t/*\n\t\t * If the start position is past the end of the string, SQL99 says to\n\t\t * return a zero-length string -- PG_GETARG_TEXT_P_SLICE() will do\n\t\t * that for us. Convert to zero-based starting position\n\t\t */\n\t\treturn DatumGetTextPSlice(str, S1 - 1, L1);\n\t}\n\telse if (eml > 1)\n\t{\n\t\t/*\n\t\t * When encoding max length is > 1, we can't get LC without\n\t\t * detoasting, so we'll grab a conservatively large slice now and go\n\t\t * back later to do the right thing\n\t\t */\n\t\tint32\t\tslice_start;\n\t\tint32\t\tslice_size;\n\t\tint32\t\tslice_strlen;\n\t\ttext\t   *slice;\n\t\tint32\t\tE1;\n\t\tint32\t\ti;\n\t\tchar\t   *p;\n\t\tchar\t   *s;\n\t\ttext\t   *ret;\n\n\t\t/*\n\t\t * if S is past the end of the string, the tuple toaster will return a\n\t\t * zero-length string to us\n\t\t */\n\t\tS1 = Max(S, 1);\n\n\t\t/*\n\t\t * We need to start at position zero because there is no way to know\n\t\t * in advance which byte offset corresponds to the supplied start\n\t\t * position.\n\t\t */\n\t\tslice_start = 0;\n\n\t\tif (length_not_specified)\t/* special case - get length to end of\n\t\t\t\t\t\t\t\t\t * string */\n\t\t\tslice_size = L1 = -1;\n\t\telse\n\t\t{\n\t\t\tint\t\t\tE = S + length;\n\n\t\t\t/*\n\t\t\t * A negative value for L is the only way for the end position to\n\t\t\t * be before the start. SQL99 says to throw an error.\n\t\t\t */\n\t\t\tif (E < S)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SUBSTRING_ERROR),\n\t\t\t\t\t\t errmsg(\"negative substring length not allowed\")));\n\n\t\t\t/*\n\t\t\t * A zero or negative value for the end position can happen if the\n\t\t\t * start was negative or one. SQL99 says to return a zero-length\n\t\t\t * string.\n\t\t\t */\n\t\t\tif (E < 1)\n\t\t\t\treturn cstring_to_text(\"\");\n\n\t\t\t/*\n\t\t\t * if E is past the end of the string, the tuple toaster will\n\t\t\t * truncate the length for us\n\t\t\t */\n\t\t\tL1 = E - S1;\n\n\t\t\t/*\n\t\t\t * Total slice size in bytes can't be any longer than the start\n\t\t\t * position plus substring length times the encoding max length.\n\t\t\t */\n\t\t\tslice_size = (S1 + L1) * eml;\n\t\t}\n\n\t\t/*\n\t\t * If we're working with an untoasted source, no need to do an extra\n\t\t * copying step.\n\t\t */\n\t\tif (VARATT_IS_COMPRESSED(DatumGetPointer(str)) ||\n\t\t\tVARATT_IS_EXTERNAL(DatumGetPointer(str)))\n\t\t\tslice = DatumGetTextPSlice(str, slice_start, slice_size);\n\t\telse\n\t\t\tslice = (text *) DatumGetPointer(str);\n\n\t\t/* see if we got back an empty string */\n\t\tif (VARSIZE_ANY_EXHDR(slice) == 0)\n\t\t{\n\t\t\tif (slice != (text *) DatumGetPointer(str))\n\t\t\t\tpfree(slice);\n\t\t\treturn cstring_to_text(\"\");\n\t\t}\n\n\t\t/* Now we can get the actual length of the slice in MB characters */\n\t\tslice_strlen = pg_mbstrlen_with_len(VARDATA_ANY(slice),\n\t\t\t\t\t\t\t\t\t\t\tVARSIZE_ANY_EXHDR(slice));\n\n\t\t/*\n\t\t * Check that the start position wasn't > slice_strlen. If so, SQL99\n\t\t * says to return a zero-length string.\n\t\t */\n\t\tif (S1 > slice_strlen)\n\t\t{\n\t\t\tif (slice != (text *) DatumGetPointer(str))\n\t\t\t\tpfree(slice);\n\t\t\treturn cstring_to_text(\"\");\n\t\t}\n\n\t\t/*\n\t\t * Adjust L1 and E1 now that we know the slice string length. Again\n\t\t * remember that S1 is one based, and slice_start is zero based.\n\t\t */\n\t\tif (L1 > -1)\n\t\t\tE1 = Min(S1 + L1, slice_start + 1 + slice_strlen);\n\t\telse\n\t\t\tE1 = slice_start + 1 + slice_strlen;\n\n\t\t/*\n\t\t * Find the start position in the slice; remember S1 is not zero based\n\t\t */\n\t\tp = VARDATA_ANY(slice);\n\t\tfor (i = 0; i < S1 - 1; i++)\n\t\t\tp += pg_mblen(p);\n\n\t\t/* hang onto a pointer to our start position */\n\t\ts = p;\n\n\t\t/*\n\t\t * Count the actual bytes used by the substring of the requested\n\t\t * length.\n\t\t */\n\t\tfor (i = S1; i < E1; i++)\n\t\t\tp += pg_mblen(p);\n\n\t\tret = (text *) palloc(VARHDRSZ + (p - s));\n\t\tSET_VARSIZE(ret, VARHDRSZ + (p - s));\n\t\tmemcpy(VARDATA(ret), s, (p - s));\n\n\t\tif (slice != (text *) DatumGetPointer(str))\n\t\t\tpfree(slice);\n\n\t\treturn ret;\n\t}\n\telse\n\t\telog(ERROR, \"invalid backend encoding: encoding max length < 1\");\n\n\t/* not reached: suppress compiler warning */\n\treturn NULL;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int32 text_length(Datum str);",
            "static text *text_substring(Datum str,\n\t\t\t   int32 start,\n\t\t\t   int32 length,\n\t\t\t   bool length_not_specified);",
            "static bytea *bytea_substring(Datum str,\n\t\t\t\tint S,\n\t\t\t\tint L,\n\t\t\t\tbool length_not_specified);",
            "static void appendStringInfoText(StringInfo str, const text *t);",
            "static bool text_format_parse_digits(const char **ptr, const char *end_ptr,\n\t\t\t\t\t\t int *value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int32 text_length(Datum str);\nstatic text *text_substring(Datum str,\n\t\t\t   int32 start,\n\t\t\t   int32 length,\n\t\t\t   bool length_not_specified);\nstatic bytea *bytea_substring(Datum str,\n\t\t\t\tint S,\n\t\t\t\tint L,\n\t\t\t\tbool length_not_specified);\nstatic void appendStringInfoText(StringInfo str, const text *t);\nstatic bool text_format_parse_digits(const char **ptr, const char *end_ptr,\n\t\t\t\t\t\t int *value);\n\nstatic text *\ntext_substring(Datum str, int32 start, int32 length, bool length_not_specified)\n{\n\tint32\t\teml = pg_database_encoding_max_length();\n\tint32\t\tS = start;\t\t/* start position */\n\tint32\t\tS1;\t\t\t\t/* adjusted start position */\n\tint32\t\tL1;\t\t\t\t/* adjusted substring length */\n\n\t/* life is easy if the encoding max length is 1 */\n\tif (eml == 1)\n\t{\n\t\tS1 = Max(S, 1);\n\n\t\tif (length_not_specified)\t/* special case - get length to end of\n\t\t\t\t\t\t\t\t\t * string */\n\t\t\tL1 = -1;\n\t\telse\n\t\t{\n\t\t\t/* end position */\n\t\t\tint\t\t\tE = S + length;\n\n\t\t\t/*\n\t\t\t * A negative value for L is the only way for the end position to\n\t\t\t * be before the start. SQL99 says to throw an error.\n\t\t\t */\n\t\t\tif (E < S)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SUBSTRING_ERROR),\n\t\t\t\t\t\t errmsg(\"negative substring length not allowed\")));\n\n\t\t\t/*\n\t\t\t * A zero or negative value for the end position can happen if the\n\t\t\t * start was negative or one. SQL99 says to return a zero-length\n\t\t\t * string.\n\t\t\t */\n\t\t\tif (E < 1)\n\t\t\t\treturn cstring_to_text(\"\");\n\n\t\t\tL1 = E - S1;\n\t\t}\n\n\t\t/*\n\t\t * If the start position is past the end of the string, SQL99 says to\n\t\t * return a zero-length string -- PG_GETARG_TEXT_P_SLICE() will do\n\t\t * that for us. Convert to zero-based starting position\n\t\t */\n\t\treturn DatumGetTextPSlice(str, S1 - 1, L1);\n\t}\n\telse if (eml > 1)\n\t{\n\t\t/*\n\t\t * When encoding max length is > 1, we can't get LC without\n\t\t * detoasting, so we'll grab a conservatively large slice now and go\n\t\t * back later to do the right thing\n\t\t */\n\t\tint32\t\tslice_start;\n\t\tint32\t\tslice_size;\n\t\tint32\t\tslice_strlen;\n\t\ttext\t   *slice;\n\t\tint32\t\tE1;\n\t\tint32\t\ti;\n\t\tchar\t   *p;\n\t\tchar\t   *s;\n\t\ttext\t   *ret;\n\n\t\t/*\n\t\t * if S is past the end of the string, the tuple toaster will return a\n\t\t * zero-length string to us\n\t\t */\n\t\tS1 = Max(S, 1);\n\n\t\t/*\n\t\t * We need to start at position zero because there is no way to know\n\t\t * in advance which byte offset corresponds to the supplied start\n\t\t * position.\n\t\t */\n\t\tslice_start = 0;\n\n\t\tif (length_not_specified)\t/* special case - get length to end of\n\t\t\t\t\t\t\t\t\t * string */\n\t\t\tslice_size = L1 = -1;\n\t\telse\n\t\t{\n\t\t\tint\t\t\tE = S + length;\n\n\t\t\t/*\n\t\t\t * A negative value for L is the only way for the end position to\n\t\t\t * be before the start. SQL99 says to throw an error.\n\t\t\t */\n\t\t\tif (E < S)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SUBSTRING_ERROR),\n\t\t\t\t\t\t errmsg(\"negative substring length not allowed\")));\n\n\t\t\t/*\n\t\t\t * A zero or negative value for the end position can happen if the\n\t\t\t * start was negative or one. SQL99 says to return a zero-length\n\t\t\t * string.\n\t\t\t */\n\t\t\tif (E < 1)\n\t\t\t\treturn cstring_to_text(\"\");\n\n\t\t\t/*\n\t\t\t * if E is past the end of the string, the tuple toaster will\n\t\t\t * truncate the length for us\n\t\t\t */\n\t\t\tL1 = E - S1;\n\n\t\t\t/*\n\t\t\t * Total slice size in bytes can't be any longer than the start\n\t\t\t * position plus substring length times the encoding max length.\n\t\t\t */\n\t\t\tslice_size = (S1 + L1) * eml;\n\t\t}\n\n\t\t/*\n\t\t * If we're working with an untoasted source, no need to do an extra\n\t\t * copying step.\n\t\t */\n\t\tif (VARATT_IS_COMPRESSED(DatumGetPointer(str)) ||\n\t\t\tVARATT_IS_EXTERNAL(DatumGetPointer(str)))\n\t\t\tslice = DatumGetTextPSlice(str, slice_start, slice_size);\n\t\telse\n\t\t\tslice = (text *) DatumGetPointer(str);\n\n\t\t/* see if we got back an empty string */\n\t\tif (VARSIZE_ANY_EXHDR(slice) == 0)\n\t\t{\n\t\t\tif (slice != (text *) DatumGetPointer(str))\n\t\t\t\tpfree(slice);\n\t\t\treturn cstring_to_text(\"\");\n\t\t}\n\n\t\t/* Now we can get the actual length of the slice in MB characters */\n\t\tslice_strlen = pg_mbstrlen_with_len(VARDATA_ANY(slice),\n\t\t\t\t\t\t\t\t\t\t\tVARSIZE_ANY_EXHDR(slice));\n\n\t\t/*\n\t\t * Check that the start position wasn't > slice_strlen. If so, SQL99\n\t\t * says to return a zero-length string.\n\t\t */\n\t\tif (S1 > slice_strlen)\n\t\t{\n\t\t\tif (slice != (text *) DatumGetPointer(str))\n\t\t\t\tpfree(slice);\n\t\t\treturn cstring_to_text(\"\");\n\t\t}\n\n\t\t/*\n\t\t * Adjust L1 and E1 now that we know the slice string length. Again\n\t\t * remember that S1 is one based, and slice_start is zero based.\n\t\t */\n\t\tif (L1 > -1)\n\t\t\tE1 = Min(S1 + L1, slice_start + 1 + slice_strlen);\n\t\telse\n\t\t\tE1 = slice_start + 1 + slice_strlen;\n\n\t\t/*\n\t\t * Find the start position in the slice; remember S1 is not zero based\n\t\t */\n\t\tp = VARDATA_ANY(slice);\n\t\tfor (i = 0; i < S1 - 1; i++)\n\t\t\tp += pg_mblen(p);\n\n\t\t/* hang onto a pointer to our start position */\n\t\ts = p;\n\n\t\t/*\n\t\t * Count the actual bytes used by the substring of the requested\n\t\t * length.\n\t\t */\n\t\tfor (i = S1; i < E1; i++)\n\t\t\tp += pg_mblen(p);\n\n\t\tret = (text *) palloc(VARHDRSZ + (p - s));\n\t\tSET_VARSIZE(ret, VARHDRSZ + (p - s));\n\t\tmemcpy(VARDATA(ret), s, (p - s));\n\n\t\tif (slice != (text *) DatumGetPointer(str))\n\t\t\tpfree(slice);\n\n\t\treturn ret;\n\t}\n\telse\n\t\telog(ERROR, \"invalid backend encoding: encoding max length < 1\");\n\n\t/* not reached: suppress compiler warning */\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "2"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "1"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "0"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\n\nDatum\ntext_substr(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_TEXT_P(text_substring(PG_GETARG_DATUM(0),\n\t\t\t\t\t\t\t\t\tPG_GETARG_INT32(1),\n\t\t\t\t\t\t\t\t\tPG_GETARG_INT32(2),\n\t\t\t\t\t\t\t\t\tfalse));\n}"
  },
  {
    "function_name": "charlen_to_bytelen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "734-751",
    "snippet": "static int\ncharlen_to_bytelen(const char *p, int n)\n{\n\tif (pg_database_encoding_max_length() == 1)\n\t{\n\t\t/* Optimization for single-byte encodings */\n\t\treturn n;\n\t}\n\telse\n\t{\n\t\tconst char *s;\n\n\t\tfor (s = p; n > 0; n--)\n\t\t\ts += pg_mblen(s);\n\n\t\treturn s - p;\n\t}\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pg_mblen",
          "args": [
            "s"
          ],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mblen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "759-763",
          "snippet": "int\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nint\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_database_encoding_max_length",
          "args": [],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "pg_database_encoding_max_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "1832-1836",
          "snippet": "int\npg_database_encoding_max_length(void)\n{\n\treturn pg_wchar_table[GetDatabaseEncoding()].maxmblen;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nconst pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};\n\nint\npg_database_encoding_max_length(void)\n{\n\treturn pg_wchar_table[GetDatabaseEncoding()].maxmblen;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ncharlen_to_bytelen(const char *p, int n)\n{\n\tif (pg_database_encoding_max_length() == 1)\n\t{\n\t\t/* Optimization for single-byte encodings */\n\t\treturn n;\n\t}\n\telse\n\t{\n\t\tconst char *s;\n\n\t\tfor (s = p; n > 0; n--)\n\t\t\ts += pg_mblen(s);\n\n\t\treturn s - p;\n\t}\n}"
  },
  {
    "function_name": "text_catenate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "693-725",
    "snippet": "static text *\ntext_catenate(text *t1, text *t2)\n{\n\ttext\t   *result;\n\tint\t\t\tlen1,\n\t\t\t\tlen2,\n\t\t\t\tlen;\n\tchar\t   *ptr;\n\n\tlen1 = VARSIZE_ANY_EXHDR(t1);\n\tlen2 = VARSIZE_ANY_EXHDR(t2);\n\n\t/* paranoia ... probably should throw error instead? */\n\tif (len1 < 0)\n\t\tlen1 = 0;\n\tif (len2 < 0)\n\t\tlen2 = 0;\n\n\tlen = len1 + len2 + VARHDRSZ;\n\tresult = (text *) palloc(len);\n\n\t/* Set size of result string... */\n\tSET_VARSIZE(result, len);\n\n\t/* Fill data field of result string... */\n\tptr = VARDATA(result);\n\tif (len1 > 0)\n\t\tmemcpy(ptr, VARDATA_ANY(t1), len1);\n\tif (len2 > 0)\n\t\tmemcpy(ptr + len1, VARDATA_ANY(t2), len2);\n\n\treturn result;\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static text *text_catenate(text *t1, text *t2);",
      "static int\ttext_position(text *t1, text *t2);",
      "static bytea *bytea_catenate(bytea *t1, bytea *t2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ptr + len1",
            "VARDATA_ANY(t2)",
            "len2"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "t2"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ptr",
            "VARDATA_ANY(t1)",
            "len1"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "t1"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA",
          "args": [
            "result"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "result",
            "len"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "len"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "t2"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "t1"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic text *text_catenate(text *t1, text *t2);\nstatic int\ttext_position(text *t1, text *t2);\nstatic bytea *bytea_catenate(bytea *t1, bytea *t2);\n\nstatic text *\ntext_catenate(text *t1, text *t2)\n{\n\ttext\t   *result;\n\tint\t\t\tlen1,\n\t\t\t\tlen2,\n\t\t\t\tlen;\n\tchar\t   *ptr;\n\n\tlen1 = VARSIZE_ANY_EXHDR(t1);\n\tlen2 = VARSIZE_ANY_EXHDR(t2);\n\n\t/* paranoia ... probably should throw error instead? */\n\tif (len1 < 0)\n\t\tlen1 = 0;\n\tif (len2 < 0)\n\t\tlen2 = 0;\n\n\tlen = len1 + len2 + VARHDRSZ;\n\tresult = (text *) palloc(len);\n\n\t/* Set size of result string... */\n\tSET_VARSIZE(result, len);\n\n\t/* Fill data field of result string... */\n\tptr = VARDATA(result);\n\tif (len1 > 0)\n\t\tmemcpy(ptr, VARDATA_ANY(t1), len1);\n\tif (len2 > 0)\n\t\tmemcpy(ptr + len1, VARDATA_ANY(t2), len2);\n\n\treturn result;\n}"
  },
  {
    "function_name": "textcat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "678-685",
    "snippet": "Datum\ntextcat(PG_FUNCTION_ARGS)\n{\n\ttext\t   *t1 = PG_GETARG_TEXT_PP(0);\n\ttext\t   *t2 = PG_GETARG_TEXT_PP(1);\n\n\tPG_RETURN_TEXT_P(text_catenate(t1, t2));\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static text *text_catenate(text *t1, text *t2);",
      "static int\ttext_position(text *t1, text *t2);",
      "static bytea *bytea_catenate(bytea *t1, bytea *t2);",
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "text_catenate(t1, t2)"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text_catenate",
          "args": [
            "t1",
            "t2"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "text_catenate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "693-725",
          "snippet": "static text *\ntext_catenate(text *t1, text *t2)\n{\n\ttext\t   *result;\n\tint\t\t\tlen1,\n\t\t\t\tlen2,\n\t\t\t\tlen;\n\tchar\t   *ptr;\n\n\tlen1 = VARSIZE_ANY_EXHDR(t1);\n\tlen2 = VARSIZE_ANY_EXHDR(t2);\n\n\t/* paranoia ... probably should throw error instead? */\n\tif (len1 < 0)\n\t\tlen1 = 0;\n\tif (len2 < 0)\n\t\tlen2 = 0;\n\n\tlen = len1 + len2 + VARHDRSZ;\n\tresult = (text *) palloc(len);\n\n\t/* Set size of result string... */\n\tSET_VARSIZE(result, len);\n\n\t/* Fill data field of result string... */\n\tptr = VARDATA(result);\n\tif (len1 > 0)\n\t\tmemcpy(ptr, VARDATA_ANY(t1), len1);\n\tif (len2 > 0)\n\t\tmemcpy(ptr + len1, VARDATA_ANY(t2), len2);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static text *text_catenate(text *t1, text *t2);",
            "static int\ttext_position(text *t1, text *t2);",
            "static bytea *bytea_catenate(bytea *t1, bytea *t2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic text *text_catenate(text *t1, text *t2);\nstatic int\ttext_position(text *t1, text *t2);\nstatic bytea *bytea_catenate(bytea *t1, bytea *t2);\n\nstatic text *\ntext_catenate(text *t1, text *t2)\n{\n\ttext\t   *result;\n\tint\t\t\tlen1,\n\t\t\t\tlen2,\n\t\t\t\tlen;\n\tchar\t   *ptr;\n\n\tlen1 = VARSIZE_ANY_EXHDR(t1);\n\tlen2 = VARSIZE_ANY_EXHDR(t2);\n\n\t/* paranoia ... probably should throw error instead? */\n\tif (len1 < 0)\n\t\tlen1 = 0;\n\tif (len2 < 0)\n\t\tlen2 = 0;\n\n\tlen = len1 + len2 + VARHDRSZ;\n\tresult = (text *) palloc(len);\n\n\t/* Set size of result string... */\n\tSET_VARSIZE(result, len);\n\n\t/* Fill data field of result string... */\n\tptr = VARDATA(result);\n\tif (len1 > 0)\n\t\tmemcpy(ptr, VARDATA_ANY(t1), len1);\n\tif (len2 > 0)\n\t\tmemcpy(ptr + len1, VARDATA_ANY(t2), len2);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic text *text_catenate(text *t1, text *t2);\nstatic int\ttext_position(text *t1, text *t2);\nstatic bytea *bytea_catenate(bytea *t1, bytea *t2);\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\n\nDatum\ntextcat(PG_FUNCTION_ARGS)\n{\n\ttext\t   *t1 = PG_GETARG_TEXT_PP(0);\n\ttext\t   *t2 = PG_GETARG_TEXT_PP(1);\n\n\tPG_RETURN_TEXT_P(text_catenate(t1, t2));\n}"
  },
  {
    "function_name": "textoctetlen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "659-666",
    "snippet": "Datum\ntextoctetlen(PG_FUNCTION_ARGS)\n{\n\tDatum\t\tstr = PG_GETARG_DATUM(0);\n\n\t/* We need not detoast the input at all */\n\tPG_RETURN_INT32(toast_raw_datum_size(str) - VARHDRSZ);\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int32 text_length(Datum str);",
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "toast_raw_datum_size(str) - VARHDRSZ"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toast_raw_datum_size",
          "args": [
            "str"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "0"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int32 text_length(Datum str);\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\n\nDatum\ntextoctetlen(PG_FUNCTION_ARGS)\n{\n\tDatum\t\tstr = PG_GETARG_DATUM(0);\n\n\t/* We need not detoast the input at all */\n\tPG_RETURN_INT32(toast_raw_datum_size(str) - VARHDRSZ);\n}"
  },
  {
    "function_name": "text_length",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "639-652",
    "snippet": "static int32\ntext_length(Datum str)\n{\n\t/* fastpath when max encoding length is one */\n\tif (pg_database_encoding_max_length() == 1)\n\t\tPG_RETURN_INT32(toast_raw_datum_size(str) - VARHDRSZ);\n\telse\n\t{\n\t\ttext\t   *t = DatumGetTextPP(str);\n\n\t\tPG_RETURN_INT32(pg_mbstrlen_with_len(VARDATA_ANY(t),\n\t\t\t\t\t\t\t\t\t\t\t VARSIZE_ANY_EXHDR(t)));\n\t}\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int32 text_length(Datum str);",
      "static void appendStringInfoText(StringInfo str, const text *t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "pg_mbstrlen_with_len(VARDATA_ANY(t),\n\t\t\t\t\t\t\t\t\t\t\t VARSIZE_ANY_EXHDR(t))"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_mbstrlen_with_len",
          "args": [
            "VARDATA_ANY(t)",
            "VARSIZE_ANY_EXHDR(t)"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mbstrlen_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "793-811",
          "snippet": "int\npg_mbstrlen_with_len(const char *mbstr, int limit)\n{\n\tint\t\t\tlen = 0;\n\n\t/* optimization for single byte encoding */\n\tif (pg_database_encoding_max_length() == 1)\n\t\treturn limit;\n\n\twhile (limit > 0 && *mbstr)\n\t{\n\t\tint\t\t\tl = pg_mblen(mbstr);\n\n\t\tlimit -= l;\n\t\tmbstr += l;\n\t\tlen++;\n\t}\n\treturn len;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tcliplen(const char *str, int len, int limit);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic int\tcliplen(const char *str, int len, int limit);\n\nint\npg_mbstrlen_with_len(const char *mbstr, int limit)\n{\n\tint\t\t\tlen = 0;\n\n\t/* optimization for single byte encoding */\n\tif (pg_database_encoding_max_length() == 1)\n\t\treturn limit;\n\n\twhile (limit > 0 && *mbstr)\n\t{\n\t\tint\t\t\tl = pg_mblen(mbstr);\n\n\t\tlimit -= l;\n\t\tmbstr += l;\n\t\tlen++;\n\t}\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "t"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "t"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetTextPP",
          "args": [
            "str"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "toast_raw_datum_size(str) - VARHDRSZ"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toast_raw_datum_size",
          "args": [
            "str"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_database_encoding_max_length",
          "args": [],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "pg_database_encoding_max_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "1832-1836",
          "snippet": "int\npg_database_encoding_max_length(void)\n{\n\treturn pg_wchar_table[GetDatabaseEncoding()].maxmblen;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nconst pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};\n\nint\npg_database_encoding_max_length(void)\n{\n\treturn pg_wchar_table[GetDatabaseEncoding()].maxmblen;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int32 text_length(Datum str);\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nstatic int32\ntext_length(Datum str)\n{\n\t/* fastpath when max encoding length is one */\n\tif (pg_database_encoding_max_length() == 1)\n\t\tPG_RETURN_INT32(toast_raw_datum_size(str) - VARHDRSZ);\n\telse\n\t{\n\t\ttext\t   *t = DatumGetTextPP(str);\n\n\t\tPG_RETURN_INT32(pg_mbstrlen_with_len(VARDATA_ANY(t),\n\t\t\t\t\t\t\t\t\t\t\t VARSIZE_ANY_EXHDR(t)));\n\t}\n}"
  },
  {
    "function_name": "textlen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "621-628",
    "snippet": "Datum\ntextlen(PG_FUNCTION_ARGS)\n{\n\tDatum\t\tstr = PG_GETARG_DATUM(0);\n\n\t/* try to avoid decompressing argument */\n\tPG_RETURN_INT32(text_length(str));\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int32 text_length(Datum str);",
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "text_length(str)"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text_length",
          "args": [
            "str"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "text_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "639-652",
          "snippet": "static int32\ntext_length(Datum str)\n{\n\t/* fastpath when max encoding length is one */\n\tif (pg_database_encoding_max_length() == 1)\n\t\tPG_RETURN_INT32(toast_raw_datum_size(str) - VARHDRSZ);\n\telse\n\t{\n\t\ttext\t   *t = DatumGetTextPP(str);\n\n\t\tPG_RETURN_INT32(pg_mbstrlen_with_len(VARDATA_ANY(t),\n\t\t\t\t\t\t\t\t\t\t\t VARSIZE_ANY_EXHDR(t)));\n\t}\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int32 text_length(Datum str);",
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int32 text_length(Datum str);\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nstatic int32\ntext_length(Datum str)\n{\n\t/* fastpath when max encoding length is one */\n\tif (pg_database_encoding_max_length() == 1)\n\t\tPG_RETURN_INT32(toast_raw_datum_size(str) - VARHDRSZ);\n\telse\n\t{\n\t\ttext\t   *t = DatumGetTextPP(str);\n\n\t\tPG_RETURN_INT32(pg_mbstrlen_with_len(VARDATA_ANY(t),\n\t\t\t\t\t\t\t\t\t\t\t VARSIZE_ANY_EXHDR(t)));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "0"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int32 text_length(Datum str);\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\n\nDatum\ntextlen(PG_FUNCTION_ARGS)\n{\n\tDatum\t\tstr = PG_GETARG_DATUM(0);\n\n\t/* try to avoid decompressing argument */\n\tPG_RETURN_INT32(text_length(str));\n}"
  },
  {
    "function_name": "unknownsend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "601-611",
    "snippet": "Datum\nunknownsend(PG_FUNCTION_ARGS)\n{\n\t/* representation is same as cstring */\n\tchar\t   *str = PG_GETARG_CSTRING(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendtext(&buf, str, strlen(str));\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int32 text_length(Datum str);",
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BYTEA_P",
          "args": [
            "pq_endtypsend(&buf)"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_endtypsend",
          "args": [
            "&buf"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendtext",
          "args": [
            "&buf",
            "str",
            "strlen(str)"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pq_begintypsend",
          "args": [
            "&buf"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CSTRING",
          "args": [
            "0"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int32 text_length(Datum str);\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\n\nDatum\nunknownsend(PG_FUNCTION_ARGS)\n{\n\t/* representation is same as cstring */\n\tchar\t   *str = PG_GETARG_CSTRING(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendtext(&buf, str, strlen(str));\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}"
  },
  {
    "function_name": "unknownrecv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "586-596",
    "snippet": "Datum\nunknownrecv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\tchar\t   *str;\n\tint\t\t\tnbytes;\n\n\tstr = pq_getmsgtext(buf, buf->len - buf->cursor, &nbytes);\n\t/* representation is same as cstring */\n\tPG_RETURN_CSTRING(str);\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int32 text_length(Datum str);",
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "str"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgtext",
          "args": [
            "buf",
            "buf->len - buf->cursor",
            "&nbytes"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int32 text_length(Datum str);\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\n\nDatum\nunknownrecv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\tchar\t   *str;\n\tint\t\t\tnbytes;\n\n\tstr = pq_getmsgtext(buf, buf->len - buf->cursor, &nbytes);\n\t/* representation is same as cstring */\n\tPG_RETURN_CSTRING(str);\n}"
  },
  {
    "function_name": "unknownout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "574-581",
    "snippet": "Datum\nunknownout(PG_FUNCTION_ARGS)\n{\n\t/* representation is same as cstring */\n\tchar\t   *str = PG_GETARG_CSTRING(0);\n\n\tPG_RETURN_CSTRING(pstrdup(str));\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int32 text_length(Datum str);",
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "pstrdup(str)"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pstrdup",
          "args": [
            "str"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1658-1662",
          "snippet": "static char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CSTRING",
          "args": [
            "0"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int32 text_length(Datum str);\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\n\nDatum\nunknownout(PG_FUNCTION_ARGS)\n{\n\t/* representation is same as cstring */\n\tchar\t   *str = PG_GETARG_CSTRING(0);\n\n\tPG_RETURN_CSTRING(pstrdup(str));\n}"
  },
  {
    "function_name": "unknownin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "562-569",
    "snippet": "Datum\nunknownin(PG_FUNCTION_ARGS)\n{\n\tchar\t   *str = PG_GETARG_CSTRING(0);\n\n\t/* representation is same as cstring */\n\tPG_RETURN_CSTRING(pstrdup(str));\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int32 text_length(Datum str);",
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "pstrdup(str)"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pstrdup",
          "args": [
            "str"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1658-1662",
          "snippet": "static char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CSTRING",
          "args": [
            "0"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int32 text_length(Datum str);\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\n\nDatum\nunknownin(PG_FUNCTION_ARGS)\n{\n\tchar\t   *str = PG_GETARG_CSTRING(0);\n\n\t/* representation is same as cstring */\n\tPG_RETURN_CSTRING(pstrdup(str));\n}"
  },
  {
    "function_name": "textsend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "547-556",
    "snippet": "Datum\ntextsend(PG_FUNCTION_ARGS)\n{\n\ttext\t   *t = PG_GETARG_TEXT_PP(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendtext(&buf, VARDATA_ANY(t), VARSIZE_ANY_EXHDR(t));\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void appendStringInfoText(StringInfo str, const text *t);",
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BYTEA_P",
          "args": [
            "pq_endtypsend(&buf)"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_endtypsend",
          "args": [
            "&buf"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendtext",
          "args": [
            "&buf",
            "VARDATA_ANY(t)",
            "VARSIZE_ANY_EXHDR(t)"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "t"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "t"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_begintypsend",
          "args": [
            "&buf"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\n\nDatum\ntextsend(PG_FUNCTION_ARGS)\n{\n\ttext\t   *t = PG_GETARG_TEXT_PP(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendtext(&buf, VARDATA_ANY(t), VARSIZE_ANY_EXHDR(t));\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}"
  },
  {
    "function_name": "textrecv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "529-542",
    "snippet": "Datum\ntextrecv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\ttext\t   *result;\n\tchar\t   *str;\n\tint\t\t\tnbytes;\n\n\tstr = pq_getmsgtext(buf, buf->len - buf->cursor, &nbytes);\n\n\tresult = cstring_to_text_with_len(str, nbytes);\n\tpfree(str);\n\tPG_RETURN_TEXT_P(result);\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int32 text_length(Datum str);",
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "result"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "str"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cstring_to_text_with_len",
          "args": [
            "str",
            "nbytes"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "160-169",
          "snippet": "text *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pq_getmsgtext",
          "args": [
            "buf",
            "buf->len - buf->cursor",
            "&nbytes"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int32 text_length(Datum str);\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\n\nDatum\ntextrecv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\ttext\t   *result;\n\tchar\t   *str;\n\tint\t\t\tnbytes;\n\n\tstr = pq_getmsgtext(buf, buf->len - buf->cursor, &nbytes);\n\n\tresult = cstring_to_text_with_len(str, nbytes);\n\tpfree(str);\n\tPG_RETURN_TEXT_P(result);\n}"
  },
  {
    "function_name": "textout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "518-524",
    "snippet": "Datum\ntextout(PG_FUNCTION_ARGS)\n{\n\tDatum\t\ttxt = PG_GETARG_DATUM(0);\n\n\tPG_RETURN_CSTRING(TextDatumGetCString(txt));\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "TextDatumGetCString(txt)"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TextDatumGetCString",
          "args": [
            "txt"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "0"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\n\nDatum\ntextout(PG_FUNCTION_ARGS)\n{\n\tDatum\t\ttxt = PG_GETARG_DATUM(0);\n\n\tPG_RETURN_CSTRING(TextDatumGetCString(txt));\n}"
  },
  {
    "function_name": "textin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "507-513",
    "snippet": "Datum\ntextin(PG_FUNCTION_ARGS)\n{\n\tchar\t   *inputText = PG_GETARG_CSTRING(0);\n\n\tPG_RETURN_TEXT_P(cstring_to_text(inputText));\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "cstring_to_text(inputText)"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cstring_to_text",
          "args": [
            "inputText"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "148-152",
          "snippet": "text *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CSTRING",
          "args": [
            "0"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\n\nDatum\ntextin(PG_FUNCTION_ARGS)\n{\n\tchar\t   *inputText = PG_GETARG_CSTRING(0);\n\n\tPG_RETURN_TEXT_P(cstring_to_text(inputText));\n}"
  },
  {
    "function_name": "bytea_string_agg_finalfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "481-502",
    "snippet": "Datum\nbytea_string_agg_finalfn(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tstate;\n\n\t/* cannot be called directly because of internal-type argument */\n\tAssert(AggCheckCallContext(fcinfo, NULL));\n\n\tstate = PG_ARGISNULL(0) ? NULL : (StringInfo) PG_GETARG_POINTER(0);\n\n\tif (state != NULL)\n\t{\n\t\tbytea\t   *result;\n\n\t\tresult = (bytea *) palloc(state->len + VARHDRSZ);\n\t\tSET_VARSIZE(result, state->len + VARHDRSZ);\n\t\tmemcpy(VARDATA(result), state->data, state->len);\n\t\tPG_RETURN_BYTEA_P(result);\n\t}\n\telse\n\t\tPG_RETURN_NULL();\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void text_position_setup(text *t1, text *t2, TextPositionState *state);",
      "static int\ttext_position_next(int start_pos, TextPositionState *state);",
      "static void text_position_cleanup(TextPositionState *state);",
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);",
      "static StringInfo makeStringAggState(FunctionCallInfo fcinfo);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BYTEA_P",
          "args": [
            "result"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "VARDATA(result)",
            "state->data",
            "state->len"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA",
          "args": [
            "result"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "result",
            "state->len + VARHDRSZ"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "state->len + VARHDRSZ"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "0"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "AggCheckCallContext(fcinfo, NULL)"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AggCheckCallContext",
          "args": [
            "fcinfo",
            "NULL"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void text_position_setup(text *t1, text *t2, TextPositionState *state);\nstatic int\ttext_position_next(int start_pos, TextPositionState *state);\nstatic void text_position_cleanup(TextPositionState *state);\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\nstatic StringInfo makeStringAggState(FunctionCallInfo fcinfo);\n\nDatum\nbytea_string_agg_finalfn(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tstate;\n\n\t/* cannot be called directly because of internal-type argument */\n\tAssert(AggCheckCallContext(fcinfo, NULL));\n\n\tstate = PG_ARGISNULL(0) ? NULL : (StringInfo) PG_GETARG_POINTER(0);\n\n\tif (state != NULL)\n\t{\n\t\tbytea\t   *result;\n\n\t\tresult = (bytea *) palloc(state->len + VARHDRSZ);\n\t\tSET_VARSIZE(result, state->len + VARHDRSZ);\n\t\tmemcpy(VARDATA(result), state->data, state->len);\n\t\tPG_RETURN_BYTEA_P(result);\n\t}\n\telse\n\t\tPG_RETURN_NULL();\n}"
  },
  {
    "function_name": "bytea_string_agg_transfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "449-479",
    "snippet": "Datum\nbytea_string_agg_transfn(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tstate;\n\n\tstate = PG_ARGISNULL(0) ? NULL : (StringInfo) PG_GETARG_POINTER(0);\n\n\t/* Append the value unless null. */\n\tif (!PG_ARGISNULL(1))\n\t{\n\t\tbytea\t   *value = PG_GETARG_BYTEA_PP(1);\n\n\t\t/* On the first time through, we ignore the delimiter. */\n\t\tif (state == NULL)\n\t\t\tstate = makeStringAggState(fcinfo);\n\t\telse if (!PG_ARGISNULL(2))\n\t\t{\n\t\t\tbytea\t   *delim = PG_GETARG_BYTEA_PP(2);\n\n\t\t\tappendBinaryStringInfo(state, VARDATA_ANY(delim), VARSIZE_ANY_EXHDR(delim));\n\t\t}\n\n\t\tappendBinaryStringInfo(state, VARDATA_ANY(value), VARSIZE_ANY_EXHDR(value));\n\t}\n\n\t/*\n\t * The transition type for string_agg() is declared to be \"internal\",\n\t * which is a pass-by-value type the same size as a pointer.\n\t */\n\tPG_RETURN_POINTER(state);\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void text_position_setup(text *t1, text *t2, TextPositionState *state);",
      "static int\ttext_position_next(int start_pos, TextPositionState *state);",
      "static void text_position_cleanup(TextPositionState *state);",
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);",
      "static StringInfo makeStringAggState(FunctionCallInfo fcinfo);",
      "static bool text_format_parse_digits(const char **ptr, const char *end_ptr,\n\t\t\t\t\t\t int *value);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "state"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendBinaryStringInfo",
          "args": [
            "state",
            "VARDATA_ANY(value)",
            "VARSIZE_ANY_EXHDR(value)"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "value"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "value"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendBinaryStringInfo",
          "args": [
            "state",
            "VARDATA_ANY(delim)",
            "VARSIZE_ANY_EXHDR(delim)"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "delim"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "delim"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BYTEA_PP",
          "args": [
            "2"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "2"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeStringAggState",
          "args": [
            "fcinfo"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "makeStringAggState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "4765-4787",
          "snippet": "static StringInfo\nmakeStringAggState(FunctionCallInfo fcinfo)\n{\n\tStringInfo\tstate;\n\tMemoryContext aggcontext;\n\tMemoryContext oldcontext;\n\n\tif (!AggCheckCallContext(fcinfo, &aggcontext))\n\t{\n\t\t/* cannot be called directly because of internal-type argument */\n\t\telog(ERROR, \"string_agg_transfn called in non-aggregate context\");\n\t}\n\n\t/*\n\t * Create state in aggregate context.  It'll stay there across subsequent\n\t * calls.\n\t */\n\toldcontext = MemoryContextSwitchTo(aggcontext);\n\tstate = makeStringInfo();\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn state;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void text_position_setup(text *t1, text *t2, TextPositionState *state);",
            "static int\ttext_position_next(int start_pos, TextPositionState *state);",
            "static void text_position_cleanup(TextPositionState *state);",
            "static StringInfo makeStringAggState(FunctionCallInfo fcinfo);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void text_position_setup(text *t1, text *t2, TextPositionState *state);\nstatic int\ttext_position_next(int start_pos, TextPositionState *state);\nstatic void text_position_cleanup(TextPositionState *state);\nstatic StringInfo makeStringAggState(FunctionCallInfo fcinfo);\n\nstatic StringInfo\nmakeStringAggState(FunctionCallInfo fcinfo)\n{\n\tStringInfo\tstate;\n\tMemoryContext aggcontext;\n\tMemoryContext oldcontext;\n\n\tif (!AggCheckCallContext(fcinfo, &aggcontext))\n\t{\n\t\t/* cannot be called directly because of internal-type argument */\n\t\telog(ERROR, \"string_agg_transfn called in non-aggregate context\");\n\t}\n\n\t/*\n\t * Create state in aggregate context.  It'll stay there across subsequent\n\t * calls.\n\t */\n\toldcontext = MemoryContextSwitchTo(aggcontext);\n\tstate = makeStringInfo();\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BYTEA_PP",
          "args": [
            "1"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "1"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "0"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void text_position_setup(text *t1, text *t2, TextPositionState *state);\nstatic int\ttext_position_next(int start_pos, TextPositionState *state);\nstatic void text_position_cleanup(TextPositionState *state);\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\nstatic StringInfo makeStringAggState(FunctionCallInfo fcinfo);\nstatic bool text_format_parse_digits(const char **ptr, const char *end_ptr,\n\t\t\t\t\t\t int *value);\n\nDatum\nbytea_string_agg_transfn(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tstate;\n\n\tstate = PG_ARGISNULL(0) ? NULL : (StringInfo) PG_GETARG_POINTER(0);\n\n\t/* Append the value unless null. */\n\tif (!PG_ARGISNULL(1))\n\t{\n\t\tbytea\t   *value = PG_GETARG_BYTEA_PP(1);\n\n\t\t/* On the first time through, we ignore the delimiter. */\n\t\tif (state == NULL)\n\t\t\tstate = makeStringAggState(fcinfo);\n\t\telse if (!PG_ARGISNULL(2))\n\t\t{\n\t\t\tbytea\t   *delim = PG_GETARG_BYTEA_PP(2);\n\n\t\t\tappendBinaryStringInfo(state, VARDATA_ANY(delim), VARSIZE_ANY_EXHDR(delim));\n\t\t}\n\n\t\tappendBinaryStringInfo(state, VARDATA_ANY(value), VARSIZE_ANY_EXHDR(value));\n\t}\n\n\t/*\n\t * The transition type for string_agg() is declared to be \"internal\",\n\t * which is a pass-by-value type the same size as a pointer.\n\t */\n\tPG_RETURN_POINTER(state);\n}"
  },
  {
    "function_name": "byteasend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "441-447",
    "snippet": "Datum\nbyteasend(PG_FUNCTION_ARGS)\n{\n\tbytea\t   *vlena = PG_GETARG_BYTEA_P_COPY(0);\n\n\tPG_RETURN_BYTEA_P(vlena);\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BYTEA_P",
          "args": [
            "vlena"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BYTEA_P_COPY",
          "args": [
            "0"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\n\nDatum\nbyteasend(PG_FUNCTION_ARGS)\n{\n\tbytea\t   *vlena = PG_GETARG_BYTEA_P_COPY(0);\n\n\tPG_RETURN_BYTEA_P(vlena);\n}"
  },
  {
    "function_name": "bytearecv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "422-434",
    "snippet": "Datum\nbytearecv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\tbytea\t   *result;\n\tint\t\t\tnbytes;\n\n\tnbytes = buf->len - buf->cursor;\n\tresult = (bytea *) palloc(nbytes + VARHDRSZ);\n\tSET_VARSIZE(result, nbytes + VARHDRSZ);\n\tpq_copymsgbytes(buf, VARDATA(result), nbytes);\n\tPG_RETURN_BYTEA_P(result);\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BYTEA_P",
          "args": [
            "result"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_copymsgbytes",
          "args": [
            "buf",
            "VARDATA(result)",
            "nbytes"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA",
          "args": [
            "result"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "result",
            "nbytes + VARHDRSZ"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "nbytes + VARHDRSZ"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\n\nDatum\nbytearecv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\tbytea\t   *result;\n\tint\t\t\tnbytes;\n\n\tnbytes = buf->len - buf->cursor;\n\tresult = (bytea *) palloc(nbytes + VARHDRSZ);\n\tSET_VARSIZE(result, nbytes + VARHDRSZ);\n\tpq_copymsgbytes(buf, VARDATA(result), nbytes);\n\tPG_RETURN_BYTEA_P(result);\n}"
  },
  {
    "function_name": "byteaout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "350-417",
    "snippet": "Datum\nbyteaout(PG_FUNCTION_ARGS)\n{\n\tbytea\t   *vlena = PG_GETARG_BYTEA_PP(0);\n\tchar\t   *result;\n\tchar\t   *rp;\n\n\tif (bytea_output == BYTEA_OUTPUT_HEX)\n\t{\n\t\t/* Print hex format */\n\t\trp = result = palloc(VARSIZE_ANY_EXHDR(vlena) * 2 + 2 + 1);\n\t\t*rp++ = '\\\\';\n\t\t*rp++ = 'x';\n\t\trp += hex_encode(VARDATA_ANY(vlena), VARSIZE_ANY_EXHDR(vlena), rp);\n\t}\n\telse if (bytea_output == BYTEA_OUTPUT_ESCAPE)\n\t{\n\t\t/* Print traditional escaped format */\n\t\tchar\t   *vp;\n\t\tint\t\t\tlen;\n\t\tint\t\t\ti;\n\n\t\tlen = 1;\t\t\t\t/* empty string has 1 char */\n\t\tvp = VARDATA_ANY(vlena);\n\t\tfor (i = VARSIZE_ANY_EXHDR(vlena); i != 0; i--, vp++)\n\t\t{\n\t\t\tif (*vp == '\\\\')\n\t\t\t\tlen += 2;\n\t\t\telse if ((unsigned char) *vp < 0x20 || (unsigned char) *vp > 0x7e)\n\t\t\t\tlen += 4;\n\t\t\telse\n\t\t\t\tlen++;\n\t\t}\n\t\trp = result = (char *) palloc(len);\n\t\tvp = VARDATA_ANY(vlena);\n\t\tfor (i = VARSIZE_ANY_EXHDR(vlena); i != 0; i--, vp++)\n\t\t{\n\t\t\tif (*vp == '\\\\')\n\t\t\t{\n\t\t\t\t*rp++ = '\\\\';\n\t\t\t\t*rp++ = '\\\\';\n\t\t\t}\n\t\t\telse if ((unsigned char) *vp < 0x20 || (unsigned char) *vp > 0x7e)\n\t\t\t{\n\t\t\t\tint\t\t\tval;\t/* holds unprintable chars */\n\n\t\t\t\tval = *vp;\n\t\t\t\trp[0] = '\\\\';\n\t\t\t\trp[3] = DIG(val & 07);\n\t\t\t\tval >>= 3;\n\t\t\t\trp[2] = DIG(val & 07);\n\t\t\t\tval >>= 3;\n\t\t\t\trp[1] = DIG(val & 03);\n\t\t\t\trp += 4;\n\t\t\t}\n\t\t\telse\n\t\t\t\t*rp++ = *vp;\n\t\t}\n\t}\n\telse\n\t{\n\t\telog(ERROR, \"unrecognized bytea_output setting: %d\",\n\t\t\t bytea_output);\n\t\trp = result = NULL;\t\t/* keep compiler quiet */\n\t}\n\t*rp = '\\0';\n\tPG_RETURN_CSTRING(result);\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\t\t\tbytea_output = BYTEA_OUTPUT_HEX;",
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "result"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unrecognized bytea_output setting: %d\"",
            "bytea_output"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DIG",
          "args": [
            "val & 03"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIG",
          "args": [
            "val & 07"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIG",
          "args": [
            "val & 07"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "vlena"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "vlena"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "len"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "vlena"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "vlena"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hex_encode",
          "args": [
            "VARDATA_ANY(vlena)",
            "VARSIZE_ANY_EXHDR(vlena)",
            "rp"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "hex_encode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/encode.c",
          "lines": "125-137",
          "snippet": "unsigned\nhex_encode(const char *src, unsigned len, char *dst)\n{\n\tconst char *end = src + len;\n\n\twhile (src < end)\n\t{\n\t\t*dst++ = hextbl[(*src >> 4) & 0xF];\n\t\t*dst++ = hextbl[*src & 0xF];\n\t\tsrc++;\n\t}\n\treturn len * 2;\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char hextbl[] = \"0123456789abcdef\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic const char hextbl[] = \"0123456789abcdef\";\n\nunsigned\nhex_encode(const char *src, unsigned len, char *dst)\n{\n\tconst char *end = src + len;\n\n\twhile (src < end)\n\t{\n\t\t*dst++ = hextbl[(*src >> 4) & 0xF];\n\t\t*dst++ = hextbl[*src & 0xF];\n\t\tsrc++;\n\t}\n\treturn len * 2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "vlena"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "vlena"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "vlena"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BYTEA_PP",
          "args": [
            "0"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\t\t\tbytea_output = BYTEA_OUTPUT_HEX;\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\n\nDatum\nbyteaout(PG_FUNCTION_ARGS)\n{\n\tbytea\t   *vlena = PG_GETARG_BYTEA_PP(0);\n\tchar\t   *result;\n\tchar\t   *rp;\n\n\tif (bytea_output == BYTEA_OUTPUT_HEX)\n\t{\n\t\t/* Print hex format */\n\t\trp = result = palloc(VARSIZE_ANY_EXHDR(vlena) * 2 + 2 + 1);\n\t\t*rp++ = '\\\\';\n\t\t*rp++ = 'x';\n\t\trp += hex_encode(VARDATA_ANY(vlena), VARSIZE_ANY_EXHDR(vlena), rp);\n\t}\n\telse if (bytea_output == BYTEA_OUTPUT_ESCAPE)\n\t{\n\t\t/* Print traditional escaped format */\n\t\tchar\t   *vp;\n\t\tint\t\t\tlen;\n\t\tint\t\t\ti;\n\n\t\tlen = 1;\t\t\t\t/* empty string has 1 char */\n\t\tvp = VARDATA_ANY(vlena);\n\t\tfor (i = VARSIZE_ANY_EXHDR(vlena); i != 0; i--, vp++)\n\t\t{\n\t\t\tif (*vp == '\\\\')\n\t\t\t\tlen += 2;\n\t\t\telse if ((unsigned char) *vp < 0x20 || (unsigned char) *vp > 0x7e)\n\t\t\t\tlen += 4;\n\t\t\telse\n\t\t\t\tlen++;\n\t\t}\n\t\trp = result = (char *) palloc(len);\n\t\tvp = VARDATA_ANY(vlena);\n\t\tfor (i = VARSIZE_ANY_EXHDR(vlena); i != 0; i--, vp++)\n\t\t{\n\t\t\tif (*vp == '\\\\')\n\t\t\t{\n\t\t\t\t*rp++ = '\\\\';\n\t\t\t\t*rp++ = '\\\\';\n\t\t\t}\n\t\t\telse if ((unsigned char) *vp < 0x20 || (unsigned char) *vp > 0x7e)\n\t\t\t{\n\t\t\t\tint\t\t\tval;\t/* holds unprintable chars */\n\n\t\t\t\tval = *vp;\n\t\t\t\trp[0] = '\\\\';\n\t\t\t\trp[3] = DIG(val & 07);\n\t\t\t\tval >>= 3;\n\t\t\t\trp[2] = DIG(val & 07);\n\t\t\t\tval >>= 3;\n\t\t\t\trp[1] = DIG(val & 03);\n\t\t\t\trp += 4;\n\t\t\t}\n\t\t\telse\n\t\t\t\t*rp++ = *vp;\n\t\t}\n\t}\n\telse\n\t{\n\t\telog(ERROR, \"unrecognized bytea_output setting: %d\",\n\t\t\t bytea_output);\n\t\trp = result = NULL;\t\t/* keep compiler quiet */\n\t}\n\t*rp = '\\0';\n\tPG_RETURN_CSTRING(result);\n}"
  },
  {
    "function_name": "byteain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "254-342",
    "snippet": "Datum\nbyteain(PG_FUNCTION_ARGS)\n{\n\tchar\t   *inputText = PG_GETARG_CSTRING(0);\n\tchar\t   *tp;\n\tchar\t   *rp;\n\tint\t\t\tbc;\n\tbytea\t   *result;\n\n\t/* Recognize hex input */\n\tif (inputText[0] == '\\\\' && inputText[1] == 'x')\n\t{\n\t\tsize_t\t\tlen = strlen(inputText);\n\n\t\tbc = (len - 2) / 2 + VARHDRSZ;\t/* maximum possible length */\n\t\tresult = palloc(bc);\n\t\tbc = hex_decode(inputText + 2, len - 2, VARDATA(result));\n\t\tSET_VARSIZE(result, bc + VARHDRSZ); /* actual length */\n\n\t\tPG_RETURN_BYTEA_P(result);\n\t}\n\n\t/* Else, it's the traditional escaped style */\n\tfor (bc = 0, tp = inputText; *tp != '\\0'; bc++)\n\t{\n\t\tif (tp[0] != '\\\\')\n\t\t\ttp++;\n\t\telse if ((tp[0] == '\\\\') &&\n\t\t\t\t (tp[1] >= '0' && tp[1] <= '3') &&\n\t\t\t\t (tp[2] >= '0' && tp[2] <= '7') &&\n\t\t\t\t (tp[3] >= '0' && tp[3] <= '7'))\n\t\t\ttp += 4;\n\t\telse if ((tp[0] == '\\\\') &&\n\t\t\t\t (tp[1] == '\\\\'))\n\t\t\ttp += 2;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * one backslash, not followed by another or ### valid octal\n\t\t\t */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"bytea\")));\n\t\t}\n\t}\n\n\tbc += VARHDRSZ;\n\n\tresult = (bytea *) palloc(bc);\n\tSET_VARSIZE(result, bc);\n\n\ttp = inputText;\n\trp = VARDATA(result);\n\twhile (*tp != '\\0')\n\t{\n\t\tif (tp[0] != '\\\\')\n\t\t\t*rp++ = *tp++;\n\t\telse if ((tp[0] == '\\\\') &&\n\t\t\t\t (tp[1] >= '0' && tp[1] <= '3') &&\n\t\t\t\t (tp[2] >= '0' && tp[2] <= '7') &&\n\t\t\t\t (tp[3] >= '0' && tp[3] <= '7'))\n\t\t{\n\t\t\tbc = VAL(tp[1]);\n\t\t\tbc <<= 3;\n\t\t\tbc += VAL(tp[2]);\n\t\t\tbc <<= 3;\n\t\t\t*rp++ = bc + VAL(tp[3]);\n\n\t\t\ttp += 4;\n\t\t}\n\t\telse if ((tp[0] == '\\\\') &&\n\t\t\t\t (tp[1] == '\\\\'))\n\t\t{\n\t\t\t*rp++ = '\\\\';\n\t\t\ttp += 2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * We should never get here. The first pass should not allow it.\n\t\t\t */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"bytea\")));\n\t\t}\n\t}\n\n\tPG_RETURN_BYTEA_P(result);\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum text_to_array_internal(PG_FUNCTION_ARGS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BYTEA_P",
          "args": [
            "result"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"bytea\"))"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid input syntax for type %s\"",
            "\"bytea\""
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_TEXT_REPRESENTATION"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "VAL",
          "args": [
            "tp[3]"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VAL",
          "args": [
            "tp[2]"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VAL",
          "args": [
            "tp[1]"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA",
          "args": [
            "result"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "result",
            "bc"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "bc"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"bytea\"))"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BYTEA_P",
          "args": [
            "result"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "result",
            "bc + VARHDRSZ"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hex_decode",
          "args": [
            "inputText + 2",
            "len - 2",
            "VARDATA(result)"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "hex_decode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/encode.c",
          "lines": "155-185",
          "snippet": "unsigned\nhex_decode(const char *src, unsigned len, char *dst)\n{\n\tconst char *s,\n\t\t\t   *srcend;\n\tchar\t\tv1,\n\t\t\t\tv2,\n\t\t\t   *p;\n\n\tsrcend = src + len;\n\ts = src;\n\tp = dst;\n\twhile (s < srcend)\n\t{\n\t\tif (*s == ' ' || *s == '\\n' || *s == '\\t' || *s == '\\r')\n\t\t{\n\t\t\ts++;\n\t\t\tcontinue;\n\t\t}\n\t\tv1 = get_hex(*s++) << 4;\n\t\tif (s >= srcend)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"invalid hexadecimal data: odd number of digits\")));\n\n\t\tv2 = get_hex(*s++);\n\t\t*p++ = v1 | v2;\n\t}\n\n\treturn p - dst;\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nunsigned\nhex_decode(const char *src, unsigned len, char *dst)\n{\n\tconst char *s,\n\t\t\t   *srcend;\n\tchar\t\tv1,\n\t\t\t\tv2,\n\t\t\t   *p;\n\n\tsrcend = src + len;\n\ts = src;\n\tp = dst;\n\twhile (s < srcend)\n\t{\n\t\tif (*s == ' ' || *s == '\\n' || *s == '\\t' || *s == '\\r')\n\t\t{\n\t\t\ts++;\n\t\t\tcontinue;\n\t\t}\n\t\tv1 = get_hex(*s++) << 4;\n\t\tif (s >= srcend)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"invalid hexadecimal data: odd number of digits\")));\n\n\t\tv2 = get_hex(*s++);\n\t\t*p++ = v1 | v2;\n\t}\n\n\treturn p - dst;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARDATA",
          "args": [
            "result"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "inputText"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CSTRING",
          "args": [
            "0"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\n\nDatum\nbyteain(PG_FUNCTION_ARGS)\n{\n\tchar\t   *inputText = PG_GETARG_CSTRING(0);\n\tchar\t   *tp;\n\tchar\t   *rp;\n\tint\t\t\tbc;\n\tbytea\t   *result;\n\n\t/* Recognize hex input */\n\tif (inputText[0] == '\\\\' && inputText[1] == 'x')\n\t{\n\t\tsize_t\t\tlen = strlen(inputText);\n\n\t\tbc = (len - 2) / 2 + VARHDRSZ;\t/* maximum possible length */\n\t\tresult = palloc(bc);\n\t\tbc = hex_decode(inputText + 2, len - 2, VARDATA(result));\n\t\tSET_VARSIZE(result, bc + VARHDRSZ); /* actual length */\n\n\t\tPG_RETURN_BYTEA_P(result);\n\t}\n\n\t/* Else, it's the traditional escaped style */\n\tfor (bc = 0, tp = inputText; *tp != '\\0'; bc++)\n\t{\n\t\tif (tp[0] != '\\\\')\n\t\t\ttp++;\n\t\telse if ((tp[0] == '\\\\') &&\n\t\t\t\t (tp[1] >= '0' && tp[1] <= '3') &&\n\t\t\t\t (tp[2] >= '0' && tp[2] <= '7') &&\n\t\t\t\t (tp[3] >= '0' && tp[3] <= '7'))\n\t\t\ttp += 4;\n\t\telse if ((tp[0] == '\\\\') &&\n\t\t\t\t (tp[1] == '\\\\'))\n\t\t\ttp += 2;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * one backslash, not followed by another or ### valid octal\n\t\t\t */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"bytea\")));\n\t\t}\n\t}\n\n\tbc += VARHDRSZ;\n\n\tresult = (bytea *) palloc(bc);\n\tSET_VARSIZE(result, bc);\n\n\ttp = inputText;\n\trp = VARDATA(result);\n\twhile (*tp != '\\0')\n\t{\n\t\tif (tp[0] != '\\\\')\n\t\t\t*rp++ = *tp++;\n\t\telse if ((tp[0] == '\\\\') &&\n\t\t\t\t (tp[1] >= '0' && tp[1] <= '3') &&\n\t\t\t\t (tp[2] >= '0' && tp[2] <= '7') &&\n\t\t\t\t (tp[3] >= '0' && tp[3] <= '7'))\n\t\t{\n\t\t\tbc = VAL(tp[1]);\n\t\t\tbc <<= 3;\n\t\t\tbc += VAL(tp[2]);\n\t\t\tbc <<= 3;\n\t\t\t*rp++ = bc + VAL(tp[3]);\n\n\t\t\ttp += 4;\n\t\t}\n\t\telse if ((tp[0] == '\\\\') &&\n\t\t\t\t (tp[1] == '\\\\'))\n\t\t{\n\t\t\t*rp++ = '\\\\';\n\t\t\ttp += 2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * We should never get here. The first pass should not allow it.\n\t\t\t */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s\", \"bytea\")));\n\t\t}\n\t}\n\n\tPG_RETURN_BYTEA_P(result);\n}"
  },
  {
    "function_name": "text_to_cstring_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "212-232",
    "snippet": "void\ntext_to_cstring_buffer(const text *src, char *dst, size_t dst_len)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *srcunpacked = pg_detoast_datum_packed((struct varlena *) src);\n\tsize_t\t\tsrc_len = VARSIZE_ANY_EXHDR(srcunpacked);\n\n\tif (dst_len > 0)\n\t{\n\t\tdst_len--;\n\t\tif (dst_len >= src_len)\n\t\t\tdst_len = src_len;\n\t\telse\t\t\t\t\t/* ensure truncation is encoding-safe */\n\t\t\tdst_len = pg_mbcliplen(VARDATA_ANY(srcunpacked), src_len, dst_len);\n\t\tmemcpy(dst, VARDATA_ANY(srcunpacked), dst_len);\n\t\tdst[dst_len] = '\\0';\n\t}\n\n\tif (srcunpacked != src)\n\t\tpfree(srcunpacked);\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "srcunpacked"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst",
            "VARDATA_ANY(srcunpacked)",
            "dst_len"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "srcunpacked"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_mbcliplen",
          "args": [
            "VARDATA_ANY(srcunpacked)",
            "src_len",
            "dst_len"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mbcliplen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "819-824",
          "snippet": "int\npg_mbcliplen(const char *mbstr, int len, int limit)\n{\n\treturn pg_encoding_mbcliplen(DatabaseEncoding->encoding, mbstr,\n\t\t\t\t\t\t\t\t len, limit);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];",
            "static int\tcliplen(const char *str, int len, int limit);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\nstatic int\tcliplen(const char *str, int len, int limit);\n\nint\npg_mbcliplen(const char *mbstr, int len, int limit)\n{\n\treturn pg_encoding_mbcliplen(DatabaseEncoding->encoding, mbstr,\n\t\t\t\t\t\t\t\t len, limit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "srcunpacked"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "srcunpacked"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_detoast_datum_packed",
          "args": [
            "(struct varlena *) src"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "pg_detoast_datum_packed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1948-1955",
          "snippet": "struct varlena *\npg_detoast_datum_packed(struct varlena *datum)\n{\n\tif (VARATT_IS_COMPRESSED(datum) || VARATT_IS_EXTERNAL(datum))\n\t\treturn heap_tuple_untoast_attr(datum);\n\telse\n\t\treturn datum;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nstruct varlena *\npg_detoast_datum_packed(struct varlena *datum)\n{\n\tif (VARATT_IS_COMPRESSED(datum) || VARATT_IS_EXTERNAL(datum))\n\t\treturn heap_tuple_untoast_attr(datum);\n\telse\n\t\treturn datum;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nvoid\ntext_to_cstring_buffer(const text *src, char *dst, size_t dst_len)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *srcunpacked = pg_detoast_datum_packed((struct varlena *) src);\n\tsize_t\t\tsrc_len = VARSIZE_ANY_EXHDR(srcunpacked);\n\n\tif (dst_len > 0)\n\t{\n\t\tdst_len--;\n\t\tif (dst_len >= src_len)\n\t\t\tdst_len = src_len;\n\t\telse\t\t\t\t\t/* ensure truncation is encoding-safe */\n\t\t\tdst_len = pg_mbcliplen(VARDATA_ANY(srcunpacked), src_len, dst_len);\n\t\tmemcpy(dst, VARDATA_ANY(srcunpacked), dst_len);\n\t\tdst[dst_len] = '\\0';\n\t}\n\n\tif (srcunpacked != src)\n\t\tpfree(srcunpacked);\n}"
  },
  {
    "function_name": "text_to_cstring",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "181-197",
    "snippet": "char *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void appendStringInfoText(StringInfo str, const text *t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "tunpacked"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "result",
            "VARDATA_ANY(tunpacked)",
            "len"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "tunpacked"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "len + 1"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "tunpacked"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_detoast_datum_packed",
          "args": [
            "(struct varlena *) t"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "pg_detoast_datum_packed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1948-1955",
          "snippet": "struct varlena *\npg_detoast_datum_packed(struct varlena *datum)\n{\n\tif (VARATT_IS_COMPRESSED(datum) || VARATT_IS_EXTERNAL(datum))\n\t\treturn heap_tuple_untoast_attr(datum);\n\telse\n\t\treturn datum;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nstruct varlena *\npg_detoast_datum_packed(struct varlena *datum)\n{\n\tif (VARATT_IS_COMPRESSED(datum) || VARATT_IS_EXTERNAL(datum))\n\t\treturn heap_tuple_untoast_attr(datum);\n\telse\n\t\treturn datum;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nchar *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}"
  },
  {
    "function_name": "cstring_to_text_with_len",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "160-169",
    "snippet": "text *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "VARDATA(result)",
            "s",
            "len"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA",
          "args": [
            "result"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "result",
            "len + VARHDRSZ"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "len + VARHDRSZ"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}"
  },
  {
    "function_name": "cstring_to_text",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
    "lines": "148-152",
    "snippet": "text *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}",
    "includes": [
      "#include \"levenshtein.c\"",
      "#include \"levenshtein.c\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"regex/regex.h\"",
      "#include \"port/pg_bswap.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"lib/hyperloglog.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cstring_to_text_with_len",
          "args": [
            "s",
            "strlen(s)"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "160-169",
          "snippet": "text *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "s"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}"
  }
]