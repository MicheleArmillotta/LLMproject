[
  {
    "function_name": "RoleidCallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/superuser.c",
    "lines": "103-108",
    "snippet": "static void\nRoleidCallback(Datum arg, int cacheid, uint32 hashvalue)\n{\n\t/* Invalidate our local cache in case role's superuserness changed */\n\tlast_roleid = InvalidOid;\n}",
    "includes": [
      "#include \"miscadmin.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Oid\tlast_roleid = InvalidOid;",
      "static void RoleidCallback(Datum arg, int cacheid, uint32 hashvalue);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/syscache.h\"\n#include \"utils/inval.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic Oid\tlast_roleid = InvalidOid;\nstatic void RoleidCallback(Datum arg, int cacheid, uint32 hashvalue);\n\nstatic void\nRoleidCallback(Datum arg, int cacheid, uint32 hashvalue)\n{\n\t/* Invalidate our local cache in case role's superuserness changed */\n\tlast_roleid = InvalidOid;\n}"
  },
  {
    "function_name": "superuser_arg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/superuser.c",
    "lines": "56-97",
    "snippet": "bool\nsuperuser_arg(Oid roleid)\n{\n\tbool\t\tresult;\n\tHeapTuple\trtup;\n\n\t/* Quick out for cache hit */\n\tif (OidIsValid(last_roleid) && last_roleid == roleid)\n\t\treturn last_roleid_is_super;\n\n\t/* Special escape path in case you deleted all your users. */\n\tif (!IsUnderPostmaster && roleid == BOOTSTRAP_SUPERUSERID)\n\t\treturn true;\n\n\t/* OK, look up the information in pg_authid */\n\trtup = SearchSysCache1(AUTHOID, ObjectIdGetDatum(roleid));\n\tif (HeapTupleIsValid(rtup))\n\t{\n\t\tresult = ((Form_pg_authid) GETSTRUCT(rtup))->rolsuper;\n\t\tReleaseSysCache(rtup);\n\t}\n\telse\n\t{\n\t\t/* Report \"not superuser\" for invalid roleids */\n\t\tresult = false;\n\t}\n\n\t/* If first time through, set up callback for cache flushes */\n\tif (!roleid_callback_registered)\n\t{\n\t\tCacheRegisterSyscacheCallback(AUTHOID,\n\t\t\t\t\t\t\t\t\t  RoleidCallback,\n\t\t\t\t\t\t\t\t\t  (Datum) 0);\n\t\troleid_callback_registered = true;\n\t}\n\n\t/* Cache the result for next time */\n\tlast_roleid = roleid;\n\tlast_roleid_is_super = result;\n\n\treturn result;\n}",
    "includes": [
      "#include \"miscadmin.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Oid\tlast_roleid = InvalidOid;",
      "static bool last_roleid_is_super = false;",
      "static bool roleid_callback_registered = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CacheRegisterSyscacheCallback",
          "args": [
            "AUTHOID",
            "RoleidCallback",
            "(Datum) 0"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "CacheRegisterSyscacheCallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
          "lines": "1425-1456",
          "snippet": "void\nCacheRegisterSyscacheCallback(int cacheid,\n\t\t\t\t\t\t\t  SyscacheCallbackFunction func,\n\t\t\t\t\t\t\t  Datum arg)\n{\n\tif (cacheid < 0 || cacheid >= SysCacheSize)\n\t\telog(FATAL, \"invalid cache ID: %d\", cacheid);\n\tif (syscache_callback_count >= MAX_SYSCACHE_CALLBACKS)\n\t\telog(FATAL, \"out of syscache_callback_list slots\");\n\n\tif (syscache_callback_links[cacheid] == 0)\n\t{\n\t\t/* first callback for this cache */\n\t\tsyscache_callback_links[cacheid] = syscache_callback_count + 1;\n\t}\n\telse\n\t{\n\t\t/* add to end of chain, so that older callbacks are called first */\n\t\tint\t\t\ti = syscache_callback_links[cacheid] - 1;\n\n\t\twhile (syscache_callback_list[i].link > 0)\n\t\t\ti = syscache_callback_list[i].link - 1;\n\t\tsyscache_callback_list[i].link = syscache_callback_count + 1;\n\t}\n\n\tsyscache_callback_list[syscache_callback_count].id = cacheid;\n\tsyscache_callback_list[syscache_callback_count].link = 0;\n\tsyscache_callback_list[syscache_callback_count].function = func;\n\tsyscache_callback_list[syscache_callback_count].arg = arg;\n\n\t++syscache_callback_count;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MAX_SYSCACHE_CALLBACKS 64"
          ],
          "globals_used": [
            "static struct SYSCACHECALLBACK\n{\n\tint16\t\tid;\t\t\t\t/* cache number */\n\tint16\t\tlink;\t\t\t/* next callback index+1 for same cache */\n\tSyscacheCallbackFunction function;\n\tDatum\t\targ;\n}\t\t\tsyscache_callback_list[MAX_SYSCACHE_CALLBACKS];",
            "static int16 syscache_callback_links[SysCacheSize];",
            "static int\tsyscache_callback_count = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define MAX_SYSCACHE_CALLBACKS 64\n\nstatic struct SYSCACHECALLBACK\n{\n\tint16\t\tid;\t\t\t\t/* cache number */\n\tint16\t\tlink;\t\t\t/* next callback index+1 for same cache */\n\tSyscacheCallbackFunction function;\n\tDatum\t\targ;\n}\t\t\tsyscache_callback_list[MAX_SYSCACHE_CALLBACKS];\nstatic int16 syscache_callback_links[SysCacheSize];\nstatic int\tsyscache_callback_count = 0;\n\nvoid\nCacheRegisterSyscacheCallback(int cacheid,\n\t\t\t\t\t\t\t  SyscacheCallbackFunction func,\n\t\t\t\t\t\t\t  Datum arg)\n{\n\tif (cacheid < 0 || cacheid >= SysCacheSize)\n\t\telog(FATAL, \"invalid cache ID: %d\", cacheid);\n\tif (syscache_callback_count >= MAX_SYSCACHE_CALLBACKS)\n\t\telog(FATAL, \"out of syscache_callback_list slots\");\n\n\tif (syscache_callback_links[cacheid] == 0)\n\t{\n\t\t/* first callback for this cache */\n\t\tsyscache_callback_links[cacheid] = syscache_callback_count + 1;\n\t}\n\telse\n\t{\n\t\t/* add to end of chain, so that older callbacks are called first */\n\t\tint\t\t\ti = syscache_callback_links[cacheid] - 1;\n\n\t\twhile (syscache_callback_list[i].link > 0)\n\t\t\ti = syscache_callback_list[i].link - 1;\n\t\tsyscache_callback_list[i].link = syscache_callback_count + 1;\n\t}\n\n\tsyscache_callback_list[syscache_callback_count].id = cacheid;\n\tsyscache_callback_list[syscache_callback_count].link = 0;\n\tsyscache_callback_list[syscache_callback_count].function = func;\n\tsyscache_callback_list[syscache_callback_count].arg = arg;\n\n\t++syscache_callback_count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ReleaseSysCache",
          "args": [
            "rtup"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "ReleaseSysCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1159-1163",
          "snippet": "void\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "rtup"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "rtup"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SearchSysCache1",
          "args": [
            "AUTHOID",
            "ObjectIdGetDatum(roleid)"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "SearchSysCache1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1111-1120",
          "snippet": "HeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nHeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "roleid"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "last_roleid"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/syscache.h\"\n#include \"utils/inval.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic Oid\tlast_roleid = InvalidOid;\nstatic bool last_roleid_is_super = false;\nstatic bool roleid_callback_registered = false;\n\nbool\nsuperuser_arg(Oid roleid)\n{\n\tbool\t\tresult;\n\tHeapTuple\trtup;\n\n\t/* Quick out for cache hit */\n\tif (OidIsValid(last_roleid) && last_roleid == roleid)\n\t\treturn last_roleid_is_super;\n\n\t/* Special escape path in case you deleted all your users. */\n\tif (!IsUnderPostmaster && roleid == BOOTSTRAP_SUPERUSERID)\n\t\treturn true;\n\n\t/* OK, look up the information in pg_authid */\n\trtup = SearchSysCache1(AUTHOID, ObjectIdGetDatum(roleid));\n\tif (HeapTupleIsValid(rtup))\n\t{\n\t\tresult = ((Form_pg_authid) GETSTRUCT(rtup))->rolsuper;\n\t\tReleaseSysCache(rtup);\n\t}\n\telse\n\t{\n\t\t/* Report \"not superuser\" for invalid roleids */\n\t\tresult = false;\n\t}\n\n\t/* If first time through, set up callback for cache flushes */\n\tif (!roleid_callback_registered)\n\t{\n\t\tCacheRegisterSyscacheCallback(AUTHOID,\n\t\t\t\t\t\t\t\t\t  RoleidCallback,\n\t\t\t\t\t\t\t\t\t  (Datum) 0);\n\t\troleid_callback_registered = true;\n\t}\n\n\t/* Cache the result for next time */\n\tlast_roleid = roleid;\n\tlast_roleid_is_super = result;\n\n\treturn result;\n}"
  },
  {
    "function_name": "superuser",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/superuser.c",
    "lines": "46-50",
    "snippet": "bool\nsuperuser(void)\n{\n\treturn superuser_arg(GetUserId());\n}",
    "includes": [
      "#include \"miscadmin.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "superuser_arg",
          "args": [
            "GetUserId()"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "superuser_arg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/superuser.c",
          "lines": "56-97",
          "snippet": "bool\nsuperuser_arg(Oid roleid)\n{\n\tbool\t\tresult;\n\tHeapTuple\trtup;\n\n\t/* Quick out for cache hit */\n\tif (OidIsValid(last_roleid) && last_roleid == roleid)\n\t\treturn last_roleid_is_super;\n\n\t/* Special escape path in case you deleted all your users. */\n\tif (!IsUnderPostmaster && roleid == BOOTSTRAP_SUPERUSERID)\n\t\treturn true;\n\n\t/* OK, look up the information in pg_authid */\n\trtup = SearchSysCache1(AUTHOID, ObjectIdGetDatum(roleid));\n\tif (HeapTupleIsValid(rtup))\n\t{\n\t\tresult = ((Form_pg_authid) GETSTRUCT(rtup))->rolsuper;\n\t\tReleaseSysCache(rtup);\n\t}\n\telse\n\t{\n\t\t/* Report \"not superuser\" for invalid roleids */\n\t\tresult = false;\n\t}\n\n\t/* If first time through, set up callback for cache flushes */\n\tif (!roleid_callback_registered)\n\t{\n\t\tCacheRegisterSyscacheCallback(AUTHOID,\n\t\t\t\t\t\t\t\t\t  RoleidCallback,\n\t\t\t\t\t\t\t\t\t  (Datum) 0);\n\t\troleid_callback_registered = true;\n\t}\n\n\t/* Cache the result for next time */\n\tlast_roleid = roleid;\n\tlast_roleid_is_super = result;\n\n\treturn result;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Oid\tlast_roleid = InvalidOid;",
            "static bool last_roleid_is_super = false;",
            "static bool roleid_callback_registered = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/syscache.h\"\n#include \"utils/inval.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic Oid\tlast_roleid = InvalidOid;\nstatic bool last_roleid_is_super = false;\nstatic bool roleid_callback_registered = false;\n\nbool\nsuperuser_arg(Oid roleid)\n{\n\tbool\t\tresult;\n\tHeapTuple\trtup;\n\n\t/* Quick out for cache hit */\n\tif (OidIsValid(last_roleid) && last_roleid == roleid)\n\t\treturn last_roleid_is_super;\n\n\t/* Special escape path in case you deleted all your users. */\n\tif (!IsUnderPostmaster && roleid == BOOTSTRAP_SUPERUSERID)\n\t\treturn true;\n\n\t/* OK, look up the information in pg_authid */\n\trtup = SearchSysCache1(AUTHOID, ObjectIdGetDatum(roleid));\n\tif (HeapTupleIsValid(rtup))\n\t{\n\t\tresult = ((Form_pg_authid) GETSTRUCT(rtup))->rolsuper;\n\t\tReleaseSysCache(rtup);\n\t}\n\telse\n\t{\n\t\t/* Report \"not superuser\" for invalid roleids */\n\t\tresult = false;\n\t}\n\n\t/* If first time through, set up callback for cache flushes */\n\tif (!roleid_callback_registered)\n\t{\n\t\tCacheRegisterSyscacheCallback(AUTHOID,\n\t\t\t\t\t\t\t\t\t  RoleidCallback,\n\t\t\t\t\t\t\t\t\t  (Datum) 0);\n\t\troleid_callback_registered = true;\n\t}\n\n\t/* Cache the result for next time */\n\tlast_roleid = roleid;\n\tlast_roleid_is_super = result;\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetUserId",
          "args": [],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "GetUserId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
          "lines": "386-391",
          "snippet": "Oid\nGetUserId(void)\n{\n\tAssertState(OidIsValid(CurrentUserId));\n\treturn CurrentUserId;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pidfile.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pg_shmem.h\"",
            "#include \"storage/latch.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/fd.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"common/file_perm.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/htup_details.h\"",
            "#include <utime.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/param.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Oid\tCurrentUserId = InvalidOid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nstatic Oid\tCurrentUserId = InvalidOid;\n\nOid\nGetUserId(void)\n{\n\tAssertState(OidIsValid(CurrentUserId));\n\treturn CurrentUserId;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/syscache.h\"\n#include \"utils/inval.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nbool\nsuperuser(void)\n{\n\treturn superuser_arg(GetUserId());\n}"
  }
]