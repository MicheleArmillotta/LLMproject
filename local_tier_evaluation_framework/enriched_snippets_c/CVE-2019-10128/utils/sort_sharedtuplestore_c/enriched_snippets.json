[
  {
    "function_name": "sts_filename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/sharedtuplestore.c",
    "lines": "629-633",
    "snippet": "static void\nsts_filename(char *name, SharedTuplestoreAccessor *accessor, int participant)\n{\n\tsnprintf(name, MAXPGPATH, \"%s.p%d\", accessor->sts->name, participant);\n}",
    "includes": [
      "#include <limits.h>",
      "#include \"utils/sharedtuplestore.h\"",
      "#include \"storage/sharedfileset.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/buffile.h\"",
      "#include \"miscadmin.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/htup.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void sts_filename(char *name, SharedTuplestoreAccessor *accessor,\n\t\t\t int participant);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "name",
            "MAXPGPATH",
            "\"%s.p%d\"",
            "accessor->sts->name",
            "participant"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include \"utils/sharedtuplestore.h\"\n#include \"storage/sharedfileset.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"access/htup_details.h\"\n#include \"access/htup.h\"\n#include \"postgres.h\"\n\nstatic void sts_filename(char *name, SharedTuplestoreAccessor *accessor,\n\t\t\t int participant);\n\nstatic void\nsts_filename(char *name, SharedTuplestoreAccessor *accessor, int participant)\n{\n\tsnprintf(name, MAXPGPATH, \"%s.p%d\", accessor->sts->name, participant);\n}"
  },
  {
    "function_name": "sts_parallel_scan_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/sharedtuplestore.c",
    "lines": "526-624",
    "snippet": "MinimalTuple\nsts_parallel_scan_next(SharedTuplestoreAccessor *accessor, void *meta_data)\n{\n\tSharedTuplestoreParticipant *p;\n\tBlockNumber read_page;\n\tbool\t\teof;\n\n\tfor (;;)\n\t{\n\t\t/* Can we read more tuples from the current chunk? */\n\t\tif (accessor->read_ntuples < accessor->read_ntuples_available)\n\t\t\treturn sts_read_tuple(accessor, meta_data);\n\n\t\t/* Find the location of a new chunk to read. */\n\t\tp = &accessor->sts->participants[accessor->read_participant];\n\n\t\tLWLockAcquire(&p->lock, LW_EXCLUSIVE);\n\t\t/* We can skip directly past overflow pages we know about. */\n\t\tif (p->read_page < accessor->read_next_page)\n\t\t\tp->read_page = accessor->read_next_page;\n\t\teof = p->read_page >= p->npages;\n\t\tif (!eof)\n\t\t{\n\t\t\t/* Claim the next chunk. */\n\t\t\tread_page = p->read_page;\n\t\t\t/* Advance the read head for the next reader. */\n\t\t\tp->read_page += STS_CHUNK_PAGES;\n\t\t\taccessor->read_next_page = p->read_page;\n\t\t}\n\t\tLWLockRelease(&p->lock);\n\n\t\tif (!eof)\n\t\t{\n\t\t\tSharedTuplestoreChunk chunk_header;\n\n\t\t\t/* Make sure we have the file open. */\n\t\t\tif (accessor->read_file == NULL)\n\t\t\t{\n\t\t\t\tchar\t\tname[MAXPGPATH];\n\n\t\t\t\tsts_filename(name, accessor, accessor->read_participant);\n\t\t\t\taccessor->read_file =\n\t\t\t\t\tBufFileOpenShared(accessor->fileset, name);\n\t\t\t}\n\n\t\t\t/* Seek and load the chunk header. */\n\t\t\tif (BufFileSeekBlock(accessor->read_file, read_page) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not read from shared tuplestore temporary file\"),\n\t\t\t\t\t\t errdetail_internal(\"Could not seek to next block.\")));\n\t\t\tif (BufFileRead(accessor->read_file, &chunk_header,\n\t\t\t\t\t\t\tSTS_CHUNK_HEADER_SIZE) != STS_CHUNK_HEADER_SIZE)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not read from shared tuplestore temporary file\"),\n\t\t\t\t\t\t errdetail_internal(\"Short read while reading chunk header.\")));\n\n\t\t\t/*\n\t\t\t * If this is an overflow chunk, we skip it and any following\n\t\t\t * overflow chunks all at once.\n\t\t\t */\n\t\t\tif (chunk_header.overflow > 0)\n\t\t\t{\n\t\t\t\taccessor->read_next_page = read_page +\n\t\t\t\t\tchunk_header.overflow * STS_CHUNK_PAGES;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\taccessor->read_ntuples = 0;\n\t\t\taccessor->read_ntuples_available = chunk_header.ntuples;\n\t\t\taccessor->read_bytes = STS_CHUNK_HEADER_SIZE;\n\n\t\t\t/* Go around again, so we can get a tuple from this chunk. */\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (accessor->read_file != NULL)\n\t\t\t{\n\t\t\t\tBufFileClose(accessor->read_file);\n\t\t\t\taccessor->read_file = NULL;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Try the next participant's file.  If we've gone full circle,\n\t\t\t * we're done.\n\t\t\t */\n\t\t\taccessor->read_participant = (accessor->read_participant + 1) %\n\t\t\t\taccessor->sts->nparticipants;\n\t\t\tif (accessor->read_participant == accessor->participant)\n\t\t\t\tbreak;\n\t\t\taccessor->read_next_page = 0;\n\n\t\t\t/* Go around again, so we can get a chunk from this file. */\n\t\t}\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include <limits.h>",
      "#include \"utils/sharedtuplestore.h\"",
      "#include \"storage/sharedfileset.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/buffile.h\"",
      "#include \"miscadmin.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/htup.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define STS_CHUNK_HEADER_SIZE offsetof(SharedTuplestoreChunk, data)",
      "#define STS_CHUNK_PAGES 4"
    ],
    "globals_used": [
      "static void sts_filename(char *name, SharedTuplestoreAccessor *accessor,\n\t\t\t int participant);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BufFileClose",
          "args": [
            "accessor->read_file"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not read from shared tuplestore temporary file\"),\n\t\t\t\t\t\t errdetail_internal(\"Short read while reading chunk header.\"))"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errdetail_internal",
          "args": [
            "\"Short read while reading chunk header.\""
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "errdetail_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "897-912",
          "snippet": "int\nerrdetail_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrdetail_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not read from shared tuplestore temporary file\""
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode_for_file_access",
          "args": [],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "errcode_for_file_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "595-655",
          "snippet": "int\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "BufFileRead",
          "args": [
            "accessor->read_file",
            "&chunk_header",
            "STS_CHUNK_HEADER_SIZE"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not read from shared tuplestore temporary file\"),\n\t\t\t\t\t\t errdetail_internal(\"Could not seek to next block.\"))"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BufFileSeekBlock",
          "args": [
            "accessor->read_file",
            "read_page"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BufFileOpenShared",
          "args": [
            "accessor->fileset",
            "name"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sts_filename",
          "args": [
            "name",
            "accessor",
            "accessor->read_participant"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "sts_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/sharedtuplestore.c",
          "lines": "629-633",
          "snippet": "static void\nsts_filename(char *name, SharedTuplestoreAccessor *accessor, int participant)\n{\n\tsnprintf(name, MAXPGPATH, \"%s.p%d\", accessor->sts->name, participant);\n}",
          "includes": [
            "#include <limits.h>",
            "#include \"utils/sharedtuplestore.h\"",
            "#include \"storage/sharedfileset.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"miscadmin.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/htup.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void sts_filename(char *name, SharedTuplestoreAccessor *accessor,\n\t\t\t int participant);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include \"utils/sharedtuplestore.h\"\n#include \"storage/sharedfileset.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"access/htup_details.h\"\n#include \"access/htup.h\"\n#include \"postgres.h\"\n\nstatic void sts_filename(char *name, SharedTuplestoreAccessor *accessor,\n\t\t\t int participant);\n\nstatic void\nsts_filename(char *name, SharedTuplestoreAccessor *accessor, int participant)\n{\n\tsnprintf(name, MAXPGPATH, \"%s.p%d\", accessor->sts->name, participant);\n}"
        }
      },
      {
        "call_info": {
          "callee": "LWLockRelease",
          "args": [
            "&p->lock"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LWLockAcquire",
          "args": [
            "&p->lock",
            "LW_EXCLUSIVE"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sts_read_tuple",
          "args": [
            "accessor",
            "meta_data"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "sts_read_tuple",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/sharedtuplestore.c",
          "lines": "416-521",
          "snippet": "static MinimalTuple\nsts_read_tuple(SharedTuplestoreAccessor *accessor, void *meta_data)\n{\n\tMinimalTuple tuple;\n\tuint32\t\tsize;\n\tsize_t\t\tremaining_size;\n\tsize_t\t\tthis_chunk_size;\n\tchar\t   *destination;\n\n\t/*\n\t * We'll keep track of bytes read from this chunk so that we can detect an\n\t * overflowing tuple and switch to reading overflow pages.\n\t */\n\tif (accessor->sts->meta_data_size > 0)\n\t{\n\t\tif (BufFileRead(accessor->read_file,\n\t\t\t\t\t\tmeta_data,\n\t\t\t\t\t\taccessor->sts->meta_data_size) !=\n\t\t\taccessor->sts->meta_data_size)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not read from shared tuplestore temporary file\"),\n\t\t\t\t\t errdetail_internal(\"Short read while reading meta-data.\")));\n\t\taccessor->read_bytes += accessor->sts->meta_data_size;\n\t}\n\tif (BufFileRead(accessor->read_file,\n\t\t\t\t\t&size,\n\t\t\t\t\tsizeof(size)) != sizeof(size))\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not read from shared tuplestore temporary file\"),\n\t\t\t\t errdetail_internal(\"Short read while reading size.\")));\n\taccessor->read_bytes += sizeof(size);\n\tif (size > accessor->read_buffer_size)\n\t{\n\t\tsize_t\t\tnew_read_buffer_size;\n\n\t\tif (accessor->read_buffer != NULL)\n\t\t\tpfree(accessor->read_buffer);\n\t\tnew_read_buffer_size = Max(size, accessor->read_buffer_size * 2);\n\t\taccessor->read_buffer =\n\t\t\tMemoryContextAlloc(accessor->context, new_read_buffer_size);\n\t\taccessor->read_buffer_size = new_read_buffer_size;\n\t}\n\tremaining_size = size - sizeof(uint32);\n\tthis_chunk_size = Min(remaining_size,\n\t\t\t\t\t\t  BLCKSZ * STS_CHUNK_PAGES - accessor->read_bytes);\n\tdestination = accessor->read_buffer + sizeof(uint32);\n\tif (BufFileRead(accessor->read_file,\n\t\t\t\t\tdestination,\n\t\t\t\t\tthis_chunk_size) != this_chunk_size)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not read from shared tuplestore temporary file\"),\n\t\t\t\t errdetail_internal(\"Short read while reading tuple.\")));\n\taccessor->read_bytes += this_chunk_size;\n\tremaining_size -= this_chunk_size;\n\tdestination += this_chunk_size;\n\t++accessor->read_ntuples;\n\n\t/* Check if we need to read any overflow chunks. */\n\twhile (remaining_size > 0)\n\t{\n\t\t/* We are now positioned at the start of an overflow chunk. */\n\t\tSharedTuplestoreChunk chunk_header;\n\n\t\tif (BufFileRead(accessor->read_file, &chunk_header, STS_CHUNK_HEADER_SIZE) !=\n\t\t\tSTS_CHUNK_HEADER_SIZE)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not read from shared tuplestore temporary file\"),\n\t\t\t\t\t errdetail_internal(\"Short read while reading overflow chunk header.\")));\n\t\taccessor->read_bytes = STS_CHUNK_HEADER_SIZE;\n\t\tif (chunk_header.overflow == 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"unexpected chunk in shared tuplestore temporary file\"),\n\t\t\t\t\t errdetail_internal(\"Expected overflow chunk.\")));\n\t\taccessor->read_next_page += STS_CHUNK_PAGES;\n\t\tthis_chunk_size = Min(remaining_size,\n\t\t\t\t\t\t\t  BLCKSZ * STS_CHUNK_PAGES -\n\t\t\t\t\t\t\t  STS_CHUNK_HEADER_SIZE);\n\t\tif (BufFileRead(accessor->read_file,\n\t\t\t\t\t\tdestination,\n\t\t\t\t\t\tthis_chunk_size) != this_chunk_size)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not read from shared tuplestore temporary file\"),\n\t\t\t\t\t errdetail_internal(\"Short read while reading tuple.\")));\n\t\taccessor->read_bytes += this_chunk_size;\n\t\tremaining_size -= this_chunk_size;\n\t\tdestination += this_chunk_size;\n\n\t\t/*\n\t\t * These will be used to count regular tuples following the oversized\n\t\t * tuple that spilled into this overflow chunk.\n\t\t */\n\t\taccessor->read_ntuples = 0;\n\t\taccessor->read_ntuples_available = chunk_header.ntuples;\n\t}\n\n\ttuple = (MinimalTuple) accessor->read_buffer;\n\ttuple->t_len = size;\n\n\treturn tuple;\n}",
          "includes": [
            "#include <limits.h>",
            "#include \"utils/sharedtuplestore.h\"",
            "#include \"storage/sharedfileset.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"miscadmin.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/htup.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define STS_CHUNK_HEADER_SIZE offsetof(SharedTuplestoreChunk, data)",
            "#define STS_CHUNK_PAGES 4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include \"utils/sharedtuplestore.h\"\n#include \"storage/sharedfileset.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"access/htup_details.h\"\n#include \"access/htup.h\"\n#include \"postgres.h\"\n\n#define STS_CHUNK_HEADER_SIZE offsetof(SharedTuplestoreChunk, data)\n#define STS_CHUNK_PAGES 4\n\nstatic MinimalTuple\nsts_read_tuple(SharedTuplestoreAccessor *accessor, void *meta_data)\n{\n\tMinimalTuple tuple;\n\tuint32\t\tsize;\n\tsize_t\t\tremaining_size;\n\tsize_t\t\tthis_chunk_size;\n\tchar\t   *destination;\n\n\t/*\n\t * We'll keep track of bytes read from this chunk so that we can detect an\n\t * overflowing tuple and switch to reading overflow pages.\n\t */\n\tif (accessor->sts->meta_data_size > 0)\n\t{\n\t\tif (BufFileRead(accessor->read_file,\n\t\t\t\t\t\tmeta_data,\n\t\t\t\t\t\taccessor->sts->meta_data_size) !=\n\t\t\taccessor->sts->meta_data_size)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not read from shared tuplestore temporary file\"),\n\t\t\t\t\t errdetail_internal(\"Short read while reading meta-data.\")));\n\t\taccessor->read_bytes += accessor->sts->meta_data_size;\n\t}\n\tif (BufFileRead(accessor->read_file,\n\t\t\t\t\t&size,\n\t\t\t\t\tsizeof(size)) != sizeof(size))\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not read from shared tuplestore temporary file\"),\n\t\t\t\t errdetail_internal(\"Short read while reading size.\")));\n\taccessor->read_bytes += sizeof(size);\n\tif (size > accessor->read_buffer_size)\n\t{\n\t\tsize_t\t\tnew_read_buffer_size;\n\n\t\tif (accessor->read_buffer != NULL)\n\t\t\tpfree(accessor->read_buffer);\n\t\tnew_read_buffer_size = Max(size, accessor->read_buffer_size * 2);\n\t\taccessor->read_buffer =\n\t\t\tMemoryContextAlloc(accessor->context, new_read_buffer_size);\n\t\taccessor->read_buffer_size = new_read_buffer_size;\n\t}\n\tremaining_size = size - sizeof(uint32);\n\tthis_chunk_size = Min(remaining_size,\n\t\t\t\t\t\t  BLCKSZ * STS_CHUNK_PAGES - accessor->read_bytes);\n\tdestination = accessor->read_buffer + sizeof(uint32);\n\tif (BufFileRead(accessor->read_file,\n\t\t\t\t\tdestination,\n\t\t\t\t\tthis_chunk_size) != this_chunk_size)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not read from shared tuplestore temporary file\"),\n\t\t\t\t errdetail_internal(\"Short read while reading tuple.\")));\n\taccessor->read_bytes += this_chunk_size;\n\tremaining_size -= this_chunk_size;\n\tdestination += this_chunk_size;\n\t++accessor->read_ntuples;\n\n\t/* Check if we need to read any overflow chunks. */\n\twhile (remaining_size > 0)\n\t{\n\t\t/* We are now positioned at the start of an overflow chunk. */\n\t\tSharedTuplestoreChunk chunk_header;\n\n\t\tif (BufFileRead(accessor->read_file, &chunk_header, STS_CHUNK_HEADER_SIZE) !=\n\t\t\tSTS_CHUNK_HEADER_SIZE)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not read from shared tuplestore temporary file\"),\n\t\t\t\t\t errdetail_internal(\"Short read while reading overflow chunk header.\")));\n\t\taccessor->read_bytes = STS_CHUNK_HEADER_SIZE;\n\t\tif (chunk_header.overflow == 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"unexpected chunk in shared tuplestore temporary file\"),\n\t\t\t\t\t errdetail_internal(\"Expected overflow chunk.\")));\n\t\taccessor->read_next_page += STS_CHUNK_PAGES;\n\t\tthis_chunk_size = Min(remaining_size,\n\t\t\t\t\t\t\t  BLCKSZ * STS_CHUNK_PAGES -\n\t\t\t\t\t\t\t  STS_CHUNK_HEADER_SIZE);\n\t\tif (BufFileRead(accessor->read_file,\n\t\t\t\t\t\tdestination,\n\t\t\t\t\t\tthis_chunk_size) != this_chunk_size)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not read from shared tuplestore temporary file\"),\n\t\t\t\t\t errdetail_internal(\"Short read while reading tuple.\")));\n\t\taccessor->read_bytes += this_chunk_size;\n\t\tremaining_size -= this_chunk_size;\n\t\tdestination += this_chunk_size;\n\n\t\t/*\n\t\t * These will be used to count regular tuples following the oversized\n\t\t * tuple that spilled into this overflow chunk.\n\t\t */\n\t\taccessor->read_ntuples = 0;\n\t\taccessor->read_ntuples_available = chunk_header.ntuples;\n\t}\n\n\ttuple = (MinimalTuple) accessor->read_buffer;\n\ttuple->t_len = size;\n\n\treturn tuple;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include \"utils/sharedtuplestore.h\"\n#include \"storage/sharedfileset.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"access/htup_details.h\"\n#include \"access/htup.h\"\n#include \"postgres.h\"\n\n#define STS_CHUNK_HEADER_SIZE offsetof(SharedTuplestoreChunk, data)\n#define STS_CHUNK_PAGES 4\n\nstatic void sts_filename(char *name, SharedTuplestoreAccessor *accessor,\n\t\t\t int participant);\n\nMinimalTuple\nsts_parallel_scan_next(SharedTuplestoreAccessor *accessor, void *meta_data)\n{\n\tSharedTuplestoreParticipant *p;\n\tBlockNumber read_page;\n\tbool\t\teof;\n\n\tfor (;;)\n\t{\n\t\t/* Can we read more tuples from the current chunk? */\n\t\tif (accessor->read_ntuples < accessor->read_ntuples_available)\n\t\t\treturn sts_read_tuple(accessor, meta_data);\n\n\t\t/* Find the location of a new chunk to read. */\n\t\tp = &accessor->sts->participants[accessor->read_participant];\n\n\t\tLWLockAcquire(&p->lock, LW_EXCLUSIVE);\n\t\t/* We can skip directly past overflow pages we know about. */\n\t\tif (p->read_page < accessor->read_next_page)\n\t\t\tp->read_page = accessor->read_next_page;\n\t\teof = p->read_page >= p->npages;\n\t\tif (!eof)\n\t\t{\n\t\t\t/* Claim the next chunk. */\n\t\t\tread_page = p->read_page;\n\t\t\t/* Advance the read head for the next reader. */\n\t\t\tp->read_page += STS_CHUNK_PAGES;\n\t\t\taccessor->read_next_page = p->read_page;\n\t\t}\n\t\tLWLockRelease(&p->lock);\n\n\t\tif (!eof)\n\t\t{\n\t\t\tSharedTuplestoreChunk chunk_header;\n\n\t\t\t/* Make sure we have the file open. */\n\t\t\tif (accessor->read_file == NULL)\n\t\t\t{\n\t\t\t\tchar\t\tname[MAXPGPATH];\n\n\t\t\t\tsts_filename(name, accessor, accessor->read_participant);\n\t\t\t\taccessor->read_file =\n\t\t\t\t\tBufFileOpenShared(accessor->fileset, name);\n\t\t\t}\n\n\t\t\t/* Seek and load the chunk header. */\n\t\t\tif (BufFileSeekBlock(accessor->read_file, read_page) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not read from shared tuplestore temporary file\"),\n\t\t\t\t\t\t errdetail_internal(\"Could not seek to next block.\")));\n\t\t\tif (BufFileRead(accessor->read_file, &chunk_header,\n\t\t\t\t\t\t\tSTS_CHUNK_HEADER_SIZE) != STS_CHUNK_HEADER_SIZE)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not read from shared tuplestore temporary file\"),\n\t\t\t\t\t\t errdetail_internal(\"Short read while reading chunk header.\")));\n\n\t\t\t/*\n\t\t\t * If this is an overflow chunk, we skip it and any following\n\t\t\t * overflow chunks all at once.\n\t\t\t */\n\t\t\tif (chunk_header.overflow > 0)\n\t\t\t{\n\t\t\t\taccessor->read_next_page = read_page +\n\t\t\t\t\tchunk_header.overflow * STS_CHUNK_PAGES;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\taccessor->read_ntuples = 0;\n\t\t\taccessor->read_ntuples_available = chunk_header.ntuples;\n\t\t\taccessor->read_bytes = STS_CHUNK_HEADER_SIZE;\n\n\t\t\t/* Go around again, so we can get a tuple from this chunk. */\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (accessor->read_file != NULL)\n\t\t\t{\n\t\t\t\tBufFileClose(accessor->read_file);\n\t\t\t\taccessor->read_file = NULL;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Try the next participant's file.  If we've gone full circle,\n\t\t\t * we're done.\n\t\t\t */\n\t\t\taccessor->read_participant = (accessor->read_participant + 1) %\n\t\t\t\taccessor->sts->nparticipants;\n\t\t\tif (accessor->read_participant == accessor->participant)\n\t\t\t\tbreak;\n\t\t\taccessor->read_next_page = 0;\n\n\t\t\t/* Go around again, so we can get a chunk from this file. */\n\t\t}\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "sts_read_tuple",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/sharedtuplestore.c",
    "lines": "416-521",
    "snippet": "static MinimalTuple\nsts_read_tuple(SharedTuplestoreAccessor *accessor, void *meta_data)\n{\n\tMinimalTuple tuple;\n\tuint32\t\tsize;\n\tsize_t\t\tremaining_size;\n\tsize_t\t\tthis_chunk_size;\n\tchar\t   *destination;\n\n\t/*\n\t * We'll keep track of bytes read from this chunk so that we can detect an\n\t * overflowing tuple and switch to reading overflow pages.\n\t */\n\tif (accessor->sts->meta_data_size > 0)\n\t{\n\t\tif (BufFileRead(accessor->read_file,\n\t\t\t\t\t\tmeta_data,\n\t\t\t\t\t\taccessor->sts->meta_data_size) !=\n\t\t\taccessor->sts->meta_data_size)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not read from shared tuplestore temporary file\"),\n\t\t\t\t\t errdetail_internal(\"Short read while reading meta-data.\")));\n\t\taccessor->read_bytes += accessor->sts->meta_data_size;\n\t}\n\tif (BufFileRead(accessor->read_file,\n\t\t\t\t\t&size,\n\t\t\t\t\tsizeof(size)) != sizeof(size))\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not read from shared tuplestore temporary file\"),\n\t\t\t\t errdetail_internal(\"Short read while reading size.\")));\n\taccessor->read_bytes += sizeof(size);\n\tif (size > accessor->read_buffer_size)\n\t{\n\t\tsize_t\t\tnew_read_buffer_size;\n\n\t\tif (accessor->read_buffer != NULL)\n\t\t\tpfree(accessor->read_buffer);\n\t\tnew_read_buffer_size = Max(size, accessor->read_buffer_size * 2);\n\t\taccessor->read_buffer =\n\t\t\tMemoryContextAlloc(accessor->context, new_read_buffer_size);\n\t\taccessor->read_buffer_size = new_read_buffer_size;\n\t}\n\tremaining_size = size - sizeof(uint32);\n\tthis_chunk_size = Min(remaining_size,\n\t\t\t\t\t\t  BLCKSZ * STS_CHUNK_PAGES - accessor->read_bytes);\n\tdestination = accessor->read_buffer + sizeof(uint32);\n\tif (BufFileRead(accessor->read_file,\n\t\t\t\t\tdestination,\n\t\t\t\t\tthis_chunk_size) != this_chunk_size)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not read from shared tuplestore temporary file\"),\n\t\t\t\t errdetail_internal(\"Short read while reading tuple.\")));\n\taccessor->read_bytes += this_chunk_size;\n\tremaining_size -= this_chunk_size;\n\tdestination += this_chunk_size;\n\t++accessor->read_ntuples;\n\n\t/* Check if we need to read any overflow chunks. */\n\twhile (remaining_size > 0)\n\t{\n\t\t/* We are now positioned at the start of an overflow chunk. */\n\t\tSharedTuplestoreChunk chunk_header;\n\n\t\tif (BufFileRead(accessor->read_file, &chunk_header, STS_CHUNK_HEADER_SIZE) !=\n\t\t\tSTS_CHUNK_HEADER_SIZE)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not read from shared tuplestore temporary file\"),\n\t\t\t\t\t errdetail_internal(\"Short read while reading overflow chunk header.\")));\n\t\taccessor->read_bytes = STS_CHUNK_HEADER_SIZE;\n\t\tif (chunk_header.overflow == 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"unexpected chunk in shared tuplestore temporary file\"),\n\t\t\t\t\t errdetail_internal(\"Expected overflow chunk.\")));\n\t\taccessor->read_next_page += STS_CHUNK_PAGES;\n\t\tthis_chunk_size = Min(remaining_size,\n\t\t\t\t\t\t\t  BLCKSZ * STS_CHUNK_PAGES -\n\t\t\t\t\t\t\t  STS_CHUNK_HEADER_SIZE);\n\t\tif (BufFileRead(accessor->read_file,\n\t\t\t\t\t\tdestination,\n\t\t\t\t\t\tthis_chunk_size) != this_chunk_size)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not read from shared tuplestore temporary file\"),\n\t\t\t\t\t errdetail_internal(\"Short read while reading tuple.\")));\n\t\taccessor->read_bytes += this_chunk_size;\n\t\tremaining_size -= this_chunk_size;\n\t\tdestination += this_chunk_size;\n\n\t\t/*\n\t\t * These will be used to count regular tuples following the oversized\n\t\t * tuple that spilled into this overflow chunk.\n\t\t */\n\t\taccessor->read_ntuples = 0;\n\t\taccessor->read_ntuples_available = chunk_header.ntuples;\n\t}\n\n\ttuple = (MinimalTuple) accessor->read_buffer;\n\ttuple->t_len = size;\n\n\treturn tuple;\n}",
    "includes": [
      "#include <limits.h>",
      "#include \"utils/sharedtuplestore.h\"",
      "#include \"storage/sharedfileset.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/buffile.h\"",
      "#include \"miscadmin.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/htup.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define STS_CHUNK_HEADER_SIZE offsetof(SharedTuplestoreChunk, data)",
      "#define STS_CHUNK_PAGES 4"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not read from shared tuplestore temporary file\"),\n\t\t\t\t\t errdetail_internal(\"Short read while reading tuple.\"))"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errdetail_internal",
          "args": [
            "\"Short read while reading tuple.\""
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "errdetail_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "897-912",
          "snippet": "int\nerrdetail_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrdetail_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not read from shared tuplestore temporary file\""
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode_for_file_access",
          "args": [],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "errcode_for_file_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "595-655",
          "snippet": "int\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "BufFileRead",
          "args": [
            "accessor->read_file",
            "destination",
            "this_chunk_size"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "remaining_size",
            "BLCKSZ * STS_CHUNK_PAGES -\n\t\t\t\t\t\t\t  STS_CHUNK_HEADER_SIZE"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"unexpected chunk in shared tuplestore temporary file\"),\n\t\t\t\t\t errdetail_internal(\"Expected overflow chunk.\"))"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not read from shared tuplestore temporary file\"),\n\t\t\t\t\t errdetail_internal(\"Short read while reading overflow chunk header.\"))"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BufFileRead",
          "args": [
            "accessor->read_file",
            "&chunk_header",
            "STS_CHUNK_HEADER_SIZE"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not read from shared tuplestore temporary file\"),\n\t\t\t\t errdetail_internal(\"Short read while reading tuple.\"))"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BufFileRead",
          "args": [
            "accessor->read_file",
            "destination",
            "this_chunk_size"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "remaining_size",
            "BLCKSZ * STS_CHUNK_PAGES - accessor->read_bytes"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextAlloc",
          "args": [
            "accessor->context",
            "new_read_buffer_size"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1079-1106",
          "snippet": "void *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Max",
          "args": [
            "size",
            "accessor->read_buffer_size * 2"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "accessor->read_buffer"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not read from shared tuplestore temporary file\"),\n\t\t\t\t errdetail_internal(\"Short read while reading size.\"))"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BufFileRead",
          "args": [
            "accessor->read_file",
            "&size",
            "sizeof(size)"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not read from shared tuplestore temporary file\"),\n\t\t\t\t\t errdetail_internal(\"Short read while reading meta-data.\"))"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BufFileRead",
          "args": [
            "accessor->read_file",
            "meta_data",
            "accessor->sts->meta_data_size"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include \"utils/sharedtuplestore.h\"\n#include \"storage/sharedfileset.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"access/htup_details.h\"\n#include \"access/htup.h\"\n#include \"postgres.h\"\n\n#define STS_CHUNK_HEADER_SIZE offsetof(SharedTuplestoreChunk, data)\n#define STS_CHUNK_PAGES 4\n\nstatic MinimalTuple\nsts_read_tuple(SharedTuplestoreAccessor *accessor, void *meta_data)\n{\n\tMinimalTuple tuple;\n\tuint32\t\tsize;\n\tsize_t\t\tremaining_size;\n\tsize_t\t\tthis_chunk_size;\n\tchar\t   *destination;\n\n\t/*\n\t * We'll keep track of bytes read from this chunk so that we can detect an\n\t * overflowing tuple and switch to reading overflow pages.\n\t */\n\tif (accessor->sts->meta_data_size > 0)\n\t{\n\t\tif (BufFileRead(accessor->read_file,\n\t\t\t\t\t\tmeta_data,\n\t\t\t\t\t\taccessor->sts->meta_data_size) !=\n\t\t\taccessor->sts->meta_data_size)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not read from shared tuplestore temporary file\"),\n\t\t\t\t\t errdetail_internal(\"Short read while reading meta-data.\")));\n\t\taccessor->read_bytes += accessor->sts->meta_data_size;\n\t}\n\tif (BufFileRead(accessor->read_file,\n\t\t\t\t\t&size,\n\t\t\t\t\tsizeof(size)) != sizeof(size))\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not read from shared tuplestore temporary file\"),\n\t\t\t\t errdetail_internal(\"Short read while reading size.\")));\n\taccessor->read_bytes += sizeof(size);\n\tif (size > accessor->read_buffer_size)\n\t{\n\t\tsize_t\t\tnew_read_buffer_size;\n\n\t\tif (accessor->read_buffer != NULL)\n\t\t\tpfree(accessor->read_buffer);\n\t\tnew_read_buffer_size = Max(size, accessor->read_buffer_size * 2);\n\t\taccessor->read_buffer =\n\t\t\tMemoryContextAlloc(accessor->context, new_read_buffer_size);\n\t\taccessor->read_buffer_size = new_read_buffer_size;\n\t}\n\tremaining_size = size - sizeof(uint32);\n\tthis_chunk_size = Min(remaining_size,\n\t\t\t\t\t\t  BLCKSZ * STS_CHUNK_PAGES - accessor->read_bytes);\n\tdestination = accessor->read_buffer + sizeof(uint32);\n\tif (BufFileRead(accessor->read_file,\n\t\t\t\t\tdestination,\n\t\t\t\t\tthis_chunk_size) != this_chunk_size)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not read from shared tuplestore temporary file\"),\n\t\t\t\t errdetail_internal(\"Short read while reading tuple.\")));\n\taccessor->read_bytes += this_chunk_size;\n\tremaining_size -= this_chunk_size;\n\tdestination += this_chunk_size;\n\t++accessor->read_ntuples;\n\n\t/* Check if we need to read any overflow chunks. */\n\twhile (remaining_size > 0)\n\t{\n\t\t/* We are now positioned at the start of an overflow chunk. */\n\t\tSharedTuplestoreChunk chunk_header;\n\n\t\tif (BufFileRead(accessor->read_file, &chunk_header, STS_CHUNK_HEADER_SIZE) !=\n\t\t\tSTS_CHUNK_HEADER_SIZE)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not read from shared tuplestore temporary file\"),\n\t\t\t\t\t errdetail_internal(\"Short read while reading overflow chunk header.\")));\n\t\taccessor->read_bytes = STS_CHUNK_HEADER_SIZE;\n\t\tif (chunk_header.overflow == 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"unexpected chunk in shared tuplestore temporary file\"),\n\t\t\t\t\t errdetail_internal(\"Expected overflow chunk.\")));\n\t\taccessor->read_next_page += STS_CHUNK_PAGES;\n\t\tthis_chunk_size = Min(remaining_size,\n\t\t\t\t\t\t\t  BLCKSZ * STS_CHUNK_PAGES -\n\t\t\t\t\t\t\t  STS_CHUNK_HEADER_SIZE);\n\t\tif (BufFileRead(accessor->read_file,\n\t\t\t\t\t\tdestination,\n\t\t\t\t\t\tthis_chunk_size) != this_chunk_size)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not read from shared tuplestore temporary file\"),\n\t\t\t\t\t errdetail_internal(\"Short read while reading tuple.\")));\n\t\taccessor->read_bytes += this_chunk_size;\n\t\tremaining_size -= this_chunk_size;\n\t\tdestination += this_chunk_size;\n\n\t\t/*\n\t\t * These will be used to count regular tuples following the oversized\n\t\t * tuple that spilled into this overflow chunk.\n\t\t */\n\t\taccessor->read_ntuples = 0;\n\t\taccessor->read_ntuples_available = chunk_header.ntuples;\n\t}\n\n\ttuple = (MinimalTuple) accessor->read_buffer;\n\ttuple->t_len = size;\n\n\treturn tuple;\n}"
  },
  {
    "function_name": "sts_puttuple",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/sharedtuplestore.c",
    "lines": "306-414",
    "snippet": "void\nsts_puttuple(SharedTuplestoreAccessor *accessor, void *meta_data,\n\t\t\t MinimalTuple tuple)\n{\n\tsize_t\t\tsize;\n\n\t/* Do we have our own file yet? */\n\tif (accessor->write_file == NULL)\n\t{\n\t\tSharedTuplestoreParticipant *participant;\n\t\tchar\t\tname[MAXPGPATH];\n\n\t\t/* Create one.  Only this backend will write into it. */\n\t\tsts_filename(name, accessor, accessor->participant);\n\t\taccessor->write_file = BufFileCreateShared(accessor->fileset, name);\n\n\t\t/* Set up the shared state for this backend's file. */\n\t\tparticipant = &accessor->sts->participants[accessor->participant];\n\t\tparticipant->writing = true;\t/* for assertions only */\n\t}\n\n\t/* Do we have space? */\n\tsize = accessor->sts->meta_data_size + tuple->t_len;\n\tif (accessor->write_pointer + size >= accessor->write_end)\n\t{\n\t\tif (accessor->write_chunk == NULL)\n\t\t{\n\t\t\t/* First time through.  Allocate chunk. */\n\t\t\taccessor->write_chunk = (SharedTuplestoreChunk *)\n\t\t\t\tMemoryContextAllocZero(accessor->context,\n\t\t\t\t\t\t\t\t\t   STS_CHUNK_PAGES * BLCKSZ);\n\t\t\taccessor->write_chunk->ntuples = 0;\n\t\t\taccessor->write_pointer = &accessor->write_chunk->data[0];\n\t\t\taccessor->write_end = (char *)\n\t\t\t\taccessor->write_chunk + STS_CHUNK_PAGES * BLCKSZ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* See if flushing helps. */\n\t\t\tsts_flush_chunk(accessor);\n\t\t}\n\n\t\t/* It may still not be enough in the case of a gigantic tuple. */\n\t\tif (accessor->write_pointer + size >= accessor->write_end)\n\t\t{\n\t\t\tsize_t\t\twritten;\n\n\t\t\t/*\n\t\t\t * We'll write the beginning of the oversized tuple, and then\n\t\t\t * write the rest in some number of 'overflow' chunks.\n\t\t\t *\n\t\t\t * sts_initialize() verifies that the size of the tuple +\n\t\t\t * meta-data always fits into a chunk. Because the chunk has been\n\t\t\t * flushed above, we can be sure to have all of a chunk's usable\n\t\t\t * space available.\n\t\t\t */\n\t\t\tAssert(accessor->write_pointer + accessor->sts->meta_data_size +\n\t\t\t\t   sizeof(uint32) < accessor->write_end);\n\n\t\t\t/* Write the meta-data as one chunk. */\n\t\t\tif (accessor->sts->meta_data_size > 0)\n\t\t\t\tmemcpy(accessor->write_pointer, meta_data,\n\t\t\t\t\t   accessor->sts->meta_data_size);\n\n\t\t\t/*\n\t\t\t * Write as much of the tuple as we can fit. This includes the\n\t\t\t * tuple's size at the start.\n\t\t\t */\n\t\t\twritten = accessor->write_end - accessor->write_pointer -\n\t\t\t\taccessor->sts->meta_data_size;\n\t\t\tmemcpy(accessor->write_pointer + accessor->sts->meta_data_size,\n\t\t\t\t   tuple, written);\n\t\t\t++accessor->write_chunk->ntuples;\n\t\t\tsize -= accessor->sts->meta_data_size;\n\t\t\tsize -= written;\n\t\t\t/* Now write as many overflow chunks as we need for the rest. */\n\t\t\twhile (size > 0)\n\t\t\t{\n\t\t\t\tsize_t\t\twritten_this_chunk;\n\n\t\t\t\tsts_flush_chunk(accessor);\n\n\t\t\t\t/*\n\t\t\t\t * How many overflow chunks to go?  This will allow readers to\n\t\t\t\t * skip all of them at once instead of reading each one.\n\t\t\t\t */\n\t\t\t\taccessor->write_chunk->overflow = (size + STS_CHUNK_DATA_SIZE - 1) /\n\t\t\t\t\tSTS_CHUNK_DATA_SIZE;\n\t\t\t\twritten_this_chunk =\n\t\t\t\t\tMin(accessor->write_end - accessor->write_pointer, size);\n\t\t\t\tmemcpy(accessor->write_pointer, (char *) tuple + written,\n\t\t\t\t\t   written_this_chunk);\n\t\t\t\taccessor->write_pointer += written_this_chunk;\n\t\t\t\tsize -= written_this_chunk;\n\t\t\t\twritten += written_this_chunk;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Copy meta-data and tuple into buffer. */\n\tif (accessor->sts->meta_data_size > 0)\n\t\tmemcpy(accessor->write_pointer, meta_data,\n\t\t\t   accessor->sts->meta_data_size);\n\tmemcpy(accessor->write_pointer + accessor->sts->meta_data_size, tuple,\n\t\t   tuple->t_len);\n\taccessor->write_pointer += size;\n\t++accessor->write_chunk->ntuples;\n}",
    "includes": [
      "#include <limits.h>",
      "#include \"utils/sharedtuplestore.h\"",
      "#include \"storage/sharedfileset.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/buffile.h\"",
      "#include \"miscadmin.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/htup.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define STS_CHUNK_DATA_SIZE (STS_CHUNK_PAGES * BLCKSZ - STS_CHUNK_HEADER_SIZE)",
      "#define STS_CHUNK_PAGES 4"
    ],
    "globals_used": [
      "static void sts_filename(char *name, SharedTuplestoreAccessor *accessor,\n\t\t\t int participant);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "accessor->write_pointer + accessor->sts->meta_data_size",
            "tuple",
            "tuple->t_len"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "accessor->write_pointer",
            "meta_data",
            "accessor->sts->meta_data_size"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "accessor->write_pointer",
            "(char *) tuple + written",
            "written_this_chunk"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "accessor->write_end - accessor->write_pointer",
            "size"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sts_flush_chunk",
          "args": [
            "accessor"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "sts_flush_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/sharedtuplestore.c",
          "lines": "197-213",
          "snippet": "static void\nsts_flush_chunk(SharedTuplestoreAccessor *accessor)\n{\n\tsize_t\t\tsize;\n\tsize_t\t\twritten;\n\n\tsize = STS_CHUNK_PAGES * BLCKSZ;\n\twritten = BufFileWrite(accessor->write_file, accessor->write_chunk, size);\n\tif (written != size)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write to temporary file: %m\")));\n\tmemset(accessor->write_chunk, 0, size);\n\taccessor->write_pointer = &accessor->write_chunk->data[0];\n\taccessor->sts->participants[accessor->participant].npages +=\n\t\tSTS_CHUNK_PAGES;\n}",
          "includes": [
            "#include <limits.h>",
            "#include \"utils/sharedtuplestore.h\"",
            "#include \"storage/sharedfileset.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"miscadmin.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/htup.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define STS_CHUNK_PAGES 4"
          ],
          "globals_used": [
            "static void sts_filename(char *name, SharedTuplestoreAccessor *accessor,\n\t\t\t int participant);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include \"utils/sharedtuplestore.h\"\n#include \"storage/sharedfileset.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"access/htup_details.h\"\n#include \"access/htup.h\"\n#include \"postgres.h\"\n\n#define STS_CHUNK_PAGES 4\n\nstatic void sts_filename(char *name, SharedTuplestoreAccessor *accessor,\n\t\t\t int participant);\n\nstatic void\nsts_flush_chunk(SharedTuplestoreAccessor *accessor)\n{\n\tsize_t\t\tsize;\n\tsize_t\t\twritten;\n\n\tsize = STS_CHUNK_PAGES * BLCKSZ;\n\twritten = BufFileWrite(accessor->write_file, accessor->write_chunk, size);\n\tif (written != size)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write to temporary file: %m\")));\n\tmemset(accessor->write_chunk, 0, size);\n\taccessor->write_pointer = &accessor->write_chunk->data[0];\n\taccessor->sts->participants[accessor->participant].npages +=\n\t\tSTS_CHUNK_PAGES;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "accessor->write_pointer + accessor->sts->meta_data_size",
            "tuple",
            "written"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "accessor->write_pointer",
            "meta_data",
            "accessor->sts->meta_data_size"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "accessor->write_pointer + accessor->sts->meta_data_size +\n\t\t\t\t   sizeof(uint32) < accessor->write_end"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextAllocZero",
          "args": [
            "accessor->context",
            "STS_CHUNK_PAGES * BLCKSZ"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocZeroAligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "851-880",
          "snippet": "void *\nMemoryContextAllocZeroAligned(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetLoop(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocZeroAligned(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetLoop(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BufFileCreateShared",
          "args": [
            "accessor->fileset",
            "name"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sts_filename",
          "args": [
            "name",
            "accessor",
            "accessor->participant"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "sts_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/sharedtuplestore.c",
          "lines": "629-633",
          "snippet": "static void\nsts_filename(char *name, SharedTuplestoreAccessor *accessor, int participant)\n{\n\tsnprintf(name, MAXPGPATH, \"%s.p%d\", accessor->sts->name, participant);\n}",
          "includes": [
            "#include <limits.h>",
            "#include \"utils/sharedtuplestore.h\"",
            "#include \"storage/sharedfileset.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"miscadmin.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/htup.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void sts_filename(char *name, SharedTuplestoreAccessor *accessor,\n\t\t\t int participant);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include \"utils/sharedtuplestore.h\"\n#include \"storage/sharedfileset.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"access/htup_details.h\"\n#include \"access/htup.h\"\n#include \"postgres.h\"\n\nstatic void sts_filename(char *name, SharedTuplestoreAccessor *accessor,\n\t\t\t int participant);\n\nstatic void\nsts_filename(char *name, SharedTuplestoreAccessor *accessor, int participant)\n{\n\tsnprintf(name, MAXPGPATH, \"%s.p%d\", accessor->sts->name, participant);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include \"utils/sharedtuplestore.h\"\n#include \"storage/sharedfileset.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"access/htup_details.h\"\n#include \"access/htup.h\"\n#include \"postgres.h\"\n\n#define STS_CHUNK_DATA_SIZE (STS_CHUNK_PAGES * BLCKSZ - STS_CHUNK_HEADER_SIZE)\n#define STS_CHUNK_PAGES 4\n\nstatic void sts_filename(char *name, SharedTuplestoreAccessor *accessor,\n\t\t\t int participant);\n\nvoid\nsts_puttuple(SharedTuplestoreAccessor *accessor, void *meta_data,\n\t\t\t MinimalTuple tuple)\n{\n\tsize_t\t\tsize;\n\n\t/* Do we have our own file yet? */\n\tif (accessor->write_file == NULL)\n\t{\n\t\tSharedTuplestoreParticipant *participant;\n\t\tchar\t\tname[MAXPGPATH];\n\n\t\t/* Create one.  Only this backend will write into it. */\n\t\tsts_filename(name, accessor, accessor->participant);\n\t\taccessor->write_file = BufFileCreateShared(accessor->fileset, name);\n\n\t\t/* Set up the shared state for this backend's file. */\n\t\tparticipant = &accessor->sts->participants[accessor->participant];\n\t\tparticipant->writing = true;\t/* for assertions only */\n\t}\n\n\t/* Do we have space? */\n\tsize = accessor->sts->meta_data_size + tuple->t_len;\n\tif (accessor->write_pointer + size >= accessor->write_end)\n\t{\n\t\tif (accessor->write_chunk == NULL)\n\t\t{\n\t\t\t/* First time through.  Allocate chunk. */\n\t\t\taccessor->write_chunk = (SharedTuplestoreChunk *)\n\t\t\t\tMemoryContextAllocZero(accessor->context,\n\t\t\t\t\t\t\t\t\t   STS_CHUNK_PAGES * BLCKSZ);\n\t\t\taccessor->write_chunk->ntuples = 0;\n\t\t\taccessor->write_pointer = &accessor->write_chunk->data[0];\n\t\t\taccessor->write_end = (char *)\n\t\t\t\taccessor->write_chunk + STS_CHUNK_PAGES * BLCKSZ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* See if flushing helps. */\n\t\t\tsts_flush_chunk(accessor);\n\t\t}\n\n\t\t/* It may still not be enough in the case of a gigantic tuple. */\n\t\tif (accessor->write_pointer + size >= accessor->write_end)\n\t\t{\n\t\t\tsize_t\t\twritten;\n\n\t\t\t/*\n\t\t\t * We'll write the beginning of the oversized tuple, and then\n\t\t\t * write the rest in some number of 'overflow' chunks.\n\t\t\t *\n\t\t\t * sts_initialize() verifies that the size of the tuple +\n\t\t\t * meta-data always fits into a chunk. Because the chunk has been\n\t\t\t * flushed above, we can be sure to have all of a chunk's usable\n\t\t\t * space available.\n\t\t\t */\n\t\t\tAssert(accessor->write_pointer + accessor->sts->meta_data_size +\n\t\t\t\t   sizeof(uint32) < accessor->write_end);\n\n\t\t\t/* Write the meta-data as one chunk. */\n\t\t\tif (accessor->sts->meta_data_size > 0)\n\t\t\t\tmemcpy(accessor->write_pointer, meta_data,\n\t\t\t\t\t   accessor->sts->meta_data_size);\n\n\t\t\t/*\n\t\t\t * Write as much of the tuple as we can fit. This includes the\n\t\t\t * tuple's size at the start.\n\t\t\t */\n\t\t\twritten = accessor->write_end - accessor->write_pointer -\n\t\t\t\taccessor->sts->meta_data_size;\n\t\t\tmemcpy(accessor->write_pointer + accessor->sts->meta_data_size,\n\t\t\t\t   tuple, written);\n\t\t\t++accessor->write_chunk->ntuples;\n\t\t\tsize -= accessor->sts->meta_data_size;\n\t\t\tsize -= written;\n\t\t\t/* Now write as many overflow chunks as we need for the rest. */\n\t\t\twhile (size > 0)\n\t\t\t{\n\t\t\t\tsize_t\t\twritten_this_chunk;\n\n\t\t\t\tsts_flush_chunk(accessor);\n\n\t\t\t\t/*\n\t\t\t\t * How many overflow chunks to go?  This will allow readers to\n\t\t\t\t * skip all of them at once instead of reading each one.\n\t\t\t\t */\n\t\t\t\taccessor->write_chunk->overflow = (size + STS_CHUNK_DATA_SIZE - 1) /\n\t\t\t\t\tSTS_CHUNK_DATA_SIZE;\n\t\t\t\twritten_this_chunk =\n\t\t\t\t\tMin(accessor->write_end - accessor->write_pointer, size);\n\t\t\t\tmemcpy(accessor->write_pointer, (char *) tuple + written,\n\t\t\t\t\t   written_this_chunk);\n\t\t\t\taccessor->write_pointer += written_this_chunk;\n\t\t\t\tsize -= written_this_chunk;\n\t\t\t\twritten += written_this_chunk;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Copy meta-data and tuple into buffer. */\n\tif (accessor->sts->meta_data_size > 0)\n\t\tmemcpy(accessor->write_pointer, meta_data,\n\t\t\t   accessor->sts->meta_data_size);\n\tmemcpy(accessor->write_pointer + accessor->sts->meta_data_size, tuple,\n\t\t   tuple->t_len);\n\taccessor->write_pointer += size;\n\t++accessor->write_chunk->ntuples;\n}"
  },
  {
    "function_name": "sts_end_parallel_scan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/sharedtuplestore.c",
    "lines": "287-300",
    "snippet": "void\nsts_end_parallel_scan(SharedTuplestoreAccessor *accessor)\n{\n\t/*\n\t * Here we could delete all files if SHARED_TUPLESTORE_SINGLE_PASS, but\n\t * we'd probably need a reference count of current parallel scanners so we\n\t * could safely do it only when the reference count reaches zero.\n\t */\n\tif (accessor->read_file != NULL)\n\t{\n\t\tBufFileClose(accessor->read_file);\n\t\taccessor->read_file = NULL;\n\t}\n}",
    "includes": [
      "#include <limits.h>",
      "#include \"utils/sharedtuplestore.h\"",
      "#include \"storage/sharedfileset.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/buffile.h\"",
      "#include \"miscadmin.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/htup.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BufFileClose",
          "args": [
            "accessor->read_file"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include \"utils/sharedtuplestore.h\"\n#include \"storage/sharedfileset.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"access/htup_details.h\"\n#include \"access/htup.h\"\n#include \"postgres.h\"\n\nvoid\nsts_end_parallel_scan(SharedTuplestoreAccessor *accessor)\n{\n\t/*\n\t * Here we could delete all files if SHARED_TUPLESTORE_SINGLE_PASS, but\n\t * we'd probably need a reference count of current parallel scanners so we\n\t * could safely do it only when the reference count reaches zero.\n\t */\n\tif (accessor->read_file != NULL)\n\t{\n\t\tBufFileClose(accessor->read_file);\n\t\taccessor->read_file = NULL;\n\t}\n}"
  },
  {
    "function_name": "sts_begin_parallel_scan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/sharedtuplestore.c",
    "lines": "259-282",
    "snippet": "void\nsts_begin_parallel_scan(SharedTuplestoreAccessor *accessor)\n{\n\tint\t\t\ti PG_USED_FOR_ASSERTS_ONLY;\n\n\t/* End any existing scan that was in progress. */\n\tsts_end_parallel_scan(accessor);\n\n\t/*\n\t * Any backend that might have written into this shared tuplestore must\n\t * have called sts_end_write(), so that all buffers are flushed and the\n\t * files have stopped growing.\n\t */\n\tfor (i = 0; i < accessor->sts->nparticipants; ++i)\n\t\tAssert(!accessor->sts->participants[i].writing);\n\n\t/*\n\t * We will start out reading the file that THIS backend wrote.  There may\n\t * be some caching locality advantage to that.\n\t */\n\taccessor->read_participant = accessor->participant;\n\taccessor->read_file = NULL;\n\taccessor->read_next_page = 0;\n}",
    "includes": [
      "#include <limits.h>",
      "#include \"utils/sharedtuplestore.h\"",
      "#include \"storage/sharedfileset.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/buffile.h\"",
      "#include \"miscadmin.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/htup.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void sts_filename(char *name, SharedTuplestoreAccessor *accessor,\n\t\t\t int participant);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!accessor->sts->participants[i].writing"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sts_end_parallel_scan",
          "args": [
            "accessor"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "sts_end_parallel_scan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/sharedtuplestore.c",
          "lines": "287-300",
          "snippet": "void\nsts_end_parallel_scan(SharedTuplestoreAccessor *accessor)\n{\n\t/*\n\t * Here we could delete all files if SHARED_TUPLESTORE_SINGLE_PASS, but\n\t * we'd probably need a reference count of current parallel scanners so we\n\t * could safely do it only when the reference count reaches zero.\n\t */\n\tif (accessor->read_file != NULL)\n\t{\n\t\tBufFileClose(accessor->read_file);\n\t\taccessor->read_file = NULL;\n\t}\n}",
          "includes": [
            "#include <limits.h>",
            "#include \"utils/sharedtuplestore.h\"",
            "#include \"storage/sharedfileset.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"miscadmin.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/htup.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include \"utils/sharedtuplestore.h\"\n#include \"storage/sharedfileset.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"access/htup_details.h\"\n#include \"access/htup.h\"\n#include \"postgres.h\"\n\nvoid\nsts_end_parallel_scan(SharedTuplestoreAccessor *accessor)\n{\n\t/*\n\t * Here we could delete all files if SHARED_TUPLESTORE_SINGLE_PASS, but\n\t * we'd probably need a reference count of current parallel scanners so we\n\t * could safely do it only when the reference count reaches zero.\n\t */\n\tif (accessor->read_file != NULL)\n\t{\n\t\tBufFileClose(accessor->read_file);\n\t\taccessor->read_file = NULL;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include \"utils/sharedtuplestore.h\"\n#include \"storage/sharedfileset.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"access/htup_details.h\"\n#include \"access/htup.h\"\n#include \"postgres.h\"\n\nstatic void sts_filename(char *name, SharedTuplestoreAccessor *accessor,\n\t\t\t int participant);\n\nvoid\nsts_begin_parallel_scan(SharedTuplestoreAccessor *accessor)\n{\n\tint\t\t\ti PG_USED_FOR_ASSERTS_ONLY;\n\n\t/* End any existing scan that was in progress. */\n\tsts_end_parallel_scan(accessor);\n\n\t/*\n\t * Any backend that might have written into this shared tuplestore must\n\t * have called sts_end_write(), so that all buffers are flushed and the\n\t * files have stopped growing.\n\t */\n\tfor (i = 0; i < accessor->sts->nparticipants; ++i)\n\t\tAssert(!accessor->sts->participants[i].writing);\n\n\t/*\n\t * We will start out reading the file that THIS backend wrote.  There may\n\t * be some caching locality advantage to that.\n\t */\n\taccessor->read_participant = accessor->participant;\n\taccessor->read_file = NULL;\n\taccessor->read_next_page = 0;\n}"
  },
  {
    "function_name": "sts_reinitialize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/sharedtuplestore.c",
    "lines": "240-254",
    "snippet": "void\nsts_reinitialize(SharedTuplestoreAccessor *accessor)\n{\n\tint\t\t\ti;\n\n\t/*\n\t * Reset the shared read head for all participants' files.  Also set the\n\t * initial chunk size to the minimum (any increases from that size will be\n\t * recorded in chunk_expansion_log).\n\t */\n\tfor (i = 0; i < accessor->sts->nparticipants; ++i)\n\t{\n\t\taccessor->sts->participants[i].read_page = 0;\n\t}\n}",
    "includes": [
      "#include <limits.h>",
      "#include \"utils/sharedtuplestore.h\"",
      "#include \"storage/sharedfileset.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/buffile.h\"",
      "#include \"miscadmin.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/htup.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <limits.h>\n#include \"utils/sharedtuplestore.h\"\n#include \"storage/sharedfileset.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"access/htup_details.h\"\n#include \"access/htup.h\"\n#include \"postgres.h\"\n\nvoid\nsts_reinitialize(SharedTuplestoreAccessor *accessor)\n{\n\tint\t\t\ti;\n\n\t/*\n\t * Reset the shared read head for all participants' files.  Also set the\n\t * initial chunk size to the minimum (any increases from that size will be\n\t * recorded in chunk_expansion_log).\n\t */\n\tfor (i = 0; i < accessor->sts->nparticipants; ++i)\n\t{\n\t\taccessor->sts->participants[i].read_page = 0;\n\t}\n}"
  },
  {
    "function_name": "sts_end_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/sharedtuplestore.c",
    "lines": "219-231",
    "snippet": "void\nsts_end_write(SharedTuplestoreAccessor *accessor)\n{\n\tif (accessor->write_file != NULL)\n\t{\n\t\tsts_flush_chunk(accessor);\n\t\tBufFileClose(accessor->write_file);\n\t\tpfree(accessor->write_chunk);\n\t\taccessor->write_chunk = NULL;\n\t\taccessor->write_file = NULL;\n\t\taccessor->sts->participants[accessor->participant].writing = false;\n\t}\n}",
    "includes": [
      "#include <limits.h>",
      "#include \"utils/sharedtuplestore.h\"",
      "#include \"storage/sharedfileset.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/buffile.h\"",
      "#include \"miscadmin.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/htup.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void sts_filename(char *name, SharedTuplestoreAccessor *accessor,\n\t\t\t int participant);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "accessor->write_chunk"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BufFileClose",
          "args": [
            "accessor->write_file"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sts_flush_chunk",
          "args": [
            "accessor"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "sts_flush_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/sharedtuplestore.c",
          "lines": "197-213",
          "snippet": "static void\nsts_flush_chunk(SharedTuplestoreAccessor *accessor)\n{\n\tsize_t\t\tsize;\n\tsize_t\t\twritten;\n\n\tsize = STS_CHUNK_PAGES * BLCKSZ;\n\twritten = BufFileWrite(accessor->write_file, accessor->write_chunk, size);\n\tif (written != size)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write to temporary file: %m\")));\n\tmemset(accessor->write_chunk, 0, size);\n\taccessor->write_pointer = &accessor->write_chunk->data[0];\n\taccessor->sts->participants[accessor->participant].npages +=\n\t\tSTS_CHUNK_PAGES;\n}",
          "includes": [
            "#include <limits.h>",
            "#include \"utils/sharedtuplestore.h\"",
            "#include \"storage/sharedfileset.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"miscadmin.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/htup.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define STS_CHUNK_PAGES 4"
          ],
          "globals_used": [
            "static void sts_filename(char *name, SharedTuplestoreAccessor *accessor,\n\t\t\t int participant);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include \"utils/sharedtuplestore.h\"\n#include \"storage/sharedfileset.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"access/htup_details.h\"\n#include \"access/htup.h\"\n#include \"postgres.h\"\n\n#define STS_CHUNK_PAGES 4\n\nstatic void sts_filename(char *name, SharedTuplestoreAccessor *accessor,\n\t\t\t int participant);\n\nstatic void\nsts_flush_chunk(SharedTuplestoreAccessor *accessor)\n{\n\tsize_t\t\tsize;\n\tsize_t\t\twritten;\n\n\tsize = STS_CHUNK_PAGES * BLCKSZ;\n\twritten = BufFileWrite(accessor->write_file, accessor->write_chunk, size);\n\tif (written != size)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write to temporary file: %m\")));\n\tmemset(accessor->write_chunk, 0, size);\n\taccessor->write_pointer = &accessor->write_chunk->data[0];\n\taccessor->sts->participants[accessor->participant].npages +=\n\t\tSTS_CHUNK_PAGES;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include \"utils/sharedtuplestore.h\"\n#include \"storage/sharedfileset.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"access/htup_details.h\"\n#include \"access/htup.h\"\n#include \"postgres.h\"\n\nstatic void sts_filename(char *name, SharedTuplestoreAccessor *accessor,\n\t\t\t int participant);\n\nvoid\nsts_end_write(SharedTuplestoreAccessor *accessor)\n{\n\tif (accessor->write_file != NULL)\n\t{\n\t\tsts_flush_chunk(accessor);\n\t\tBufFileClose(accessor->write_file);\n\t\tpfree(accessor->write_chunk);\n\t\taccessor->write_chunk = NULL;\n\t\taccessor->write_file = NULL;\n\t\taccessor->sts->participants[accessor->participant].writing = false;\n\t}\n}"
  },
  {
    "function_name": "sts_flush_chunk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/sharedtuplestore.c",
    "lines": "197-213",
    "snippet": "static void\nsts_flush_chunk(SharedTuplestoreAccessor *accessor)\n{\n\tsize_t\t\tsize;\n\tsize_t\t\twritten;\n\n\tsize = STS_CHUNK_PAGES * BLCKSZ;\n\twritten = BufFileWrite(accessor->write_file, accessor->write_chunk, size);\n\tif (written != size)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write to temporary file: %m\")));\n\tmemset(accessor->write_chunk, 0, size);\n\taccessor->write_pointer = &accessor->write_chunk->data[0];\n\taccessor->sts->participants[accessor->participant].npages +=\n\t\tSTS_CHUNK_PAGES;\n}",
    "includes": [
      "#include <limits.h>",
      "#include \"utils/sharedtuplestore.h\"",
      "#include \"storage/sharedfileset.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/buffile.h\"",
      "#include \"miscadmin.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/htup.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define STS_CHUNK_PAGES 4"
    ],
    "globals_used": [
      "static void sts_filename(char *name, SharedTuplestoreAccessor *accessor,\n\t\t\t int participant);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "accessor->write_chunk",
            "0",
            "size"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write to temporary file: %m\"))"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not write to temporary file: %m\""
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode_for_file_access",
          "args": [],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "errcode_for_file_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "595-655",
          "snippet": "int\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "BufFileWrite",
          "args": [
            "accessor->write_file",
            "accessor->write_chunk",
            "size"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include \"utils/sharedtuplestore.h\"\n#include \"storage/sharedfileset.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"access/htup_details.h\"\n#include \"access/htup.h\"\n#include \"postgres.h\"\n\n#define STS_CHUNK_PAGES 4\n\nstatic void sts_filename(char *name, SharedTuplestoreAccessor *accessor,\n\t\t\t int participant);\n\nstatic void\nsts_flush_chunk(SharedTuplestoreAccessor *accessor)\n{\n\tsize_t\t\tsize;\n\tsize_t\t\twritten;\n\n\tsize = STS_CHUNK_PAGES * BLCKSZ;\n\twritten = BufFileWrite(accessor->write_file, accessor->write_chunk, size);\n\tif (written != size)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write to temporary file: %m\")));\n\tmemset(accessor->write_chunk, 0, size);\n\taccessor->write_pointer = &accessor->write_chunk->data[0];\n\taccessor->sts->participants[accessor->participant].npages +=\n\t\tSTS_CHUNK_PAGES;\n}"
  },
  {
    "function_name": "sts_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/sharedtuplestore.c",
    "lines": "179-195",
    "snippet": "SharedTuplestoreAccessor *\nsts_attach(SharedTuplestore *sts,\n\t\t   int my_participant_number,\n\t\t   SharedFileSet *fileset)\n{\n\tSharedTuplestoreAccessor *accessor;\n\n\tAssert(my_participant_number < sts->nparticipants);\n\n\taccessor = palloc0(sizeof(SharedTuplestoreAccessor));\n\taccessor->participant = my_participant_number;\n\taccessor->sts = sts;\n\taccessor->fileset = fileset;\n\taccessor->context = CurrentMemoryContext;\n\n\treturn accessor;\n}",
    "includes": [
      "#include <limits.h>",
      "#include \"utils/sharedtuplestore.h\"",
      "#include \"storage/sharedfileset.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/buffile.h\"",
      "#include \"miscadmin.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/htup.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void sts_filename(char *name, SharedTuplestoreAccessor *accessor,\n\t\t\t int participant);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "sizeof(SharedTuplestoreAccessor)"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "my_participant_number < sts->nparticipants"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include \"utils/sharedtuplestore.h\"\n#include \"storage/sharedfileset.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"access/htup_details.h\"\n#include \"access/htup.h\"\n#include \"postgres.h\"\n\nstatic void sts_filename(char *name, SharedTuplestoreAccessor *accessor,\n\t\t\t int participant);\n\nSharedTuplestoreAccessor *\nsts_attach(SharedTuplestore *sts,\n\t\t   int my_participant_number,\n\t\t   SharedFileSet *fileset)\n{\n\tSharedTuplestoreAccessor *accessor;\n\n\tAssert(my_participant_number < sts->nparticipants);\n\n\taccessor = palloc0(sizeof(SharedTuplestoreAccessor));\n\taccessor->participant = my_participant_number;\n\taccessor->sts = sts;\n\taccessor->fileset = fileset;\n\taccessor->context = CurrentMemoryContext;\n\n\treturn accessor;\n}"
  },
  {
    "function_name": "sts_initialize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/sharedtuplestore.c",
    "lines": "128-173",
    "snippet": "SharedTuplestoreAccessor *\nsts_initialize(SharedTuplestore *sts, int participants,\n\t\t\t   int my_participant_number,\n\t\t\t   size_t meta_data_size,\n\t\t\t   int flags,\n\t\t\t   SharedFileSet *fileset,\n\t\t\t   const char *name)\n{\n\tSharedTuplestoreAccessor *accessor;\n\tint\t\t\ti;\n\n\tAssert(my_participant_number < participants);\n\n\tsts->nparticipants = participants;\n\tsts->meta_data_size = meta_data_size;\n\tsts->flags = flags;\n\n\tif (strlen(name) > sizeof(sts->name) - 1)\n\t\telog(ERROR, \"SharedTuplestore name too long\");\n\tstrcpy(sts->name, name);\n\n\t/*\n\t * Limit meta-data so it + tuple size always fits into a single chunk.\n\t * sts_puttuple() and sts_read_tuple() could be made to support scenarios\n\t * where that's not the case, but it's not currently required. If so,\n\t * meta-data size probably should be made variable, too.\n\t */\n\tif (meta_data_size + sizeof(uint32) >= STS_CHUNK_DATA_SIZE)\n\t\telog(ERROR, \"meta-data too long\");\n\n\tfor (i = 0; i < participants; ++i)\n\t{\n\t\tLWLockInitialize(&sts->participants[i].lock,\n\t\t\t\t\t\t LWTRANCHE_SHARED_TUPLESTORE);\n\t\tsts->participants[i].read_page = 0;\n\t\tsts->participants[i].writing = false;\n\t}\n\n\taccessor = palloc0(sizeof(SharedTuplestoreAccessor));\n\taccessor->participant = my_participant_number;\n\taccessor->sts = sts;\n\taccessor->fileset = fileset;\n\taccessor->context = CurrentMemoryContext;\n\n\treturn accessor;\n}",
    "includes": [
      "#include <limits.h>",
      "#include \"utils/sharedtuplestore.h\"",
      "#include \"storage/sharedfileset.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/buffile.h\"",
      "#include \"miscadmin.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/htup.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define STS_CHUNK_DATA_SIZE (STS_CHUNK_PAGES * BLCKSZ - STS_CHUNK_HEADER_SIZE)"
    ],
    "globals_used": [
      "static void sts_filename(char *name, SharedTuplestoreAccessor *accessor,\n\t\t\t int participant);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "sizeof(SharedTuplestoreAccessor)"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LWLockInitialize",
          "args": [
            "&sts->participants[i].lock",
            "LWTRANCHE_SHARED_TUPLESTORE"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"meta-data too long\""
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "sts->name",
            "name"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "215-222",
          "snippet": "int\nnamestrcpy(Name name, const char *str)\n{\n\tif (!name || !str)\n\t\treturn -1;\n\tStrNCpy(NameStr(*name), str, NAMEDATALEN);\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcpy(Name name, const char *str)\n{\n\tif (!name || !str)\n\t\treturn -1;\n\tStrNCpy(NameStr(*name), str, NAMEDATALEN);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "my_participant_number < participants"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include \"utils/sharedtuplestore.h\"\n#include \"storage/sharedfileset.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"access/htup_details.h\"\n#include \"access/htup.h\"\n#include \"postgres.h\"\n\n#define STS_CHUNK_DATA_SIZE (STS_CHUNK_PAGES * BLCKSZ - STS_CHUNK_HEADER_SIZE)\n\nstatic void sts_filename(char *name, SharedTuplestoreAccessor *accessor,\n\t\t\t int participant);\n\nSharedTuplestoreAccessor *\nsts_initialize(SharedTuplestore *sts, int participants,\n\t\t\t   int my_participant_number,\n\t\t\t   size_t meta_data_size,\n\t\t\t   int flags,\n\t\t\t   SharedFileSet *fileset,\n\t\t\t   const char *name)\n{\n\tSharedTuplestoreAccessor *accessor;\n\tint\t\t\ti;\n\n\tAssert(my_participant_number < participants);\n\n\tsts->nparticipants = participants;\n\tsts->meta_data_size = meta_data_size;\n\tsts->flags = flags;\n\n\tif (strlen(name) > sizeof(sts->name) - 1)\n\t\telog(ERROR, \"SharedTuplestore name too long\");\n\tstrcpy(sts->name, name);\n\n\t/*\n\t * Limit meta-data so it + tuple size always fits into a single chunk.\n\t * sts_puttuple() and sts_read_tuple() could be made to support scenarios\n\t * where that's not the case, but it's not currently required. If so,\n\t * meta-data size probably should be made variable, too.\n\t */\n\tif (meta_data_size + sizeof(uint32) >= STS_CHUNK_DATA_SIZE)\n\t\telog(ERROR, \"meta-data too long\");\n\n\tfor (i = 0; i < participants; ++i)\n\t{\n\t\tLWLockInitialize(&sts->participants[i].lock,\n\t\t\t\t\t\t LWTRANCHE_SHARED_TUPLESTORE);\n\t\tsts->participants[i].read_page = 0;\n\t\tsts->participants[i].writing = false;\n\t}\n\n\taccessor = palloc0(sizeof(SharedTuplestoreAccessor));\n\taccessor->participant = my_participant_number;\n\taccessor->sts = sts;\n\taccessor->fileset = fileset;\n\taccessor->context = CurrentMemoryContext;\n\n\treturn accessor;\n}"
  },
  {
    "function_name": "sts_estimate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/sharedtuplestore.c",
    "lines": "106-111",
    "snippet": "size_t\nsts_estimate(int participants)\n{\n\treturn offsetof(SharedTuplestore, participants) +\n\t\tsizeof(SharedTuplestoreParticipant) * participants;\n}",
    "includes": [
      "#include <limits.h>",
      "#include \"utils/sharedtuplestore.h\"",
      "#include \"storage/sharedfileset.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"storage/buffile.h\"",
      "#include \"miscadmin.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/htup.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <limits.h>\n#include \"utils/sharedtuplestore.h\"\n#include \"storage/sharedfileset.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"access/htup_details.h\"\n#include \"access/htup.h\"\n#include \"postgres.h\"\n\nsize_t\nsts_estimate(int participants)\n{\n\treturn offsetof(SharedTuplestore, participants) +\n\t\tsizeof(SharedTuplestoreParticipant) * participants;\n}"
  }
]