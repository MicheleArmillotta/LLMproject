[
  {
    "function_name": "ts_rankcd_tt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsrank.c",
    "lines": "997-1009",
    "snippet": "Datum\nts_rankcd_tt(PG_FUNCTION_ARGS)\n{\n\tTSVector\ttxt = PG_GETARG_TSVECTOR(0);\n\tTSQuery\t\tquery = PG_GETARG_TSQUERY(1);\n\tfloat\t\tres;\n\n\tres = calc_rank_cd(getWeights(NULL), txt, query, DEF_NORM_METHOD);\n\n\tPG_FREE_IF_COPY(txt, 0);\n\tPG_FREE_IF_COPY(query, 1);\n\tPG_RETURN_FLOAT4(res);\n}",
    "includes": [
      "#include \"miscadmin.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define DEF_NORM_METHOD\t\t\tRANK_NO_NORM"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT4",
          "args": [
            "res"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "query",
            "1"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "txt",
            "0"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calc_rank_cd",
          "args": [
            "getWeights(NULL)",
            "txt",
            "query",
            "DEF_NORM_METHOD"
          ],
          "line": 1004
        },
        "resolved": true,
        "details": {
          "function_name": "calc_rank_cd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsrank.c",
          "lines": "846-947",
          "snippet": "static float4\ncalc_rank_cd(const float4 *arrdata, TSVector txt, TSQuery query, int method)\n{\n\tDocRepresentation *doc;\n\tint\t\t\tlen,\n\t\t\t\ti,\n\t\t\t\tdoclen = 0;\n\tCoverExt\text;\n\tdouble\t\tWdoc = 0.0;\n\tdouble\t\tinvws[lengthof(weights)];\n\tdouble\t\tSumDist = 0.0,\n\t\t\t\tPrevExtPos = 0.0,\n\t\t\t\tCurExtPos = 0.0;\n\tint\t\t\tNExtent = 0;\n\tQueryRepresentation qr;\n\n\n\tfor (i = 0; i < lengthof(weights); i++)\n\t{\n\t\tinvws[i] = ((double) ((arrdata[i] >= 0) ? arrdata[i] : weights[i]));\n\t\tif (invws[i] > 1.0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"weight out of range\")));\n\t\tinvws[i] = 1.0 / invws[i];\n\t}\n\n\tqr.query = query;\n\tqr.operandData = (QueryRepresentationOperand *)\n\t\tpalloc0(sizeof(QueryRepresentationOperand) * query->size);\n\n\tdoc = get_docrep(txt, &qr, &doclen);\n\tif (!doc)\n\t{\n\t\tpfree(qr.operandData);\n\t\treturn 0.0;\n\t}\n\n\tMemSet(&ext, 0, sizeof(CoverExt));\n\twhile (Cover(doc, doclen, &qr, &ext))\n\t{\n\t\tdouble\t\tCpos = 0.0;\n\t\tdouble\t\tInvSum = 0.0;\n\t\tint\t\t\tnNoise;\n\t\tDocRepresentation *ptr = ext.begin;\n\n\t\twhile (ptr <= ext.end)\n\t\t{\n\t\t\tInvSum += invws[WEP_GETWEIGHT(ptr->pos)];\n\t\t\tptr++;\n\t\t}\n\n\t\tCpos = ((double) (ext.end - ext.begin + 1)) / InvSum;\n\n\t\t/*\n\t\t * if doc are big enough then ext.q may be equal to ext.p due to limit\n\t\t * of positional information. In this case we approximate number of\n\t\t * noise word as half cover's length\n\t\t */\n\t\tnNoise = (ext.q - ext.p) - (ext.end - ext.begin);\n\t\tif (nNoise < 0)\n\t\t\tnNoise = (ext.end - ext.begin) / 2;\n\t\tWdoc += Cpos / ((double) (1 + nNoise));\n\n\t\tCurExtPos = ((double) (ext.q + ext.p)) / 2.0;\n\t\tif (NExtent > 0 && CurExtPos > PrevExtPos\t/* prevent division by\n\t\t\t\t\t\t\t\t\t\t\t\t\t * zero in a case of\n\t\t\t  * multiple lexize */ )\n\t\t\tSumDist += 1.0 / (CurExtPos - PrevExtPos);\n\n\t\tPrevExtPos = CurExtPos;\n\t\tNExtent++;\n\t}\n\n\tif ((method & RANK_NORM_LOGLENGTH) && txt->size > 0)\n\t\tWdoc /= log((double) (cnt_length(txt) + 1));\n\n\tif (method & RANK_NORM_LENGTH)\n\t{\n\t\tlen = cnt_length(txt);\n\t\tif (len > 0)\n\t\t\tWdoc /= (double) len;\n\t}\n\n\tif ((method & RANK_NORM_EXTDIST) && NExtent > 0 && SumDist > 0)\n\t\tWdoc /= ((double) NExtent) / SumDist;\n\n\tif ((method & RANK_NORM_UNIQ) && txt->size > 0)\n\t\tWdoc /= (double) (txt->size);\n\n\tif ((method & RANK_NORM_LOGUNIQ) && txt->size > 0)\n\t\tWdoc /= log((double) (txt->size + 1)) / log(2.0);\n\n\tif (method & RANK_NORM_RDIVRPLUS1)\n\t\tWdoc /= (Wdoc + 1);\n\n\tpfree(doc);\n\n\tpfree(qr.operandData);\n\n\treturn (float4) Wdoc;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RANK_NORM_RDIVRPLUS1\t0x20",
            "#define RANK_NORM_LOGUNIQ\t\t0x10",
            "#define RANK_NORM_UNIQ\t\t\t0x08",
            "#define RANK_NORM_EXTDIST\t\t0x04",
            "#define RANK_NORM_LENGTH\t\t0x02",
            "#define RANK_NORM_LOGLENGTH\t\t0x01"
          ],
          "globals_used": [
            "static const float weights[] = {0.1f, 0.2f, 0.4f, 1.0f};",
            "static float calc_rank_or(const float *w, TSVector t, TSQuery q);",
            "static float calc_rank_and(const float *w, TSVector t, TSQuery q);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"tsearch/ts_utils.h\"\n#include <math.h>\n#include <limits.h>\n#include \"postgres.h\"\n\n#define RANK_NORM_RDIVRPLUS1\t0x20\n#define RANK_NORM_LOGUNIQ\t\t0x10\n#define RANK_NORM_UNIQ\t\t\t0x08\n#define RANK_NORM_EXTDIST\t\t0x04\n#define RANK_NORM_LENGTH\t\t0x02\n#define RANK_NORM_LOGLENGTH\t\t0x01\n\nstatic const float weights[] = {0.1f, 0.2f, 0.4f, 1.0f};\nstatic float calc_rank_or(const float *w, TSVector t, TSQuery q);\nstatic float calc_rank_and(const float *w, TSVector t, TSQuery q);\n\nstatic float4\ncalc_rank_cd(const float4 *arrdata, TSVector txt, TSQuery query, int method)\n{\n\tDocRepresentation *doc;\n\tint\t\t\tlen,\n\t\t\t\ti,\n\t\t\t\tdoclen = 0;\n\tCoverExt\text;\n\tdouble\t\tWdoc = 0.0;\n\tdouble\t\tinvws[lengthof(weights)];\n\tdouble\t\tSumDist = 0.0,\n\t\t\t\tPrevExtPos = 0.0,\n\t\t\t\tCurExtPos = 0.0;\n\tint\t\t\tNExtent = 0;\n\tQueryRepresentation qr;\n\n\n\tfor (i = 0; i < lengthof(weights); i++)\n\t{\n\t\tinvws[i] = ((double) ((arrdata[i] >= 0) ? arrdata[i] : weights[i]));\n\t\tif (invws[i] > 1.0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"weight out of range\")));\n\t\tinvws[i] = 1.0 / invws[i];\n\t}\n\n\tqr.query = query;\n\tqr.operandData = (QueryRepresentationOperand *)\n\t\tpalloc0(sizeof(QueryRepresentationOperand) * query->size);\n\n\tdoc = get_docrep(txt, &qr, &doclen);\n\tif (!doc)\n\t{\n\t\tpfree(qr.operandData);\n\t\treturn 0.0;\n\t}\n\n\tMemSet(&ext, 0, sizeof(CoverExt));\n\twhile (Cover(doc, doclen, &qr, &ext))\n\t{\n\t\tdouble\t\tCpos = 0.0;\n\t\tdouble\t\tInvSum = 0.0;\n\t\tint\t\t\tnNoise;\n\t\tDocRepresentation *ptr = ext.begin;\n\n\t\twhile (ptr <= ext.end)\n\t\t{\n\t\t\tInvSum += invws[WEP_GETWEIGHT(ptr->pos)];\n\t\t\tptr++;\n\t\t}\n\n\t\tCpos = ((double) (ext.end - ext.begin + 1)) / InvSum;\n\n\t\t/*\n\t\t * if doc are big enough then ext.q may be equal to ext.p due to limit\n\t\t * of positional information. In this case we approximate number of\n\t\t * noise word as half cover's length\n\t\t */\n\t\tnNoise = (ext.q - ext.p) - (ext.end - ext.begin);\n\t\tif (nNoise < 0)\n\t\t\tnNoise = (ext.end - ext.begin) / 2;\n\t\tWdoc += Cpos / ((double) (1 + nNoise));\n\n\t\tCurExtPos = ((double) (ext.q + ext.p)) / 2.0;\n\t\tif (NExtent > 0 && CurExtPos > PrevExtPos\t/* prevent division by\n\t\t\t\t\t\t\t\t\t\t\t\t\t * zero in a case of\n\t\t\t  * multiple lexize */ )\n\t\t\tSumDist += 1.0 / (CurExtPos - PrevExtPos);\n\n\t\tPrevExtPos = CurExtPos;\n\t\tNExtent++;\n\t}\n\n\tif ((method & RANK_NORM_LOGLENGTH) && txt->size > 0)\n\t\tWdoc /= log((double) (cnt_length(txt) + 1));\n\n\tif (method & RANK_NORM_LENGTH)\n\t{\n\t\tlen = cnt_length(txt);\n\t\tif (len > 0)\n\t\t\tWdoc /= (double) len;\n\t}\n\n\tif ((method & RANK_NORM_EXTDIST) && NExtent > 0 && SumDist > 0)\n\t\tWdoc /= ((double) NExtent) / SumDist;\n\n\tif ((method & RANK_NORM_UNIQ) && txt->size > 0)\n\t\tWdoc /= (double) (txt->size);\n\n\tif ((method & RANK_NORM_LOGUNIQ) && txt->size > 0)\n\t\tWdoc /= log((double) (txt->size + 1)) / log(2.0);\n\n\tif (method & RANK_NORM_RDIVRPLUS1)\n\t\tWdoc /= (Wdoc + 1);\n\n\tpfree(doc);\n\n\tpfree(qr.operandData);\n\n\treturn (float4) Wdoc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getWeights",
          "args": [
            "NULL"
          ],
          "line": 1004
        },
        "resolved": true,
        "details": {
          "function_name": "getWeights",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsrank.c",
          "lines": "400-436",
          "snippet": "static const float *\ngetWeights(ArrayType *win)\n{\n\tstatic float ws[lengthof(weights)];\n\tint\t\t\ti;\n\tfloat4\t   *arrdata;\n\n\tif (win == NULL)\n\t\treturn weights;\n\n\tif (ARR_NDIM(win) != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"array of weight must be one-dimensional\")));\n\n\tif (ArrayGetNItems(ARR_NDIM(win), ARR_DIMS(win)) < lengthof(weights))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"array of weight is too short\")));\n\n\tif (array_contains_nulls(win))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"array of weight must not contain nulls\")));\n\n\tarrdata = (float4 *) ARR_DATA_PTR(win);\n\tfor (i = 0; i < lengthof(weights); i++)\n\t{\n\t\tws[i] = (arrdata[i] >= 0) ? arrdata[i] : weights[i];\n\t\tif (ws[i] > 1.0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"weight out of range\")));\n\t}\n\n\treturn ws;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const float weights[] = {0.1f, 0.2f, 0.4f, 1.0f};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"tsearch/ts_utils.h\"\n#include <math.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic const float weights[] = {0.1f, 0.2f, 0.4f, 1.0f};\n\nstatic const float *\ngetWeights(ArrayType *win)\n{\n\tstatic float ws[lengthof(weights)];\n\tint\t\t\ti;\n\tfloat4\t   *arrdata;\n\n\tif (win == NULL)\n\t\treturn weights;\n\n\tif (ARR_NDIM(win) != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"array of weight must be one-dimensional\")));\n\n\tif (ArrayGetNItems(ARR_NDIM(win), ARR_DIMS(win)) < lengthof(weights))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"array of weight is too short\")));\n\n\tif (array_contains_nulls(win))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"array of weight must not contain nulls\")));\n\n\tarrdata = (float4 *) ARR_DATA_PTR(win);\n\tfor (i = 0; i < lengthof(weights); i++)\n\t{\n\t\tws[i] = (arrdata[i] >= 0) ? arrdata[i] : weights[i];\n\t\tif (ws[i] > 1.0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"weight out of range\")));\n\t}\n\n\treturn ws;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TSQUERY",
          "args": [
            "1"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TSVECTOR",
          "args": [
            "0"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"tsearch/ts_utils.h\"\n#include <math.h>\n#include <limits.h>\n#include \"postgres.h\"\n\n#define DEF_NORM_METHOD\t\t\tRANK_NO_NORM\n\nDatum\nts_rankcd_tt(PG_FUNCTION_ARGS)\n{\n\tTSVector\ttxt = PG_GETARG_TSVECTOR(0);\n\tTSQuery\t\tquery = PG_GETARG_TSQUERY(1);\n\tfloat\t\tres;\n\n\tres = calc_rank_cd(getWeights(NULL), txt, query, DEF_NORM_METHOD);\n\n\tPG_FREE_IF_COPY(txt, 0);\n\tPG_FREE_IF_COPY(query, 1);\n\tPG_RETURN_FLOAT4(res);\n}"
  },
  {
    "function_name": "ts_rankcd_ttf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsrank.c",
    "lines": "982-995",
    "snippet": "Datum\nts_rankcd_ttf(PG_FUNCTION_ARGS)\n{\n\tTSVector\ttxt = PG_GETARG_TSVECTOR(0);\n\tTSQuery\t\tquery = PG_GETARG_TSQUERY(1);\n\tint\t\t\tmethod = PG_GETARG_INT32(2);\n\tfloat\t\tres;\n\n\tres = calc_rank_cd(getWeights(NULL), txt, query, method);\n\n\tPG_FREE_IF_COPY(txt, 0);\n\tPG_FREE_IF_COPY(query, 1);\n\tPG_RETURN_FLOAT4(res);\n}",
    "includes": [
      "#include \"miscadmin.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT4",
          "args": [
            "res"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "query",
            "1"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "txt",
            "0"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calc_rank_cd",
          "args": [
            "getWeights(NULL)",
            "txt",
            "query",
            "method"
          ],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "calc_rank_cd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsrank.c",
          "lines": "846-947",
          "snippet": "static float4\ncalc_rank_cd(const float4 *arrdata, TSVector txt, TSQuery query, int method)\n{\n\tDocRepresentation *doc;\n\tint\t\t\tlen,\n\t\t\t\ti,\n\t\t\t\tdoclen = 0;\n\tCoverExt\text;\n\tdouble\t\tWdoc = 0.0;\n\tdouble\t\tinvws[lengthof(weights)];\n\tdouble\t\tSumDist = 0.0,\n\t\t\t\tPrevExtPos = 0.0,\n\t\t\t\tCurExtPos = 0.0;\n\tint\t\t\tNExtent = 0;\n\tQueryRepresentation qr;\n\n\n\tfor (i = 0; i < lengthof(weights); i++)\n\t{\n\t\tinvws[i] = ((double) ((arrdata[i] >= 0) ? arrdata[i] : weights[i]));\n\t\tif (invws[i] > 1.0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"weight out of range\")));\n\t\tinvws[i] = 1.0 / invws[i];\n\t}\n\n\tqr.query = query;\n\tqr.operandData = (QueryRepresentationOperand *)\n\t\tpalloc0(sizeof(QueryRepresentationOperand) * query->size);\n\n\tdoc = get_docrep(txt, &qr, &doclen);\n\tif (!doc)\n\t{\n\t\tpfree(qr.operandData);\n\t\treturn 0.0;\n\t}\n\n\tMemSet(&ext, 0, sizeof(CoverExt));\n\twhile (Cover(doc, doclen, &qr, &ext))\n\t{\n\t\tdouble\t\tCpos = 0.0;\n\t\tdouble\t\tInvSum = 0.0;\n\t\tint\t\t\tnNoise;\n\t\tDocRepresentation *ptr = ext.begin;\n\n\t\twhile (ptr <= ext.end)\n\t\t{\n\t\t\tInvSum += invws[WEP_GETWEIGHT(ptr->pos)];\n\t\t\tptr++;\n\t\t}\n\n\t\tCpos = ((double) (ext.end - ext.begin + 1)) / InvSum;\n\n\t\t/*\n\t\t * if doc are big enough then ext.q may be equal to ext.p due to limit\n\t\t * of positional information. In this case we approximate number of\n\t\t * noise word as half cover's length\n\t\t */\n\t\tnNoise = (ext.q - ext.p) - (ext.end - ext.begin);\n\t\tif (nNoise < 0)\n\t\t\tnNoise = (ext.end - ext.begin) / 2;\n\t\tWdoc += Cpos / ((double) (1 + nNoise));\n\n\t\tCurExtPos = ((double) (ext.q + ext.p)) / 2.0;\n\t\tif (NExtent > 0 && CurExtPos > PrevExtPos\t/* prevent division by\n\t\t\t\t\t\t\t\t\t\t\t\t\t * zero in a case of\n\t\t\t  * multiple lexize */ )\n\t\t\tSumDist += 1.0 / (CurExtPos - PrevExtPos);\n\n\t\tPrevExtPos = CurExtPos;\n\t\tNExtent++;\n\t}\n\n\tif ((method & RANK_NORM_LOGLENGTH) && txt->size > 0)\n\t\tWdoc /= log((double) (cnt_length(txt) + 1));\n\n\tif (method & RANK_NORM_LENGTH)\n\t{\n\t\tlen = cnt_length(txt);\n\t\tif (len > 0)\n\t\t\tWdoc /= (double) len;\n\t}\n\n\tif ((method & RANK_NORM_EXTDIST) && NExtent > 0 && SumDist > 0)\n\t\tWdoc /= ((double) NExtent) / SumDist;\n\n\tif ((method & RANK_NORM_UNIQ) && txt->size > 0)\n\t\tWdoc /= (double) (txt->size);\n\n\tif ((method & RANK_NORM_LOGUNIQ) && txt->size > 0)\n\t\tWdoc /= log((double) (txt->size + 1)) / log(2.0);\n\n\tif (method & RANK_NORM_RDIVRPLUS1)\n\t\tWdoc /= (Wdoc + 1);\n\n\tpfree(doc);\n\n\tpfree(qr.operandData);\n\n\treturn (float4) Wdoc;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RANK_NORM_RDIVRPLUS1\t0x20",
            "#define RANK_NORM_LOGUNIQ\t\t0x10",
            "#define RANK_NORM_UNIQ\t\t\t0x08",
            "#define RANK_NORM_EXTDIST\t\t0x04",
            "#define RANK_NORM_LENGTH\t\t0x02",
            "#define RANK_NORM_LOGLENGTH\t\t0x01"
          ],
          "globals_used": [
            "static const float weights[] = {0.1f, 0.2f, 0.4f, 1.0f};",
            "static float calc_rank_or(const float *w, TSVector t, TSQuery q);",
            "static float calc_rank_and(const float *w, TSVector t, TSQuery q);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"tsearch/ts_utils.h\"\n#include <math.h>\n#include <limits.h>\n#include \"postgres.h\"\n\n#define RANK_NORM_RDIVRPLUS1\t0x20\n#define RANK_NORM_LOGUNIQ\t\t0x10\n#define RANK_NORM_UNIQ\t\t\t0x08\n#define RANK_NORM_EXTDIST\t\t0x04\n#define RANK_NORM_LENGTH\t\t0x02\n#define RANK_NORM_LOGLENGTH\t\t0x01\n\nstatic const float weights[] = {0.1f, 0.2f, 0.4f, 1.0f};\nstatic float calc_rank_or(const float *w, TSVector t, TSQuery q);\nstatic float calc_rank_and(const float *w, TSVector t, TSQuery q);\n\nstatic float4\ncalc_rank_cd(const float4 *arrdata, TSVector txt, TSQuery query, int method)\n{\n\tDocRepresentation *doc;\n\tint\t\t\tlen,\n\t\t\t\ti,\n\t\t\t\tdoclen = 0;\n\tCoverExt\text;\n\tdouble\t\tWdoc = 0.0;\n\tdouble\t\tinvws[lengthof(weights)];\n\tdouble\t\tSumDist = 0.0,\n\t\t\t\tPrevExtPos = 0.0,\n\t\t\t\tCurExtPos = 0.0;\n\tint\t\t\tNExtent = 0;\n\tQueryRepresentation qr;\n\n\n\tfor (i = 0; i < lengthof(weights); i++)\n\t{\n\t\tinvws[i] = ((double) ((arrdata[i] >= 0) ? arrdata[i] : weights[i]));\n\t\tif (invws[i] > 1.0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"weight out of range\")));\n\t\tinvws[i] = 1.0 / invws[i];\n\t}\n\n\tqr.query = query;\n\tqr.operandData = (QueryRepresentationOperand *)\n\t\tpalloc0(sizeof(QueryRepresentationOperand) * query->size);\n\n\tdoc = get_docrep(txt, &qr, &doclen);\n\tif (!doc)\n\t{\n\t\tpfree(qr.operandData);\n\t\treturn 0.0;\n\t}\n\n\tMemSet(&ext, 0, sizeof(CoverExt));\n\twhile (Cover(doc, doclen, &qr, &ext))\n\t{\n\t\tdouble\t\tCpos = 0.0;\n\t\tdouble\t\tInvSum = 0.0;\n\t\tint\t\t\tnNoise;\n\t\tDocRepresentation *ptr = ext.begin;\n\n\t\twhile (ptr <= ext.end)\n\t\t{\n\t\t\tInvSum += invws[WEP_GETWEIGHT(ptr->pos)];\n\t\t\tptr++;\n\t\t}\n\n\t\tCpos = ((double) (ext.end - ext.begin + 1)) / InvSum;\n\n\t\t/*\n\t\t * if doc are big enough then ext.q may be equal to ext.p due to limit\n\t\t * of positional information. In this case we approximate number of\n\t\t * noise word as half cover's length\n\t\t */\n\t\tnNoise = (ext.q - ext.p) - (ext.end - ext.begin);\n\t\tif (nNoise < 0)\n\t\t\tnNoise = (ext.end - ext.begin) / 2;\n\t\tWdoc += Cpos / ((double) (1 + nNoise));\n\n\t\tCurExtPos = ((double) (ext.q + ext.p)) / 2.0;\n\t\tif (NExtent > 0 && CurExtPos > PrevExtPos\t/* prevent division by\n\t\t\t\t\t\t\t\t\t\t\t\t\t * zero in a case of\n\t\t\t  * multiple lexize */ )\n\t\t\tSumDist += 1.0 / (CurExtPos - PrevExtPos);\n\n\t\tPrevExtPos = CurExtPos;\n\t\tNExtent++;\n\t}\n\n\tif ((method & RANK_NORM_LOGLENGTH) && txt->size > 0)\n\t\tWdoc /= log((double) (cnt_length(txt) + 1));\n\n\tif (method & RANK_NORM_LENGTH)\n\t{\n\t\tlen = cnt_length(txt);\n\t\tif (len > 0)\n\t\t\tWdoc /= (double) len;\n\t}\n\n\tif ((method & RANK_NORM_EXTDIST) && NExtent > 0 && SumDist > 0)\n\t\tWdoc /= ((double) NExtent) / SumDist;\n\n\tif ((method & RANK_NORM_UNIQ) && txt->size > 0)\n\t\tWdoc /= (double) (txt->size);\n\n\tif ((method & RANK_NORM_LOGUNIQ) && txt->size > 0)\n\t\tWdoc /= log((double) (txt->size + 1)) / log(2.0);\n\n\tif (method & RANK_NORM_RDIVRPLUS1)\n\t\tWdoc /= (Wdoc + 1);\n\n\tpfree(doc);\n\n\tpfree(qr.operandData);\n\n\treturn (float4) Wdoc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getWeights",
          "args": [
            "NULL"
          ],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "getWeights",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsrank.c",
          "lines": "400-436",
          "snippet": "static const float *\ngetWeights(ArrayType *win)\n{\n\tstatic float ws[lengthof(weights)];\n\tint\t\t\ti;\n\tfloat4\t   *arrdata;\n\n\tif (win == NULL)\n\t\treturn weights;\n\n\tif (ARR_NDIM(win) != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"array of weight must be one-dimensional\")));\n\n\tif (ArrayGetNItems(ARR_NDIM(win), ARR_DIMS(win)) < lengthof(weights))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"array of weight is too short\")));\n\n\tif (array_contains_nulls(win))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"array of weight must not contain nulls\")));\n\n\tarrdata = (float4 *) ARR_DATA_PTR(win);\n\tfor (i = 0; i < lengthof(weights); i++)\n\t{\n\t\tws[i] = (arrdata[i] >= 0) ? arrdata[i] : weights[i];\n\t\tif (ws[i] > 1.0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"weight out of range\")));\n\t}\n\n\treturn ws;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const float weights[] = {0.1f, 0.2f, 0.4f, 1.0f};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"tsearch/ts_utils.h\"\n#include <math.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic const float weights[] = {0.1f, 0.2f, 0.4f, 1.0f};\n\nstatic const float *\ngetWeights(ArrayType *win)\n{\n\tstatic float ws[lengthof(weights)];\n\tint\t\t\ti;\n\tfloat4\t   *arrdata;\n\n\tif (win == NULL)\n\t\treturn weights;\n\n\tif (ARR_NDIM(win) != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"array of weight must be one-dimensional\")));\n\n\tif (ArrayGetNItems(ARR_NDIM(win), ARR_DIMS(win)) < lengthof(weights))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"array of weight is too short\")));\n\n\tif (array_contains_nulls(win))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"array of weight must not contain nulls\")));\n\n\tarrdata = (float4 *) ARR_DATA_PTR(win);\n\tfor (i = 0; i < lengthof(weights); i++)\n\t{\n\t\tws[i] = (arrdata[i] >= 0) ? arrdata[i] : weights[i];\n\t\tif (ws[i] > 1.0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"weight out of range\")));\n\t}\n\n\treturn ws;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "2"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TSQUERY",
          "args": [
            "1"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TSVECTOR",
          "args": [
            "0"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"tsearch/ts_utils.h\"\n#include <math.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\nts_rankcd_ttf(PG_FUNCTION_ARGS)\n{\n\tTSVector\ttxt = PG_GETARG_TSVECTOR(0);\n\tTSQuery\t\tquery = PG_GETARG_TSQUERY(1);\n\tint\t\t\tmethod = PG_GETARG_INT32(2);\n\tfloat\t\tres;\n\n\tres = calc_rank_cd(getWeights(NULL), txt, query, method);\n\n\tPG_FREE_IF_COPY(txt, 0);\n\tPG_FREE_IF_COPY(query, 1);\n\tPG_RETURN_FLOAT4(res);\n}"
  },
  {
    "function_name": "ts_rankcd_wtt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsrank.c",
    "lines": "966-980",
    "snippet": "Datum\nts_rankcd_wtt(PG_FUNCTION_ARGS)\n{\n\tArrayType  *win = (ArrayType *) PG_DETOAST_DATUM(PG_GETARG_DATUM(0));\n\tTSVector\ttxt = PG_GETARG_TSVECTOR(1);\n\tTSQuery\t\tquery = PG_GETARG_TSQUERY(2);\n\tfloat\t\tres;\n\n\tres = calc_rank_cd(getWeights(win), txt, query, DEF_NORM_METHOD);\n\n\tPG_FREE_IF_COPY(win, 0);\n\tPG_FREE_IF_COPY(txt, 1);\n\tPG_FREE_IF_COPY(query, 2);\n\tPG_RETURN_FLOAT4(res);\n}",
    "includes": [
      "#include \"miscadmin.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define DEF_NORM_METHOD\t\t\tRANK_NO_NORM"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT4",
          "args": [
            "res"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "query",
            "2"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "txt",
            "1"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "win",
            "0"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calc_rank_cd",
          "args": [
            "getWeights(win)",
            "txt",
            "query",
            "DEF_NORM_METHOD"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "calc_rank_cd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsrank.c",
          "lines": "846-947",
          "snippet": "static float4\ncalc_rank_cd(const float4 *arrdata, TSVector txt, TSQuery query, int method)\n{\n\tDocRepresentation *doc;\n\tint\t\t\tlen,\n\t\t\t\ti,\n\t\t\t\tdoclen = 0;\n\tCoverExt\text;\n\tdouble\t\tWdoc = 0.0;\n\tdouble\t\tinvws[lengthof(weights)];\n\tdouble\t\tSumDist = 0.0,\n\t\t\t\tPrevExtPos = 0.0,\n\t\t\t\tCurExtPos = 0.0;\n\tint\t\t\tNExtent = 0;\n\tQueryRepresentation qr;\n\n\n\tfor (i = 0; i < lengthof(weights); i++)\n\t{\n\t\tinvws[i] = ((double) ((arrdata[i] >= 0) ? arrdata[i] : weights[i]));\n\t\tif (invws[i] > 1.0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"weight out of range\")));\n\t\tinvws[i] = 1.0 / invws[i];\n\t}\n\n\tqr.query = query;\n\tqr.operandData = (QueryRepresentationOperand *)\n\t\tpalloc0(sizeof(QueryRepresentationOperand) * query->size);\n\n\tdoc = get_docrep(txt, &qr, &doclen);\n\tif (!doc)\n\t{\n\t\tpfree(qr.operandData);\n\t\treturn 0.0;\n\t}\n\n\tMemSet(&ext, 0, sizeof(CoverExt));\n\twhile (Cover(doc, doclen, &qr, &ext))\n\t{\n\t\tdouble\t\tCpos = 0.0;\n\t\tdouble\t\tInvSum = 0.0;\n\t\tint\t\t\tnNoise;\n\t\tDocRepresentation *ptr = ext.begin;\n\n\t\twhile (ptr <= ext.end)\n\t\t{\n\t\t\tInvSum += invws[WEP_GETWEIGHT(ptr->pos)];\n\t\t\tptr++;\n\t\t}\n\n\t\tCpos = ((double) (ext.end - ext.begin + 1)) / InvSum;\n\n\t\t/*\n\t\t * if doc are big enough then ext.q may be equal to ext.p due to limit\n\t\t * of positional information. In this case we approximate number of\n\t\t * noise word as half cover's length\n\t\t */\n\t\tnNoise = (ext.q - ext.p) - (ext.end - ext.begin);\n\t\tif (nNoise < 0)\n\t\t\tnNoise = (ext.end - ext.begin) / 2;\n\t\tWdoc += Cpos / ((double) (1 + nNoise));\n\n\t\tCurExtPos = ((double) (ext.q + ext.p)) / 2.0;\n\t\tif (NExtent > 0 && CurExtPos > PrevExtPos\t/* prevent division by\n\t\t\t\t\t\t\t\t\t\t\t\t\t * zero in a case of\n\t\t\t  * multiple lexize */ )\n\t\t\tSumDist += 1.0 / (CurExtPos - PrevExtPos);\n\n\t\tPrevExtPos = CurExtPos;\n\t\tNExtent++;\n\t}\n\n\tif ((method & RANK_NORM_LOGLENGTH) && txt->size > 0)\n\t\tWdoc /= log((double) (cnt_length(txt) + 1));\n\n\tif (method & RANK_NORM_LENGTH)\n\t{\n\t\tlen = cnt_length(txt);\n\t\tif (len > 0)\n\t\t\tWdoc /= (double) len;\n\t}\n\n\tif ((method & RANK_NORM_EXTDIST) && NExtent > 0 && SumDist > 0)\n\t\tWdoc /= ((double) NExtent) / SumDist;\n\n\tif ((method & RANK_NORM_UNIQ) && txt->size > 0)\n\t\tWdoc /= (double) (txt->size);\n\n\tif ((method & RANK_NORM_LOGUNIQ) && txt->size > 0)\n\t\tWdoc /= log((double) (txt->size + 1)) / log(2.0);\n\n\tif (method & RANK_NORM_RDIVRPLUS1)\n\t\tWdoc /= (Wdoc + 1);\n\n\tpfree(doc);\n\n\tpfree(qr.operandData);\n\n\treturn (float4) Wdoc;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RANK_NORM_RDIVRPLUS1\t0x20",
            "#define RANK_NORM_LOGUNIQ\t\t0x10",
            "#define RANK_NORM_UNIQ\t\t\t0x08",
            "#define RANK_NORM_EXTDIST\t\t0x04",
            "#define RANK_NORM_LENGTH\t\t0x02",
            "#define RANK_NORM_LOGLENGTH\t\t0x01"
          ],
          "globals_used": [
            "static const float weights[] = {0.1f, 0.2f, 0.4f, 1.0f};",
            "static float calc_rank_or(const float *w, TSVector t, TSQuery q);",
            "static float calc_rank_and(const float *w, TSVector t, TSQuery q);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"tsearch/ts_utils.h\"\n#include <math.h>\n#include <limits.h>\n#include \"postgres.h\"\n\n#define RANK_NORM_RDIVRPLUS1\t0x20\n#define RANK_NORM_LOGUNIQ\t\t0x10\n#define RANK_NORM_UNIQ\t\t\t0x08\n#define RANK_NORM_EXTDIST\t\t0x04\n#define RANK_NORM_LENGTH\t\t0x02\n#define RANK_NORM_LOGLENGTH\t\t0x01\n\nstatic const float weights[] = {0.1f, 0.2f, 0.4f, 1.0f};\nstatic float calc_rank_or(const float *w, TSVector t, TSQuery q);\nstatic float calc_rank_and(const float *w, TSVector t, TSQuery q);\n\nstatic float4\ncalc_rank_cd(const float4 *arrdata, TSVector txt, TSQuery query, int method)\n{\n\tDocRepresentation *doc;\n\tint\t\t\tlen,\n\t\t\t\ti,\n\t\t\t\tdoclen = 0;\n\tCoverExt\text;\n\tdouble\t\tWdoc = 0.0;\n\tdouble\t\tinvws[lengthof(weights)];\n\tdouble\t\tSumDist = 0.0,\n\t\t\t\tPrevExtPos = 0.0,\n\t\t\t\tCurExtPos = 0.0;\n\tint\t\t\tNExtent = 0;\n\tQueryRepresentation qr;\n\n\n\tfor (i = 0; i < lengthof(weights); i++)\n\t{\n\t\tinvws[i] = ((double) ((arrdata[i] >= 0) ? arrdata[i] : weights[i]));\n\t\tif (invws[i] > 1.0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"weight out of range\")));\n\t\tinvws[i] = 1.0 / invws[i];\n\t}\n\n\tqr.query = query;\n\tqr.operandData = (QueryRepresentationOperand *)\n\t\tpalloc0(sizeof(QueryRepresentationOperand) * query->size);\n\n\tdoc = get_docrep(txt, &qr, &doclen);\n\tif (!doc)\n\t{\n\t\tpfree(qr.operandData);\n\t\treturn 0.0;\n\t}\n\n\tMemSet(&ext, 0, sizeof(CoverExt));\n\twhile (Cover(doc, doclen, &qr, &ext))\n\t{\n\t\tdouble\t\tCpos = 0.0;\n\t\tdouble\t\tInvSum = 0.0;\n\t\tint\t\t\tnNoise;\n\t\tDocRepresentation *ptr = ext.begin;\n\n\t\twhile (ptr <= ext.end)\n\t\t{\n\t\t\tInvSum += invws[WEP_GETWEIGHT(ptr->pos)];\n\t\t\tptr++;\n\t\t}\n\n\t\tCpos = ((double) (ext.end - ext.begin + 1)) / InvSum;\n\n\t\t/*\n\t\t * if doc are big enough then ext.q may be equal to ext.p due to limit\n\t\t * of positional information. In this case we approximate number of\n\t\t * noise word as half cover's length\n\t\t */\n\t\tnNoise = (ext.q - ext.p) - (ext.end - ext.begin);\n\t\tif (nNoise < 0)\n\t\t\tnNoise = (ext.end - ext.begin) / 2;\n\t\tWdoc += Cpos / ((double) (1 + nNoise));\n\n\t\tCurExtPos = ((double) (ext.q + ext.p)) / 2.0;\n\t\tif (NExtent > 0 && CurExtPos > PrevExtPos\t/* prevent division by\n\t\t\t\t\t\t\t\t\t\t\t\t\t * zero in a case of\n\t\t\t  * multiple lexize */ )\n\t\t\tSumDist += 1.0 / (CurExtPos - PrevExtPos);\n\n\t\tPrevExtPos = CurExtPos;\n\t\tNExtent++;\n\t}\n\n\tif ((method & RANK_NORM_LOGLENGTH) && txt->size > 0)\n\t\tWdoc /= log((double) (cnt_length(txt) + 1));\n\n\tif (method & RANK_NORM_LENGTH)\n\t{\n\t\tlen = cnt_length(txt);\n\t\tif (len > 0)\n\t\t\tWdoc /= (double) len;\n\t}\n\n\tif ((method & RANK_NORM_EXTDIST) && NExtent > 0 && SumDist > 0)\n\t\tWdoc /= ((double) NExtent) / SumDist;\n\n\tif ((method & RANK_NORM_UNIQ) && txt->size > 0)\n\t\tWdoc /= (double) (txt->size);\n\n\tif ((method & RANK_NORM_LOGUNIQ) && txt->size > 0)\n\t\tWdoc /= log((double) (txt->size + 1)) / log(2.0);\n\n\tif (method & RANK_NORM_RDIVRPLUS1)\n\t\tWdoc /= (Wdoc + 1);\n\n\tpfree(doc);\n\n\tpfree(qr.operandData);\n\n\treturn (float4) Wdoc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getWeights",
          "args": [
            "win"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "getWeights",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsrank.c",
          "lines": "400-436",
          "snippet": "static const float *\ngetWeights(ArrayType *win)\n{\n\tstatic float ws[lengthof(weights)];\n\tint\t\t\ti;\n\tfloat4\t   *arrdata;\n\n\tif (win == NULL)\n\t\treturn weights;\n\n\tif (ARR_NDIM(win) != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"array of weight must be one-dimensional\")));\n\n\tif (ArrayGetNItems(ARR_NDIM(win), ARR_DIMS(win)) < lengthof(weights))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"array of weight is too short\")));\n\n\tif (array_contains_nulls(win))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"array of weight must not contain nulls\")));\n\n\tarrdata = (float4 *) ARR_DATA_PTR(win);\n\tfor (i = 0; i < lengthof(weights); i++)\n\t{\n\t\tws[i] = (arrdata[i] >= 0) ? arrdata[i] : weights[i];\n\t\tif (ws[i] > 1.0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"weight out of range\")));\n\t}\n\n\treturn ws;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const float weights[] = {0.1f, 0.2f, 0.4f, 1.0f};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"tsearch/ts_utils.h\"\n#include <math.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic const float weights[] = {0.1f, 0.2f, 0.4f, 1.0f};\n\nstatic const float *\ngetWeights(ArrayType *win)\n{\n\tstatic float ws[lengthof(weights)];\n\tint\t\t\ti;\n\tfloat4\t   *arrdata;\n\n\tif (win == NULL)\n\t\treturn weights;\n\n\tif (ARR_NDIM(win) != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"array of weight must be one-dimensional\")));\n\n\tif (ArrayGetNItems(ARR_NDIM(win), ARR_DIMS(win)) < lengthof(weights))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"array of weight is too short\")));\n\n\tif (array_contains_nulls(win))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"array of weight must not contain nulls\")));\n\n\tarrdata = (float4 *) ARR_DATA_PTR(win);\n\tfor (i = 0; i < lengthof(weights); i++)\n\t{\n\t\tws[i] = (arrdata[i] >= 0) ? arrdata[i] : weights[i];\n\t\tif (ws[i] > 1.0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"weight out of range\")));\n\t}\n\n\treturn ws;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TSQUERY",
          "args": [
            "2"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TSVECTOR",
          "args": [
            "1"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_DETOAST_DATUM",
          "args": [
            "PG_GETARG_DATUM(0)"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "0"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"tsearch/ts_utils.h\"\n#include <math.h>\n#include <limits.h>\n#include \"postgres.h\"\n\n#define DEF_NORM_METHOD\t\t\tRANK_NO_NORM\n\nDatum\nts_rankcd_wtt(PG_FUNCTION_ARGS)\n{\n\tArrayType  *win = (ArrayType *) PG_DETOAST_DATUM(PG_GETARG_DATUM(0));\n\tTSVector\ttxt = PG_GETARG_TSVECTOR(1);\n\tTSQuery\t\tquery = PG_GETARG_TSQUERY(2);\n\tfloat\t\tres;\n\n\tres = calc_rank_cd(getWeights(win), txt, query, DEF_NORM_METHOD);\n\n\tPG_FREE_IF_COPY(win, 0);\n\tPG_FREE_IF_COPY(txt, 1);\n\tPG_FREE_IF_COPY(query, 2);\n\tPG_RETURN_FLOAT4(res);\n}"
  },
  {
    "function_name": "ts_rankcd_wttf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsrank.c",
    "lines": "949-964",
    "snippet": "Datum\nts_rankcd_wttf(PG_FUNCTION_ARGS)\n{\n\tArrayType  *win = (ArrayType *) PG_DETOAST_DATUM(PG_GETARG_DATUM(0));\n\tTSVector\ttxt = PG_GETARG_TSVECTOR(1);\n\tTSQuery\t\tquery = PG_GETARG_TSQUERY(2);\n\tint\t\t\tmethod = PG_GETARG_INT32(3);\n\tfloat\t\tres;\n\n\tres = calc_rank_cd(getWeights(win), txt, query, method);\n\n\tPG_FREE_IF_COPY(win, 0);\n\tPG_FREE_IF_COPY(txt, 1);\n\tPG_FREE_IF_COPY(query, 2);\n\tPG_RETURN_FLOAT4(res);\n}",
    "includes": [
      "#include \"miscadmin.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT4",
          "args": [
            "res"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "query",
            "2"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "txt",
            "1"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "win",
            "0"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calc_rank_cd",
          "args": [
            "getWeights(win)",
            "txt",
            "query",
            "method"
          ],
          "line": 958
        },
        "resolved": true,
        "details": {
          "function_name": "calc_rank_cd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsrank.c",
          "lines": "846-947",
          "snippet": "static float4\ncalc_rank_cd(const float4 *arrdata, TSVector txt, TSQuery query, int method)\n{\n\tDocRepresentation *doc;\n\tint\t\t\tlen,\n\t\t\t\ti,\n\t\t\t\tdoclen = 0;\n\tCoverExt\text;\n\tdouble\t\tWdoc = 0.0;\n\tdouble\t\tinvws[lengthof(weights)];\n\tdouble\t\tSumDist = 0.0,\n\t\t\t\tPrevExtPos = 0.0,\n\t\t\t\tCurExtPos = 0.0;\n\tint\t\t\tNExtent = 0;\n\tQueryRepresentation qr;\n\n\n\tfor (i = 0; i < lengthof(weights); i++)\n\t{\n\t\tinvws[i] = ((double) ((arrdata[i] >= 0) ? arrdata[i] : weights[i]));\n\t\tif (invws[i] > 1.0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"weight out of range\")));\n\t\tinvws[i] = 1.0 / invws[i];\n\t}\n\n\tqr.query = query;\n\tqr.operandData = (QueryRepresentationOperand *)\n\t\tpalloc0(sizeof(QueryRepresentationOperand) * query->size);\n\n\tdoc = get_docrep(txt, &qr, &doclen);\n\tif (!doc)\n\t{\n\t\tpfree(qr.operandData);\n\t\treturn 0.0;\n\t}\n\n\tMemSet(&ext, 0, sizeof(CoverExt));\n\twhile (Cover(doc, doclen, &qr, &ext))\n\t{\n\t\tdouble\t\tCpos = 0.0;\n\t\tdouble\t\tInvSum = 0.0;\n\t\tint\t\t\tnNoise;\n\t\tDocRepresentation *ptr = ext.begin;\n\n\t\twhile (ptr <= ext.end)\n\t\t{\n\t\t\tInvSum += invws[WEP_GETWEIGHT(ptr->pos)];\n\t\t\tptr++;\n\t\t}\n\n\t\tCpos = ((double) (ext.end - ext.begin + 1)) / InvSum;\n\n\t\t/*\n\t\t * if doc are big enough then ext.q may be equal to ext.p due to limit\n\t\t * of positional information. In this case we approximate number of\n\t\t * noise word as half cover's length\n\t\t */\n\t\tnNoise = (ext.q - ext.p) - (ext.end - ext.begin);\n\t\tif (nNoise < 0)\n\t\t\tnNoise = (ext.end - ext.begin) / 2;\n\t\tWdoc += Cpos / ((double) (1 + nNoise));\n\n\t\tCurExtPos = ((double) (ext.q + ext.p)) / 2.0;\n\t\tif (NExtent > 0 && CurExtPos > PrevExtPos\t/* prevent division by\n\t\t\t\t\t\t\t\t\t\t\t\t\t * zero in a case of\n\t\t\t  * multiple lexize */ )\n\t\t\tSumDist += 1.0 / (CurExtPos - PrevExtPos);\n\n\t\tPrevExtPos = CurExtPos;\n\t\tNExtent++;\n\t}\n\n\tif ((method & RANK_NORM_LOGLENGTH) && txt->size > 0)\n\t\tWdoc /= log((double) (cnt_length(txt) + 1));\n\n\tif (method & RANK_NORM_LENGTH)\n\t{\n\t\tlen = cnt_length(txt);\n\t\tif (len > 0)\n\t\t\tWdoc /= (double) len;\n\t}\n\n\tif ((method & RANK_NORM_EXTDIST) && NExtent > 0 && SumDist > 0)\n\t\tWdoc /= ((double) NExtent) / SumDist;\n\n\tif ((method & RANK_NORM_UNIQ) && txt->size > 0)\n\t\tWdoc /= (double) (txt->size);\n\n\tif ((method & RANK_NORM_LOGUNIQ) && txt->size > 0)\n\t\tWdoc /= log((double) (txt->size + 1)) / log(2.0);\n\n\tif (method & RANK_NORM_RDIVRPLUS1)\n\t\tWdoc /= (Wdoc + 1);\n\n\tpfree(doc);\n\n\tpfree(qr.operandData);\n\n\treturn (float4) Wdoc;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RANK_NORM_RDIVRPLUS1\t0x20",
            "#define RANK_NORM_LOGUNIQ\t\t0x10",
            "#define RANK_NORM_UNIQ\t\t\t0x08",
            "#define RANK_NORM_EXTDIST\t\t0x04",
            "#define RANK_NORM_LENGTH\t\t0x02",
            "#define RANK_NORM_LOGLENGTH\t\t0x01"
          ],
          "globals_used": [
            "static const float weights[] = {0.1f, 0.2f, 0.4f, 1.0f};",
            "static float calc_rank_or(const float *w, TSVector t, TSQuery q);",
            "static float calc_rank_and(const float *w, TSVector t, TSQuery q);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"tsearch/ts_utils.h\"\n#include <math.h>\n#include <limits.h>\n#include \"postgres.h\"\n\n#define RANK_NORM_RDIVRPLUS1\t0x20\n#define RANK_NORM_LOGUNIQ\t\t0x10\n#define RANK_NORM_UNIQ\t\t\t0x08\n#define RANK_NORM_EXTDIST\t\t0x04\n#define RANK_NORM_LENGTH\t\t0x02\n#define RANK_NORM_LOGLENGTH\t\t0x01\n\nstatic const float weights[] = {0.1f, 0.2f, 0.4f, 1.0f};\nstatic float calc_rank_or(const float *w, TSVector t, TSQuery q);\nstatic float calc_rank_and(const float *w, TSVector t, TSQuery q);\n\nstatic float4\ncalc_rank_cd(const float4 *arrdata, TSVector txt, TSQuery query, int method)\n{\n\tDocRepresentation *doc;\n\tint\t\t\tlen,\n\t\t\t\ti,\n\t\t\t\tdoclen = 0;\n\tCoverExt\text;\n\tdouble\t\tWdoc = 0.0;\n\tdouble\t\tinvws[lengthof(weights)];\n\tdouble\t\tSumDist = 0.0,\n\t\t\t\tPrevExtPos = 0.0,\n\t\t\t\tCurExtPos = 0.0;\n\tint\t\t\tNExtent = 0;\n\tQueryRepresentation qr;\n\n\n\tfor (i = 0; i < lengthof(weights); i++)\n\t{\n\t\tinvws[i] = ((double) ((arrdata[i] >= 0) ? arrdata[i] : weights[i]));\n\t\tif (invws[i] > 1.0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"weight out of range\")));\n\t\tinvws[i] = 1.0 / invws[i];\n\t}\n\n\tqr.query = query;\n\tqr.operandData = (QueryRepresentationOperand *)\n\t\tpalloc0(sizeof(QueryRepresentationOperand) * query->size);\n\n\tdoc = get_docrep(txt, &qr, &doclen);\n\tif (!doc)\n\t{\n\t\tpfree(qr.operandData);\n\t\treturn 0.0;\n\t}\n\n\tMemSet(&ext, 0, sizeof(CoverExt));\n\twhile (Cover(doc, doclen, &qr, &ext))\n\t{\n\t\tdouble\t\tCpos = 0.0;\n\t\tdouble\t\tInvSum = 0.0;\n\t\tint\t\t\tnNoise;\n\t\tDocRepresentation *ptr = ext.begin;\n\n\t\twhile (ptr <= ext.end)\n\t\t{\n\t\t\tInvSum += invws[WEP_GETWEIGHT(ptr->pos)];\n\t\t\tptr++;\n\t\t}\n\n\t\tCpos = ((double) (ext.end - ext.begin + 1)) / InvSum;\n\n\t\t/*\n\t\t * if doc are big enough then ext.q may be equal to ext.p due to limit\n\t\t * of positional information. In this case we approximate number of\n\t\t * noise word as half cover's length\n\t\t */\n\t\tnNoise = (ext.q - ext.p) - (ext.end - ext.begin);\n\t\tif (nNoise < 0)\n\t\t\tnNoise = (ext.end - ext.begin) / 2;\n\t\tWdoc += Cpos / ((double) (1 + nNoise));\n\n\t\tCurExtPos = ((double) (ext.q + ext.p)) / 2.0;\n\t\tif (NExtent > 0 && CurExtPos > PrevExtPos\t/* prevent division by\n\t\t\t\t\t\t\t\t\t\t\t\t\t * zero in a case of\n\t\t\t  * multiple lexize */ )\n\t\t\tSumDist += 1.0 / (CurExtPos - PrevExtPos);\n\n\t\tPrevExtPos = CurExtPos;\n\t\tNExtent++;\n\t}\n\n\tif ((method & RANK_NORM_LOGLENGTH) && txt->size > 0)\n\t\tWdoc /= log((double) (cnt_length(txt) + 1));\n\n\tif (method & RANK_NORM_LENGTH)\n\t{\n\t\tlen = cnt_length(txt);\n\t\tif (len > 0)\n\t\t\tWdoc /= (double) len;\n\t}\n\n\tif ((method & RANK_NORM_EXTDIST) && NExtent > 0 && SumDist > 0)\n\t\tWdoc /= ((double) NExtent) / SumDist;\n\n\tif ((method & RANK_NORM_UNIQ) && txt->size > 0)\n\t\tWdoc /= (double) (txt->size);\n\n\tif ((method & RANK_NORM_LOGUNIQ) && txt->size > 0)\n\t\tWdoc /= log((double) (txt->size + 1)) / log(2.0);\n\n\tif (method & RANK_NORM_RDIVRPLUS1)\n\t\tWdoc /= (Wdoc + 1);\n\n\tpfree(doc);\n\n\tpfree(qr.operandData);\n\n\treturn (float4) Wdoc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getWeights",
          "args": [
            "win"
          ],
          "line": 958
        },
        "resolved": true,
        "details": {
          "function_name": "getWeights",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsrank.c",
          "lines": "400-436",
          "snippet": "static const float *\ngetWeights(ArrayType *win)\n{\n\tstatic float ws[lengthof(weights)];\n\tint\t\t\ti;\n\tfloat4\t   *arrdata;\n\n\tif (win == NULL)\n\t\treturn weights;\n\n\tif (ARR_NDIM(win) != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"array of weight must be one-dimensional\")));\n\n\tif (ArrayGetNItems(ARR_NDIM(win), ARR_DIMS(win)) < lengthof(weights))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"array of weight is too short\")));\n\n\tif (array_contains_nulls(win))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"array of weight must not contain nulls\")));\n\n\tarrdata = (float4 *) ARR_DATA_PTR(win);\n\tfor (i = 0; i < lengthof(weights); i++)\n\t{\n\t\tws[i] = (arrdata[i] >= 0) ? arrdata[i] : weights[i];\n\t\tif (ws[i] > 1.0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"weight out of range\")));\n\t}\n\n\treturn ws;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const float weights[] = {0.1f, 0.2f, 0.4f, 1.0f};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"tsearch/ts_utils.h\"\n#include <math.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic const float weights[] = {0.1f, 0.2f, 0.4f, 1.0f};\n\nstatic const float *\ngetWeights(ArrayType *win)\n{\n\tstatic float ws[lengthof(weights)];\n\tint\t\t\ti;\n\tfloat4\t   *arrdata;\n\n\tif (win == NULL)\n\t\treturn weights;\n\n\tif (ARR_NDIM(win) != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"array of weight must be one-dimensional\")));\n\n\tif (ArrayGetNItems(ARR_NDIM(win), ARR_DIMS(win)) < lengthof(weights))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"array of weight is too short\")));\n\n\tif (array_contains_nulls(win))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"array of weight must not contain nulls\")));\n\n\tarrdata = (float4 *) ARR_DATA_PTR(win);\n\tfor (i = 0; i < lengthof(weights); i++)\n\t{\n\t\tws[i] = (arrdata[i] >= 0) ? arrdata[i] : weights[i];\n\t\tif (ws[i] > 1.0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"weight out of range\")));\n\t}\n\n\treturn ws;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "3"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TSQUERY",
          "args": [
            "2"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TSVECTOR",
          "args": [
            "1"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_DETOAST_DATUM",
          "args": [
            "PG_GETARG_DATUM(0)"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "0"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"tsearch/ts_utils.h\"\n#include <math.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\nts_rankcd_wttf(PG_FUNCTION_ARGS)\n{\n\tArrayType  *win = (ArrayType *) PG_DETOAST_DATUM(PG_GETARG_DATUM(0));\n\tTSVector\ttxt = PG_GETARG_TSVECTOR(1);\n\tTSQuery\t\tquery = PG_GETARG_TSQUERY(2);\n\tint\t\t\tmethod = PG_GETARG_INT32(3);\n\tfloat\t\tres;\n\n\tres = calc_rank_cd(getWeights(win), txt, query, method);\n\n\tPG_FREE_IF_COPY(win, 0);\n\tPG_FREE_IF_COPY(txt, 1);\n\tPG_FREE_IF_COPY(query, 2);\n\tPG_RETURN_FLOAT4(res);\n}"
  },
  {
    "function_name": "calc_rank_cd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsrank.c",
    "lines": "846-947",
    "snippet": "static float4\ncalc_rank_cd(const float4 *arrdata, TSVector txt, TSQuery query, int method)\n{\n\tDocRepresentation *doc;\n\tint\t\t\tlen,\n\t\t\t\ti,\n\t\t\t\tdoclen = 0;\n\tCoverExt\text;\n\tdouble\t\tWdoc = 0.0;\n\tdouble\t\tinvws[lengthof(weights)];\n\tdouble\t\tSumDist = 0.0,\n\t\t\t\tPrevExtPos = 0.0,\n\t\t\t\tCurExtPos = 0.0;\n\tint\t\t\tNExtent = 0;\n\tQueryRepresentation qr;\n\n\n\tfor (i = 0; i < lengthof(weights); i++)\n\t{\n\t\tinvws[i] = ((double) ((arrdata[i] >= 0) ? arrdata[i] : weights[i]));\n\t\tif (invws[i] > 1.0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"weight out of range\")));\n\t\tinvws[i] = 1.0 / invws[i];\n\t}\n\n\tqr.query = query;\n\tqr.operandData = (QueryRepresentationOperand *)\n\t\tpalloc0(sizeof(QueryRepresentationOperand) * query->size);\n\n\tdoc = get_docrep(txt, &qr, &doclen);\n\tif (!doc)\n\t{\n\t\tpfree(qr.operandData);\n\t\treturn 0.0;\n\t}\n\n\tMemSet(&ext, 0, sizeof(CoverExt));\n\twhile (Cover(doc, doclen, &qr, &ext))\n\t{\n\t\tdouble\t\tCpos = 0.0;\n\t\tdouble\t\tInvSum = 0.0;\n\t\tint\t\t\tnNoise;\n\t\tDocRepresentation *ptr = ext.begin;\n\n\t\twhile (ptr <= ext.end)\n\t\t{\n\t\t\tInvSum += invws[WEP_GETWEIGHT(ptr->pos)];\n\t\t\tptr++;\n\t\t}\n\n\t\tCpos = ((double) (ext.end - ext.begin + 1)) / InvSum;\n\n\t\t/*\n\t\t * if doc are big enough then ext.q may be equal to ext.p due to limit\n\t\t * of positional information. In this case we approximate number of\n\t\t * noise word as half cover's length\n\t\t */\n\t\tnNoise = (ext.q - ext.p) - (ext.end - ext.begin);\n\t\tif (nNoise < 0)\n\t\t\tnNoise = (ext.end - ext.begin) / 2;\n\t\tWdoc += Cpos / ((double) (1 + nNoise));\n\n\t\tCurExtPos = ((double) (ext.q + ext.p)) / 2.0;\n\t\tif (NExtent > 0 && CurExtPos > PrevExtPos\t/* prevent division by\n\t\t\t\t\t\t\t\t\t\t\t\t\t * zero in a case of\n\t\t\t  * multiple lexize */ )\n\t\t\tSumDist += 1.0 / (CurExtPos - PrevExtPos);\n\n\t\tPrevExtPos = CurExtPos;\n\t\tNExtent++;\n\t}\n\n\tif ((method & RANK_NORM_LOGLENGTH) && txt->size > 0)\n\t\tWdoc /= log((double) (cnt_length(txt) + 1));\n\n\tif (method & RANK_NORM_LENGTH)\n\t{\n\t\tlen = cnt_length(txt);\n\t\tif (len > 0)\n\t\t\tWdoc /= (double) len;\n\t}\n\n\tif ((method & RANK_NORM_EXTDIST) && NExtent > 0 && SumDist > 0)\n\t\tWdoc /= ((double) NExtent) / SumDist;\n\n\tif ((method & RANK_NORM_UNIQ) && txt->size > 0)\n\t\tWdoc /= (double) (txt->size);\n\n\tif ((method & RANK_NORM_LOGUNIQ) && txt->size > 0)\n\t\tWdoc /= log((double) (txt->size + 1)) / log(2.0);\n\n\tif (method & RANK_NORM_RDIVRPLUS1)\n\t\tWdoc /= (Wdoc + 1);\n\n\tpfree(doc);\n\n\tpfree(qr.operandData);\n\n\treturn (float4) Wdoc;\n}",
    "includes": [
      "#include \"miscadmin.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define RANK_NORM_RDIVRPLUS1\t0x20",
      "#define RANK_NORM_LOGUNIQ\t\t0x10",
      "#define RANK_NORM_UNIQ\t\t\t0x08",
      "#define RANK_NORM_EXTDIST\t\t0x04",
      "#define RANK_NORM_LENGTH\t\t0x02",
      "#define RANK_NORM_LOGLENGTH\t\t0x01"
    ],
    "globals_used": [
      "static const float weights[] = {0.1f, 0.2f, 0.4f, 1.0f};",
      "static float calc_rank_or(const float *w, TSVector t, TSQuery q);",
      "static float calc_rank_and(const float *w, TSVector t, TSQuery q);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "qr.operandData"
          ],
          "line": 944
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log",
          "args": [
            "2.0"
          ],
          "line": 937
        },
        "resolved": true,
        "details": {
          "function_name": "floor_log2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_selfuncs.c",
          "lines": "1090-1122",
          "snippet": "static int\nfloor_log2(uint32 n)\n{\n\tint\t\t\tlogval = 0;\n\n\tif (n == 0)\n\t\treturn -1;\n\tif (n >= (1 << 16))\n\t{\n\t\tn >>= 16;\n\t\tlogval += 16;\n\t}\n\tif (n >= (1 << 8))\n\t{\n\t\tn >>= 8;\n\t\tlogval += 8;\n\t}\n\tif (n >= (1 << 4))\n\t{\n\t\tn >>= 4;\n\t\tlogval += 4;\n\t}\n\tif (n >= (1 << 2))\n\t{\n\t\tn >>= 2;\n\t\tlogval += 2;\n\t}\n\tif (n >= (1 << 1))\n\t{\n\t\tlogval += 1;\n\t}\n\treturn logval;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static float *calc_hist(const float4 *hist, int nhist, int n);",
            "static int\tfloor_log2(uint32 n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/clauses.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nstatic float *calc_hist(const float4 *hist, int nhist, int n);\nstatic int\tfloor_log2(uint32 n);\n\nstatic int\nfloor_log2(uint32 n)\n{\n\tint\t\t\tlogval = 0;\n\n\tif (n == 0)\n\t\treturn -1;\n\tif (n >= (1 << 16))\n\t{\n\t\tn >>= 16;\n\t\tlogval += 16;\n\t}\n\tif (n >= (1 << 8))\n\t{\n\t\tn >>= 8;\n\t\tlogval += 8;\n\t}\n\tif (n >= (1 << 4))\n\t{\n\t\tn >>= 4;\n\t\tlogval += 4;\n\t}\n\tif (n >= (1 << 2))\n\t{\n\t\tn >>= 2;\n\t\tlogval += 2;\n\t}\n\tif (n >= (1 << 1))\n\t{\n\t\tlogval += 1;\n\t}\n\treturn logval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cnt_length",
          "args": [
            "txt"
          ],
          "line": 925
        },
        "resolved": true,
        "details": {
          "function_name": "cnt_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsrank.c",
          "lines": "53-73",
          "snippet": "static int\ncnt_length(TSVector t)\n{\n\tWordEntry  *ptr = ARRPTR(t),\n\t\t\t   *end = (WordEntry *) STRPTR(t);\n\tint\t\t\tlen = 0;\n\n\twhile (ptr < end)\n\t{\n\t\tint\t\t\tclen = POSDATALEN(t, ptr);\n\n\t\tif (clen == 0)\n\t\t\tlen += 1;\n\t\telse\n\t\t\tlen += clen;\n\n\t\tptr++;\n\t}\n\n\treturn len;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"tsearch/ts_utils.h\"\n#include <math.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic int\ncnt_length(TSVector t)\n{\n\tWordEntry  *ptr = ARRPTR(t),\n\t\t\t   *end = (WordEntry *) STRPTR(t);\n\tint\t\t\tlen = 0;\n\n\twhile (ptr < end)\n\t{\n\t\tint\t\t\tclen = POSDATALEN(t, ptr);\n\n\t\tif (clen == 0)\n\t\t\tlen += 1;\n\t\telse\n\t\t\tlen += clen;\n\n\t\tptr++;\n\t}\n\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WEP_GETWEIGHT",
          "args": [
            "ptr->pos"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Cover",
          "args": [
            "doc",
            "doclen",
            "&qr",
            "&ext"
          ],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "Cover",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsrank.c",
          "lines": "642-721",
          "snippet": "static bool\nCover(DocRepresentation *doc, int len, QueryRepresentation *qr, CoverExt *ext)\n{\n\tDocRepresentation *ptr;\n\tint\t\t\tlastpos = ext->pos;\n\tbool\t\tfound = false;\n\n\t/*\n\t * since this function recurses, it could be driven to stack overflow.\n\t * (though any decent compiler will optimize away the tail-recursion.\n\t */\n\tcheck_stack_depth();\n\n\tresetQueryRepresentation(qr, false);\n\n\text->p = INT_MAX;\n\text->q = 0;\n\tptr = doc + ext->pos;\n\n\t/* find upper bound of cover from current position, move up */\n\twhile (ptr - doc < len)\n\t{\n\t\tfillQueryRepresentationData(qr, ptr);\n\n\t\tif (TS_execute(GETQUERY(qr->query), (void *) qr,\n\t\t\t\t\t   TS_EXEC_EMPTY, checkcondition_QueryOperand))\n\t\t{\n\t\t\tif (WEP_GETPOS(ptr->pos) > ext->q)\n\t\t\t{\n\t\t\t\text->q = WEP_GETPOS(ptr->pos);\n\t\t\t\text->end = ptr;\n\t\t\t\tlastpos = ptr - doc;\n\t\t\t\tfound = true;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tptr++;\n\t}\n\n\tif (!found)\n\t\treturn false;\n\n\tresetQueryRepresentation(qr, true);\n\n\tptr = doc + lastpos;\n\n\t/* find lower bound of cover from found upper bound, move down */\n\twhile (ptr >= doc + ext->pos)\n\t{\n\t\t/*\n\t\t * we scan doc from right to left, so pos info in reverse order!\n\t\t */\n\t\tfillQueryRepresentationData(qr, ptr);\n\n\t\tif (TS_execute(GETQUERY(qr->query), (void *) qr,\n\t\t\t\t\t   TS_EXEC_CALC_NOT, checkcondition_QueryOperand))\n\t\t{\n\t\t\tif (WEP_GETPOS(ptr->pos) < ext->p)\n\t\t\t{\n\t\t\t\text->begin = ptr;\n\t\t\t\text->p = WEP_GETPOS(ptr->pos);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tptr--;\n\t}\n\n\tif (ext->p <= ext->q)\n\t{\n\t\t/*\n\t\t * set position for next try to next lexeme after beginning of found\n\t\t * cover\n\t\t */\n\t\text->pos = (ptr - doc) + 1;\n\t\treturn true;\n\t}\n\n\text->pos++;\n\treturn Cover(doc, len, qr, ext);\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static float calc_rank_or(const float *w, TSVector t, TSQuery q);",
            "static float calc_rank_and(const float *w, TSVector t, TSQuery q);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"tsearch/ts_utils.h\"\n#include <math.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic float calc_rank_or(const float *w, TSVector t, TSQuery q);\nstatic float calc_rank_and(const float *w, TSVector t, TSQuery q);\n\nstatic bool\nCover(DocRepresentation *doc, int len, QueryRepresentation *qr, CoverExt *ext)\n{\n\tDocRepresentation *ptr;\n\tint\t\t\tlastpos = ext->pos;\n\tbool\t\tfound = false;\n\n\t/*\n\t * since this function recurses, it could be driven to stack overflow.\n\t * (though any decent compiler will optimize away the tail-recursion.\n\t */\n\tcheck_stack_depth();\n\n\tresetQueryRepresentation(qr, false);\n\n\text->p = INT_MAX;\n\text->q = 0;\n\tptr = doc + ext->pos;\n\n\t/* find upper bound of cover from current position, move up */\n\twhile (ptr - doc < len)\n\t{\n\t\tfillQueryRepresentationData(qr, ptr);\n\n\t\tif (TS_execute(GETQUERY(qr->query), (void *) qr,\n\t\t\t\t\t   TS_EXEC_EMPTY, checkcondition_QueryOperand))\n\t\t{\n\t\t\tif (WEP_GETPOS(ptr->pos) > ext->q)\n\t\t\t{\n\t\t\t\text->q = WEP_GETPOS(ptr->pos);\n\t\t\t\text->end = ptr;\n\t\t\t\tlastpos = ptr - doc;\n\t\t\t\tfound = true;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tptr++;\n\t}\n\n\tif (!found)\n\t\treturn false;\n\n\tresetQueryRepresentation(qr, true);\n\n\tptr = doc + lastpos;\n\n\t/* find lower bound of cover from found upper bound, move down */\n\twhile (ptr >= doc + ext->pos)\n\t{\n\t\t/*\n\t\t * we scan doc from right to left, so pos info in reverse order!\n\t\t */\n\t\tfillQueryRepresentationData(qr, ptr);\n\n\t\tif (TS_execute(GETQUERY(qr->query), (void *) qr,\n\t\t\t\t\t   TS_EXEC_CALC_NOT, checkcondition_QueryOperand))\n\t\t{\n\t\t\tif (WEP_GETPOS(ptr->pos) < ext->p)\n\t\t\t{\n\t\t\t\text->begin = ptr;\n\t\t\t\text->p = WEP_GETPOS(ptr->pos);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tptr--;\n\t}\n\n\tif (ext->p <= ext->q)\n\t{\n\t\t/*\n\t\t * set position for next try to next lexeme after beginning of found\n\t\t * cover\n\t\t */\n\t\text->pos = (ptr - doc) + 1;\n\t\treturn true;\n\t}\n\n\text->pos++;\n\treturn Cover(doc, len, qr, ext);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemSet",
          "args": [
            "&ext",
            "0",
            "sizeof(CoverExt)"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_docrep",
          "args": [
            "txt",
            "&qr",
            "&doclen"
          ],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "get_docrep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsrank.c",
          "lines": "723-844",
          "snippet": "static DocRepresentation *\nget_docrep(TSVector txt, QueryRepresentation *qr, int *doclen)\n{\n\tQueryItem  *item = GETQUERY(qr->query);\n\tWordEntry  *entry,\n\t\t\t   *firstentry;\n\tWordEntryPos *post;\n\tint32\t\tdimt,\t\t\t/* number of 'post' items */\n\t\t\t\tj,\n\t\t\t\ti,\n\t\t\t\tnitem;\n\tint\t\t\tlen = qr->query->size * 4,\n\t\t\t\tcur = 0;\n\tDocRepresentation *doc;\n\n\tdoc = (DocRepresentation *) palloc(sizeof(DocRepresentation) * len);\n\n\t/*\n\t * Iterate through query to make DocRepresentaion for words and it's\n\t * entries satisfied by query\n\t */\n\tfor (i = 0; i < qr->query->size; i++)\n\t{\n\t\tQueryOperand *curoperand;\n\n\t\tif (item[i].type != QI_VAL)\n\t\t\tcontinue;\n\n\t\tcuroperand = &item[i].qoperand;\n\n\t\tfirstentry = entry = find_wordentry(txt, qr->query, curoperand, &nitem);\n\t\tif (!entry)\n\t\t\tcontinue;\n\n\t\t/* iterations over entries in tsvector */\n\t\twhile (entry - firstentry < nitem)\n\t\t{\n\t\t\tif (entry->haspos)\n\t\t\t{\n\t\t\t\tdimt = POSDATALEN(txt, entry);\n\t\t\t\tpost = POSDATAPTR(txt, entry);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* ignore words without positions */\n\t\t\t\tentry++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\twhile (cur + dimt >= len)\n\t\t\t{\n\t\t\t\tlen *= 2;\n\t\t\t\tdoc = (DocRepresentation *) repalloc(doc, sizeof(DocRepresentation) * len);\n\t\t\t}\n\n\t\t\t/* iterations over entry's positions */\n\t\t\tfor (j = 0; j < dimt; j++)\n\t\t\t{\n\t\t\t\tif (curoperand->weight == 0 ||\n\t\t\t\t\tcuroperand->weight & (1 << WEP_GETWEIGHT(post[j])))\n\t\t\t\t{\n\t\t\t\t\tdoc[cur].pos = post[j];\n\t\t\t\t\tdoc[cur].data.map.entry = entry;\n\t\t\t\t\tdoc[cur].data.map.item = (QueryItem *) curoperand;\n\t\t\t\t\tcur++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tentry++;\n\t\t}\n\t}\n\n\tif (cur > 0)\n\t{\n\t\tDocRepresentation *rptr = doc + 1,\n\t\t\t\t   *wptr = doc,\n\t\t\t\t\tstorage;\n\n\t\t/*\n\t\t * Sort representation in ascending order by pos and entry\n\t\t */\n\t\tqsort((void *) doc, cur, sizeof(DocRepresentation), compareDocR);\n\n\t\t/*\n\t\t * Join QueryItem per WordEntry and it's position\n\t\t */\n\t\tstorage.pos = doc->pos;\n\t\tstorage.data.query.items = palloc(sizeof(QueryItem *) * qr->query->size);\n\t\tstorage.data.query.items[0] = doc->data.map.item;\n\t\tstorage.data.query.nitem = 1;\n\n\t\twhile (rptr - doc < cur)\n\t\t{\n\t\t\tif (rptr->pos == (rptr - 1)->pos &&\n\t\t\t\trptr->data.map.entry == (rptr - 1)->data.map.entry)\n\t\t\t{\n\t\t\t\tstorage.data.query.items[storage.data.query.nitem] = rptr->data.map.item;\n\t\t\t\tstorage.data.query.nitem++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t*wptr = storage;\n\t\t\t\twptr++;\n\t\t\t\tstorage.pos = rptr->pos;\n\t\t\t\tstorage.data.query.items = palloc(sizeof(QueryItem *) * qr->query->size);\n\t\t\t\tstorage.data.query.items[0] = rptr->data.map.item;\n\t\t\t\tstorage.data.query.nitem = 1;\n\t\t\t}\n\n\t\t\trptr++;\n\t\t}\n\n\t\t*wptr = storage;\n\t\twptr++;\n\n\t\t*doclen = wptr - doc;\n\t\treturn doc;\n\t}\n\n\tpfree(doc);\n\treturn NULL;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"tsearch/ts_utils.h\"\n#include <math.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic DocRepresentation *\nget_docrep(TSVector txt, QueryRepresentation *qr, int *doclen)\n{\n\tQueryItem  *item = GETQUERY(qr->query);\n\tWordEntry  *entry,\n\t\t\t   *firstentry;\n\tWordEntryPos *post;\n\tint32\t\tdimt,\t\t\t/* number of 'post' items */\n\t\t\t\tj,\n\t\t\t\ti,\n\t\t\t\tnitem;\n\tint\t\t\tlen = qr->query->size * 4,\n\t\t\t\tcur = 0;\n\tDocRepresentation *doc;\n\n\tdoc = (DocRepresentation *) palloc(sizeof(DocRepresentation) * len);\n\n\t/*\n\t * Iterate through query to make DocRepresentaion for words and it's\n\t * entries satisfied by query\n\t */\n\tfor (i = 0; i < qr->query->size; i++)\n\t{\n\t\tQueryOperand *curoperand;\n\n\t\tif (item[i].type != QI_VAL)\n\t\t\tcontinue;\n\n\t\tcuroperand = &item[i].qoperand;\n\n\t\tfirstentry = entry = find_wordentry(txt, qr->query, curoperand, &nitem);\n\t\tif (!entry)\n\t\t\tcontinue;\n\n\t\t/* iterations over entries in tsvector */\n\t\twhile (entry - firstentry < nitem)\n\t\t{\n\t\t\tif (entry->haspos)\n\t\t\t{\n\t\t\t\tdimt = POSDATALEN(txt, entry);\n\t\t\t\tpost = POSDATAPTR(txt, entry);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* ignore words without positions */\n\t\t\t\tentry++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\twhile (cur + dimt >= len)\n\t\t\t{\n\t\t\t\tlen *= 2;\n\t\t\t\tdoc = (DocRepresentation *) repalloc(doc, sizeof(DocRepresentation) * len);\n\t\t\t}\n\n\t\t\t/* iterations over entry's positions */\n\t\t\tfor (j = 0; j < dimt; j++)\n\t\t\t{\n\t\t\t\tif (curoperand->weight == 0 ||\n\t\t\t\t\tcuroperand->weight & (1 << WEP_GETWEIGHT(post[j])))\n\t\t\t\t{\n\t\t\t\t\tdoc[cur].pos = post[j];\n\t\t\t\t\tdoc[cur].data.map.entry = entry;\n\t\t\t\t\tdoc[cur].data.map.item = (QueryItem *) curoperand;\n\t\t\t\t\tcur++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tentry++;\n\t\t}\n\t}\n\n\tif (cur > 0)\n\t{\n\t\tDocRepresentation *rptr = doc + 1,\n\t\t\t\t   *wptr = doc,\n\t\t\t\t\tstorage;\n\n\t\t/*\n\t\t * Sort representation in ascending order by pos and entry\n\t\t */\n\t\tqsort((void *) doc, cur, sizeof(DocRepresentation), compareDocR);\n\n\t\t/*\n\t\t * Join QueryItem per WordEntry and it's position\n\t\t */\n\t\tstorage.pos = doc->pos;\n\t\tstorage.data.query.items = palloc(sizeof(QueryItem *) * qr->query->size);\n\t\tstorage.data.query.items[0] = doc->data.map.item;\n\t\tstorage.data.query.nitem = 1;\n\n\t\twhile (rptr - doc < cur)\n\t\t{\n\t\t\tif (rptr->pos == (rptr - 1)->pos &&\n\t\t\t\trptr->data.map.entry == (rptr - 1)->data.map.entry)\n\t\t\t{\n\t\t\t\tstorage.data.query.items[storage.data.query.nitem] = rptr->data.map.item;\n\t\t\t\tstorage.data.query.nitem++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t*wptr = storage;\n\t\t\t\twptr++;\n\t\t\t\tstorage.pos = rptr->pos;\n\t\t\t\tstorage.data.query.items = palloc(sizeof(QueryItem *) * qr->query->size);\n\t\t\t\tstorage.data.query.items[0] = rptr->data.map.item;\n\t\t\t\tstorage.data.query.nitem = 1;\n\t\t\t}\n\n\t\t\trptr++;\n\t\t}\n\n\t\t*wptr = storage;\n\t\twptr++;\n\n\t\t*doclen = wptr - doc;\n\t\treturn doc;\n\t}\n\n\tpfree(doc);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "sizeof(QueryRepresentationOperand) * query->size"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"weight out of range\"))"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"weight out of range\""
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "lengthof",
          "args": [
            "weights"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lengthof",
          "args": [
            "weights"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"tsearch/ts_utils.h\"\n#include <math.h>\n#include <limits.h>\n#include \"postgres.h\"\n\n#define RANK_NORM_RDIVRPLUS1\t0x20\n#define RANK_NORM_LOGUNIQ\t\t0x10\n#define RANK_NORM_UNIQ\t\t\t0x08\n#define RANK_NORM_EXTDIST\t\t0x04\n#define RANK_NORM_LENGTH\t\t0x02\n#define RANK_NORM_LOGLENGTH\t\t0x01\n\nstatic const float weights[] = {0.1f, 0.2f, 0.4f, 1.0f};\nstatic float calc_rank_or(const float *w, TSVector t, TSQuery q);\nstatic float calc_rank_and(const float *w, TSVector t, TSQuery q);\n\nstatic float4\ncalc_rank_cd(const float4 *arrdata, TSVector txt, TSQuery query, int method)\n{\n\tDocRepresentation *doc;\n\tint\t\t\tlen,\n\t\t\t\ti,\n\t\t\t\tdoclen = 0;\n\tCoverExt\text;\n\tdouble\t\tWdoc = 0.0;\n\tdouble\t\tinvws[lengthof(weights)];\n\tdouble\t\tSumDist = 0.0,\n\t\t\t\tPrevExtPos = 0.0,\n\t\t\t\tCurExtPos = 0.0;\n\tint\t\t\tNExtent = 0;\n\tQueryRepresentation qr;\n\n\n\tfor (i = 0; i < lengthof(weights); i++)\n\t{\n\t\tinvws[i] = ((double) ((arrdata[i] >= 0) ? arrdata[i] : weights[i]));\n\t\tif (invws[i] > 1.0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"weight out of range\")));\n\t\tinvws[i] = 1.0 / invws[i];\n\t}\n\n\tqr.query = query;\n\tqr.operandData = (QueryRepresentationOperand *)\n\t\tpalloc0(sizeof(QueryRepresentationOperand) * query->size);\n\n\tdoc = get_docrep(txt, &qr, &doclen);\n\tif (!doc)\n\t{\n\t\tpfree(qr.operandData);\n\t\treturn 0.0;\n\t}\n\n\tMemSet(&ext, 0, sizeof(CoverExt));\n\twhile (Cover(doc, doclen, &qr, &ext))\n\t{\n\t\tdouble\t\tCpos = 0.0;\n\t\tdouble\t\tInvSum = 0.0;\n\t\tint\t\t\tnNoise;\n\t\tDocRepresentation *ptr = ext.begin;\n\n\t\twhile (ptr <= ext.end)\n\t\t{\n\t\t\tInvSum += invws[WEP_GETWEIGHT(ptr->pos)];\n\t\t\tptr++;\n\t\t}\n\n\t\tCpos = ((double) (ext.end - ext.begin + 1)) / InvSum;\n\n\t\t/*\n\t\t * if doc are big enough then ext.q may be equal to ext.p due to limit\n\t\t * of positional information. In this case we approximate number of\n\t\t * noise word as half cover's length\n\t\t */\n\t\tnNoise = (ext.q - ext.p) - (ext.end - ext.begin);\n\t\tif (nNoise < 0)\n\t\t\tnNoise = (ext.end - ext.begin) / 2;\n\t\tWdoc += Cpos / ((double) (1 + nNoise));\n\n\t\tCurExtPos = ((double) (ext.q + ext.p)) / 2.0;\n\t\tif (NExtent > 0 && CurExtPos > PrevExtPos\t/* prevent division by\n\t\t\t\t\t\t\t\t\t\t\t\t\t * zero in a case of\n\t\t\t  * multiple lexize */ )\n\t\t\tSumDist += 1.0 / (CurExtPos - PrevExtPos);\n\n\t\tPrevExtPos = CurExtPos;\n\t\tNExtent++;\n\t}\n\n\tif ((method & RANK_NORM_LOGLENGTH) && txt->size > 0)\n\t\tWdoc /= log((double) (cnt_length(txt) + 1));\n\n\tif (method & RANK_NORM_LENGTH)\n\t{\n\t\tlen = cnt_length(txt);\n\t\tif (len > 0)\n\t\t\tWdoc /= (double) len;\n\t}\n\n\tif ((method & RANK_NORM_EXTDIST) && NExtent > 0 && SumDist > 0)\n\t\tWdoc /= ((double) NExtent) / SumDist;\n\n\tif ((method & RANK_NORM_UNIQ) && txt->size > 0)\n\t\tWdoc /= (double) (txt->size);\n\n\tif ((method & RANK_NORM_LOGUNIQ) && txt->size > 0)\n\t\tWdoc /= log((double) (txt->size + 1)) / log(2.0);\n\n\tif (method & RANK_NORM_RDIVRPLUS1)\n\t\tWdoc /= (Wdoc + 1);\n\n\tpfree(doc);\n\n\tpfree(qr.operandData);\n\n\treturn (float4) Wdoc;\n}"
  },
  {
    "function_name": "get_docrep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsrank.c",
    "lines": "723-844",
    "snippet": "static DocRepresentation *\nget_docrep(TSVector txt, QueryRepresentation *qr, int *doclen)\n{\n\tQueryItem  *item = GETQUERY(qr->query);\n\tWordEntry  *entry,\n\t\t\t   *firstentry;\n\tWordEntryPos *post;\n\tint32\t\tdimt,\t\t\t/* number of 'post' items */\n\t\t\t\tj,\n\t\t\t\ti,\n\t\t\t\tnitem;\n\tint\t\t\tlen = qr->query->size * 4,\n\t\t\t\tcur = 0;\n\tDocRepresentation *doc;\n\n\tdoc = (DocRepresentation *) palloc(sizeof(DocRepresentation) * len);\n\n\t/*\n\t * Iterate through query to make DocRepresentaion for words and it's\n\t * entries satisfied by query\n\t */\n\tfor (i = 0; i < qr->query->size; i++)\n\t{\n\t\tQueryOperand *curoperand;\n\n\t\tif (item[i].type != QI_VAL)\n\t\t\tcontinue;\n\n\t\tcuroperand = &item[i].qoperand;\n\n\t\tfirstentry = entry = find_wordentry(txt, qr->query, curoperand, &nitem);\n\t\tif (!entry)\n\t\t\tcontinue;\n\n\t\t/* iterations over entries in tsvector */\n\t\twhile (entry - firstentry < nitem)\n\t\t{\n\t\t\tif (entry->haspos)\n\t\t\t{\n\t\t\t\tdimt = POSDATALEN(txt, entry);\n\t\t\t\tpost = POSDATAPTR(txt, entry);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* ignore words without positions */\n\t\t\t\tentry++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\twhile (cur + dimt >= len)\n\t\t\t{\n\t\t\t\tlen *= 2;\n\t\t\t\tdoc = (DocRepresentation *) repalloc(doc, sizeof(DocRepresentation) * len);\n\t\t\t}\n\n\t\t\t/* iterations over entry's positions */\n\t\t\tfor (j = 0; j < dimt; j++)\n\t\t\t{\n\t\t\t\tif (curoperand->weight == 0 ||\n\t\t\t\t\tcuroperand->weight & (1 << WEP_GETWEIGHT(post[j])))\n\t\t\t\t{\n\t\t\t\t\tdoc[cur].pos = post[j];\n\t\t\t\t\tdoc[cur].data.map.entry = entry;\n\t\t\t\t\tdoc[cur].data.map.item = (QueryItem *) curoperand;\n\t\t\t\t\tcur++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tentry++;\n\t\t}\n\t}\n\n\tif (cur > 0)\n\t{\n\t\tDocRepresentation *rptr = doc + 1,\n\t\t\t\t   *wptr = doc,\n\t\t\t\t\tstorage;\n\n\t\t/*\n\t\t * Sort representation in ascending order by pos and entry\n\t\t */\n\t\tqsort((void *) doc, cur, sizeof(DocRepresentation), compareDocR);\n\n\t\t/*\n\t\t * Join QueryItem per WordEntry and it's position\n\t\t */\n\t\tstorage.pos = doc->pos;\n\t\tstorage.data.query.items = palloc(sizeof(QueryItem *) * qr->query->size);\n\t\tstorage.data.query.items[0] = doc->data.map.item;\n\t\tstorage.data.query.nitem = 1;\n\n\t\twhile (rptr - doc < cur)\n\t\t{\n\t\t\tif (rptr->pos == (rptr - 1)->pos &&\n\t\t\t\trptr->data.map.entry == (rptr - 1)->data.map.entry)\n\t\t\t{\n\t\t\t\tstorage.data.query.items[storage.data.query.nitem] = rptr->data.map.item;\n\t\t\t\tstorage.data.query.nitem++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t*wptr = storage;\n\t\t\t\twptr++;\n\t\t\t\tstorage.pos = rptr->pos;\n\t\t\t\tstorage.data.query.items = palloc(sizeof(QueryItem *) * qr->query->size);\n\t\t\t\tstorage.data.query.items[0] = rptr->data.map.item;\n\t\t\t\tstorage.data.query.nitem = 1;\n\t\t\t}\n\n\t\t\trptr++;\n\t\t}\n\n\t\t*wptr = storage;\n\t\twptr++;\n\n\t\t*doclen = wptr - doc;\n\t\treturn doc;\n\t}\n\n\tpfree(doc);\n\treturn NULL;\n}",
    "includes": [
      "#include \"miscadmin.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "doc"
          ],
          "line": 842
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(QueryItem *) * qr->query->size"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qsort",
          "args": [
            "(void *) doc",
            "cur",
            "sizeof(DocRepresentation)",
            "compareDocR"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEP_GETWEIGHT",
          "args": [
            "post[j]"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "repalloc",
          "args": [
            "doc",
            "sizeof(DocRepresentation) * len"
          ],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "xml_repalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1642-1646",
          "snippet": "static void *\nxml_repalloc(void *ptr, size_t size)\n{\n\treturn repalloc(ptr, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_repalloc(void *ptr, size_t size)\n{\n\treturn repalloc(ptr, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "POSDATAPTR",
          "args": [
            "txt",
            "entry"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "POSDATALEN",
          "args": [
            "txt",
            "entry"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_wordentry",
          "args": [
            "txt",
            "qr->query",
            "curoperand",
            "&nitem"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "find_wordentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsrank.c",
          "lines": "86-129",
          "snippet": "static WordEntry *\nfind_wordentry(TSVector t, TSQuery q, QueryOperand *item, int32 *nitem)\n{\n\tWordEntry  *StopLow = ARRPTR(t);\n\tWordEntry  *StopHigh = (WordEntry *) STRPTR(t);\n\tWordEntry  *StopMiddle = StopHigh;\n\tint\t\t\tdifference;\n\n\t*nitem = 0;\n\n\t/* Loop invariant: StopLow <= item < StopHigh */\n\twhile (StopLow < StopHigh)\n\t{\n\t\tStopMiddle = StopLow + (StopHigh - StopLow) / 2;\n\t\tdifference = WordECompareQueryItem(STRPTR(t), GETOPERAND(q), StopMiddle, item, false);\n\t\tif (difference == 0)\n\t\t{\n\t\t\tStopHigh = StopMiddle;\n\t\t\t*nitem = 1;\n\t\t\tbreak;\n\t\t}\n\t\telse if (difference > 0)\n\t\t\tStopLow = StopMiddle + 1;\n\t\telse\n\t\t\tStopHigh = StopMiddle;\n\t}\n\n\tif (item->prefix)\n\t{\n\t\tif (StopLow >= StopHigh)\n\t\t\tStopMiddle = StopHigh;\n\n\t\t*nitem = 0;\n\n\t\twhile (StopMiddle < (WordEntry *) STRPTR(t) &&\n\t\t\t   WordECompareQueryItem(STRPTR(t), GETOPERAND(q), StopMiddle, item, true) == 0)\n\t\t{\n\t\t\t(*nitem)++;\n\t\t\tStopMiddle++;\n\t\t}\n\t}\n\n\treturn (*nitem > 0) ? StopHigh : NULL;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static float calc_rank_or(const float *w, TSVector t, TSQuery q);",
            "static float calc_rank_and(const float *w, TSVector t, TSQuery q);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"tsearch/ts_utils.h\"\n#include <math.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic float calc_rank_or(const float *w, TSVector t, TSQuery q);\nstatic float calc_rank_and(const float *w, TSVector t, TSQuery q);\n\nstatic WordEntry *\nfind_wordentry(TSVector t, TSQuery q, QueryOperand *item, int32 *nitem)\n{\n\tWordEntry  *StopLow = ARRPTR(t);\n\tWordEntry  *StopHigh = (WordEntry *) STRPTR(t);\n\tWordEntry  *StopMiddle = StopHigh;\n\tint\t\t\tdifference;\n\n\t*nitem = 0;\n\n\t/* Loop invariant: StopLow <= item < StopHigh */\n\twhile (StopLow < StopHigh)\n\t{\n\t\tStopMiddle = StopLow + (StopHigh - StopLow) / 2;\n\t\tdifference = WordECompareQueryItem(STRPTR(t), GETOPERAND(q), StopMiddle, item, false);\n\t\tif (difference == 0)\n\t\t{\n\t\t\tStopHigh = StopMiddle;\n\t\t\t*nitem = 1;\n\t\t\tbreak;\n\t\t}\n\t\telse if (difference > 0)\n\t\t\tStopLow = StopMiddle + 1;\n\t\telse\n\t\t\tStopHigh = StopMiddle;\n\t}\n\n\tif (item->prefix)\n\t{\n\t\tif (StopLow >= StopHigh)\n\t\t\tStopMiddle = StopHigh;\n\n\t\t*nitem = 0;\n\n\t\twhile (StopMiddle < (WordEntry *) STRPTR(t) &&\n\t\t\t   WordECompareQueryItem(STRPTR(t), GETOPERAND(q), StopMiddle, item, true) == 0)\n\t\t{\n\t\t\t(*nitem)++;\n\t\t\tStopMiddle++;\n\t\t}\n\t}\n\n\treturn (*nitem > 0) ? StopHigh : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GETQUERY",
          "args": [
            "qr->query"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"tsearch/ts_utils.h\"\n#include <math.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic DocRepresentation *\nget_docrep(TSVector txt, QueryRepresentation *qr, int *doclen)\n{\n\tQueryItem  *item = GETQUERY(qr->query);\n\tWordEntry  *entry,\n\t\t\t   *firstentry;\n\tWordEntryPos *post;\n\tint32\t\tdimt,\t\t\t/* number of 'post' items */\n\t\t\t\tj,\n\t\t\t\ti,\n\t\t\t\tnitem;\n\tint\t\t\tlen = qr->query->size * 4,\n\t\t\t\tcur = 0;\n\tDocRepresentation *doc;\n\n\tdoc = (DocRepresentation *) palloc(sizeof(DocRepresentation) * len);\n\n\t/*\n\t * Iterate through query to make DocRepresentaion for words and it's\n\t * entries satisfied by query\n\t */\n\tfor (i = 0; i < qr->query->size; i++)\n\t{\n\t\tQueryOperand *curoperand;\n\n\t\tif (item[i].type != QI_VAL)\n\t\t\tcontinue;\n\n\t\tcuroperand = &item[i].qoperand;\n\n\t\tfirstentry = entry = find_wordentry(txt, qr->query, curoperand, &nitem);\n\t\tif (!entry)\n\t\t\tcontinue;\n\n\t\t/* iterations over entries in tsvector */\n\t\twhile (entry - firstentry < nitem)\n\t\t{\n\t\t\tif (entry->haspos)\n\t\t\t{\n\t\t\t\tdimt = POSDATALEN(txt, entry);\n\t\t\t\tpost = POSDATAPTR(txt, entry);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* ignore words without positions */\n\t\t\t\tentry++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\twhile (cur + dimt >= len)\n\t\t\t{\n\t\t\t\tlen *= 2;\n\t\t\t\tdoc = (DocRepresentation *) repalloc(doc, sizeof(DocRepresentation) * len);\n\t\t\t}\n\n\t\t\t/* iterations over entry's positions */\n\t\t\tfor (j = 0; j < dimt; j++)\n\t\t\t{\n\t\t\t\tif (curoperand->weight == 0 ||\n\t\t\t\t\tcuroperand->weight & (1 << WEP_GETWEIGHT(post[j])))\n\t\t\t\t{\n\t\t\t\t\tdoc[cur].pos = post[j];\n\t\t\t\t\tdoc[cur].data.map.entry = entry;\n\t\t\t\t\tdoc[cur].data.map.item = (QueryItem *) curoperand;\n\t\t\t\t\tcur++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tentry++;\n\t\t}\n\t}\n\n\tif (cur > 0)\n\t{\n\t\tDocRepresentation *rptr = doc + 1,\n\t\t\t\t   *wptr = doc,\n\t\t\t\t\tstorage;\n\n\t\t/*\n\t\t * Sort representation in ascending order by pos and entry\n\t\t */\n\t\tqsort((void *) doc, cur, sizeof(DocRepresentation), compareDocR);\n\n\t\t/*\n\t\t * Join QueryItem per WordEntry and it's position\n\t\t */\n\t\tstorage.pos = doc->pos;\n\t\tstorage.data.query.items = palloc(sizeof(QueryItem *) * qr->query->size);\n\t\tstorage.data.query.items[0] = doc->data.map.item;\n\t\tstorage.data.query.nitem = 1;\n\n\t\twhile (rptr - doc < cur)\n\t\t{\n\t\t\tif (rptr->pos == (rptr - 1)->pos &&\n\t\t\t\trptr->data.map.entry == (rptr - 1)->data.map.entry)\n\t\t\t{\n\t\t\t\tstorage.data.query.items[storage.data.query.nitem] = rptr->data.map.item;\n\t\t\t\tstorage.data.query.nitem++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t*wptr = storage;\n\t\t\t\twptr++;\n\t\t\t\tstorage.pos = rptr->pos;\n\t\t\t\tstorage.data.query.items = palloc(sizeof(QueryItem *) * qr->query->size);\n\t\t\t\tstorage.data.query.items[0] = rptr->data.map.item;\n\t\t\t\tstorage.data.query.nitem = 1;\n\t\t\t}\n\n\t\t\trptr++;\n\t\t}\n\n\t\t*wptr = storage;\n\t\twptr++;\n\n\t\t*doclen = wptr - doc;\n\t\treturn doc;\n\t}\n\n\tpfree(doc);\n\treturn NULL;\n}"
  },
  {
    "function_name": "Cover",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsrank.c",
    "lines": "642-721",
    "snippet": "static bool\nCover(DocRepresentation *doc, int len, QueryRepresentation *qr, CoverExt *ext)\n{\n\tDocRepresentation *ptr;\n\tint\t\t\tlastpos = ext->pos;\n\tbool\t\tfound = false;\n\n\t/*\n\t * since this function recurses, it could be driven to stack overflow.\n\t * (though any decent compiler will optimize away the tail-recursion.\n\t */\n\tcheck_stack_depth();\n\n\tresetQueryRepresentation(qr, false);\n\n\text->p = INT_MAX;\n\text->q = 0;\n\tptr = doc + ext->pos;\n\n\t/* find upper bound of cover from current position, move up */\n\twhile (ptr - doc < len)\n\t{\n\t\tfillQueryRepresentationData(qr, ptr);\n\n\t\tif (TS_execute(GETQUERY(qr->query), (void *) qr,\n\t\t\t\t\t   TS_EXEC_EMPTY, checkcondition_QueryOperand))\n\t\t{\n\t\t\tif (WEP_GETPOS(ptr->pos) > ext->q)\n\t\t\t{\n\t\t\t\text->q = WEP_GETPOS(ptr->pos);\n\t\t\t\text->end = ptr;\n\t\t\t\tlastpos = ptr - doc;\n\t\t\t\tfound = true;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tptr++;\n\t}\n\n\tif (!found)\n\t\treturn false;\n\n\tresetQueryRepresentation(qr, true);\n\n\tptr = doc + lastpos;\n\n\t/* find lower bound of cover from found upper bound, move down */\n\twhile (ptr >= doc + ext->pos)\n\t{\n\t\t/*\n\t\t * we scan doc from right to left, so pos info in reverse order!\n\t\t */\n\t\tfillQueryRepresentationData(qr, ptr);\n\n\t\tif (TS_execute(GETQUERY(qr->query), (void *) qr,\n\t\t\t\t\t   TS_EXEC_CALC_NOT, checkcondition_QueryOperand))\n\t\t{\n\t\t\tif (WEP_GETPOS(ptr->pos) < ext->p)\n\t\t\t{\n\t\t\t\text->begin = ptr;\n\t\t\t\text->p = WEP_GETPOS(ptr->pos);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tptr--;\n\t}\n\n\tif (ext->p <= ext->q)\n\t{\n\t\t/*\n\t\t * set position for next try to next lexeme after beginning of found\n\t\t * cover\n\t\t */\n\t\text->pos = (ptr - doc) + 1;\n\t\treturn true;\n\t}\n\n\text->pos++;\n\treturn Cover(doc, len, qr, ext);\n}",
    "includes": [
      "#include \"miscadmin.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static float calc_rank_or(const float *w, TSVector t, TSQuery q);",
      "static float calc_rank_and(const float *w, TSVector t, TSQuery q);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Cover",
          "args": [
            "doc",
            "len",
            "qr",
            "ext"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "Cover",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsrank.c",
          "lines": "642-721",
          "snippet": "static bool\nCover(DocRepresentation *doc, int len, QueryRepresentation *qr, CoverExt *ext)\n{\n\tDocRepresentation *ptr;\n\tint\t\t\tlastpos = ext->pos;\n\tbool\t\tfound = false;\n\n\t/*\n\t * since this function recurses, it could be driven to stack overflow.\n\t * (though any decent compiler will optimize away the tail-recursion.\n\t */\n\tcheck_stack_depth();\n\n\tresetQueryRepresentation(qr, false);\n\n\text->p = INT_MAX;\n\text->q = 0;\n\tptr = doc + ext->pos;\n\n\t/* find upper bound of cover from current position, move up */\n\twhile (ptr - doc < len)\n\t{\n\t\tfillQueryRepresentationData(qr, ptr);\n\n\t\tif (TS_execute(GETQUERY(qr->query), (void *) qr,\n\t\t\t\t\t   TS_EXEC_EMPTY, checkcondition_QueryOperand))\n\t\t{\n\t\t\tif (WEP_GETPOS(ptr->pos) > ext->q)\n\t\t\t{\n\t\t\t\text->q = WEP_GETPOS(ptr->pos);\n\t\t\t\text->end = ptr;\n\t\t\t\tlastpos = ptr - doc;\n\t\t\t\tfound = true;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tptr++;\n\t}\n\n\tif (!found)\n\t\treturn false;\n\n\tresetQueryRepresentation(qr, true);\n\n\tptr = doc + lastpos;\n\n\t/* find lower bound of cover from found upper bound, move down */\n\twhile (ptr >= doc + ext->pos)\n\t{\n\t\t/*\n\t\t * we scan doc from right to left, so pos info in reverse order!\n\t\t */\n\t\tfillQueryRepresentationData(qr, ptr);\n\n\t\tif (TS_execute(GETQUERY(qr->query), (void *) qr,\n\t\t\t\t\t   TS_EXEC_CALC_NOT, checkcondition_QueryOperand))\n\t\t{\n\t\t\tif (WEP_GETPOS(ptr->pos) < ext->p)\n\t\t\t{\n\t\t\t\text->begin = ptr;\n\t\t\t\text->p = WEP_GETPOS(ptr->pos);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tptr--;\n\t}\n\n\tif (ext->p <= ext->q)\n\t{\n\t\t/*\n\t\t * set position for next try to next lexeme after beginning of found\n\t\t * cover\n\t\t */\n\t\text->pos = (ptr - doc) + 1;\n\t\treturn true;\n\t}\n\n\text->pos++;\n\treturn Cover(doc, len, qr, ext);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "WEP_GETPOS",
          "args": [
            "ptr->pos"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEP_GETPOS",
          "args": [
            "ptr->pos"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TS_execute",
          "args": [
            "GETQUERY(qr->query)",
            "(void *) qr",
            "TS_EXEC_CALC_NOT",
            "checkcondition_QueryOperand"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "TS_execute",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
          "lines": "1814-1854",
          "snippet": "bool\nTS_execute(QueryItem *curitem, void *arg, uint32 flags,\n\t\t   TSExecuteCallback chkcond)\n{\n\t/* since this function recurses, it could be driven to stack overflow */\n\tcheck_stack_depth();\n\n\tif (curitem->type == QI_VAL)\n\t\treturn chkcond(arg, (QueryOperand *) curitem,\n\t\t\t\t\t   NULL /* we don't need position info */ );\n\n\tswitch (curitem->qoperator.oper)\n\t{\n\t\tcase OP_NOT:\n\t\t\tif (flags & TS_EXEC_CALC_NOT)\n\t\t\t\treturn !TS_execute(curitem + 1, arg, flags, chkcond);\n\t\t\telse\n\t\t\t\treturn true;\n\n\t\tcase OP_AND:\n\t\t\tif (TS_execute(curitem + curitem->qoperator.left, arg, flags, chkcond))\n\t\t\t\treturn TS_execute(curitem + 1, arg, flags, chkcond);\n\t\t\telse\n\t\t\t\treturn false;\n\n\t\tcase OP_OR:\n\t\t\tif (TS_execute(curitem + curitem->qoperator.left, arg, flags, chkcond))\n\t\t\t\treturn true;\n\t\t\telse\n\t\t\t\treturn TS_execute(curitem + 1, arg, flags, chkcond);\n\n\t\tcase OP_PHRASE:\n\t\t\treturn TS_phrase_execute(curitem, arg, flags, chkcond, NULL);\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized operator: %d\", curitem->qoperator.oper);\n\t}\n\n\t/* not reachable, but keep compiler quiet */\n\treturn false;\n}",
          "includes": [
            "#include \"utils/rel.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nbool\nTS_execute(QueryItem *curitem, void *arg, uint32 flags,\n\t\t   TSExecuteCallback chkcond)\n{\n\t/* since this function recurses, it could be driven to stack overflow */\n\tcheck_stack_depth();\n\n\tif (curitem->type == QI_VAL)\n\t\treturn chkcond(arg, (QueryOperand *) curitem,\n\t\t\t\t\t   NULL /* we don't need position info */ );\n\n\tswitch (curitem->qoperator.oper)\n\t{\n\t\tcase OP_NOT:\n\t\t\tif (flags & TS_EXEC_CALC_NOT)\n\t\t\t\treturn !TS_execute(curitem + 1, arg, flags, chkcond);\n\t\t\telse\n\t\t\t\treturn true;\n\n\t\tcase OP_AND:\n\t\t\tif (TS_execute(curitem + curitem->qoperator.left, arg, flags, chkcond))\n\t\t\t\treturn TS_execute(curitem + 1, arg, flags, chkcond);\n\t\t\telse\n\t\t\t\treturn false;\n\n\t\tcase OP_OR:\n\t\t\tif (TS_execute(curitem + curitem->qoperator.left, arg, flags, chkcond))\n\t\t\t\treturn true;\n\t\t\telse\n\t\t\t\treturn TS_execute(curitem + 1, arg, flags, chkcond);\n\n\t\tcase OP_PHRASE:\n\t\t\treturn TS_phrase_execute(curitem, arg, flags, chkcond, NULL);\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized operator: %d\", curitem->qoperator.oper);\n\t}\n\n\t/* not reachable, but keep compiler quiet */\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GETQUERY",
          "args": [
            "qr->query"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fillQueryRepresentationData",
          "args": [
            "qr",
            "ptr"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "fillQueryRepresentationData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsrank.c",
          "lines": "602-640",
          "snippet": "static void\nfillQueryRepresentationData(QueryRepresentation *qr, DocRepresentation *entry)\n{\n\tint\t\t\ti;\n\tint\t\t\tlastPos;\n\tQueryRepresentationOperand *opData;\n\n\tfor (i = 0; i < entry->data.query.nitem; i++)\n\t{\n\t\tif (entry->data.query.items[i]->type != QI_VAL)\n\t\t\tcontinue;\n\n\t\topData = QR_GET_OPERAND_DATA(qr, entry->data.query.items[i]);\n\n\t\topData->operandexists = true;\n\n\t\tif (opData->npos == 0)\n\t\t{\n\t\t\tlastPos = (opData->reverseinsert) ? (MAXQROPOS - 1) : 0;\n\t\t\topData->pos[lastPos] = entry->pos;\n\t\t\topData->npos++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlastPos = opData->reverseinsert ?\n\t\t\t(MAXQROPOS - opData->npos) :\n\t\t\t(opData->npos - 1);\n\n\t\tif (WEP_GETPOS(opData->pos[lastPos]) != WEP_GETPOS(entry->pos))\n\t\t{\n\t\t\tlastPos = opData->reverseinsert ?\n\t\t\t\t(MAXQROPOS - 1 - opData->npos) :\n\t\t\t\t(opData->npos);\n\n\t\t\topData->pos[lastPos] = entry->pos;\n\t\t\topData->npos++;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MAXQROPOS\tMAXENTRYPOS"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"tsearch/ts_utils.h\"\n#include <math.h>\n#include <limits.h>\n#include \"postgres.h\"\n\n#define MAXQROPOS\tMAXENTRYPOS\n\nstatic void\nfillQueryRepresentationData(QueryRepresentation *qr, DocRepresentation *entry)\n{\n\tint\t\t\ti;\n\tint\t\t\tlastPos;\n\tQueryRepresentationOperand *opData;\n\n\tfor (i = 0; i < entry->data.query.nitem; i++)\n\t{\n\t\tif (entry->data.query.items[i]->type != QI_VAL)\n\t\t\tcontinue;\n\n\t\topData = QR_GET_OPERAND_DATA(qr, entry->data.query.items[i]);\n\n\t\topData->operandexists = true;\n\n\t\tif (opData->npos == 0)\n\t\t{\n\t\t\tlastPos = (opData->reverseinsert) ? (MAXQROPOS - 1) : 0;\n\t\t\topData->pos[lastPos] = entry->pos;\n\t\t\topData->npos++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlastPos = opData->reverseinsert ?\n\t\t\t(MAXQROPOS - opData->npos) :\n\t\t\t(opData->npos - 1);\n\n\t\tif (WEP_GETPOS(opData->pos[lastPos]) != WEP_GETPOS(entry->pos))\n\t\t{\n\t\t\tlastPos = opData->reverseinsert ?\n\t\t\t\t(MAXQROPOS - 1 - opData->npos) :\n\t\t\t\t(opData->npos);\n\n\t\t\topData->pos[lastPos] = entry->pos;\n\t\t\topData->npos++;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "resetQueryRepresentation",
          "args": [
            "qr",
            "true"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "resetQueryRepresentation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsrank.c",
          "lines": "589-600",
          "snippet": "static void\nresetQueryRepresentation(QueryRepresentation *qr, bool reverseinsert)\n{\n\tint\t\t\ti;\n\n\tfor (i = 0; i < qr->query->size; i++)\n\t{\n\t\tqr->operandData[i].operandexists = false;\n\t\tqr->operandData[i].reverseinsert = reverseinsert;\n\t\tqr->operandData[i].npos = 0;\n\t}\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"tsearch/ts_utils.h\"\n#include <math.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void\nresetQueryRepresentation(QueryRepresentation *qr, bool reverseinsert)\n{\n\tint\t\t\ti;\n\n\tfor (i = 0; i < qr->query->size; i++)\n\t{\n\t\tqr->operandData[i].operandexists = false;\n\t\tqr->operandData[i].reverseinsert = reverseinsert;\n\t\tqr->operandData[i].npos = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WEP_GETPOS",
          "args": [
            "ptr->pos"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEP_GETPOS",
          "args": [
            "ptr->pos"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETQUERY",
          "args": [
            "qr->query"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_stack_depth",
          "args": [],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"tsearch/ts_utils.h\"\n#include <math.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic float calc_rank_or(const float *w, TSVector t, TSQuery q);\nstatic float calc_rank_and(const float *w, TSVector t, TSQuery q);\n\nstatic bool\nCover(DocRepresentation *doc, int len, QueryRepresentation *qr, CoverExt *ext)\n{\n\tDocRepresentation *ptr;\n\tint\t\t\tlastpos = ext->pos;\n\tbool\t\tfound = false;\n\n\t/*\n\t * since this function recurses, it could be driven to stack overflow.\n\t * (though any decent compiler will optimize away the tail-recursion.\n\t */\n\tcheck_stack_depth();\n\n\tresetQueryRepresentation(qr, false);\n\n\text->p = INT_MAX;\n\text->q = 0;\n\tptr = doc + ext->pos;\n\n\t/* find upper bound of cover from current position, move up */\n\twhile (ptr - doc < len)\n\t{\n\t\tfillQueryRepresentationData(qr, ptr);\n\n\t\tif (TS_execute(GETQUERY(qr->query), (void *) qr,\n\t\t\t\t\t   TS_EXEC_EMPTY, checkcondition_QueryOperand))\n\t\t{\n\t\t\tif (WEP_GETPOS(ptr->pos) > ext->q)\n\t\t\t{\n\t\t\t\text->q = WEP_GETPOS(ptr->pos);\n\t\t\t\text->end = ptr;\n\t\t\t\tlastpos = ptr - doc;\n\t\t\t\tfound = true;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tptr++;\n\t}\n\n\tif (!found)\n\t\treturn false;\n\n\tresetQueryRepresentation(qr, true);\n\n\tptr = doc + lastpos;\n\n\t/* find lower bound of cover from found upper bound, move down */\n\twhile (ptr >= doc + ext->pos)\n\t{\n\t\t/*\n\t\t * we scan doc from right to left, so pos info in reverse order!\n\t\t */\n\t\tfillQueryRepresentationData(qr, ptr);\n\n\t\tif (TS_execute(GETQUERY(qr->query), (void *) qr,\n\t\t\t\t\t   TS_EXEC_CALC_NOT, checkcondition_QueryOperand))\n\t\t{\n\t\t\tif (WEP_GETPOS(ptr->pos) < ext->p)\n\t\t\t{\n\t\t\t\text->begin = ptr;\n\t\t\t\text->p = WEP_GETPOS(ptr->pos);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tptr--;\n\t}\n\n\tif (ext->p <= ext->q)\n\t{\n\t\t/*\n\t\t * set position for next try to next lexeme after beginning of found\n\t\t * cover\n\t\t */\n\t\text->pos = (ptr - doc) + 1;\n\t\treturn true;\n\t}\n\n\text->pos++;\n\treturn Cover(doc, len, qr, ext);\n}"
  },
  {
    "function_name": "fillQueryRepresentationData",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsrank.c",
    "lines": "602-640",
    "snippet": "static void\nfillQueryRepresentationData(QueryRepresentation *qr, DocRepresentation *entry)\n{\n\tint\t\t\ti;\n\tint\t\t\tlastPos;\n\tQueryRepresentationOperand *opData;\n\n\tfor (i = 0; i < entry->data.query.nitem; i++)\n\t{\n\t\tif (entry->data.query.items[i]->type != QI_VAL)\n\t\t\tcontinue;\n\n\t\topData = QR_GET_OPERAND_DATA(qr, entry->data.query.items[i]);\n\n\t\topData->operandexists = true;\n\n\t\tif (opData->npos == 0)\n\t\t{\n\t\t\tlastPos = (opData->reverseinsert) ? (MAXQROPOS - 1) : 0;\n\t\t\topData->pos[lastPos] = entry->pos;\n\t\t\topData->npos++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlastPos = opData->reverseinsert ?\n\t\t\t(MAXQROPOS - opData->npos) :\n\t\t\t(opData->npos - 1);\n\n\t\tif (WEP_GETPOS(opData->pos[lastPos]) != WEP_GETPOS(entry->pos))\n\t\t{\n\t\t\tlastPos = opData->reverseinsert ?\n\t\t\t\t(MAXQROPOS - 1 - opData->npos) :\n\t\t\t\t(opData->npos);\n\n\t\t\topData->pos[lastPos] = entry->pos;\n\t\t\topData->npos++;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"miscadmin.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define MAXQROPOS\tMAXENTRYPOS"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WEP_GETPOS",
          "args": [
            "entry->pos"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEP_GETPOS",
          "args": [
            "opData->pos[lastPos]"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QR_GET_OPERAND_DATA",
          "args": [
            "qr",
            "entry->data.query.items[i]"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"tsearch/ts_utils.h\"\n#include <math.h>\n#include <limits.h>\n#include \"postgres.h\"\n\n#define MAXQROPOS\tMAXENTRYPOS\n\nstatic void\nfillQueryRepresentationData(QueryRepresentation *qr, DocRepresentation *entry)\n{\n\tint\t\t\ti;\n\tint\t\t\tlastPos;\n\tQueryRepresentationOperand *opData;\n\n\tfor (i = 0; i < entry->data.query.nitem; i++)\n\t{\n\t\tif (entry->data.query.items[i]->type != QI_VAL)\n\t\t\tcontinue;\n\n\t\topData = QR_GET_OPERAND_DATA(qr, entry->data.query.items[i]);\n\n\t\topData->operandexists = true;\n\n\t\tif (opData->npos == 0)\n\t\t{\n\t\t\tlastPos = (opData->reverseinsert) ? (MAXQROPOS - 1) : 0;\n\t\t\topData->pos[lastPos] = entry->pos;\n\t\t\topData->npos++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlastPos = opData->reverseinsert ?\n\t\t\t(MAXQROPOS - opData->npos) :\n\t\t\t(opData->npos - 1);\n\n\t\tif (WEP_GETPOS(opData->pos[lastPos]) != WEP_GETPOS(entry->pos))\n\t\t{\n\t\t\tlastPos = opData->reverseinsert ?\n\t\t\t\t(MAXQROPOS - 1 - opData->npos) :\n\t\t\t\t(opData->npos);\n\n\t\t\topData->pos[lastPos] = entry->pos;\n\t\t\topData->npos++;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "resetQueryRepresentation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsrank.c",
    "lines": "589-600",
    "snippet": "static void\nresetQueryRepresentation(QueryRepresentation *qr, bool reverseinsert)\n{\n\tint\t\t\ti;\n\n\tfor (i = 0; i < qr->query->size; i++)\n\t{\n\t\tqr->operandData[i].operandexists = false;\n\t\tqr->operandData[i].reverseinsert = reverseinsert;\n\t\tqr->operandData[i].npos = 0;\n\t}\n}",
    "includes": [
      "#include \"miscadmin.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"tsearch/ts_utils.h\"\n#include <math.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void\nresetQueryRepresentation(QueryRepresentation *qr, bool reverseinsert)\n{\n\tint\t\t\ti;\n\n\tfor (i = 0; i < qr->query->size; i++)\n\t{\n\t\tqr->operandData[i].operandexists = false;\n\t\tqr->operandData[i].reverseinsert = reverseinsert;\n\t\tqr->operandData[i].npos = 0;\n\t}\n}"
  },
  {
    "function_name": "checkcondition_QueryOperand",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsrank.c",
    "lines": "560-578",
    "snippet": "static bool\ncheckcondition_QueryOperand(void *checkval, QueryOperand *val, ExecPhraseData *data)\n{\n\tQueryRepresentation *qr = (QueryRepresentation *) checkval;\n\tQueryRepresentationOperand *opData = QR_GET_OPERAND_DATA(qr, val);\n\n\tif (!opData->operandexists)\n\t\treturn false;\n\n\tif (data)\n\t{\n\t\tdata->npos = opData->npos;\n\t\tdata->pos = opData->pos;\n\t\tif (opData->reverseinsert)\n\t\t\tdata->pos += MAXQROPOS - opData->npos;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include \"miscadmin.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define MAXQROPOS\tMAXENTRYPOS"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "QR_GET_OPERAND_DATA",
          "args": [
            "qr",
            "val"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"tsearch/ts_utils.h\"\n#include <math.h>\n#include <limits.h>\n#include \"postgres.h\"\n\n#define MAXQROPOS\tMAXENTRYPOS\n\nstatic bool\ncheckcondition_QueryOperand(void *checkval, QueryOperand *val, ExecPhraseData *data)\n{\n\tQueryRepresentation *qr = (QueryRepresentation *) checkval;\n\tQueryRepresentationOperand *opData = QR_GET_OPERAND_DATA(qr, val);\n\n\tif (!opData->operandexists)\n\t\treturn false;\n\n\tif (data)\n\t{\n\t\tdata->npos = opData->npos;\n\t\tdata->pos = opData->pos;\n\t\tif (opData->reverseinsert)\n\t\t\tdata->pos += MAXQROPOS - opData->npos;\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "compareDocR",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsrank.c",
    "lines": "519-539",
    "snippet": "static int\ncompareDocR(const void *va, const void *vb)\n{\n\tconst DocRepresentation *a = (const DocRepresentation *) va;\n\tconst DocRepresentation *b = (const DocRepresentation *) vb;\n\n\tif (WEP_GETPOS(a->pos) == WEP_GETPOS(b->pos))\n\t{\n\t\tif (WEP_GETWEIGHT(a->pos) == WEP_GETWEIGHT(b->pos))\n\t\t{\n\t\t\tif (a->data.map.entry == b->data.map.entry)\n\t\t\t\treturn 0;\n\n\t\t\treturn (a->data.map.entry > b->data.map.entry) ? 1 : -1;\n\t\t}\n\n\t\treturn (WEP_GETWEIGHT(a->pos) > WEP_GETWEIGHT(b->pos)) ? 1 : -1;\n\t}\n\n\treturn (WEP_GETPOS(a->pos) > WEP_GETPOS(b->pos)) ? 1 : -1;\n}",
    "includes": [
      "#include \"miscadmin.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WEP_GETPOS",
          "args": [
            "b->pos"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEP_GETPOS",
          "args": [
            "a->pos"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEP_GETWEIGHT",
          "args": [
            "b->pos"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEP_GETWEIGHT",
          "args": [
            "a->pos"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEP_GETWEIGHT",
          "args": [
            "b->pos"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEP_GETWEIGHT",
          "args": [
            "a->pos"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEP_GETPOS",
          "args": [
            "b->pos"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEP_GETPOS",
          "args": [
            "a->pos"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"tsearch/ts_utils.h\"\n#include <math.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic int\ncompareDocR(const void *va, const void *vb)\n{\n\tconst DocRepresentation *a = (const DocRepresentation *) va;\n\tconst DocRepresentation *b = (const DocRepresentation *) vb;\n\n\tif (WEP_GETPOS(a->pos) == WEP_GETPOS(b->pos))\n\t{\n\t\tif (WEP_GETWEIGHT(a->pos) == WEP_GETWEIGHT(b->pos))\n\t\t{\n\t\t\tif (a->data.map.entry == b->data.map.entry)\n\t\t\t\treturn 0;\n\n\t\t\treturn (a->data.map.entry > b->data.map.entry) ? 1 : -1;\n\t\t}\n\n\t\treturn (WEP_GETWEIGHT(a->pos) > WEP_GETWEIGHT(b->pos)) ? 1 : -1;\n\t}\n\n\treturn (WEP_GETPOS(a->pos) > WEP_GETPOS(b->pos)) ? 1 : -1;\n}"
  },
  {
    "function_name": "ts_rank_tt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsrank.c",
    "lines": "486-498",
    "snippet": "Datum\nts_rank_tt(PG_FUNCTION_ARGS)\n{\n\tTSVector\ttxt = PG_GETARG_TSVECTOR(0);\n\tTSQuery\t\tquery = PG_GETARG_TSQUERY(1);\n\tfloat\t\tres;\n\n\tres = calc_rank(getWeights(NULL), txt, query, DEF_NORM_METHOD);\n\n\tPG_FREE_IF_COPY(txt, 0);\n\tPG_FREE_IF_COPY(query, 1);\n\tPG_RETURN_FLOAT4(res);\n}",
    "includes": [
      "#include \"miscadmin.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define DEF_NORM_METHOD\t\t\tRANK_NO_NORM"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT4",
          "args": [
            "res"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "query",
            "1"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "txt",
            "0"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calc_rank",
          "args": [
            "getWeights(NULL)",
            "txt",
            "query",
            "DEF_NORM_METHOD"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "calc_rank_cd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsrank.c",
          "lines": "846-947",
          "snippet": "static float4\ncalc_rank_cd(const float4 *arrdata, TSVector txt, TSQuery query, int method)\n{\n\tDocRepresentation *doc;\n\tint\t\t\tlen,\n\t\t\t\ti,\n\t\t\t\tdoclen = 0;\n\tCoverExt\text;\n\tdouble\t\tWdoc = 0.0;\n\tdouble\t\tinvws[lengthof(weights)];\n\tdouble\t\tSumDist = 0.0,\n\t\t\t\tPrevExtPos = 0.0,\n\t\t\t\tCurExtPos = 0.0;\n\tint\t\t\tNExtent = 0;\n\tQueryRepresentation qr;\n\n\n\tfor (i = 0; i < lengthof(weights); i++)\n\t{\n\t\tinvws[i] = ((double) ((arrdata[i] >= 0) ? arrdata[i] : weights[i]));\n\t\tif (invws[i] > 1.0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"weight out of range\")));\n\t\tinvws[i] = 1.0 / invws[i];\n\t}\n\n\tqr.query = query;\n\tqr.operandData = (QueryRepresentationOperand *)\n\t\tpalloc0(sizeof(QueryRepresentationOperand) * query->size);\n\n\tdoc = get_docrep(txt, &qr, &doclen);\n\tif (!doc)\n\t{\n\t\tpfree(qr.operandData);\n\t\treturn 0.0;\n\t}\n\n\tMemSet(&ext, 0, sizeof(CoverExt));\n\twhile (Cover(doc, doclen, &qr, &ext))\n\t{\n\t\tdouble\t\tCpos = 0.0;\n\t\tdouble\t\tInvSum = 0.0;\n\t\tint\t\t\tnNoise;\n\t\tDocRepresentation *ptr = ext.begin;\n\n\t\twhile (ptr <= ext.end)\n\t\t{\n\t\t\tInvSum += invws[WEP_GETWEIGHT(ptr->pos)];\n\t\t\tptr++;\n\t\t}\n\n\t\tCpos = ((double) (ext.end - ext.begin + 1)) / InvSum;\n\n\t\t/*\n\t\t * if doc are big enough then ext.q may be equal to ext.p due to limit\n\t\t * of positional information. In this case we approximate number of\n\t\t * noise word as half cover's length\n\t\t */\n\t\tnNoise = (ext.q - ext.p) - (ext.end - ext.begin);\n\t\tif (nNoise < 0)\n\t\t\tnNoise = (ext.end - ext.begin) / 2;\n\t\tWdoc += Cpos / ((double) (1 + nNoise));\n\n\t\tCurExtPos = ((double) (ext.q + ext.p)) / 2.0;\n\t\tif (NExtent > 0 && CurExtPos > PrevExtPos\t/* prevent division by\n\t\t\t\t\t\t\t\t\t\t\t\t\t * zero in a case of\n\t\t\t  * multiple lexize */ )\n\t\t\tSumDist += 1.0 / (CurExtPos - PrevExtPos);\n\n\t\tPrevExtPos = CurExtPos;\n\t\tNExtent++;\n\t}\n\n\tif ((method & RANK_NORM_LOGLENGTH) && txt->size > 0)\n\t\tWdoc /= log((double) (cnt_length(txt) + 1));\n\n\tif (method & RANK_NORM_LENGTH)\n\t{\n\t\tlen = cnt_length(txt);\n\t\tif (len > 0)\n\t\t\tWdoc /= (double) len;\n\t}\n\n\tif ((method & RANK_NORM_EXTDIST) && NExtent > 0 && SumDist > 0)\n\t\tWdoc /= ((double) NExtent) / SumDist;\n\n\tif ((method & RANK_NORM_UNIQ) && txt->size > 0)\n\t\tWdoc /= (double) (txt->size);\n\n\tif ((method & RANK_NORM_LOGUNIQ) && txt->size > 0)\n\t\tWdoc /= log((double) (txt->size + 1)) / log(2.0);\n\n\tif (method & RANK_NORM_RDIVRPLUS1)\n\t\tWdoc /= (Wdoc + 1);\n\n\tpfree(doc);\n\n\tpfree(qr.operandData);\n\n\treturn (float4) Wdoc;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RANK_NORM_RDIVRPLUS1\t0x20",
            "#define RANK_NORM_LOGUNIQ\t\t0x10",
            "#define RANK_NORM_UNIQ\t\t\t0x08",
            "#define RANK_NORM_EXTDIST\t\t0x04",
            "#define RANK_NORM_LENGTH\t\t0x02",
            "#define RANK_NORM_LOGLENGTH\t\t0x01"
          ],
          "globals_used": [
            "static const float weights[] = {0.1f, 0.2f, 0.4f, 1.0f};",
            "static float calc_rank_or(const float *w, TSVector t, TSQuery q);",
            "static float calc_rank_and(const float *w, TSVector t, TSQuery q);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"tsearch/ts_utils.h\"\n#include <math.h>\n#include <limits.h>\n#include \"postgres.h\"\n\n#define RANK_NORM_RDIVRPLUS1\t0x20\n#define RANK_NORM_LOGUNIQ\t\t0x10\n#define RANK_NORM_UNIQ\t\t\t0x08\n#define RANK_NORM_EXTDIST\t\t0x04\n#define RANK_NORM_LENGTH\t\t0x02\n#define RANK_NORM_LOGLENGTH\t\t0x01\n\nstatic const float weights[] = {0.1f, 0.2f, 0.4f, 1.0f};\nstatic float calc_rank_or(const float *w, TSVector t, TSQuery q);\nstatic float calc_rank_and(const float *w, TSVector t, TSQuery q);\n\nstatic float4\ncalc_rank_cd(const float4 *arrdata, TSVector txt, TSQuery query, int method)\n{\n\tDocRepresentation *doc;\n\tint\t\t\tlen,\n\t\t\t\ti,\n\t\t\t\tdoclen = 0;\n\tCoverExt\text;\n\tdouble\t\tWdoc = 0.0;\n\tdouble\t\tinvws[lengthof(weights)];\n\tdouble\t\tSumDist = 0.0,\n\t\t\t\tPrevExtPos = 0.0,\n\t\t\t\tCurExtPos = 0.0;\n\tint\t\t\tNExtent = 0;\n\tQueryRepresentation qr;\n\n\n\tfor (i = 0; i < lengthof(weights); i++)\n\t{\n\t\tinvws[i] = ((double) ((arrdata[i] >= 0) ? arrdata[i] : weights[i]));\n\t\tif (invws[i] > 1.0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"weight out of range\")));\n\t\tinvws[i] = 1.0 / invws[i];\n\t}\n\n\tqr.query = query;\n\tqr.operandData = (QueryRepresentationOperand *)\n\t\tpalloc0(sizeof(QueryRepresentationOperand) * query->size);\n\n\tdoc = get_docrep(txt, &qr, &doclen);\n\tif (!doc)\n\t{\n\t\tpfree(qr.operandData);\n\t\treturn 0.0;\n\t}\n\n\tMemSet(&ext, 0, sizeof(CoverExt));\n\twhile (Cover(doc, doclen, &qr, &ext))\n\t{\n\t\tdouble\t\tCpos = 0.0;\n\t\tdouble\t\tInvSum = 0.0;\n\t\tint\t\t\tnNoise;\n\t\tDocRepresentation *ptr = ext.begin;\n\n\t\twhile (ptr <= ext.end)\n\t\t{\n\t\t\tInvSum += invws[WEP_GETWEIGHT(ptr->pos)];\n\t\t\tptr++;\n\t\t}\n\n\t\tCpos = ((double) (ext.end - ext.begin + 1)) / InvSum;\n\n\t\t/*\n\t\t * if doc are big enough then ext.q may be equal to ext.p due to limit\n\t\t * of positional information. In this case we approximate number of\n\t\t * noise word as half cover's length\n\t\t */\n\t\tnNoise = (ext.q - ext.p) - (ext.end - ext.begin);\n\t\tif (nNoise < 0)\n\t\t\tnNoise = (ext.end - ext.begin) / 2;\n\t\tWdoc += Cpos / ((double) (1 + nNoise));\n\n\t\tCurExtPos = ((double) (ext.q + ext.p)) / 2.0;\n\t\tif (NExtent > 0 && CurExtPos > PrevExtPos\t/* prevent division by\n\t\t\t\t\t\t\t\t\t\t\t\t\t * zero in a case of\n\t\t\t  * multiple lexize */ )\n\t\t\tSumDist += 1.0 / (CurExtPos - PrevExtPos);\n\n\t\tPrevExtPos = CurExtPos;\n\t\tNExtent++;\n\t}\n\n\tif ((method & RANK_NORM_LOGLENGTH) && txt->size > 0)\n\t\tWdoc /= log((double) (cnt_length(txt) + 1));\n\n\tif (method & RANK_NORM_LENGTH)\n\t{\n\t\tlen = cnt_length(txt);\n\t\tif (len > 0)\n\t\t\tWdoc /= (double) len;\n\t}\n\n\tif ((method & RANK_NORM_EXTDIST) && NExtent > 0 && SumDist > 0)\n\t\tWdoc /= ((double) NExtent) / SumDist;\n\n\tif ((method & RANK_NORM_UNIQ) && txt->size > 0)\n\t\tWdoc /= (double) (txt->size);\n\n\tif ((method & RANK_NORM_LOGUNIQ) && txt->size > 0)\n\t\tWdoc /= log((double) (txt->size + 1)) / log(2.0);\n\n\tif (method & RANK_NORM_RDIVRPLUS1)\n\t\tWdoc /= (Wdoc + 1);\n\n\tpfree(doc);\n\n\tpfree(qr.operandData);\n\n\treturn (float4) Wdoc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getWeights",
          "args": [
            "NULL"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "getWeights",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsrank.c",
          "lines": "400-436",
          "snippet": "static const float *\ngetWeights(ArrayType *win)\n{\n\tstatic float ws[lengthof(weights)];\n\tint\t\t\ti;\n\tfloat4\t   *arrdata;\n\n\tif (win == NULL)\n\t\treturn weights;\n\n\tif (ARR_NDIM(win) != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"array of weight must be one-dimensional\")));\n\n\tif (ArrayGetNItems(ARR_NDIM(win), ARR_DIMS(win)) < lengthof(weights))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"array of weight is too short\")));\n\n\tif (array_contains_nulls(win))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"array of weight must not contain nulls\")));\n\n\tarrdata = (float4 *) ARR_DATA_PTR(win);\n\tfor (i = 0; i < lengthof(weights); i++)\n\t{\n\t\tws[i] = (arrdata[i] >= 0) ? arrdata[i] : weights[i];\n\t\tif (ws[i] > 1.0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"weight out of range\")));\n\t}\n\n\treturn ws;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const float weights[] = {0.1f, 0.2f, 0.4f, 1.0f};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"tsearch/ts_utils.h\"\n#include <math.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic const float weights[] = {0.1f, 0.2f, 0.4f, 1.0f};\n\nstatic const float *\ngetWeights(ArrayType *win)\n{\n\tstatic float ws[lengthof(weights)];\n\tint\t\t\ti;\n\tfloat4\t   *arrdata;\n\n\tif (win == NULL)\n\t\treturn weights;\n\n\tif (ARR_NDIM(win) != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"array of weight must be one-dimensional\")));\n\n\tif (ArrayGetNItems(ARR_NDIM(win), ARR_DIMS(win)) < lengthof(weights))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"array of weight is too short\")));\n\n\tif (array_contains_nulls(win))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"array of weight must not contain nulls\")));\n\n\tarrdata = (float4 *) ARR_DATA_PTR(win);\n\tfor (i = 0; i < lengthof(weights); i++)\n\t{\n\t\tws[i] = (arrdata[i] >= 0) ? arrdata[i] : weights[i];\n\t\tif (ws[i] > 1.0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"weight out of range\")));\n\t}\n\n\treturn ws;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TSQUERY",
          "args": [
            "1"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TSVECTOR",
          "args": [
            "0"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"tsearch/ts_utils.h\"\n#include <math.h>\n#include <limits.h>\n#include \"postgres.h\"\n\n#define DEF_NORM_METHOD\t\t\tRANK_NO_NORM\n\nDatum\nts_rank_tt(PG_FUNCTION_ARGS)\n{\n\tTSVector\ttxt = PG_GETARG_TSVECTOR(0);\n\tTSQuery\t\tquery = PG_GETARG_TSQUERY(1);\n\tfloat\t\tres;\n\n\tres = calc_rank(getWeights(NULL), txt, query, DEF_NORM_METHOD);\n\n\tPG_FREE_IF_COPY(txt, 0);\n\tPG_FREE_IF_COPY(query, 1);\n\tPG_RETURN_FLOAT4(res);\n}"
  },
  {
    "function_name": "ts_rank_ttf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsrank.c",
    "lines": "471-484",
    "snippet": "Datum\nts_rank_ttf(PG_FUNCTION_ARGS)\n{\n\tTSVector\ttxt = PG_GETARG_TSVECTOR(0);\n\tTSQuery\t\tquery = PG_GETARG_TSQUERY(1);\n\tint\t\t\tmethod = PG_GETARG_INT32(2);\n\tfloat\t\tres;\n\n\tres = calc_rank(getWeights(NULL), txt, query, method);\n\n\tPG_FREE_IF_COPY(txt, 0);\n\tPG_FREE_IF_COPY(query, 1);\n\tPG_RETURN_FLOAT4(res);\n}",
    "includes": [
      "#include \"miscadmin.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT4",
          "args": [
            "res"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "query",
            "1"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "txt",
            "0"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calc_rank",
          "args": [
            "getWeights(NULL)",
            "txt",
            "query",
            "method"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "calc_rank_cd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsrank.c",
          "lines": "846-947",
          "snippet": "static float4\ncalc_rank_cd(const float4 *arrdata, TSVector txt, TSQuery query, int method)\n{\n\tDocRepresentation *doc;\n\tint\t\t\tlen,\n\t\t\t\ti,\n\t\t\t\tdoclen = 0;\n\tCoverExt\text;\n\tdouble\t\tWdoc = 0.0;\n\tdouble\t\tinvws[lengthof(weights)];\n\tdouble\t\tSumDist = 0.0,\n\t\t\t\tPrevExtPos = 0.0,\n\t\t\t\tCurExtPos = 0.0;\n\tint\t\t\tNExtent = 0;\n\tQueryRepresentation qr;\n\n\n\tfor (i = 0; i < lengthof(weights); i++)\n\t{\n\t\tinvws[i] = ((double) ((arrdata[i] >= 0) ? arrdata[i] : weights[i]));\n\t\tif (invws[i] > 1.0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"weight out of range\")));\n\t\tinvws[i] = 1.0 / invws[i];\n\t}\n\n\tqr.query = query;\n\tqr.operandData = (QueryRepresentationOperand *)\n\t\tpalloc0(sizeof(QueryRepresentationOperand) * query->size);\n\n\tdoc = get_docrep(txt, &qr, &doclen);\n\tif (!doc)\n\t{\n\t\tpfree(qr.operandData);\n\t\treturn 0.0;\n\t}\n\n\tMemSet(&ext, 0, sizeof(CoverExt));\n\twhile (Cover(doc, doclen, &qr, &ext))\n\t{\n\t\tdouble\t\tCpos = 0.0;\n\t\tdouble\t\tInvSum = 0.0;\n\t\tint\t\t\tnNoise;\n\t\tDocRepresentation *ptr = ext.begin;\n\n\t\twhile (ptr <= ext.end)\n\t\t{\n\t\t\tInvSum += invws[WEP_GETWEIGHT(ptr->pos)];\n\t\t\tptr++;\n\t\t}\n\n\t\tCpos = ((double) (ext.end - ext.begin + 1)) / InvSum;\n\n\t\t/*\n\t\t * if doc are big enough then ext.q may be equal to ext.p due to limit\n\t\t * of positional information. In this case we approximate number of\n\t\t * noise word as half cover's length\n\t\t */\n\t\tnNoise = (ext.q - ext.p) - (ext.end - ext.begin);\n\t\tif (nNoise < 0)\n\t\t\tnNoise = (ext.end - ext.begin) / 2;\n\t\tWdoc += Cpos / ((double) (1 + nNoise));\n\n\t\tCurExtPos = ((double) (ext.q + ext.p)) / 2.0;\n\t\tif (NExtent > 0 && CurExtPos > PrevExtPos\t/* prevent division by\n\t\t\t\t\t\t\t\t\t\t\t\t\t * zero in a case of\n\t\t\t  * multiple lexize */ )\n\t\t\tSumDist += 1.0 / (CurExtPos - PrevExtPos);\n\n\t\tPrevExtPos = CurExtPos;\n\t\tNExtent++;\n\t}\n\n\tif ((method & RANK_NORM_LOGLENGTH) && txt->size > 0)\n\t\tWdoc /= log((double) (cnt_length(txt) + 1));\n\n\tif (method & RANK_NORM_LENGTH)\n\t{\n\t\tlen = cnt_length(txt);\n\t\tif (len > 0)\n\t\t\tWdoc /= (double) len;\n\t}\n\n\tif ((method & RANK_NORM_EXTDIST) && NExtent > 0 && SumDist > 0)\n\t\tWdoc /= ((double) NExtent) / SumDist;\n\n\tif ((method & RANK_NORM_UNIQ) && txt->size > 0)\n\t\tWdoc /= (double) (txt->size);\n\n\tif ((method & RANK_NORM_LOGUNIQ) && txt->size > 0)\n\t\tWdoc /= log((double) (txt->size + 1)) / log(2.0);\n\n\tif (method & RANK_NORM_RDIVRPLUS1)\n\t\tWdoc /= (Wdoc + 1);\n\n\tpfree(doc);\n\n\tpfree(qr.operandData);\n\n\treturn (float4) Wdoc;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RANK_NORM_RDIVRPLUS1\t0x20",
            "#define RANK_NORM_LOGUNIQ\t\t0x10",
            "#define RANK_NORM_UNIQ\t\t\t0x08",
            "#define RANK_NORM_EXTDIST\t\t0x04",
            "#define RANK_NORM_LENGTH\t\t0x02",
            "#define RANK_NORM_LOGLENGTH\t\t0x01"
          ],
          "globals_used": [
            "static const float weights[] = {0.1f, 0.2f, 0.4f, 1.0f};",
            "static float calc_rank_or(const float *w, TSVector t, TSQuery q);",
            "static float calc_rank_and(const float *w, TSVector t, TSQuery q);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"tsearch/ts_utils.h\"\n#include <math.h>\n#include <limits.h>\n#include \"postgres.h\"\n\n#define RANK_NORM_RDIVRPLUS1\t0x20\n#define RANK_NORM_LOGUNIQ\t\t0x10\n#define RANK_NORM_UNIQ\t\t\t0x08\n#define RANK_NORM_EXTDIST\t\t0x04\n#define RANK_NORM_LENGTH\t\t0x02\n#define RANK_NORM_LOGLENGTH\t\t0x01\n\nstatic const float weights[] = {0.1f, 0.2f, 0.4f, 1.0f};\nstatic float calc_rank_or(const float *w, TSVector t, TSQuery q);\nstatic float calc_rank_and(const float *w, TSVector t, TSQuery q);\n\nstatic float4\ncalc_rank_cd(const float4 *arrdata, TSVector txt, TSQuery query, int method)\n{\n\tDocRepresentation *doc;\n\tint\t\t\tlen,\n\t\t\t\ti,\n\t\t\t\tdoclen = 0;\n\tCoverExt\text;\n\tdouble\t\tWdoc = 0.0;\n\tdouble\t\tinvws[lengthof(weights)];\n\tdouble\t\tSumDist = 0.0,\n\t\t\t\tPrevExtPos = 0.0,\n\t\t\t\tCurExtPos = 0.0;\n\tint\t\t\tNExtent = 0;\n\tQueryRepresentation qr;\n\n\n\tfor (i = 0; i < lengthof(weights); i++)\n\t{\n\t\tinvws[i] = ((double) ((arrdata[i] >= 0) ? arrdata[i] : weights[i]));\n\t\tif (invws[i] > 1.0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"weight out of range\")));\n\t\tinvws[i] = 1.0 / invws[i];\n\t}\n\n\tqr.query = query;\n\tqr.operandData = (QueryRepresentationOperand *)\n\t\tpalloc0(sizeof(QueryRepresentationOperand) * query->size);\n\n\tdoc = get_docrep(txt, &qr, &doclen);\n\tif (!doc)\n\t{\n\t\tpfree(qr.operandData);\n\t\treturn 0.0;\n\t}\n\n\tMemSet(&ext, 0, sizeof(CoverExt));\n\twhile (Cover(doc, doclen, &qr, &ext))\n\t{\n\t\tdouble\t\tCpos = 0.0;\n\t\tdouble\t\tInvSum = 0.0;\n\t\tint\t\t\tnNoise;\n\t\tDocRepresentation *ptr = ext.begin;\n\n\t\twhile (ptr <= ext.end)\n\t\t{\n\t\t\tInvSum += invws[WEP_GETWEIGHT(ptr->pos)];\n\t\t\tptr++;\n\t\t}\n\n\t\tCpos = ((double) (ext.end - ext.begin + 1)) / InvSum;\n\n\t\t/*\n\t\t * if doc are big enough then ext.q may be equal to ext.p due to limit\n\t\t * of positional information. In this case we approximate number of\n\t\t * noise word as half cover's length\n\t\t */\n\t\tnNoise = (ext.q - ext.p) - (ext.end - ext.begin);\n\t\tif (nNoise < 0)\n\t\t\tnNoise = (ext.end - ext.begin) / 2;\n\t\tWdoc += Cpos / ((double) (1 + nNoise));\n\n\t\tCurExtPos = ((double) (ext.q + ext.p)) / 2.0;\n\t\tif (NExtent > 0 && CurExtPos > PrevExtPos\t/* prevent division by\n\t\t\t\t\t\t\t\t\t\t\t\t\t * zero in a case of\n\t\t\t  * multiple lexize */ )\n\t\t\tSumDist += 1.0 / (CurExtPos - PrevExtPos);\n\n\t\tPrevExtPos = CurExtPos;\n\t\tNExtent++;\n\t}\n\n\tif ((method & RANK_NORM_LOGLENGTH) && txt->size > 0)\n\t\tWdoc /= log((double) (cnt_length(txt) + 1));\n\n\tif (method & RANK_NORM_LENGTH)\n\t{\n\t\tlen = cnt_length(txt);\n\t\tif (len > 0)\n\t\t\tWdoc /= (double) len;\n\t}\n\n\tif ((method & RANK_NORM_EXTDIST) && NExtent > 0 && SumDist > 0)\n\t\tWdoc /= ((double) NExtent) / SumDist;\n\n\tif ((method & RANK_NORM_UNIQ) && txt->size > 0)\n\t\tWdoc /= (double) (txt->size);\n\n\tif ((method & RANK_NORM_LOGUNIQ) && txt->size > 0)\n\t\tWdoc /= log((double) (txt->size + 1)) / log(2.0);\n\n\tif (method & RANK_NORM_RDIVRPLUS1)\n\t\tWdoc /= (Wdoc + 1);\n\n\tpfree(doc);\n\n\tpfree(qr.operandData);\n\n\treturn (float4) Wdoc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getWeights",
          "args": [
            "NULL"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "getWeights",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsrank.c",
          "lines": "400-436",
          "snippet": "static const float *\ngetWeights(ArrayType *win)\n{\n\tstatic float ws[lengthof(weights)];\n\tint\t\t\ti;\n\tfloat4\t   *arrdata;\n\n\tif (win == NULL)\n\t\treturn weights;\n\n\tif (ARR_NDIM(win) != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"array of weight must be one-dimensional\")));\n\n\tif (ArrayGetNItems(ARR_NDIM(win), ARR_DIMS(win)) < lengthof(weights))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"array of weight is too short\")));\n\n\tif (array_contains_nulls(win))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"array of weight must not contain nulls\")));\n\n\tarrdata = (float4 *) ARR_DATA_PTR(win);\n\tfor (i = 0; i < lengthof(weights); i++)\n\t{\n\t\tws[i] = (arrdata[i] >= 0) ? arrdata[i] : weights[i];\n\t\tif (ws[i] > 1.0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"weight out of range\")));\n\t}\n\n\treturn ws;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const float weights[] = {0.1f, 0.2f, 0.4f, 1.0f};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"tsearch/ts_utils.h\"\n#include <math.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic const float weights[] = {0.1f, 0.2f, 0.4f, 1.0f};\n\nstatic const float *\ngetWeights(ArrayType *win)\n{\n\tstatic float ws[lengthof(weights)];\n\tint\t\t\ti;\n\tfloat4\t   *arrdata;\n\n\tif (win == NULL)\n\t\treturn weights;\n\n\tif (ARR_NDIM(win) != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"array of weight must be one-dimensional\")));\n\n\tif (ArrayGetNItems(ARR_NDIM(win), ARR_DIMS(win)) < lengthof(weights))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"array of weight is too short\")));\n\n\tif (array_contains_nulls(win))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"array of weight must not contain nulls\")));\n\n\tarrdata = (float4 *) ARR_DATA_PTR(win);\n\tfor (i = 0; i < lengthof(weights); i++)\n\t{\n\t\tws[i] = (arrdata[i] >= 0) ? arrdata[i] : weights[i];\n\t\tif (ws[i] > 1.0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"weight out of range\")));\n\t}\n\n\treturn ws;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "2"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TSQUERY",
          "args": [
            "1"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TSVECTOR",
          "args": [
            "0"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"tsearch/ts_utils.h\"\n#include <math.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\nts_rank_ttf(PG_FUNCTION_ARGS)\n{\n\tTSVector\ttxt = PG_GETARG_TSVECTOR(0);\n\tTSQuery\t\tquery = PG_GETARG_TSQUERY(1);\n\tint\t\t\tmethod = PG_GETARG_INT32(2);\n\tfloat\t\tres;\n\n\tres = calc_rank(getWeights(NULL), txt, query, method);\n\n\tPG_FREE_IF_COPY(txt, 0);\n\tPG_FREE_IF_COPY(query, 1);\n\tPG_RETURN_FLOAT4(res);\n}"
  },
  {
    "function_name": "ts_rank_wtt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsrank.c",
    "lines": "455-469",
    "snippet": "Datum\nts_rank_wtt(PG_FUNCTION_ARGS)\n{\n\tArrayType  *win = (ArrayType *) PG_DETOAST_DATUM(PG_GETARG_DATUM(0));\n\tTSVector\ttxt = PG_GETARG_TSVECTOR(1);\n\tTSQuery\t\tquery = PG_GETARG_TSQUERY(2);\n\tfloat\t\tres;\n\n\tres = calc_rank(getWeights(win), txt, query, DEF_NORM_METHOD);\n\n\tPG_FREE_IF_COPY(win, 0);\n\tPG_FREE_IF_COPY(txt, 1);\n\tPG_FREE_IF_COPY(query, 2);\n\tPG_RETURN_FLOAT4(res);\n}",
    "includes": [
      "#include \"miscadmin.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define DEF_NORM_METHOD\t\t\tRANK_NO_NORM"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT4",
          "args": [
            "res"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "query",
            "2"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "txt",
            "1"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "win",
            "0"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calc_rank",
          "args": [
            "getWeights(win)",
            "txt",
            "query",
            "DEF_NORM_METHOD"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "calc_rank_cd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsrank.c",
          "lines": "846-947",
          "snippet": "static float4\ncalc_rank_cd(const float4 *arrdata, TSVector txt, TSQuery query, int method)\n{\n\tDocRepresentation *doc;\n\tint\t\t\tlen,\n\t\t\t\ti,\n\t\t\t\tdoclen = 0;\n\tCoverExt\text;\n\tdouble\t\tWdoc = 0.0;\n\tdouble\t\tinvws[lengthof(weights)];\n\tdouble\t\tSumDist = 0.0,\n\t\t\t\tPrevExtPos = 0.0,\n\t\t\t\tCurExtPos = 0.0;\n\tint\t\t\tNExtent = 0;\n\tQueryRepresentation qr;\n\n\n\tfor (i = 0; i < lengthof(weights); i++)\n\t{\n\t\tinvws[i] = ((double) ((arrdata[i] >= 0) ? arrdata[i] : weights[i]));\n\t\tif (invws[i] > 1.0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"weight out of range\")));\n\t\tinvws[i] = 1.0 / invws[i];\n\t}\n\n\tqr.query = query;\n\tqr.operandData = (QueryRepresentationOperand *)\n\t\tpalloc0(sizeof(QueryRepresentationOperand) * query->size);\n\n\tdoc = get_docrep(txt, &qr, &doclen);\n\tif (!doc)\n\t{\n\t\tpfree(qr.operandData);\n\t\treturn 0.0;\n\t}\n\n\tMemSet(&ext, 0, sizeof(CoverExt));\n\twhile (Cover(doc, doclen, &qr, &ext))\n\t{\n\t\tdouble\t\tCpos = 0.0;\n\t\tdouble\t\tInvSum = 0.0;\n\t\tint\t\t\tnNoise;\n\t\tDocRepresentation *ptr = ext.begin;\n\n\t\twhile (ptr <= ext.end)\n\t\t{\n\t\t\tInvSum += invws[WEP_GETWEIGHT(ptr->pos)];\n\t\t\tptr++;\n\t\t}\n\n\t\tCpos = ((double) (ext.end - ext.begin + 1)) / InvSum;\n\n\t\t/*\n\t\t * if doc are big enough then ext.q may be equal to ext.p due to limit\n\t\t * of positional information. In this case we approximate number of\n\t\t * noise word as half cover's length\n\t\t */\n\t\tnNoise = (ext.q - ext.p) - (ext.end - ext.begin);\n\t\tif (nNoise < 0)\n\t\t\tnNoise = (ext.end - ext.begin) / 2;\n\t\tWdoc += Cpos / ((double) (1 + nNoise));\n\n\t\tCurExtPos = ((double) (ext.q + ext.p)) / 2.0;\n\t\tif (NExtent > 0 && CurExtPos > PrevExtPos\t/* prevent division by\n\t\t\t\t\t\t\t\t\t\t\t\t\t * zero in a case of\n\t\t\t  * multiple lexize */ )\n\t\t\tSumDist += 1.0 / (CurExtPos - PrevExtPos);\n\n\t\tPrevExtPos = CurExtPos;\n\t\tNExtent++;\n\t}\n\n\tif ((method & RANK_NORM_LOGLENGTH) && txt->size > 0)\n\t\tWdoc /= log((double) (cnt_length(txt) + 1));\n\n\tif (method & RANK_NORM_LENGTH)\n\t{\n\t\tlen = cnt_length(txt);\n\t\tif (len > 0)\n\t\t\tWdoc /= (double) len;\n\t}\n\n\tif ((method & RANK_NORM_EXTDIST) && NExtent > 0 && SumDist > 0)\n\t\tWdoc /= ((double) NExtent) / SumDist;\n\n\tif ((method & RANK_NORM_UNIQ) && txt->size > 0)\n\t\tWdoc /= (double) (txt->size);\n\n\tif ((method & RANK_NORM_LOGUNIQ) && txt->size > 0)\n\t\tWdoc /= log((double) (txt->size + 1)) / log(2.0);\n\n\tif (method & RANK_NORM_RDIVRPLUS1)\n\t\tWdoc /= (Wdoc + 1);\n\n\tpfree(doc);\n\n\tpfree(qr.operandData);\n\n\treturn (float4) Wdoc;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RANK_NORM_RDIVRPLUS1\t0x20",
            "#define RANK_NORM_LOGUNIQ\t\t0x10",
            "#define RANK_NORM_UNIQ\t\t\t0x08",
            "#define RANK_NORM_EXTDIST\t\t0x04",
            "#define RANK_NORM_LENGTH\t\t0x02",
            "#define RANK_NORM_LOGLENGTH\t\t0x01"
          ],
          "globals_used": [
            "static const float weights[] = {0.1f, 0.2f, 0.4f, 1.0f};",
            "static float calc_rank_or(const float *w, TSVector t, TSQuery q);",
            "static float calc_rank_and(const float *w, TSVector t, TSQuery q);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"tsearch/ts_utils.h\"\n#include <math.h>\n#include <limits.h>\n#include \"postgres.h\"\n\n#define RANK_NORM_RDIVRPLUS1\t0x20\n#define RANK_NORM_LOGUNIQ\t\t0x10\n#define RANK_NORM_UNIQ\t\t\t0x08\n#define RANK_NORM_EXTDIST\t\t0x04\n#define RANK_NORM_LENGTH\t\t0x02\n#define RANK_NORM_LOGLENGTH\t\t0x01\n\nstatic const float weights[] = {0.1f, 0.2f, 0.4f, 1.0f};\nstatic float calc_rank_or(const float *w, TSVector t, TSQuery q);\nstatic float calc_rank_and(const float *w, TSVector t, TSQuery q);\n\nstatic float4\ncalc_rank_cd(const float4 *arrdata, TSVector txt, TSQuery query, int method)\n{\n\tDocRepresentation *doc;\n\tint\t\t\tlen,\n\t\t\t\ti,\n\t\t\t\tdoclen = 0;\n\tCoverExt\text;\n\tdouble\t\tWdoc = 0.0;\n\tdouble\t\tinvws[lengthof(weights)];\n\tdouble\t\tSumDist = 0.0,\n\t\t\t\tPrevExtPos = 0.0,\n\t\t\t\tCurExtPos = 0.0;\n\tint\t\t\tNExtent = 0;\n\tQueryRepresentation qr;\n\n\n\tfor (i = 0; i < lengthof(weights); i++)\n\t{\n\t\tinvws[i] = ((double) ((arrdata[i] >= 0) ? arrdata[i] : weights[i]));\n\t\tif (invws[i] > 1.0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"weight out of range\")));\n\t\tinvws[i] = 1.0 / invws[i];\n\t}\n\n\tqr.query = query;\n\tqr.operandData = (QueryRepresentationOperand *)\n\t\tpalloc0(sizeof(QueryRepresentationOperand) * query->size);\n\n\tdoc = get_docrep(txt, &qr, &doclen);\n\tif (!doc)\n\t{\n\t\tpfree(qr.operandData);\n\t\treturn 0.0;\n\t}\n\n\tMemSet(&ext, 0, sizeof(CoverExt));\n\twhile (Cover(doc, doclen, &qr, &ext))\n\t{\n\t\tdouble\t\tCpos = 0.0;\n\t\tdouble\t\tInvSum = 0.0;\n\t\tint\t\t\tnNoise;\n\t\tDocRepresentation *ptr = ext.begin;\n\n\t\twhile (ptr <= ext.end)\n\t\t{\n\t\t\tInvSum += invws[WEP_GETWEIGHT(ptr->pos)];\n\t\t\tptr++;\n\t\t}\n\n\t\tCpos = ((double) (ext.end - ext.begin + 1)) / InvSum;\n\n\t\t/*\n\t\t * if doc are big enough then ext.q may be equal to ext.p due to limit\n\t\t * of positional information. In this case we approximate number of\n\t\t * noise word as half cover's length\n\t\t */\n\t\tnNoise = (ext.q - ext.p) - (ext.end - ext.begin);\n\t\tif (nNoise < 0)\n\t\t\tnNoise = (ext.end - ext.begin) / 2;\n\t\tWdoc += Cpos / ((double) (1 + nNoise));\n\n\t\tCurExtPos = ((double) (ext.q + ext.p)) / 2.0;\n\t\tif (NExtent > 0 && CurExtPos > PrevExtPos\t/* prevent division by\n\t\t\t\t\t\t\t\t\t\t\t\t\t * zero in a case of\n\t\t\t  * multiple lexize */ )\n\t\t\tSumDist += 1.0 / (CurExtPos - PrevExtPos);\n\n\t\tPrevExtPos = CurExtPos;\n\t\tNExtent++;\n\t}\n\n\tif ((method & RANK_NORM_LOGLENGTH) && txt->size > 0)\n\t\tWdoc /= log((double) (cnt_length(txt) + 1));\n\n\tif (method & RANK_NORM_LENGTH)\n\t{\n\t\tlen = cnt_length(txt);\n\t\tif (len > 0)\n\t\t\tWdoc /= (double) len;\n\t}\n\n\tif ((method & RANK_NORM_EXTDIST) && NExtent > 0 && SumDist > 0)\n\t\tWdoc /= ((double) NExtent) / SumDist;\n\n\tif ((method & RANK_NORM_UNIQ) && txt->size > 0)\n\t\tWdoc /= (double) (txt->size);\n\n\tif ((method & RANK_NORM_LOGUNIQ) && txt->size > 0)\n\t\tWdoc /= log((double) (txt->size + 1)) / log(2.0);\n\n\tif (method & RANK_NORM_RDIVRPLUS1)\n\t\tWdoc /= (Wdoc + 1);\n\n\tpfree(doc);\n\n\tpfree(qr.operandData);\n\n\treturn (float4) Wdoc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getWeights",
          "args": [
            "win"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "getWeights",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsrank.c",
          "lines": "400-436",
          "snippet": "static const float *\ngetWeights(ArrayType *win)\n{\n\tstatic float ws[lengthof(weights)];\n\tint\t\t\ti;\n\tfloat4\t   *arrdata;\n\n\tif (win == NULL)\n\t\treturn weights;\n\n\tif (ARR_NDIM(win) != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"array of weight must be one-dimensional\")));\n\n\tif (ArrayGetNItems(ARR_NDIM(win), ARR_DIMS(win)) < lengthof(weights))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"array of weight is too short\")));\n\n\tif (array_contains_nulls(win))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"array of weight must not contain nulls\")));\n\n\tarrdata = (float4 *) ARR_DATA_PTR(win);\n\tfor (i = 0; i < lengthof(weights); i++)\n\t{\n\t\tws[i] = (arrdata[i] >= 0) ? arrdata[i] : weights[i];\n\t\tif (ws[i] > 1.0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"weight out of range\")));\n\t}\n\n\treturn ws;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const float weights[] = {0.1f, 0.2f, 0.4f, 1.0f};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"tsearch/ts_utils.h\"\n#include <math.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic const float weights[] = {0.1f, 0.2f, 0.4f, 1.0f};\n\nstatic const float *\ngetWeights(ArrayType *win)\n{\n\tstatic float ws[lengthof(weights)];\n\tint\t\t\ti;\n\tfloat4\t   *arrdata;\n\n\tif (win == NULL)\n\t\treturn weights;\n\n\tif (ARR_NDIM(win) != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"array of weight must be one-dimensional\")));\n\n\tif (ArrayGetNItems(ARR_NDIM(win), ARR_DIMS(win)) < lengthof(weights))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"array of weight is too short\")));\n\n\tif (array_contains_nulls(win))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"array of weight must not contain nulls\")));\n\n\tarrdata = (float4 *) ARR_DATA_PTR(win);\n\tfor (i = 0; i < lengthof(weights); i++)\n\t{\n\t\tws[i] = (arrdata[i] >= 0) ? arrdata[i] : weights[i];\n\t\tif (ws[i] > 1.0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"weight out of range\")));\n\t}\n\n\treturn ws;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TSQUERY",
          "args": [
            "2"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TSVECTOR",
          "args": [
            "1"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_DETOAST_DATUM",
          "args": [
            "PG_GETARG_DATUM(0)"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "0"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"tsearch/ts_utils.h\"\n#include <math.h>\n#include <limits.h>\n#include \"postgres.h\"\n\n#define DEF_NORM_METHOD\t\t\tRANK_NO_NORM\n\nDatum\nts_rank_wtt(PG_FUNCTION_ARGS)\n{\n\tArrayType  *win = (ArrayType *) PG_DETOAST_DATUM(PG_GETARG_DATUM(0));\n\tTSVector\ttxt = PG_GETARG_TSVECTOR(1);\n\tTSQuery\t\tquery = PG_GETARG_TSQUERY(2);\n\tfloat\t\tres;\n\n\tres = calc_rank(getWeights(win), txt, query, DEF_NORM_METHOD);\n\n\tPG_FREE_IF_COPY(win, 0);\n\tPG_FREE_IF_COPY(txt, 1);\n\tPG_FREE_IF_COPY(query, 2);\n\tPG_RETURN_FLOAT4(res);\n}"
  },
  {
    "function_name": "ts_rank_wttf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsrank.c",
    "lines": "438-453",
    "snippet": "Datum\nts_rank_wttf(PG_FUNCTION_ARGS)\n{\n\tArrayType  *win = (ArrayType *) PG_DETOAST_DATUM(PG_GETARG_DATUM(0));\n\tTSVector\ttxt = PG_GETARG_TSVECTOR(1);\n\tTSQuery\t\tquery = PG_GETARG_TSQUERY(2);\n\tint\t\t\tmethod = PG_GETARG_INT32(3);\n\tfloat\t\tres;\n\n\tres = calc_rank(getWeights(win), txt, query, method);\n\n\tPG_FREE_IF_COPY(win, 0);\n\tPG_FREE_IF_COPY(txt, 1);\n\tPG_FREE_IF_COPY(query, 2);\n\tPG_RETURN_FLOAT4(res);\n}",
    "includes": [
      "#include \"miscadmin.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT4",
          "args": [
            "res"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "query",
            "2"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "txt",
            "1"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "win",
            "0"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calc_rank",
          "args": [
            "getWeights(win)",
            "txt",
            "query",
            "method"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "calc_rank_cd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsrank.c",
          "lines": "846-947",
          "snippet": "static float4\ncalc_rank_cd(const float4 *arrdata, TSVector txt, TSQuery query, int method)\n{\n\tDocRepresentation *doc;\n\tint\t\t\tlen,\n\t\t\t\ti,\n\t\t\t\tdoclen = 0;\n\tCoverExt\text;\n\tdouble\t\tWdoc = 0.0;\n\tdouble\t\tinvws[lengthof(weights)];\n\tdouble\t\tSumDist = 0.0,\n\t\t\t\tPrevExtPos = 0.0,\n\t\t\t\tCurExtPos = 0.0;\n\tint\t\t\tNExtent = 0;\n\tQueryRepresentation qr;\n\n\n\tfor (i = 0; i < lengthof(weights); i++)\n\t{\n\t\tinvws[i] = ((double) ((arrdata[i] >= 0) ? arrdata[i] : weights[i]));\n\t\tif (invws[i] > 1.0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"weight out of range\")));\n\t\tinvws[i] = 1.0 / invws[i];\n\t}\n\n\tqr.query = query;\n\tqr.operandData = (QueryRepresentationOperand *)\n\t\tpalloc0(sizeof(QueryRepresentationOperand) * query->size);\n\n\tdoc = get_docrep(txt, &qr, &doclen);\n\tif (!doc)\n\t{\n\t\tpfree(qr.operandData);\n\t\treturn 0.0;\n\t}\n\n\tMemSet(&ext, 0, sizeof(CoverExt));\n\twhile (Cover(doc, doclen, &qr, &ext))\n\t{\n\t\tdouble\t\tCpos = 0.0;\n\t\tdouble\t\tInvSum = 0.0;\n\t\tint\t\t\tnNoise;\n\t\tDocRepresentation *ptr = ext.begin;\n\n\t\twhile (ptr <= ext.end)\n\t\t{\n\t\t\tInvSum += invws[WEP_GETWEIGHT(ptr->pos)];\n\t\t\tptr++;\n\t\t}\n\n\t\tCpos = ((double) (ext.end - ext.begin + 1)) / InvSum;\n\n\t\t/*\n\t\t * if doc are big enough then ext.q may be equal to ext.p due to limit\n\t\t * of positional information. In this case we approximate number of\n\t\t * noise word as half cover's length\n\t\t */\n\t\tnNoise = (ext.q - ext.p) - (ext.end - ext.begin);\n\t\tif (nNoise < 0)\n\t\t\tnNoise = (ext.end - ext.begin) / 2;\n\t\tWdoc += Cpos / ((double) (1 + nNoise));\n\n\t\tCurExtPos = ((double) (ext.q + ext.p)) / 2.0;\n\t\tif (NExtent > 0 && CurExtPos > PrevExtPos\t/* prevent division by\n\t\t\t\t\t\t\t\t\t\t\t\t\t * zero in a case of\n\t\t\t  * multiple lexize */ )\n\t\t\tSumDist += 1.0 / (CurExtPos - PrevExtPos);\n\n\t\tPrevExtPos = CurExtPos;\n\t\tNExtent++;\n\t}\n\n\tif ((method & RANK_NORM_LOGLENGTH) && txt->size > 0)\n\t\tWdoc /= log((double) (cnt_length(txt) + 1));\n\n\tif (method & RANK_NORM_LENGTH)\n\t{\n\t\tlen = cnt_length(txt);\n\t\tif (len > 0)\n\t\t\tWdoc /= (double) len;\n\t}\n\n\tif ((method & RANK_NORM_EXTDIST) && NExtent > 0 && SumDist > 0)\n\t\tWdoc /= ((double) NExtent) / SumDist;\n\n\tif ((method & RANK_NORM_UNIQ) && txt->size > 0)\n\t\tWdoc /= (double) (txt->size);\n\n\tif ((method & RANK_NORM_LOGUNIQ) && txt->size > 0)\n\t\tWdoc /= log((double) (txt->size + 1)) / log(2.0);\n\n\tif (method & RANK_NORM_RDIVRPLUS1)\n\t\tWdoc /= (Wdoc + 1);\n\n\tpfree(doc);\n\n\tpfree(qr.operandData);\n\n\treturn (float4) Wdoc;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RANK_NORM_RDIVRPLUS1\t0x20",
            "#define RANK_NORM_LOGUNIQ\t\t0x10",
            "#define RANK_NORM_UNIQ\t\t\t0x08",
            "#define RANK_NORM_EXTDIST\t\t0x04",
            "#define RANK_NORM_LENGTH\t\t0x02",
            "#define RANK_NORM_LOGLENGTH\t\t0x01"
          ],
          "globals_used": [
            "static const float weights[] = {0.1f, 0.2f, 0.4f, 1.0f};",
            "static float calc_rank_or(const float *w, TSVector t, TSQuery q);",
            "static float calc_rank_and(const float *w, TSVector t, TSQuery q);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"tsearch/ts_utils.h\"\n#include <math.h>\n#include <limits.h>\n#include \"postgres.h\"\n\n#define RANK_NORM_RDIVRPLUS1\t0x20\n#define RANK_NORM_LOGUNIQ\t\t0x10\n#define RANK_NORM_UNIQ\t\t\t0x08\n#define RANK_NORM_EXTDIST\t\t0x04\n#define RANK_NORM_LENGTH\t\t0x02\n#define RANK_NORM_LOGLENGTH\t\t0x01\n\nstatic const float weights[] = {0.1f, 0.2f, 0.4f, 1.0f};\nstatic float calc_rank_or(const float *w, TSVector t, TSQuery q);\nstatic float calc_rank_and(const float *w, TSVector t, TSQuery q);\n\nstatic float4\ncalc_rank_cd(const float4 *arrdata, TSVector txt, TSQuery query, int method)\n{\n\tDocRepresentation *doc;\n\tint\t\t\tlen,\n\t\t\t\ti,\n\t\t\t\tdoclen = 0;\n\tCoverExt\text;\n\tdouble\t\tWdoc = 0.0;\n\tdouble\t\tinvws[lengthof(weights)];\n\tdouble\t\tSumDist = 0.0,\n\t\t\t\tPrevExtPos = 0.0,\n\t\t\t\tCurExtPos = 0.0;\n\tint\t\t\tNExtent = 0;\n\tQueryRepresentation qr;\n\n\n\tfor (i = 0; i < lengthof(weights); i++)\n\t{\n\t\tinvws[i] = ((double) ((arrdata[i] >= 0) ? arrdata[i] : weights[i]));\n\t\tif (invws[i] > 1.0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"weight out of range\")));\n\t\tinvws[i] = 1.0 / invws[i];\n\t}\n\n\tqr.query = query;\n\tqr.operandData = (QueryRepresentationOperand *)\n\t\tpalloc0(sizeof(QueryRepresentationOperand) * query->size);\n\n\tdoc = get_docrep(txt, &qr, &doclen);\n\tif (!doc)\n\t{\n\t\tpfree(qr.operandData);\n\t\treturn 0.0;\n\t}\n\n\tMemSet(&ext, 0, sizeof(CoverExt));\n\twhile (Cover(doc, doclen, &qr, &ext))\n\t{\n\t\tdouble\t\tCpos = 0.0;\n\t\tdouble\t\tInvSum = 0.0;\n\t\tint\t\t\tnNoise;\n\t\tDocRepresentation *ptr = ext.begin;\n\n\t\twhile (ptr <= ext.end)\n\t\t{\n\t\t\tInvSum += invws[WEP_GETWEIGHT(ptr->pos)];\n\t\t\tptr++;\n\t\t}\n\n\t\tCpos = ((double) (ext.end - ext.begin + 1)) / InvSum;\n\n\t\t/*\n\t\t * if doc are big enough then ext.q may be equal to ext.p due to limit\n\t\t * of positional information. In this case we approximate number of\n\t\t * noise word as half cover's length\n\t\t */\n\t\tnNoise = (ext.q - ext.p) - (ext.end - ext.begin);\n\t\tif (nNoise < 0)\n\t\t\tnNoise = (ext.end - ext.begin) / 2;\n\t\tWdoc += Cpos / ((double) (1 + nNoise));\n\n\t\tCurExtPos = ((double) (ext.q + ext.p)) / 2.0;\n\t\tif (NExtent > 0 && CurExtPos > PrevExtPos\t/* prevent division by\n\t\t\t\t\t\t\t\t\t\t\t\t\t * zero in a case of\n\t\t\t  * multiple lexize */ )\n\t\t\tSumDist += 1.0 / (CurExtPos - PrevExtPos);\n\n\t\tPrevExtPos = CurExtPos;\n\t\tNExtent++;\n\t}\n\n\tif ((method & RANK_NORM_LOGLENGTH) && txt->size > 0)\n\t\tWdoc /= log((double) (cnt_length(txt) + 1));\n\n\tif (method & RANK_NORM_LENGTH)\n\t{\n\t\tlen = cnt_length(txt);\n\t\tif (len > 0)\n\t\t\tWdoc /= (double) len;\n\t}\n\n\tif ((method & RANK_NORM_EXTDIST) && NExtent > 0 && SumDist > 0)\n\t\tWdoc /= ((double) NExtent) / SumDist;\n\n\tif ((method & RANK_NORM_UNIQ) && txt->size > 0)\n\t\tWdoc /= (double) (txt->size);\n\n\tif ((method & RANK_NORM_LOGUNIQ) && txt->size > 0)\n\t\tWdoc /= log((double) (txt->size + 1)) / log(2.0);\n\n\tif (method & RANK_NORM_RDIVRPLUS1)\n\t\tWdoc /= (Wdoc + 1);\n\n\tpfree(doc);\n\n\tpfree(qr.operandData);\n\n\treturn (float4) Wdoc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getWeights",
          "args": [
            "win"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "getWeights",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsrank.c",
          "lines": "400-436",
          "snippet": "static const float *\ngetWeights(ArrayType *win)\n{\n\tstatic float ws[lengthof(weights)];\n\tint\t\t\ti;\n\tfloat4\t   *arrdata;\n\n\tif (win == NULL)\n\t\treturn weights;\n\n\tif (ARR_NDIM(win) != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"array of weight must be one-dimensional\")));\n\n\tif (ArrayGetNItems(ARR_NDIM(win), ARR_DIMS(win)) < lengthof(weights))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"array of weight is too short\")));\n\n\tif (array_contains_nulls(win))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"array of weight must not contain nulls\")));\n\n\tarrdata = (float4 *) ARR_DATA_PTR(win);\n\tfor (i = 0; i < lengthof(weights); i++)\n\t{\n\t\tws[i] = (arrdata[i] >= 0) ? arrdata[i] : weights[i];\n\t\tif (ws[i] > 1.0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"weight out of range\")));\n\t}\n\n\treturn ws;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const float weights[] = {0.1f, 0.2f, 0.4f, 1.0f};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"tsearch/ts_utils.h\"\n#include <math.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic const float weights[] = {0.1f, 0.2f, 0.4f, 1.0f};\n\nstatic const float *\ngetWeights(ArrayType *win)\n{\n\tstatic float ws[lengthof(weights)];\n\tint\t\t\ti;\n\tfloat4\t   *arrdata;\n\n\tif (win == NULL)\n\t\treturn weights;\n\n\tif (ARR_NDIM(win) != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"array of weight must be one-dimensional\")));\n\n\tif (ArrayGetNItems(ARR_NDIM(win), ARR_DIMS(win)) < lengthof(weights))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"array of weight is too short\")));\n\n\tif (array_contains_nulls(win))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"array of weight must not contain nulls\")));\n\n\tarrdata = (float4 *) ARR_DATA_PTR(win);\n\tfor (i = 0; i < lengthof(weights); i++)\n\t{\n\t\tws[i] = (arrdata[i] >= 0) ? arrdata[i] : weights[i];\n\t\tif (ws[i] > 1.0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"weight out of range\")));\n\t}\n\n\treturn ws;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "3"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TSQUERY",
          "args": [
            "2"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TSVECTOR",
          "args": [
            "1"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_DETOAST_DATUM",
          "args": [
            "PG_GETARG_DATUM(0)"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "0"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"tsearch/ts_utils.h\"\n#include <math.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\nts_rank_wttf(PG_FUNCTION_ARGS)\n{\n\tArrayType  *win = (ArrayType *) PG_DETOAST_DATUM(PG_GETARG_DATUM(0));\n\tTSVector\ttxt = PG_GETARG_TSVECTOR(1);\n\tTSQuery\t\tquery = PG_GETARG_TSQUERY(2);\n\tint\t\t\tmethod = PG_GETARG_INT32(3);\n\tfloat\t\tres;\n\n\tres = calc_rank(getWeights(win), txt, query, method);\n\n\tPG_FREE_IF_COPY(win, 0);\n\tPG_FREE_IF_COPY(txt, 1);\n\tPG_FREE_IF_COPY(query, 2);\n\tPG_RETURN_FLOAT4(res);\n}"
  },
  {
    "function_name": "getWeights",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsrank.c",
    "lines": "400-436",
    "snippet": "static const float *\ngetWeights(ArrayType *win)\n{\n\tstatic float ws[lengthof(weights)];\n\tint\t\t\ti;\n\tfloat4\t   *arrdata;\n\n\tif (win == NULL)\n\t\treturn weights;\n\n\tif (ARR_NDIM(win) != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"array of weight must be one-dimensional\")));\n\n\tif (ArrayGetNItems(ARR_NDIM(win), ARR_DIMS(win)) < lengthof(weights))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"array of weight is too short\")));\n\n\tif (array_contains_nulls(win))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"array of weight must not contain nulls\")));\n\n\tarrdata = (float4 *) ARR_DATA_PTR(win);\n\tfor (i = 0; i < lengthof(weights); i++)\n\t{\n\t\tws[i] = (arrdata[i] >= 0) ? arrdata[i] : weights[i];\n\t\tif (ws[i] > 1.0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"weight out of range\")));\n\t}\n\n\treturn ws;\n}",
    "includes": [
      "#include \"miscadmin.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const float weights[] = {0.1f, 0.2f, 0.4f, 1.0f};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"weight out of range\"))"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"weight out of range\""
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "lengthof",
          "args": [
            "weights"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DATA_PTR",
          "args": [
            "win"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"array of weight must not contain nulls\"))"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_contains_nulls",
          "args": [
            "win"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "array_contains_nulls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3527-3562",
          "snippet": "bool\narray_contains_nulls(ArrayType *array)\n{\n\tint\t\t\tnelems;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\n\t/* Easy answer if there's no null bitmap */\n\tif (!ARR_HASNULL(array))\n\t\treturn false;\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\n\tbitmap = ARR_NULLBITMAP(array);\n\n\t/* check whole bytes of the bitmap byte-at-a-time */\n\twhile (nelems >= 8)\n\t{\n\t\tif (*bitmap != 0xFF)\n\t\t\treturn true;\n\t\tbitmap++;\n\t\tnelems -= 8;\n\t}\n\n\t/* check last partial byte */\n\tbitmask = 1;\n\twhile (nelems > 0)\n\t{\n\t\tif ((*bitmap & bitmask) == 0)\n\t\t\treturn true;\n\t\tbitmask <<= 1;\n\t\tnelems--;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nbool\narray_contains_nulls(ArrayType *array)\n{\n\tint\t\t\tnelems;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\n\t/* Easy answer if there's no null bitmap */\n\tif (!ARR_HASNULL(array))\n\t\treturn false;\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\n\tbitmap = ARR_NULLBITMAP(array);\n\n\t/* check whole bytes of the bitmap byte-at-a-time */\n\twhile (nelems >= 8)\n\t{\n\t\tif (*bitmap != 0xFF)\n\t\t\treturn true;\n\t\tbitmap++;\n\t\tnelems -= 8;\n\t}\n\n\t/* check last partial byte */\n\tbitmask = 1;\n\twhile (nelems > 0)\n\t{\n\t\tif ((*bitmap & bitmask) == 0)\n\t\t\treturn true;\n\t\tbitmask <<= 1;\n\t\tnelems--;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"array of weight is too short\"))"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lengthof",
          "args": [
            "weights"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ArrayGetNItems",
          "args": [
            "ARR_NDIM(win)",
            "ARR_DIMS(win)"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "ArrayGetNItems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
          "lines": "74-112",
          "snippet": "int\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\nint\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "win"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NDIM",
          "args": [
            "win"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"array of weight must be one-dimensional\"))"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NDIM",
          "args": [
            "win"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lengthof",
          "args": [
            "weights"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"tsearch/ts_utils.h\"\n#include <math.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic const float weights[] = {0.1f, 0.2f, 0.4f, 1.0f};\n\nstatic const float *\ngetWeights(ArrayType *win)\n{\n\tstatic float ws[lengthof(weights)];\n\tint\t\t\ti;\n\tfloat4\t   *arrdata;\n\n\tif (win == NULL)\n\t\treturn weights;\n\n\tif (ARR_NDIM(win) != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"array of weight must be one-dimensional\")));\n\n\tif (ArrayGetNItems(ARR_NDIM(win), ARR_DIMS(win)) < lengthof(weights))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"array of weight is too short\")));\n\n\tif (array_contains_nulls(win))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"array of weight must not contain nulls\")));\n\n\tarrdata = (float4 *) ARR_DATA_PTR(win);\n\tfor (i = 0; i < lengthof(weights); i++)\n\t{\n\t\tws[i] = (arrdata[i] >= 0) ? arrdata[i] : weights[i];\n\t\tif (ws[i] > 1.0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"weight out of range\")));\n\t}\n\n\treturn ws;\n}"
  },
  {
    "function_name": "calc_rank",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsrank.c",
    "lines": "357-398",
    "snippet": "static float\ncalc_rank(const float *w, TSVector t, TSQuery q, int32 method)\n{\n\tQueryItem  *item = GETQUERY(q);\n\tfloat\t\tres = 0.0;\n\tint\t\t\tlen;\n\n\tif (!t->size || !q->size)\n\t\treturn 0.0;\n\n\t/* XXX: What about NOT? */\n\tres = (item->type == QI_OPR && (item->qoperator.oper == OP_AND ||\n\t\t\t\t\t\t\t\t\titem->qoperator.oper == OP_PHRASE)) ?\n\t\tcalc_rank_and(w, t, q) :\n\t\tcalc_rank_or(w, t, q);\n\n\tif (res < 0)\n\t\tres = 1e-20f;\n\n\tif ((method & RANK_NORM_LOGLENGTH) && t->size > 0)\n\t\tres /= log((double) (cnt_length(t) + 1)) / log(2.0);\n\n\tif (method & RANK_NORM_LENGTH)\n\t{\n\t\tlen = cnt_length(t);\n\t\tif (len > 0)\n\t\t\tres /= (float) len;\n\t}\n\n\t/* RANK_NORM_EXTDIST not applicable */\n\n\tif ((method & RANK_NORM_UNIQ) && t->size > 0)\n\t\tres /= (float) (t->size);\n\n\tif ((method & RANK_NORM_LOGUNIQ) && t->size > 0)\n\t\tres /= log((double) (t->size + 1)) / log(2.0);\n\n\tif (method & RANK_NORM_RDIVRPLUS1)\n\t\tres /= (res + 1);\n\n\treturn res;\n}",
    "includes": [
      "#include \"miscadmin.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define RANK_NORM_RDIVRPLUS1\t0x20",
      "#define RANK_NORM_LOGUNIQ\t\t0x10",
      "#define RANK_NORM_UNIQ\t\t\t0x08",
      "#define RANK_NORM_EXTDIST\t\t0x04",
      "#define RANK_NORM_LENGTH\t\t0x02",
      "#define RANK_NORM_LOGLENGTH\t\t0x01"
    ],
    "globals_used": [
      "static float calc_rank_or(const float *w, TSVector t, TSQuery q);",
      "static float calc_rank_and(const float *w, TSVector t, TSQuery q);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "log",
          "args": [
            "2.0"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "floor_log2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_selfuncs.c",
          "lines": "1090-1122",
          "snippet": "static int\nfloor_log2(uint32 n)\n{\n\tint\t\t\tlogval = 0;\n\n\tif (n == 0)\n\t\treturn -1;\n\tif (n >= (1 << 16))\n\t{\n\t\tn >>= 16;\n\t\tlogval += 16;\n\t}\n\tif (n >= (1 << 8))\n\t{\n\t\tn >>= 8;\n\t\tlogval += 8;\n\t}\n\tif (n >= (1 << 4))\n\t{\n\t\tn >>= 4;\n\t\tlogval += 4;\n\t}\n\tif (n >= (1 << 2))\n\t{\n\t\tn >>= 2;\n\t\tlogval += 2;\n\t}\n\tif (n >= (1 << 1))\n\t{\n\t\tlogval += 1;\n\t}\n\treturn logval;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static float *calc_hist(const float4 *hist, int nhist, int n);",
            "static int\tfloor_log2(uint32 n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/clauses.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nstatic float *calc_hist(const float4 *hist, int nhist, int n);\nstatic int\tfloor_log2(uint32 n);\n\nstatic int\nfloor_log2(uint32 n)\n{\n\tint\t\t\tlogval = 0;\n\n\tif (n == 0)\n\t\treturn -1;\n\tif (n >= (1 << 16))\n\t{\n\t\tn >>= 16;\n\t\tlogval += 16;\n\t}\n\tif (n >= (1 << 8))\n\t{\n\t\tn >>= 8;\n\t\tlogval += 8;\n\t}\n\tif (n >= (1 << 4))\n\t{\n\t\tn >>= 4;\n\t\tlogval += 4;\n\t}\n\tif (n >= (1 << 2))\n\t{\n\t\tn >>= 2;\n\t\tlogval += 2;\n\t}\n\tif (n >= (1 << 1))\n\t{\n\t\tlogval += 1;\n\t}\n\treturn logval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cnt_length",
          "args": [
            "t"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "cnt_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsrank.c",
          "lines": "53-73",
          "snippet": "static int\ncnt_length(TSVector t)\n{\n\tWordEntry  *ptr = ARRPTR(t),\n\t\t\t   *end = (WordEntry *) STRPTR(t);\n\tint\t\t\tlen = 0;\n\n\twhile (ptr < end)\n\t{\n\t\tint\t\t\tclen = POSDATALEN(t, ptr);\n\n\t\tif (clen == 0)\n\t\t\tlen += 1;\n\t\telse\n\t\t\tlen += clen;\n\n\t\tptr++;\n\t}\n\n\treturn len;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"tsearch/ts_utils.h\"\n#include <math.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic int\ncnt_length(TSVector t)\n{\n\tWordEntry  *ptr = ARRPTR(t),\n\t\t\t   *end = (WordEntry *) STRPTR(t);\n\tint\t\t\tlen = 0;\n\n\twhile (ptr < end)\n\t{\n\t\tint\t\t\tclen = POSDATALEN(t, ptr);\n\n\t\tif (clen == 0)\n\t\t\tlen += 1;\n\t\telse\n\t\t\tlen += clen;\n\n\t\tptr++;\n\t}\n\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "calc_rank_or",
          "args": [
            "w",
            "t",
            "q"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "calc_rank_or",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsrank.c",
          "lines": "283-355",
          "snippet": "static float\ncalc_rank_or(const float *w, TSVector t, TSQuery q)\n{\n\tWordEntry  *entry,\n\t\t\t   *firstentry;\n\tWordEntryPosVector1 posnull;\n\tWordEntryPos *post;\n\tint32\t\tdimt,\n\t\t\t\tj,\n\t\t\t\ti,\n\t\t\t\tnitem;\n\tfloat\t\tres = 0.0;\n\tQueryOperand **item;\n\tint\t\t\tsize = q->size;\n\n\t/* A dummy WordEntryPos array to use when haspos is false */\n\tposnull.npos = 1;\n\tposnull.pos[0] = 0;\n\n\titem = SortAndUniqItems(q, &size);\n\n\tfor (i = 0; i < size; i++)\n\t{\n\t\tfloat\t\tresj,\n\t\t\t\t\twjm;\n\t\tint32\t\tjm;\n\n\t\tfirstentry = entry = find_wordentry(t, q, item[i], &nitem);\n\t\tif (!entry)\n\t\t\tcontinue;\n\n\t\twhile (entry - firstentry < nitem)\n\t\t{\n\t\t\tif (entry->haspos)\n\t\t\t{\n\t\t\t\tdimt = POSDATALEN(t, entry);\n\t\t\t\tpost = POSDATAPTR(t, entry);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdimt = posnull.npos;\n\t\t\t\tpost = posnull.pos;\n\t\t\t}\n\n\t\t\tresj = 0.0;\n\t\t\twjm = -1.0;\n\t\t\tjm = 0;\n\t\t\tfor (j = 0; j < dimt; j++)\n\t\t\t{\n\t\t\t\tresj = resj + wpos(post[j]) / ((j + 1) * (j + 1));\n\t\t\t\tif (wpos(post[j]) > wjm)\n\t\t\t\t{\n\t\t\t\t\twjm = wpos(post[j]);\n\t\t\t\t\tjm = j;\n\t\t\t\t}\n\t\t\t}\n/*\n\t\t\tlimit (sum(i/i^2),i->inf) = pi^2/6\n\t\t\tresj = sum(wi/i^2),i=1,noccurence,\n\t\t\twi - should be sorted desc,\n\t\t\tdon't sort for now, just choose maximum weight. This should be corrected\n\t\t\tOleg Bartunov\n*/\n\t\t\tres = res + (wjm + resj - wjm / ((jm + 1) * (jm + 1))) / 1.64493406685;\n\n\t\t\tentry++;\n\t\t}\n\t}\n\tif (size > 0)\n\t\tres = res / size;\n\tpfree(item);\n\treturn res;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static float calc_rank_or(const float *w, TSVector t, TSQuery q);",
            "static float calc_rank_and(const float *w, TSVector t, TSQuery q);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"tsearch/ts_utils.h\"\n#include <math.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic float calc_rank_or(const float *w, TSVector t, TSQuery q);\nstatic float calc_rank_and(const float *w, TSVector t, TSQuery q);\n\nstatic float\ncalc_rank_or(const float *w, TSVector t, TSQuery q)\n{\n\tWordEntry  *entry,\n\t\t\t   *firstentry;\n\tWordEntryPosVector1 posnull;\n\tWordEntryPos *post;\n\tint32\t\tdimt,\n\t\t\t\tj,\n\t\t\t\ti,\n\t\t\t\tnitem;\n\tfloat\t\tres = 0.0;\n\tQueryOperand **item;\n\tint\t\t\tsize = q->size;\n\n\t/* A dummy WordEntryPos array to use when haspos is false */\n\tposnull.npos = 1;\n\tposnull.pos[0] = 0;\n\n\titem = SortAndUniqItems(q, &size);\n\n\tfor (i = 0; i < size; i++)\n\t{\n\t\tfloat\t\tresj,\n\t\t\t\t\twjm;\n\t\tint32\t\tjm;\n\n\t\tfirstentry = entry = find_wordentry(t, q, item[i], &nitem);\n\t\tif (!entry)\n\t\t\tcontinue;\n\n\t\twhile (entry - firstentry < nitem)\n\t\t{\n\t\t\tif (entry->haspos)\n\t\t\t{\n\t\t\t\tdimt = POSDATALEN(t, entry);\n\t\t\t\tpost = POSDATAPTR(t, entry);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdimt = posnull.npos;\n\t\t\t\tpost = posnull.pos;\n\t\t\t}\n\n\t\t\tresj = 0.0;\n\t\t\twjm = -1.0;\n\t\t\tjm = 0;\n\t\t\tfor (j = 0; j < dimt; j++)\n\t\t\t{\n\t\t\t\tresj = resj + wpos(post[j]) / ((j + 1) * (j + 1));\n\t\t\t\tif (wpos(post[j]) > wjm)\n\t\t\t\t{\n\t\t\t\t\twjm = wpos(post[j]);\n\t\t\t\t\tjm = j;\n\t\t\t\t}\n\t\t\t}\n/*\n\t\t\tlimit (sum(i/i^2),i->inf) = pi^2/6\n\t\t\tresj = sum(wi/i^2),i=1,noccurence,\n\t\t\twi - should be sorted desc,\n\t\t\tdon't sort for now, just choose maximum weight. This should be corrected\n\t\t\tOleg Bartunov\n*/\n\t\t\tres = res + (wjm + resj - wjm / ((jm + 1) * (jm + 1))) / 1.64493406685;\n\n\t\t\tentry++;\n\t\t}\n\t}\n\tif (size > 0)\n\t\tres = res / size;\n\tpfree(item);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "calc_rank_and",
          "args": [
            "w",
            "t",
            "q"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "calc_rank_and",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsrank.c",
          "lines": "200-281",
          "snippet": "static float\ncalc_rank_and(const float *w, TSVector t, TSQuery q)\n{\n\tWordEntryPosVector **pos;\n\tWordEntryPosVector1 posnull;\n\tWordEntryPosVector *POSNULL;\n\tint\t\t\ti,\n\t\t\t\tk,\n\t\t\t\tl,\n\t\t\t\tp;\n\tWordEntry  *entry,\n\t\t\t   *firstentry;\n\tWordEntryPos *post,\n\t\t\t   *ct;\n\tint32\t\tdimt,\n\t\t\t\tlenct,\n\t\t\t\tdist,\n\t\t\t\tnitem;\n\tfloat\t\tres = -1.0;\n\tQueryOperand **item;\n\tint\t\t\tsize = q->size;\n\n\titem = SortAndUniqItems(q, &size);\n\tif (size < 2)\n\t{\n\t\tpfree(item);\n\t\treturn calc_rank_or(w, t, q);\n\t}\n\tpos = (WordEntryPosVector **) palloc0(sizeof(WordEntryPosVector *) * q->size);\n\n\t/* A dummy WordEntryPos array to use when haspos is false */\n\tposnull.npos = 1;\n\tposnull.pos[0] = 0;\n\tWEP_SETPOS(posnull.pos[0], MAXENTRYPOS - 1);\n\tPOSNULL = (WordEntryPosVector *) &posnull;\n\n\tfor (i = 0; i < size; i++)\n\t{\n\t\tfirstentry = entry = find_wordentry(t, q, item[i], &nitem);\n\t\tif (!entry)\n\t\t\tcontinue;\n\n\t\twhile (entry - firstentry < nitem)\n\t\t{\n\t\t\tif (entry->haspos)\n\t\t\t\tpos[i] = _POSVECPTR(t, entry);\n\t\t\telse\n\t\t\t\tpos[i] = POSNULL;\n\n\t\t\tdimt = pos[i]->npos;\n\t\t\tpost = pos[i]->pos;\n\t\t\tfor (k = 0; k < i; k++)\n\t\t\t{\n\t\t\t\tif (!pos[k])\n\t\t\t\t\tcontinue;\n\t\t\t\tlenct = pos[k]->npos;\n\t\t\t\tct = pos[k]->pos;\n\t\t\t\tfor (l = 0; l < dimt; l++)\n\t\t\t\t{\n\t\t\t\t\tfor (p = 0; p < lenct; p++)\n\t\t\t\t\t{\n\t\t\t\t\t\tdist = Abs((int) WEP_GETPOS(post[l]) - (int) WEP_GETPOS(ct[p]));\n\t\t\t\t\t\tif (dist || (dist == 0 && (pos[i] == POSNULL || pos[k] == POSNULL)))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfloat\t\tcurw;\n\n\t\t\t\t\t\t\tif (!dist)\n\t\t\t\t\t\t\t\tdist = MAXENTRYPOS;\n\t\t\t\t\t\t\tcurw = sqrt(wpos(post[l]) * wpos(ct[p]) * word_distance(dist));\n\t\t\t\t\t\t\tres = (res < 0) ? curw : 1.0 - (1.0 - res) * (1.0 - curw);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tentry++;\n\t\t}\n\t}\n\tpfree(pos);\n\tpfree(item);\n\treturn res;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static float calc_rank_or(const float *w, TSVector t, TSQuery q);",
            "static float calc_rank_and(const float *w, TSVector t, TSQuery q);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"tsearch/ts_utils.h\"\n#include <math.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic float calc_rank_or(const float *w, TSVector t, TSQuery q);\nstatic float calc_rank_and(const float *w, TSVector t, TSQuery q);\n\nstatic float\ncalc_rank_and(const float *w, TSVector t, TSQuery q)\n{\n\tWordEntryPosVector **pos;\n\tWordEntryPosVector1 posnull;\n\tWordEntryPosVector *POSNULL;\n\tint\t\t\ti,\n\t\t\t\tk,\n\t\t\t\tl,\n\t\t\t\tp;\n\tWordEntry  *entry,\n\t\t\t   *firstentry;\n\tWordEntryPos *post,\n\t\t\t   *ct;\n\tint32\t\tdimt,\n\t\t\t\tlenct,\n\t\t\t\tdist,\n\t\t\t\tnitem;\n\tfloat\t\tres = -1.0;\n\tQueryOperand **item;\n\tint\t\t\tsize = q->size;\n\n\titem = SortAndUniqItems(q, &size);\n\tif (size < 2)\n\t{\n\t\tpfree(item);\n\t\treturn calc_rank_or(w, t, q);\n\t}\n\tpos = (WordEntryPosVector **) palloc0(sizeof(WordEntryPosVector *) * q->size);\n\n\t/* A dummy WordEntryPos array to use when haspos is false */\n\tposnull.npos = 1;\n\tposnull.pos[0] = 0;\n\tWEP_SETPOS(posnull.pos[0], MAXENTRYPOS - 1);\n\tPOSNULL = (WordEntryPosVector *) &posnull;\n\n\tfor (i = 0; i < size; i++)\n\t{\n\t\tfirstentry = entry = find_wordentry(t, q, item[i], &nitem);\n\t\tif (!entry)\n\t\t\tcontinue;\n\n\t\twhile (entry - firstentry < nitem)\n\t\t{\n\t\t\tif (entry->haspos)\n\t\t\t\tpos[i] = _POSVECPTR(t, entry);\n\t\t\telse\n\t\t\t\tpos[i] = POSNULL;\n\n\t\t\tdimt = pos[i]->npos;\n\t\t\tpost = pos[i]->pos;\n\t\t\tfor (k = 0; k < i; k++)\n\t\t\t{\n\t\t\t\tif (!pos[k])\n\t\t\t\t\tcontinue;\n\t\t\t\tlenct = pos[k]->npos;\n\t\t\t\tct = pos[k]->pos;\n\t\t\t\tfor (l = 0; l < dimt; l++)\n\t\t\t\t{\n\t\t\t\t\tfor (p = 0; p < lenct; p++)\n\t\t\t\t\t{\n\t\t\t\t\t\tdist = Abs((int) WEP_GETPOS(post[l]) - (int) WEP_GETPOS(ct[p]));\n\t\t\t\t\t\tif (dist || (dist == 0 && (pos[i] == POSNULL || pos[k] == POSNULL)))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfloat\t\tcurw;\n\n\t\t\t\t\t\t\tif (!dist)\n\t\t\t\t\t\t\t\tdist = MAXENTRYPOS;\n\t\t\t\t\t\t\tcurw = sqrt(wpos(post[l]) * wpos(ct[p]) * word_distance(dist));\n\t\t\t\t\t\t\tres = (res < 0) ? curw : 1.0 - (1.0 - res) * (1.0 - curw);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tentry++;\n\t\t}\n\t}\n\tpfree(pos);\n\tpfree(item);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GETQUERY",
          "args": [
            "q"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"tsearch/ts_utils.h\"\n#include <math.h>\n#include <limits.h>\n#include \"postgres.h\"\n\n#define RANK_NORM_RDIVRPLUS1\t0x20\n#define RANK_NORM_LOGUNIQ\t\t0x10\n#define RANK_NORM_UNIQ\t\t\t0x08\n#define RANK_NORM_EXTDIST\t\t0x04\n#define RANK_NORM_LENGTH\t\t0x02\n#define RANK_NORM_LOGLENGTH\t\t0x01\n\nstatic float calc_rank_or(const float *w, TSVector t, TSQuery q);\nstatic float calc_rank_and(const float *w, TSVector t, TSQuery q);\n\nstatic float\ncalc_rank(const float *w, TSVector t, TSQuery q, int32 method)\n{\n\tQueryItem  *item = GETQUERY(q);\n\tfloat\t\tres = 0.0;\n\tint\t\t\tlen;\n\n\tif (!t->size || !q->size)\n\t\treturn 0.0;\n\n\t/* XXX: What about NOT? */\n\tres = (item->type == QI_OPR && (item->qoperator.oper == OP_AND ||\n\t\t\t\t\t\t\t\t\titem->qoperator.oper == OP_PHRASE)) ?\n\t\tcalc_rank_and(w, t, q) :\n\t\tcalc_rank_or(w, t, q);\n\n\tif (res < 0)\n\t\tres = 1e-20f;\n\n\tif ((method & RANK_NORM_LOGLENGTH) && t->size > 0)\n\t\tres /= log((double) (cnt_length(t) + 1)) / log(2.0);\n\n\tif (method & RANK_NORM_LENGTH)\n\t{\n\t\tlen = cnt_length(t);\n\t\tif (len > 0)\n\t\t\tres /= (float) len;\n\t}\n\n\t/* RANK_NORM_EXTDIST not applicable */\n\n\tif ((method & RANK_NORM_UNIQ) && t->size > 0)\n\t\tres /= (float) (t->size);\n\n\tif ((method & RANK_NORM_LOGUNIQ) && t->size > 0)\n\t\tres /= log((double) (t->size + 1)) / log(2.0);\n\n\tif (method & RANK_NORM_RDIVRPLUS1)\n\t\tres /= (res + 1);\n\n\treturn res;\n}"
  },
  {
    "function_name": "calc_rank_or",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsrank.c",
    "lines": "283-355",
    "snippet": "static float\ncalc_rank_or(const float *w, TSVector t, TSQuery q)\n{\n\tWordEntry  *entry,\n\t\t\t   *firstentry;\n\tWordEntryPosVector1 posnull;\n\tWordEntryPos *post;\n\tint32\t\tdimt,\n\t\t\t\tj,\n\t\t\t\ti,\n\t\t\t\tnitem;\n\tfloat\t\tres = 0.0;\n\tQueryOperand **item;\n\tint\t\t\tsize = q->size;\n\n\t/* A dummy WordEntryPos array to use when haspos is false */\n\tposnull.npos = 1;\n\tposnull.pos[0] = 0;\n\n\titem = SortAndUniqItems(q, &size);\n\n\tfor (i = 0; i < size; i++)\n\t{\n\t\tfloat\t\tresj,\n\t\t\t\t\twjm;\n\t\tint32\t\tjm;\n\n\t\tfirstentry = entry = find_wordentry(t, q, item[i], &nitem);\n\t\tif (!entry)\n\t\t\tcontinue;\n\n\t\twhile (entry - firstentry < nitem)\n\t\t{\n\t\t\tif (entry->haspos)\n\t\t\t{\n\t\t\t\tdimt = POSDATALEN(t, entry);\n\t\t\t\tpost = POSDATAPTR(t, entry);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdimt = posnull.npos;\n\t\t\t\tpost = posnull.pos;\n\t\t\t}\n\n\t\t\tresj = 0.0;\n\t\t\twjm = -1.0;\n\t\t\tjm = 0;\n\t\t\tfor (j = 0; j < dimt; j++)\n\t\t\t{\n\t\t\t\tresj = resj + wpos(post[j]) / ((j + 1) * (j + 1));\n\t\t\t\tif (wpos(post[j]) > wjm)\n\t\t\t\t{\n\t\t\t\t\twjm = wpos(post[j]);\n\t\t\t\t\tjm = j;\n\t\t\t\t}\n\t\t\t}\n/*\n\t\t\tlimit (sum(i/i^2),i->inf) = pi^2/6\n\t\t\tresj = sum(wi/i^2),i=1,noccurence,\n\t\t\twi - should be sorted desc,\n\t\t\tdon't sort for now, just choose maximum weight. This should be corrected\n\t\t\tOleg Bartunov\n*/\n\t\t\tres = res + (wjm + resj - wjm / ((jm + 1) * (jm + 1))) / 1.64493406685;\n\n\t\t\tentry++;\n\t\t}\n\t}\n\tif (size > 0)\n\t\tres = res / size;\n\tpfree(item);\n\treturn res;\n}",
    "includes": [
      "#include \"miscadmin.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static float calc_rank_or(const float *w, TSVector t, TSQuery q);",
      "static float calc_rank_and(const float *w, TSVector t, TSQuery q);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "item"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wpos",
          "args": [
            "post[j]"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wpos",
          "args": [
            "post[j]"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wpos",
          "args": [
            "post[j]"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "POSDATAPTR",
          "args": [
            "t",
            "entry"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "POSDATALEN",
          "args": [
            "t",
            "entry"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_wordentry",
          "args": [
            "t",
            "q",
            "item[i]",
            "&nitem"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "find_wordentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsrank.c",
          "lines": "86-129",
          "snippet": "static WordEntry *\nfind_wordentry(TSVector t, TSQuery q, QueryOperand *item, int32 *nitem)\n{\n\tWordEntry  *StopLow = ARRPTR(t);\n\tWordEntry  *StopHigh = (WordEntry *) STRPTR(t);\n\tWordEntry  *StopMiddle = StopHigh;\n\tint\t\t\tdifference;\n\n\t*nitem = 0;\n\n\t/* Loop invariant: StopLow <= item < StopHigh */\n\twhile (StopLow < StopHigh)\n\t{\n\t\tStopMiddle = StopLow + (StopHigh - StopLow) / 2;\n\t\tdifference = WordECompareQueryItem(STRPTR(t), GETOPERAND(q), StopMiddle, item, false);\n\t\tif (difference == 0)\n\t\t{\n\t\t\tStopHigh = StopMiddle;\n\t\t\t*nitem = 1;\n\t\t\tbreak;\n\t\t}\n\t\telse if (difference > 0)\n\t\t\tStopLow = StopMiddle + 1;\n\t\telse\n\t\t\tStopHigh = StopMiddle;\n\t}\n\n\tif (item->prefix)\n\t{\n\t\tif (StopLow >= StopHigh)\n\t\t\tStopMiddle = StopHigh;\n\n\t\t*nitem = 0;\n\n\t\twhile (StopMiddle < (WordEntry *) STRPTR(t) &&\n\t\t\t   WordECompareQueryItem(STRPTR(t), GETOPERAND(q), StopMiddle, item, true) == 0)\n\t\t{\n\t\t\t(*nitem)++;\n\t\t\tStopMiddle++;\n\t\t}\n\t}\n\n\treturn (*nitem > 0) ? StopHigh : NULL;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static float calc_rank_or(const float *w, TSVector t, TSQuery q);",
            "static float calc_rank_and(const float *w, TSVector t, TSQuery q);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"tsearch/ts_utils.h\"\n#include <math.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic float calc_rank_or(const float *w, TSVector t, TSQuery q);\nstatic float calc_rank_and(const float *w, TSVector t, TSQuery q);\n\nstatic WordEntry *\nfind_wordentry(TSVector t, TSQuery q, QueryOperand *item, int32 *nitem)\n{\n\tWordEntry  *StopLow = ARRPTR(t);\n\tWordEntry  *StopHigh = (WordEntry *) STRPTR(t);\n\tWordEntry  *StopMiddle = StopHigh;\n\tint\t\t\tdifference;\n\n\t*nitem = 0;\n\n\t/* Loop invariant: StopLow <= item < StopHigh */\n\twhile (StopLow < StopHigh)\n\t{\n\t\tStopMiddle = StopLow + (StopHigh - StopLow) / 2;\n\t\tdifference = WordECompareQueryItem(STRPTR(t), GETOPERAND(q), StopMiddle, item, false);\n\t\tif (difference == 0)\n\t\t{\n\t\t\tStopHigh = StopMiddle;\n\t\t\t*nitem = 1;\n\t\t\tbreak;\n\t\t}\n\t\telse if (difference > 0)\n\t\t\tStopLow = StopMiddle + 1;\n\t\telse\n\t\t\tStopHigh = StopMiddle;\n\t}\n\n\tif (item->prefix)\n\t{\n\t\tif (StopLow >= StopHigh)\n\t\t\tStopMiddle = StopHigh;\n\n\t\t*nitem = 0;\n\n\t\twhile (StopMiddle < (WordEntry *) STRPTR(t) &&\n\t\t\t   WordECompareQueryItem(STRPTR(t), GETOPERAND(q), StopMiddle, item, true) == 0)\n\t\t{\n\t\t\t(*nitem)++;\n\t\t\tStopMiddle++;\n\t\t}\n\t}\n\n\treturn (*nitem > 0) ? StopHigh : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SortAndUniqItems",
          "args": [
            "q",
            "&size"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "SortAndUniqItems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsrank.c",
          "lines": "154-198",
          "snippet": "static QueryOperand **\nSortAndUniqItems(TSQuery q, int *size)\n{\n\tchar\t   *operand = GETOPERAND(q);\n\tQueryItem  *item = GETQUERY(q);\n\tQueryOperand **res,\n\t\t\t  **ptr,\n\t\t\t  **prevptr;\n\n\tptr = res = (QueryOperand **) palloc(sizeof(QueryOperand *) * *size);\n\n\t/* Collect all operands from the tree to res */\n\twhile ((*size)--)\n\t{\n\t\tif (item->type == QI_VAL)\n\t\t{\n\t\t\t*ptr = (QueryOperand *) item;\n\t\t\tptr++;\n\t\t}\n\t\titem++;\n\t}\n\n\t*size = ptr - res;\n\tif (*size < 2)\n\t\treturn res;\n\n\tqsort_arg(res, *size, sizeof(QueryOperand *), compareQueryOperand, (void *) operand);\n\n\tptr = res + 1;\n\tprevptr = res;\n\n\t/* remove duplicates */\n\twhile (ptr - res < *size)\n\t{\n\t\tif (compareQueryOperand((void *) ptr, (void *) prevptr, (void *) operand) != 0)\n\t\t{\n\t\t\tprevptr++;\n\t\t\t*prevptr = *ptr;\n\t\t}\n\t\tptr++;\n\t}\n\n\t*size = prevptr + 1 - res;\n\treturn res;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static float calc_rank_or(const float *w, TSVector t, TSQuery q);",
            "static float calc_rank_and(const float *w, TSVector t, TSQuery q);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"tsearch/ts_utils.h\"\n#include <math.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic float calc_rank_or(const float *w, TSVector t, TSQuery q);\nstatic float calc_rank_and(const float *w, TSVector t, TSQuery q);\n\nstatic QueryOperand **\nSortAndUniqItems(TSQuery q, int *size)\n{\n\tchar\t   *operand = GETOPERAND(q);\n\tQueryItem  *item = GETQUERY(q);\n\tQueryOperand **res,\n\t\t\t  **ptr,\n\t\t\t  **prevptr;\n\n\tptr = res = (QueryOperand **) palloc(sizeof(QueryOperand *) * *size);\n\n\t/* Collect all operands from the tree to res */\n\twhile ((*size)--)\n\t{\n\t\tif (item->type == QI_VAL)\n\t\t{\n\t\t\t*ptr = (QueryOperand *) item;\n\t\t\tptr++;\n\t\t}\n\t\titem++;\n\t}\n\n\t*size = ptr - res;\n\tif (*size < 2)\n\t\treturn res;\n\n\tqsort_arg(res, *size, sizeof(QueryOperand *), compareQueryOperand, (void *) operand);\n\n\tptr = res + 1;\n\tprevptr = res;\n\n\t/* remove duplicates */\n\twhile (ptr - res < *size)\n\t{\n\t\tif (compareQueryOperand((void *) ptr, (void *) prevptr, (void *) operand) != 0)\n\t\t{\n\t\t\tprevptr++;\n\t\t\t*prevptr = *ptr;\n\t\t}\n\t\tptr++;\n\t}\n\n\t*size = prevptr + 1 - res;\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"tsearch/ts_utils.h\"\n#include <math.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic float calc_rank_or(const float *w, TSVector t, TSQuery q);\nstatic float calc_rank_and(const float *w, TSVector t, TSQuery q);\n\nstatic float\ncalc_rank_or(const float *w, TSVector t, TSQuery q)\n{\n\tWordEntry  *entry,\n\t\t\t   *firstentry;\n\tWordEntryPosVector1 posnull;\n\tWordEntryPos *post;\n\tint32\t\tdimt,\n\t\t\t\tj,\n\t\t\t\ti,\n\t\t\t\tnitem;\n\tfloat\t\tres = 0.0;\n\tQueryOperand **item;\n\tint\t\t\tsize = q->size;\n\n\t/* A dummy WordEntryPos array to use when haspos is false */\n\tposnull.npos = 1;\n\tposnull.pos[0] = 0;\n\n\titem = SortAndUniqItems(q, &size);\n\n\tfor (i = 0; i < size; i++)\n\t{\n\t\tfloat\t\tresj,\n\t\t\t\t\twjm;\n\t\tint32\t\tjm;\n\n\t\tfirstentry = entry = find_wordentry(t, q, item[i], &nitem);\n\t\tif (!entry)\n\t\t\tcontinue;\n\n\t\twhile (entry - firstentry < nitem)\n\t\t{\n\t\t\tif (entry->haspos)\n\t\t\t{\n\t\t\t\tdimt = POSDATALEN(t, entry);\n\t\t\t\tpost = POSDATAPTR(t, entry);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdimt = posnull.npos;\n\t\t\t\tpost = posnull.pos;\n\t\t\t}\n\n\t\t\tresj = 0.0;\n\t\t\twjm = -1.0;\n\t\t\tjm = 0;\n\t\t\tfor (j = 0; j < dimt; j++)\n\t\t\t{\n\t\t\t\tresj = resj + wpos(post[j]) / ((j + 1) * (j + 1));\n\t\t\t\tif (wpos(post[j]) > wjm)\n\t\t\t\t{\n\t\t\t\t\twjm = wpos(post[j]);\n\t\t\t\t\tjm = j;\n\t\t\t\t}\n\t\t\t}\n/*\n\t\t\tlimit (sum(i/i^2),i->inf) = pi^2/6\n\t\t\tresj = sum(wi/i^2),i=1,noccurence,\n\t\t\twi - should be sorted desc,\n\t\t\tdon't sort for now, just choose maximum weight. This should be corrected\n\t\t\tOleg Bartunov\n*/\n\t\t\tres = res + (wjm + resj - wjm / ((jm + 1) * (jm + 1))) / 1.64493406685;\n\n\t\t\tentry++;\n\t\t}\n\t}\n\tif (size > 0)\n\t\tres = res / size;\n\tpfree(item);\n\treturn res;\n}"
  },
  {
    "function_name": "calc_rank_and",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsrank.c",
    "lines": "200-281",
    "snippet": "static float\ncalc_rank_and(const float *w, TSVector t, TSQuery q)\n{\n\tWordEntryPosVector **pos;\n\tWordEntryPosVector1 posnull;\n\tWordEntryPosVector *POSNULL;\n\tint\t\t\ti,\n\t\t\t\tk,\n\t\t\t\tl,\n\t\t\t\tp;\n\tWordEntry  *entry,\n\t\t\t   *firstentry;\n\tWordEntryPos *post,\n\t\t\t   *ct;\n\tint32\t\tdimt,\n\t\t\t\tlenct,\n\t\t\t\tdist,\n\t\t\t\tnitem;\n\tfloat\t\tres = -1.0;\n\tQueryOperand **item;\n\tint\t\t\tsize = q->size;\n\n\titem = SortAndUniqItems(q, &size);\n\tif (size < 2)\n\t{\n\t\tpfree(item);\n\t\treturn calc_rank_or(w, t, q);\n\t}\n\tpos = (WordEntryPosVector **) palloc0(sizeof(WordEntryPosVector *) * q->size);\n\n\t/* A dummy WordEntryPos array to use when haspos is false */\n\tposnull.npos = 1;\n\tposnull.pos[0] = 0;\n\tWEP_SETPOS(posnull.pos[0], MAXENTRYPOS - 1);\n\tPOSNULL = (WordEntryPosVector *) &posnull;\n\n\tfor (i = 0; i < size; i++)\n\t{\n\t\tfirstentry = entry = find_wordentry(t, q, item[i], &nitem);\n\t\tif (!entry)\n\t\t\tcontinue;\n\n\t\twhile (entry - firstentry < nitem)\n\t\t{\n\t\t\tif (entry->haspos)\n\t\t\t\tpos[i] = _POSVECPTR(t, entry);\n\t\t\telse\n\t\t\t\tpos[i] = POSNULL;\n\n\t\t\tdimt = pos[i]->npos;\n\t\t\tpost = pos[i]->pos;\n\t\t\tfor (k = 0; k < i; k++)\n\t\t\t{\n\t\t\t\tif (!pos[k])\n\t\t\t\t\tcontinue;\n\t\t\t\tlenct = pos[k]->npos;\n\t\t\t\tct = pos[k]->pos;\n\t\t\t\tfor (l = 0; l < dimt; l++)\n\t\t\t\t{\n\t\t\t\t\tfor (p = 0; p < lenct; p++)\n\t\t\t\t\t{\n\t\t\t\t\t\tdist = Abs((int) WEP_GETPOS(post[l]) - (int) WEP_GETPOS(ct[p]));\n\t\t\t\t\t\tif (dist || (dist == 0 && (pos[i] == POSNULL || pos[k] == POSNULL)))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfloat\t\tcurw;\n\n\t\t\t\t\t\t\tif (!dist)\n\t\t\t\t\t\t\t\tdist = MAXENTRYPOS;\n\t\t\t\t\t\t\tcurw = sqrt(wpos(post[l]) * wpos(ct[p]) * word_distance(dist));\n\t\t\t\t\t\t\tres = (res < 0) ? curw : 1.0 - (1.0 - res) * (1.0 - curw);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tentry++;\n\t\t}\n\t}\n\tpfree(pos);\n\tpfree(item);\n\treturn res;\n}",
    "includes": [
      "#include \"miscadmin.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static float calc_rank_or(const float *w, TSVector t, TSQuery q);",
      "static float calc_rank_and(const float *w, TSVector t, TSQuery q);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "item"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sqrt",
          "args": [
            "wpos(post[l]) * wpos(ct[p]) * word_distance(dist)"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "dsqrt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "1613-1628",
          "snippet": "Datum\ndsqrt(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\tif (arg1 < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_ARGUMENT_FOR_POWER_FUNCTION),\n\t\t\t\t errmsg(\"cannot take square root of a negative number\")));\n\n\tresult = sqrt(arg1);\n\n\tCHECKFLOATVAL(result, isinf(arg1), arg1 == 0);\n\tPG_RETURN_FLOAT8(result);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndsqrt(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tresult;\n\n\tif (arg1 < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_ARGUMENT_FOR_POWER_FUNCTION),\n\t\t\t\t errmsg(\"cannot take square root of a negative number\")));\n\n\tresult = sqrt(arg1);\n\n\tCHECKFLOATVAL(result, isinf(arg1), arg1 == 0);\n\tPG_RETURN_FLOAT8(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "word_distance",
          "args": [
            "dist"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "word_distance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsrank.c",
          "lines": "44-51",
          "snippet": "static float4\nword_distance(int32 w)\n{\n\tif (w > 100)\n\t\treturn 1e-30f;\n\n\treturn 1.0 / (1.005 + 0.05 * exp(((float4) w) / 1.5 - 2));\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"tsearch/ts_utils.h\"\n#include <math.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic float4\nword_distance(int32 w)\n{\n\tif (w > 100)\n\t\treturn 1e-30f;\n\n\treturn 1.0 / (1.005 + 0.05 * exp(((float4) w) / 1.5 - 2));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wpos",
          "args": [
            "ct[p]"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wpos",
          "args": [
            "post[l]"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Abs",
          "args": [
            "(int) WEP_GETPOS(post[l]) - (int) WEP_GETPOS(ct[p])"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEP_GETPOS",
          "args": [
            "ct[p]"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEP_GETPOS",
          "args": [
            "post[l]"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_POSVECPTR",
          "args": [
            "t",
            "entry"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_wordentry",
          "args": [
            "t",
            "q",
            "item[i]",
            "&nitem"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "find_wordentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsrank.c",
          "lines": "86-129",
          "snippet": "static WordEntry *\nfind_wordentry(TSVector t, TSQuery q, QueryOperand *item, int32 *nitem)\n{\n\tWordEntry  *StopLow = ARRPTR(t);\n\tWordEntry  *StopHigh = (WordEntry *) STRPTR(t);\n\tWordEntry  *StopMiddle = StopHigh;\n\tint\t\t\tdifference;\n\n\t*nitem = 0;\n\n\t/* Loop invariant: StopLow <= item < StopHigh */\n\twhile (StopLow < StopHigh)\n\t{\n\t\tStopMiddle = StopLow + (StopHigh - StopLow) / 2;\n\t\tdifference = WordECompareQueryItem(STRPTR(t), GETOPERAND(q), StopMiddle, item, false);\n\t\tif (difference == 0)\n\t\t{\n\t\t\tStopHigh = StopMiddle;\n\t\t\t*nitem = 1;\n\t\t\tbreak;\n\t\t}\n\t\telse if (difference > 0)\n\t\t\tStopLow = StopMiddle + 1;\n\t\telse\n\t\t\tStopHigh = StopMiddle;\n\t}\n\n\tif (item->prefix)\n\t{\n\t\tif (StopLow >= StopHigh)\n\t\t\tStopMiddle = StopHigh;\n\n\t\t*nitem = 0;\n\n\t\twhile (StopMiddle < (WordEntry *) STRPTR(t) &&\n\t\t\t   WordECompareQueryItem(STRPTR(t), GETOPERAND(q), StopMiddle, item, true) == 0)\n\t\t{\n\t\t\t(*nitem)++;\n\t\t\tStopMiddle++;\n\t\t}\n\t}\n\n\treturn (*nitem > 0) ? StopHigh : NULL;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static float calc_rank_or(const float *w, TSVector t, TSQuery q);",
            "static float calc_rank_and(const float *w, TSVector t, TSQuery q);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"tsearch/ts_utils.h\"\n#include <math.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic float calc_rank_or(const float *w, TSVector t, TSQuery q);\nstatic float calc_rank_and(const float *w, TSVector t, TSQuery q);\n\nstatic WordEntry *\nfind_wordentry(TSVector t, TSQuery q, QueryOperand *item, int32 *nitem)\n{\n\tWordEntry  *StopLow = ARRPTR(t);\n\tWordEntry  *StopHigh = (WordEntry *) STRPTR(t);\n\tWordEntry  *StopMiddle = StopHigh;\n\tint\t\t\tdifference;\n\n\t*nitem = 0;\n\n\t/* Loop invariant: StopLow <= item < StopHigh */\n\twhile (StopLow < StopHigh)\n\t{\n\t\tStopMiddle = StopLow + (StopHigh - StopLow) / 2;\n\t\tdifference = WordECompareQueryItem(STRPTR(t), GETOPERAND(q), StopMiddle, item, false);\n\t\tif (difference == 0)\n\t\t{\n\t\t\tStopHigh = StopMiddle;\n\t\t\t*nitem = 1;\n\t\t\tbreak;\n\t\t}\n\t\telse if (difference > 0)\n\t\t\tStopLow = StopMiddle + 1;\n\t\telse\n\t\t\tStopHigh = StopMiddle;\n\t}\n\n\tif (item->prefix)\n\t{\n\t\tif (StopLow >= StopHigh)\n\t\t\tStopMiddle = StopHigh;\n\n\t\t*nitem = 0;\n\n\t\twhile (StopMiddle < (WordEntry *) STRPTR(t) &&\n\t\t\t   WordECompareQueryItem(STRPTR(t), GETOPERAND(q), StopMiddle, item, true) == 0)\n\t\t{\n\t\t\t(*nitem)++;\n\t\t\tStopMiddle++;\n\t\t}\n\t}\n\n\treturn (*nitem > 0) ? StopHigh : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WEP_SETPOS",
          "args": [
            "posnull.pos[0]",
            "MAXENTRYPOS - 1"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "sizeof(WordEntryPosVector *) * q->size"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "calc_rank_or",
          "args": [
            "w",
            "t",
            "q"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "calc_rank_or",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsrank.c",
          "lines": "283-355",
          "snippet": "static float\ncalc_rank_or(const float *w, TSVector t, TSQuery q)\n{\n\tWordEntry  *entry,\n\t\t\t   *firstentry;\n\tWordEntryPosVector1 posnull;\n\tWordEntryPos *post;\n\tint32\t\tdimt,\n\t\t\t\tj,\n\t\t\t\ti,\n\t\t\t\tnitem;\n\tfloat\t\tres = 0.0;\n\tQueryOperand **item;\n\tint\t\t\tsize = q->size;\n\n\t/* A dummy WordEntryPos array to use when haspos is false */\n\tposnull.npos = 1;\n\tposnull.pos[0] = 0;\n\n\titem = SortAndUniqItems(q, &size);\n\n\tfor (i = 0; i < size; i++)\n\t{\n\t\tfloat\t\tresj,\n\t\t\t\t\twjm;\n\t\tint32\t\tjm;\n\n\t\tfirstentry = entry = find_wordentry(t, q, item[i], &nitem);\n\t\tif (!entry)\n\t\t\tcontinue;\n\n\t\twhile (entry - firstentry < nitem)\n\t\t{\n\t\t\tif (entry->haspos)\n\t\t\t{\n\t\t\t\tdimt = POSDATALEN(t, entry);\n\t\t\t\tpost = POSDATAPTR(t, entry);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdimt = posnull.npos;\n\t\t\t\tpost = posnull.pos;\n\t\t\t}\n\n\t\t\tresj = 0.0;\n\t\t\twjm = -1.0;\n\t\t\tjm = 0;\n\t\t\tfor (j = 0; j < dimt; j++)\n\t\t\t{\n\t\t\t\tresj = resj + wpos(post[j]) / ((j + 1) * (j + 1));\n\t\t\t\tif (wpos(post[j]) > wjm)\n\t\t\t\t{\n\t\t\t\t\twjm = wpos(post[j]);\n\t\t\t\t\tjm = j;\n\t\t\t\t}\n\t\t\t}\n/*\n\t\t\tlimit (sum(i/i^2),i->inf) = pi^2/6\n\t\t\tresj = sum(wi/i^2),i=1,noccurence,\n\t\t\twi - should be sorted desc,\n\t\t\tdon't sort for now, just choose maximum weight. This should be corrected\n\t\t\tOleg Bartunov\n*/\n\t\t\tres = res + (wjm + resj - wjm / ((jm + 1) * (jm + 1))) / 1.64493406685;\n\n\t\t\tentry++;\n\t\t}\n\t}\n\tif (size > 0)\n\t\tres = res / size;\n\tpfree(item);\n\treturn res;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static float calc_rank_or(const float *w, TSVector t, TSQuery q);",
            "static float calc_rank_and(const float *w, TSVector t, TSQuery q);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"tsearch/ts_utils.h\"\n#include <math.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic float calc_rank_or(const float *w, TSVector t, TSQuery q);\nstatic float calc_rank_and(const float *w, TSVector t, TSQuery q);\n\nstatic float\ncalc_rank_or(const float *w, TSVector t, TSQuery q)\n{\n\tWordEntry  *entry,\n\t\t\t   *firstentry;\n\tWordEntryPosVector1 posnull;\n\tWordEntryPos *post;\n\tint32\t\tdimt,\n\t\t\t\tj,\n\t\t\t\ti,\n\t\t\t\tnitem;\n\tfloat\t\tres = 0.0;\n\tQueryOperand **item;\n\tint\t\t\tsize = q->size;\n\n\t/* A dummy WordEntryPos array to use when haspos is false */\n\tposnull.npos = 1;\n\tposnull.pos[0] = 0;\n\n\titem = SortAndUniqItems(q, &size);\n\n\tfor (i = 0; i < size; i++)\n\t{\n\t\tfloat\t\tresj,\n\t\t\t\t\twjm;\n\t\tint32\t\tjm;\n\n\t\tfirstentry = entry = find_wordentry(t, q, item[i], &nitem);\n\t\tif (!entry)\n\t\t\tcontinue;\n\n\t\twhile (entry - firstentry < nitem)\n\t\t{\n\t\t\tif (entry->haspos)\n\t\t\t{\n\t\t\t\tdimt = POSDATALEN(t, entry);\n\t\t\t\tpost = POSDATAPTR(t, entry);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdimt = posnull.npos;\n\t\t\t\tpost = posnull.pos;\n\t\t\t}\n\n\t\t\tresj = 0.0;\n\t\t\twjm = -1.0;\n\t\t\tjm = 0;\n\t\t\tfor (j = 0; j < dimt; j++)\n\t\t\t{\n\t\t\t\tresj = resj + wpos(post[j]) / ((j + 1) * (j + 1));\n\t\t\t\tif (wpos(post[j]) > wjm)\n\t\t\t\t{\n\t\t\t\t\twjm = wpos(post[j]);\n\t\t\t\t\tjm = j;\n\t\t\t\t}\n\t\t\t}\n/*\n\t\t\tlimit (sum(i/i^2),i->inf) = pi^2/6\n\t\t\tresj = sum(wi/i^2),i=1,noccurence,\n\t\t\twi - should be sorted desc,\n\t\t\tdon't sort for now, just choose maximum weight. This should be corrected\n\t\t\tOleg Bartunov\n*/\n\t\t\tres = res + (wjm + resj - wjm / ((jm + 1) * (jm + 1))) / 1.64493406685;\n\n\t\t\tentry++;\n\t\t}\n\t}\n\tif (size > 0)\n\t\tres = res / size;\n\tpfree(item);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SortAndUniqItems",
          "args": [
            "q",
            "&size"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "SortAndUniqItems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsrank.c",
          "lines": "154-198",
          "snippet": "static QueryOperand **\nSortAndUniqItems(TSQuery q, int *size)\n{\n\tchar\t   *operand = GETOPERAND(q);\n\tQueryItem  *item = GETQUERY(q);\n\tQueryOperand **res,\n\t\t\t  **ptr,\n\t\t\t  **prevptr;\n\n\tptr = res = (QueryOperand **) palloc(sizeof(QueryOperand *) * *size);\n\n\t/* Collect all operands from the tree to res */\n\twhile ((*size)--)\n\t{\n\t\tif (item->type == QI_VAL)\n\t\t{\n\t\t\t*ptr = (QueryOperand *) item;\n\t\t\tptr++;\n\t\t}\n\t\titem++;\n\t}\n\n\t*size = ptr - res;\n\tif (*size < 2)\n\t\treturn res;\n\n\tqsort_arg(res, *size, sizeof(QueryOperand *), compareQueryOperand, (void *) operand);\n\n\tptr = res + 1;\n\tprevptr = res;\n\n\t/* remove duplicates */\n\twhile (ptr - res < *size)\n\t{\n\t\tif (compareQueryOperand((void *) ptr, (void *) prevptr, (void *) operand) != 0)\n\t\t{\n\t\t\tprevptr++;\n\t\t\t*prevptr = *ptr;\n\t\t}\n\t\tptr++;\n\t}\n\n\t*size = prevptr + 1 - res;\n\treturn res;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static float calc_rank_or(const float *w, TSVector t, TSQuery q);",
            "static float calc_rank_and(const float *w, TSVector t, TSQuery q);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"tsearch/ts_utils.h\"\n#include <math.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic float calc_rank_or(const float *w, TSVector t, TSQuery q);\nstatic float calc_rank_and(const float *w, TSVector t, TSQuery q);\n\nstatic QueryOperand **\nSortAndUniqItems(TSQuery q, int *size)\n{\n\tchar\t   *operand = GETOPERAND(q);\n\tQueryItem  *item = GETQUERY(q);\n\tQueryOperand **res,\n\t\t\t  **ptr,\n\t\t\t  **prevptr;\n\n\tptr = res = (QueryOperand **) palloc(sizeof(QueryOperand *) * *size);\n\n\t/* Collect all operands from the tree to res */\n\twhile ((*size)--)\n\t{\n\t\tif (item->type == QI_VAL)\n\t\t{\n\t\t\t*ptr = (QueryOperand *) item;\n\t\t\tptr++;\n\t\t}\n\t\titem++;\n\t}\n\n\t*size = ptr - res;\n\tif (*size < 2)\n\t\treturn res;\n\n\tqsort_arg(res, *size, sizeof(QueryOperand *), compareQueryOperand, (void *) operand);\n\n\tptr = res + 1;\n\tprevptr = res;\n\n\t/* remove duplicates */\n\twhile (ptr - res < *size)\n\t{\n\t\tif (compareQueryOperand((void *) ptr, (void *) prevptr, (void *) operand) != 0)\n\t\t{\n\t\t\tprevptr++;\n\t\t\t*prevptr = *ptr;\n\t\t}\n\t\tptr++;\n\t}\n\n\t*size = prevptr + 1 - res;\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"tsearch/ts_utils.h\"\n#include <math.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic float calc_rank_or(const float *w, TSVector t, TSQuery q);\nstatic float calc_rank_and(const float *w, TSVector t, TSQuery q);\n\nstatic float\ncalc_rank_and(const float *w, TSVector t, TSQuery q)\n{\n\tWordEntryPosVector **pos;\n\tWordEntryPosVector1 posnull;\n\tWordEntryPosVector *POSNULL;\n\tint\t\t\ti,\n\t\t\t\tk,\n\t\t\t\tl,\n\t\t\t\tp;\n\tWordEntry  *entry,\n\t\t\t   *firstentry;\n\tWordEntryPos *post,\n\t\t\t   *ct;\n\tint32\t\tdimt,\n\t\t\t\tlenct,\n\t\t\t\tdist,\n\t\t\t\tnitem;\n\tfloat\t\tres = -1.0;\n\tQueryOperand **item;\n\tint\t\t\tsize = q->size;\n\n\titem = SortAndUniqItems(q, &size);\n\tif (size < 2)\n\t{\n\t\tpfree(item);\n\t\treturn calc_rank_or(w, t, q);\n\t}\n\tpos = (WordEntryPosVector **) palloc0(sizeof(WordEntryPosVector *) * q->size);\n\n\t/* A dummy WordEntryPos array to use when haspos is false */\n\tposnull.npos = 1;\n\tposnull.pos[0] = 0;\n\tWEP_SETPOS(posnull.pos[0], MAXENTRYPOS - 1);\n\tPOSNULL = (WordEntryPosVector *) &posnull;\n\n\tfor (i = 0; i < size; i++)\n\t{\n\t\tfirstentry = entry = find_wordentry(t, q, item[i], &nitem);\n\t\tif (!entry)\n\t\t\tcontinue;\n\n\t\twhile (entry - firstentry < nitem)\n\t\t{\n\t\t\tif (entry->haspos)\n\t\t\t\tpos[i] = _POSVECPTR(t, entry);\n\t\t\telse\n\t\t\t\tpos[i] = POSNULL;\n\n\t\t\tdimt = pos[i]->npos;\n\t\t\tpost = pos[i]->pos;\n\t\t\tfor (k = 0; k < i; k++)\n\t\t\t{\n\t\t\t\tif (!pos[k])\n\t\t\t\t\tcontinue;\n\t\t\t\tlenct = pos[k]->npos;\n\t\t\t\tct = pos[k]->pos;\n\t\t\t\tfor (l = 0; l < dimt; l++)\n\t\t\t\t{\n\t\t\t\t\tfor (p = 0; p < lenct; p++)\n\t\t\t\t\t{\n\t\t\t\t\t\tdist = Abs((int) WEP_GETPOS(post[l]) - (int) WEP_GETPOS(ct[p]));\n\t\t\t\t\t\tif (dist || (dist == 0 && (pos[i] == POSNULL || pos[k] == POSNULL)))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfloat\t\tcurw;\n\n\t\t\t\t\t\t\tif (!dist)\n\t\t\t\t\t\t\t\tdist = MAXENTRYPOS;\n\t\t\t\t\t\t\tcurw = sqrt(wpos(post[l]) * wpos(ct[p]) * word_distance(dist));\n\t\t\t\t\t\t\tres = (res < 0) ? curw : 1.0 - (1.0 - res) * (1.0 - curw);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tentry++;\n\t\t}\n\t}\n\tpfree(pos);\n\tpfree(item);\n\treturn res;\n}"
  },
  {
    "function_name": "SortAndUniqItems",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsrank.c",
    "lines": "154-198",
    "snippet": "static QueryOperand **\nSortAndUniqItems(TSQuery q, int *size)\n{\n\tchar\t   *operand = GETOPERAND(q);\n\tQueryItem  *item = GETQUERY(q);\n\tQueryOperand **res,\n\t\t\t  **ptr,\n\t\t\t  **prevptr;\n\n\tptr = res = (QueryOperand **) palloc(sizeof(QueryOperand *) * *size);\n\n\t/* Collect all operands from the tree to res */\n\twhile ((*size)--)\n\t{\n\t\tif (item->type == QI_VAL)\n\t\t{\n\t\t\t*ptr = (QueryOperand *) item;\n\t\t\tptr++;\n\t\t}\n\t\titem++;\n\t}\n\n\t*size = ptr - res;\n\tif (*size < 2)\n\t\treturn res;\n\n\tqsort_arg(res, *size, sizeof(QueryOperand *), compareQueryOperand, (void *) operand);\n\n\tptr = res + 1;\n\tprevptr = res;\n\n\t/* remove duplicates */\n\twhile (ptr - res < *size)\n\t{\n\t\tif (compareQueryOperand((void *) ptr, (void *) prevptr, (void *) operand) != 0)\n\t\t{\n\t\t\tprevptr++;\n\t\t\t*prevptr = *ptr;\n\t\t}\n\t\tptr++;\n\t}\n\n\t*size = prevptr + 1 - res;\n\treturn res;\n}",
    "includes": [
      "#include \"miscadmin.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static float calc_rank_or(const float *w, TSVector t, TSQuery q);",
      "static float calc_rank_and(const float *w, TSVector t, TSQuery q);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "compareQueryOperand",
          "args": [
            "(void *) ptr",
            "(void *) prevptr",
            "(void *) operand"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "compareQueryOperand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsrank.c",
          "lines": "135-145",
          "snippet": "static int\ncompareQueryOperand(const void *a, const void *b, void *arg)\n{\n\tchar\t   *operand = (char *) arg;\n\tQueryOperand *qa = (*(QueryOperand *const *) a);\n\tQueryOperand *qb = (*(QueryOperand *const *) b);\n\n\treturn tsCompareString(operand + qa->distance, qa->length,\n\t\t\t\t\t\t   operand + qb->distance, qb->length,\n\t\t\t\t\t\t   false);\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"tsearch/ts_utils.h\"\n#include <math.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic int\ncompareQueryOperand(const void *a, const void *b, void *arg)\n{\n\tchar\t   *operand = (char *) arg;\n\tQueryOperand *qa = (*(QueryOperand *const *) a);\n\tQueryOperand *qb = (*(QueryOperand *const *) b);\n\n\treturn tsCompareString(operand + qa->distance, qa->length,\n\t\t\t\t\t\t   operand + qb->distance, qb->length,\n\t\t\t\t\t\t   false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qsort_arg",
          "args": [
            "res",
            "*size",
            "sizeof(QueryOperand *)",
            "compareQueryOperand",
            "(void *) operand"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(QueryOperand *) * *size"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GETQUERY",
          "args": [
            "q"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETOPERAND",
          "args": [
            "q"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"tsearch/ts_utils.h\"\n#include <math.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic float calc_rank_or(const float *w, TSVector t, TSQuery q);\nstatic float calc_rank_and(const float *w, TSVector t, TSQuery q);\n\nstatic QueryOperand **\nSortAndUniqItems(TSQuery q, int *size)\n{\n\tchar\t   *operand = GETOPERAND(q);\n\tQueryItem  *item = GETQUERY(q);\n\tQueryOperand **res,\n\t\t\t  **ptr,\n\t\t\t  **prevptr;\n\n\tptr = res = (QueryOperand **) palloc(sizeof(QueryOperand *) * *size);\n\n\t/* Collect all operands from the tree to res */\n\twhile ((*size)--)\n\t{\n\t\tif (item->type == QI_VAL)\n\t\t{\n\t\t\t*ptr = (QueryOperand *) item;\n\t\t\tptr++;\n\t\t}\n\t\titem++;\n\t}\n\n\t*size = ptr - res;\n\tif (*size < 2)\n\t\treturn res;\n\n\tqsort_arg(res, *size, sizeof(QueryOperand *), compareQueryOperand, (void *) operand);\n\n\tptr = res + 1;\n\tprevptr = res;\n\n\t/* remove duplicates */\n\twhile (ptr - res < *size)\n\t{\n\t\tif (compareQueryOperand((void *) ptr, (void *) prevptr, (void *) operand) != 0)\n\t\t{\n\t\t\tprevptr++;\n\t\t\t*prevptr = *ptr;\n\t\t}\n\t\tptr++;\n\t}\n\n\t*size = prevptr + 1 - res;\n\treturn res;\n}"
  },
  {
    "function_name": "compareQueryOperand",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsrank.c",
    "lines": "135-145",
    "snippet": "static int\ncompareQueryOperand(const void *a, const void *b, void *arg)\n{\n\tchar\t   *operand = (char *) arg;\n\tQueryOperand *qa = (*(QueryOperand *const *) a);\n\tQueryOperand *qb = (*(QueryOperand *const *) b);\n\n\treturn tsCompareString(operand + qa->distance, qa->length,\n\t\t\t\t\t\t   operand + qb->distance, qb->length,\n\t\t\t\t\t\t   false);\n}",
    "includes": [
      "#include \"miscadmin.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tsCompareString",
          "args": [
            "operand + qa->distance",
            "qa->length",
            "operand + qb->distance",
            "qb->length",
            "false"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "tsCompareString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
          "lines": "1159-1191",
          "snippet": "int32\ntsCompareString(char *a, int lena, char *b, int lenb, bool prefix)\n{\n\tint\t\t\tcmp;\n\n\tif (lena == 0)\n\t{\n\t\tif (prefix)\n\t\t\tcmp = 0;\t\t\t/* empty string is prefix of anything */\n\t\telse\n\t\t\tcmp = (lenb > 0) ? -1 : 0;\n\t}\n\telse if (lenb == 0)\n\t{\n\t\tcmp = (lena > 0) ? 1 : 0;\n\t}\n\telse\n\t{\n\t\tcmp = memcmp(a, b, Min(lena, lenb));\n\n\t\tif (prefix)\n\t\t{\n\t\t\tif (cmp == 0 && lena > lenb)\n\t\t\t\tcmp = 1;\t\t/* a is longer, so not a prefix of b */\n\t\t}\n\t\telse if (cmp == 0 && lena != lenb)\n\t\t{\n\t\t\tcmp = (lena < lenb) ? -1 : 1;\n\t\t}\n\t}\n\n\treturn cmp;\n}",
          "includes": [
            "#include \"utils/rel.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nint32\ntsCompareString(char *a, int lena, char *b, int lenb, bool prefix)\n{\n\tint\t\t\tcmp;\n\n\tif (lena == 0)\n\t{\n\t\tif (prefix)\n\t\t\tcmp = 0;\t\t\t/* empty string is prefix of anything */\n\t\telse\n\t\t\tcmp = (lenb > 0) ? -1 : 0;\n\t}\n\telse if (lenb == 0)\n\t{\n\t\tcmp = (lena > 0) ? 1 : 0;\n\t}\n\telse\n\t{\n\t\tcmp = memcmp(a, b, Min(lena, lenb));\n\n\t\tif (prefix)\n\t\t{\n\t\t\tif (cmp == 0 && lena > lenb)\n\t\t\t\tcmp = 1;\t\t/* a is longer, so not a prefix of b */\n\t\t}\n\t\telse if (cmp == 0 && lena != lenb)\n\t\t{\n\t\t\tcmp = (lena < lenb) ? -1 : 1;\n\t\t}\n\t}\n\n\treturn cmp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"tsearch/ts_utils.h\"\n#include <math.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic int\ncompareQueryOperand(const void *a, const void *b, void *arg)\n{\n\tchar\t   *operand = (char *) arg;\n\tQueryOperand *qa = (*(QueryOperand *const *) a);\n\tQueryOperand *qb = (*(QueryOperand *const *) b);\n\n\treturn tsCompareString(operand + qa->distance, qa->length,\n\t\t\t\t\t\t   operand + qb->distance, qb->length,\n\t\t\t\t\t\t   false);\n}"
  },
  {
    "function_name": "find_wordentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsrank.c",
    "lines": "86-129",
    "snippet": "static WordEntry *\nfind_wordentry(TSVector t, TSQuery q, QueryOperand *item, int32 *nitem)\n{\n\tWordEntry  *StopLow = ARRPTR(t);\n\tWordEntry  *StopHigh = (WordEntry *) STRPTR(t);\n\tWordEntry  *StopMiddle = StopHigh;\n\tint\t\t\tdifference;\n\n\t*nitem = 0;\n\n\t/* Loop invariant: StopLow <= item < StopHigh */\n\twhile (StopLow < StopHigh)\n\t{\n\t\tStopMiddle = StopLow + (StopHigh - StopLow) / 2;\n\t\tdifference = WordECompareQueryItem(STRPTR(t), GETOPERAND(q), StopMiddle, item, false);\n\t\tif (difference == 0)\n\t\t{\n\t\t\tStopHigh = StopMiddle;\n\t\t\t*nitem = 1;\n\t\t\tbreak;\n\t\t}\n\t\telse if (difference > 0)\n\t\t\tStopLow = StopMiddle + 1;\n\t\telse\n\t\t\tStopHigh = StopMiddle;\n\t}\n\n\tif (item->prefix)\n\t{\n\t\tif (StopLow >= StopHigh)\n\t\t\tStopMiddle = StopHigh;\n\n\t\t*nitem = 0;\n\n\t\twhile (StopMiddle < (WordEntry *) STRPTR(t) &&\n\t\t\t   WordECompareQueryItem(STRPTR(t), GETOPERAND(q), StopMiddle, item, true) == 0)\n\t\t{\n\t\t\t(*nitem)++;\n\t\t\tStopMiddle++;\n\t\t}\n\t}\n\n\treturn (*nitem > 0) ? StopHigh : NULL;\n}",
    "includes": [
      "#include \"miscadmin.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static float calc_rank_or(const float *w, TSVector t, TSQuery q);",
      "static float calc_rank_and(const float *w, TSVector t, TSQuery q);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WordECompareQueryItem",
          "args": [
            "STRPTR(t)",
            "GETOPERAND(q)",
            "StopMiddle",
            "item",
            "true"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETOPERAND",
          "args": [
            "q"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPTR",
          "args": [
            "t"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPTR",
          "args": [
            "t"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WordECompareQueryItem",
          "args": [
            "STRPTR(t)",
            "GETOPERAND(q)",
            "StopMiddle",
            "item",
            "false"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETOPERAND",
          "args": [
            "q"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPTR",
          "args": [
            "t"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPTR",
          "args": [
            "t"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRPTR",
          "args": [
            "t"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"tsearch/ts_utils.h\"\n#include <math.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic float calc_rank_or(const float *w, TSVector t, TSQuery q);\nstatic float calc_rank_and(const float *w, TSVector t, TSQuery q);\n\nstatic WordEntry *\nfind_wordentry(TSVector t, TSQuery q, QueryOperand *item, int32 *nitem)\n{\n\tWordEntry  *StopLow = ARRPTR(t);\n\tWordEntry  *StopHigh = (WordEntry *) STRPTR(t);\n\tWordEntry  *StopMiddle = StopHigh;\n\tint\t\t\tdifference;\n\n\t*nitem = 0;\n\n\t/* Loop invariant: StopLow <= item < StopHigh */\n\twhile (StopLow < StopHigh)\n\t{\n\t\tStopMiddle = StopLow + (StopHigh - StopLow) / 2;\n\t\tdifference = WordECompareQueryItem(STRPTR(t), GETOPERAND(q), StopMiddle, item, false);\n\t\tif (difference == 0)\n\t\t{\n\t\t\tStopHigh = StopMiddle;\n\t\t\t*nitem = 1;\n\t\t\tbreak;\n\t\t}\n\t\telse if (difference > 0)\n\t\t\tStopLow = StopMiddle + 1;\n\t\telse\n\t\t\tStopHigh = StopMiddle;\n\t}\n\n\tif (item->prefix)\n\t{\n\t\tif (StopLow >= StopHigh)\n\t\t\tStopMiddle = StopHigh;\n\n\t\t*nitem = 0;\n\n\t\twhile (StopMiddle < (WordEntry *) STRPTR(t) &&\n\t\t\t   WordECompareQueryItem(STRPTR(t), GETOPERAND(q), StopMiddle, item, true) == 0)\n\t\t{\n\t\t\t(*nitem)++;\n\t\t\tStopMiddle++;\n\t\t}\n\t}\n\n\treturn (*nitem > 0) ? StopHigh : NULL;\n}"
  },
  {
    "function_name": "cnt_length",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsrank.c",
    "lines": "53-73",
    "snippet": "static int\ncnt_length(TSVector t)\n{\n\tWordEntry  *ptr = ARRPTR(t),\n\t\t\t   *end = (WordEntry *) STRPTR(t);\n\tint\t\t\tlen = 0;\n\n\twhile (ptr < end)\n\t{\n\t\tint\t\t\tclen = POSDATALEN(t, ptr);\n\n\t\tif (clen == 0)\n\t\t\tlen += 1;\n\t\telse\n\t\t\tlen += clen;\n\n\t\tptr++;\n\t}\n\n\treturn len;\n}",
    "includes": [
      "#include \"miscadmin.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "POSDATALEN",
          "args": [
            "t",
            "ptr"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPTR",
          "args": [
            "t"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRPTR",
          "args": [
            "t"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"tsearch/ts_utils.h\"\n#include <math.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic int\ncnt_length(TSVector t)\n{\n\tWordEntry  *ptr = ARRPTR(t),\n\t\t\t   *end = (WordEntry *) STRPTR(t);\n\tint\t\t\tlen = 0;\n\n\twhile (ptr < end)\n\t{\n\t\tint\t\t\tclen = POSDATALEN(t, ptr);\n\n\t\tif (clen == 0)\n\t\t\tlen += 1;\n\t\telse\n\t\t\tlen += clen;\n\n\t\tptr++;\n\t}\n\n\treturn len;\n}"
  },
  {
    "function_name": "word_distance",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsrank.c",
    "lines": "44-51",
    "snippet": "static float4\nword_distance(int32 w)\n{\n\tif (w > 100)\n\t\treturn 1e-30f;\n\n\treturn 1.0 / (1.005 + 0.05 * exp(((float4) w) / 1.5 - 2));\n}",
    "includes": [
      "#include \"miscadmin.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include <math.h>",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exp",
          "args": [
            "((float4) w) / 1.5 - 2"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "pg_get_expr_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ruleutils.c",
          "lines": "2341-2364",
          "snippet": "Datum\npg_get_expr_ext(PG_FUNCTION_ARGS)\n{\n\ttext\t   *expr = PG_GETARG_TEXT_PP(0);\n\tOid\t\t\trelid = PG_GETARG_OID(1);\n\tbool\t\tpretty = PG_GETARG_BOOL(2);\n\tint\t\t\tprettyFlags;\n\tchar\t   *relname;\n\n\tprettyFlags = pretty ? (PRETTYFLAG_PAREN | PRETTYFLAG_INDENT | PRETTYFLAG_SCHEMA) : PRETTYFLAG_INDENT;\n\n\tif (OidIsValid(relid))\n\t{\n\t\t/* Get the name for the relation */\n\t\trelname = get_rel_name(relid);\n\t\t/* See notes above */\n\t\tif (relname == NULL)\n\t\t\tPG_RETURN_NULL();\n\t}\n\telse\n\t\trelname = NULL;\n\n\tPG_RETURN_TEXT_P(pg_get_expr_worker(expr, relid, relname, prettyFlags));\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/ruleutils.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"rewrite/rewriteSupport.h\"",
            "#include \"rewrite/rewriteManip.h\"",
            "#include \"rewrite/rewriteHandler.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parser.h\"",
            "#include \"parser/parse_oper.h\"",
            "#include \"parser/parse_func.h\"",
            "#include \"parser/parse_agg.h\"",
            "#include \"parser/parse_node.h\"",
            "#include \"optimizer/tlist.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"common/keywords.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/dependency.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/amapi.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define PRETTYFLAG_SCHEMA\t\t0x0004",
            "#define PRETTYFLAG_INDENT\t\t0x0002",
            "#define PRETTYFLAG_PAREN\t\t0x0001"
          ],
          "globals_used": [
            "static char *pg_get_triggerdef_worker(Oid trigid, bool pretty);",
            "static char *pg_get_ruledef_worker(Oid ruleoid, int prettyFlags);",
            "static text *pg_get_expr_worker(text *expr, Oid relid, const char *relname,\n\t\t\t\t   int prettyFlags);",
            "static void make_ruledef(StringInfo buf, HeapTuple ruletup, TupleDesc rulettc,\n\t\t\t int prettyFlags);",
            "static const char *get_simple_binary_op_name(OpExpr *expr);",
            "static bool isSimpleNode(Node *node, Node *parentNode, int prettyFlags);",
            "static char *get_relation_name(Oid relid);",
            "static char *generate_qualified_relation_name(Oid relid);",
            "static char *flatten_reloptions(Oid relid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/ruleutils.h\"\n#include \"utils/rel.h\"\n#include \"utils/partcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"rewrite/rewriteSupport.h\"\n#include \"rewrite/rewriteManip.h\"\n#include \"rewrite/rewriteHandler.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parser.h\"\n#include \"parser/parse_oper.h\"\n#include \"parser/parse_func.h\"\n#include \"parser/parse_agg.h\"\n#include \"parser/parse_node.h\"\n#include \"optimizer/tlist.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"common/keywords.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/dependency.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/amapi.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define PRETTYFLAG_SCHEMA\t\t0x0004\n#define PRETTYFLAG_INDENT\t\t0x0002\n#define PRETTYFLAG_PAREN\t\t0x0001\n\nstatic char *pg_get_triggerdef_worker(Oid trigid, bool pretty);\nstatic char *pg_get_ruledef_worker(Oid ruleoid, int prettyFlags);\nstatic text *pg_get_expr_worker(text *expr, Oid relid, const char *relname,\n\t\t\t\t   int prettyFlags);\nstatic void make_ruledef(StringInfo buf, HeapTuple ruletup, TupleDesc rulettc,\n\t\t\t int prettyFlags);\nstatic const char *get_simple_binary_op_name(OpExpr *expr);\nstatic bool isSimpleNode(Node *node, Node *parentNode, int prettyFlags);\nstatic char *get_relation_name(Oid relid);\nstatic char *generate_qualified_relation_name(Oid relid);\nstatic char *flatten_reloptions(Oid relid);\n\nDatum\npg_get_expr_ext(PG_FUNCTION_ARGS)\n{\n\ttext\t   *expr = PG_GETARG_TEXT_PP(0);\n\tOid\t\t\trelid = PG_GETARG_OID(1);\n\tbool\t\tpretty = PG_GETARG_BOOL(2);\n\tint\t\t\tprettyFlags;\n\tchar\t   *relname;\n\n\tprettyFlags = pretty ? (PRETTYFLAG_PAREN | PRETTYFLAG_INDENT | PRETTYFLAG_SCHEMA) : PRETTYFLAG_INDENT;\n\n\tif (OidIsValid(relid))\n\t{\n\t\t/* Get the name for the relation */\n\t\trelname = get_rel_name(relid);\n\t\t/* See notes above */\n\t\tif (relname == NULL)\n\t\t\tPG_RETURN_NULL();\n\t}\n\telse\n\t\trelname = NULL;\n\n\tPG_RETURN_TEXT_P(pg_get_expr_worker(expr, relid, relname, prettyFlags));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"tsearch/ts_utils.h\"\n#include <math.h>\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic float4\nword_distance(int32 w)\n{\n\tif (w > 100)\n\t\treturn 1e-30f;\n\n\treturn 1.0 / (1.005 + 0.05 * exp(((float4) w) / 1.5 - 2));\n}"
  }
]