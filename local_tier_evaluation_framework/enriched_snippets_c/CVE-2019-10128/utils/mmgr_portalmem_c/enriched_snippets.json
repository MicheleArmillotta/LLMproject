[
  {
    "function_name": "HoldPinnedPortals",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/portalmem.c",
    "lines": "1243-1279",
    "snippet": "void\nHoldPinnedPortals(void)\n{\n\tHASH_SEQ_STATUS status;\n\tPortalHashEnt *hentry;\n\n\thash_seq_init(&status, PortalHashTable);\n\n\twhile ((hentry = (PortalHashEnt *) hash_seq_search(&status)) != NULL)\n\t{\n\t\tPortal\t\tportal = hentry->portal;\n\n\t\tif (portal->portalPinned && !portal->autoHeld)\n\t\t{\n\t\t\t/*\n\t\t\t * Doing transaction control, especially abort, inside a cursor\n\t\t\t * loop that is not read-only, for example using UPDATE ...\n\t\t\t * RETURNING, has weird semantics issues.  Also, this\n\t\t\t * implementation wouldn't work, because such portals cannot be\n\t\t\t * held.  (The core grammar enforces that only SELECT statements\n\t\t\t * can drive a cursor, but for example PL/pgSQL does not restrict\n\t\t\t * it.)\n\t\t\t */\n\t\t\tif (portal->strategy != PORTAL_ONE_SELECT)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TRANSACTION_TERMINATION),\n\t\t\t\t\t\t errmsg(\"cannot perform transaction commands inside a cursor loop that is not read-only\")));\n\n\t\t\t/* Verify it's in a suitable state to be held */\n\t\t\tif (portal->status != PORTAL_READY)\n\t\t\t\telog(ERROR, \"pinned portal is not ready to be auto-held\");\n\n\t\t\tHoldPortal(portal);\n\t\t\tportal->autoHeld = true;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/portalcmds.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static HTAB *PortalHashTable = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "HoldPortal",
          "args": [
            "portal"
          ],
          "line": 1275
        },
        "resolved": true,
        "details": {
          "function_name": "HoldPortal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/portalmem.c",
          "lines": "629-655",
          "snippet": "static void\nHoldPortal(Portal portal)\n{\n\t/*\n\t * Note that PersistHoldablePortal() must release all resources used by\n\t * the portal that are local to the creating transaction.\n\t */\n\tPortalCreateHoldStore(portal);\n\tPersistHoldablePortal(portal);\n\n\t/* drop cached plan reference, if any */\n\tPortalReleaseCachedPlan(portal);\n\n\t/*\n\t * Any resources belonging to the portal will be released in the upcoming\n\t * transaction-wide cleanup; the portal will no longer have its own\n\t * resources.\n\t */\n\tportal->resowner = NULL;\n\n\t/*\n\t * Having successfully exported the holdable cursor, mark it as not\n\t * belonging to this transaction.\n\t */\n\tportal->createSubid = InvalidSubTransactionId;\n\tportal->activeSubid = InvalidSubTransactionId;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/portalcmds.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/ipc.h\"\n#include \"miscadmin.h\"\n#include \"commands/portalcmds.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic void\nHoldPortal(Portal portal)\n{\n\t/*\n\t * Note that PersistHoldablePortal() must release all resources used by\n\t * the portal that are local to the creating transaction.\n\t */\n\tPortalCreateHoldStore(portal);\n\tPersistHoldablePortal(portal);\n\n\t/* drop cached plan reference, if any */\n\tPortalReleaseCachedPlan(portal);\n\n\t/*\n\t * Any resources belonging to the portal will be released in the upcoming\n\t * transaction-wide cleanup; the portal will no longer have its own\n\t * resources.\n\t */\n\tportal->resowner = NULL;\n\n\t/*\n\t * Having successfully exported the holdable cursor, mark it as not\n\t * belonging to this transaction.\n\t */\n\tportal->createSubid = InvalidSubTransactionId;\n\tportal->activeSubid = InvalidSubTransactionId;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"pinned portal is not ready to be auto-held\""
          ],
          "line": 1273
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TRANSACTION_TERMINATION),\n\t\t\t\t\t\t errmsg(\"cannot perform transaction commands inside a cursor loop that is not read-only\"))"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"cannot perform transaction commands inside a cursor loop that is not read-only\""
          ],
          "line": 1269
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_TRANSACTION_TERMINATION"
          ],
          "line": 1268
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_seq_search",
          "args": [
            "&status"
          ],
          "line": 1251
        },
        "resolved": true,
        "details": {
          "function_name": "hash_seq_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "1388-1462",
          "snippet": "void *\nhash_seq_search(HASH_SEQ_STATUS *status)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\tuint32\t\tmax_bucket;\n\tlong\t\tssize;\n\tlong\t\tsegment_num;\n\tlong\t\tsegment_ndx;\n\tHASHSEGMENT segp;\n\tuint32\t\tcurBucket;\n\tHASHELEMENT *curElem;\n\n\tif ((curElem = status->curEntry) != NULL)\n\t{\n\t\t/* Continuing scan of curBucket... */\n\t\tstatus->curEntry = curElem->link;\n\t\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t\t++status->curBucket;\n\t\treturn (void *) ELEMENTKEY(curElem);\n\t}\n\n\t/*\n\t * Search for next nonempty bucket starting at curBucket.\n\t */\n\tcurBucket = status->curBucket;\n\thashp = status->hashp;\n\thctl = hashp->hctl;\n\tssize = hashp->ssize;\n\tmax_bucket = hctl->max_bucket;\n\n\tif (curBucket > max_bucket)\n\t{\n\t\thash_seq_term(status);\n\t\treturn NULL;\t\t\t/* search is done */\n\t}\n\n\t/*\n\t * first find the right segment in the table directory.\n\t */\n\tsegment_num = curBucket >> hashp->sshift;\n\tsegment_ndx = MOD(curBucket, ssize);\n\n\tsegp = hashp->dir[segment_num];\n\n\t/*\n\t * Pick up the first item in this bucket's chain.  If chain is not empty\n\t * we can begin searching it.  Otherwise we have to advance to find the\n\t * next nonempty bucket.  We try to optimize that case since searching a\n\t * near-empty hashtable has to iterate this loop a lot.\n\t */\n\twhile ((curElem = segp[segment_ndx]) == NULL)\n\t{\n\t\t/* empty bucket, advance to next */\n\t\tif (++curBucket > max_bucket)\n\t\t{\n\t\t\tstatus->curBucket = curBucket;\n\t\t\thash_seq_term(status);\n\t\t\treturn NULL;\t\t/* search is done */\n\t\t}\n\t\tif (++segment_ndx >= ssize)\n\t\t{\n\t\t\tsegment_num++;\n\t\t\tsegment_ndx = 0;\n\t\t\tsegp = hashp->dir[segment_num];\n\t\t}\n\t}\n\n\t/* Begin scan of curBucket... */\n\tstatus->curEntry = curElem->link;\n\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t++curBucket;\n\tstatus->curBucket = curBucket;\n\treturn (void *) ELEMENTKEY(curElem);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid *\nhash_seq_search(HASH_SEQ_STATUS *status)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\tuint32\t\tmax_bucket;\n\tlong\t\tssize;\n\tlong\t\tsegment_num;\n\tlong\t\tsegment_ndx;\n\tHASHSEGMENT segp;\n\tuint32\t\tcurBucket;\n\tHASHELEMENT *curElem;\n\n\tif ((curElem = status->curEntry) != NULL)\n\t{\n\t\t/* Continuing scan of curBucket... */\n\t\tstatus->curEntry = curElem->link;\n\t\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t\t++status->curBucket;\n\t\treturn (void *) ELEMENTKEY(curElem);\n\t}\n\n\t/*\n\t * Search for next nonempty bucket starting at curBucket.\n\t */\n\tcurBucket = status->curBucket;\n\thashp = status->hashp;\n\thctl = hashp->hctl;\n\tssize = hashp->ssize;\n\tmax_bucket = hctl->max_bucket;\n\n\tif (curBucket > max_bucket)\n\t{\n\t\thash_seq_term(status);\n\t\treturn NULL;\t\t\t/* search is done */\n\t}\n\n\t/*\n\t * first find the right segment in the table directory.\n\t */\n\tsegment_num = curBucket >> hashp->sshift;\n\tsegment_ndx = MOD(curBucket, ssize);\n\n\tsegp = hashp->dir[segment_num];\n\n\t/*\n\t * Pick up the first item in this bucket's chain.  If chain is not empty\n\t * we can begin searching it.  Otherwise we have to advance to find the\n\t * next nonempty bucket.  We try to optimize that case since searching a\n\t * near-empty hashtable has to iterate this loop a lot.\n\t */\n\twhile ((curElem = segp[segment_ndx]) == NULL)\n\t{\n\t\t/* empty bucket, advance to next */\n\t\tif (++curBucket > max_bucket)\n\t\t{\n\t\t\tstatus->curBucket = curBucket;\n\t\t\thash_seq_term(status);\n\t\t\treturn NULL;\t\t/* search is done */\n\t\t}\n\t\tif (++segment_ndx >= ssize)\n\t\t{\n\t\t\tsegment_num++;\n\t\t\tsegment_ndx = 0;\n\t\t\tsegp = hashp->dir[segment_num];\n\t\t}\n\t}\n\n\t/* Begin scan of curBucket... */\n\tstatus->curEntry = curElem->link;\n\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t++curBucket;\n\tstatus->curBucket = curBucket;\n\treturn (void *) ELEMENTKEY(curElem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_seq_init",
          "args": [
            "&status",
            "PortalHashTable"
          ],
          "line": 1249
        },
        "resolved": true,
        "details": {
          "function_name": "hash_seq_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "1378-1386",
          "snippet": "void\nhash_seq_init(HASH_SEQ_STATUS *status, HTAB *hashp)\n{\n\tstatus->hashp = hashp;\n\tstatus->curBucket = 0;\n\tstatus->curEntry = NULL;\n\tif (!hashp->frozen)\n\t\tregister_seq_scan(hashp);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid\nhash_seq_init(HASH_SEQ_STATUS *status, HTAB *hashp)\n{\n\tstatus->hashp = hashp;\n\tstatus->curBucket = 0;\n\tstatus->curEntry = NULL;\n\tif (!hashp->frozen)\n\t\tregister_seq_scan(hashp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/ipc.h\"\n#include \"miscadmin.h\"\n#include \"commands/portalcmds.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic HTAB *PortalHashTable = NULL;\n\nvoid\nHoldPinnedPortals(void)\n{\n\tHASH_SEQ_STATUS status;\n\tPortalHashEnt *hentry;\n\n\thash_seq_init(&status, PortalHashTable);\n\n\twhile ((hentry = (PortalHashEnt *) hash_seq_search(&status)) != NULL)\n\t{\n\t\tPortal\t\tportal = hentry->portal;\n\n\t\tif (portal->portalPinned && !portal->autoHeld)\n\t\t{\n\t\t\t/*\n\t\t\t * Doing transaction control, especially abort, inside a cursor\n\t\t\t * loop that is not read-only, for example using UPDATE ...\n\t\t\t * RETURNING, has weird semantics issues.  Also, this\n\t\t\t * implementation wouldn't work, because such portals cannot be\n\t\t\t * held.  (The core grammar enforces that only SELECT statements\n\t\t\t * can drive a cursor, but for example PL/pgSQL does not restrict\n\t\t\t * it.)\n\t\t\t */\n\t\t\tif (portal->strategy != PORTAL_ONE_SELECT)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TRANSACTION_TERMINATION),\n\t\t\t\t\t\t errmsg(\"cannot perform transaction commands inside a cursor loop that is not read-only\")));\n\n\t\t\t/* Verify it's in a suitable state to be held */\n\t\t\tif (portal->status != PORTAL_READY)\n\t\t\t\telog(ERROR, \"pinned portal is not ready to be auto-held\");\n\n\t\t\tHoldPortal(portal);\n\t\t\tportal->autoHeld = true;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "ThereAreNoReadyPortals",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/portalmem.c",
    "lines": "1207-1224",
    "snippet": "bool\nThereAreNoReadyPortals(void)\n{\n\tHASH_SEQ_STATUS status;\n\tPortalHashEnt *hentry;\n\n\thash_seq_init(&status, PortalHashTable);\n\n\twhile ((hentry = (PortalHashEnt *) hash_seq_search(&status)) != NULL)\n\t{\n\t\tPortal\t\tportal = hentry->portal;\n\n\t\tif (portal->status == PORTAL_READY)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/portalcmds.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static HTAB *PortalHashTable = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash_seq_search",
          "args": [
            "&status"
          ],
          "line": 1215
        },
        "resolved": true,
        "details": {
          "function_name": "hash_seq_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "1388-1462",
          "snippet": "void *\nhash_seq_search(HASH_SEQ_STATUS *status)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\tuint32\t\tmax_bucket;\n\tlong\t\tssize;\n\tlong\t\tsegment_num;\n\tlong\t\tsegment_ndx;\n\tHASHSEGMENT segp;\n\tuint32\t\tcurBucket;\n\tHASHELEMENT *curElem;\n\n\tif ((curElem = status->curEntry) != NULL)\n\t{\n\t\t/* Continuing scan of curBucket... */\n\t\tstatus->curEntry = curElem->link;\n\t\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t\t++status->curBucket;\n\t\treturn (void *) ELEMENTKEY(curElem);\n\t}\n\n\t/*\n\t * Search for next nonempty bucket starting at curBucket.\n\t */\n\tcurBucket = status->curBucket;\n\thashp = status->hashp;\n\thctl = hashp->hctl;\n\tssize = hashp->ssize;\n\tmax_bucket = hctl->max_bucket;\n\n\tif (curBucket > max_bucket)\n\t{\n\t\thash_seq_term(status);\n\t\treturn NULL;\t\t\t/* search is done */\n\t}\n\n\t/*\n\t * first find the right segment in the table directory.\n\t */\n\tsegment_num = curBucket >> hashp->sshift;\n\tsegment_ndx = MOD(curBucket, ssize);\n\n\tsegp = hashp->dir[segment_num];\n\n\t/*\n\t * Pick up the first item in this bucket's chain.  If chain is not empty\n\t * we can begin searching it.  Otherwise we have to advance to find the\n\t * next nonempty bucket.  We try to optimize that case since searching a\n\t * near-empty hashtable has to iterate this loop a lot.\n\t */\n\twhile ((curElem = segp[segment_ndx]) == NULL)\n\t{\n\t\t/* empty bucket, advance to next */\n\t\tif (++curBucket > max_bucket)\n\t\t{\n\t\t\tstatus->curBucket = curBucket;\n\t\t\thash_seq_term(status);\n\t\t\treturn NULL;\t\t/* search is done */\n\t\t}\n\t\tif (++segment_ndx >= ssize)\n\t\t{\n\t\t\tsegment_num++;\n\t\t\tsegment_ndx = 0;\n\t\t\tsegp = hashp->dir[segment_num];\n\t\t}\n\t}\n\n\t/* Begin scan of curBucket... */\n\tstatus->curEntry = curElem->link;\n\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t++curBucket;\n\tstatus->curBucket = curBucket;\n\treturn (void *) ELEMENTKEY(curElem);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid *\nhash_seq_search(HASH_SEQ_STATUS *status)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\tuint32\t\tmax_bucket;\n\tlong\t\tssize;\n\tlong\t\tsegment_num;\n\tlong\t\tsegment_ndx;\n\tHASHSEGMENT segp;\n\tuint32\t\tcurBucket;\n\tHASHELEMENT *curElem;\n\n\tif ((curElem = status->curEntry) != NULL)\n\t{\n\t\t/* Continuing scan of curBucket... */\n\t\tstatus->curEntry = curElem->link;\n\t\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t\t++status->curBucket;\n\t\treturn (void *) ELEMENTKEY(curElem);\n\t}\n\n\t/*\n\t * Search for next nonempty bucket starting at curBucket.\n\t */\n\tcurBucket = status->curBucket;\n\thashp = status->hashp;\n\thctl = hashp->hctl;\n\tssize = hashp->ssize;\n\tmax_bucket = hctl->max_bucket;\n\n\tif (curBucket > max_bucket)\n\t{\n\t\thash_seq_term(status);\n\t\treturn NULL;\t\t\t/* search is done */\n\t}\n\n\t/*\n\t * first find the right segment in the table directory.\n\t */\n\tsegment_num = curBucket >> hashp->sshift;\n\tsegment_ndx = MOD(curBucket, ssize);\n\n\tsegp = hashp->dir[segment_num];\n\n\t/*\n\t * Pick up the first item in this bucket's chain.  If chain is not empty\n\t * we can begin searching it.  Otherwise we have to advance to find the\n\t * next nonempty bucket.  We try to optimize that case since searching a\n\t * near-empty hashtable has to iterate this loop a lot.\n\t */\n\twhile ((curElem = segp[segment_ndx]) == NULL)\n\t{\n\t\t/* empty bucket, advance to next */\n\t\tif (++curBucket > max_bucket)\n\t\t{\n\t\t\tstatus->curBucket = curBucket;\n\t\t\thash_seq_term(status);\n\t\t\treturn NULL;\t\t/* search is done */\n\t\t}\n\t\tif (++segment_ndx >= ssize)\n\t\t{\n\t\t\tsegment_num++;\n\t\t\tsegment_ndx = 0;\n\t\t\tsegp = hashp->dir[segment_num];\n\t\t}\n\t}\n\n\t/* Begin scan of curBucket... */\n\tstatus->curEntry = curElem->link;\n\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t++curBucket;\n\tstatus->curBucket = curBucket;\n\treturn (void *) ELEMENTKEY(curElem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_seq_init",
          "args": [
            "&status",
            "PortalHashTable"
          ],
          "line": 1213
        },
        "resolved": true,
        "details": {
          "function_name": "hash_seq_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "1378-1386",
          "snippet": "void\nhash_seq_init(HASH_SEQ_STATUS *status, HTAB *hashp)\n{\n\tstatus->hashp = hashp;\n\tstatus->curBucket = 0;\n\tstatus->curEntry = NULL;\n\tif (!hashp->frozen)\n\t\tregister_seq_scan(hashp);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid\nhash_seq_init(HASH_SEQ_STATUS *status, HTAB *hashp)\n{\n\tstatus->hashp = hashp;\n\tstatus->curBucket = 0;\n\tstatus->curEntry = NULL;\n\tif (!hashp->frozen)\n\t\tregister_seq_scan(hashp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/ipc.h\"\n#include \"miscadmin.h\"\n#include \"commands/portalcmds.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic HTAB *PortalHashTable = NULL;\n\nbool\nThereAreNoReadyPortals(void)\n{\n\tHASH_SEQ_STATUS status;\n\tPortalHashEnt *hentry;\n\n\thash_seq_init(&status, PortalHashTable);\n\n\twhile ((hentry = (PortalHashEnt *) hash_seq_search(&status)) != NULL)\n\t{\n\t\tPortal\t\tportal = hentry->portal;\n\n\t\tif (portal->status == PORTAL_READY)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "pg_cursor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/portalmem.c",
    "lines": "1119-1205",
    "snippet": "Datum\npg_cursor(PG_FUNCTION_ARGS)\n{\n\tReturnSetInfo *rsinfo = (ReturnSetInfo *) fcinfo->resultinfo;\n\tTupleDesc\ttupdesc;\n\tTuplestorestate *tupstore;\n\tMemoryContext per_query_ctx;\n\tMemoryContext oldcontext;\n\tHASH_SEQ_STATUS hash_seq;\n\tPortalHashEnt *hentry;\n\n\t/* check to see if caller supports us returning a tuplestore */\n\tif (rsinfo == NULL || !IsA(rsinfo, ReturnSetInfo))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"set-valued function called in context that cannot accept a set\")));\n\tif (!(rsinfo->allowedModes & SFRM_Materialize))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"materialize mode required, but it is not \" \\\n\t\t\t\t\t\t\"allowed in this context\")));\n\n\t/* need to build tuplestore in query context */\n\tper_query_ctx = rsinfo->econtext->ecxt_per_query_memory;\n\toldcontext = MemoryContextSwitchTo(per_query_ctx);\n\n\t/*\n\t * build tupdesc for result tuples. This must match the definition of the\n\t * pg_cursors view in system_views.sql\n\t */\n\ttupdesc = CreateTemplateTupleDesc(6, false);\n\tTupleDescInitEntry(tupdesc, (AttrNumber) 1, \"name\",\n\t\t\t\t\t   TEXTOID, -1, 0);\n\tTupleDescInitEntry(tupdesc, (AttrNumber) 2, \"statement\",\n\t\t\t\t\t   TEXTOID, -1, 0);\n\tTupleDescInitEntry(tupdesc, (AttrNumber) 3, \"is_holdable\",\n\t\t\t\t\t   BOOLOID, -1, 0);\n\tTupleDescInitEntry(tupdesc, (AttrNumber) 4, \"is_binary\",\n\t\t\t\t\t   BOOLOID, -1, 0);\n\tTupleDescInitEntry(tupdesc, (AttrNumber) 5, \"is_scrollable\",\n\t\t\t\t\t   BOOLOID, -1, 0);\n\tTupleDescInitEntry(tupdesc, (AttrNumber) 6, \"creation_time\",\n\t\t\t\t\t   TIMESTAMPTZOID, -1, 0);\n\n\t/*\n\t * We put all the tuples into a tuplestore in one scan of the hashtable.\n\t * This avoids any issue of the hashtable possibly changing between calls.\n\t */\n\ttupstore =\n\t\ttuplestore_begin_heap(rsinfo->allowedModes & SFRM_Materialize_Random,\n\t\t\t\t\t\t\t  false, work_mem);\n\n\t/* generate junk in short-term context */\n\tMemoryContextSwitchTo(oldcontext);\n\n\thash_seq_init(&hash_seq, PortalHashTable);\n\twhile ((hentry = hash_seq_search(&hash_seq)) != NULL)\n\t{\n\t\tPortal\t\tportal = hentry->portal;\n\t\tDatum\t\tvalues[6];\n\t\tbool\t\tnulls[6];\n\n\t\t/* report only \"visible\" entries */\n\t\tif (!portal->visible)\n\t\t\tcontinue;\n\n\t\tMemSet(nulls, 0, sizeof(nulls));\n\n\t\tvalues[0] = CStringGetTextDatum(portal->name);\n\t\tvalues[1] = CStringGetTextDatum(portal->sourceText);\n\t\tvalues[2] = BoolGetDatum(portal->cursorOptions & CURSOR_OPT_HOLD);\n\t\tvalues[3] = BoolGetDatum(portal->cursorOptions & CURSOR_OPT_BINARY);\n\t\tvalues[4] = BoolGetDatum(portal->cursorOptions & CURSOR_OPT_SCROLL);\n\t\tvalues[5] = TimestampTzGetDatum(portal->creation_time);\n\n\t\ttuplestore_putvalues(tupstore, tupdesc, values, nulls);\n\t}\n\n\t/* clean up and return the tuplestore */\n\ttuplestore_donestoring(tupstore);\n\n\trsinfo->returnMode = SFRM_Materialize;\n\trsinfo->setResult = tupstore;\n\trsinfo->setDesc = tupdesc;\n\n\treturn (Datum) 0;\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/portalcmds.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static HTAB *PortalHashTable = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tuplestore_donestoring",
          "args": [
            "tupstore"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tuplestore_putvalues",
          "args": [
            "tupstore",
            "tupdesc",
            "values",
            "nulls"
          ],
          "line": 1194
        },
        "resolved": true,
        "details": {
          "function_name": "tuplestore_putvalues",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplestore.c",
          "lines": "749-762",
          "snippet": "void\ntuplestore_putvalues(Tuplestorestate *state, TupleDesc tdesc,\n\t\t\t\t\t Datum *values, bool *isnull)\n{\n\tMinimalTuple tuple;\n\tMemoryContext oldcxt = MemoryContextSwitchTo(state->context);\n\n\ttuple = heap_form_minimal_tuple(tdesc, values, isnull);\n\tUSEMEM(state, GetMemoryChunkSpace(tuple));\n\n\ttuplestore_puttuple_common(state, (void *) tuple);\n\n\tMemoryContextSwitchTo(oldcxt);\n}",
          "includes": [
            "#include \"utils/resowner.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void tuplestore_puttuple_common(Tuplestorestate *state, void *tuple);",
            "static void dumptuples(Tuplestorestate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/resowner.h\"\n#include \"utils/memutils.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void tuplestore_puttuple_common(Tuplestorestate *state, void *tuple);\nstatic void dumptuples(Tuplestorestate *state);\n\nvoid\ntuplestore_putvalues(Tuplestorestate *state, TupleDesc tdesc,\n\t\t\t\t\t Datum *values, bool *isnull)\n{\n\tMinimalTuple tuple;\n\tMemoryContext oldcxt = MemoryContextSwitchTo(state->context);\n\n\ttuple = heap_form_minimal_tuple(tdesc, values, isnull);\n\tUSEMEM(state, GetMemoryChunkSpace(tuple));\n\n\ttuplestore_puttuple_common(state, (void *) tuple);\n\n\tMemoryContextSwitchTo(oldcxt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TimestampTzGetDatum",
          "args": [
            "portal->creation_time"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BoolGetDatum",
          "args": [
            "portal->cursorOptions & CURSOR_OPT_SCROLL"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BoolGetDatum",
          "args": [
            "portal->cursorOptions & CURSOR_OPT_BINARY"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BoolGetDatum",
          "args": [
            "portal->cursorOptions & CURSOR_OPT_HOLD"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CStringGetTextDatum",
          "args": [
            "portal->sourceText"
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CStringGetTextDatum",
          "args": [
            "portal->name"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemSet",
          "args": [
            "nulls",
            "0",
            "sizeof(nulls)"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_seq_search",
          "args": [
            "&hash_seq"
          ],
          "line": 1175
        },
        "resolved": true,
        "details": {
          "function_name": "hash_seq_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "1388-1462",
          "snippet": "void *\nhash_seq_search(HASH_SEQ_STATUS *status)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\tuint32\t\tmax_bucket;\n\tlong\t\tssize;\n\tlong\t\tsegment_num;\n\tlong\t\tsegment_ndx;\n\tHASHSEGMENT segp;\n\tuint32\t\tcurBucket;\n\tHASHELEMENT *curElem;\n\n\tif ((curElem = status->curEntry) != NULL)\n\t{\n\t\t/* Continuing scan of curBucket... */\n\t\tstatus->curEntry = curElem->link;\n\t\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t\t++status->curBucket;\n\t\treturn (void *) ELEMENTKEY(curElem);\n\t}\n\n\t/*\n\t * Search for next nonempty bucket starting at curBucket.\n\t */\n\tcurBucket = status->curBucket;\n\thashp = status->hashp;\n\thctl = hashp->hctl;\n\tssize = hashp->ssize;\n\tmax_bucket = hctl->max_bucket;\n\n\tif (curBucket > max_bucket)\n\t{\n\t\thash_seq_term(status);\n\t\treturn NULL;\t\t\t/* search is done */\n\t}\n\n\t/*\n\t * first find the right segment in the table directory.\n\t */\n\tsegment_num = curBucket >> hashp->sshift;\n\tsegment_ndx = MOD(curBucket, ssize);\n\n\tsegp = hashp->dir[segment_num];\n\n\t/*\n\t * Pick up the first item in this bucket's chain.  If chain is not empty\n\t * we can begin searching it.  Otherwise we have to advance to find the\n\t * next nonempty bucket.  We try to optimize that case since searching a\n\t * near-empty hashtable has to iterate this loop a lot.\n\t */\n\twhile ((curElem = segp[segment_ndx]) == NULL)\n\t{\n\t\t/* empty bucket, advance to next */\n\t\tif (++curBucket > max_bucket)\n\t\t{\n\t\t\tstatus->curBucket = curBucket;\n\t\t\thash_seq_term(status);\n\t\t\treturn NULL;\t\t/* search is done */\n\t\t}\n\t\tif (++segment_ndx >= ssize)\n\t\t{\n\t\t\tsegment_num++;\n\t\t\tsegment_ndx = 0;\n\t\t\tsegp = hashp->dir[segment_num];\n\t\t}\n\t}\n\n\t/* Begin scan of curBucket... */\n\tstatus->curEntry = curElem->link;\n\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t++curBucket;\n\tstatus->curBucket = curBucket;\n\treturn (void *) ELEMENTKEY(curElem);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid *\nhash_seq_search(HASH_SEQ_STATUS *status)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\tuint32\t\tmax_bucket;\n\tlong\t\tssize;\n\tlong\t\tsegment_num;\n\tlong\t\tsegment_ndx;\n\tHASHSEGMENT segp;\n\tuint32\t\tcurBucket;\n\tHASHELEMENT *curElem;\n\n\tif ((curElem = status->curEntry) != NULL)\n\t{\n\t\t/* Continuing scan of curBucket... */\n\t\tstatus->curEntry = curElem->link;\n\t\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t\t++status->curBucket;\n\t\treturn (void *) ELEMENTKEY(curElem);\n\t}\n\n\t/*\n\t * Search for next nonempty bucket starting at curBucket.\n\t */\n\tcurBucket = status->curBucket;\n\thashp = status->hashp;\n\thctl = hashp->hctl;\n\tssize = hashp->ssize;\n\tmax_bucket = hctl->max_bucket;\n\n\tif (curBucket > max_bucket)\n\t{\n\t\thash_seq_term(status);\n\t\treturn NULL;\t\t\t/* search is done */\n\t}\n\n\t/*\n\t * first find the right segment in the table directory.\n\t */\n\tsegment_num = curBucket >> hashp->sshift;\n\tsegment_ndx = MOD(curBucket, ssize);\n\n\tsegp = hashp->dir[segment_num];\n\n\t/*\n\t * Pick up the first item in this bucket's chain.  If chain is not empty\n\t * we can begin searching it.  Otherwise we have to advance to find the\n\t * next nonempty bucket.  We try to optimize that case since searching a\n\t * near-empty hashtable has to iterate this loop a lot.\n\t */\n\twhile ((curElem = segp[segment_ndx]) == NULL)\n\t{\n\t\t/* empty bucket, advance to next */\n\t\tif (++curBucket > max_bucket)\n\t\t{\n\t\t\tstatus->curBucket = curBucket;\n\t\t\thash_seq_term(status);\n\t\t\treturn NULL;\t\t/* search is done */\n\t\t}\n\t\tif (++segment_ndx >= ssize)\n\t\t{\n\t\t\tsegment_num++;\n\t\t\tsegment_ndx = 0;\n\t\t\tsegp = hashp->dir[segment_num];\n\t\t}\n\t}\n\n\t/* Begin scan of curBucket... */\n\tstatus->curEntry = curElem->link;\n\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t++curBucket;\n\tstatus->curBucket = curBucket;\n\treturn (void *) ELEMENTKEY(curElem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_seq_init",
          "args": [
            "&hash_seq",
            "PortalHashTable"
          ],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "hash_seq_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "1378-1386",
          "snippet": "void\nhash_seq_init(HASH_SEQ_STATUS *status, HTAB *hashp)\n{\n\tstatus->hashp = hashp;\n\tstatus->curBucket = 0;\n\tstatus->curEntry = NULL;\n\tif (!hashp->frozen)\n\t\tregister_seq_scan(hashp);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid\nhash_seq_init(HASH_SEQ_STATUS *status, HTAB *hashp)\n{\n\tstatus->hashp = hashp;\n\tstatus->curBucket = 0;\n\tstatus->curEntry = NULL;\n\tif (!hashp->frozen)\n\t\tregister_seq_scan(hashp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tuplestore_begin_heap",
          "args": [
            "rsinfo->allowedModes & SFRM_Materialize_Random",
            "false",
            "work_mem"
          ],
          "line": 1168
        },
        "resolved": true,
        "details": {
          "function_name": "tuplestore_begin_heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplestore.c",
          "lines": "317-338",
          "snippet": "Tuplestorestate *\ntuplestore_begin_heap(bool randomAccess, bool interXact, int maxKBytes)\n{\n\tTuplestorestate *state;\n\tint\t\t\teflags;\n\n\t/*\n\t * This interpretation of the meaning of randomAccess is compatible with\n\t * the pre-8.3 behavior of tuplestores.\n\t */\n\teflags = randomAccess ?\n\t\t(EXEC_FLAG_BACKWARD | EXEC_FLAG_REWIND) :\n\t\t(EXEC_FLAG_REWIND);\n\n\tstate = tuplestore_begin_common(eflags, interXact, maxKBytes);\n\n\tstate->copytup = copytup_heap;\n\tstate->writetup = writetup_heap;\n\tstate->readtup = readtup_heap;\n\n\treturn state;\n}",
          "includes": [
            "#include \"utils/resowner.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Tuplestorestate *tuplestore_begin_common(int eflags,\n\t\t\t\t\t\tbool interXact,\n\t\t\t\t\t\tint maxKBytes);",
            "static void dumptuples(Tuplestorestate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/resowner.h\"\n#include \"utils/memutils.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Tuplestorestate *tuplestore_begin_common(int eflags,\n\t\t\t\t\t\tbool interXact,\n\t\t\t\t\t\tint maxKBytes);\nstatic void dumptuples(Tuplestorestate *state);\n\nTuplestorestate *\ntuplestore_begin_heap(bool randomAccess, bool interXact, int maxKBytes)\n{\n\tTuplestorestate *state;\n\tint\t\t\teflags;\n\n\t/*\n\t * This interpretation of the meaning of randomAccess is compatible with\n\t * the pre-8.3 behavior of tuplestores.\n\t */\n\teflags = randomAccess ?\n\t\t(EXEC_FLAG_BACKWARD | EXEC_FLAG_REWIND) :\n\t\t(EXEC_FLAG_REWIND);\n\n\tstate = tuplestore_begin_common(eflags, interXact, maxKBytes);\n\n\tstate->copytup = copytup_heap;\n\tstate->writetup = writetup_heap;\n\tstate->readtup = readtup_heap;\n\n\treturn state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TupleDescInitEntry",
          "args": [
            "tupdesc",
            "(AttrNumber) 6",
            "\"creation_time\"",
            "TIMESTAMPTZOID",
            "-1",
            "0"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescInitEntry",
          "args": [
            "tupdesc",
            "(AttrNumber) 5",
            "\"is_scrollable\"",
            "BOOLOID",
            "-1",
            "0"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescInitEntry",
          "args": [
            "tupdesc",
            "(AttrNumber) 4",
            "\"is_binary\"",
            "BOOLOID",
            "-1",
            "0"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescInitEntry",
          "args": [
            "tupdesc",
            "(AttrNumber) 3",
            "\"is_holdable\"",
            "BOOLOID",
            "-1",
            "0"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescInitEntry",
          "args": [
            "tupdesc",
            "(AttrNumber) 2",
            "\"statement\"",
            "TEXTOID",
            "-1",
            "0"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescInitEntry",
          "args": [
            "tupdesc",
            "(AttrNumber) 1",
            "\"name\"",
            "TEXTOID",
            "-1",
            "0"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CreateTemplateTupleDesc",
          "args": [
            "6",
            "false"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "per_query_ctx"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"materialize mode required, but it is not \" \\\n\t\t\t\t\t\t\"allowed in this context\"))"
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"materialize mode required, but it is not \" \\\n\t\t\t\t\t\t\"allowed in this context\""
          ],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_FEATURE_NOT_SUPPORTED"
          ],
          "line": 1137
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"set-valued function called in context that cannot accept a set\"))"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "rsinfo",
            "ReturnSetInfo"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/ipc.h\"\n#include \"miscadmin.h\"\n#include \"commands/portalcmds.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic HTAB *PortalHashTable = NULL;\n\nDatum\npg_cursor(PG_FUNCTION_ARGS)\n{\n\tReturnSetInfo *rsinfo = (ReturnSetInfo *) fcinfo->resultinfo;\n\tTupleDesc\ttupdesc;\n\tTuplestorestate *tupstore;\n\tMemoryContext per_query_ctx;\n\tMemoryContext oldcontext;\n\tHASH_SEQ_STATUS hash_seq;\n\tPortalHashEnt *hentry;\n\n\t/* check to see if caller supports us returning a tuplestore */\n\tif (rsinfo == NULL || !IsA(rsinfo, ReturnSetInfo))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"set-valued function called in context that cannot accept a set\")));\n\tif (!(rsinfo->allowedModes & SFRM_Materialize))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"materialize mode required, but it is not \" \\\n\t\t\t\t\t\t\"allowed in this context\")));\n\n\t/* need to build tuplestore in query context */\n\tper_query_ctx = rsinfo->econtext->ecxt_per_query_memory;\n\toldcontext = MemoryContextSwitchTo(per_query_ctx);\n\n\t/*\n\t * build tupdesc for result tuples. This must match the definition of the\n\t * pg_cursors view in system_views.sql\n\t */\n\ttupdesc = CreateTemplateTupleDesc(6, false);\n\tTupleDescInitEntry(tupdesc, (AttrNumber) 1, \"name\",\n\t\t\t\t\t   TEXTOID, -1, 0);\n\tTupleDescInitEntry(tupdesc, (AttrNumber) 2, \"statement\",\n\t\t\t\t\t   TEXTOID, -1, 0);\n\tTupleDescInitEntry(tupdesc, (AttrNumber) 3, \"is_holdable\",\n\t\t\t\t\t   BOOLOID, -1, 0);\n\tTupleDescInitEntry(tupdesc, (AttrNumber) 4, \"is_binary\",\n\t\t\t\t\t   BOOLOID, -1, 0);\n\tTupleDescInitEntry(tupdesc, (AttrNumber) 5, \"is_scrollable\",\n\t\t\t\t\t   BOOLOID, -1, 0);\n\tTupleDescInitEntry(tupdesc, (AttrNumber) 6, \"creation_time\",\n\t\t\t\t\t   TIMESTAMPTZOID, -1, 0);\n\n\t/*\n\t * We put all the tuples into a tuplestore in one scan of the hashtable.\n\t * This avoids any issue of the hashtable possibly changing between calls.\n\t */\n\ttupstore =\n\t\ttuplestore_begin_heap(rsinfo->allowedModes & SFRM_Materialize_Random,\n\t\t\t\t\t\t\t  false, work_mem);\n\n\t/* generate junk in short-term context */\n\tMemoryContextSwitchTo(oldcontext);\n\n\thash_seq_init(&hash_seq, PortalHashTable);\n\twhile ((hentry = hash_seq_search(&hash_seq)) != NULL)\n\t{\n\t\tPortal\t\tportal = hentry->portal;\n\t\tDatum\t\tvalues[6];\n\t\tbool\t\tnulls[6];\n\n\t\t/* report only \"visible\" entries */\n\t\tif (!portal->visible)\n\t\t\tcontinue;\n\n\t\tMemSet(nulls, 0, sizeof(nulls));\n\n\t\tvalues[0] = CStringGetTextDatum(portal->name);\n\t\tvalues[1] = CStringGetTextDatum(portal->sourceText);\n\t\tvalues[2] = BoolGetDatum(portal->cursorOptions & CURSOR_OPT_HOLD);\n\t\tvalues[3] = BoolGetDatum(portal->cursorOptions & CURSOR_OPT_BINARY);\n\t\tvalues[4] = BoolGetDatum(portal->cursorOptions & CURSOR_OPT_SCROLL);\n\t\tvalues[5] = TimestampTzGetDatum(portal->creation_time);\n\n\t\ttuplestore_putvalues(tupstore, tupdesc, values, nulls);\n\t}\n\n\t/* clean up and return the tuplestore */\n\ttuplestore_donestoring(tupstore);\n\n\trsinfo->returnMode = SFRM_Materialize;\n\trsinfo->setResult = tupstore;\n\trsinfo->setDesc = tupdesc;\n\n\treturn (Datum) 0;\n}"
  },
  {
    "function_name": "AtSubCleanup_Portals",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/portalmem.c",
    "lines": "1080-1116",
    "snippet": "void\nAtSubCleanup_Portals(SubTransactionId mySubid)\n{\n\tHASH_SEQ_STATUS status;\n\tPortalHashEnt *hentry;\n\n\thash_seq_init(&status, PortalHashTable);\n\n\twhile ((hentry = (PortalHashEnt *) hash_seq_search(&status)) != NULL)\n\t{\n\t\tPortal\t\tportal = hentry->portal;\n\n\t\tif (portal->createSubid != mySubid)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * If a portal is still pinned, forcibly unpin it. PortalDrop will not\n\t\t * let us drop the portal otherwise. Whoever pinned the portal was\n\t\t * interrupted by the abort too and won't try to use it anymore.\n\t\t */\n\t\tif (portal->portalPinned)\n\t\t\tportal->portalPinned = false;\n\n\t\t/*\n\t\t * We had better not call any user-defined code during cleanup, so if\n\t\t * the cleanup hook hasn't been run yet, too bad; we'll just skip it.\n\t\t */\n\t\tif (PointerIsValid(portal->cleanup))\n\t\t{\n\t\t\telog(WARNING, \"skipping cleanup for portal \\\"%s\\\"\", portal->name);\n\t\t\tportal->cleanup = NULL;\n\t\t}\n\n\t\t/* Zap it. */\n\t\tPortalDrop(portal, false);\n\t}\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/portalcmds.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static HTAB *PortalHashTable = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PortalDrop",
          "args": [
            "portal",
            "false"
          ],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "PortalDrop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/portalmem.c",
          "lines": "464-593",
          "snippet": "void\nPortalDrop(Portal portal, bool isTopCommit)\n{\n\tAssertArg(PortalIsValid(portal));\n\n\t/*\n\t * Don't allow dropping a pinned portal, it's still needed by whoever\n\t * pinned it.\n\t */\n\tif (portal->portalPinned)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_CURSOR_STATE),\n\t\t\t\t errmsg(\"cannot drop pinned portal \\\"%s\\\"\", portal->name)));\n\n\t/*\n\t * Not sure if the PORTAL_ACTIVE case can validly happen or not...\n\t */\n\tif (portal->status == PORTAL_ACTIVE)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_CURSOR_STATE),\n\t\t\t\t errmsg(\"cannot drop active portal \\\"%s\\\"\", portal->name)));\n\n\t/*\n\t * Allow portalcmds.c to clean up the state it knows about, in particular\n\t * shutting down the executor if still active.  This step potentially runs\n\t * user-defined code so failure has to be expected.  It's the cleanup\n\t * hook's responsibility to not try to do that more than once, in the case\n\t * that failure occurs and then we come back to drop the portal again\n\t * during transaction abort.\n\t *\n\t * Note: in most paths of control, this will have been done already in\n\t * MarkPortalDone or MarkPortalFailed.  We're just making sure.\n\t */\n\tif (PointerIsValid(portal->cleanup))\n\t{\n\t\tportal->cleanup(portal);\n\t\tportal->cleanup = NULL;\n\t}\n\n\t/*\n\t * Remove portal from hash table.  Because we do this here, we will not\n\t * come back to try to remove the portal again if there's any error in the\n\t * subsequent steps.  Better to leak a little memory than to get into an\n\t * infinite error-recovery loop.\n\t */\n\tPortalHashTableDelete(portal);\n\n\t/* drop cached plan reference, if any */\n\tPortalReleaseCachedPlan(portal);\n\n\t/*\n\t * If portal has a snapshot protecting its data, release that.  This needs\n\t * a little care since the registration will be attached to the portal's\n\t * resowner; if the portal failed, we will already have released the\n\t * resowner (and the snapshot) during transaction abort.\n\t */\n\tif (portal->holdSnapshot)\n\t{\n\t\tif (portal->resowner)\n\t\t\tUnregisterSnapshotFromOwner(portal->holdSnapshot,\n\t\t\t\t\t\t\t\t\t\tportal->resowner);\n\t\tportal->holdSnapshot = NULL;\n\t}\n\n\t/*\n\t * Release any resources still attached to the portal.  There are several\n\t * cases being covered here:\n\t *\n\t * Top transaction commit (indicated by isTopCommit): normally we should\n\t * do nothing here and let the regular end-of-transaction resource\n\t * releasing mechanism handle these resources too.  However, if we have a\n\t * FAILED portal (eg, a cursor that got an error), we'd better clean up\n\t * its resources to avoid resource-leakage warning messages.\n\t *\n\t * Sub transaction commit: never comes here at all, since we don't kill\n\t * any portals in AtSubCommit_Portals().\n\t *\n\t * Main or sub transaction abort: we will do nothing here because\n\t * portal->resowner was already set NULL; the resources were already\n\t * cleaned up in transaction abort.\n\t *\n\t * Ordinary portal drop: must release resources.  However, if the portal\n\t * is not FAILED then we do not release its locks.  The locks become the\n\t * responsibility of the transaction's ResourceOwner (since it is the\n\t * parent of the portal's owner) and will be released when the transaction\n\t * eventually ends.\n\t */\n\tif (portal->resowner &&\n\t\t(!isTopCommit || portal->status == PORTAL_FAILED))\n\t{\n\t\tbool\t\tisCommit = (portal->status != PORTAL_FAILED);\n\n\t\tResourceOwnerRelease(portal->resowner,\n\t\t\t\t\t\t\t RESOURCE_RELEASE_BEFORE_LOCKS,\n\t\t\t\t\t\t\t isCommit, false);\n\t\tResourceOwnerRelease(portal->resowner,\n\t\t\t\t\t\t\t RESOURCE_RELEASE_LOCKS,\n\t\t\t\t\t\t\t isCommit, false);\n\t\tResourceOwnerRelease(portal->resowner,\n\t\t\t\t\t\t\t RESOURCE_RELEASE_AFTER_LOCKS,\n\t\t\t\t\t\t\t isCommit, false);\n\t\tResourceOwnerDelete(portal->resowner);\n\t}\n\tportal->resowner = NULL;\n\n\t/*\n\t * Delete tuplestore if present.  We should do this even under error\n\t * conditions; since the tuplestore would have been using cross-\n\t * transaction storage, its temp files need to be explicitly deleted.\n\t */\n\tif (portal->holdStore)\n\t{\n\t\tMemoryContext oldcontext;\n\n\t\toldcontext = MemoryContextSwitchTo(portal->holdContext);\n\t\ttuplestore_end(portal->holdStore);\n\t\tMemoryContextSwitchTo(oldcontext);\n\t\tportal->holdStore = NULL;\n\t}\n\n\t/* delete tuplestore storage, if any */\n\tif (portal->holdContext)\n\t\tMemoryContextDelete(portal->holdContext);\n\n\t/* release subsidiary storage */\n\tMemoryContextDelete(portal->portalContext);\n\n\t/* release portal struct (it's in TopPortalContext) */\n\tpfree(portal);\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/portalcmds.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static MemoryContext TopPortalContext = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/ipc.h\"\n#include \"miscadmin.h\"\n#include \"commands/portalcmds.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic MemoryContext TopPortalContext = NULL;\n\nvoid\nPortalDrop(Portal portal, bool isTopCommit)\n{\n\tAssertArg(PortalIsValid(portal));\n\n\t/*\n\t * Don't allow dropping a pinned portal, it's still needed by whoever\n\t * pinned it.\n\t */\n\tif (portal->portalPinned)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_CURSOR_STATE),\n\t\t\t\t errmsg(\"cannot drop pinned portal \\\"%s\\\"\", portal->name)));\n\n\t/*\n\t * Not sure if the PORTAL_ACTIVE case can validly happen or not...\n\t */\n\tif (portal->status == PORTAL_ACTIVE)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_CURSOR_STATE),\n\t\t\t\t errmsg(\"cannot drop active portal \\\"%s\\\"\", portal->name)));\n\n\t/*\n\t * Allow portalcmds.c to clean up the state it knows about, in particular\n\t * shutting down the executor if still active.  This step potentially runs\n\t * user-defined code so failure has to be expected.  It's the cleanup\n\t * hook's responsibility to not try to do that more than once, in the case\n\t * that failure occurs and then we come back to drop the portal again\n\t * during transaction abort.\n\t *\n\t * Note: in most paths of control, this will have been done already in\n\t * MarkPortalDone or MarkPortalFailed.  We're just making sure.\n\t */\n\tif (PointerIsValid(portal->cleanup))\n\t{\n\t\tportal->cleanup(portal);\n\t\tportal->cleanup = NULL;\n\t}\n\n\t/*\n\t * Remove portal from hash table.  Because we do this here, we will not\n\t * come back to try to remove the portal again if there's any error in the\n\t * subsequent steps.  Better to leak a little memory than to get into an\n\t * infinite error-recovery loop.\n\t */\n\tPortalHashTableDelete(portal);\n\n\t/* drop cached plan reference, if any */\n\tPortalReleaseCachedPlan(portal);\n\n\t/*\n\t * If portal has a snapshot protecting its data, release that.  This needs\n\t * a little care since the registration will be attached to the portal's\n\t * resowner; if the portal failed, we will already have released the\n\t * resowner (and the snapshot) during transaction abort.\n\t */\n\tif (portal->holdSnapshot)\n\t{\n\t\tif (portal->resowner)\n\t\t\tUnregisterSnapshotFromOwner(portal->holdSnapshot,\n\t\t\t\t\t\t\t\t\t\tportal->resowner);\n\t\tportal->holdSnapshot = NULL;\n\t}\n\n\t/*\n\t * Release any resources still attached to the portal.  There are several\n\t * cases being covered here:\n\t *\n\t * Top transaction commit (indicated by isTopCommit): normally we should\n\t * do nothing here and let the regular end-of-transaction resource\n\t * releasing mechanism handle these resources too.  However, if we have a\n\t * FAILED portal (eg, a cursor that got an error), we'd better clean up\n\t * its resources to avoid resource-leakage warning messages.\n\t *\n\t * Sub transaction commit: never comes here at all, since we don't kill\n\t * any portals in AtSubCommit_Portals().\n\t *\n\t * Main or sub transaction abort: we will do nothing here because\n\t * portal->resowner was already set NULL; the resources were already\n\t * cleaned up in transaction abort.\n\t *\n\t * Ordinary portal drop: must release resources.  However, if the portal\n\t * is not FAILED then we do not release its locks.  The locks become the\n\t * responsibility of the transaction's ResourceOwner (since it is the\n\t * parent of the portal's owner) and will be released when the transaction\n\t * eventually ends.\n\t */\n\tif (portal->resowner &&\n\t\t(!isTopCommit || portal->status == PORTAL_FAILED))\n\t{\n\t\tbool\t\tisCommit = (portal->status != PORTAL_FAILED);\n\n\t\tResourceOwnerRelease(portal->resowner,\n\t\t\t\t\t\t\t RESOURCE_RELEASE_BEFORE_LOCKS,\n\t\t\t\t\t\t\t isCommit, false);\n\t\tResourceOwnerRelease(portal->resowner,\n\t\t\t\t\t\t\t RESOURCE_RELEASE_LOCKS,\n\t\t\t\t\t\t\t isCommit, false);\n\t\tResourceOwnerRelease(portal->resowner,\n\t\t\t\t\t\t\t RESOURCE_RELEASE_AFTER_LOCKS,\n\t\t\t\t\t\t\t isCommit, false);\n\t\tResourceOwnerDelete(portal->resowner);\n\t}\n\tportal->resowner = NULL;\n\n\t/*\n\t * Delete tuplestore if present.  We should do this even under error\n\t * conditions; since the tuplestore would have been using cross-\n\t * transaction storage, its temp files need to be explicitly deleted.\n\t */\n\tif (portal->holdStore)\n\t{\n\t\tMemoryContext oldcontext;\n\n\t\toldcontext = MemoryContextSwitchTo(portal->holdContext);\n\t\ttuplestore_end(portal->holdStore);\n\t\tMemoryContextSwitchTo(oldcontext);\n\t\tportal->holdStore = NULL;\n\t}\n\n\t/* delete tuplestore storage, if any */\n\tif (portal->holdContext)\n\t\tMemoryContextDelete(portal->holdContext);\n\n\t/* release subsidiary storage */\n\tMemoryContextDelete(portal->portalContext);\n\n\t/* release portal struct (it's in TopPortalContext) */\n\tpfree(portal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "WARNING",
            "\"skipping cleanup for portal \\\"%s\\\"\"",
            "portal->name"
          ],
          "line": 1109
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerIsValid",
          "args": [
            "portal->cleanup"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_seq_search",
          "args": [
            "&status"
          ],
          "line": 1088
        },
        "resolved": true,
        "details": {
          "function_name": "hash_seq_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "1388-1462",
          "snippet": "void *\nhash_seq_search(HASH_SEQ_STATUS *status)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\tuint32\t\tmax_bucket;\n\tlong\t\tssize;\n\tlong\t\tsegment_num;\n\tlong\t\tsegment_ndx;\n\tHASHSEGMENT segp;\n\tuint32\t\tcurBucket;\n\tHASHELEMENT *curElem;\n\n\tif ((curElem = status->curEntry) != NULL)\n\t{\n\t\t/* Continuing scan of curBucket... */\n\t\tstatus->curEntry = curElem->link;\n\t\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t\t++status->curBucket;\n\t\treturn (void *) ELEMENTKEY(curElem);\n\t}\n\n\t/*\n\t * Search for next nonempty bucket starting at curBucket.\n\t */\n\tcurBucket = status->curBucket;\n\thashp = status->hashp;\n\thctl = hashp->hctl;\n\tssize = hashp->ssize;\n\tmax_bucket = hctl->max_bucket;\n\n\tif (curBucket > max_bucket)\n\t{\n\t\thash_seq_term(status);\n\t\treturn NULL;\t\t\t/* search is done */\n\t}\n\n\t/*\n\t * first find the right segment in the table directory.\n\t */\n\tsegment_num = curBucket >> hashp->sshift;\n\tsegment_ndx = MOD(curBucket, ssize);\n\n\tsegp = hashp->dir[segment_num];\n\n\t/*\n\t * Pick up the first item in this bucket's chain.  If chain is not empty\n\t * we can begin searching it.  Otherwise we have to advance to find the\n\t * next nonempty bucket.  We try to optimize that case since searching a\n\t * near-empty hashtable has to iterate this loop a lot.\n\t */\n\twhile ((curElem = segp[segment_ndx]) == NULL)\n\t{\n\t\t/* empty bucket, advance to next */\n\t\tif (++curBucket > max_bucket)\n\t\t{\n\t\t\tstatus->curBucket = curBucket;\n\t\t\thash_seq_term(status);\n\t\t\treturn NULL;\t\t/* search is done */\n\t\t}\n\t\tif (++segment_ndx >= ssize)\n\t\t{\n\t\t\tsegment_num++;\n\t\t\tsegment_ndx = 0;\n\t\t\tsegp = hashp->dir[segment_num];\n\t\t}\n\t}\n\n\t/* Begin scan of curBucket... */\n\tstatus->curEntry = curElem->link;\n\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t++curBucket;\n\tstatus->curBucket = curBucket;\n\treturn (void *) ELEMENTKEY(curElem);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid *\nhash_seq_search(HASH_SEQ_STATUS *status)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\tuint32\t\tmax_bucket;\n\tlong\t\tssize;\n\tlong\t\tsegment_num;\n\tlong\t\tsegment_ndx;\n\tHASHSEGMENT segp;\n\tuint32\t\tcurBucket;\n\tHASHELEMENT *curElem;\n\n\tif ((curElem = status->curEntry) != NULL)\n\t{\n\t\t/* Continuing scan of curBucket... */\n\t\tstatus->curEntry = curElem->link;\n\t\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t\t++status->curBucket;\n\t\treturn (void *) ELEMENTKEY(curElem);\n\t}\n\n\t/*\n\t * Search for next nonempty bucket starting at curBucket.\n\t */\n\tcurBucket = status->curBucket;\n\thashp = status->hashp;\n\thctl = hashp->hctl;\n\tssize = hashp->ssize;\n\tmax_bucket = hctl->max_bucket;\n\n\tif (curBucket > max_bucket)\n\t{\n\t\thash_seq_term(status);\n\t\treturn NULL;\t\t\t/* search is done */\n\t}\n\n\t/*\n\t * first find the right segment in the table directory.\n\t */\n\tsegment_num = curBucket >> hashp->sshift;\n\tsegment_ndx = MOD(curBucket, ssize);\n\n\tsegp = hashp->dir[segment_num];\n\n\t/*\n\t * Pick up the first item in this bucket's chain.  If chain is not empty\n\t * we can begin searching it.  Otherwise we have to advance to find the\n\t * next nonempty bucket.  We try to optimize that case since searching a\n\t * near-empty hashtable has to iterate this loop a lot.\n\t */\n\twhile ((curElem = segp[segment_ndx]) == NULL)\n\t{\n\t\t/* empty bucket, advance to next */\n\t\tif (++curBucket > max_bucket)\n\t\t{\n\t\t\tstatus->curBucket = curBucket;\n\t\t\thash_seq_term(status);\n\t\t\treturn NULL;\t\t/* search is done */\n\t\t}\n\t\tif (++segment_ndx >= ssize)\n\t\t{\n\t\t\tsegment_num++;\n\t\t\tsegment_ndx = 0;\n\t\t\tsegp = hashp->dir[segment_num];\n\t\t}\n\t}\n\n\t/* Begin scan of curBucket... */\n\tstatus->curEntry = curElem->link;\n\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t++curBucket;\n\tstatus->curBucket = curBucket;\n\treturn (void *) ELEMENTKEY(curElem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_seq_init",
          "args": [
            "&status",
            "PortalHashTable"
          ],
          "line": 1086
        },
        "resolved": true,
        "details": {
          "function_name": "hash_seq_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "1378-1386",
          "snippet": "void\nhash_seq_init(HASH_SEQ_STATUS *status, HTAB *hashp)\n{\n\tstatus->hashp = hashp;\n\tstatus->curBucket = 0;\n\tstatus->curEntry = NULL;\n\tif (!hashp->frozen)\n\t\tregister_seq_scan(hashp);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid\nhash_seq_init(HASH_SEQ_STATUS *status, HTAB *hashp)\n{\n\tstatus->hashp = hashp;\n\tstatus->curBucket = 0;\n\tstatus->curEntry = NULL;\n\tif (!hashp->frozen)\n\t\tregister_seq_scan(hashp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/ipc.h\"\n#include \"miscadmin.h\"\n#include \"commands/portalcmds.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic HTAB *PortalHashTable = NULL;\n\nvoid\nAtSubCleanup_Portals(SubTransactionId mySubid)\n{\n\tHASH_SEQ_STATUS status;\n\tPortalHashEnt *hentry;\n\n\thash_seq_init(&status, PortalHashTable);\n\n\twhile ((hentry = (PortalHashEnt *) hash_seq_search(&status)) != NULL)\n\t{\n\t\tPortal\t\tportal = hentry->portal;\n\n\t\tif (portal->createSubid != mySubid)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * If a portal is still pinned, forcibly unpin it. PortalDrop will not\n\t\t * let us drop the portal otherwise. Whoever pinned the portal was\n\t\t * interrupted by the abort too and won't try to use it anymore.\n\t\t */\n\t\tif (portal->portalPinned)\n\t\t\tportal->portalPinned = false;\n\n\t\t/*\n\t\t * We had better not call any user-defined code during cleanup, so if\n\t\t * the cleanup hook hasn't been run yet, too bad; we'll just skip it.\n\t\t */\n\t\tif (PointerIsValid(portal->cleanup))\n\t\t{\n\t\t\telog(WARNING, \"skipping cleanup for portal \\\"%s\\\"\", portal->name);\n\t\t\tportal->cleanup = NULL;\n\t\t}\n\n\t\t/* Zap it. */\n\t\tPortalDrop(portal, false);\n\t}\n}"
  },
  {
    "function_name": "AtSubAbort_Portals",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/portalmem.c",
    "lines": "967-1072",
    "snippet": "void\nAtSubAbort_Portals(SubTransactionId mySubid,\n\t\t\t\t   SubTransactionId parentSubid,\n\t\t\t\t   ResourceOwner myXactOwner,\n\t\t\t\t   ResourceOwner parentXactOwner)\n{\n\tHASH_SEQ_STATUS status;\n\tPortalHashEnt *hentry;\n\n\thash_seq_init(&status, PortalHashTable);\n\n\twhile ((hentry = (PortalHashEnt *) hash_seq_search(&status)) != NULL)\n\t{\n\t\tPortal\t\tportal = hentry->portal;\n\n\t\t/* Was it created in this subtransaction? */\n\t\tif (portal->createSubid != mySubid)\n\t\t{\n\t\t\t/* No, but maybe it was used in this subtransaction? */\n\t\t\tif (portal->activeSubid == mySubid)\n\t\t\t{\n\t\t\t\t/* Maintain activeSubid until the portal is removed */\n\t\t\t\tportal->activeSubid = parentSubid;\n\n\t\t\t\t/*\n\t\t\t\t * A MarkPortalActive() caller ran an upper-level portal in\n\t\t\t\t * this subtransaction and left the portal ACTIVE.  This can't\n\t\t\t\t * happen, but force the portal into FAILED state for the same\n\t\t\t\t * reasons discussed below.\n\t\t\t\t *\n\t\t\t\t * We assume we can get away without forcing upper-level READY\n\t\t\t\t * portals to fail, even if they were run and then suspended.\n\t\t\t\t * In theory a suspended upper-level portal could have\n\t\t\t\t * acquired some references to objects that are about to be\n\t\t\t\t * destroyed, but there should be sufficient defenses against\n\t\t\t\t * such cases: the portal's original query cannot contain such\n\t\t\t\t * references, and any references within, say, cached plans of\n\t\t\t\t * PL/pgSQL functions are not from active queries and should\n\t\t\t\t * be protected by revalidation logic.\n\t\t\t\t */\n\t\t\t\tif (portal->status == PORTAL_ACTIVE)\n\t\t\t\t\tMarkPortalFailed(portal);\n\n\t\t\t\t/*\n\t\t\t\t * Also, if we failed it during the current subtransaction\n\t\t\t\t * (either just above, or earlier), reattach its resource\n\t\t\t\t * owner to the current subtransaction's resource owner, so\n\t\t\t\t * that any resources it still holds will be released while\n\t\t\t\t * cleaning up this subtransaction.  This prevents some corner\n\t\t\t\t * cases wherein we might get Asserts or worse while cleaning\n\t\t\t\t * up objects created during the current subtransaction\n\t\t\t\t * (because they're still referenced within this portal).\n\t\t\t\t */\n\t\t\t\tif (portal->status == PORTAL_FAILED && portal->resowner)\n\t\t\t\t{\n\t\t\t\t\tResourceOwnerNewParent(portal->resowner, myXactOwner);\n\t\t\t\t\tportal->resowner = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Done if it wasn't created in this subtransaction */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Force any live portals of my own subtransaction into FAILED state.\n\t\t * We have to do this because they might refer to objects created or\n\t\t * changed in the failed subtransaction, leading to crashes within\n\t\t * ExecutorEnd when portalcmds.c tries to close down the portal.\n\t\t * Currently, every MarkPortalActive() caller ensures it updates the\n\t\t * portal status again before relinquishing control, so ACTIVE can't\n\t\t * happen here.  If it does happen, dispose the portal like existing\n\t\t * MarkPortalActive() callers would.\n\t\t */\n\t\tif (portal->status == PORTAL_READY ||\n\t\t\tportal->status == PORTAL_ACTIVE)\n\t\t\tMarkPortalFailed(portal);\n\n\t\t/*\n\t\t * Allow portalcmds.c to clean up the state it knows about, if we\n\t\t * haven't already.\n\t\t */\n\t\tif (PointerIsValid(portal->cleanup))\n\t\t{\n\t\t\tportal->cleanup(portal);\n\t\t\tportal->cleanup = NULL;\n\t\t}\n\n\t\t/* drop cached plan reference, if any */\n\t\tPortalReleaseCachedPlan(portal);\n\n\t\t/*\n\t\t * Any resources belonging to the portal will be released in the\n\t\t * upcoming transaction-wide cleanup; they will be gone before we run\n\t\t * PortalDrop.\n\t\t */\n\t\tportal->resowner = NULL;\n\n\t\t/*\n\t\t * Although we can't delete the portal data structure proper, we can\n\t\t * release any memory in subsidiary contexts, such as executor state.\n\t\t * The cleanup hook was the last thing that might have needed data\n\t\t * there.\n\t\t */\n\t\tMemoryContextDeleteChildren(portal->portalContext);\n\t}\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/portalcmds.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static HTAB *PortalHashTable = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextDeleteChildren",
          "args": [
            "portal->portalContext"
          ],
          "line": 1070
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextDeleteChildren",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "255-266",
          "snippet": "void\nMemoryContextDeleteChildren(MemoryContext context)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\n\t/*\n\t * MemoryContextDelete will delink the child from me, so just iterate as\n\t * long as there is a child.\n\t */\n\twhile (context->firstchild != NULL)\n\t\tMemoryContextDelete(context->firstchild);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\nMemoryContextDeleteChildren(MemoryContext context)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\n\t/*\n\t * MemoryContextDelete will delink the child from me, so just iterate as\n\t * long as there is a child.\n\t */\n\twhile (context->firstchild != NULL)\n\t\tMemoryContextDelete(context->firstchild);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PortalReleaseCachedPlan",
          "args": [
            "portal"
          ],
          "line": 1055
        },
        "resolved": true,
        "details": {
          "function_name": "PortalReleaseCachedPlan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/portalmem.c",
          "lines": "306-321",
          "snippet": "static void\nPortalReleaseCachedPlan(Portal portal)\n{\n\tif (portal->cplan)\n\t{\n\t\tReleaseCachedPlan(portal->cplan, false);\n\t\tportal->cplan = NULL;\n\n\t\t/*\n\t\t * We must also clear portal->stmts which is now a dangling reference\n\t\t * to the cached plan's plan list.  This protects any code that might\n\t\t * try to examine the Portal later.\n\t\t */\n\t\tportal->stmts = NIL;\n\t}\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/portalcmds.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/ipc.h\"\n#include \"miscadmin.h\"\n#include \"commands/portalcmds.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic void\nPortalReleaseCachedPlan(Portal portal)\n{\n\tif (portal->cplan)\n\t{\n\t\tReleaseCachedPlan(portal->cplan, false);\n\t\tportal->cplan = NULL;\n\n\t\t/*\n\t\t * We must also clear portal->stmts which is now a dangling reference\n\t\t * to the cached plan's plan list.  This protects any code that might\n\t\t * try to examine the Portal later.\n\t\t */\n\t\tportal->stmts = NIL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "portal->cleanup",
          "args": [
            "portal"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerIsValid",
          "args": [
            "portal->cleanup"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MarkPortalFailed",
          "args": [
            "portal"
          ],
          "line": 1042
        },
        "resolved": true,
        "details": {
          "function_name": "MarkPortalFailed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/portalmem.c",
          "lines": "438-458",
          "snippet": "void\nMarkPortalFailed(Portal portal)\n{\n\t/* Perform the state transition */\n\tAssert(portal->status != PORTAL_DONE);\n\tportal->status = PORTAL_FAILED;\n\n\t/*\n\t * Allow portalcmds.c to clean up the state it knows about.  We might as\n\t * well do that now, since the portal can't be executed any more.\n\t *\n\t * In some cases involving cleanup of an already aborted transaction, this\n\t * is necessary, or we'd reach AtCleanup_Portals with the cleanup hook\n\t * still unexecuted.\n\t */\n\tif (PointerIsValid(portal->cleanup))\n\t{\n\t\tportal->cleanup(portal);\n\t\tportal->cleanup = NULL;\n\t}\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/portalcmds.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/ipc.h\"\n#include \"miscadmin.h\"\n#include \"commands/portalcmds.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nvoid\nMarkPortalFailed(Portal portal)\n{\n\t/* Perform the state transition */\n\tAssert(portal->status != PORTAL_DONE);\n\tportal->status = PORTAL_FAILED;\n\n\t/*\n\t * Allow portalcmds.c to clean up the state it knows about.  We might as\n\t * well do that now, since the portal can't be executed any more.\n\t *\n\t * In some cases involving cleanup of an already aborted transaction, this\n\t * is necessary, or we'd reach AtCleanup_Portals with the cleanup hook\n\t * still unexecuted.\n\t */\n\tif (PointerIsValid(portal->cleanup))\n\t{\n\t\tportal->cleanup(portal);\n\t\tportal->cleanup = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ResourceOwnerNewParent",
          "args": [
            "portal->resowner",
            "myXactOwner"
          ],
          "line": 1022
        },
        "resolved": true,
        "details": {
          "function_name": "ResourceOwnerNewParent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "743-780",
          "snippet": "void\nResourceOwnerNewParent(ResourceOwner owner,\n\t\t\t\t\t   ResourceOwner newparent)\n{\n\tResourceOwner oldparent = owner->parent;\n\n\tif (oldparent)\n\t{\n\t\tif (owner == oldparent->firstchild)\n\t\t\toldparent->firstchild = owner->nextchild;\n\t\telse\n\t\t{\n\t\t\tResourceOwner child;\n\n\t\t\tfor (child = oldparent->firstchild; child; child = child->nextchild)\n\t\t\t{\n\t\t\t\tif (owner == child->nextchild)\n\t\t\t\t{\n\t\t\t\t\tchild->nextchild = owner->nextchild;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (newparent)\n\t{\n\t\tAssert(owner != newparent);\n\t\towner->parent = newparent;\n\t\towner->nextchild = newparent->firstchild;\n\t\tnewparent->firstchild = owner;\n\t}\n\telse\n\t{\n\t\towner->parent = NULL;\n\t\towner->nextchild = NULL;\n\t}\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"jit/jit.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nResourceOwnerNewParent(ResourceOwner owner,\n\t\t\t\t\t   ResourceOwner newparent)\n{\n\tResourceOwner oldparent = owner->parent;\n\n\tif (oldparent)\n\t{\n\t\tif (owner == oldparent->firstchild)\n\t\t\toldparent->firstchild = owner->nextchild;\n\t\telse\n\t\t{\n\t\t\tResourceOwner child;\n\n\t\t\tfor (child = oldparent->firstchild; child; child = child->nextchild)\n\t\t\t{\n\t\t\t\tif (owner == child->nextchild)\n\t\t\t\t{\n\t\t\t\t\tchild->nextchild = owner->nextchild;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (newparent)\n\t{\n\t\tAssert(owner != newparent);\n\t\towner->parent = newparent;\n\t\towner->nextchild = newparent->firstchild;\n\t\tnewparent->firstchild = owner;\n\t}\n\telse\n\t{\n\t\towner->parent = NULL;\n\t\towner->nextchild = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_seq_search",
          "args": [
            "&status"
          ],
          "line": 978
        },
        "resolved": true,
        "details": {
          "function_name": "hash_seq_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "1388-1462",
          "snippet": "void *\nhash_seq_search(HASH_SEQ_STATUS *status)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\tuint32\t\tmax_bucket;\n\tlong\t\tssize;\n\tlong\t\tsegment_num;\n\tlong\t\tsegment_ndx;\n\tHASHSEGMENT segp;\n\tuint32\t\tcurBucket;\n\tHASHELEMENT *curElem;\n\n\tif ((curElem = status->curEntry) != NULL)\n\t{\n\t\t/* Continuing scan of curBucket... */\n\t\tstatus->curEntry = curElem->link;\n\t\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t\t++status->curBucket;\n\t\treturn (void *) ELEMENTKEY(curElem);\n\t}\n\n\t/*\n\t * Search for next nonempty bucket starting at curBucket.\n\t */\n\tcurBucket = status->curBucket;\n\thashp = status->hashp;\n\thctl = hashp->hctl;\n\tssize = hashp->ssize;\n\tmax_bucket = hctl->max_bucket;\n\n\tif (curBucket > max_bucket)\n\t{\n\t\thash_seq_term(status);\n\t\treturn NULL;\t\t\t/* search is done */\n\t}\n\n\t/*\n\t * first find the right segment in the table directory.\n\t */\n\tsegment_num = curBucket >> hashp->sshift;\n\tsegment_ndx = MOD(curBucket, ssize);\n\n\tsegp = hashp->dir[segment_num];\n\n\t/*\n\t * Pick up the first item in this bucket's chain.  If chain is not empty\n\t * we can begin searching it.  Otherwise we have to advance to find the\n\t * next nonempty bucket.  We try to optimize that case since searching a\n\t * near-empty hashtable has to iterate this loop a lot.\n\t */\n\twhile ((curElem = segp[segment_ndx]) == NULL)\n\t{\n\t\t/* empty bucket, advance to next */\n\t\tif (++curBucket > max_bucket)\n\t\t{\n\t\t\tstatus->curBucket = curBucket;\n\t\t\thash_seq_term(status);\n\t\t\treturn NULL;\t\t/* search is done */\n\t\t}\n\t\tif (++segment_ndx >= ssize)\n\t\t{\n\t\t\tsegment_num++;\n\t\t\tsegment_ndx = 0;\n\t\t\tsegp = hashp->dir[segment_num];\n\t\t}\n\t}\n\n\t/* Begin scan of curBucket... */\n\tstatus->curEntry = curElem->link;\n\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t++curBucket;\n\tstatus->curBucket = curBucket;\n\treturn (void *) ELEMENTKEY(curElem);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid *\nhash_seq_search(HASH_SEQ_STATUS *status)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\tuint32\t\tmax_bucket;\n\tlong\t\tssize;\n\tlong\t\tsegment_num;\n\tlong\t\tsegment_ndx;\n\tHASHSEGMENT segp;\n\tuint32\t\tcurBucket;\n\tHASHELEMENT *curElem;\n\n\tif ((curElem = status->curEntry) != NULL)\n\t{\n\t\t/* Continuing scan of curBucket... */\n\t\tstatus->curEntry = curElem->link;\n\t\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t\t++status->curBucket;\n\t\treturn (void *) ELEMENTKEY(curElem);\n\t}\n\n\t/*\n\t * Search for next nonempty bucket starting at curBucket.\n\t */\n\tcurBucket = status->curBucket;\n\thashp = status->hashp;\n\thctl = hashp->hctl;\n\tssize = hashp->ssize;\n\tmax_bucket = hctl->max_bucket;\n\n\tif (curBucket > max_bucket)\n\t{\n\t\thash_seq_term(status);\n\t\treturn NULL;\t\t\t/* search is done */\n\t}\n\n\t/*\n\t * first find the right segment in the table directory.\n\t */\n\tsegment_num = curBucket >> hashp->sshift;\n\tsegment_ndx = MOD(curBucket, ssize);\n\n\tsegp = hashp->dir[segment_num];\n\n\t/*\n\t * Pick up the first item in this bucket's chain.  If chain is not empty\n\t * we can begin searching it.  Otherwise we have to advance to find the\n\t * next nonempty bucket.  We try to optimize that case since searching a\n\t * near-empty hashtable has to iterate this loop a lot.\n\t */\n\twhile ((curElem = segp[segment_ndx]) == NULL)\n\t{\n\t\t/* empty bucket, advance to next */\n\t\tif (++curBucket > max_bucket)\n\t\t{\n\t\t\tstatus->curBucket = curBucket;\n\t\t\thash_seq_term(status);\n\t\t\treturn NULL;\t\t/* search is done */\n\t\t}\n\t\tif (++segment_ndx >= ssize)\n\t\t{\n\t\t\tsegment_num++;\n\t\t\tsegment_ndx = 0;\n\t\t\tsegp = hashp->dir[segment_num];\n\t\t}\n\t}\n\n\t/* Begin scan of curBucket... */\n\tstatus->curEntry = curElem->link;\n\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t++curBucket;\n\tstatus->curBucket = curBucket;\n\treturn (void *) ELEMENTKEY(curElem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_seq_init",
          "args": [
            "&status",
            "PortalHashTable"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "hash_seq_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "1378-1386",
          "snippet": "void\nhash_seq_init(HASH_SEQ_STATUS *status, HTAB *hashp)\n{\n\tstatus->hashp = hashp;\n\tstatus->curBucket = 0;\n\tstatus->curEntry = NULL;\n\tif (!hashp->frozen)\n\t\tregister_seq_scan(hashp);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid\nhash_seq_init(HASH_SEQ_STATUS *status, HTAB *hashp)\n{\n\tstatus->hashp = hashp;\n\tstatus->curBucket = 0;\n\tstatus->curEntry = NULL;\n\tif (!hashp->frozen)\n\t\tregister_seq_scan(hashp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/ipc.h\"\n#include \"miscadmin.h\"\n#include \"commands/portalcmds.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic HTAB *PortalHashTable = NULL;\n\nvoid\nAtSubAbort_Portals(SubTransactionId mySubid,\n\t\t\t\t   SubTransactionId parentSubid,\n\t\t\t\t   ResourceOwner myXactOwner,\n\t\t\t\t   ResourceOwner parentXactOwner)\n{\n\tHASH_SEQ_STATUS status;\n\tPortalHashEnt *hentry;\n\n\thash_seq_init(&status, PortalHashTable);\n\n\twhile ((hentry = (PortalHashEnt *) hash_seq_search(&status)) != NULL)\n\t{\n\t\tPortal\t\tportal = hentry->portal;\n\n\t\t/* Was it created in this subtransaction? */\n\t\tif (portal->createSubid != mySubid)\n\t\t{\n\t\t\t/* No, but maybe it was used in this subtransaction? */\n\t\t\tif (portal->activeSubid == mySubid)\n\t\t\t{\n\t\t\t\t/* Maintain activeSubid until the portal is removed */\n\t\t\t\tportal->activeSubid = parentSubid;\n\n\t\t\t\t/*\n\t\t\t\t * A MarkPortalActive() caller ran an upper-level portal in\n\t\t\t\t * this subtransaction and left the portal ACTIVE.  This can't\n\t\t\t\t * happen, but force the portal into FAILED state for the same\n\t\t\t\t * reasons discussed below.\n\t\t\t\t *\n\t\t\t\t * We assume we can get away without forcing upper-level READY\n\t\t\t\t * portals to fail, even if they were run and then suspended.\n\t\t\t\t * In theory a suspended upper-level portal could have\n\t\t\t\t * acquired some references to objects that are about to be\n\t\t\t\t * destroyed, but there should be sufficient defenses against\n\t\t\t\t * such cases: the portal's original query cannot contain such\n\t\t\t\t * references, and any references within, say, cached plans of\n\t\t\t\t * PL/pgSQL functions are not from active queries and should\n\t\t\t\t * be protected by revalidation logic.\n\t\t\t\t */\n\t\t\t\tif (portal->status == PORTAL_ACTIVE)\n\t\t\t\t\tMarkPortalFailed(portal);\n\n\t\t\t\t/*\n\t\t\t\t * Also, if we failed it during the current subtransaction\n\t\t\t\t * (either just above, or earlier), reattach its resource\n\t\t\t\t * owner to the current subtransaction's resource owner, so\n\t\t\t\t * that any resources it still holds will be released while\n\t\t\t\t * cleaning up this subtransaction.  This prevents some corner\n\t\t\t\t * cases wherein we might get Asserts or worse while cleaning\n\t\t\t\t * up objects created during the current subtransaction\n\t\t\t\t * (because they're still referenced within this portal).\n\t\t\t\t */\n\t\t\t\tif (portal->status == PORTAL_FAILED && portal->resowner)\n\t\t\t\t{\n\t\t\t\t\tResourceOwnerNewParent(portal->resowner, myXactOwner);\n\t\t\t\t\tportal->resowner = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Done if it wasn't created in this subtransaction */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Force any live portals of my own subtransaction into FAILED state.\n\t\t * We have to do this because they might refer to objects created or\n\t\t * changed in the failed subtransaction, leading to crashes within\n\t\t * ExecutorEnd when portalcmds.c tries to close down the portal.\n\t\t * Currently, every MarkPortalActive() caller ensures it updates the\n\t\t * portal status again before relinquishing control, so ACTIVE can't\n\t\t * happen here.  If it does happen, dispose the portal like existing\n\t\t * MarkPortalActive() callers would.\n\t\t */\n\t\tif (portal->status == PORTAL_READY ||\n\t\t\tportal->status == PORTAL_ACTIVE)\n\t\t\tMarkPortalFailed(portal);\n\n\t\t/*\n\t\t * Allow portalcmds.c to clean up the state it knows about, if we\n\t\t * haven't already.\n\t\t */\n\t\tif (PointerIsValid(portal->cleanup))\n\t\t{\n\t\t\tportal->cleanup(portal);\n\t\t\tportal->cleanup = NULL;\n\t\t}\n\n\t\t/* drop cached plan reference, if any */\n\t\tPortalReleaseCachedPlan(portal);\n\n\t\t/*\n\t\t * Any resources belonging to the portal will be released in the\n\t\t * upcoming transaction-wide cleanup; they will be gone before we run\n\t\t * PortalDrop.\n\t\t */\n\t\tportal->resowner = NULL;\n\n\t\t/*\n\t\t * Although we can't delete the portal data structure proper, we can\n\t\t * release any memory in subsidiary contexts, such as executor state.\n\t\t * The cleanup hook was the last thing that might have needed data\n\t\t * there.\n\t\t */\n\t\tMemoryContextDeleteChildren(portal->portalContext);\n\t}\n}"
  },
  {
    "function_name": "AtSubCommit_Portals",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/portalmem.c",
    "lines": "933-956",
    "snippet": "void\nAtSubCommit_Portals(SubTransactionId mySubid,\n\t\t\t\t\tSubTransactionId parentSubid,\n\t\t\t\t\tResourceOwner parentXactOwner)\n{\n\tHASH_SEQ_STATUS status;\n\tPortalHashEnt *hentry;\n\n\thash_seq_init(&status, PortalHashTable);\n\n\twhile ((hentry = (PortalHashEnt *) hash_seq_search(&status)) != NULL)\n\t{\n\t\tPortal\t\tportal = hentry->portal;\n\n\t\tif (portal->createSubid == mySubid)\n\t\t{\n\t\t\tportal->createSubid = parentSubid;\n\t\t\tif (portal->resowner)\n\t\t\t\tResourceOwnerNewParent(portal->resowner, parentXactOwner);\n\t\t}\n\t\tif (portal->activeSubid == mySubid)\n\t\t\tportal->activeSubid = parentSubid;\n\t}\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/portalcmds.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static HTAB *PortalHashTable = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ResourceOwnerNewParent",
          "args": [
            "portal->resowner",
            "parentXactOwner"
          ],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "ResourceOwnerNewParent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "743-780",
          "snippet": "void\nResourceOwnerNewParent(ResourceOwner owner,\n\t\t\t\t\t   ResourceOwner newparent)\n{\n\tResourceOwner oldparent = owner->parent;\n\n\tif (oldparent)\n\t{\n\t\tif (owner == oldparent->firstchild)\n\t\t\toldparent->firstchild = owner->nextchild;\n\t\telse\n\t\t{\n\t\t\tResourceOwner child;\n\n\t\t\tfor (child = oldparent->firstchild; child; child = child->nextchild)\n\t\t\t{\n\t\t\t\tif (owner == child->nextchild)\n\t\t\t\t{\n\t\t\t\t\tchild->nextchild = owner->nextchild;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (newparent)\n\t{\n\t\tAssert(owner != newparent);\n\t\towner->parent = newparent;\n\t\towner->nextchild = newparent->firstchild;\n\t\tnewparent->firstchild = owner;\n\t}\n\telse\n\t{\n\t\towner->parent = NULL;\n\t\towner->nextchild = NULL;\n\t}\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"jit/jit.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nResourceOwnerNewParent(ResourceOwner owner,\n\t\t\t\t\t   ResourceOwner newparent)\n{\n\tResourceOwner oldparent = owner->parent;\n\n\tif (oldparent)\n\t{\n\t\tif (owner == oldparent->firstchild)\n\t\t\toldparent->firstchild = owner->nextchild;\n\t\telse\n\t\t{\n\t\t\tResourceOwner child;\n\n\t\t\tfor (child = oldparent->firstchild; child; child = child->nextchild)\n\t\t\t{\n\t\t\t\tif (owner == child->nextchild)\n\t\t\t\t{\n\t\t\t\t\tchild->nextchild = owner->nextchild;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (newparent)\n\t{\n\t\tAssert(owner != newparent);\n\t\towner->parent = newparent;\n\t\towner->nextchild = newparent->firstchild;\n\t\tnewparent->firstchild = owner;\n\t}\n\telse\n\t{\n\t\towner->parent = NULL;\n\t\towner->nextchild = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_seq_search",
          "args": [
            "&status"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "hash_seq_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "1388-1462",
          "snippet": "void *\nhash_seq_search(HASH_SEQ_STATUS *status)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\tuint32\t\tmax_bucket;\n\tlong\t\tssize;\n\tlong\t\tsegment_num;\n\tlong\t\tsegment_ndx;\n\tHASHSEGMENT segp;\n\tuint32\t\tcurBucket;\n\tHASHELEMENT *curElem;\n\n\tif ((curElem = status->curEntry) != NULL)\n\t{\n\t\t/* Continuing scan of curBucket... */\n\t\tstatus->curEntry = curElem->link;\n\t\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t\t++status->curBucket;\n\t\treturn (void *) ELEMENTKEY(curElem);\n\t}\n\n\t/*\n\t * Search for next nonempty bucket starting at curBucket.\n\t */\n\tcurBucket = status->curBucket;\n\thashp = status->hashp;\n\thctl = hashp->hctl;\n\tssize = hashp->ssize;\n\tmax_bucket = hctl->max_bucket;\n\n\tif (curBucket > max_bucket)\n\t{\n\t\thash_seq_term(status);\n\t\treturn NULL;\t\t\t/* search is done */\n\t}\n\n\t/*\n\t * first find the right segment in the table directory.\n\t */\n\tsegment_num = curBucket >> hashp->sshift;\n\tsegment_ndx = MOD(curBucket, ssize);\n\n\tsegp = hashp->dir[segment_num];\n\n\t/*\n\t * Pick up the first item in this bucket's chain.  If chain is not empty\n\t * we can begin searching it.  Otherwise we have to advance to find the\n\t * next nonempty bucket.  We try to optimize that case since searching a\n\t * near-empty hashtable has to iterate this loop a lot.\n\t */\n\twhile ((curElem = segp[segment_ndx]) == NULL)\n\t{\n\t\t/* empty bucket, advance to next */\n\t\tif (++curBucket > max_bucket)\n\t\t{\n\t\t\tstatus->curBucket = curBucket;\n\t\t\thash_seq_term(status);\n\t\t\treturn NULL;\t\t/* search is done */\n\t\t}\n\t\tif (++segment_ndx >= ssize)\n\t\t{\n\t\t\tsegment_num++;\n\t\t\tsegment_ndx = 0;\n\t\t\tsegp = hashp->dir[segment_num];\n\t\t}\n\t}\n\n\t/* Begin scan of curBucket... */\n\tstatus->curEntry = curElem->link;\n\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t++curBucket;\n\tstatus->curBucket = curBucket;\n\treturn (void *) ELEMENTKEY(curElem);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid *\nhash_seq_search(HASH_SEQ_STATUS *status)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\tuint32\t\tmax_bucket;\n\tlong\t\tssize;\n\tlong\t\tsegment_num;\n\tlong\t\tsegment_ndx;\n\tHASHSEGMENT segp;\n\tuint32\t\tcurBucket;\n\tHASHELEMENT *curElem;\n\n\tif ((curElem = status->curEntry) != NULL)\n\t{\n\t\t/* Continuing scan of curBucket... */\n\t\tstatus->curEntry = curElem->link;\n\t\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t\t++status->curBucket;\n\t\treturn (void *) ELEMENTKEY(curElem);\n\t}\n\n\t/*\n\t * Search for next nonempty bucket starting at curBucket.\n\t */\n\tcurBucket = status->curBucket;\n\thashp = status->hashp;\n\thctl = hashp->hctl;\n\tssize = hashp->ssize;\n\tmax_bucket = hctl->max_bucket;\n\n\tif (curBucket > max_bucket)\n\t{\n\t\thash_seq_term(status);\n\t\treturn NULL;\t\t\t/* search is done */\n\t}\n\n\t/*\n\t * first find the right segment in the table directory.\n\t */\n\tsegment_num = curBucket >> hashp->sshift;\n\tsegment_ndx = MOD(curBucket, ssize);\n\n\tsegp = hashp->dir[segment_num];\n\n\t/*\n\t * Pick up the first item in this bucket's chain.  If chain is not empty\n\t * we can begin searching it.  Otherwise we have to advance to find the\n\t * next nonempty bucket.  We try to optimize that case since searching a\n\t * near-empty hashtable has to iterate this loop a lot.\n\t */\n\twhile ((curElem = segp[segment_ndx]) == NULL)\n\t{\n\t\t/* empty bucket, advance to next */\n\t\tif (++curBucket > max_bucket)\n\t\t{\n\t\t\tstatus->curBucket = curBucket;\n\t\t\thash_seq_term(status);\n\t\t\treturn NULL;\t\t/* search is done */\n\t\t}\n\t\tif (++segment_ndx >= ssize)\n\t\t{\n\t\t\tsegment_num++;\n\t\t\tsegment_ndx = 0;\n\t\t\tsegp = hashp->dir[segment_num];\n\t\t}\n\t}\n\n\t/* Begin scan of curBucket... */\n\tstatus->curEntry = curElem->link;\n\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t++curBucket;\n\tstatus->curBucket = curBucket;\n\treturn (void *) ELEMENTKEY(curElem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_seq_init",
          "args": [
            "&status",
            "PortalHashTable"
          ],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "hash_seq_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "1378-1386",
          "snippet": "void\nhash_seq_init(HASH_SEQ_STATUS *status, HTAB *hashp)\n{\n\tstatus->hashp = hashp;\n\tstatus->curBucket = 0;\n\tstatus->curEntry = NULL;\n\tif (!hashp->frozen)\n\t\tregister_seq_scan(hashp);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid\nhash_seq_init(HASH_SEQ_STATUS *status, HTAB *hashp)\n{\n\tstatus->hashp = hashp;\n\tstatus->curBucket = 0;\n\tstatus->curEntry = NULL;\n\tif (!hashp->frozen)\n\t\tregister_seq_scan(hashp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/ipc.h\"\n#include \"miscadmin.h\"\n#include \"commands/portalcmds.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic HTAB *PortalHashTable = NULL;\n\nvoid\nAtSubCommit_Portals(SubTransactionId mySubid,\n\t\t\t\t\tSubTransactionId parentSubid,\n\t\t\t\t\tResourceOwner parentXactOwner)\n{\n\tHASH_SEQ_STATUS status;\n\tPortalHashEnt *hentry;\n\n\thash_seq_init(&status, PortalHashTable);\n\n\twhile ((hentry = (PortalHashEnt *) hash_seq_search(&status)) != NULL)\n\t{\n\t\tPortal\t\tportal = hentry->portal;\n\n\t\tif (portal->createSubid == mySubid)\n\t\t{\n\t\t\tportal->createSubid = parentSubid;\n\t\t\tif (portal->resowner)\n\t\t\t\tResourceOwnerNewParent(portal->resowner, parentXactOwner);\n\t\t}\n\t\tif (portal->activeSubid == mySubid)\n\t\t\tportal->activeSubid = parentSubid;\n\t}\n}"
  },
  {
    "function_name": "PortalErrorCleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/portalmem.c",
    "lines": "907-925",
    "snippet": "void\nPortalErrorCleanup(void)\n{\n\tHASH_SEQ_STATUS status;\n\tPortalHashEnt *hentry;\n\n\thash_seq_init(&status, PortalHashTable);\n\n\twhile ((hentry = (PortalHashEnt *) hash_seq_search(&status)) != NULL)\n\t{\n\t\tPortal\t\tportal = hentry->portal;\n\n\t\tif (portal->autoHeld)\n\t\t{\n\t\t\tportal->portalPinned = false;\n\t\t\tPortalDrop(portal, false);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/portalcmds.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static HTAB *PortalHashTable = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PortalDrop",
          "args": [
            "portal",
            "false"
          ],
          "line": 922
        },
        "resolved": true,
        "details": {
          "function_name": "PortalDrop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/portalmem.c",
          "lines": "464-593",
          "snippet": "void\nPortalDrop(Portal portal, bool isTopCommit)\n{\n\tAssertArg(PortalIsValid(portal));\n\n\t/*\n\t * Don't allow dropping a pinned portal, it's still needed by whoever\n\t * pinned it.\n\t */\n\tif (portal->portalPinned)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_CURSOR_STATE),\n\t\t\t\t errmsg(\"cannot drop pinned portal \\\"%s\\\"\", portal->name)));\n\n\t/*\n\t * Not sure if the PORTAL_ACTIVE case can validly happen or not...\n\t */\n\tif (portal->status == PORTAL_ACTIVE)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_CURSOR_STATE),\n\t\t\t\t errmsg(\"cannot drop active portal \\\"%s\\\"\", portal->name)));\n\n\t/*\n\t * Allow portalcmds.c to clean up the state it knows about, in particular\n\t * shutting down the executor if still active.  This step potentially runs\n\t * user-defined code so failure has to be expected.  It's the cleanup\n\t * hook's responsibility to not try to do that more than once, in the case\n\t * that failure occurs and then we come back to drop the portal again\n\t * during transaction abort.\n\t *\n\t * Note: in most paths of control, this will have been done already in\n\t * MarkPortalDone or MarkPortalFailed.  We're just making sure.\n\t */\n\tif (PointerIsValid(portal->cleanup))\n\t{\n\t\tportal->cleanup(portal);\n\t\tportal->cleanup = NULL;\n\t}\n\n\t/*\n\t * Remove portal from hash table.  Because we do this here, we will not\n\t * come back to try to remove the portal again if there's any error in the\n\t * subsequent steps.  Better to leak a little memory than to get into an\n\t * infinite error-recovery loop.\n\t */\n\tPortalHashTableDelete(portal);\n\n\t/* drop cached plan reference, if any */\n\tPortalReleaseCachedPlan(portal);\n\n\t/*\n\t * If portal has a snapshot protecting its data, release that.  This needs\n\t * a little care since the registration will be attached to the portal's\n\t * resowner; if the portal failed, we will already have released the\n\t * resowner (and the snapshot) during transaction abort.\n\t */\n\tif (portal->holdSnapshot)\n\t{\n\t\tif (portal->resowner)\n\t\t\tUnregisterSnapshotFromOwner(portal->holdSnapshot,\n\t\t\t\t\t\t\t\t\t\tportal->resowner);\n\t\tportal->holdSnapshot = NULL;\n\t}\n\n\t/*\n\t * Release any resources still attached to the portal.  There are several\n\t * cases being covered here:\n\t *\n\t * Top transaction commit (indicated by isTopCommit): normally we should\n\t * do nothing here and let the regular end-of-transaction resource\n\t * releasing mechanism handle these resources too.  However, if we have a\n\t * FAILED portal (eg, a cursor that got an error), we'd better clean up\n\t * its resources to avoid resource-leakage warning messages.\n\t *\n\t * Sub transaction commit: never comes here at all, since we don't kill\n\t * any portals in AtSubCommit_Portals().\n\t *\n\t * Main or sub transaction abort: we will do nothing here because\n\t * portal->resowner was already set NULL; the resources were already\n\t * cleaned up in transaction abort.\n\t *\n\t * Ordinary portal drop: must release resources.  However, if the portal\n\t * is not FAILED then we do not release its locks.  The locks become the\n\t * responsibility of the transaction's ResourceOwner (since it is the\n\t * parent of the portal's owner) and will be released when the transaction\n\t * eventually ends.\n\t */\n\tif (portal->resowner &&\n\t\t(!isTopCommit || portal->status == PORTAL_FAILED))\n\t{\n\t\tbool\t\tisCommit = (portal->status != PORTAL_FAILED);\n\n\t\tResourceOwnerRelease(portal->resowner,\n\t\t\t\t\t\t\t RESOURCE_RELEASE_BEFORE_LOCKS,\n\t\t\t\t\t\t\t isCommit, false);\n\t\tResourceOwnerRelease(portal->resowner,\n\t\t\t\t\t\t\t RESOURCE_RELEASE_LOCKS,\n\t\t\t\t\t\t\t isCommit, false);\n\t\tResourceOwnerRelease(portal->resowner,\n\t\t\t\t\t\t\t RESOURCE_RELEASE_AFTER_LOCKS,\n\t\t\t\t\t\t\t isCommit, false);\n\t\tResourceOwnerDelete(portal->resowner);\n\t}\n\tportal->resowner = NULL;\n\n\t/*\n\t * Delete tuplestore if present.  We should do this even under error\n\t * conditions; since the tuplestore would have been using cross-\n\t * transaction storage, its temp files need to be explicitly deleted.\n\t */\n\tif (portal->holdStore)\n\t{\n\t\tMemoryContext oldcontext;\n\n\t\toldcontext = MemoryContextSwitchTo(portal->holdContext);\n\t\ttuplestore_end(portal->holdStore);\n\t\tMemoryContextSwitchTo(oldcontext);\n\t\tportal->holdStore = NULL;\n\t}\n\n\t/* delete tuplestore storage, if any */\n\tif (portal->holdContext)\n\t\tMemoryContextDelete(portal->holdContext);\n\n\t/* release subsidiary storage */\n\tMemoryContextDelete(portal->portalContext);\n\n\t/* release portal struct (it's in TopPortalContext) */\n\tpfree(portal);\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/portalcmds.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static MemoryContext TopPortalContext = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/ipc.h\"\n#include \"miscadmin.h\"\n#include \"commands/portalcmds.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic MemoryContext TopPortalContext = NULL;\n\nvoid\nPortalDrop(Portal portal, bool isTopCommit)\n{\n\tAssertArg(PortalIsValid(portal));\n\n\t/*\n\t * Don't allow dropping a pinned portal, it's still needed by whoever\n\t * pinned it.\n\t */\n\tif (portal->portalPinned)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_CURSOR_STATE),\n\t\t\t\t errmsg(\"cannot drop pinned portal \\\"%s\\\"\", portal->name)));\n\n\t/*\n\t * Not sure if the PORTAL_ACTIVE case can validly happen or not...\n\t */\n\tif (portal->status == PORTAL_ACTIVE)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_CURSOR_STATE),\n\t\t\t\t errmsg(\"cannot drop active portal \\\"%s\\\"\", portal->name)));\n\n\t/*\n\t * Allow portalcmds.c to clean up the state it knows about, in particular\n\t * shutting down the executor if still active.  This step potentially runs\n\t * user-defined code so failure has to be expected.  It's the cleanup\n\t * hook's responsibility to not try to do that more than once, in the case\n\t * that failure occurs and then we come back to drop the portal again\n\t * during transaction abort.\n\t *\n\t * Note: in most paths of control, this will have been done already in\n\t * MarkPortalDone or MarkPortalFailed.  We're just making sure.\n\t */\n\tif (PointerIsValid(portal->cleanup))\n\t{\n\t\tportal->cleanup(portal);\n\t\tportal->cleanup = NULL;\n\t}\n\n\t/*\n\t * Remove portal from hash table.  Because we do this here, we will not\n\t * come back to try to remove the portal again if there's any error in the\n\t * subsequent steps.  Better to leak a little memory than to get into an\n\t * infinite error-recovery loop.\n\t */\n\tPortalHashTableDelete(portal);\n\n\t/* drop cached plan reference, if any */\n\tPortalReleaseCachedPlan(portal);\n\n\t/*\n\t * If portal has a snapshot protecting its data, release that.  This needs\n\t * a little care since the registration will be attached to the portal's\n\t * resowner; if the portal failed, we will already have released the\n\t * resowner (and the snapshot) during transaction abort.\n\t */\n\tif (portal->holdSnapshot)\n\t{\n\t\tif (portal->resowner)\n\t\t\tUnregisterSnapshotFromOwner(portal->holdSnapshot,\n\t\t\t\t\t\t\t\t\t\tportal->resowner);\n\t\tportal->holdSnapshot = NULL;\n\t}\n\n\t/*\n\t * Release any resources still attached to the portal.  There are several\n\t * cases being covered here:\n\t *\n\t * Top transaction commit (indicated by isTopCommit): normally we should\n\t * do nothing here and let the regular end-of-transaction resource\n\t * releasing mechanism handle these resources too.  However, if we have a\n\t * FAILED portal (eg, a cursor that got an error), we'd better clean up\n\t * its resources to avoid resource-leakage warning messages.\n\t *\n\t * Sub transaction commit: never comes here at all, since we don't kill\n\t * any portals in AtSubCommit_Portals().\n\t *\n\t * Main or sub transaction abort: we will do nothing here because\n\t * portal->resowner was already set NULL; the resources were already\n\t * cleaned up in transaction abort.\n\t *\n\t * Ordinary portal drop: must release resources.  However, if the portal\n\t * is not FAILED then we do not release its locks.  The locks become the\n\t * responsibility of the transaction's ResourceOwner (since it is the\n\t * parent of the portal's owner) and will be released when the transaction\n\t * eventually ends.\n\t */\n\tif (portal->resowner &&\n\t\t(!isTopCommit || portal->status == PORTAL_FAILED))\n\t{\n\t\tbool\t\tisCommit = (portal->status != PORTAL_FAILED);\n\n\t\tResourceOwnerRelease(portal->resowner,\n\t\t\t\t\t\t\t RESOURCE_RELEASE_BEFORE_LOCKS,\n\t\t\t\t\t\t\t isCommit, false);\n\t\tResourceOwnerRelease(portal->resowner,\n\t\t\t\t\t\t\t RESOURCE_RELEASE_LOCKS,\n\t\t\t\t\t\t\t isCommit, false);\n\t\tResourceOwnerRelease(portal->resowner,\n\t\t\t\t\t\t\t RESOURCE_RELEASE_AFTER_LOCKS,\n\t\t\t\t\t\t\t isCommit, false);\n\t\tResourceOwnerDelete(portal->resowner);\n\t}\n\tportal->resowner = NULL;\n\n\t/*\n\t * Delete tuplestore if present.  We should do this even under error\n\t * conditions; since the tuplestore would have been using cross-\n\t * transaction storage, its temp files need to be explicitly deleted.\n\t */\n\tif (portal->holdStore)\n\t{\n\t\tMemoryContext oldcontext;\n\n\t\toldcontext = MemoryContextSwitchTo(portal->holdContext);\n\t\ttuplestore_end(portal->holdStore);\n\t\tMemoryContextSwitchTo(oldcontext);\n\t\tportal->holdStore = NULL;\n\t}\n\n\t/* delete tuplestore storage, if any */\n\tif (portal->holdContext)\n\t\tMemoryContextDelete(portal->holdContext);\n\n\t/* release subsidiary storage */\n\tMemoryContextDelete(portal->portalContext);\n\n\t/* release portal struct (it's in TopPortalContext) */\n\tpfree(portal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_seq_search",
          "args": [
            "&status"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "hash_seq_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "1388-1462",
          "snippet": "void *\nhash_seq_search(HASH_SEQ_STATUS *status)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\tuint32\t\tmax_bucket;\n\tlong\t\tssize;\n\tlong\t\tsegment_num;\n\tlong\t\tsegment_ndx;\n\tHASHSEGMENT segp;\n\tuint32\t\tcurBucket;\n\tHASHELEMENT *curElem;\n\n\tif ((curElem = status->curEntry) != NULL)\n\t{\n\t\t/* Continuing scan of curBucket... */\n\t\tstatus->curEntry = curElem->link;\n\t\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t\t++status->curBucket;\n\t\treturn (void *) ELEMENTKEY(curElem);\n\t}\n\n\t/*\n\t * Search for next nonempty bucket starting at curBucket.\n\t */\n\tcurBucket = status->curBucket;\n\thashp = status->hashp;\n\thctl = hashp->hctl;\n\tssize = hashp->ssize;\n\tmax_bucket = hctl->max_bucket;\n\n\tif (curBucket > max_bucket)\n\t{\n\t\thash_seq_term(status);\n\t\treturn NULL;\t\t\t/* search is done */\n\t}\n\n\t/*\n\t * first find the right segment in the table directory.\n\t */\n\tsegment_num = curBucket >> hashp->sshift;\n\tsegment_ndx = MOD(curBucket, ssize);\n\n\tsegp = hashp->dir[segment_num];\n\n\t/*\n\t * Pick up the first item in this bucket's chain.  If chain is not empty\n\t * we can begin searching it.  Otherwise we have to advance to find the\n\t * next nonempty bucket.  We try to optimize that case since searching a\n\t * near-empty hashtable has to iterate this loop a lot.\n\t */\n\twhile ((curElem = segp[segment_ndx]) == NULL)\n\t{\n\t\t/* empty bucket, advance to next */\n\t\tif (++curBucket > max_bucket)\n\t\t{\n\t\t\tstatus->curBucket = curBucket;\n\t\t\thash_seq_term(status);\n\t\t\treturn NULL;\t\t/* search is done */\n\t\t}\n\t\tif (++segment_ndx >= ssize)\n\t\t{\n\t\t\tsegment_num++;\n\t\t\tsegment_ndx = 0;\n\t\t\tsegp = hashp->dir[segment_num];\n\t\t}\n\t}\n\n\t/* Begin scan of curBucket... */\n\tstatus->curEntry = curElem->link;\n\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t++curBucket;\n\tstatus->curBucket = curBucket;\n\treturn (void *) ELEMENTKEY(curElem);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid *\nhash_seq_search(HASH_SEQ_STATUS *status)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\tuint32\t\tmax_bucket;\n\tlong\t\tssize;\n\tlong\t\tsegment_num;\n\tlong\t\tsegment_ndx;\n\tHASHSEGMENT segp;\n\tuint32\t\tcurBucket;\n\tHASHELEMENT *curElem;\n\n\tif ((curElem = status->curEntry) != NULL)\n\t{\n\t\t/* Continuing scan of curBucket... */\n\t\tstatus->curEntry = curElem->link;\n\t\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t\t++status->curBucket;\n\t\treturn (void *) ELEMENTKEY(curElem);\n\t}\n\n\t/*\n\t * Search for next nonempty bucket starting at curBucket.\n\t */\n\tcurBucket = status->curBucket;\n\thashp = status->hashp;\n\thctl = hashp->hctl;\n\tssize = hashp->ssize;\n\tmax_bucket = hctl->max_bucket;\n\n\tif (curBucket > max_bucket)\n\t{\n\t\thash_seq_term(status);\n\t\treturn NULL;\t\t\t/* search is done */\n\t}\n\n\t/*\n\t * first find the right segment in the table directory.\n\t */\n\tsegment_num = curBucket >> hashp->sshift;\n\tsegment_ndx = MOD(curBucket, ssize);\n\n\tsegp = hashp->dir[segment_num];\n\n\t/*\n\t * Pick up the first item in this bucket's chain.  If chain is not empty\n\t * we can begin searching it.  Otherwise we have to advance to find the\n\t * next nonempty bucket.  We try to optimize that case since searching a\n\t * near-empty hashtable has to iterate this loop a lot.\n\t */\n\twhile ((curElem = segp[segment_ndx]) == NULL)\n\t{\n\t\t/* empty bucket, advance to next */\n\t\tif (++curBucket > max_bucket)\n\t\t{\n\t\t\tstatus->curBucket = curBucket;\n\t\t\thash_seq_term(status);\n\t\t\treturn NULL;\t\t/* search is done */\n\t\t}\n\t\tif (++segment_ndx >= ssize)\n\t\t{\n\t\t\tsegment_num++;\n\t\t\tsegment_ndx = 0;\n\t\t\tsegp = hashp->dir[segment_num];\n\t\t}\n\t}\n\n\t/* Begin scan of curBucket... */\n\tstatus->curEntry = curElem->link;\n\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t++curBucket;\n\tstatus->curBucket = curBucket;\n\treturn (void *) ELEMENTKEY(curElem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_seq_init",
          "args": [
            "&status",
            "PortalHashTable"
          ],
          "line": 913
        },
        "resolved": true,
        "details": {
          "function_name": "hash_seq_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "1378-1386",
          "snippet": "void\nhash_seq_init(HASH_SEQ_STATUS *status, HTAB *hashp)\n{\n\tstatus->hashp = hashp;\n\tstatus->curBucket = 0;\n\tstatus->curEntry = NULL;\n\tif (!hashp->frozen)\n\t\tregister_seq_scan(hashp);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid\nhash_seq_init(HASH_SEQ_STATUS *status, HTAB *hashp)\n{\n\tstatus->hashp = hashp;\n\tstatus->curBucket = 0;\n\tstatus->curEntry = NULL;\n\tif (!hashp->frozen)\n\t\tregister_seq_scan(hashp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/ipc.h\"\n#include \"miscadmin.h\"\n#include \"commands/portalcmds.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic HTAB *PortalHashTable = NULL;\n\nvoid\nPortalErrorCleanup(void)\n{\n\tHASH_SEQ_STATUS status;\n\tPortalHashEnt *hentry;\n\n\thash_seq_init(&status, PortalHashTable);\n\n\twhile ((hentry = (PortalHashEnt *) hash_seq_search(&status)) != NULL)\n\t{\n\t\tPortal\t\tportal = hentry->portal;\n\n\t\tif (portal->autoHeld)\n\t\t{\n\t\t\tportal->portalPinned = false;\n\t\t\tPortalDrop(portal, false);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "AtCleanup_Portals",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/portalmem.c",
    "lines": "848-899",
    "snippet": "void\nAtCleanup_Portals(void)\n{\n\tHASH_SEQ_STATUS status;\n\tPortalHashEnt *hentry;\n\n\thash_seq_init(&status, PortalHashTable);\n\n\twhile ((hentry = (PortalHashEnt *) hash_seq_search(&status)) != NULL)\n\t{\n\t\tPortal\t\tportal = hentry->portal;\n\n\t\t/*\n\t\t * Do not touch active portals --- this can only happen in the case of\n\t\t * a multi-transaction command.\n\t\t */\n\t\tif (portal->status == PORTAL_ACTIVE)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Do nothing to cursors held over from a previous transaction or\n\t\t * auto-held ones.\n\t\t */\n\t\tif (portal->createSubid == InvalidSubTransactionId || portal->autoHeld)\n\t\t{\n\t\t\tAssert(portal->status != PORTAL_ACTIVE);\n\t\t\tAssert(portal->resowner == NULL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If a portal is still pinned, forcibly unpin it. PortalDrop will not\n\t\t * let us drop the portal otherwise. Whoever pinned the portal was\n\t\t * interrupted by the abort too and won't try to use it anymore.\n\t\t */\n\t\tif (portal->portalPinned)\n\t\t\tportal->portalPinned = false;\n\n\t\t/*\n\t\t * We had better not call any user-defined code during cleanup, so if\n\t\t * the cleanup hook hasn't been run yet, too bad; we'll just skip it.\n\t\t */\n\t\tif (PointerIsValid(portal->cleanup))\n\t\t{\n\t\t\telog(WARNING, \"skipping cleanup for portal \\\"%s\\\"\", portal->name);\n\t\t\tportal->cleanup = NULL;\n\t\t}\n\n\t\t/* Zap it. */\n\t\tPortalDrop(portal, false);\n\t}\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/portalcmds.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static HTAB *PortalHashTable = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PortalDrop",
          "args": [
            "portal",
            "false"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "PortalDrop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/portalmem.c",
          "lines": "464-593",
          "snippet": "void\nPortalDrop(Portal portal, bool isTopCommit)\n{\n\tAssertArg(PortalIsValid(portal));\n\n\t/*\n\t * Don't allow dropping a pinned portal, it's still needed by whoever\n\t * pinned it.\n\t */\n\tif (portal->portalPinned)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_CURSOR_STATE),\n\t\t\t\t errmsg(\"cannot drop pinned portal \\\"%s\\\"\", portal->name)));\n\n\t/*\n\t * Not sure if the PORTAL_ACTIVE case can validly happen or not...\n\t */\n\tif (portal->status == PORTAL_ACTIVE)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_CURSOR_STATE),\n\t\t\t\t errmsg(\"cannot drop active portal \\\"%s\\\"\", portal->name)));\n\n\t/*\n\t * Allow portalcmds.c to clean up the state it knows about, in particular\n\t * shutting down the executor if still active.  This step potentially runs\n\t * user-defined code so failure has to be expected.  It's the cleanup\n\t * hook's responsibility to not try to do that more than once, in the case\n\t * that failure occurs and then we come back to drop the portal again\n\t * during transaction abort.\n\t *\n\t * Note: in most paths of control, this will have been done already in\n\t * MarkPortalDone or MarkPortalFailed.  We're just making sure.\n\t */\n\tif (PointerIsValid(portal->cleanup))\n\t{\n\t\tportal->cleanup(portal);\n\t\tportal->cleanup = NULL;\n\t}\n\n\t/*\n\t * Remove portal from hash table.  Because we do this here, we will not\n\t * come back to try to remove the portal again if there's any error in the\n\t * subsequent steps.  Better to leak a little memory than to get into an\n\t * infinite error-recovery loop.\n\t */\n\tPortalHashTableDelete(portal);\n\n\t/* drop cached plan reference, if any */\n\tPortalReleaseCachedPlan(portal);\n\n\t/*\n\t * If portal has a snapshot protecting its data, release that.  This needs\n\t * a little care since the registration will be attached to the portal's\n\t * resowner; if the portal failed, we will already have released the\n\t * resowner (and the snapshot) during transaction abort.\n\t */\n\tif (portal->holdSnapshot)\n\t{\n\t\tif (portal->resowner)\n\t\t\tUnregisterSnapshotFromOwner(portal->holdSnapshot,\n\t\t\t\t\t\t\t\t\t\tportal->resowner);\n\t\tportal->holdSnapshot = NULL;\n\t}\n\n\t/*\n\t * Release any resources still attached to the portal.  There are several\n\t * cases being covered here:\n\t *\n\t * Top transaction commit (indicated by isTopCommit): normally we should\n\t * do nothing here and let the regular end-of-transaction resource\n\t * releasing mechanism handle these resources too.  However, if we have a\n\t * FAILED portal (eg, a cursor that got an error), we'd better clean up\n\t * its resources to avoid resource-leakage warning messages.\n\t *\n\t * Sub transaction commit: never comes here at all, since we don't kill\n\t * any portals in AtSubCommit_Portals().\n\t *\n\t * Main or sub transaction abort: we will do nothing here because\n\t * portal->resowner was already set NULL; the resources were already\n\t * cleaned up in transaction abort.\n\t *\n\t * Ordinary portal drop: must release resources.  However, if the portal\n\t * is not FAILED then we do not release its locks.  The locks become the\n\t * responsibility of the transaction's ResourceOwner (since it is the\n\t * parent of the portal's owner) and will be released when the transaction\n\t * eventually ends.\n\t */\n\tif (portal->resowner &&\n\t\t(!isTopCommit || portal->status == PORTAL_FAILED))\n\t{\n\t\tbool\t\tisCommit = (portal->status != PORTAL_FAILED);\n\n\t\tResourceOwnerRelease(portal->resowner,\n\t\t\t\t\t\t\t RESOURCE_RELEASE_BEFORE_LOCKS,\n\t\t\t\t\t\t\t isCommit, false);\n\t\tResourceOwnerRelease(portal->resowner,\n\t\t\t\t\t\t\t RESOURCE_RELEASE_LOCKS,\n\t\t\t\t\t\t\t isCommit, false);\n\t\tResourceOwnerRelease(portal->resowner,\n\t\t\t\t\t\t\t RESOURCE_RELEASE_AFTER_LOCKS,\n\t\t\t\t\t\t\t isCommit, false);\n\t\tResourceOwnerDelete(portal->resowner);\n\t}\n\tportal->resowner = NULL;\n\n\t/*\n\t * Delete tuplestore if present.  We should do this even under error\n\t * conditions; since the tuplestore would have been using cross-\n\t * transaction storage, its temp files need to be explicitly deleted.\n\t */\n\tif (portal->holdStore)\n\t{\n\t\tMemoryContext oldcontext;\n\n\t\toldcontext = MemoryContextSwitchTo(portal->holdContext);\n\t\ttuplestore_end(portal->holdStore);\n\t\tMemoryContextSwitchTo(oldcontext);\n\t\tportal->holdStore = NULL;\n\t}\n\n\t/* delete tuplestore storage, if any */\n\tif (portal->holdContext)\n\t\tMemoryContextDelete(portal->holdContext);\n\n\t/* release subsidiary storage */\n\tMemoryContextDelete(portal->portalContext);\n\n\t/* release portal struct (it's in TopPortalContext) */\n\tpfree(portal);\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/portalcmds.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static MemoryContext TopPortalContext = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/ipc.h\"\n#include \"miscadmin.h\"\n#include \"commands/portalcmds.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic MemoryContext TopPortalContext = NULL;\n\nvoid\nPortalDrop(Portal portal, bool isTopCommit)\n{\n\tAssertArg(PortalIsValid(portal));\n\n\t/*\n\t * Don't allow dropping a pinned portal, it's still needed by whoever\n\t * pinned it.\n\t */\n\tif (portal->portalPinned)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_CURSOR_STATE),\n\t\t\t\t errmsg(\"cannot drop pinned portal \\\"%s\\\"\", portal->name)));\n\n\t/*\n\t * Not sure if the PORTAL_ACTIVE case can validly happen or not...\n\t */\n\tif (portal->status == PORTAL_ACTIVE)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_CURSOR_STATE),\n\t\t\t\t errmsg(\"cannot drop active portal \\\"%s\\\"\", portal->name)));\n\n\t/*\n\t * Allow portalcmds.c to clean up the state it knows about, in particular\n\t * shutting down the executor if still active.  This step potentially runs\n\t * user-defined code so failure has to be expected.  It's the cleanup\n\t * hook's responsibility to not try to do that more than once, in the case\n\t * that failure occurs and then we come back to drop the portal again\n\t * during transaction abort.\n\t *\n\t * Note: in most paths of control, this will have been done already in\n\t * MarkPortalDone or MarkPortalFailed.  We're just making sure.\n\t */\n\tif (PointerIsValid(portal->cleanup))\n\t{\n\t\tportal->cleanup(portal);\n\t\tportal->cleanup = NULL;\n\t}\n\n\t/*\n\t * Remove portal from hash table.  Because we do this here, we will not\n\t * come back to try to remove the portal again if there's any error in the\n\t * subsequent steps.  Better to leak a little memory than to get into an\n\t * infinite error-recovery loop.\n\t */\n\tPortalHashTableDelete(portal);\n\n\t/* drop cached plan reference, if any */\n\tPortalReleaseCachedPlan(portal);\n\n\t/*\n\t * If portal has a snapshot protecting its data, release that.  This needs\n\t * a little care since the registration will be attached to the portal's\n\t * resowner; if the portal failed, we will already have released the\n\t * resowner (and the snapshot) during transaction abort.\n\t */\n\tif (portal->holdSnapshot)\n\t{\n\t\tif (portal->resowner)\n\t\t\tUnregisterSnapshotFromOwner(portal->holdSnapshot,\n\t\t\t\t\t\t\t\t\t\tportal->resowner);\n\t\tportal->holdSnapshot = NULL;\n\t}\n\n\t/*\n\t * Release any resources still attached to the portal.  There are several\n\t * cases being covered here:\n\t *\n\t * Top transaction commit (indicated by isTopCommit): normally we should\n\t * do nothing here and let the regular end-of-transaction resource\n\t * releasing mechanism handle these resources too.  However, if we have a\n\t * FAILED portal (eg, a cursor that got an error), we'd better clean up\n\t * its resources to avoid resource-leakage warning messages.\n\t *\n\t * Sub transaction commit: never comes here at all, since we don't kill\n\t * any portals in AtSubCommit_Portals().\n\t *\n\t * Main or sub transaction abort: we will do nothing here because\n\t * portal->resowner was already set NULL; the resources were already\n\t * cleaned up in transaction abort.\n\t *\n\t * Ordinary portal drop: must release resources.  However, if the portal\n\t * is not FAILED then we do not release its locks.  The locks become the\n\t * responsibility of the transaction's ResourceOwner (since it is the\n\t * parent of the portal's owner) and will be released when the transaction\n\t * eventually ends.\n\t */\n\tif (portal->resowner &&\n\t\t(!isTopCommit || portal->status == PORTAL_FAILED))\n\t{\n\t\tbool\t\tisCommit = (portal->status != PORTAL_FAILED);\n\n\t\tResourceOwnerRelease(portal->resowner,\n\t\t\t\t\t\t\t RESOURCE_RELEASE_BEFORE_LOCKS,\n\t\t\t\t\t\t\t isCommit, false);\n\t\tResourceOwnerRelease(portal->resowner,\n\t\t\t\t\t\t\t RESOURCE_RELEASE_LOCKS,\n\t\t\t\t\t\t\t isCommit, false);\n\t\tResourceOwnerRelease(portal->resowner,\n\t\t\t\t\t\t\t RESOURCE_RELEASE_AFTER_LOCKS,\n\t\t\t\t\t\t\t isCommit, false);\n\t\tResourceOwnerDelete(portal->resowner);\n\t}\n\tportal->resowner = NULL;\n\n\t/*\n\t * Delete tuplestore if present.  We should do this even under error\n\t * conditions; since the tuplestore would have been using cross-\n\t * transaction storage, its temp files need to be explicitly deleted.\n\t */\n\tif (portal->holdStore)\n\t{\n\t\tMemoryContext oldcontext;\n\n\t\toldcontext = MemoryContextSwitchTo(portal->holdContext);\n\t\ttuplestore_end(portal->holdStore);\n\t\tMemoryContextSwitchTo(oldcontext);\n\t\tportal->holdStore = NULL;\n\t}\n\n\t/* delete tuplestore storage, if any */\n\tif (portal->holdContext)\n\t\tMemoryContextDelete(portal->holdContext);\n\n\t/* release subsidiary storage */\n\tMemoryContextDelete(portal->portalContext);\n\n\t/* release portal struct (it's in TopPortalContext) */\n\tpfree(portal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "WARNING",
            "\"skipping cleanup for portal \\\"%s\\\"\"",
            "portal->name"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerIsValid",
          "args": [
            "portal->cleanup"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "portal->resowner == NULL"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "portal->status != PORTAL_ACTIVE"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_seq_search",
          "args": [
            "&status"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "hash_seq_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "1388-1462",
          "snippet": "void *\nhash_seq_search(HASH_SEQ_STATUS *status)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\tuint32\t\tmax_bucket;\n\tlong\t\tssize;\n\tlong\t\tsegment_num;\n\tlong\t\tsegment_ndx;\n\tHASHSEGMENT segp;\n\tuint32\t\tcurBucket;\n\tHASHELEMENT *curElem;\n\n\tif ((curElem = status->curEntry) != NULL)\n\t{\n\t\t/* Continuing scan of curBucket... */\n\t\tstatus->curEntry = curElem->link;\n\t\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t\t++status->curBucket;\n\t\treturn (void *) ELEMENTKEY(curElem);\n\t}\n\n\t/*\n\t * Search for next nonempty bucket starting at curBucket.\n\t */\n\tcurBucket = status->curBucket;\n\thashp = status->hashp;\n\thctl = hashp->hctl;\n\tssize = hashp->ssize;\n\tmax_bucket = hctl->max_bucket;\n\n\tif (curBucket > max_bucket)\n\t{\n\t\thash_seq_term(status);\n\t\treturn NULL;\t\t\t/* search is done */\n\t}\n\n\t/*\n\t * first find the right segment in the table directory.\n\t */\n\tsegment_num = curBucket >> hashp->sshift;\n\tsegment_ndx = MOD(curBucket, ssize);\n\n\tsegp = hashp->dir[segment_num];\n\n\t/*\n\t * Pick up the first item in this bucket's chain.  If chain is not empty\n\t * we can begin searching it.  Otherwise we have to advance to find the\n\t * next nonempty bucket.  We try to optimize that case since searching a\n\t * near-empty hashtable has to iterate this loop a lot.\n\t */\n\twhile ((curElem = segp[segment_ndx]) == NULL)\n\t{\n\t\t/* empty bucket, advance to next */\n\t\tif (++curBucket > max_bucket)\n\t\t{\n\t\t\tstatus->curBucket = curBucket;\n\t\t\thash_seq_term(status);\n\t\t\treturn NULL;\t\t/* search is done */\n\t\t}\n\t\tif (++segment_ndx >= ssize)\n\t\t{\n\t\t\tsegment_num++;\n\t\t\tsegment_ndx = 0;\n\t\t\tsegp = hashp->dir[segment_num];\n\t\t}\n\t}\n\n\t/* Begin scan of curBucket... */\n\tstatus->curEntry = curElem->link;\n\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t++curBucket;\n\tstatus->curBucket = curBucket;\n\treturn (void *) ELEMENTKEY(curElem);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid *\nhash_seq_search(HASH_SEQ_STATUS *status)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\tuint32\t\tmax_bucket;\n\tlong\t\tssize;\n\tlong\t\tsegment_num;\n\tlong\t\tsegment_ndx;\n\tHASHSEGMENT segp;\n\tuint32\t\tcurBucket;\n\tHASHELEMENT *curElem;\n\n\tif ((curElem = status->curEntry) != NULL)\n\t{\n\t\t/* Continuing scan of curBucket... */\n\t\tstatus->curEntry = curElem->link;\n\t\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t\t++status->curBucket;\n\t\treturn (void *) ELEMENTKEY(curElem);\n\t}\n\n\t/*\n\t * Search for next nonempty bucket starting at curBucket.\n\t */\n\tcurBucket = status->curBucket;\n\thashp = status->hashp;\n\thctl = hashp->hctl;\n\tssize = hashp->ssize;\n\tmax_bucket = hctl->max_bucket;\n\n\tif (curBucket > max_bucket)\n\t{\n\t\thash_seq_term(status);\n\t\treturn NULL;\t\t\t/* search is done */\n\t}\n\n\t/*\n\t * first find the right segment in the table directory.\n\t */\n\tsegment_num = curBucket >> hashp->sshift;\n\tsegment_ndx = MOD(curBucket, ssize);\n\n\tsegp = hashp->dir[segment_num];\n\n\t/*\n\t * Pick up the first item in this bucket's chain.  If chain is not empty\n\t * we can begin searching it.  Otherwise we have to advance to find the\n\t * next nonempty bucket.  We try to optimize that case since searching a\n\t * near-empty hashtable has to iterate this loop a lot.\n\t */\n\twhile ((curElem = segp[segment_ndx]) == NULL)\n\t{\n\t\t/* empty bucket, advance to next */\n\t\tif (++curBucket > max_bucket)\n\t\t{\n\t\t\tstatus->curBucket = curBucket;\n\t\t\thash_seq_term(status);\n\t\t\treturn NULL;\t\t/* search is done */\n\t\t}\n\t\tif (++segment_ndx >= ssize)\n\t\t{\n\t\t\tsegment_num++;\n\t\t\tsegment_ndx = 0;\n\t\t\tsegp = hashp->dir[segment_num];\n\t\t}\n\t}\n\n\t/* Begin scan of curBucket... */\n\tstatus->curEntry = curElem->link;\n\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t++curBucket;\n\tstatus->curBucket = curBucket;\n\treturn (void *) ELEMENTKEY(curElem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_seq_init",
          "args": [
            "&status",
            "PortalHashTable"
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "hash_seq_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "1378-1386",
          "snippet": "void\nhash_seq_init(HASH_SEQ_STATUS *status, HTAB *hashp)\n{\n\tstatus->hashp = hashp;\n\tstatus->curBucket = 0;\n\tstatus->curEntry = NULL;\n\tif (!hashp->frozen)\n\t\tregister_seq_scan(hashp);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid\nhash_seq_init(HASH_SEQ_STATUS *status, HTAB *hashp)\n{\n\tstatus->hashp = hashp;\n\tstatus->curBucket = 0;\n\tstatus->curEntry = NULL;\n\tif (!hashp->frozen)\n\t\tregister_seq_scan(hashp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/ipc.h\"\n#include \"miscadmin.h\"\n#include \"commands/portalcmds.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic HTAB *PortalHashTable = NULL;\n\nvoid\nAtCleanup_Portals(void)\n{\n\tHASH_SEQ_STATUS status;\n\tPortalHashEnt *hentry;\n\n\thash_seq_init(&status, PortalHashTable);\n\n\twhile ((hentry = (PortalHashEnt *) hash_seq_search(&status)) != NULL)\n\t{\n\t\tPortal\t\tportal = hentry->portal;\n\n\t\t/*\n\t\t * Do not touch active portals --- this can only happen in the case of\n\t\t * a multi-transaction command.\n\t\t */\n\t\tif (portal->status == PORTAL_ACTIVE)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Do nothing to cursors held over from a previous transaction or\n\t\t * auto-held ones.\n\t\t */\n\t\tif (portal->createSubid == InvalidSubTransactionId || portal->autoHeld)\n\t\t{\n\t\t\tAssert(portal->status != PORTAL_ACTIVE);\n\t\t\tAssert(portal->resowner == NULL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If a portal is still pinned, forcibly unpin it. PortalDrop will not\n\t\t * let us drop the portal otherwise. Whoever pinned the portal was\n\t\t * interrupted by the abort too and won't try to use it anymore.\n\t\t */\n\t\tif (portal->portalPinned)\n\t\t\tportal->portalPinned = false;\n\n\t\t/*\n\t\t * We had better not call any user-defined code during cleanup, so if\n\t\t * the cleanup hook hasn't been run yet, too bad; we'll just skip it.\n\t\t */\n\t\tif (PointerIsValid(portal->cleanup))\n\t\t{\n\t\t\telog(WARNING, \"skipping cleanup for portal \\\"%s\\\"\", portal->name);\n\t\t\tportal->cleanup = NULL;\n\t\t}\n\n\t\t/* Zap it. */\n\t\tPortalDrop(portal, false);\n\t}\n}"
  },
  {
    "function_name": "AtAbort_Portals",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/portalmem.c",
    "lines": "771-842",
    "snippet": "void\nAtAbort_Portals(void)\n{\n\tHASH_SEQ_STATUS status;\n\tPortalHashEnt *hentry;\n\n\thash_seq_init(&status, PortalHashTable);\n\n\twhile ((hentry = (PortalHashEnt *) hash_seq_search(&status)) != NULL)\n\t{\n\t\tPortal\t\tportal = hentry->portal;\n\n\t\t/*\n\t\t * When elog(FATAL) is progress, we need to set the active portal to\n\t\t * failed, so that PortalCleanup() doesn't run the executor shutdown.\n\t\t */\n\t\tif (portal->status == PORTAL_ACTIVE && shmem_exit_inprogress)\n\t\t\tMarkPortalFailed(portal);\n\n\t\t/*\n\t\t * Do nothing else to cursors held over from a previous transaction.\n\t\t */\n\t\tif (portal->createSubid == InvalidSubTransactionId)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Do nothing to auto-held cursors.  This is similar to the case of a\n\t\t * cursor from a previous transaction, but it could also be that the\n\t\t * cursor was auto-held in this transaction, so it wants to live on.\n\t\t */\n\t\tif (portal->autoHeld)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * If it was created in the current transaction, we can't do normal\n\t\t * shutdown on a READY portal either; it might refer to objects\n\t\t * created in the failed transaction.  See comments in\n\t\t * AtSubAbort_Portals.\n\t\t */\n\t\tif (portal->status == PORTAL_READY)\n\t\t\tMarkPortalFailed(portal);\n\n\t\t/*\n\t\t * Allow portalcmds.c to clean up the state it knows about, if we\n\t\t * haven't already.\n\t\t */\n\t\tif (PointerIsValid(portal->cleanup))\n\t\t{\n\t\t\tportal->cleanup(portal);\n\t\t\tportal->cleanup = NULL;\n\t\t}\n\n\t\t/* drop cached plan reference, if any */\n\t\tPortalReleaseCachedPlan(portal);\n\n\t\t/*\n\t\t * Any resources belonging to the portal will be released in the\n\t\t * upcoming transaction-wide cleanup; they will be gone before we run\n\t\t * PortalDrop.\n\t\t */\n\t\tportal->resowner = NULL;\n\n\t\t/*\n\t\t * Although we can't delete the portal data structure proper, we can\n\t\t * release any memory in subsidiary contexts, such as executor state.\n\t\t * The cleanup hook was the last thing that might have needed data\n\t\t * there.  But leave active portals alone.\n\t\t */\n\t\tif (portal->status != PORTAL_ACTIVE)\n\t\t\tMemoryContextDeleteChildren(portal->portalContext);\n\t}\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/portalcmds.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static HTAB *PortalHashTable = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextDeleteChildren",
          "args": [
            "portal->portalContext"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextDeleteChildren",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "255-266",
          "snippet": "void\nMemoryContextDeleteChildren(MemoryContext context)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\n\t/*\n\t * MemoryContextDelete will delink the child from me, so just iterate as\n\t * long as there is a child.\n\t */\n\twhile (context->firstchild != NULL)\n\t\tMemoryContextDelete(context->firstchild);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\nMemoryContextDeleteChildren(MemoryContext context)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\n\t/*\n\t * MemoryContextDelete will delink the child from me, so just iterate as\n\t * long as there is a child.\n\t */\n\twhile (context->firstchild != NULL)\n\t\tMemoryContextDelete(context->firstchild);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PortalReleaseCachedPlan",
          "args": [
            "portal"
          ],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "PortalReleaseCachedPlan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/portalmem.c",
          "lines": "306-321",
          "snippet": "static void\nPortalReleaseCachedPlan(Portal portal)\n{\n\tif (portal->cplan)\n\t{\n\t\tReleaseCachedPlan(portal->cplan, false);\n\t\tportal->cplan = NULL;\n\n\t\t/*\n\t\t * We must also clear portal->stmts which is now a dangling reference\n\t\t * to the cached plan's plan list.  This protects any code that might\n\t\t * try to examine the Portal later.\n\t\t */\n\t\tportal->stmts = NIL;\n\t}\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/portalcmds.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/ipc.h\"\n#include \"miscadmin.h\"\n#include \"commands/portalcmds.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic void\nPortalReleaseCachedPlan(Portal portal)\n{\n\tif (portal->cplan)\n\t{\n\t\tReleaseCachedPlan(portal->cplan, false);\n\t\tportal->cplan = NULL;\n\n\t\t/*\n\t\t * We must also clear portal->stmts which is now a dangling reference\n\t\t * to the cached plan's plan list.  This protects any code that might\n\t\t * try to examine the Portal later.\n\t\t */\n\t\tportal->stmts = NIL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "portal->cleanup",
          "args": [
            "portal"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerIsValid",
          "args": [
            "portal->cleanup"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MarkPortalFailed",
          "args": [
            "portal"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "MarkPortalFailed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/portalmem.c",
          "lines": "438-458",
          "snippet": "void\nMarkPortalFailed(Portal portal)\n{\n\t/* Perform the state transition */\n\tAssert(portal->status != PORTAL_DONE);\n\tportal->status = PORTAL_FAILED;\n\n\t/*\n\t * Allow portalcmds.c to clean up the state it knows about.  We might as\n\t * well do that now, since the portal can't be executed any more.\n\t *\n\t * In some cases involving cleanup of an already aborted transaction, this\n\t * is necessary, or we'd reach AtCleanup_Portals with the cleanup hook\n\t * still unexecuted.\n\t */\n\tif (PointerIsValid(portal->cleanup))\n\t{\n\t\tportal->cleanup(portal);\n\t\tportal->cleanup = NULL;\n\t}\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/portalcmds.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/ipc.h\"\n#include \"miscadmin.h\"\n#include \"commands/portalcmds.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nvoid\nMarkPortalFailed(Portal portal)\n{\n\t/* Perform the state transition */\n\tAssert(portal->status != PORTAL_DONE);\n\tportal->status = PORTAL_FAILED;\n\n\t/*\n\t * Allow portalcmds.c to clean up the state it knows about.  We might as\n\t * well do that now, since the portal can't be executed any more.\n\t *\n\t * In some cases involving cleanup of an already aborted transaction, this\n\t * is necessary, or we'd reach AtCleanup_Portals with the cleanup hook\n\t * still unexecuted.\n\t */\n\tif (PointerIsValid(portal->cleanup))\n\t{\n\t\tportal->cleanup(portal);\n\t\tportal->cleanup = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_seq_search",
          "args": [
            "&status"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "hash_seq_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "1388-1462",
          "snippet": "void *\nhash_seq_search(HASH_SEQ_STATUS *status)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\tuint32\t\tmax_bucket;\n\tlong\t\tssize;\n\tlong\t\tsegment_num;\n\tlong\t\tsegment_ndx;\n\tHASHSEGMENT segp;\n\tuint32\t\tcurBucket;\n\tHASHELEMENT *curElem;\n\n\tif ((curElem = status->curEntry) != NULL)\n\t{\n\t\t/* Continuing scan of curBucket... */\n\t\tstatus->curEntry = curElem->link;\n\t\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t\t++status->curBucket;\n\t\treturn (void *) ELEMENTKEY(curElem);\n\t}\n\n\t/*\n\t * Search for next nonempty bucket starting at curBucket.\n\t */\n\tcurBucket = status->curBucket;\n\thashp = status->hashp;\n\thctl = hashp->hctl;\n\tssize = hashp->ssize;\n\tmax_bucket = hctl->max_bucket;\n\n\tif (curBucket > max_bucket)\n\t{\n\t\thash_seq_term(status);\n\t\treturn NULL;\t\t\t/* search is done */\n\t}\n\n\t/*\n\t * first find the right segment in the table directory.\n\t */\n\tsegment_num = curBucket >> hashp->sshift;\n\tsegment_ndx = MOD(curBucket, ssize);\n\n\tsegp = hashp->dir[segment_num];\n\n\t/*\n\t * Pick up the first item in this bucket's chain.  If chain is not empty\n\t * we can begin searching it.  Otherwise we have to advance to find the\n\t * next nonempty bucket.  We try to optimize that case since searching a\n\t * near-empty hashtable has to iterate this loop a lot.\n\t */\n\twhile ((curElem = segp[segment_ndx]) == NULL)\n\t{\n\t\t/* empty bucket, advance to next */\n\t\tif (++curBucket > max_bucket)\n\t\t{\n\t\t\tstatus->curBucket = curBucket;\n\t\t\thash_seq_term(status);\n\t\t\treturn NULL;\t\t/* search is done */\n\t\t}\n\t\tif (++segment_ndx >= ssize)\n\t\t{\n\t\t\tsegment_num++;\n\t\t\tsegment_ndx = 0;\n\t\t\tsegp = hashp->dir[segment_num];\n\t\t}\n\t}\n\n\t/* Begin scan of curBucket... */\n\tstatus->curEntry = curElem->link;\n\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t++curBucket;\n\tstatus->curBucket = curBucket;\n\treturn (void *) ELEMENTKEY(curElem);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid *\nhash_seq_search(HASH_SEQ_STATUS *status)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\tuint32\t\tmax_bucket;\n\tlong\t\tssize;\n\tlong\t\tsegment_num;\n\tlong\t\tsegment_ndx;\n\tHASHSEGMENT segp;\n\tuint32\t\tcurBucket;\n\tHASHELEMENT *curElem;\n\n\tif ((curElem = status->curEntry) != NULL)\n\t{\n\t\t/* Continuing scan of curBucket... */\n\t\tstatus->curEntry = curElem->link;\n\t\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t\t++status->curBucket;\n\t\treturn (void *) ELEMENTKEY(curElem);\n\t}\n\n\t/*\n\t * Search for next nonempty bucket starting at curBucket.\n\t */\n\tcurBucket = status->curBucket;\n\thashp = status->hashp;\n\thctl = hashp->hctl;\n\tssize = hashp->ssize;\n\tmax_bucket = hctl->max_bucket;\n\n\tif (curBucket > max_bucket)\n\t{\n\t\thash_seq_term(status);\n\t\treturn NULL;\t\t\t/* search is done */\n\t}\n\n\t/*\n\t * first find the right segment in the table directory.\n\t */\n\tsegment_num = curBucket >> hashp->sshift;\n\tsegment_ndx = MOD(curBucket, ssize);\n\n\tsegp = hashp->dir[segment_num];\n\n\t/*\n\t * Pick up the first item in this bucket's chain.  If chain is not empty\n\t * we can begin searching it.  Otherwise we have to advance to find the\n\t * next nonempty bucket.  We try to optimize that case since searching a\n\t * near-empty hashtable has to iterate this loop a lot.\n\t */\n\twhile ((curElem = segp[segment_ndx]) == NULL)\n\t{\n\t\t/* empty bucket, advance to next */\n\t\tif (++curBucket > max_bucket)\n\t\t{\n\t\t\tstatus->curBucket = curBucket;\n\t\t\thash_seq_term(status);\n\t\t\treturn NULL;\t\t/* search is done */\n\t\t}\n\t\tif (++segment_ndx >= ssize)\n\t\t{\n\t\t\tsegment_num++;\n\t\t\tsegment_ndx = 0;\n\t\t\tsegp = hashp->dir[segment_num];\n\t\t}\n\t}\n\n\t/* Begin scan of curBucket... */\n\tstatus->curEntry = curElem->link;\n\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t++curBucket;\n\tstatus->curBucket = curBucket;\n\treturn (void *) ELEMENTKEY(curElem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_seq_init",
          "args": [
            "&status",
            "PortalHashTable"
          ],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "hash_seq_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "1378-1386",
          "snippet": "void\nhash_seq_init(HASH_SEQ_STATUS *status, HTAB *hashp)\n{\n\tstatus->hashp = hashp;\n\tstatus->curBucket = 0;\n\tstatus->curEntry = NULL;\n\tif (!hashp->frozen)\n\t\tregister_seq_scan(hashp);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid\nhash_seq_init(HASH_SEQ_STATUS *status, HTAB *hashp)\n{\n\tstatus->hashp = hashp;\n\tstatus->curBucket = 0;\n\tstatus->curEntry = NULL;\n\tif (!hashp->frozen)\n\t\tregister_seq_scan(hashp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/ipc.h\"\n#include \"miscadmin.h\"\n#include \"commands/portalcmds.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic HTAB *PortalHashTable = NULL;\n\nvoid\nAtAbort_Portals(void)\n{\n\tHASH_SEQ_STATUS status;\n\tPortalHashEnt *hentry;\n\n\thash_seq_init(&status, PortalHashTable);\n\n\twhile ((hentry = (PortalHashEnt *) hash_seq_search(&status)) != NULL)\n\t{\n\t\tPortal\t\tportal = hentry->portal;\n\n\t\t/*\n\t\t * When elog(FATAL) is progress, we need to set the active portal to\n\t\t * failed, so that PortalCleanup() doesn't run the executor shutdown.\n\t\t */\n\t\tif (portal->status == PORTAL_ACTIVE && shmem_exit_inprogress)\n\t\t\tMarkPortalFailed(portal);\n\n\t\t/*\n\t\t * Do nothing else to cursors held over from a previous transaction.\n\t\t */\n\t\tif (portal->createSubid == InvalidSubTransactionId)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Do nothing to auto-held cursors.  This is similar to the case of a\n\t\t * cursor from a previous transaction, but it could also be that the\n\t\t * cursor was auto-held in this transaction, so it wants to live on.\n\t\t */\n\t\tif (portal->autoHeld)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * If it was created in the current transaction, we can't do normal\n\t\t * shutdown on a READY portal either; it might refer to objects\n\t\t * created in the failed transaction.  See comments in\n\t\t * AtSubAbort_Portals.\n\t\t */\n\t\tif (portal->status == PORTAL_READY)\n\t\t\tMarkPortalFailed(portal);\n\n\t\t/*\n\t\t * Allow portalcmds.c to clean up the state it knows about, if we\n\t\t * haven't already.\n\t\t */\n\t\tif (PointerIsValid(portal->cleanup))\n\t\t{\n\t\t\tportal->cleanup(portal);\n\t\t\tportal->cleanup = NULL;\n\t\t}\n\n\t\t/* drop cached plan reference, if any */\n\t\tPortalReleaseCachedPlan(portal);\n\n\t\t/*\n\t\t * Any resources belonging to the portal will be released in the\n\t\t * upcoming transaction-wide cleanup; they will be gone before we run\n\t\t * PortalDrop.\n\t\t */\n\t\tportal->resowner = NULL;\n\n\t\t/*\n\t\t * Although we can't delete the portal data structure proper, we can\n\t\t * release any memory in subsidiary contexts, such as executor state.\n\t\t * The cleanup hook was the last thing that might have needed data\n\t\t * there.  But leave active portals alone.\n\t\t */\n\t\tif (portal->status != PORTAL_ACTIVE)\n\t\t\tMemoryContextDeleteChildren(portal->portalContext);\n\t}\n}"
  },
  {
    "function_name": "PreCommit_Portals",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/portalmem.c",
    "lines": "669-763",
    "snippet": "bool\nPreCommit_Portals(bool isPrepare)\n{\n\tbool\t\tresult = false;\n\tHASH_SEQ_STATUS status;\n\tPortalHashEnt *hentry;\n\n\thash_seq_init(&status, PortalHashTable);\n\n\twhile ((hentry = (PortalHashEnt *) hash_seq_search(&status)) != NULL)\n\t{\n\t\tPortal\t\tportal = hentry->portal;\n\n\t\t/*\n\t\t * There should be no pinned portals anymore. Complain if someone\n\t\t * leaked one. Auto-held portals are allowed; we assume that whoever\n\t\t * pinned them is managing them.\n\t\t */\n\t\tif (portal->portalPinned && !portal->autoHeld)\n\t\t\telog(ERROR, \"cannot commit while a portal is pinned\");\n\n\t\t/*\n\t\t * Do not touch active portals --- this can only happen in the case of\n\t\t * a multi-transaction utility command, such as VACUUM, or a commit in\n\t\t * a procedure.\n\t\t *\n\t\t * Note however that any resource owner attached to such a portal is\n\t\t * still going to go away, so don't leave a dangling pointer.  Also\n\t\t * unregister any snapshots held by the portal, mainly to avoid\n\t\t * snapshot leak warnings from ResourceOwnerRelease().\n\t\t */\n\t\tif (portal->status == PORTAL_ACTIVE)\n\t\t{\n\t\t\tif (portal->holdSnapshot)\n\t\t\t{\n\t\t\t\tif (portal->resowner)\n\t\t\t\t\tUnregisterSnapshotFromOwner(portal->holdSnapshot,\n\t\t\t\t\t\t\t\t\t\t\t\tportal->resowner);\n\t\t\t\tportal->holdSnapshot = NULL;\n\t\t\t}\n\t\t\tportal->resowner = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Is it a holdable portal created in the current xact? */\n\t\tif ((portal->cursorOptions & CURSOR_OPT_HOLD) &&\n\t\t\tportal->createSubid != InvalidSubTransactionId &&\n\t\t\tportal->status == PORTAL_READY)\n\t\t{\n\t\t\t/*\n\t\t\t * We are exiting the transaction that created a holdable cursor.\n\t\t\t * Instead of dropping the portal, prepare it for access by later\n\t\t\t * transactions.\n\t\t\t *\n\t\t\t * However, if this is PREPARE TRANSACTION rather than COMMIT,\n\t\t\t * refuse PREPARE, because the semantics seem pretty unclear.\n\t\t\t */\n\t\t\tif (isPrepare)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"cannot PREPARE a transaction that has created a cursor WITH HOLD\")));\n\n\t\t\tHoldPortal(portal);\n\n\t\t\t/* Report we changed state */\n\t\t\tresult = true;\n\t\t}\n\t\telse if (portal->createSubid == InvalidSubTransactionId)\n\t\t{\n\t\t\t/*\n\t\t\t * Do nothing to cursors held over from a previous transaction\n\t\t\t * (including ones we just froze in a previous cycle of this loop)\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Zap all non-holdable portals */\n\t\t\tPortalDrop(portal, true);\n\n\t\t\t/* Report we changed state */\n\t\t\tresult = true;\n\t\t}\n\n\t\t/*\n\t\t * After either freezing or dropping a portal, we have to restart the\n\t\t * iteration, because we could have invoked user-defined code that\n\t\t * caused a drop of the next portal in the hash chain.\n\t\t */\n\t\thash_seq_term(&status);\n\t\thash_seq_init(&status, PortalHashTable);\n\t}\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/portalcmds.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static HTAB *PortalHashTable = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash_seq_init",
          "args": [
            "&status",
            "PortalHashTable"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "hash_seq_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "1378-1386",
          "snippet": "void\nhash_seq_init(HASH_SEQ_STATUS *status, HTAB *hashp)\n{\n\tstatus->hashp = hashp;\n\tstatus->curBucket = 0;\n\tstatus->curEntry = NULL;\n\tif (!hashp->frozen)\n\t\tregister_seq_scan(hashp);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid\nhash_seq_init(HASH_SEQ_STATUS *status, HTAB *hashp)\n{\n\tstatus->hashp = hashp;\n\tstatus->curBucket = 0;\n\tstatus->curEntry = NULL;\n\tif (!hashp->frozen)\n\t\tregister_seq_scan(hashp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_seq_term",
          "args": [
            "&status"
          ],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "hash_seq_term",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "1464-1469",
          "snippet": "void\nhash_seq_term(HASH_SEQ_STATUS *status)\n{\n\tif (!status->hashp->frozen)\n\t\tderegister_seq_scan(status->hashp);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid\nhash_seq_term(HASH_SEQ_STATUS *status)\n{\n\tif (!status->hashp->frozen)\n\t\tderegister_seq_scan(status->hashp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PortalDrop",
          "args": [
            "portal",
            "true"
          ],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "PortalDrop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/portalmem.c",
          "lines": "464-593",
          "snippet": "void\nPortalDrop(Portal portal, bool isTopCommit)\n{\n\tAssertArg(PortalIsValid(portal));\n\n\t/*\n\t * Don't allow dropping a pinned portal, it's still needed by whoever\n\t * pinned it.\n\t */\n\tif (portal->portalPinned)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_CURSOR_STATE),\n\t\t\t\t errmsg(\"cannot drop pinned portal \\\"%s\\\"\", portal->name)));\n\n\t/*\n\t * Not sure if the PORTAL_ACTIVE case can validly happen or not...\n\t */\n\tif (portal->status == PORTAL_ACTIVE)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_CURSOR_STATE),\n\t\t\t\t errmsg(\"cannot drop active portal \\\"%s\\\"\", portal->name)));\n\n\t/*\n\t * Allow portalcmds.c to clean up the state it knows about, in particular\n\t * shutting down the executor if still active.  This step potentially runs\n\t * user-defined code so failure has to be expected.  It's the cleanup\n\t * hook's responsibility to not try to do that more than once, in the case\n\t * that failure occurs and then we come back to drop the portal again\n\t * during transaction abort.\n\t *\n\t * Note: in most paths of control, this will have been done already in\n\t * MarkPortalDone or MarkPortalFailed.  We're just making sure.\n\t */\n\tif (PointerIsValid(portal->cleanup))\n\t{\n\t\tportal->cleanup(portal);\n\t\tportal->cleanup = NULL;\n\t}\n\n\t/*\n\t * Remove portal from hash table.  Because we do this here, we will not\n\t * come back to try to remove the portal again if there's any error in the\n\t * subsequent steps.  Better to leak a little memory than to get into an\n\t * infinite error-recovery loop.\n\t */\n\tPortalHashTableDelete(portal);\n\n\t/* drop cached plan reference, if any */\n\tPortalReleaseCachedPlan(portal);\n\n\t/*\n\t * If portal has a snapshot protecting its data, release that.  This needs\n\t * a little care since the registration will be attached to the portal's\n\t * resowner; if the portal failed, we will already have released the\n\t * resowner (and the snapshot) during transaction abort.\n\t */\n\tif (portal->holdSnapshot)\n\t{\n\t\tif (portal->resowner)\n\t\t\tUnregisterSnapshotFromOwner(portal->holdSnapshot,\n\t\t\t\t\t\t\t\t\t\tportal->resowner);\n\t\tportal->holdSnapshot = NULL;\n\t}\n\n\t/*\n\t * Release any resources still attached to the portal.  There are several\n\t * cases being covered here:\n\t *\n\t * Top transaction commit (indicated by isTopCommit): normally we should\n\t * do nothing here and let the regular end-of-transaction resource\n\t * releasing mechanism handle these resources too.  However, if we have a\n\t * FAILED portal (eg, a cursor that got an error), we'd better clean up\n\t * its resources to avoid resource-leakage warning messages.\n\t *\n\t * Sub transaction commit: never comes here at all, since we don't kill\n\t * any portals in AtSubCommit_Portals().\n\t *\n\t * Main or sub transaction abort: we will do nothing here because\n\t * portal->resowner was already set NULL; the resources were already\n\t * cleaned up in transaction abort.\n\t *\n\t * Ordinary portal drop: must release resources.  However, if the portal\n\t * is not FAILED then we do not release its locks.  The locks become the\n\t * responsibility of the transaction's ResourceOwner (since it is the\n\t * parent of the portal's owner) and will be released when the transaction\n\t * eventually ends.\n\t */\n\tif (portal->resowner &&\n\t\t(!isTopCommit || portal->status == PORTAL_FAILED))\n\t{\n\t\tbool\t\tisCommit = (portal->status != PORTAL_FAILED);\n\n\t\tResourceOwnerRelease(portal->resowner,\n\t\t\t\t\t\t\t RESOURCE_RELEASE_BEFORE_LOCKS,\n\t\t\t\t\t\t\t isCommit, false);\n\t\tResourceOwnerRelease(portal->resowner,\n\t\t\t\t\t\t\t RESOURCE_RELEASE_LOCKS,\n\t\t\t\t\t\t\t isCommit, false);\n\t\tResourceOwnerRelease(portal->resowner,\n\t\t\t\t\t\t\t RESOURCE_RELEASE_AFTER_LOCKS,\n\t\t\t\t\t\t\t isCommit, false);\n\t\tResourceOwnerDelete(portal->resowner);\n\t}\n\tportal->resowner = NULL;\n\n\t/*\n\t * Delete tuplestore if present.  We should do this even under error\n\t * conditions; since the tuplestore would have been using cross-\n\t * transaction storage, its temp files need to be explicitly deleted.\n\t */\n\tif (portal->holdStore)\n\t{\n\t\tMemoryContext oldcontext;\n\n\t\toldcontext = MemoryContextSwitchTo(portal->holdContext);\n\t\ttuplestore_end(portal->holdStore);\n\t\tMemoryContextSwitchTo(oldcontext);\n\t\tportal->holdStore = NULL;\n\t}\n\n\t/* delete tuplestore storage, if any */\n\tif (portal->holdContext)\n\t\tMemoryContextDelete(portal->holdContext);\n\n\t/* release subsidiary storage */\n\tMemoryContextDelete(portal->portalContext);\n\n\t/* release portal struct (it's in TopPortalContext) */\n\tpfree(portal);\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/portalcmds.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static MemoryContext TopPortalContext = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/ipc.h\"\n#include \"miscadmin.h\"\n#include \"commands/portalcmds.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic MemoryContext TopPortalContext = NULL;\n\nvoid\nPortalDrop(Portal portal, bool isTopCommit)\n{\n\tAssertArg(PortalIsValid(portal));\n\n\t/*\n\t * Don't allow dropping a pinned portal, it's still needed by whoever\n\t * pinned it.\n\t */\n\tif (portal->portalPinned)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_CURSOR_STATE),\n\t\t\t\t errmsg(\"cannot drop pinned portal \\\"%s\\\"\", portal->name)));\n\n\t/*\n\t * Not sure if the PORTAL_ACTIVE case can validly happen or not...\n\t */\n\tif (portal->status == PORTAL_ACTIVE)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_CURSOR_STATE),\n\t\t\t\t errmsg(\"cannot drop active portal \\\"%s\\\"\", portal->name)));\n\n\t/*\n\t * Allow portalcmds.c to clean up the state it knows about, in particular\n\t * shutting down the executor if still active.  This step potentially runs\n\t * user-defined code so failure has to be expected.  It's the cleanup\n\t * hook's responsibility to not try to do that more than once, in the case\n\t * that failure occurs and then we come back to drop the portal again\n\t * during transaction abort.\n\t *\n\t * Note: in most paths of control, this will have been done already in\n\t * MarkPortalDone or MarkPortalFailed.  We're just making sure.\n\t */\n\tif (PointerIsValid(portal->cleanup))\n\t{\n\t\tportal->cleanup(portal);\n\t\tportal->cleanup = NULL;\n\t}\n\n\t/*\n\t * Remove portal from hash table.  Because we do this here, we will not\n\t * come back to try to remove the portal again if there's any error in the\n\t * subsequent steps.  Better to leak a little memory than to get into an\n\t * infinite error-recovery loop.\n\t */\n\tPortalHashTableDelete(portal);\n\n\t/* drop cached plan reference, if any */\n\tPortalReleaseCachedPlan(portal);\n\n\t/*\n\t * If portal has a snapshot protecting its data, release that.  This needs\n\t * a little care since the registration will be attached to the portal's\n\t * resowner; if the portal failed, we will already have released the\n\t * resowner (and the snapshot) during transaction abort.\n\t */\n\tif (portal->holdSnapshot)\n\t{\n\t\tif (portal->resowner)\n\t\t\tUnregisterSnapshotFromOwner(portal->holdSnapshot,\n\t\t\t\t\t\t\t\t\t\tportal->resowner);\n\t\tportal->holdSnapshot = NULL;\n\t}\n\n\t/*\n\t * Release any resources still attached to the portal.  There are several\n\t * cases being covered here:\n\t *\n\t * Top transaction commit (indicated by isTopCommit): normally we should\n\t * do nothing here and let the regular end-of-transaction resource\n\t * releasing mechanism handle these resources too.  However, if we have a\n\t * FAILED portal (eg, a cursor that got an error), we'd better clean up\n\t * its resources to avoid resource-leakage warning messages.\n\t *\n\t * Sub transaction commit: never comes here at all, since we don't kill\n\t * any portals in AtSubCommit_Portals().\n\t *\n\t * Main or sub transaction abort: we will do nothing here because\n\t * portal->resowner was already set NULL; the resources were already\n\t * cleaned up in transaction abort.\n\t *\n\t * Ordinary portal drop: must release resources.  However, if the portal\n\t * is not FAILED then we do not release its locks.  The locks become the\n\t * responsibility of the transaction's ResourceOwner (since it is the\n\t * parent of the portal's owner) and will be released when the transaction\n\t * eventually ends.\n\t */\n\tif (portal->resowner &&\n\t\t(!isTopCommit || portal->status == PORTAL_FAILED))\n\t{\n\t\tbool\t\tisCommit = (portal->status != PORTAL_FAILED);\n\n\t\tResourceOwnerRelease(portal->resowner,\n\t\t\t\t\t\t\t RESOURCE_RELEASE_BEFORE_LOCKS,\n\t\t\t\t\t\t\t isCommit, false);\n\t\tResourceOwnerRelease(portal->resowner,\n\t\t\t\t\t\t\t RESOURCE_RELEASE_LOCKS,\n\t\t\t\t\t\t\t isCommit, false);\n\t\tResourceOwnerRelease(portal->resowner,\n\t\t\t\t\t\t\t RESOURCE_RELEASE_AFTER_LOCKS,\n\t\t\t\t\t\t\t isCommit, false);\n\t\tResourceOwnerDelete(portal->resowner);\n\t}\n\tportal->resowner = NULL;\n\n\t/*\n\t * Delete tuplestore if present.  We should do this even under error\n\t * conditions; since the tuplestore would have been using cross-\n\t * transaction storage, its temp files need to be explicitly deleted.\n\t */\n\tif (portal->holdStore)\n\t{\n\t\tMemoryContext oldcontext;\n\n\t\toldcontext = MemoryContextSwitchTo(portal->holdContext);\n\t\ttuplestore_end(portal->holdStore);\n\t\tMemoryContextSwitchTo(oldcontext);\n\t\tportal->holdStore = NULL;\n\t}\n\n\t/* delete tuplestore storage, if any */\n\tif (portal->holdContext)\n\t\tMemoryContextDelete(portal->holdContext);\n\n\t/* release subsidiary storage */\n\tMemoryContextDelete(portal->portalContext);\n\n\t/* release portal struct (it's in TopPortalContext) */\n\tpfree(portal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HoldPortal",
          "args": [
            "portal"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "HoldPortal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/portalmem.c",
          "lines": "629-655",
          "snippet": "static void\nHoldPortal(Portal portal)\n{\n\t/*\n\t * Note that PersistHoldablePortal() must release all resources used by\n\t * the portal that are local to the creating transaction.\n\t */\n\tPortalCreateHoldStore(portal);\n\tPersistHoldablePortal(portal);\n\n\t/* drop cached plan reference, if any */\n\tPortalReleaseCachedPlan(portal);\n\n\t/*\n\t * Any resources belonging to the portal will be released in the upcoming\n\t * transaction-wide cleanup; the portal will no longer have its own\n\t * resources.\n\t */\n\tportal->resowner = NULL;\n\n\t/*\n\t * Having successfully exported the holdable cursor, mark it as not\n\t * belonging to this transaction.\n\t */\n\tportal->createSubid = InvalidSubTransactionId;\n\tportal->activeSubid = InvalidSubTransactionId;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/portalcmds.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/ipc.h\"\n#include \"miscadmin.h\"\n#include \"commands/portalcmds.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic void\nHoldPortal(Portal portal)\n{\n\t/*\n\t * Note that PersistHoldablePortal() must release all resources used by\n\t * the portal that are local to the creating transaction.\n\t */\n\tPortalCreateHoldStore(portal);\n\tPersistHoldablePortal(portal);\n\n\t/* drop cached plan reference, if any */\n\tPortalReleaseCachedPlan(portal);\n\n\t/*\n\t * Any resources belonging to the portal will be released in the upcoming\n\t * transaction-wide cleanup; the portal will no longer have its own\n\t * resources.\n\t */\n\tportal->resowner = NULL;\n\n\t/*\n\t * Having successfully exported the holdable cursor, mark it as not\n\t * belonging to this transaction.\n\t */\n\tportal->createSubid = InvalidSubTransactionId;\n\tportal->activeSubid = InvalidSubTransactionId;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"cannot PREPARE a transaction that has created a cursor WITH HOLD\"))"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"cannot PREPARE a transaction that has created a cursor WITH HOLD\""
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_FEATURE_NOT_SUPPORTED"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "UnregisterSnapshotFromOwner",
          "args": [
            "portal->holdSnapshot",
            "portal->resowner"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "UnregisterSnapshotFromOwner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "917-937",
          "snippet": "void\nUnregisterSnapshotFromOwner(Snapshot snapshot, ResourceOwner owner)\n{\n\tif (snapshot == NULL)\n\t\treturn;\n\n\tAssert(snapshot->regd_count > 0);\n\tAssert(!pairingheap_is_empty(&RegisteredSnapshots));\n\n\tResourceOwnerForgetSnapshot(owner, snapshot);\n\n\tsnapshot->regd_count--;\n\tif (snapshot->regd_count == 0)\n\t\tpairingheap_remove(&RegisteredSnapshots, &snapshot->ph_node);\n\n\tif (snapshot->regd_count == 0 && snapshot->active_count == 0)\n\t{\n\t\tFreeSnapshot(snapshot);\n\t\tSnapshotResetXmin();\n\t}\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};",
            "static Snapshot CopySnapshot(Snapshot snapshot);",
            "static void FreeSnapshot(Snapshot snapshot);",
            "static void SnapshotResetXmin(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};\nstatic Snapshot CopySnapshot(Snapshot snapshot);\nstatic void FreeSnapshot(Snapshot snapshot);\nstatic void SnapshotResetXmin(void);\n\nvoid\nUnregisterSnapshotFromOwner(Snapshot snapshot, ResourceOwner owner)\n{\n\tif (snapshot == NULL)\n\t\treturn;\n\n\tAssert(snapshot->regd_count > 0);\n\tAssert(!pairingheap_is_empty(&RegisteredSnapshots));\n\n\tResourceOwnerForgetSnapshot(owner, snapshot);\n\n\tsnapshot->regd_count--;\n\tif (snapshot->regd_count == 0)\n\t\tpairingheap_remove(&RegisteredSnapshots, &snapshot->ph_node);\n\n\tif (snapshot->regd_count == 0 && snapshot->active_count == 0)\n\t{\n\t\tFreeSnapshot(snapshot);\n\t\tSnapshotResetXmin();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"cannot commit while a portal is pinned\""
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_seq_search",
          "args": [
            "&status"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "hash_seq_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "1388-1462",
          "snippet": "void *\nhash_seq_search(HASH_SEQ_STATUS *status)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\tuint32\t\tmax_bucket;\n\tlong\t\tssize;\n\tlong\t\tsegment_num;\n\tlong\t\tsegment_ndx;\n\tHASHSEGMENT segp;\n\tuint32\t\tcurBucket;\n\tHASHELEMENT *curElem;\n\n\tif ((curElem = status->curEntry) != NULL)\n\t{\n\t\t/* Continuing scan of curBucket... */\n\t\tstatus->curEntry = curElem->link;\n\t\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t\t++status->curBucket;\n\t\treturn (void *) ELEMENTKEY(curElem);\n\t}\n\n\t/*\n\t * Search for next nonempty bucket starting at curBucket.\n\t */\n\tcurBucket = status->curBucket;\n\thashp = status->hashp;\n\thctl = hashp->hctl;\n\tssize = hashp->ssize;\n\tmax_bucket = hctl->max_bucket;\n\n\tif (curBucket > max_bucket)\n\t{\n\t\thash_seq_term(status);\n\t\treturn NULL;\t\t\t/* search is done */\n\t}\n\n\t/*\n\t * first find the right segment in the table directory.\n\t */\n\tsegment_num = curBucket >> hashp->sshift;\n\tsegment_ndx = MOD(curBucket, ssize);\n\n\tsegp = hashp->dir[segment_num];\n\n\t/*\n\t * Pick up the first item in this bucket's chain.  If chain is not empty\n\t * we can begin searching it.  Otherwise we have to advance to find the\n\t * next nonempty bucket.  We try to optimize that case since searching a\n\t * near-empty hashtable has to iterate this loop a lot.\n\t */\n\twhile ((curElem = segp[segment_ndx]) == NULL)\n\t{\n\t\t/* empty bucket, advance to next */\n\t\tif (++curBucket > max_bucket)\n\t\t{\n\t\t\tstatus->curBucket = curBucket;\n\t\t\thash_seq_term(status);\n\t\t\treturn NULL;\t\t/* search is done */\n\t\t}\n\t\tif (++segment_ndx >= ssize)\n\t\t{\n\t\t\tsegment_num++;\n\t\t\tsegment_ndx = 0;\n\t\t\tsegp = hashp->dir[segment_num];\n\t\t}\n\t}\n\n\t/* Begin scan of curBucket... */\n\tstatus->curEntry = curElem->link;\n\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t++curBucket;\n\tstatus->curBucket = curBucket;\n\treturn (void *) ELEMENTKEY(curElem);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid *\nhash_seq_search(HASH_SEQ_STATUS *status)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\tuint32\t\tmax_bucket;\n\tlong\t\tssize;\n\tlong\t\tsegment_num;\n\tlong\t\tsegment_ndx;\n\tHASHSEGMENT segp;\n\tuint32\t\tcurBucket;\n\tHASHELEMENT *curElem;\n\n\tif ((curElem = status->curEntry) != NULL)\n\t{\n\t\t/* Continuing scan of curBucket... */\n\t\tstatus->curEntry = curElem->link;\n\t\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t\t++status->curBucket;\n\t\treturn (void *) ELEMENTKEY(curElem);\n\t}\n\n\t/*\n\t * Search for next nonempty bucket starting at curBucket.\n\t */\n\tcurBucket = status->curBucket;\n\thashp = status->hashp;\n\thctl = hashp->hctl;\n\tssize = hashp->ssize;\n\tmax_bucket = hctl->max_bucket;\n\n\tif (curBucket > max_bucket)\n\t{\n\t\thash_seq_term(status);\n\t\treturn NULL;\t\t\t/* search is done */\n\t}\n\n\t/*\n\t * first find the right segment in the table directory.\n\t */\n\tsegment_num = curBucket >> hashp->sshift;\n\tsegment_ndx = MOD(curBucket, ssize);\n\n\tsegp = hashp->dir[segment_num];\n\n\t/*\n\t * Pick up the first item in this bucket's chain.  If chain is not empty\n\t * we can begin searching it.  Otherwise we have to advance to find the\n\t * next nonempty bucket.  We try to optimize that case since searching a\n\t * near-empty hashtable has to iterate this loop a lot.\n\t */\n\twhile ((curElem = segp[segment_ndx]) == NULL)\n\t{\n\t\t/* empty bucket, advance to next */\n\t\tif (++curBucket > max_bucket)\n\t\t{\n\t\t\tstatus->curBucket = curBucket;\n\t\t\thash_seq_term(status);\n\t\t\treturn NULL;\t\t/* search is done */\n\t\t}\n\t\tif (++segment_ndx >= ssize)\n\t\t{\n\t\t\tsegment_num++;\n\t\t\tsegment_ndx = 0;\n\t\t\tsegp = hashp->dir[segment_num];\n\t\t}\n\t}\n\n\t/* Begin scan of curBucket... */\n\tstatus->curEntry = curElem->link;\n\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t++curBucket;\n\tstatus->curBucket = curBucket;\n\treturn (void *) ELEMENTKEY(curElem);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/ipc.h\"\n#include \"miscadmin.h\"\n#include \"commands/portalcmds.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic HTAB *PortalHashTable = NULL;\n\nbool\nPreCommit_Portals(bool isPrepare)\n{\n\tbool\t\tresult = false;\n\tHASH_SEQ_STATUS status;\n\tPortalHashEnt *hentry;\n\n\thash_seq_init(&status, PortalHashTable);\n\n\twhile ((hentry = (PortalHashEnt *) hash_seq_search(&status)) != NULL)\n\t{\n\t\tPortal\t\tportal = hentry->portal;\n\n\t\t/*\n\t\t * There should be no pinned portals anymore. Complain if someone\n\t\t * leaked one. Auto-held portals are allowed; we assume that whoever\n\t\t * pinned them is managing them.\n\t\t */\n\t\tif (portal->portalPinned && !portal->autoHeld)\n\t\t\telog(ERROR, \"cannot commit while a portal is pinned\");\n\n\t\t/*\n\t\t * Do not touch active portals --- this can only happen in the case of\n\t\t * a multi-transaction utility command, such as VACUUM, or a commit in\n\t\t * a procedure.\n\t\t *\n\t\t * Note however that any resource owner attached to such a portal is\n\t\t * still going to go away, so don't leave a dangling pointer.  Also\n\t\t * unregister any snapshots held by the portal, mainly to avoid\n\t\t * snapshot leak warnings from ResourceOwnerRelease().\n\t\t */\n\t\tif (portal->status == PORTAL_ACTIVE)\n\t\t{\n\t\t\tif (portal->holdSnapshot)\n\t\t\t{\n\t\t\t\tif (portal->resowner)\n\t\t\t\t\tUnregisterSnapshotFromOwner(portal->holdSnapshot,\n\t\t\t\t\t\t\t\t\t\t\t\tportal->resowner);\n\t\t\t\tportal->holdSnapshot = NULL;\n\t\t\t}\n\t\t\tportal->resowner = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Is it a holdable portal created in the current xact? */\n\t\tif ((portal->cursorOptions & CURSOR_OPT_HOLD) &&\n\t\t\tportal->createSubid != InvalidSubTransactionId &&\n\t\t\tportal->status == PORTAL_READY)\n\t\t{\n\t\t\t/*\n\t\t\t * We are exiting the transaction that created a holdable cursor.\n\t\t\t * Instead of dropping the portal, prepare it for access by later\n\t\t\t * transactions.\n\t\t\t *\n\t\t\t * However, if this is PREPARE TRANSACTION rather than COMMIT,\n\t\t\t * refuse PREPARE, because the semantics seem pretty unclear.\n\t\t\t */\n\t\t\tif (isPrepare)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"cannot PREPARE a transaction that has created a cursor WITH HOLD\")));\n\n\t\t\tHoldPortal(portal);\n\n\t\t\t/* Report we changed state */\n\t\t\tresult = true;\n\t\t}\n\t\telse if (portal->createSubid == InvalidSubTransactionId)\n\t\t{\n\t\t\t/*\n\t\t\t * Do nothing to cursors held over from a previous transaction\n\t\t\t * (including ones we just froze in a previous cycle of this loop)\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Zap all non-holdable portals */\n\t\t\tPortalDrop(portal, true);\n\n\t\t\t/* Report we changed state */\n\t\t\tresult = true;\n\t\t}\n\n\t\t/*\n\t\t * After either freezing or dropping a portal, we have to restart the\n\t\t * iteration, because we could have invoked user-defined code that\n\t\t * caused a drop of the next portal in the hash chain.\n\t\t */\n\t\thash_seq_term(&status);\n\t\thash_seq_init(&status, PortalHashTable);\n\t}\n\n\treturn result;\n}"
  },
  {
    "function_name": "HoldPortal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/portalmem.c",
    "lines": "629-655",
    "snippet": "static void\nHoldPortal(Portal portal)\n{\n\t/*\n\t * Note that PersistHoldablePortal() must release all resources used by\n\t * the portal that are local to the creating transaction.\n\t */\n\tPortalCreateHoldStore(portal);\n\tPersistHoldablePortal(portal);\n\n\t/* drop cached plan reference, if any */\n\tPortalReleaseCachedPlan(portal);\n\n\t/*\n\t * Any resources belonging to the portal will be released in the upcoming\n\t * transaction-wide cleanup; the portal will no longer have its own\n\t * resources.\n\t */\n\tportal->resowner = NULL;\n\n\t/*\n\t * Having successfully exported the holdable cursor, mark it as not\n\t * belonging to this transaction.\n\t */\n\tportal->createSubid = InvalidSubTransactionId;\n\tportal->activeSubid = InvalidSubTransactionId;\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/portalcmds.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PortalReleaseCachedPlan",
          "args": [
            "portal"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "PortalReleaseCachedPlan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/portalmem.c",
          "lines": "306-321",
          "snippet": "static void\nPortalReleaseCachedPlan(Portal portal)\n{\n\tif (portal->cplan)\n\t{\n\t\tReleaseCachedPlan(portal->cplan, false);\n\t\tportal->cplan = NULL;\n\n\t\t/*\n\t\t * We must also clear portal->stmts which is now a dangling reference\n\t\t * to the cached plan's plan list.  This protects any code that might\n\t\t * try to examine the Portal later.\n\t\t */\n\t\tportal->stmts = NIL;\n\t}\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/portalcmds.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/ipc.h\"\n#include \"miscadmin.h\"\n#include \"commands/portalcmds.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic void\nPortalReleaseCachedPlan(Portal portal)\n{\n\tif (portal->cplan)\n\t{\n\t\tReleaseCachedPlan(portal->cplan, false);\n\t\tportal->cplan = NULL;\n\n\t\t/*\n\t\t * We must also clear portal->stmts which is now a dangling reference\n\t\t * to the cached plan's plan list.  This protects any code that might\n\t\t * try to examine the Portal later.\n\t\t */\n\t\tportal->stmts = NIL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PersistHoldablePortal",
          "args": [
            "portal"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PortalCreateHoldStore",
          "args": [
            "portal"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "PortalCreateHoldStore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/portalmem.c",
          "lines": "327-358",
          "snippet": "void\nPortalCreateHoldStore(Portal portal)\n{\n\tMemoryContext oldcxt;\n\n\tAssert(portal->holdContext == NULL);\n\tAssert(portal->holdStore == NULL);\n\tAssert(portal->holdSnapshot == NULL);\n\n\t/*\n\t * Create the memory context that is used for storage of the tuple set.\n\t * Note this is NOT a child of the portal's portalContext.\n\t */\n\tportal->holdContext =\n\t\tAllocSetContextCreate(TopPortalContext,\n\t\t\t\t\t\t\t  \"PortalHoldContext\",\n\t\t\t\t\t\t\t  ALLOCSET_DEFAULT_SIZES);\n\n\t/*\n\t * Create the tuple store, selecting cross-transaction temp files, and\n\t * enabling random access only if cursor requires scrolling.\n\t *\n\t * XXX: Should maintenance_work_mem be used for the portal size?\n\t */\n\toldcxt = MemoryContextSwitchTo(portal->holdContext);\n\n\tportal->holdStore =\n\t\ttuplestore_begin_heap(portal->cursorOptions & CURSOR_OPT_SCROLL,\n\t\t\t\t\t\t\t  true, work_mem);\n\n\tMemoryContextSwitchTo(oldcxt);\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/portalcmds.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static MemoryContext TopPortalContext = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/ipc.h\"\n#include \"miscadmin.h\"\n#include \"commands/portalcmds.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic MemoryContext TopPortalContext = NULL;\n\nvoid\nPortalCreateHoldStore(Portal portal)\n{\n\tMemoryContext oldcxt;\n\n\tAssert(portal->holdContext == NULL);\n\tAssert(portal->holdStore == NULL);\n\tAssert(portal->holdSnapshot == NULL);\n\n\t/*\n\t * Create the memory context that is used for storage of the tuple set.\n\t * Note this is NOT a child of the portal's portalContext.\n\t */\n\tportal->holdContext =\n\t\tAllocSetContextCreate(TopPortalContext,\n\t\t\t\t\t\t\t  \"PortalHoldContext\",\n\t\t\t\t\t\t\t  ALLOCSET_DEFAULT_SIZES);\n\n\t/*\n\t * Create the tuple store, selecting cross-transaction temp files, and\n\t * enabling random access only if cursor requires scrolling.\n\t *\n\t * XXX: Should maintenance_work_mem be used for the portal size?\n\t */\n\toldcxt = MemoryContextSwitchTo(portal->holdContext);\n\n\tportal->holdStore =\n\t\ttuplestore_begin_heap(portal->cursorOptions & CURSOR_OPT_SCROLL,\n\t\t\t\t\t\t\t  true, work_mem);\n\n\tMemoryContextSwitchTo(oldcxt);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/ipc.h\"\n#include \"miscadmin.h\"\n#include \"commands/portalcmds.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic void\nHoldPortal(Portal portal)\n{\n\t/*\n\t * Note that PersistHoldablePortal() must release all resources used by\n\t * the portal that are local to the creating transaction.\n\t */\n\tPortalCreateHoldStore(portal);\n\tPersistHoldablePortal(portal);\n\n\t/* drop cached plan reference, if any */\n\tPortalReleaseCachedPlan(portal);\n\n\t/*\n\t * Any resources belonging to the portal will be released in the upcoming\n\t * transaction-wide cleanup; the portal will no longer have its own\n\t * resources.\n\t */\n\tportal->resowner = NULL;\n\n\t/*\n\t * Having successfully exported the holdable cursor, mark it as not\n\t * belonging to this transaction.\n\t */\n\tportal->createSubid = InvalidSubTransactionId;\n\tportal->activeSubid = InvalidSubTransactionId;\n}"
  },
  {
    "function_name": "PortalHashTableDeleteAll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/portalmem.c",
    "lines": "600-624",
    "snippet": "void\nPortalHashTableDeleteAll(void)\n{\n\tHASH_SEQ_STATUS status;\n\tPortalHashEnt *hentry;\n\n\tif (PortalHashTable == NULL)\n\t\treturn;\n\n\thash_seq_init(&status, PortalHashTable);\n\twhile ((hentry = hash_seq_search(&status)) != NULL)\n\t{\n\t\tPortal\t\tportal = hentry->portal;\n\n\t\t/* Can't close the active portal (the one running the command) */\n\t\tif (portal->status == PORTAL_ACTIVE)\n\t\t\tcontinue;\n\n\t\tPortalDrop(portal, false);\n\n\t\t/* Restart the iteration in case that led to other drops */\n\t\thash_seq_term(&status);\n\t\thash_seq_init(&status, PortalHashTable);\n\t}\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/portalcmds.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static HTAB *PortalHashTable = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash_seq_init",
          "args": [
            "&status",
            "PortalHashTable"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "hash_seq_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "1378-1386",
          "snippet": "void\nhash_seq_init(HASH_SEQ_STATUS *status, HTAB *hashp)\n{\n\tstatus->hashp = hashp;\n\tstatus->curBucket = 0;\n\tstatus->curEntry = NULL;\n\tif (!hashp->frozen)\n\t\tregister_seq_scan(hashp);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid\nhash_seq_init(HASH_SEQ_STATUS *status, HTAB *hashp)\n{\n\tstatus->hashp = hashp;\n\tstatus->curBucket = 0;\n\tstatus->curEntry = NULL;\n\tif (!hashp->frozen)\n\t\tregister_seq_scan(hashp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_seq_term",
          "args": [
            "&status"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "hash_seq_term",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "1464-1469",
          "snippet": "void\nhash_seq_term(HASH_SEQ_STATUS *status)\n{\n\tif (!status->hashp->frozen)\n\t\tderegister_seq_scan(status->hashp);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid\nhash_seq_term(HASH_SEQ_STATUS *status)\n{\n\tif (!status->hashp->frozen)\n\t\tderegister_seq_scan(status->hashp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PortalDrop",
          "args": [
            "portal",
            "false"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "PortalDrop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/portalmem.c",
          "lines": "464-593",
          "snippet": "void\nPortalDrop(Portal portal, bool isTopCommit)\n{\n\tAssertArg(PortalIsValid(portal));\n\n\t/*\n\t * Don't allow dropping a pinned portal, it's still needed by whoever\n\t * pinned it.\n\t */\n\tif (portal->portalPinned)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_CURSOR_STATE),\n\t\t\t\t errmsg(\"cannot drop pinned portal \\\"%s\\\"\", portal->name)));\n\n\t/*\n\t * Not sure if the PORTAL_ACTIVE case can validly happen or not...\n\t */\n\tif (portal->status == PORTAL_ACTIVE)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_CURSOR_STATE),\n\t\t\t\t errmsg(\"cannot drop active portal \\\"%s\\\"\", portal->name)));\n\n\t/*\n\t * Allow portalcmds.c to clean up the state it knows about, in particular\n\t * shutting down the executor if still active.  This step potentially runs\n\t * user-defined code so failure has to be expected.  It's the cleanup\n\t * hook's responsibility to not try to do that more than once, in the case\n\t * that failure occurs and then we come back to drop the portal again\n\t * during transaction abort.\n\t *\n\t * Note: in most paths of control, this will have been done already in\n\t * MarkPortalDone or MarkPortalFailed.  We're just making sure.\n\t */\n\tif (PointerIsValid(portal->cleanup))\n\t{\n\t\tportal->cleanup(portal);\n\t\tportal->cleanup = NULL;\n\t}\n\n\t/*\n\t * Remove portal from hash table.  Because we do this here, we will not\n\t * come back to try to remove the portal again if there's any error in the\n\t * subsequent steps.  Better to leak a little memory than to get into an\n\t * infinite error-recovery loop.\n\t */\n\tPortalHashTableDelete(portal);\n\n\t/* drop cached plan reference, if any */\n\tPortalReleaseCachedPlan(portal);\n\n\t/*\n\t * If portal has a snapshot protecting its data, release that.  This needs\n\t * a little care since the registration will be attached to the portal's\n\t * resowner; if the portal failed, we will already have released the\n\t * resowner (and the snapshot) during transaction abort.\n\t */\n\tif (portal->holdSnapshot)\n\t{\n\t\tif (portal->resowner)\n\t\t\tUnregisterSnapshotFromOwner(portal->holdSnapshot,\n\t\t\t\t\t\t\t\t\t\tportal->resowner);\n\t\tportal->holdSnapshot = NULL;\n\t}\n\n\t/*\n\t * Release any resources still attached to the portal.  There are several\n\t * cases being covered here:\n\t *\n\t * Top transaction commit (indicated by isTopCommit): normally we should\n\t * do nothing here and let the regular end-of-transaction resource\n\t * releasing mechanism handle these resources too.  However, if we have a\n\t * FAILED portal (eg, a cursor that got an error), we'd better clean up\n\t * its resources to avoid resource-leakage warning messages.\n\t *\n\t * Sub transaction commit: never comes here at all, since we don't kill\n\t * any portals in AtSubCommit_Portals().\n\t *\n\t * Main or sub transaction abort: we will do nothing here because\n\t * portal->resowner was already set NULL; the resources were already\n\t * cleaned up in transaction abort.\n\t *\n\t * Ordinary portal drop: must release resources.  However, if the portal\n\t * is not FAILED then we do not release its locks.  The locks become the\n\t * responsibility of the transaction's ResourceOwner (since it is the\n\t * parent of the portal's owner) and will be released when the transaction\n\t * eventually ends.\n\t */\n\tif (portal->resowner &&\n\t\t(!isTopCommit || portal->status == PORTAL_FAILED))\n\t{\n\t\tbool\t\tisCommit = (portal->status != PORTAL_FAILED);\n\n\t\tResourceOwnerRelease(portal->resowner,\n\t\t\t\t\t\t\t RESOURCE_RELEASE_BEFORE_LOCKS,\n\t\t\t\t\t\t\t isCommit, false);\n\t\tResourceOwnerRelease(portal->resowner,\n\t\t\t\t\t\t\t RESOURCE_RELEASE_LOCKS,\n\t\t\t\t\t\t\t isCommit, false);\n\t\tResourceOwnerRelease(portal->resowner,\n\t\t\t\t\t\t\t RESOURCE_RELEASE_AFTER_LOCKS,\n\t\t\t\t\t\t\t isCommit, false);\n\t\tResourceOwnerDelete(portal->resowner);\n\t}\n\tportal->resowner = NULL;\n\n\t/*\n\t * Delete tuplestore if present.  We should do this even under error\n\t * conditions; since the tuplestore would have been using cross-\n\t * transaction storage, its temp files need to be explicitly deleted.\n\t */\n\tif (portal->holdStore)\n\t{\n\t\tMemoryContext oldcontext;\n\n\t\toldcontext = MemoryContextSwitchTo(portal->holdContext);\n\t\ttuplestore_end(portal->holdStore);\n\t\tMemoryContextSwitchTo(oldcontext);\n\t\tportal->holdStore = NULL;\n\t}\n\n\t/* delete tuplestore storage, if any */\n\tif (portal->holdContext)\n\t\tMemoryContextDelete(portal->holdContext);\n\n\t/* release subsidiary storage */\n\tMemoryContextDelete(portal->portalContext);\n\n\t/* release portal struct (it's in TopPortalContext) */\n\tpfree(portal);\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/portalcmds.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static MemoryContext TopPortalContext = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/ipc.h\"\n#include \"miscadmin.h\"\n#include \"commands/portalcmds.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic MemoryContext TopPortalContext = NULL;\n\nvoid\nPortalDrop(Portal portal, bool isTopCommit)\n{\n\tAssertArg(PortalIsValid(portal));\n\n\t/*\n\t * Don't allow dropping a pinned portal, it's still needed by whoever\n\t * pinned it.\n\t */\n\tif (portal->portalPinned)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_CURSOR_STATE),\n\t\t\t\t errmsg(\"cannot drop pinned portal \\\"%s\\\"\", portal->name)));\n\n\t/*\n\t * Not sure if the PORTAL_ACTIVE case can validly happen or not...\n\t */\n\tif (portal->status == PORTAL_ACTIVE)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_CURSOR_STATE),\n\t\t\t\t errmsg(\"cannot drop active portal \\\"%s\\\"\", portal->name)));\n\n\t/*\n\t * Allow portalcmds.c to clean up the state it knows about, in particular\n\t * shutting down the executor if still active.  This step potentially runs\n\t * user-defined code so failure has to be expected.  It's the cleanup\n\t * hook's responsibility to not try to do that more than once, in the case\n\t * that failure occurs and then we come back to drop the portal again\n\t * during transaction abort.\n\t *\n\t * Note: in most paths of control, this will have been done already in\n\t * MarkPortalDone or MarkPortalFailed.  We're just making sure.\n\t */\n\tif (PointerIsValid(portal->cleanup))\n\t{\n\t\tportal->cleanup(portal);\n\t\tportal->cleanup = NULL;\n\t}\n\n\t/*\n\t * Remove portal from hash table.  Because we do this here, we will not\n\t * come back to try to remove the portal again if there's any error in the\n\t * subsequent steps.  Better to leak a little memory than to get into an\n\t * infinite error-recovery loop.\n\t */\n\tPortalHashTableDelete(portal);\n\n\t/* drop cached plan reference, if any */\n\tPortalReleaseCachedPlan(portal);\n\n\t/*\n\t * If portal has a snapshot protecting its data, release that.  This needs\n\t * a little care since the registration will be attached to the portal's\n\t * resowner; if the portal failed, we will already have released the\n\t * resowner (and the snapshot) during transaction abort.\n\t */\n\tif (portal->holdSnapshot)\n\t{\n\t\tif (portal->resowner)\n\t\t\tUnregisterSnapshotFromOwner(portal->holdSnapshot,\n\t\t\t\t\t\t\t\t\t\tportal->resowner);\n\t\tportal->holdSnapshot = NULL;\n\t}\n\n\t/*\n\t * Release any resources still attached to the portal.  There are several\n\t * cases being covered here:\n\t *\n\t * Top transaction commit (indicated by isTopCommit): normally we should\n\t * do nothing here and let the regular end-of-transaction resource\n\t * releasing mechanism handle these resources too.  However, if we have a\n\t * FAILED portal (eg, a cursor that got an error), we'd better clean up\n\t * its resources to avoid resource-leakage warning messages.\n\t *\n\t * Sub transaction commit: never comes here at all, since we don't kill\n\t * any portals in AtSubCommit_Portals().\n\t *\n\t * Main or sub transaction abort: we will do nothing here because\n\t * portal->resowner was already set NULL; the resources were already\n\t * cleaned up in transaction abort.\n\t *\n\t * Ordinary portal drop: must release resources.  However, if the portal\n\t * is not FAILED then we do not release its locks.  The locks become the\n\t * responsibility of the transaction's ResourceOwner (since it is the\n\t * parent of the portal's owner) and will be released when the transaction\n\t * eventually ends.\n\t */\n\tif (portal->resowner &&\n\t\t(!isTopCommit || portal->status == PORTAL_FAILED))\n\t{\n\t\tbool\t\tisCommit = (portal->status != PORTAL_FAILED);\n\n\t\tResourceOwnerRelease(portal->resowner,\n\t\t\t\t\t\t\t RESOURCE_RELEASE_BEFORE_LOCKS,\n\t\t\t\t\t\t\t isCommit, false);\n\t\tResourceOwnerRelease(portal->resowner,\n\t\t\t\t\t\t\t RESOURCE_RELEASE_LOCKS,\n\t\t\t\t\t\t\t isCommit, false);\n\t\tResourceOwnerRelease(portal->resowner,\n\t\t\t\t\t\t\t RESOURCE_RELEASE_AFTER_LOCKS,\n\t\t\t\t\t\t\t isCommit, false);\n\t\tResourceOwnerDelete(portal->resowner);\n\t}\n\tportal->resowner = NULL;\n\n\t/*\n\t * Delete tuplestore if present.  We should do this even under error\n\t * conditions; since the tuplestore would have been using cross-\n\t * transaction storage, its temp files need to be explicitly deleted.\n\t */\n\tif (portal->holdStore)\n\t{\n\t\tMemoryContext oldcontext;\n\n\t\toldcontext = MemoryContextSwitchTo(portal->holdContext);\n\t\ttuplestore_end(portal->holdStore);\n\t\tMemoryContextSwitchTo(oldcontext);\n\t\tportal->holdStore = NULL;\n\t}\n\n\t/* delete tuplestore storage, if any */\n\tif (portal->holdContext)\n\t\tMemoryContextDelete(portal->holdContext);\n\n\t/* release subsidiary storage */\n\tMemoryContextDelete(portal->portalContext);\n\n\t/* release portal struct (it's in TopPortalContext) */\n\tpfree(portal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_seq_search",
          "args": [
            "&status"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "hash_seq_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "1388-1462",
          "snippet": "void *\nhash_seq_search(HASH_SEQ_STATUS *status)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\tuint32\t\tmax_bucket;\n\tlong\t\tssize;\n\tlong\t\tsegment_num;\n\tlong\t\tsegment_ndx;\n\tHASHSEGMENT segp;\n\tuint32\t\tcurBucket;\n\tHASHELEMENT *curElem;\n\n\tif ((curElem = status->curEntry) != NULL)\n\t{\n\t\t/* Continuing scan of curBucket... */\n\t\tstatus->curEntry = curElem->link;\n\t\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t\t++status->curBucket;\n\t\treturn (void *) ELEMENTKEY(curElem);\n\t}\n\n\t/*\n\t * Search for next nonempty bucket starting at curBucket.\n\t */\n\tcurBucket = status->curBucket;\n\thashp = status->hashp;\n\thctl = hashp->hctl;\n\tssize = hashp->ssize;\n\tmax_bucket = hctl->max_bucket;\n\n\tif (curBucket > max_bucket)\n\t{\n\t\thash_seq_term(status);\n\t\treturn NULL;\t\t\t/* search is done */\n\t}\n\n\t/*\n\t * first find the right segment in the table directory.\n\t */\n\tsegment_num = curBucket >> hashp->sshift;\n\tsegment_ndx = MOD(curBucket, ssize);\n\n\tsegp = hashp->dir[segment_num];\n\n\t/*\n\t * Pick up the first item in this bucket's chain.  If chain is not empty\n\t * we can begin searching it.  Otherwise we have to advance to find the\n\t * next nonempty bucket.  We try to optimize that case since searching a\n\t * near-empty hashtable has to iterate this loop a lot.\n\t */\n\twhile ((curElem = segp[segment_ndx]) == NULL)\n\t{\n\t\t/* empty bucket, advance to next */\n\t\tif (++curBucket > max_bucket)\n\t\t{\n\t\t\tstatus->curBucket = curBucket;\n\t\t\thash_seq_term(status);\n\t\t\treturn NULL;\t\t/* search is done */\n\t\t}\n\t\tif (++segment_ndx >= ssize)\n\t\t{\n\t\t\tsegment_num++;\n\t\t\tsegment_ndx = 0;\n\t\t\tsegp = hashp->dir[segment_num];\n\t\t}\n\t}\n\n\t/* Begin scan of curBucket... */\n\tstatus->curEntry = curElem->link;\n\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t++curBucket;\n\tstatus->curBucket = curBucket;\n\treturn (void *) ELEMENTKEY(curElem);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid *\nhash_seq_search(HASH_SEQ_STATUS *status)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\tuint32\t\tmax_bucket;\n\tlong\t\tssize;\n\tlong\t\tsegment_num;\n\tlong\t\tsegment_ndx;\n\tHASHSEGMENT segp;\n\tuint32\t\tcurBucket;\n\tHASHELEMENT *curElem;\n\n\tif ((curElem = status->curEntry) != NULL)\n\t{\n\t\t/* Continuing scan of curBucket... */\n\t\tstatus->curEntry = curElem->link;\n\t\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t\t++status->curBucket;\n\t\treturn (void *) ELEMENTKEY(curElem);\n\t}\n\n\t/*\n\t * Search for next nonempty bucket starting at curBucket.\n\t */\n\tcurBucket = status->curBucket;\n\thashp = status->hashp;\n\thctl = hashp->hctl;\n\tssize = hashp->ssize;\n\tmax_bucket = hctl->max_bucket;\n\n\tif (curBucket > max_bucket)\n\t{\n\t\thash_seq_term(status);\n\t\treturn NULL;\t\t\t/* search is done */\n\t}\n\n\t/*\n\t * first find the right segment in the table directory.\n\t */\n\tsegment_num = curBucket >> hashp->sshift;\n\tsegment_ndx = MOD(curBucket, ssize);\n\n\tsegp = hashp->dir[segment_num];\n\n\t/*\n\t * Pick up the first item in this bucket's chain.  If chain is not empty\n\t * we can begin searching it.  Otherwise we have to advance to find the\n\t * next nonempty bucket.  We try to optimize that case since searching a\n\t * near-empty hashtable has to iterate this loop a lot.\n\t */\n\twhile ((curElem = segp[segment_ndx]) == NULL)\n\t{\n\t\t/* empty bucket, advance to next */\n\t\tif (++curBucket > max_bucket)\n\t\t{\n\t\t\tstatus->curBucket = curBucket;\n\t\t\thash_seq_term(status);\n\t\t\treturn NULL;\t\t/* search is done */\n\t\t}\n\t\tif (++segment_ndx >= ssize)\n\t\t{\n\t\t\tsegment_num++;\n\t\t\tsegment_ndx = 0;\n\t\t\tsegp = hashp->dir[segment_num];\n\t\t}\n\t}\n\n\t/* Begin scan of curBucket... */\n\tstatus->curEntry = curElem->link;\n\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t++curBucket;\n\tstatus->curBucket = curBucket;\n\treturn (void *) ELEMENTKEY(curElem);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/ipc.h\"\n#include \"miscadmin.h\"\n#include \"commands/portalcmds.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic HTAB *PortalHashTable = NULL;\n\nvoid\nPortalHashTableDeleteAll(void)\n{\n\tHASH_SEQ_STATUS status;\n\tPortalHashEnt *hentry;\n\n\tif (PortalHashTable == NULL)\n\t\treturn;\n\n\thash_seq_init(&status, PortalHashTable);\n\twhile ((hentry = hash_seq_search(&status)) != NULL)\n\t{\n\t\tPortal\t\tportal = hentry->portal;\n\n\t\t/* Can't close the active portal (the one running the command) */\n\t\tif (portal->status == PORTAL_ACTIVE)\n\t\t\tcontinue;\n\n\t\tPortalDrop(portal, false);\n\n\t\t/* Restart the iteration in case that led to other drops */\n\t\thash_seq_term(&status);\n\t\thash_seq_init(&status, PortalHashTable);\n\t}\n}"
  },
  {
    "function_name": "PortalDrop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/portalmem.c",
    "lines": "464-593",
    "snippet": "void\nPortalDrop(Portal portal, bool isTopCommit)\n{\n\tAssertArg(PortalIsValid(portal));\n\n\t/*\n\t * Don't allow dropping a pinned portal, it's still needed by whoever\n\t * pinned it.\n\t */\n\tif (portal->portalPinned)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_CURSOR_STATE),\n\t\t\t\t errmsg(\"cannot drop pinned portal \\\"%s\\\"\", portal->name)));\n\n\t/*\n\t * Not sure if the PORTAL_ACTIVE case can validly happen or not...\n\t */\n\tif (portal->status == PORTAL_ACTIVE)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_CURSOR_STATE),\n\t\t\t\t errmsg(\"cannot drop active portal \\\"%s\\\"\", portal->name)));\n\n\t/*\n\t * Allow portalcmds.c to clean up the state it knows about, in particular\n\t * shutting down the executor if still active.  This step potentially runs\n\t * user-defined code so failure has to be expected.  It's the cleanup\n\t * hook's responsibility to not try to do that more than once, in the case\n\t * that failure occurs and then we come back to drop the portal again\n\t * during transaction abort.\n\t *\n\t * Note: in most paths of control, this will have been done already in\n\t * MarkPortalDone or MarkPortalFailed.  We're just making sure.\n\t */\n\tif (PointerIsValid(portal->cleanup))\n\t{\n\t\tportal->cleanup(portal);\n\t\tportal->cleanup = NULL;\n\t}\n\n\t/*\n\t * Remove portal from hash table.  Because we do this here, we will not\n\t * come back to try to remove the portal again if there's any error in the\n\t * subsequent steps.  Better to leak a little memory than to get into an\n\t * infinite error-recovery loop.\n\t */\n\tPortalHashTableDelete(portal);\n\n\t/* drop cached plan reference, if any */\n\tPortalReleaseCachedPlan(portal);\n\n\t/*\n\t * If portal has a snapshot protecting its data, release that.  This needs\n\t * a little care since the registration will be attached to the portal's\n\t * resowner; if the portal failed, we will already have released the\n\t * resowner (and the snapshot) during transaction abort.\n\t */\n\tif (portal->holdSnapshot)\n\t{\n\t\tif (portal->resowner)\n\t\t\tUnregisterSnapshotFromOwner(portal->holdSnapshot,\n\t\t\t\t\t\t\t\t\t\tportal->resowner);\n\t\tportal->holdSnapshot = NULL;\n\t}\n\n\t/*\n\t * Release any resources still attached to the portal.  There are several\n\t * cases being covered here:\n\t *\n\t * Top transaction commit (indicated by isTopCommit): normally we should\n\t * do nothing here and let the regular end-of-transaction resource\n\t * releasing mechanism handle these resources too.  However, if we have a\n\t * FAILED portal (eg, a cursor that got an error), we'd better clean up\n\t * its resources to avoid resource-leakage warning messages.\n\t *\n\t * Sub transaction commit: never comes here at all, since we don't kill\n\t * any portals in AtSubCommit_Portals().\n\t *\n\t * Main or sub transaction abort: we will do nothing here because\n\t * portal->resowner was already set NULL; the resources were already\n\t * cleaned up in transaction abort.\n\t *\n\t * Ordinary portal drop: must release resources.  However, if the portal\n\t * is not FAILED then we do not release its locks.  The locks become the\n\t * responsibility of the transaction's ResourceOwner (since it is the\n\t * parent of the portal's owner) and will be released when the transaction\n\t * eventually ends.\n\t */\n\tif (portal->resowner &&\n\t\t(!isTopCommit || portal->status == PORTAL_FAILED))\n\t{\n\t\tbool\t\tisCommit = (portal->status != PORTAL_FAILED);\n\n\t\tResourceOwnerRelease(portal->resowner,\n\t\t\t\t\t\t\t RESOURCE_RELEASE_BEFORE_LOCKS,\n\t\t\t\t\t\t\t isCommit, false);\n\t\tResourceOwnerRelease(portal->resowner,\n\t\t\t\t\t\t\t RESOURCE_RELEASE_LOCKS,\n\t\t\t\t\t\t\t isCommit, false);\n\t\tResourceOwnerRelease(portal->resowner,\n\t\t\t\t\t\t\t RESOURCE_RELEASE_AFTER_LOCKS,\n\t\t\t\t\t\t\t isCommit, false);\n\t\tResourceOwnerDelete(portal->resowner);\n\t}\n\tportal->resowner = NULL;\n\n\t/*\n\t * Delete tuplestore if present.  We should do this even under error\n\t * conditions; since the tuplestore would have been using cross-\n\t * transaction storage, its temp files need to be explicitly deleted.\n\t */\n\tif (portal->holdStore)\n\t{\n\t\tMemoryContext oldcontext;\n\n\t\toldcontext = MemoryContextSwitchTo(portal->holdContext);\n\t\ttuplestore_end(portal->holdStore);\n\t\tMemoryContextSwitchTo(oldcontext);\n\t\tportal->holdStore = NULL;\n\t}\n\n\t/* delete tuplestore storage, if any */\n\tif (portal->holdContext)\n\t\tMemoryContextDelete(portal->holdContext);\n\n\t/* release subsidiary storage */\n\tMemoryContextDelete(portal->portalContext);\n\n\t/* release portal struct (it's in TopPortalContext) */\n\tpfree(portal);\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/portalcmds.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static MemoryContext TopPortalContext = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "portal"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextDelete",
          "args": [
            "portal->portalContext"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextDeleteChildren",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "255-266",
          "snippet": "void\nMemoryContextDeleteChildren(MemoryContext context)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\n\t/*\n\t * MemoryContextDelete will delink the child from me, so just iterate as\n\t * long as there is a child.\n\t */\n\twhile (context->firstchild != NULL)\n\t\tMemoryContextDelete(context->firstchild);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\nMemoryContextDeleteChildren(MemoryContext context)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\n\t/*\n\t * MemoryContextDelete will delink the child from me, so just iterate as\n\t * long as there is a child.\n\t */\n\twhile (context->firstchild != NULL)\n\t\tMemoryContextDelete(context->firstchild);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tuplestore_end",
          "args": [
            "portal->holdStore"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "tuplestore_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplestore.c",
          "lines": "452-467",
          "snippet": "void\ntuplestore_end(Tuplestorestate *state)\n{\n\tint\t\t\ti;\n\n\tif (state->myfile)\n\t\tBufFileClose(state->myfile);\n\tif (state->memtuples)\n\t{\n\t\tfor (i = state->memtupdeleted; i < state->memtupcount; i++)\n\t\t\tpfree(state->memtuples[i]);\n\t\tpfree(state->memtuples);\n\t}\n\tpfree(state->readptrs);\n\tpfree(state);\n}",
          "includes": [
            "#include \"utils/resowner.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void dumptuples(Tuplestorestate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/resowner.h\"\n#include \"utils/memutils.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void dumptuples(Tuplestorestate *state);\n\nvoid\ntuplestore_end(Tuplestorestate *state)\n{\n\tint\t\t\ti;\n\n\tif (state->myfile)\n\t\tBufFileClose(state->myfile);\n\tif (state->memtuples)\n\t{\n\t\tfor (i = state->memtupdeleted; i < state->memtupcount; i++)\n\t\t\tpfree(state->memtuples[i]);\n\t\tpfree(state->memtuples);\n\t}\n\tpfree(state->readptrs);\n\tpfree(state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "portal->holdContext"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ResourceOwnerDelete",
          "args": [
            "portal->resowner"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "ResourceOwnerDelete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "683-729",
          "snippet": "void\nResourceOwnerDelete(ResourceOwner owner)\n{\n\t/* We had better not be deleting CurrentResourceOwner ... */\n\tAssert(owner != CurrentResourceOwner);\n\n\t/* And it better not own any resources, either */\n\tAssert(owner->bufferarr.nitems == 0);\n\tAssert(owner->catrefarr.nitems == 0);\n\tAssert(owner->catlistrefarr.nitems == 0);\n\tAssert(owner->relrefarr.nitems == 0);\n\tAssert(owner->planrefarr.nitems == 0);\n\tAssert(owner->tupdescarr.nitems == 0);\n\tAssert(owner->snapshotarr.nitems == 0);\n\tAssert(owner->filearr.nitems == 0);\n\tAssert(owner->dsmarr.nitems == 0);\n\tAssert(owner->jitarr.nitems == 0);\n\tAssert(owner->nlocks == 0 || owner->nlocks == MAX_RESOWNER_LOCKS + 1);\n\n\t/*\n\t * Delete children.  The recursive call will delink the child from me, so\n\t * just iterate as long as there is a child.\n\t */\n\twhile (owner->firstchild != NULL)\n\t\tResourceOwnerDelete(owner->firstchild);\n\n\t/*\n\t * We delink the owner from its parent before deleting it, so that if\n\t * there's an error we won't have deleted/busted owners still attached to\n\t * the owner tree.  Better a leak than a crash.\n\t */\n\tResourceOwnerNewParent(owner, NULL);\n\n\t/* And free the object. */\n\tResourceArrayFree(&(owner->bufferarr));\n\tResourceArrayFree(&(owner->catrefarr));\n\tResourceArrayFree(&(owner->catlistrefarr));\n\tResourceArrayFree(&(owner->relrefarr));\n\tResourceArrayFree(&(owner->planrefarr));\n\tResourceArrayFree(&(owner->tupdescarr));\n\tResourceArrayFree(&(owner->snapshotarr));\n\tResourceArrayFree(&(owner->filearr));\n\tResourceArrayFree(&(owner->dsmarr));\n\tResourceArrayFree(&(owner->jitarr));\n\n\tpfree(owner);\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"jit/jit.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MAX_RESOWNER_LOCKS 15"
          ],
          "globals_used": [
            "ResourceOwner CurrentResourceOwner = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\n#define MAX_RESOWNER_LOCKS 15\n\nResourceOwner CurrentResourceOwner = NULL;\n\nvoid\nResourceOwnerDelete(ResourceOwner owner)\n{\n\t/* We had better not be deleting CurrentResourceOwner ... */\n\tAssert(owner != CurrentResourceOwner);\n\n\t/* And it better not own any resources, either */\n\tAssert(owner->bufferarr.nitems == 0);\n\tAssert(owner->catrefarr.nitems == 0);\n\tAssert(owner->catlistrefarr.nitems == 0);\n\tAssert(owner->relrefarr.nitems == 0);\n\tAssert(owner->planrefarr.nitems == 0);\n\tAssert(owner->tupdescarr.nitems == 0);\n\tAssert(owner->snapshotarr.nitems == 0);\n\tAssert(owner->filearr.nitems == 0);\n\tAssert(owner->dsmarr.nitems == 0);\n\tAssert(owner->jitarr.nitems == 0);\n\tAssert(owner->nlocks == 0 || owner->nlocks == MAX_RESOWNER_LOCKS + 1);\n\n\t/*\n\t * Delete children.  The recursive call will delink the child from me, so\n\t * just iterate as long as there is a child.\n\t */\n\twhile (owner->firstchild != NULL)\n\t\tResourceOwnerDelete(owner->firstchild);\n\n\t/*\n\t * We delink the owner from its parent before deleting it, so that if\n\t * there's an error we won't have deleted/busted owners still attached to\n\t * the owner tree.  Better a leak than a crash.\n\t */\n\tResourceOwnerNewParent(owner, NULL);\n\n\t/* And free the object. */\n\tResourceArrayFree(&(owner->bufferarr));\n\tResourceArrayFree(&(owner->catrefarr));\n\tResourceArrayFree(&(owner->catlistrefarr));\n\tResourceArrayFree(&(owner->relrefarr));\n\tResourceArrayFree(&(owner->planrefarr));\n\tResourceArrayFree(&(owner->tupdescarr));\n\tResourceArrayFree(&(owner->snapshotarr));\n\tResourceArrayFree(&(owner->filearr));\n\tResourceArrayFree(&(owner->dsmarr));\n\tResourceArrayFree(&(owner->jitarr));\n\n\tpfree(owner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ResourceOwnerRelease",
          "args": [
            "portal->resowner",
            "RESOURCE_RELEASE_AFTER_LOCKS",
            "isCommit",
            "false"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "ResourceOwnerReleaseInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "483-675",
          "snippet": "static void\nResourceOwnerReleaseInternal(ResourceOwner owner,\n\t\t\t\t\t\t\t ResourceReleasePhase phase,\n\t\t\t\t\t\t\t bool isCommit,\n\t\t\t\t\t\t\t bool isTopLevel)\n{\n\tResourceOwner child;\n\tResourceOwner save;\n\tResourceReleaseCallbackItem *item;\n\tDatum\t\tfoundres;\n\n\t/* Recurse to handle descendants */\n\tfor (child = owner->firstchild; child != NULL; child = child->nextchild)\n\t\tResourceOwnerReleaseInternal(child, phase, isCommit, isTopLevel);\n\n\t/*\n\t * Make CurrentResourceOwner point to me, so that ReleaseBuffer etc don't\n\t * get confused.\n\t */\n\tsave = CurrentResourceOwner;\n\tCurrentResourceOwner = owner;\n\n\tif (phase == RESOURCE_RELEASE_BEFORE_LOCKS)\n\t{\n\t\t/*\n\t\t * Release buffer pins.  Note that ReleaseBuffer will remove the\n\t\t * buffer entry from our array, so we just have to iterate till there\n\t\t * are none.\n\t\t *\n\t\t * During a commit, there shouldn't be any remaining pins --- that\n\t\t * would indicate failure to clean up the executor correctly --- so\n\t\t * issue warnings.  In the abort case, just clean up quietly.\n\t\t */\n\t\twhile (ResourceArrayGetAny(&(owner->bufferarr), &foundres))\n\t\t{\n\t\t\tBuffer\t\tres = DatumGetBuffer(foundres);\n\n\t\t\tif (isCommit)\n\t\t\t\tPrintBufferLeakWarning(res);\n\t\t\tReleaseBuffer(res);\n\t\t}\n\n\t\t/* Ditto for relcache references */\n\t\twhile (ResourceArrayGetAny(&(owner->relrefarr), &foundres))\n\t\t{\n\t\t\tRelation\tres = (Relation) DatumGetPointer(foundres);\n\n\t\t\tif (isCommit)\n\t\t\t\tPrintRelCacheLeakWarning(res);\n\t\t\tRelationClose(res);\n\t\t}\n\n\t\t/* Ditto for dynamic shared memory segments */\n\t\twhile (ResourceArrayGetAny(&(owner->dsmarr), &foundres))\n\t\t{\n\t\t\tdsm_segment *res = (dsm_segment *) DatumGetPointer(foundres);\n\n\t\t\tif (isCommit)\n\t\t\t\tPrintDSMLeakWarning(res);\n\t\t\tdsm_detach(res);\n\t\t}\n\n\t\t/* Ditto for JIT contexts */\n\t\twhile (ResourceArrayGetAny(&(owner->jitarr), &foundres))\n\t\t{\n\t\t\tJitContext *context = (JitContext *) PointerGetDatum(foundres);\n\n\t\t\tjit_release_context(context);\n\t\t}\n\t}\n\telse if (phase == RESOURCE_RELEASE_LOCKS)\n\t{\n\t\tif (isTopLevel)\n\t\t{\n\t\t\t/*\n\t\t\t * For a top-level xact we are going to release all locks (or at\n\t\t\t * least all non-session locks), so just do a single lmgr call at\n\t\t\t * the top of the recursion.\n\t\t\t */\n\t\t\tif (owner == TopTransactionResourceOwner)\n\t\t\t{\n\t\t\t\tProcReleaseLocks(isCommit);\n\t\t\t\tReleasePredicateLocks(isCommit);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Release locks retail.  Note that if we are committing a\n\t\t\t * subtransaction, we do NOT release its locks yet, but transfer\n\t\t\t * them to the parent.\n\t\t\t */\n\t\t\tLOCALLOCK **locks;\n\t\t\tint\t\t\tnlocks;\n\n\t\t\tAssert(owner->parent != NULL);\n\n\t\t\t/*\n\t\t\t * Pass the list of locks owned by this resource owner to the lock\n\t\t\t * manager, unless it has overflowed.\n\t\t\t */\n\t\t\tif (owner->nlocks > MAX_RESOWNER_LOCKS)\n\t\t\t{\n\t\t\t\tlocks = NULL;\n\t\t\t\tnlocks = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlocks = owner->locks;\n\t\t\t\tnlocks = owner->nlocks;\n\t\t\t}\n\n\t\t\tif (isCommit)\n\t\t\t\tLockReassignCurrentOwner(locks, nlocks);\n\t\t\telse\n\t\t\t\tLockReleaseCurrentOwner(locks, nlocks);\n\t\t}\n\t}\n\telse if (phase == RESOURCE_RELEASE_AFTER_LOCKS)\n\t{\n\t\t/*\n\t\t * Release catcache references.  Note that ReleaseCatCache will remove\n\t\t * the catref entry from our array, so we just have to iterate till\n\t\t * there are none.\n\t\t *\n\t\t * As with buffer pins, warn if any are left at commit time.\n\t\t */\n\t\twhile (ResourceArrayGetAny(&(owner->catrefarr), &foundres))\n\t\t{\n\t\t\tHeapTuple\tres = (HeapTuple) DatumGetPointer(foundres);\n\n\t\t\tif (isCommit)\n\t\t\t\tPrintCatCacheLeakWarning(res);\n\t\t\tReleaseCatCache(res);\n\t\t}\n\n\t\t/* Ditto for catcache lists */\n\t\twhile (ResourceArrayGetAny(&(owner->catlistrefarr), &foundres))\n\t\t{\n\t\t\tCatCList   *res = (CatCList *) DatumGetPointer(foundres);\n\n\t\t\tif (isCommit)\n\t\t\t\tPrintCatCacheListLeakWarning(res);\n\t\t\tReleaseCatCacheList(res);\n\t\t}\n\n\t\t/* Ditto for plancache references */\n\t\twhile (ResourceArrayGetAny(&(owner->planrefarr), &foundres))\n\t\t{\n\t\t\tCachedPlan *res = (CachedPlan *) DatumGetPointer(foundres);\n\n\t\t\tif (isCommit)\n\t\t\t\tPrintPlanCacheLeakWarning(res);\n\t\t\tReleaseCachedPlan(res, true);\n\t\t}\n\n\t\t/* Ditto for tupdesc references */\n\t\twhile (ResourceArrayGetAny(&(owner->tupdescarr), &foundres))\n\t\t{\n\t\t\tTupleDesc\tres = (TupleDesc) DatumGetPointer(foundres);\n\n\t\t\tif (isCommit)\n\t\t\t\tPrintTupleDescLeakWarning(res);\n\t\t\tDecrTupleDescRefCount(res);\n\t\t}\n\n\t\t/* Ditto for snapshot references */\n\t\twhile (ResourceArrayGetAny(&(owner->snapshotarr), &foundres))\n\t\t{\n\t\t\tSnapshot\tres = (Snapshot) DatumGetPointer(foundres);\n\n\t\t\tif (isCommit)\n\t\t\t\tPrintSnapshotLeakWarning(res);\n\t\t\tUnregisterSnapshot(res);\n\t\t}\n\n\t\t/* Ditto for temporary files */\n\t\twhile (ResourceArrayGetAny(&(owner->filearr), &foundres))\n\t\t{\n\t\t\tFile\t\tres = DatumGetFile(foundres);\n\n\t\t\tif (isCommit)\n\t\t\t\tPrintFileLeakWarning(res);\n\t\t\tFileClose(res);\n\t\t}\n\t}\n\n\t/* Let add-on modules get a chance too */\n\tfor (item = ResourceRelease_callbacks; item; item = item->next)\n\t\titem->callback(phase, isCommit, isTopLevel, item->arg);\n\n\tCurrentResourceOwner = save;\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"jit/jit.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MAX_RESOWNER_LOCKS 15"
          ],
          "globals_used": [
            "ResourceOwner CurrentResourceOwner = NULL;",
            "ResourceOwner TopTransactionResourceOwner = NULL;",
            "static ResourceReleaseCallbackItem *ResourceRelease_callbacks = NULL;",
            "static void ResourceOwnerReleaseInternal(ResourceOwner owner,\n\t\t\t\t\t\t\t ResourceReleasePhase phase,\n\t\t\t\t\t\t\t bool isCommit,\n\t\t\t\t\t\t\t bool isTopLevel);",
            "static void PrintTupleDescLeakWarning(TupleDesc tupdesc);",
            "static void PrintSnapshotLeakWarning(Snapshot snapshot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\n#define MAX_RESOWNER_LOCKS 15\n\nResourceOwner CurrentResourceOwner = NULL;\nResourceOwner TopTransactionResourceOwner = NULL;\nstatic ResourceReleaseCallbackItem *ResourceRelease_callbacks = NULL;\nstatic void ResourceOwnerReleaseInternal(ResourceOwner owner,\n\t\t\t\t\t\t\t ResourceReleasePhase phase,\n\t\t\t\t\t\t\t bool isCommit,\n\t\t\t\t\t\t\t bool isTopLevel);\nstatic void PrintTupleDescLeakWarning(TupleDesc tupdesc);\nstatic void PrintSnapshotLeakWarning(Snapshot snapshot);\n\nstatic void\nResourceOwnerReleaseInternal(ResourceOwner owner,\n\t\t\t\t\t\t\t ResourceReleasePhase phase,\n\t\t\t\t\t\t\t bool isCommit,\n\t\t\t\t\t\t\t bool isTopLevel)\n{\n\tResourceOwner child;\n\tResourceOwner save;\n\tResourceReleaseCallbackItem *item;\n\tDatum\t\tfoundres;\n\n\t/* Recurse to handle descendants */\n\tfor (child = owner->firstchild; child != NULL; child = child->nextchild)\n\t\tResourceOwnerReleaseInternal(child, phase, isCommit, isTopLevel);\n\n\t/*\n\t * Make CurrentResourceOwner point to me, so that ReleaseBuffer etc don't\n\t * get confused.\n\t */\n\tsave = CurrentResourceOwner;\n\tCurrentResourceOwner = owner;\n\n\tif (phase == RESOURCE_RELEASE_BEFORE_LOCKS)\n\t{\n\t\t/*\n\t\t * Release buffer pins.  Note that ReleaseBuffer will remove the\n\t\t * buffer entry from our array, so we just have to iterate till there\n\t\t * are none.\n\t\t *\n\t\t * During a commit, there shouldn't be any remaining pins --- that\n\t\t * would indicate failure to clean up the executor correctly --- so\n\t\t * issue warnings.  In the abort case, just clean up quietly.\n\t\t */\n\t\twhile (ResourceArrayGetAny(&(owner->bufferarr), &foundres))\n\t\t{\n\t\t\tBuffer\t\tres = DatumGetBuffer(foundres);\n\n\t\t\tif (isCommit)\n\t\t\t\tPrintBufferLeakWarning(res);\n\t\t\tReleaseBuffer(res);\n\t\t}\n\n\t\t/* Ditto for relcache references */\n\t\twhile (ResourceArrayGetAny(&(owner->relrefarr), &foundres))\n\t\t{\n\t\t\tRelation\tres = (Relation) DatumGetPointer(foundres);\n\n\t\t\tif (isCommit)\n\t\t\t\tPrintRelCacheLeakWarning(res);\n\t\t\tRelationClose(res);\n\t\t}\n\n\t\t/* Ditto for dynamic shared memory segments */\n\t\twhile (ResourceArrayGetAny(&(owner->dsmarr), &foundres))\n\t\t{\n\t\t\tdsm_segment *res = (dsm_segment *) DatumGetPointer(foundres);\n\n\t\t\tif (isCommit)\n\t\t\t\tPrintDSMLeakWarning(res);\n\t\t\tdsm_detach(res);\n\t\t}\n\n\t\t/* Ditto for JIT contexts */\n\t\twhile (ResourceArrayGetAny(&(owner->jitarr), &foundres))\n\t\t{\n\t\t\tJitContext *context = (JitContext *) PointerGetDatum(foundres);\n\n\t\t\tjit_release_context(context);\n\t\t}\n\t}\n\telse if (phase == RESOURCE_RELEASE_LOCKS)\n\t{\n\t\tif (isTopLevel)\n\t\t{\n\t\t\t/*\n\t\t\t * For a top-level xact we are going to release all locks (or at\n\t\t\t * least all non-session locks), so just do a single lmgr call at\n\t\t\t * the top of the recursion.\n\t\t\t */\n\t\t\tif (owner == TopTransactionResourceOwner)\n\t\t\t{\n\t\t\t\tProcReleaseLocks(isCommit);\n\t\t\t\tReleasePredicateLocks(isCommit);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Release locks retail.  Note that if we are committing a\n\t\t\t * subtransaction, we do NOT release its locks yet, but transfer\n\t\t\t * them to the parent.\n\t\t\t */\n\t\t\tLOCALLOCK **locks;\n\t\t\tint\t\t\tnlocks;\n\n\t\t\tAssert(owner->parent != NULL);\n\n\t\t\t/*\n\t\t\t * Pass the list of locks owned by this resource owner to the lock\n\t\t\t * manager, unless it has overflowed.\n\t\t\t */\n\t\t\tif (owner->nlocks > MAX_RESOWNER_LOCKS)\n\t\t\t{\n\t\t\t\tlocks = NULL;\n\t\t\t\tnlocks = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlocks = owner->locks;\n\t\t\t\tnlocks = owner->nlocks;\n\t\t\t}\n\n\t\t\tif (isCommit)\n\t\t\t\tLockReassignCurrentOwner(locks, nlocks);\n\t\t\telse\n\t\t\t\tLockReleaseCurrentOwner(locks, nlocks);\n\t\t}\n\t}\n\telse if (phase == RESOURCE_RELEASE_AFTER_LOCKS)\n\t{\n\t\t/*\n\t\t * Release catcache references.  Note that ReleaseCatCache will remove\n\t\t * the catref entry from our array, so we just have to iterate till\n\t\t * there are none.\n\t\t *\n\t\t * As with buffer pins, warn if any are left at commit time.\n\t\t */\n\t\twhile (ResourceArrayGetAny(&(owner->catrefarr), &foundres))\n\t\t{\n\t\t\tHeapTuple\tres = (HeapTuple) DatumGetPointer(foundres);\n\n\t\t\tif (isCommit)\n\t\t\t\tPrintCatCacheLeakWarning(res);\n\t\t\tReleaseCatCache(res);\n\t\t}\n\n\t\t/* Ditto for catcache lists */\n\t\twhile (ResourceArrayGetAny(&(owner->catlistrefarr), &foundres))\n\t\t{\n\t\t\tCatCList   *res = (CatCList *) DatumGetPointer(foundres);\n\n\t\t\tif (isCommit)\n\t\t\t\tPrintCatCacheListLeakWarning(res);\n\t\t\tReleaseCatCacheList(res);\n\t\t}\n\n\t\t/* Ditto for plancache references */\n\t\twhile (ResourceArrayGetAny(&(owner->planrefarr), &foundres))\n\t\t{\n\t\t\tCachedPlan *res = (CachedPlan *) DatumGetPointer(foundres);\n\n\t\t\tif (isCommit)\n\t\t\t\tPrintPlanCacheLeakWarning(res);\n\t\t\tReleaseCachedPlan(res, true);\n\t\t}\n\n\t\t/* Ditto for tupdesc references */\n\t\twhile (ResourceArrayGetAny(&(owner->tupdescarr), &foundres))\n\t\t{\n\t\t\tTupleDesc\tres = (TupleDesc) DatumGetPointer(foundres);\n\n\t\t\tif (isCommit)\n\t\t\t\tPrintTupleDescLeakWarning(res);\n\t\t\tDecrTupleDescRefCount(res);\n\t\t}\n\n\t\t/* Ditto for snapshot references */\n\t\twhile (ResourceArrayGetAny(&(owner->snapshotarr), &foundres))\n\t\t{\n\t\t\tSnapshot\tres = (Snapshot) DatumGetPointer(foundres);\n\n\t\t\tif (isCommit)\n\t\t\t\tPrintSnapshotLeakWarning(res);\n\t\t\tUnregisterSnapshot(res);\n\t\t}\n\n\t\t/* Ditto for temporary files */\n\t\twhile (ResourceArrayGetAny(&(owner->filearr), &foundres))\n\t\t{\n\t\t\tFile\t\tres = DatumGetFile(foundres);\n\n\t\t\tif (isCommit)\n\t\t\t\tPrintFileLeakWarning(res);\n\t\t\tFileClose(res);\n\t\t}\n\t}\n\n\t/* Let add-on modules get a chance too */\n\tfor (item = ResourceRelease_callbacks; item; item = item->next)\n\t\titem->callback(phase, isCommit, isTopLevel, item->arg);\n\n\tCurrentResourceOwner = save;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UnregisterSnapshotFromOwner",
          "args": [
            "portal->holdSnapshot",
            "portal->resowner"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "UnregisterSnapshotFromOwner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "917-937",
          "snippet": "void\nUnregisterSnapshotFromOwner(Snapshot snapshot, ResourceOwner owner)\n{\n\tif (snapshot == NULL)\n\t\treturn;\n\n\tAssert(snapshot->regd_count > 0);\n\tAssert(!pairingheap_is_empty(&RegisteredSnapshots));\n\n\tResourceOwnerForgetSnapshot(owner, snapshot);\n\n\tsnapshot->regd_count--;\n\tif (snapshot->regd_count == 0)\n\t\tpairingheap_remove(&RegisteredSnapshots, &snapshot->ph_node);\n\n\tif (snapshot->regd_count == 0 && snapshot->active_count == 0)\n\t{\n\t\tFreeSnapshot(snapshot);\n\t\tSnapshotResetXmin();\n\t}\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};",
            "static Snapshot CopySnapshot(Snapshot snapshot);",
            "static void FreeSnapshot(Snapshot snapshot);",
            "static void SnapshotResetXmin(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};\nstatic Snapshot CopySnapshot(Snapshot snapshot);\nstatic void FreeSnapshot(Snapshot snapshot);\nstatic void SnapshotResetXmin(void);\n\nvoid\nUnregisterSnapshotFromOwner(Snapshot snapshot, ResourceOwner owner)\n{\n\tif (snapshot == NULL)\n\t\treturn;\n\n\tAssert(snapshot->regd_count > 0);\n\tAssert(!pairingheap_is_empty(&RegisteredSnapshots));\n\n\tResourceOwnerForgetSnapshot(owner, snapshot);\n\n\tsnapshot->regd_count--;\n\tif (snapshot->regd_count == 0)\n\t\tpairingheap_remove(&RegisteredSnapshots, &snapshot->ph_node);\n\n\tif (snapshot->regd_count == 0 && snapshot->active_count == 0)\n\t{\n\t\tFreeSnapshot(snapshot);\n\t\tSnapshotResetXmin();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PortalReleaseCachedPlan",
          "args": [
            "portal"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "PortalReleaseCachedPlan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/portalmem.c",
          "lines": "306-321",
          "snippet": "static void\nPortalReleaseCachedPlan(Portal portal)\n{\n\tif (portal->cplan)\n\t{\n\t\tReleaseCachedPlan(portal->cplan, false);\n\t\tportal->cplan = NULL;\n\n\t\t/*\n\t\t * We must also clear portal->stmts which is now a dangling reference\n\t\t * to the cached plan's plan list.  This protects any code that might\n\t\t * try to examine the Portal later.\n\t\t */\n\t\tportal->stmts = NIL;\n\t}\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/portalcmds.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/ipc.h\"\n#include \"miscadmin.h\"\n#include \"commands/portalcmds.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic void\nPortalReleaseCachedPlan(Portal portal)\n{\n\tif (portal->cplan)\n\t{\n\t\tReleaseCachedPlan(portal->cplan, false);\n\t\tportal->cplan = NULL;\n\n\t\t/*\n\t\t * We must also clear portal->stmts which is now a dangling reference\n\t\t * to the cached plan's plan list.  This protects any code that might\n\t\t * try to examine the Portal later.\n\t\t */\n\t\tportal->stmts = NIL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PortalHashTableDelete",
          "args": [
            "portal"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "portal->cleanup",
          "args": [
            "portal"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerIsValid",
          "args": [
            "portal->cleanup"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_CURSOR_STATE),\n\t\t\t\t errmsg(\"cannot drop active portal \\\"%s\\\"\", portal->name))"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"cannot drop active portal \\\"%s\\\"\"",
            "portal->name"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_CURSOR_STATE"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_CURSOR_STATE),\n\t\t\t\t errmsg(\"cannot drop pinned portal \\\"%s\\\"\", portal->name))"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AssertArg",
          "args": [
            "PortalIsValid(portal)"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PortalIsValid",
          "args": [
            "portal"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/ipc.h\"\n#include \"miscadmin.h\"\n#include \"commands/portalcmds.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic MemoryContext TopPortalContext = NULL;\n\nvoid\nPortalDrop(Portal portal, bool isTopCommit)\n{\n\tAssertArg(PortalIsValid(portal));\n\n\t/*\n\t * Don't allow dropping a pinned portal, it's still needed by whoever\n\t * pinned it.\n\t */\n\tif (portal->portalPinned)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_CURSOR_STATE),\n\t\t\t\t errmsg(\"cannot drop pinned portal \\\"%s\\\"\", portal->name)));\n\n\t/*\n\t * Not sure if the PORTAL_ACTIVE case can validly happen or not...\n\t */\n\tif (portal->status == PORTAL_ACTIVE)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_CURSOR_STATE),\n\t\t\t\t errmsg(\"cannot drop active portal \\\"%s\\\"\", portal->name)));\n\n\t/*\n\t * Allow portalcmds.c to clean up the state it knows about, in particular\n\t * shutting down the executor if still active.  This step potentially runs\n\t * user-defined code so failure has to be expected.  It's the cleanup\n\t * hook's responsibility to not try to do that more than once, in the case\n\t * that failure occurs and then we come back to drop the portal again\n\t * during transaction abort.\n\t *\n\t * Note: in most paths of control, this will have been done already in\n\t * MarkPortalDone or MarkPortalFailed.  We're just making sure.\n\t */\n\tif (PointerIsValid(portal->cleanup))\n\t{\n\t\tportal->cleanup(portal);\n\t\tportal->cleanup = NULL;\n\t}\n\n\t/*\n\t * Remove portal from hash table.  Because we do this here, we will not\n\t * come back to try to remove the portal again if there's any error in the\n\t * subsequent steps.  Better to leak a little memory than to get into an\n\t * infinite error-recovery loop.\n\t */\n\tPortalHashTableDelete(portal);\n\n\t/* drop cached plan reference, if any */\n\tPortalReleaseCachedPlan(portal);\n\n\t/*\n\t * If portal has a snapshot protecting its data, release that.  This needs\n\t * a little care since the registration will be attached to the portal's\n\t * resowner; if the portal failed, we will already have released the\n\t * resowner (and the snapshot) during transaction abort.\n\t */\n\tif (portal->holdSnapshot)\n\t{\n\t\tif (portal->resowner)\n\t\t\tUnregisterSnapshotFromOwner(portal->holdSnapshot,\n\t\t\t\t\t\t\t\t\t\tportal->resowner);\n\t\tportal->holdSnapshot = NULL;\n\t}\n\n\t/*\n\t * Release any resources still attached to the portal.  There are several\n\t * cases being covered here:\n\t *\n\t * Top transaction commit (indicated by isTopCommit): normally we should\n\t * do nothing here and let the regular end-of-transaction resource\n\t * releasing mechanism handle these resources too.  However, if we have a\n\t * FAILED portal (eg, a cursor that got an error), we'd better clean up\n\t * its resources to avoid resource-leakage warning messages.\n\t *\n\t * Sub transaction commit: never comes here at all, since we don't kill\n\t * any portals in AtSubCommit_Portals().\n\t *\n\t * Main or sub transaction abort: we will do nothing here because\n\t * portal->resowner was already set NULL; the resources were already\n\t * cleaned up in transaction abort.\n\t *\n\t * Ordinary portal drop: must release resources.  However, if the portal\n\t * is not FAILED then we do not release its locks.  The locks become the\n\t * responsibility of the transaction's ResourceOwner (since it is the\n\t * parent of the portal's owner) and will be released when the transaction\n\t * eventually ends.\n\t */\n\tif (portal->resowner &&\n\t\t(!isTopCommit || portal->status == PORTAL_FAILED))\n\t{\n\t\tbool\t\tisCommit = (portal->status != PORTAL_FAILED);\n\n\t\tResourceOwnerRelease(portal->resowner,\n\t\t\t\t\t\t\t RESOURCE_RELEASE_BEFORE_LOCKS,\n\t\t\t\t\t\t\t isCommit, false);\n\t\tResourceOwnerRelease(portal->resowner,\n\t\t\t\t\t\t\t RESOURCE_RELEASE_LOCKS,\n\t\t\t\t\t\t\t isCommit, false);\n\t\tResourceOwnerRelease(portal->resowner,\n\t\t\t\t\t\t\t RESOURCE_RELEASE_AFTER_LOCKS,\n\t\t\t\t\t\t\t isCommit, false);\n\t\tResourceOwnerDelete(portal->resowner);\n\t}\n\tportal->resowner = NULL;\n\n\t/*\n\t * Delete tuplestore if present.  We should do this even under error\n\t * conditions; since the tuplestore would have been using cross-\n\t * transaction storage, its temp files need to be explicitly deleted.\n\t */\n\tif (portal->holdStore)\n\t{\n\t\tMemoryContext oldcontext;\n\n\t\toldcontext = MemoryContextSwitchTo(portal->holdContext);\n\t\ttuplestore_end(portal->holdStore);\n\t\tMemoryContextSwitchTo(oldcontext);\n\t\tportal->holdStore = NULL;\n\t}\n\n\t/* delete tuplestore storage, if any */\n\tif (portal->holdContext)\n\t\tMemoryContextDelete(portal->holdContext);\n\n\t/* release subsidiary storage */\n\tMemoryContextDelete(portal->portalContext);\n\n\t/* release portal struct (it's in TopPortalContext) */\n\tpfree(portal);\n}"
  },
  {
    "function_name": "MarkPortalFailed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/portalmem.c",
    "lines": "438-458",
    "snippet": "void\nMarkPortalFailed(Portal portal)\n{\n\t/* Perform the state transition */\n\tAssert(portal->status != PORTAL_DONE);\n\tportal->status = PORTAL_FAILED;\n\n\t/*\n\t * Allow portalcmds.c to clean up the state it knows about.  We might as\n\t * well do that now, since the portal can't be executed any more.\n\t *\n\t * In some cases involving cleanup of an already aborted transaction, this\n\t * is necessary, or we'd reach AtCleanup_Portals with the cleanup hook\n\t * still unexecuted.\n\t */\n\tif (PointerIsValid(portal->cleanup))\n\t{\n\t\tportal->cleanup(portal);\n\t\tportal->cleanup = NULL;\n\t}\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/portalcmds.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "portal->cleanup",
          "args": [
            "portal"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerIsValid",
          "args": [
            "portal->cleanup"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "portal->status != PORTAL_DONE"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/ipc.h\"\n#include \"miscadmin.h\"\n#include \"commands/portalcmds.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nvoid\nMarkPortalFailed(Portal portal)\n{\n\t/* Perform the state transition */\n\tAssert(portal->status != PORTAL_DONE);\n\tportal->status = PORTAL_FAILED;\n\n\t/*\n\t * Allow portalcmds.c to clean up the state it knows about.  We might as\n\t * well do that now, since the portal can't be executed any more.\n\t *\n\t * In some cases involving cleanup of an already aborted transaction, this\n\t * is necessary, or we'd reach AtCleanup_Portals with the cleanup hook\n\t * still unexecuted.\n\t */\n\tif (PointerIsValid(portal->cleanup))\n\t{\n\t\tportal->cleanup(portal);\n\t\tportal->cleanup = NULL;\n\t}\n}"
  },
  {
    "function_name": "MarkPortalDone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/portalmem.c",
    "lines": "410-430",
    "snippet": "void\nMarkPortalDone(Portal portal)\n{\n\t/* Perform the state transition */\n\tAssert(portal->status == PORTAL_ACTIVE);\n\tportal->status = PORTAL_DONE;\n\n\t/*\n\t * Allow portalcmds.c to clean up the state it knows about.  We might as\n\t * well do that now, since the portal can't be executed any more.\n\t *\n\t * In some cases involving execution of a ROLLBACK command in an already\n\t * aborted transaction, this is necessary, or we'd reach AtCleanup_Portals\n\t * with the cleanup hook still unexecuted.\n\t */\n\tif (PointerIsValid(portal->cleanup))\n\t{\n\t\tportal->cleanup(portal);\n\t\tportal->cleanup = NULL;\n\t}\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/portalcmds.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "portal->cleanup",
          "args": [
            "portal"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerIsValid",
          "args": [
            "portal->cleanup"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "portal->status == PORTAL_ACTIVE"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/ipc.h\"\n#include \"miscadmin.h\"\n#include \"commands/portalcmds.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nvoid\nMarkPortalDone(Portal portal)\n{\n\t/* Perform the state transition */\n\tAssert(portal->status == PORTAL_ACTIVE);\n\tportal->status = PORTAL_DONE;\n\n\t/*\n\t * Allow portalcmds.c to clean up the state it knows about.  We might as\n\t * well do that now, since the portal can't be executed any more.\n\t *\n\t * In some cases involving execution of a ROLLBACK command in an already\n\t * aborted transaction, this is necessary, or we'd reach AtCleanup_Portals\n\t * with the cleanup hook still unexecuted.\n\t */\n\tif (PointerIsValid(portal->cleanup))\n\t{\n\t\tportal->cleanup(portal);\n\t\tportal->cleanup = NULL;\n\t}\n}"
  },
  {
    "function_name": "MarkPortalActive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/portalmem.c",
    "lines": "391-402",
    "snippet": "void\nMarkPortalActive(Portal portal)\n{\n\t/* For safety, this is a runtime test not just an Assert */\n\tif (portal->status != PORTAL_READY)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\n\t\t\t\t errmsg(\"portal \\\"%s\\\" cannot be run\", portal->name)));\n\t/* Perform the state transition */\n\tportal->status = PORTAL_ACTIVE;\n\tportal->activeSubid = GetCurrentSubTransactionId();\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/portalcmds.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetCurrentSubTransactionId",
          "args": [],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\n\t\t\t\t errmsg(\"portal \\\"%s\\\" cannot be run\", portal->name))"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"portal \\\"%s\\\" cannot be run\"",
            "portal->name"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/ipc.h\"\n#include \"miscadmin.h\"\n#include \"commands/portalcmds.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nvoid\nMarkPortalActive(Portal portal)\n{\n\t/* For safety, this is a runtime test not just an Assert */\n\tif (portal->status != PORTAL_READY)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),\n\t\t\t\t errmsg(\"portal \\\"%s\\\" cannot be run\", portal->name)));\n\t/* Perform the state transition */\n\tportal->status = PORTAL_ACTIVE;\n\tportal->activeSubid = GetCurrentSubTransactionId();\n}"
  },
  {
    "function_name": "UnpinPortal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/portalmem.c",
    "lines": "376-383",
    "snippet": "void\nUnpinPortal(Portal portal)\n{\n\tif (!portal->portalPinned)\n\t\telog(ERROR, \"portal not pinned\");\n\n\tportal->portalPinned = false;\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/portalcmds.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"portal not pinned\""
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/ipc.h\"\n#include \"miscadmin.h\"\n#include \"commands/portalcmds.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nvoid\nUnpinPortal(Portal portal)\n{\n\tif (!portal->portalPinned)\n\t\telog(ERROR, \"portal not pinned\");\n\n\tportal->portalPinned = false;\n}"
  },
  {
    "function_name": "PinPortal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/portalmem.c",
    "lines": "367-374",
    "snippet": "void\nPinPortal(Portal portal)\n{\n\tif (portal->portalPinned)\n\t\telog(ERROR, \"portal already pinned\");\n\n\tportal->portalPinned = true;\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/portalcmds.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"portal already pinned\""
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/ipc.h\"\n#include \"miscadmin.h\"\n#include \"commands/portalcmds.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nvoid\nPinPortal(Portal portal)\n{\n\tif (portal->portalPinned)\n\t\telog(ERROR, \"portal already pinned\");\n\n\tportal->portalPinned = true;\n}"
  },
  {
    "function_name": "PortalCreateHoldStore",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/portalmem.c",
    "lines": "327-358",
    "snippet": "void\nPortalCreateHoldStore(Portal portal)\n{\n\tMemoryContext oldcxt;\n\n\tAssert(portal->holdContext == NULL);\n\tAssert(portal->holdStore == NULL);\n\tAssert(portal->holdSnapshot == NULL);\n\n\t/*\n\t * Create the memory context that is used for storage of the tuple set.\n\t * Note this is NOT a child of the portal's portalContext.\n\t */\n\tportal->holdContext =\n\t\tAllocSetContextCreate(TopPortalContext,\n\t\t\t\t\t\t\t  \"PortalHoldContext\",\n\t\t\t\t\t\t\t  ALLOCSET_DEFAULT_SIZES);\n\n\t/*\n\t * Create the tuple store, selecting cross-transaction temp files, and\n\t * enabling random access only if cursor requires scrolling.\n\t *\n\t * XXX: Should maintenance_work_mem be used for the portal size?\n\t */\n\toldcxt = MemoryContextSwitchTo(portal->holdContext);\n\n\tportal->holdStore =\n\t\ttuplestore_begin_heap(portal->cursorOptions & CURSOR_OPT_SCROLL,\n\t\t\t\t\t\t\t  true, work_mem);\n\n\tMemoryContextSwitchTo(oldcxt);\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/portalcmds.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static MemoryContext TopPortalContext = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcxt"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tuplestore_begin_heap",
          "args": [
            "portal->cursorOptions & CURSOR_OPT_SCROLL",
            "true",
            "work_mem"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "tuplestore_begin_heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplestore.c",
          "lines": "317-338",
          "snippet": "Tuplestorestate *\ntuplestore_begin_heap(bool randomAccess, bool interXact, int maxKBytes)\n{\n\tTuplestorestate *state;\n\tint\t\t\teflags;\n\n\t/*\n\t * This interpretation of the meaning of randomAccess is compatible with\n\t * the pre-8.3 behavior of tuplestores.\n\t */\n\teflags = randomAccess ?\n\t\t(EXEC_FLAG_BACKWARD | EXEC_FLAG_REWIND) :\n\t\t(EXEC_FLAG_REWIND);\n\n\tstate = tuplestore_begin_common(eflags, interXact, maxKBytes);\n\n\tstate->copytup = copytup_heap;\n\tstate->writetup = writetup_heap;\n\tstate->readtup = readtup_heap;\n\n\treturn state;\n}",
          "includes": [
            "#include \"utils/resowner.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Tuplestorestate *tuplestore_begin_common(int eflags,\n\t\t\t\t\t\tbool interXact,\n\t\t\t\t\t\tint maxKBytes);",
            "static void dumptuples(Tuplestorestate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/resowner.h\"\n#include \"utils/memutils.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Tuplestorestate *tuplestore_begin_common(int eflags,\n\t\t\t\t\t\tbool interXact,\n\t\t\t\t\t\tint maxKBytes);\nstatic void dumptuples(Tuplestorestate *state);\n\nTuplestorestate *\ntuplestore_begin_heap(bool randomAccess, bool interXact, int maxKBytes)\n{\n\tTuplestorestate *state;\n\tint\t\t\teflags;\n\n\t/*\n\t * This interpretation of the meaning of randomAccess is compatible with\n\t * the pre-8.3 behavior of tuplestores.\n\t */\n\teflags = randomAccess ?\n\t\t(EXEC_FLAG_BACKWARD | EXEC_FLAG_REWIND) :\n\t\t(EXEC_FLAG_REWIND);\n\n\tstate = tuplestore_begin_common(eflags, interXact, maxKBytes);\n\n\tstate->copytup = copytup_heap;\n\tstate->writetup = writetup_heap;\n\tstate->readtup = readtup_heap;\n\n\treturn state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "portal->holdContext"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocSetContextCreate",
          "args": [
            "TopPortalContext",
            "\"PortalHoldContext\"",
            "ALLOCSET_DEFAULT_SIZES"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "portal->holdSnapshot == NULL"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "portal->holdStore == NULL"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "portal->holdContext == NULL"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/ipc.h\"\n#include \"miscadmin.h\"\n#include \"commands/portalcmds.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic MemoryContext TopPortalContext = NULL;\n\nvoid\nPortalCreateHoldStore(Portal portal)\n{\n\tMemoryContext oldcxt;\n\n\tAssert(portal->holdContext == NULL);\n\tAssert(portal->holdStore == NULL);\n\tAssert(portal->holdSnapshot == NULL);\n\n\t/*\n\t * Create the memory context that is used for storage of the tuple set.\n\t * Note this is NOT a child of the portal's portalContext.\n\t */\n\tportal->holdContext =\n\t\tAllocSetContextCreate(TopPortalContext,\n\t\t\t\t\t\t\t  \"PortalHoldContext\",\n\t\t\t\t\t\t\t  ALLOCSET_DEFAULT_SIZES);\n\n\t/*\n\t * Create the tuple store, selecting cross-transaction temp files, and\n\t * enabling random access only if cursor requires scrolling.\n\t *\n\t * XXX: Should maintenance_work_mem be used for the portal size?\n\t */\n\toldcxt = MemoryContextSwitchTo(portal->holdContext);\n\n\tportal->holdStore =\n\t\ttuplestore_begin_heap(portal->cursorOptions & CURSOR_OPT_SCROLL,\n\t\t\t\t\t\t\t  true, work_mem);\n\n\tMemoryContextSwitchTo(oldcxt);\n}"
  },
  {
    "function_name": "PortalReleaseCachedPlan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/portalmem.c",
    "lines": "306-321",
    "snippet": "static void\nPortalReleaseCachedPlan(Portal portal)\n{\n\tif (portal->cplan)\n\t{\n\t\tReleaseCachedPlan(portal->cplan, false);\n\t\tportal->cplan = NULL;\n\n\t\t/*\n\t\t * We must also clear portal->stmts which is now a dangling reference\n\t\t * to the cached plan's plan list.  This protects any code that might\n\t\t * try to examine the Portal later.\n\t\t */\n\t\tportal->stmts = NIL;\n\t}\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/portalcmds.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ReleaseCachedPlan",
          "args": [
            "portal->cplan",
            "false"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "ReleaseCachedPlan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/plancache.c",
          "lines": "1257-1277",
          "snippet": "void\nReleaseCachedPlan(CachedPlan *plan, bool useResOwner)\n{\n\tAssert(plan->magic == CACHEDPLAN_MAGIC);\n\tif (useResOwner)\n\t{\n\t\tAssert(plan->is_saved);\n\t\tResourceOwnerForgetPlanCacheRef(CurrentResourceOwner, plan);\n\t}\n\tAssert(plan->refcount > 0);\n\tplan->refcount--;\n\tif (plan->refcount == 0)\n\t{\n\t\t/* Mark it no longer valid */\n\t\tplan->magic = 0;\n\n\t\t/* One-shot plans do not own their context, so we can't free them */\n\t\tif (!plan->is_oneshot)\n\t\t\tMemoryContextDelete(plan->context);\n\t}\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"tcop/utility.h\"",
            "#include \"tcop/pquery.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/analyze.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/planmain.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/transam.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"tcop/utility.h\"\n#include \"tcop/pquery.h\"\n#include \"storage/lmgr.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/analyze.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/cost.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/namespace.h\"\n#include \"access/transam.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nvoid\nReleaseCachedPlan(CachedPlan *plan, bool useResOwner)\n{\n\tAssert(plan->magic == CACHEDPLAN_MAGIC);\n\tif (useResOwner)\n\t{\n\t\tAssert(plan->is_saved);\n\t\tResourceOwnerForgetPlanCacheRef(CurrentResourceOwner, plan);\n\t}\n\tAssert(plan->refcount > 0);\n\tplan->refcount--;\n\tif (plan->refcount == 0)\n\t{\n\t\t/* Mark it no longer valid */\n\t\tplan->magic = 0;\n\n\t\t/* One-shot plans do not own their context, so we can't free them */\n\t\tif (!plan->is_oneshot)\n\t\t\tMemoryContextDelete(plan->context);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/ipc.h\"\n#include \"miscadmin.h\"\n#include \"commands/portalcmds.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic void\nPortalReleaseCachedPlan(Portal portal)\n{\n\tif (portal->cplan)\n\t{\n\t\tReleaseCachedPlan(portal->cplan, false);\n\t\tportal->cplan = NULL;\n\n\t\t/*\n\t\t * We must also clear portal->stmts which is now a dangling reference\n\t\t * to the cached plan's plan list.  This protects any code that might\n\t\t * try to examine the Portal later.\n\t\t */\n\t\tportal->stmts = NIL;\n\t}\n}"
  },
  {
    "function_name": "PortalDefineQuery",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/portalmem.c",
    "lines": "280-300",
    "snippet": "void\nPortalDefineQuery(Portal portal,\n\t\t\t\t  const char *prepStmtName,\n\t\t\t\t  const char *sourceText,\n\t\t\t\t  const char *commandTag,\n\t\t\t\t  List *stmts,\n\t\t\t\t  CachedPlan *cplan)\n{\n\tAssertArg(PortalIsValid(portal));\n\tAssertState(portal->status == PORTAL_NEW);\n\n\tAssertArg(sourceText != NULL);\n\tAssertArg(commandTag != NULL || stmts == NIL);\n\n\tportal->prepStmtName = prepStmtName;\n\tportal->sourceText = sourceText;\n\tportal->commandTag = commandTag;\n\tportal->stmts = stmts;\n\tportal->cplan = cplan;\n\tportal->status = PORTAL_DEFINED;\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/portalcmds.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "AssertArg",
          "args": [
            "commandTag != NULL || stmts == NIL"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AssertArg",
          "args": [
            "sourceText != NULL"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AssertState",
          "args": [
            "portal->status == PORTAL_NEW"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AssertArg",
          "args": [
            "PortalIsValid(portal)"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PortalIsValid",
          "args": [
            "portal"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/ipc.h\"\n#include \"miscadmin.h\"\n#include \"commands/portalcmds.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nvoid\nPortalDefineQuery(Portal portal,\n\t\t\t\t  const char *prepStmtName,\n\t\t\t\t  const char *sourceText,\n\t\t\t\t  const char *commandTag,\n\t\t\t\t  List *stmts,\n\t\t\t\t  CachedPlan *cplan)\n{\n\tAssertArg(PortalIsValid(portal));\n\tAssertState(portal->status == PORTAL_NEW);\n\n\tAssertArg(sourceText != NULL);\n\tAssertArg(commandTag != NULL || stmts == NIL);\n\n\tportal->prepStmtName = prepStmtName;\n\tportal->sourceText = sourceText;\n\tportal->commandTag = commandTag;\n\tportal->stmts = stmts;\n\tportal->cplan = cplan;\n\tportal->status = PORTAL_DEFINED;\n}"
  },
  {
    "function_name": "CreateNewPortal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/portalmem.c",
    "lines": "233-250",
    "snippet": "Portal\nCreateNewPortal(void)\n{\n\tstatic unsigned int unnamed_portal_count = 0;\n\n\tchar\t\tportalname[MAX_PORTALNAME_LEN];\n\n\t/* Select a nonconflicting name */\n\tfor (;;)\n\t{\n\t\tunnamed_portal_count++;\n\t\tsprintf(portalname, \"<unnamed portal %u>\", unnamed_portal_count);\n\t\tif (GetPortalByName(portalname) == NULL)\n\t\t\tbreak;\n\t}\n\n\treturn CreatePortal(portalname, false, false);\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/portalcmds.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define MAX_PORTALNAME_LEN\t\tNAMEDATALEN"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CreatePortal",
          "args": [
            "portalname",
            "false",
            "false"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "CreatePortal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/portalmem.c",
          "lines": "174-227",
          "snippet": "Portal\nCreatePortal(const char *name, bool allowDup, bool dupSilent)\n{\n\tPortal\t\tportal;\n\n\tAssertArg(PointerIsValid(name));\n\n\tportal = GetPortalByName(name);\n\tif (PortalIsValid(portal))\n\t{\n\t\tif (!allowDup)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DUPLICATE_CURSOR),\n\t\t\t\t\t errmsg(\"cursor \\\"%s\\\" already exists\", name)));\n\t\tif (!dupSilent)\n\t\t\tereport(WARNING,\n\t\t\t\t\t(errcode(ERRCODE_DUPLICATE_CURSOR),\n\t\t\t\t\t errmsg(\"closing existing cursor \\\"%s\\\"\",\n\t\t\t\t\t\t\tname)));\n\t\tPortalDrop(portal, false);\n\t}\n\n\t/* make new portal structure */\n\tportal = (Portal) MemoryContextAllocZero(TopPortalContext, sizeof *portal);\n\n\t/* initialize portal context; typically it won't store much */\n\tportal->portalContext = AllocSetContextCreate(TopPortalContext,\n\t\t\t\t\t\t\t\t\t\t\t\t  \"PortalContext\",\n\t\t\t\t\t\t\t\t\t\t\t\t  ALLOCSET_SMALL_SIZES);\n\n\t/* create a resource owner for the portal */\n\tportal->resowner = ResourceOwnerCreate(CurTransactionResourceOwner,\n\t\t\t\t\t\t\t\t\t\t   \"Portal\");\n\n\t/* initialize portal fields that don't start off zero */\n\tportal->status = PORTAL_NEW;\n\tportal->cleanup = PortalCleanup;\n\tportal->createSubid = GetCurrentSubTransactionId();\n\tportal->activeSubid = portal->createSubid;\n\tportal->strategy = PORTAL_MULTI_QUERY;\n\tportal->cursorOptions = CURSOR_OPT_NO_SCROLL;\n\tportal->atStart = true;\n\tportal->atEnd = true;\t\t/* disallow fetches until query is set */\n\tportal->visible = true;\n\tportal->creation_time = GetCurrentStatementStartTimestamp();\n\n\t/* put portal in table (sets portal->name) */\n\tPortalHashTableInsert(portal, name);\n\n\t/* reuse portal->name copy */\n\tMemoryContextSetIdentifier(portal->portalContext, portal->name);\n\n\treturn portal;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/portalcmds.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static MemoryContext TopPortalContext = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/ipc.h\"\n#include \"miscadmin.h\"\n#include \"commands/portalcmds.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic MemoryContext TopPortalContext = NULL;\n\nPortal\nCreatePortal(const char *name, bool allowDup, bool dupSilent)\n{\n\tPortal\t\tportal;\n\n\tAssertArg(PointerIsValid(name));\n\n\tportal = GetPortalByName(name);\n\tif (PortalIsValid(portal))\n\t{\n\t\tif (!allowDup)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DUPLICATE_CURSOR),\n\t\t\t\t\t errmsg(\"cursor \\\"%s\\\" already exists\", name)));\n\t\tif (!dupSilent)\n\t\t\tereport(WARNING,\n\t\t\t\t\t(errcode(ERRCODE_DUPLICATE_CURSOR),\n\t\t\t\t\t errmsg(\"closing existing cursor \\\"%s\\\"\",\n\t\t\t\t\t\t\tname)));\n\t\tPortalDrop(portal, false);\n\t}\n\n\t/* make new portal structure */\n\tportal = (Portal) MemoryContextAllocZero(TopPortalContext, sizeof *portal);\n\n\t/* initialize portal context; typically it won't store much */\n\tportal->portalContext = AllocSetContextCreate(TopPortalContext,\n\t\t\t\t\t\t\t\t\t\t\t\t  \"PortalContext\",\n\t\t\t\t\t\t\t\t\t\t\t\t  ALLOCSET_SMALL_SIZES);\n\n\t/* create a resource owner for the portal */\n\tportal->resowner = ResourceOwnerCreate(CurTransactionResourceOwner,\n\t\t\t\t\t\t\t\t\t\t   \"Portal\");\n\n\t/* initialize portal fields that don't start off zero */\n\tportal->status = PORTAL_NEW;\n\tportal->cleanup = PortalCleanup;\n\tportal->createSubid = GetCurrentSubTransactionId();\n\tportal->activeSubid = portal->createSubid;\n\tportal->strategy = PORTAL_MULTI_QUERY;\n\tportal->cursorOptions = CURSOR_OPT_NO_SCROLL;\n\tportal->atStart = true;\n\tportal->atEnd = true;\t\t/* disallow fetches until query is set */\n\tportal->visible = true;\n\tportal->creation_time = GetCurrentStatementStartTimestamp();\n\n\t/* put portal in table (sets portal->name) */\n\tPortalHashTableInsert(portal, name);\n\n\t/* reuse portal->name copy */\n\tMemoryContextSetIdentifier(portal->portalContext, portal->name);\n\n\treturn portal;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetPortalByName",
          "args": [
            "portalname"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "GetPortalByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/portalmem.c",
          "lines": "129-140",
          "snippet": "Portal\nGetPortalByName(const char *name)\n{\n\tPortal\t\tportal;\n\n\tif (PointerIsValid(name))\n\t\tPortalHashTableLookup(name, portal);\n\telse\n\t\tportal = NULL;\n\n\treturn portal;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/portalcmds.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/ipc.h\"\n#include \"miscadmin.h\"\n#include \"commands/portalcmds.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nPortal\nGetPortalByName(const char *name)\n{\n\tPortal\t\tportal;\n\n\tif (PointerIsValid(name))\n\t\tPortalHashTableLookup(name, portal);\n\telse\n\t\tportal = NULL;\n\n\treturn portal;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "portalname",
            "\"<unnamed portal %u>\"",
            "unnamed_portal_count"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/ipc.h\"\n#include \"miscadmin.h\"\n#include \"commands/portalcmds.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\n#define MAX_PORTALNAME_LEN\t\tNAMEDATALEN\n\nPortal\nCreateNewPortal(void)\n{\n\tstatic unsigned int unnamed_portal_count = 0;\n\n\tchar\t\tportalname[MAX_PORTALNAME_LEN];\n\n\t/* Select a nonconflicting name */\n\tfor (;;)\n\t{\n\t\tunnamed_portal_count++;\n\t\tsprintf(portalname, \"<unnamed portal %u>\", unnamed_portal_count);\n\t\tif (GetPortalByName(portalname) == NULL)\n\t\t\tbreak;\n\t}\n\n\treturn CreatePortal(portalname, false, false);\n}"
  },
  {
    "function_name": "CreatePortal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/portalmem.c",
    "lines": "174-227",
    "snippet": "Portal\nCreatePortal(const char *name, bool allowDup, bool dupSilent)\n{\n\tPortal\t\tportal;\n\n\tAssertArg(PointerIsValid(name));\n\n\tportal = GetPortalByName(name);\n\tif (PortalIsValid(portal))\n\t{\n\t\tif (!allowDup)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DUPLICATE_CURSOR),\n\t\t\t\t\t errmsg(\"cursor \\\"%s\\\" already exists\", name)));\n\t\tif (!dupSilent)\n\t\t\tereport(WARNING,\n\t\t\t\t\t(errcode(ERRCODE_DUPLICATE_CURSOR),\n\t\t\t\t\t errmsg(\"closing existing cursor \\\"%s\\\"\",\n\t\t\t\t\t\t\tname)));\n\t\tPortalDrop(portal, false);\n\t}\n\n\t/* make new portal structure */\n\tportal = (Portal) MemoryContextAllocZero(TopPortalContext, sizeof *portal);\n\n\t/* initialize portal context; typically it won't store much */\n\tportal->portalContext = AllocSetContextCreate(TopPortalContext,\n\t\t\t\t\t\t\t\t\t\t\t\t  \"PortalContext\",\n\t\t\t\t\t\t\t\t\t\t\t\t  ALLOCSET_SMALL_SIZES);\n\n\t/* create a resource owner for the portal */\n\tportal->resowner = ResourceOwnerCreate(CurTransactionResourceOwner,\n\t\t\t\t\t\t\t\t\t\t   \"Portal\");\n\n\t/* initialize portal fields that don't start off zero */\n\tportal->status = PORTAL_NEW;\n\tportal->cleanup = PortalCleanup;\n\tportal->createSubid = GetCurrentSubTransactionId();\n\tportal->activeSubid = portal->createSubid;\n\tportal->strategy = PORTAL_MULTI_QUERY;\n\tportal->cursorOptions = CURSOR_OPT_NO_SCROLL;\n\tportal->atStart = true;\n\tportal->atEnd = true;\t\t/* disallow fetches until query is set */\n\tportal->visible = true;\n\tportal->creation_time = GetCurrentStatementStartTimestamp();\n\n\t/* put portal in table (sets portal->name) */\n\tPortalHashTableInsert(portal, name);\n\n\t/* reuse portal->name copy */\n\tMemoryContextSetIdentifier(portal->portalContext, portal->name);\n\n\treturn portal;\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/portalcmds.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static MemoryContext TopPortalContext = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextSetIdentifier",
          "args": [
            "portal->portalContext",
            "portal->name"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextSetIdentifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "328-333",
          "snippet": "void\nMemoryContextSetIdentifier(MemoryContext context, const char *id)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\tcontext->ident = id;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\nMemoryContextSetIdentifier(MemoryContext context, const char *id)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\tcontext->ident = id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PortalHashTableInsert",
          "args": [
            "portal",
            "name"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetCurrentStatementStartTimestamp",
          "args": [],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetCurrentSubTransactionId",
          "args": [],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ResourceOwnerCreate",
          "args": [
            "CurTransactionResourceOwner",
            "\"Portal\""
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "ResourceOwnerCreate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "417-445",
          "snippet": "ResourceOwner\nResourceOwnerCreate(ResourceOwner parent, const char *name)\n{\n\tResourceOwner owner;\n\n\towner = (ResourceOwner) MemoryContextAllocZero(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t   sizeof(ResourceOwnerData));\n\towner->name = name;\n\n\tif (parent)\n\t{\n\t\towner->parent = parent;\n\t\towner->nextchild = parent->firstchild;\n\t\tparent->firstchild = owner;\n\t}\n\n\tResourceArrayInit(&(owner->bufferarr), BufferGetDatum(InvalidBuffer));\n\tResourceArrayInit(&(owner->catrefarr), PointerGetDatum(NULL));\n\tResourceArrayInit(&(owner->catlistrefarr), PointerGetDatum(NULL));\n\tResourceArrayInit(&(owner->relrefarr), PointerGetDatum(NULL));\n\tResourceArrayInit(&(owner->planrefarr), PointerGetDatum(NULL));\n\tResourceArrayInit(&(owner->tupdescarr), PointerGetDatum(NULL));\n\tResourceArrayInit(&(owner->snapshotarr), PointerGetDatum(NULL));\n\tResourceArrayInit(&(owner->filearr), FileGetDatum(-1));\n\tResourceArrayInit(&(owner->dsmarr), PointerGetDatum(NULL));\n\tResourceArrayInit(&(owner->jitarr), PointerGetDatum(NULL));\n\n\treturn owner;\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"jit/jit.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nResourceOwner\nResourceOwnerCreate(ResourceOwner parent, const char *name)\n{\n\tResourceOwner owner;\n\n\towner = (ResourceOwner) MemoryContextAllocZero(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t   sizeof(ResourceOwnerData));\n\towner->name = name;\n\n\tif (parent)\n\t{\n\t\towner->parent = parent;\n\t\towner->nextchild = parent->firstchild;\n\t\tparent->firstchild = owner;\n\t}\n\n\tResourceArrayInit(&(owner->bufferarr), BufferGetDatum(InvalidBuffer));\n\tResourceArrayInit(&(owner->catrefarr), PointerGetDatum(NULL));\n\tResourceArrayInit(&(owner->catlistrefarr), PointerGetDatum(NULL));\n\tResourceArrayInit(&(owner->relrefarr), PointerGetDatum(NULL));\n\tResourceArrayInit(&(owner->planrefarr), PointerGetDatum(NULL));\n\tResourceArrayInit(&(owner->tupdescarr), PointerGetDatum(NULL));\n\tResourceArrayInit(&(owner->snapshotarr), PointerGetDatum(NULL));\n\tResourceArrayInit(&(owner->filearr), FileGetDatum(-1));\n\tResourceArrayInit(&(owner->dsmarr), PointerGetDatum(NULL));\n\tResourceArrayInit(&(owner->jitarr), PointerGetDatum(NULL));\n\n\treturn owner;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AllocSetContextCreate",
          "args": [
            "TopPortalContext",
            "\"PortalContext\"",
            "ALLOCSET_SMALL_SIZES"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextAllocZero",
          "args": [
            "TopPortalContext",
            "sizeof *portal"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocZeroAligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "851-880",
          "snippet": "void *\nMemoryContextAllocZeroAligned(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetLoop(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocZeroAligned(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetLoop(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PortalDrop",
          "args": [
            "portal",
            "false"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "PortalDrop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/portalmem.c",
          "lines": "464-593",
          "snippet": "void\nPortalDrop(Portal portal, bool isTopCommit)\n{\n\tAssertArg(PortalIsValid(portal));\n\n\t/*\n\t * Don't allow dropping a pinned portal, it's still needed by whoever\n\t * pinned it.\n\t */\n\tif (portal->portalPinned)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_CURSOR_STATE),\n\t\t\t\t errmsg(\"cannot drop pinned portal \\\"%s\\\"\", portal->name)));\n\n\t/*\n\t * Not sure if the PORTAL_ACTIVE case can validly happen or not...\n\t */\n\tif (portal->status == PORTAL_ACTIVE)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_CURSOR_STATE),\n\t\t\t\t errmsg(\"cannot drop active portal \\\"%s\\\"\", portal->name)));\n\n\t/*\n\t * Allow portalcmds.c to clean up the state it knows about, in particular\n\t * shutting down the executor if still active.  This step potentially runs\n\t * user-defined code so failure has to be expected.  It's the cleanup\n\t * hook's responsibility to not try to do that more than once, in the case\n\t * that failure occurs and then we come back to drop the portal again\n\t * during transaction abort.\n\t *\n\t * Note: in most paths of control, this will have been done already in\n\t * MarkPortalDone or MarkPortalFailed.  We're just making sure.\n\t */\n\tif (PointerIsValid(portal->cleanup))\n\t{\n\t\tportal->cleanup(portal);\n\t\tportal->cleanup = NULL;\n\t}\n\n\t/*\n\t * Remove portal from hash table.  Because we do this here, we will not\n\t * come back to try to remove the portal again if there's any error in the\n\t * subsequent steps.  Better to leak a little memory than to get into an\n\t * infinite error-recovery loop.\n\t */\n\tPortalHashTableDelete(portal);\n\n\t/* drop cached plan reference, if any */\n\tPortalReleaseCachedPlan(portal);\n\n\t/*\n\t * If portal has a snapshot protecting its data, release that.  This needs\n\t * a little care since the registration will be attached to the portal's\n\t * resowner; if the portal failed, we will already have released the\n\t * resowner (and the snapshot) during transaction abort.\n\t */\n\tif (portal->holdSnapshot)\n\t{\n\t\tif (portal->resowner)\n\t\t\tUnregisterSnapshotFromOwner(portal->holdSnapshot,\n\t\t\t\t\t\t\t\t\t\tportal->resowner);\n\t\tportal->holdSnapshot = NULL;\n\t}\n\n\t/*\n\t * Release any resources still attached to the portal.  There are several\n\t * cases being covered here:\n\t *\n\t * Top transaction commit (indicated by isTopCommit): normally we should\n\t * do nothing here and let the regular end-of-transaction resource\n\t * releasing mechanism handle these resources too.  However, if we have a\n\t * FAILED portal (eg, a cursor that got an error), we'd better clean up\n\t * its resources to avoid resource-leakage warning messages.\n\t *\n\t * Sub transaction commit: never comes here at all, since we don't kill\n\t * any portals in AtSubCommit_Portals().\n\t *\n\t * Main or sub transaction abort: we will do nothing here because\n\t * portal->resowner was already set NULL; the resources were already\n\t * cleaned up in transaction abort.\n\t *\n\t * Ordinary portal drop: must release resources.  However, if the portal\n\t * is not FAILED then we do not release its locks.  The locks become the\n\t * responsibility of the transaction's ResourceOwner (since it is the\n\t * parent of the portal's owner) and will be released when the transaction\n\t * eventually ends.\n\t */\n\tif (portal->resowner &&\n\t\t(!isTopCommit || portal->status == PORTAL_FAILED))\n\t{\n\t\tbool\t\tisCommit = (portal->status != PORTAL_FAILED);\n\n\t\tResourceOwnerRelease(portal->resowner,\n\t\t\t\t\t\t\t RESOURCE_RELEASE_BEFORE_LOCKS,\n\t\t\t\t\t\t\t isCommit, false);\n\t\tResourceOwnerRelease(portal->resowner,\n\t\t\t\t\t\t\t RESOURCE_RELEASE_LOCKS,\n\t\t\t\t\t\t\t isCommit, false);\n\t\tResourceOwnerRelease(portal->resowner,\n\t\t\t\t\t\t\t RESOURCE_RELEASE_AFTER_LOCKS,\n\t\t\t\t\t\t\t isCommit, false);\n\t\tResourceOwnerDelete(portal->resowner);\n\t}\n\tportal->resowner = NULL;\n\n\t/*\n\t * Delete tuplestore if present.  We should do this even under error\n\t * conditions; since the tuplestore would have been using cross-\n\t * transaction storage, its temp files need to be explicitly deleted.\n\t */\n\tif (portal->holdStore)\n\t{\n\t\tMemoryContext oldcontext;\n\n\t\toldcontext = MemoryContextSwitchTo(portal->holdContext);\n\t\ttuplestore_end(portal->holdStore);\n\t\tMemoryContextSwitchTo(oldcontext);\n\t\tportal->holdStore = NULL;\n\t}\n\n\t/* delete tuplestore storage, if any */\n\tif (portal->holdContext)\n\t\tMemoryContextDelete(portal->holdContext);\n\n\t/* release subsidiary storage */\n\tMemoryContextDelete(portal->portalContext);\n\n\t/* release portal struct (it's in TopPortalContext) */\n\tpfree(portal);\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/portalcmds.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static MemoryContext TopPortalContext = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/ipc.h\"\n#include \"miscadmin.h\"\n#include \"commands/portalcmds.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic MemoryContext TopPortalContext = NULL;\n\nvoid\nPortalDrop(Portal portal, bool isTopCommit)\n{\n\tAssertArg(PortalIsValid(portal));\n\n\t/*\n\t * Don't allow dropping a pinned portal, it's still needed by whoever\n\t * pinned it.\n\t */\n\tif (portal->portalPinned)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_CURSOR_STATE),\n\t\t\t\t errmsg(\"cannot drop pinned portal \\\"%s\\\"\", portal->name)));\n\n\t/*\n\t * Not sure if the PORTAL_ACTIVE case can validly happen or not...\n\t */\n\tif (portal->status == PORTAL_ACTIVE)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_CURSOR_STATE),\n\t\t\t\t errmsg(\"cannot drop active portal \\\"%s\\\"\", portal->name)));\n\n\t/*\n\t * Allow portalcmds.c to clean up the state it knows about, in particular\n\t * shutting down the executor if still active.  This step potentially runs\n\t * user-defined code so failure has to be expected.  It's the cleanup\n\t * hook's responsibility to not try to do that more than once, in the case\n\t * that failure occurs and then we come back to drop the portal again\n\t * during transaction abort.\n\t *\n\t * Note: in most paths of control, this will have been done already in\n\t * MarkPortalDone or MarkPortalFailed.  We're just making sure.\n\t */\n\tif (PointerIsValid(portal->cleanup))\n\t{\n\t\tportal->cleanup(portal);\n\t\tportal->cleanup = NULL;\n\t}\n\n\t/*\n\t * Remove portal from hash table.  Because we do this here, we will not\n\t * come back to try to remove the portal again if there's any error in the\n\t * subsequent steps.  Better to leak a little memory than to get into an\n\t * infinite error-recovery loop.\n\t */\n\tPortalHashTableDelete(portal);\n\n\t/* drop cached plan reference, if any */\n\tPortalReleaseCachedPlan(portal);\n\n\t/*\n\t * If portal has a snapshot protecting its data, release that.  This needs\n\t * a little care since the registration will be attached to the portal's\n\t * resowner; if the portal failed, we will already have released the\n\t * resowner (and the snapshot) during transaction abort.\n\t */\n\tif (portal->holdSnapshot)\n\t{\n\t\tif (portal->resowner)\n\t\t\tUnregisterSnapshotFromOwner(portal->holdSnapshot,\n\t\t\t\t\t\t\t\t\t\tportal->resowner);\n\t\tportal->holdSnapshot = NULL;\n\t}\n\n\t/*\n\t * Release any resources still attached to the portal.  There are several\n\t * cases being covered here:\n\t *\n\t * Top transaction commit (indicated by isTopCommit): normally we should\n\t * do nothing here and let the regular end-of-transaction resource\n\t * releasing mechanism handle these resources too.  However, if we have a\n\t * FAILED portal (eg, a cursor that got an error), we'd better clean up\n\t * its resources to avoid resource-leakage warning messages.\n\t *\n\t * Sub transaction commit: never comes here at all, since we don't kill\n\t * any portals in AtSubCommit_Portals().\n\t *\n\t * Main or sub transaction abort: we will do nothing here because\n\t * portal->resowner was already set NULL; the resources were already\n\t * cleaned up in transaction abort.\n\t *\n\t * Ordinary portal drop: must release resources.  However, if the portal\n\t * is not FAILED then we do not release its locks.  The locks become the\n\t * responsibility of the transaction's ResourceOwner (since it is the\n\t * parent of the portal's owner) and will be released when the transaction\n\t * eventually ends.\n\t */\n\tif (portal->resowner &&\n\t\t(!isTopCommit || portal->status == PORTAL_FAILED))\n\t{\n\t\tbool\t\tisCommit = (portal->status != PORTAL_FAILED);\n\n\t\tResourceOwnerRelease(portal->resowner,\n\t\t\t\t\t\t\t RESOURCE_RELEASE_BEFORE_LOCKS,\n\t\t\t\t\t\t\t isCommit, false);\n\t\tResourceOwnerRelease(portal->resowner,\n\t\t\t\t\t\t\t RESOURCE_RELEASE_LOCKS,\n\t\t\t\t\t\t\t isCommit, false);\n\t\tResourceOwnerRelease(portal->resowner,\n\t\t\t\t\t\t\t RESOURCE_RELEASE_AFTER_LOCKS,\n\t\t\t\t\t\t\t isCommit, false);\n\t\tResourceOwnerDelete(portal->resowner);\n\t}\n\tportal->resowner = NULL;\n\n\t/*\n\t * Delete tuplestore if present.  We should do this even under error\n\t * conditions; since the tuplestore would have been using cross-\n\t * transaction storage, its temp files need to be explicitly deleted.\n\t */\n\tif (portal->holdStore)\n\t{\n\t\tMemoryContext oldcontext;\n\n\t\toldcontext = MemoryContextSwitchTo(portal->holdContext);\n\t\ttuplestore_end(portal->holdStore);\n\t\tMemoryContextSwitchTo(oldcontext);\n\t\tportal->holdStore = NULL;\n\t}\n\n\t/* delete tuplestore storage, if any */\n\tif (portal->holdContext)\n\t\tMemoryContextDelete(portal->holdContext);\n\n\t/* release subsidiary storage */\n\tMemoryContextDelete(portal->portalContext);\n\n\t/* release portal struct (it's in TopPortalContext) */\n\tpfree(portal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "WARNING",
            "(errcode(ERRCODE_DUPLICATE_CURSOR),\n\t\t\t\t\t errmsg(\"closing existing cursor \\\"%s\\\"\",\n\t\t\t\t\t\t\tname))"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"closing existing cursor \\\"%s\\\"\"",
            "name"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DUPLICATE_CURSOR"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DUPLICATE_CURSOR),\n\t\t\t\t\t errmsg(\"cursor \\\"%s\\\" already exists\", name))"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PortalIsValid",
          "args": [
            "portal"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetPortalByName",
          "args": [
            "name"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "GetPortalByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/portalmem.c",
          "lines": "129-140",
          "snippet": "Portal\nGetPortalByName(const char *name)\n{\n\tPortal\t\tportal;\n\n\tif (PointerIsValid(name))\n\t\tPortalHashTableLookup(name, portal);\n\telse\n\t\tportal = NULL;\n\n\treturn portal;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/portalcmds.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/ipc.h\"\n#include \"miscadmin.h\"\n#include \"commands/portalcmds.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nPortal\nGetPortalByName(const char *name)\n{\n\tPortal\t\tportal;\n\n\tif (PointerIsValid(name))\n\t\tPortalHashTableLookup(name, portal);\n\telse\n\t\tportal = NULL;\n\n\treturn portal;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AssertArg",
          "args": [
            "PointerIsValid(name)"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerIsValid",
          "args": [
            "name"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/ipc.h\"\n#include \"miscadmin.h\"\n#include \"commands/portalcmds.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic MemoryContext TopPortalContext = NULL;\n\nPortal\nCreatePortal(const char *name, bool allowDup, bool dupSilent)\n{\n\tPortal\t\tportal;\n\n\tAssertArg(PointerIsValid(name));\n\n\tportal = GetPortalByName(name);\n\tif (PortalIsValid(portal))\n\t{\n\t\tif (!allowDup)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DUPLICATE_CURSOR),\n\t\t\t\t\t errmsg(\"cursor \\\"%s\\\" already exists\", name)));\n\t\tif (!dupSilent)\n\t\t\tereport(WARNING,\n\t\t\t\t\t(errcode(ERRCODE_DUPLICATE_CURSOR),\n\t\t\t\t\t errmsg(\"closing existing cursor \\\"%s\\\"\",\n\t\t\t\t\t\t\tname)));\n\t\tPortalDrop(portal, false);\n\t}\n\n\t/* make new portal structure */\n\tportal = (Portal) MemoryContextAllocZero(TopPortalContext, sizeof *portal);\n\n\t/* initialize portal context; typically it won't store much */\n\tportal->portalContext = AllocSetContextCreate(TopPortalContext,\n\t\t\t\t\t\t\t\t\t\t\t\t  \"PortalContext\",\n\t\t\t\t\t\t\t\t\t\t\t\t  ALLOCSET_SMALL_SIZES);\n\n\t/* create a resource owner for the portal */\n\tportal->resowner = ResourceOwnerCreate(CurTransactionResourceOwner,\n\t\t\t\t\t\t\t\t\t\t   \"Portal\");\n\n\t/* initialize portal fields that don't start off zero */\n\tportal->status = PORTAL_NEW;\n\tportal->cleanup = PortalCleanup;\n\tportal->createSubid = GetCurrentSubTransactionId();\n\tportal->activeSubid = portal->createSubid;\n\tportal->strategy = PORTAL_MULTI_QUERY;\n\tportal->cursorOptions = CURSOR_OPT_NO_SCROLL;\n\tportal->atStart = true;\n\tportal->atEnd = true;\t\t/* disallow fetches until query is set */\n\tportal->visible = true;\n\tportal->creation_time = GetCurrentStatementStartTimestamp();\n\n\t/* put portal in table (sets portal->name) */\n\tPortalHashTableInsert(portal, name);\n\n\t/* reuse portal->name copy */\n\tMemoryContextSetIdentifier(portal->portalContext, portal->name);\n\n\treturn portal;\n}"
  },
  {
    "function_name": "PortalGetPrimaryStmt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/portalmem.c",
    "lines": "150-163",
    "snippet": "PlannedStmt *\nPortalGetPrimaryStmt(Portal portal)\n{\n\tListCell   *lc;\n\n\tforeach(lc, portal->stmts)\n\t{\n\t\tPlannedStmt *stmt = lfirst_node(PlannedStmt, lc);\n\n\t\tif (stmt->canSetTag)\n\t\t\treturn stmt;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/portalcmds.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lfirst_node",
          "args": [
            "PlannedStmt",
            "lc"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "lc",
            "portal->stmts"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/ipc.h\"\n#include \"miscadmin.h\"\n#include \"commands/portalcmds.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nPlannedStmt *\nPortalGetPrimaryStmt(Portal portal)\n{\n\tListCell   *lc;\n\n\tforeach(lc, portal->stmts)\n\t{\n\t\tPlannedStmt *stmt = lfirst_node(PlannedStmt, lc);\n\n\t\tif (stmt->canSetTag)\n\t\t\treturn stmt;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "GetPortalByName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/portalmem.c",
    "lines": "129-140",
    "snippet": "Portal\nGetPortalByName(const char *name)\n{\n\tPortal\t\tportal;\n\n\tif (PointerIsValid(name))\n\t\tPortalHashTableLookup(name, portal);\n\telse\n\t\tportal = NULL;\n\n\treturn portal;\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/portalcmds.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PortalHashTableLookup",
          "args": [
            "name",
            "portal"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerIsValid",
          "args": [
            "name"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/ipc.h\"\n#include \"miscadmin.h\"\n#include \"commands/portalcmds.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nPortal\nGetPortalByName(const char *name)\n{\n\tPortal\t\tportal;\n\n\tif (PointerIsValid(name))\n\t\tPortalHashTableLookup(name, portal);\n\telse\n\t\tportal = NULL;\n\n\treturn portal;\n}"
  },
  {
    "function_name": "EnablePortalManager",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/portalmem.c",
    "lines": "103-123",
    "snippet": "void\nEnablePortalManager(void)\n{\n\tHASHCTL\t\tctl;\n\n\tAssert(TopPortalContext == NULL);\n\n\tTopPortalContext = AllocSetContextCreate(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t \"TopPortalContext\",\n\t\t\t\t\t\t\t\t\t\t\t ALLOCSET_DEFAULT_SIZES);\n\n\tctl.keysize = MAX_PORTALNAME_LEN;\n\tctl.entrysize = sizeof(PortalHashEnt);\n\n\t/*\n\t * use PORTALS_PER_USER as a guess of how many hash table entries to\n\t * create, initially\n\t */\n\tPortalHashTable = hash_create(\"Portal hash\", PORTALS_PER_USER,\n\t\t\t\t\t\t\t\t  &ctl, HASH_ELEM);\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/portalcmds.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define MAX_PORTALNAME_LEN\t\tNAMEDATALEN",
      "#define PORTALS_PER_USER\t   16"
    ],
    "globals_used": [
      "static HTAB *PortalHashTable = NULL;",
      "static MemoryContext TopPortalContext = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash_create",
          "args": [
            "\"Portal hash\"",
            "PORTALS_PER_USER",
            "&ctl",
            "HASH_ELEM"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "hash_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "315-564",
          "snippet": "HTAB *\nhash_create(const char *tabname, long nelem, HASHCTL *info, int flags)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\n\t/*\n\t * For shared hash tables, we have a local hash header (HTAB struct) that\n\t * we allocate in TopMemoryContext; all else is in shared memory.\n\t *\n\t * For non-shared hash tables, everything including the hash header is in\n\t * a memory context created specially for the hash table --- this makes\n\t * hash_destroy very simple.  The memory context is made a child of either\n\t * a context specified by the caller, or TopMemoryContext if nothing is\n\t * specified.\n\t */\n\tif (flags & HASH_SHARED_MEM)\n\t{\n\t\t/* Set up to allocate the hash header */\n\t\tCurrentDynaHashCxt = TopMemoryContext;\n\t}\n\telse\n\t{\n\t\t/* Create the hash table's private memory context */\n\t\tif (flags & HASH_CONTEXT)\n\t\t\tCurrentDynaHashCxt = info->hcxt;\n\t\telse\n\t\t\tCurrentDynaHashCxt = TopMemoryContext;\n\t\tCurrentDynaHashCxt = AllocSetContextCreate(CurrentDynaHashCxt,\n\t\t\t\t\t\t\t\t\t\t\t\t   \"dynahash\",\n\t\t\t\t\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n\t}\n\n\t/* Initialize the hash header, plus a copy of the table name */\n\thashp = (HTAB *) DynaHashAlloc(sizeof(HTAB) + strlen(tabname) + 1);\n\tMemSet(hashp, 0, sizeof(HTAB));\n\n\thashp->tabname = (char *) (hashp + 1);\n\tstrcpy(hashp->tabname, tabname);\n\n\t/* If we have a private context, label it with hashtable's name */\n\tif (!(flags & HASH_SHARED_MEM))\n\t\tMemoryContextSetIdentifier(CurrentDynaHashCxt, hashp->tabname);\n\n\t/*\n\t * Select the appropriate hash function (see comments at head of file).\n\t */\n\tif (flags & HASH_FUNCTION)\n\t\thashp->hash = info->hash;\n\telse if (flags & HASH_BLOBS)\n\t{\n\t\t/* We can optimize hashing for common key sizes */\n\t\tAssert(flags & HASH_ELEM);\n\t\tif (info->keysize == sizeof(uint32))\n\t\t\thashp->hash = uint32_hash;\n\t\telse\n\t\t\thashp->hash = tag_hash;\n\t}\n\telse\n\t\thashp->hash = string_hash;\t/* default hash function */\n\n\t/*\n\t * If you don't specify a match function, it defaults to string_compare if\n\t * you used string_hash (either explicitly or by default) and to memcmp\n\t * otherwise.\n\t *\n\t * Note: explicitly specifying string_hash is deprecated, because this\n\t * might not work for callers in loadable modules on some platforms due to\n\t * referencing a trampoline instead of the string_hash function proper.\n\t * Just let it default, eh?\n\t */\n\tif (flags & HASH_COMPARE)\n\t\thashp->match = info->match;\n\telse if (hashp->hash == string_hash)\n\t\thashp->match = (HashCompareFunc) string_compare;\n\telse\n\t\thashp->match = memcmp;\n\n\t/*\n\t * Similarly, the key-copying function defaults to strlcpy or memcpy.\n\t */\n\tif (flags & HASH_KEYCOPY)\n\t\thashp->keycopy = info->keycopy;\n\telse if (hashp->hash == string_hash)\n\t\thashp->keycopy = (HashCopyFunc) strlcpy;\n\telse\n\t\thashp->keycopy = memcpy;\n\n\t/* And select the entry allocation function, too. */\n\tif (flags & HASH_ALLOC)\n\t\thashp->alloc = info->alloc;\n\telse\n\t\thashp->alloc = DynaHashAlloc;\n\n\tif (flags & HASH_SHARED_MEM)\n\t{\n\t\t/*\n\t\t * ctl structure and directory are preallocated for shared memory\n\t\t * tables.  Note that HASH_DIRSIZE and HASH_ALLOC had better be set as\n\t\t * well.\n\t\t */\n\t\thashp->hctl = info->hctl;\n\t\thashp->dir = (HASHSEGMENT *) (((char *) info->hctl) + sizeof(HASHHDR));\n\t\thashp->hcxt = NULL;\n\t\thashp->isshared = true;\n\n\t\t/* hash table already exists, we're just attaching to it */\n\t\tif (flags & HASH_ATTACH)\n\t\t{\n\t\t\t/* make local copies of some heavily-used values */\n\t\t\thctl = hashp->hctl;\n\t\t\thashp->keysize = hctl->keysize;\n\t\t\thashp->ssize = hctl->ssize;\n\t\t\thashp->sshift = hctl->sshift;\n\n\t\t\treturn hashp;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* setup hash table defaults */\n\t\thashp->hctl = NULL;\n\t\thashp->dir = NULL;\n\t\thashp->hcxt = CurrentDynaHashCxt;\n\t\thashp->isshared = false;\n\t}\n\n\tif (!hashp->hctl)\n\t{\n\t\thashp->hctl = (HASHHDR *) hashp->alloc(sizeof(HASHHDR));\n\t\tif (!hashp->hctl)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t errmsg(\"out of memory\")));\n\t}\n\n\thashp->frozen = false;\n\n\thdefault(hashp);\n\n\thctl = hashp->hctl;\n\n\tif (flags & HASH_PARTITION)\n\t{\n\t\t/* Doesn't make sense to partition a local hash table */\n\t\tAssert(flags & HASH_SHARED_MEM);\n\n\t\t/*\n\t\t * The number of partitions had better be a power of 2. Also, it must\n\t\t * be less than INT_MAX (see init_htab()), so call the int version of\n\t\t * next_pow2.\n\t\t */\n\t\tAssert(info->num_partitions == next_pow2_int(info->num_partitions));\n\n\t\thctl->num_partitions = info->num_partitions;\n\t}\n\n\tif (flags & HASH_SEGMENT)\n\t{\n\t\thctl->ssize = info->ssize;\n\t\thctl->sshift = my_log2(info->ssize);\n\t\t/* ssize had better be a power of 2 */\n\t\tAssert(hctl->ssize == (1L << hctl->sshift));\n\t}\n\tif (flags & HASH_FFACTOR)\n\t\thctl->ffactor = info->ffactor;\n\n\t/*\n\t * SHM hash tables have fixed directory size passed by the caller.\n\t */\n\tif (flags & HASH_DIRSIZE)\n\t{\n\t\thctl->max_dsize = info->max_dsize;\n\t\thctl->dsize = info->dsize;\n\t}\n\n\t/*\n\t * hash table now allocates space for key and data but you have to say how\n\t * much space to allocate\n\t */\n\tif (flags & HASH_ELEM)\n\t{\n\t\tAssert(info->entrysize >= info->keysize);\n\t\thctl->keysize = info->keysize;\n\t\thctl->entrysize = info->entrysize;\n\t}\n\n\t/* make local copies of heavily-used constant fields */\n\thashp->keysize = hctl->keysize;\n\thashp->ssize = hctl->ssize;\n\thashp->sshift = hctl->sshift;\n\n\t/* Build the hash directory structure */\n\tif (!init_htab(hashp, nelem))\n\t\telog(ERROR, \"failed to initialize hash table \\\"%s\\\"\", hashp->tabname);\n\n\t/*\n\t * For a shared hash table, preallocate the requested number of elements.\n\t * This reduces problems with run-time out-of-shared-memory conditions.\n\t *\n\t * For a non-shared hash table, preallocate the requested number of\n\t * elements if it's less than our chosen nelem_alloc.  This avoids wasting\n\t * space if the caller correctly estimates a small table size.\n\t */\n\tif ((flags & HASH_SHARED_MEM) ||\n\t\tnelem < hctl->nelem_alloc)\n\t{\n\t\tint\t\t\ti,\n\t\t\t\t\tfreelist_partitions,\n\t\t\t\t\tnelem_alloc,\n\t\t\t\t\tnelem_alloc_first;\n\n\t\t/*\n\t\t * If hash table is partitioned, give each freelist an equal share of\n\t\t * the initial allocation.  Otherwise only freeList[0] is used.\n\t\t */\n\t\tif (IS_PARTITIONED(hashp->hctl))\n\t\t\tfreelist_partitions = NUM_FREELISTS;\n\t\telse\n\t\t\tfreelist_partitions = 1;\n\n\t\tnelem_alloc = nelem / freelist_partitions;\n\t\tif (nelem_alloc <= 0)\n\t\t\tnelem_alloc = 1;\n\n\t\t/*\n\t\t * Make sure we'll allocate all the requested elements; freeList[0]\n\t\t * gets the excess if the request isn't divisible by NUM_FREELISTS.\n\t\t */\n\t\tif (nelem_alloc * freelist_partitions < nelem)\n\t\t\tnelem_alloc_first =\n\t\t\t\tnelem - nelem_alloc * (freelist_partitions - 1);\n\t\telse\n\t\t\tnelem_alloc_first = nelem_alloc;\n\n\t\tfor (i = 0; i < freelist_partitions; i++)\n\t\t{\n\t\t\tint\t\t\ttemp = (i == 0) ? nelem_alloc_first : nelem_alloc;\n\n\t\t\tif (!element_alloc(hashp, temp, i))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t\t errmsg(\"out of memory\")));\n\t\t}\n\t}\n\n\tif (flags & HASH_FIXED_SIZE)\n\t\thashp->isfixed = true;\n\treturn hashp;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NUM_FREELISTS\t\t\t32"
          ],
          "globals_used": [
            "static void *DynaHashAlloc(Size size);",
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static int\tchoose_nelem_alloc(Size entrysize);",
            "static bool init_htab(HTAB *hashp, long nelem);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);",
            "static MemoryContext CurrentDynaHashCxt = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define NUM_FREELISTS\t\t\t32\n\nstatic void *DynaHashAlloc(Size size);\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic int\tchoose_nelem_alloc(Size entrysize);\nstatic bool init_htab(HTAB *hashp, long nelem);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\nstatic MemoryContext CurrentDynaHashCxt = NULL;\n\nHTAB *\nhash_create(const char *tabname, long nelem, HASHCTL *info, int flags)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\n\t/*\n\t * For shared hash tables, we have a local hash header (HTAB struct) that\n\t * we allocate in TopMemoryContext; all else is in shared memory.\n\t *\n\t * For non-shared hash tables, everything including the hash header is in\n\t * a memory context created specially for the hash table --- this makes\n\t * hash_destroy very simple.  The memory context is made a child of either\n\t * a context specified by the caller, or TopMemoryContext if nothing is\n\t * specified.\n\t */\n\tif (flags & HASH_SHARED_MEM)\n\t{\n\t\t/* Set up to allocate the hash header */\n\t\tCurrentDynaHashCxt = TopMemoryContext;\n\t}\n\telse\n\t{\n\t\t/* Create the hash table's private memory context */\n\t\tif (flags & HASH_CONTEXT)\n\t\t\tCurrentDynaHashCxt = info->hcxt;\n\t\telse\n\t\t\tCurrentDynaHashCxt = TopMemoryContext;\n\t\tCurrentDynaHashCxt = AllocSetContextCreate(CurrentDynaHashCxt,\n\t\t\t\t\t\t\t\t\t\t\t\t   \"dynahash\",\n\t\t\t\t\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n\t}\n\n\t/* Initialize the hash header, plus a copy of the table name */\n\thashp = (HTAB *) DynaHashAlloc(sizeof(HTAB) + strlen(tabname) + 1);\n\tMemSet(hashp, 0, sizeof(HTAB));\n\n\thashp->tabname = (char *) (hashp + 1);\n\tstrcpy(hashp->tabname, tabname);\n\n\t/* If we have a private context, label it with hashtable's name */\n\tif (!(flags & HASH_SHARED_MEM))\n\t\tMemoryContextSetIdentifier(CurrentDynaHashCxt, hashp->tabname);\n\n\t/*\n\t * Select the appropriate hash function (see comments at head of file).\n\t */\n\tif (flags & HASH_FUNCTION)\n\t\thashp->hash = info->hash;\n\telse if (flags & HASH_BLOBS)\n\t{\n\t\t/* We can optimize hashing for common key sizes */\n\t\tAssert(flags & HASH_ELEM);\n\t\tif (info->keysize == sizeof(uint32))\n\t\t\thashp->hash = uint32_hash;\n\t\telse\n\t\t\thashp->hash = tag_hash;\n\t}\n\telse\n\t\thashp->hash = string_hash;\t/* default hash function */\n\n\t/*\n\t * If you don't specify a match function, it defaults to string_compare if\n\t * you used string_hash (either explicitly or by default) and to memcmp\n\t * otherwise.\n\t *\n\t * Note: explicitly specifying string_hash is deprecated, because this\n\t * might not work for callers in loadable modules on some platforms due to\n\t * referencing a trampoline instead of the string_hash function proper.\n\t * Just let it default, eh?\n\t */\n\tif (flags & HASH_COMPARE)\n\t\thashp->match = info->match;\n\telse if (hashp->hash == string_hash)\n\t\thashp->match = (HashCompareFunc) string_compare;\n\telse\n\t\thashp->match = memcmp;\n\n\t/*\n\t * Similarly, the key-copying function defaults to strlcpy or memcpy.\n\t */\n\tif (flags & HASH_KEYCOPY)\n\t\thashp->keycopy = info->keycopy;\n\telse if (hashp->hash == string_hash)\n\t\thashp->keycopy = (HashCopyFunc) strlcpy;\n\telse\n\t\thashp->keycopy = memcpy;\n\n\t/* And select the entry allocation function, too. */\n\tif (flags & HASH_ALLOC)\n\t\thashp->alloc = info->alloc;\n\telse\n\t\thashp->alloc = DynaHashAlloc;\n\n\tif (flags & HASH_SHARED_MEM)\n\t{\n\t\t/*\n\t\t * ctl structure and directory are preallocated for shared memory\n\t\t * tables.  Note that HASH_DIRSIZE and HASH_ALLOC had better be set as\n\t\t * well.\n\t\t */\n\t\thashp->hctl = info->hctl;\n\t\thashp->dir = (HASHSEGMENT *) (((char *) info->hctl) + sizeof(HASHHDR));\n\t\thashp->hcxt = NULL;\n\t\thashp->isshared = true;\n\n\t\t/* hash table already exists, we're just attaching to it */\n\t\tif (flags & HASH_ATTACH)\n\t\t{\n\t\t\t/* make local copies of some heavily-used values */\n\t\t\thctl = hashp->hctl;\n\t\t\thashp->keysize = hctl->keysize;\n\t\t\thashp->ssize = hctl->ssize;\n\t\t\thashp->sshift = hctl->sshift;\n\n\t\t\treturn hashp;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* setup hash table defaults */\n\t\thashp->hctl = NULL;\n\t\thashp->dir = NULL;\n\t\thashp->hcxt = CurrentDynaHashCxt;\n\t\thashp->isshared = false;\n\t}\n\n\tif (!hashp->hctl)\n\t{\n\t\thashp->hctl = (HASHHDR *) hashp->alloc(sizeof(HASHHDR));\n\t\tif (!hashp->hctl)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t errmsg(\"out of memory\")));\n\t}\n\n\thashp->frozen = false;\n\n\thdefault(hashp);\n\n\thctl = hashp->hctl;\n\n\tif (flags & HASH_PARTITION)\n\t{\n\t\t/* Doesn't make sense to partition a local hash table */\n\t\tAssert(flags & HASH_SHARED_MEM);\n\n\t\t/*\n\t\t * The number of partitions had better be a power of 2. Also, it must\n\t\t * be less than INT_MAX (see init_htab()), so call the int version of\n\t\t * next_pow2.\n\t\t */\n\t\tAssert(info->num_partitions == next_pow2_int(info->num_partitions));\n\n\t\thctl->num_partitions = info->num_partitions;\n\t}\n\n\tif (flags & HASH_SEGMENT)\n\t{\n\t\thctl->ssize = info->ssize;\n\t\thctl->sshift = my_log2(info->ssize);\n\t\t/* ssize had better be a power of 2 */\n\t\tAssert(hctl->ssize == (1L << hctl->sshift));\n\t}\n\tif (flags & HASH_FFACTOR)\n\t\thctl->ffactor = info->ffactor;\n\n\t/*\n\t * SHM hash tables have fixed directory size passed by the caller.\n\t */\n\tif (flags & HASH_DIRSIZE)\n\t{\n\t\thctl->max_dsize = info->max_dsize;\n\t\thctl->dsize = info->dsize;\n\t}\n\n\t/*\n\t * hash table now allocates space for key and data but you have to say how\n\t * much space to allocate\n\t */\n\tif (flags & HASH_ELEM)\n\t{\n\t\tAssert(info->entrysize >= info->keysize);\n\t\thctl->keysize = info->keysize;\n\t\thctl->entrysize = info->entrysize;\n\t}\n\n\t/* make local copies of heavily-used constant fields */\n\thashp->keysize = hctl->keysize;\n\thashp->ssize = hctl->ssize;\n\thashp->sshift = hctl->sshift;\n\n\t/* Build the hash directory structure */\n\tif (!init_htab(hashp, nelem))\n\t\telog(ERROR, \"failed to initialize hash table \\\"%s\\\"\", hashp->tabname);\n\n\t/*\n\t * For a shared hash table, preallocate the requested number of elements.\n\t * This reduces problems with run-time out-of-shared-memory conditions.\n\t *\n\t * For a non-shared hash table, preallocate the requested number of\n\t * elements if it's less than our chosen nelem_alloc.  This avoids wasting\n\t * space if the caller correctly estimates a small table size.\n\t */\n\tif ((flags & HASH_SHARED_MEM) ||\n\t\tnelem < hctl->nelem_alloc)\n\t{\n\t\tint\t\t\ti,\n\t\t\t\t\tfreelist_partitions,\n\t\t\t\t\tnelem_alloc,\n\t\t\t\t\tnelem_alloc_first;\n\n\t\t/*\n\t\t * If hash table is partitioned, give each freelist an equal share of\n\t\t * the initial allocation.  Otherwise only freeList[0] is used.\n\t\t */\n\t\tif (IS_PARTITIONED(hashp->hctl))\n\t\t\tfreelist_partitions = NUM_FREELISTS;\n\t\telse\n\t\t\tfreelist_partitions = 1;\n\n\t\tnelem_alloc = nelem / freelist_partitions;\n\t\tif (nelem_alloc <= 0)\n\t\t\tnelem_alloc = 1;\n\n\t\t/*\n\t\t * Make sure we'll allocate all the requested elements; freeList[0]\n\t\t * gets the excess if the request isn't divisible by NUM_FREELISTS.\n\t\t */\n\t\tif (nelem_alloc * freelist_partitions < nelem)\n\t\t\tnelem_alloc_first =\n\t\t\t\tnelem - nelem_alloc * (freelist_partitions - 1);\n\t\telse\n\t\t\tnelem_alloc_first = nelem_alloc;\n\n\t\tfor (i = 0; i < freelist_partitions; i++)\n\t\t{\n\t\t\tint\t\t\ttemp = (i == 0) ? nelem_alloc_first : nelem_alloc;\n\n\t\t\tif (!element_alloc(hashp, temp, i))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t\t errmsg(\"out of memory\")));\n\t\t}\n\t}\n\n\tif (flags & HASH_FIXED_SIZE)\n\t\thashp->isfixed = true;\n\treturn hashp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AllocSetContextCreate",
          "args": [
            "TopMemoryContext",
            "\"TopPortalContext\"",
            "ALLOCSET_DEFAULT_SIZES"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "TopPortalContext == NULL"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/ipc.h\"\n#include \"miscadmin.h\"\n#include \"commands/portalcmds.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\n#define MAX_PORTALNAME_LEN\t\tNAMEDATALEN\n#define PORTALS_PER_USER\t   16\n\nstatic HTAB *PortalHashTable = NULL;\nstatic MemoryContext TopPortalContext = NULL;\n\nvoid\nEnablePortalManager(void)\n{\n\tHASHCTL\t\tctl;\n\n\tAssert(TopPortalContext == NULL);\n\n\tTopPortalContext = AllocSetContextCreate(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t \"TopPortalContext\",\n\t\t\t\t\t\t\t\t\t\t\t ALLOCSET_DEFAULT_SIZES);\n\n\tctl.keysize = MAX_PORTALNAME_LEN;\n\tctl.entrysize = sizeof(PortalHashEnt);\n\n\t/*\n\t * use PORTALS_PER_USER as a guess of how many hash table entries to\n\t * create, initially\n\t */\n\tPortalHashTable = hash_create(\"Portal hash\", PORTALS_PER_USER,\n\t\t\t\t\t\t\t\t  &ctl, HASH_ELEM);\n}"
  }
]