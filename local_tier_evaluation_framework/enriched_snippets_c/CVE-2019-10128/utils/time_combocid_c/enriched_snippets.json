[
  {
    "function_name": "RestoreComboCIDState",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/combocid.c",
    "lines": "343-366",
    "snippet": "void\nRestoreComboCIDState(char *comboCIDstate)\n{\n\tint\t\t\tnum_elements;\n\tComboCidKeyData *keydata;\n\tint\t\t\ti;\n\tCommandId\tcid;\n\n\tAssert(!comboCids && !comboHash);\n\n\t/* First, we retrieve the number of ComboCIDs that were serialized. */\n\tnum_elements = *(int *) comboCIDstate;\n\tkeydata = (ComboCidKeyData *) (comboCIDstate + sizeof(int));\n\n\t/* Use GetComboCommandId to restore each ComboCID. */\n\tfor (i = 0; i < num_elements; i++)\n\t{\n\t\tcid = GetComboCommandId(keydata[i].cmin, keydata[i].cmax);\n\n\t\t/* Verify that we got the expected answer. */\n\t\tif (cid != i)\n\t\t\telog(ERROR, \"unexpected command ID while restoring combo CIDs\");\n\t}\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/combocid.h\"",
      "#include \"storage/shmem.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"miscadmin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static HTAB *comboHash = NULL;",
      "static ComboCidKey comboCids = NULL;",
      "static CommandId GetComboCommandId(CommandId cmin, CommandId cmax);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unexpected command ID while restoring combo CIDs\""
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetComboCommandId",
          "args": [
            "keydata[i].cmin",
            "keydata[i].cmax"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "GetComboCommandId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/combocid.c",
          "lines": "204-278",
          "snippet": "static CommandId\nGetComboCommandId(CommandId cmin, CommandId cmax)\n{\n\tCommandId\tcombocid;\n\tComboCidKeyData key;\n\tComboCidEntry entry;\n\tbool\t\tfound;\n\n\t/*\n\t * Create the hash table and array the first time we need to use combo\n\t * cids in the transaction.\n\t */\n\tif (comboHash == NULL)\n\t{\n\t\tHASHCTL\t\thash_ctl;\n\n\t\t/* Make array first; existence of hash table asserts array exists */\n\t\tcomboCids = (ComboCidKeyData *)\n\t\t\tMemoryContextAlloc(TopTransactionContext,\n\t\t\t\t\t\t\t   sizeof(ComboCidKeyData) * CCID_ARRAY_SIZE);\n\t\tsizeComboCids = CCID_ARRAY_SIZE;\n\t\tusedComboCids = 0;\n\n\t\tmemset(&hash_ctl, 0, sizeof(hash_ctl));\n\t\thash_ctl.keysize = sizeof(ComboCidKeyData);\n\t\thash_ctl.entrysize = sizeof(ComboCidEntryData);\n\t\thash_ctl.hcxt = TopTransactionContext;\n\n\t\tcomboHash = hash_create(\"Combo CIDs\",\n\t\t\t\t\t\t\t\tCCID_HASH_SIZE,\n\t\t\t\t\t\t\t\t&hash_ctl,\n\t\t\t\t\t\t\t\tHASH_ELEM | HASH_BLOBS | HASH_CONTEXT);\n\t}\n\n\t/*\n\t * Grow the array if there's not at least one free slot.  We must do this\n\t * before possibly entering a new hashtable entry, else failure to\n\t * repalloc would leave a corrupt hashtable entry behind.\n\t */\n\tif (usedComboCids >= sizeComboCids)\n\t{\n\t\tint\t\t\tnewsize = sizeComboCids * 2;\n\n\t\tcomboCids = (ComboCidKeyData *)\n\t\t\trepalloc(comboCids, sizeof(ComboCidKeyData) * newsize);\n\t\tsizeComboCids = newsize;\n\t}\n\n\t/* Lookup or create a hash entry with the desired cmin/cmax */\n\n\t/* We assume there is no struct padding in ComboCidKeyData! */\n\tkey.cmin = cmin;\n\tkey.cmax = cmax;\n\tentry = (ComboCidEntry) hash_search(comboHash,\n\t\t\t\t\t\t\t\t\t\t(void *) &key,\n\t\t\t\t\t\t\t\t\t\tHASH_ENTER,\n\t\t\t\t\t\t\t\t\t\t&found);\n\n\tif (found)\n\t{\n\t\t/* Reuse an existing combo cid */\n\t\treturn entry->combocid;\n\t}\n\n\t/* We have to create a new combo cid; we already made room in the array */\n\tcombocid = usedComboCids;\n\n\tcomboCids[combocid].cmin = cmin;\n\tcomboCids[combocid].cmax = cmax;\n\tusedComboCids++;\n\n\tentry->combocid = combocid;\n\n\treturn combocid;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/combocid.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"miscadmin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define CCID_ARRAY_SIZE\t\t\t100",
            "#define CCID_HASH_SIZE\t\t\t100"
          ],
          "globals_used": [
            "static HTAB *comboHash = NULL;",
            "static ComboCidKey comboCids = NULL;",
            "static int\tusedComboCids = 0;",
            "static int\tsizeComboCids = 0;",
            "static CommandId GetComboCommandId(CommandId cmin, CommandId cmax);",
            "static CommandId GetRealCmin(CommandId combocid);",
            "static CommandId GetRealCmax(CommandId combocid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/combocid.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\n#define CCID_ARRAY_SIZE\t\t\t100\n#define CCID_HASH_SIZE\t\t\t100\n\nstatic HTAB *comboHash = NULL;\nstatic ComboCidKey comboCids = NULL;\nstatic int\tusedComboCids = 0;\nstatic int\tsizeComboCids = 0;\nstatic CommandId GetComboCommandId(CommandId cmin, CommandId cmax);\nstatic CommandId GetRealCmin(CommandId combocid);\nstatic CommandId GetRealCmax(CommandId combocid);\n\nstatic CommandId\nGetComboCommandId(CommandId cmin, CommandId cmax)\n{\n\tCommandId\tcombocid;\n\tComboCidKeyData key;\n\tComboCidEntry entry;\n\tbool\t\tfound;\n\n\t/*\n\t * Create the hash table and array the first time we need to use combo\n\t * cids in the transaction.\n\t */\n\tif (comboHash == NULL)\n\t{\n\t\tHASHCTL\t\thash_ctl;\n\n\t\t/* Make array first; existence of hash table asserts array exists */\n\t\tcomboCids = (ComboCidKeyData *)\n\t\t\tMemoryContextAlloc(TopTransactionContext,\n\t\t\t\t\t\t\t   sizeof(ComboCidKeyData) * CCID_ARRAY_SIZE);\n\t\tsizeComboCids = CCID_ARRAY_SIZE;\n\t\tusedComboCids = 0;\n\n\t\tmemset(&hash_ctl, 0, sizeof(hash_ctl));\n\t\thash_ctl.keysize = sizeof(ComboCidKeyData);\n\t\thash_ctl.entrysize = sizeof(ComboCidEntryData);\n\t\thash_ctl.hcxt = TopTransactionContext;\n\n\t\tcomboHash = hash_create(\"Combo CIDs\",\n\t\t\t\t\t\t\t\tCCID_HASH_SIZE,\n\t\t\t\t\t\t\t\t&hash_ctl,\n\t\t\t\t\t\t\t\tHASH_ELEM | HASH_BLOBS | HASH_CONTEXT);\n\t}\n\n\t/*\n\t * Grow the array if there's not at least one free slot.  We must do this\n\t * before possibly entering a new hashtable entry, else failure to\n\t * repalloc would leave a corrupt hashtable entry behind.\n\t */\n\tif (usedComboCids >= sizeComboCids)\n\t{\n\t\tint\t\t\tnewsize = sizeComboCids * 2;\n\n\t\tcomboCids = (ComboCidKeyData *)\n\t\t\trepalloc(comboCids, sizeof(ComboCidKeyData) * newsize);\n\t\tsizeComboCids = newsize;\n\t}\n\n\t/* Lookup or create a hash entry with the desired cmin/cmax */\n\n\t/* We assume there is no struct padding in ComboCidKeyData! */\n\tkey.cmin = cmin;\n\tkey.cmax = cmax;\n\tentry = (ComboCidEntry) hash_search(comboHash,\n\t\t\t\t\t\t\t\t\t\t(void *) &key,\n\t\t\t\t\t\t\t\t\t\tHASH_ENTER,\n\t\t\t\t\t\t\t\t\t\t&found);\n\n\tif (found)\n\t{\n\t\t/* Reuse an existing combo cid */\n\t\treturn entry->combocid;\n\t}\n\n\t/* We have to create a new combo cid; we already made room in the array */\n\tcombocid = usedComboCids;\n\n\tcomboCids[combocid].cmin = cmin;\n\tcomboCids[combocid].cmax = cmax;\n\tusedComboCids++;\n\n\tentry->combocid = combocid;\n\n\treturn combocid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!comboCids && !comboHash"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/combocid.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic HTAB *comboHash = NULL;\nstatic ComboCidKey comboCids = NULL;\nstatic CommandId GetComboCommandId(CommandId cmin, CommandId cmax);\n\nvoid\nRestoreComboCIDState(char *comboCIDstate)\n{\n\tint\t\t\tnum_elements;\n\tComboCidKeyData *keydata;\n\tint\t\t\ti;\n\tCommandId\tcid;\n\n\tAssert(!comboCids && !comboHash);\n\n\t/* First, we retrieve the number of ComboCIDs that were serialized. */\n\tnum_elements = *(int *) comboCIDstate;\n\tkeydata = (ComboCidKeyData *) (comboCIDstate + sizeof(int));\n\n\t/* Use GetComboCommandId to restore each ComboCID. */\n\tfor (i = 0; i < num_elements; i++)\n\t{\n\t\tcid = GetComboCommandId(keydata[i].cmin, keydata[i].cmax);\n\n\t\t/* Verify that we got the expected answer. */\n\t\tif (cid != i)\n\t\t\telog(ERROR, \"unexpected command ID while restoring combo CIDs\");\n\t}\n}"
  },
  {
    "function_name": "SerializeComboCIDState",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/combocid.c",
    "lines": "317-335",
    "snippet": "void\nSerializeComboCIDState(Size maxsize, char *start_address)\n{\n\tchar\t   *endptr;\n\n\t/* First, we store the number of currently-existing ComboCIDs. */\n\t*(int *) start_address = usedComboCids;\n\n\t/* If maxsize is too small, throw an error. */\n\tendptr = start_address + sizeof(int) +\n\t\t(sizeof(ComboCidKeyData) * usedComboCids);\n\tif (endptr < start_address || endptr > start_address + maxsize)\n\t\telog(ERROR, \"not enough space to serialize ComboCID state\");\n\n\t/* Now, copy the actual cmin/cmax pairs. */\n\tif (usedComboCids > 0)\n\t\tmemcpy(start_address + sizeof(int), comboCids,\n\t\t\t   (sizeof(ComboCidKeyData) * usedComboCids));\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/combocid.h\"",
      "#include \"storage/shmem.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"miscadmin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static ComboCidKey comboCids = NULL;",
      "static int\tusedComboCids = 0;",
      "static CommandId GetComboCommandId(CommandId cmin, CommandId cmax);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "start_address + sizeof(int)",
            "comboCids",
            "(sizeof(ComboCidKeyData) * usedComboCids)"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"not enough space to serialize ComboCID state\""
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/combocid.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic ComboCidKey comboCids = NULL;\nstatic int\tusedComboCids = 0;\nstatic CommandId GetComboCommandId(CommandId cmin, CommandId cmax);\n\nvoid\nSerializeComboCIDState(Size maxsize, char *start_address)\n{\n\tchar\t   *endptr;\n\n\t/* First, we store the number of currently-existing ComboCIDs. */\n\t*(int *) start_address = usedComboCids;\n\n\t/* If maxsize is too small, throw an error. */\n\tendptr = start_address + sizeof(int) +\n\t\t(sizeof(ComboCidKeyData) * usedComboCids);\n\tif (endptr < start_address || endptr > start_address + maxsize)\n\t\telog(ERROR, \"not enough space to serialize ComboCID state\");\n\n\t/* Now, copy the actual cmin/cmax pairs. */\n\tif (usedComboCids > 0)\n\t\tmemcpy(start_address + sizeof(int), comboCids,\n\t\t\t   (sizeof(ComboCidKeyData) * usedComboCids));\n}"
  },
  {
    "function_name": "EstimateComboCIDStateSpace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/combocid.c",
    "lines": "298-310",
    "snippet": "Size\nEstimateComboCIDStateSpace(void)\n{\n\tSize\t\tsize;\n\n\t/* Add space required for saving usedComboCids */\n\tsize = sizeof(int);\n\n\t/* Add space required for saving the combocids key */\n\tsize = add_size(size, mul_size(sizeof(ComboCidKeyData), usedComboCids));\n\n\treturn size;\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/combocid.h\"",
      "#include \"storage/shmem.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"miscadmin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tusedComboCids = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_size",
          "args": [
            "size",
            "mul_size(sizeof(ComboCidKeyData), usedComboCids)"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mul_size",
          "args": [
            "sizeof(ComboCidKeyData)",
            "usedComboCids"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/combocid.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic int\tusedComboCids = 0;\n\nSize\nEstimateComboCIDStateSpace(void)\n{\n\tSize\t\tsize;\n\n\t/* Add space required for saving usedComboCids */\n\tsize = sizeof(int);\n\n\t/* Add space required for saving the combocids key */\n\tsize = add_size(size, mul_size(sizeof(ComboCidKeyData), usedComboCids));\n\n\treturn size;\n}"
  },
  {
    "function_name": "GetRealCmax",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/combocid.c",
    "lines": "287-292",
    "snippet": "static CommandId\nGetRealCmax(CommandId combocid)\n{\n\tAssert(combocid < usedComboCids);\n\treturn comboCids[combocid].cmax;\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/combocid.h\"",
      "#include \"storage/shmem.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"miscadmin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static ComboCidKey comboCids = NULL;",
      "static int\tusedComboCids = 0;",
      "static CommandId GetComboCommandId(CommandId cmin, CommandId cmax);",
      "static CommandId GetRealCmin(CommandId combocid);",
      "static CommandId GetRealCmax(CommandId combocid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "combocid < usedComboCids"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/combocid.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic ComboCidKey comboCids = NULL;\nstatic int\tusedComboCids = 0;\nstatic CommandId GetComboCommandId(CommandId cmin, CommandId cmax);\nstatic CommandId GetRealCmin(CommandId combocid);\nstatic CommandId GetRealCmax(CommandId combocid);\n\nstatic CommandId\nGetRealCmax(CommandId combocid)\n{\n\tAssert(combocid < usedComboCids);\n\treturn comboCids[combocid].cmax;\n}"
  },
  {
    "function_name": "GetRealCmin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/combocid.c",
    "lines": "280-285",
    "snippet": "static CommandId\nGetRealCmin(CommandId combocid)\n{\n\tAssert(combocid < usedComboCids);\n\treturn comboCids[combocid].cmin;\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/combocid.h\"",
      "#include \"storage/shmem.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"miscadmin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static ComboCidKey comboCids = NULL;",
      "static int\tusedComboCids = 0;",
      "static CommandId GetRealCmin(CommandId combocid);",
      "static CommandId GetRealCmax(CommandId combocid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "combocid < usedComboCids"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/combocid.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic ComboCidKey comboCids = NULL;\nstatic int\tusedComboCids = 0;\nstatic CommandId GetRealCmin(CommandId combocid);\nstatic CommandId GetRealCmax(CommandId combocid);\n\nstatic CommandId\nGetRealCmin(CommandId combocid)\n{\n\tAssert(combocid < usedComboCids);\n\treturn comboCids[combocid].cmin;\n}"
  },
  {
    "function_name": "GetComboCommandId",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/combocid.c",
    "lines": "204-278",
    "snippet": "static CommandId\nGetComboCommandId(CommandId cmin, CommandId cmax)\n{\n\tCommandId\tcombocid;\n\tComboCidKeyData key;\n\tComboCidEntry entry;\n\tbool\t\tfound;\n\n\t/*\n\t * Create the hash table and array the first time we need to use combo\n\t * cids in the transaction.\n\t */\n\tif (comboHash == NULL)\n\t{\n\t\tHASHCTL\t\thash_ctl;\n\n\t\t/* Make array first; existence of hash table asserts array exists */\n\t\tcomboCids = (ComboCidKeyData *)\n\t\t\tMemoryContextAlloc(TopTransactionContext,\n\t\t\t\t\t\t\t   sizeof(ComboCidKeyData) * CCID_ARRAY_SIZE);\n\t\tsizeComboCids = CCID_ARRAY_SIZE;\n\t\tusedComboCids = 0;\n\n\t\tmemset(&hash_ctl, 0, sizeof(hash_ctl));\n\t\thash_ctl.keysize = sizeof(ComboCidKeyData);\n\t\thash_ctl.entrysize = sizeof(ComboCidEntryData);\n\t\thash_ctl.hcxt = TopTransactionContext;\n\n\t\tcomboHash = hash_create(\"Combo CIDs\",\n\t\t\t\t\t\t\t\tCCID_HASH_SIZE,\n\t\t\t\t\t\t\t\t&hash_ctl,\n\t\t\t\t\t\t\t\tHASH_ELEM | HASH_BLOBS | HASH_CONTEXT);\n\t}\n\n\t/*\n\t * Grow the array if there's not at least one free slot.  We must do this\n\t * before possibly entering a new hashtable entry, else failure to\n\t * repalloc would leave a corrupt hashtable entry behind.\n\t */\n\tif (usedComboCids >= sizeComboCids)\n\t{\n\t\tint\t\t\tnewsize = sizeComboCids * 2;\n\n\t\tcomboCids = (ComboCidKeyData *)\n\t\t\trepalloc(comboCids, sizeof(ComboCidKeyData) * newsize);\n\t\tsizeComboCids = newsize;\n\t}\n\n\t/* Lookup or create a hash entry with the desired cmin/cmax */\n\n\t/* We assume there is no struct padding in ComboCidKeyData! */\n\tkey.cmin = cmin;\n\tkey.cmax = cmax;\n\tentry = (ComboCidEntry) hash_search(comboHash,\n\t\t\t\t\t\t\t\t\t\t(void *) &key,\n\t\t\t\t\t\t\t\t\t\tHASH_ENTER,\n\t\t\t\t\t\t\t\t\t\t&found);\n\n\tif (found)\n\t{\n\t\t/* Reuse an existing combo cid */\n\t\treturn entry->combocid;\n\t}\n\n\t/* We have to create a new combo cid; we already made room in the array */\n\tcombocid = usedComboCids;\n\n\tcomboCids[combocid].cmin = cmin;\n\tcomboCids[combocid].cmax = cmax;\n\tusedComboCids++;\n\n\tentry->combocid = combocid;\n\n\treturn combocid;\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/combocid.h\"",
      "#include \"storage/shmem.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"miscadmin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define CCID_ARRAY_SIZE\t\t\t100",
      "#define CCID_HASH_SIZE\t\t\t100"
    ],
    "globals_used": [
      "static HTAB *comboHash = NULL;",
      "static ComboCidKey comboCids = NULL;",
      "static int\tusedComboCids = 0;",
      "static int\tsizeComboCids = 0;",
      "static CommandId GetComboCommandId(CommandId cmin, CommandId cmax);",
      "static CommandId GetRealCmin(CommandId combocid);",
      "static CommandId GetRealCmax(CommandId combocid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash_search",
          "args": [
            "comboHash",
            "(void *) &key",
            "HASH_ENTER",
            "&found"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "hash_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "905-916",
          "snippet": "void *\nhash_search(HTAB *hashp,\n\t\t\tconst void *keyPtr,\n\t\t\tHASHACTION action,\n\t\t\tbool *foundPtr)\n{\n\treturn hash_search_with_hash_value(hashp,\n\t\t\t\t\t\t\t\t\t   keyPtr,\n\t\t\t\t\t\t\t\t\t   hashp->hash(keyPtr, hashp->keysize),\n\t\t\t\t\t\t\t\t\t   action,\n\t\t\t\t\t\t\t\t\t   foundPtr);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid *\nhash_search(HTAB *hashp,\n\t\t\tconst void *keyPtr,\n\t\t\tHASHACTION action,\n\t\t\tbool *foundPtr)\n{\n\treturn hash_search_with_hash_value(hashp,\n\t\t\t\t\t\t\t\t\t   keyPtr,\n\t\t\t\t\t\t\t\t\t   hashp->hash(keyPtr, hashp->keysize),\n\t\t\t\t\t\t\t\t\t   action,\n\t\t\t\t\t\t\t\t\t   foundPtr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "repalloc",
          "args": [
            "comboCids",
            "sizeof(ComboCidKeyData) * newsize"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "repalloc_huge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1113-1141",
          "snippet": "void *\nrepalloc_huge(void *pointer, Size size)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\tvoid\t   *ret;\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tAssertNotInCriticalSection(context);\n\n\t/* isReset must be false already */\n\tAssert(!context->isReset);\n\n\tret = context->methods->realloc(context, pointer, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_CHANGE(context, pointer, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nrepalloc_huge(void *pointer, Size size)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\tvoid\t   *ret;\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tAssertNotInCriticalSection(context);\n\n\t/* isReset must be false already */\n\tAssert(!context->isReset);\n\n\tret = context->methods->realloc(context, pointer, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_CHANGE(context, pointer, ret, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_create",
          "args": [
            "\"Combo CIDs\"",
            "CCID_HASH_SIZE",
            "&hash_ctl",
            "HASH_ELEM | HASH_BLOBS | HASH_CONTEXT"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "hash_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "315-564",
          "snippet": "HTAB *\nhash_create(const char *tabname, long nelem, HASHCTL *info, int flags)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\n\t/*\n\t * For shared hash tables, we have a local hash header (HTAB struct) that\n\t * we allocate in TopMemoryContext; all else is in shared memory.\n\t *\n\t * For non-shared hash tables, everything including the hash header is in\n\t * a memory context created specially for the hash table --- this makes\n\t * hash_destroy very simple.  The memory context is made a child of either\n\t * a context specified by the caller, or TopMemoryContext if nothing is\n\t * specified.\n\t */\n\tif (flags & HASH_SHARED_MEM)\n\t{\n\t\t/* Set up to allocate the hash header */\n\t\tCurrentDynaHashCxt = TopMemoryContext;\n\t}\n\telse\n\t{\n\t\t/* Create the hash table's private memory context */\n\t\tif (flags & HASH_CONTEXT)\n\t\t\tCurrentDynaHashCxt = info->hcxt;\n\t\telse\n\t\t\tCurrentDynaHashCxt = TopMemoryContext;\n\t\tCurrentDynaHashCxt = AllocSetContextCreate(CurrentDynaHashCxt,\n\t\t\t\t\t\t\t\t\t\t\t\t   \"dynahash\",\n\t\t\t\t\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n\t}\n\n\t/* Initialize the hash header, plus a copy of the table name */\n\thashp = (HTAB *) DynaHashAlloc(sizeof(HTAB) + strlen(tabname) + 1);\n\tMemSet(hashp, 0, sizeof(HTAB));\n\n\thashp->tabname = (char *) (hashp + 1);\n\tstrcpy(hashp->tabname, tabname);\n\n\t/* If we have a private context, label it with hashtable's name */\n\tif (!(flags & HASH_SHARED_MEM))\n\t\tMemoryContextSetIdentifier(CurrentDynaHashCxt, hashp->tabname);\n\n\t/*\n\t * Select the appropriate hash function (see comments at head of file).\n\t */\n\tif (flags & HASH_FUNCTION)\n\t\thashp->hash = info->hash;\n\telse if (flags & HASH_BLOBS)\n\t{\n\t\t/* We can optimize hashing for common key sizes */\n\t\tAssert(flags & HASH_ELEM);\n\t\tif (info->keysize == sizeof(uint32))\n\t\t\thashp->hash = uint32_hash;\n\t\telse\n\t\t\thashp->hash = tag_hash;\n\t}\n\telse\n\t\thashp->hash = string_hash;\t/* default hash function */\n\n\t/*\n\t * If you don't specify a match function, it defaults to string_compare if\n\t * you used string_hash (either explicitly or by default) and to memcmp\n\t * otherwise.\n\t *\n\t * Note: explicitly specifying string_hash is deprecated, because this\n\t * might not work for callers in loadable modules on some platforms due to\n\t * referencing a trampoline instead of the string_hash function proper.\n\t * Just let it default, eh?\n\t */\n\tif (flags & HASH_COMPARE)\n\t\thashp->match = info->match;\n\telse if (hashp->hash == string_hash)\n\t\thashp->match = (HashCompareFunc) string_compare;\n\telse\n\t\thashp->match = memcmp;\n\n\t/*\n\t * Similarly, the key-copying function defaults to strlcpy or memcpy.\n\t */\n\tif (flags & HASH_KEYCOPY)\n\t\thashp->keycopy = info->keycopy;\n\telse if (hashp->hash == string_hash)\n\t\thashp->keycopy = (HashCopyFunc) strlcpy;\n\telse\n\t\thashp->keycopy = memcpy;\n\n\t/* And select the entry allocation function, too. */\n\tif (flags & HASH_ALLOC)\n\t\thashp->alloc = info->alloc;\n\telse\n\t\thashp->alloc = DynaHashAlloc;\n\n\tif (flags & HASH_SHARED_MEM)\n\t{\n\t\t/*\n\t\t * ctl structure and directory are preallocated for shared memory\n\t\t * tables.  Note that HASH_DIRSIZE and HASH_ALLOC had better be set as\n\t\t * well.\n\t\t */\n\t\thashp->hctl = info->hctl;\n\t\thashp->dir = (HASHSEGMENT *) (((char *) info->hctl) + sizeof(HASHHDR));\n\t\thashp->hcxt = NULL;\n\t\thashp->isshared = true;\n\n\t\t/* hash table already exists, we're just attaching to it */\n\t\tif (flags & HASH_ATTACH)\n\t\t{\n\t\t\t/* make local copies of some heavily-used values */\n\t\t\thctl = hashp->hctl;\n\t\t\thashp->keysize = hctl->keysize;\n\t\t\thashp->ssize = hctl->ssize;\n\t\t\thashp->sshift = hctl->sshift;\n\n\t\t\treturn hashp;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* setup hash table defaults */\n\t\thashp->hctl = NULL;\n\t\thashp->dir = NULL;\n\t\thashp->hcxt = CurrentDynaHashCxt;\n\t\thashp->isshared = false;\n\t}\n\n\tif (!hashp->hctl)\n\t{\n\t\thashp->hctl = (HASHHDR *) hashp->alloc(sizeof(HASHHDR));\n\t\tif (!hashp->hctl)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t errmsg(\"out of memory\")));\n\t}\n\n\thashp->frozen = false;\n\n\thdefault(hashp);\n\n\thctl = hashp->hctl;\n\n\tif (flags & HASH_PARTITION)\n\t{\n\t\t/* Doesn't make sense to partition a local hash table */\n\t\tAssert(flags & HASH_SHARED_MEM);\n\n\t\t/*\n\t\t * The number of partitions had better be a power of 2. Also, it must\n\t\t * be less than INT_MAX (see init_htab()), so call the int version of\n\t\t * next_pow2.\n\t\t */\n\t\tAssert(info->num_partitions == next_pow2_int(info->num_partitions));\n\n\t\thctl->num_partitions = info->num_partitions;\n\t}\n\n\tif (flags & HASH_SEGMENT)\n\t{\n\t\thctl->ssize = info->ssize;\n\t\thctl->sshift = my_log2(info->ssize);\n\t\t/* ssize had better be a power of 2 */\n\t\tAssert(hctl->ssize == (1L << hctl->sshift));\n\t}\n\tif (flags & HASH_FFACTOR)\n\t\thctl->ffactor = info->ffactor;\n\n\t/*\n\t * SHM hash tables have fixed directory size passed by the caller.\n\t */\n\tif (flags & HASH_DIRSIZE)\n\t{\n\t\thctl->max_dsize = info->max_dsize;\n\t\thctl->dsize = info->dsize;\n\t}\n\n\t/*\n\t * hash table now allocates space for key and data but you have to say how\n\t * much space to allocate\n\t */\n\tif (flags & HASH_ELEM)\n\t{\n\t\tAssert(info->entrysize >= info->keysize);\n\t\thctl->keysize = info->keysize;\n\t\thctl->entrysize = info->entrysize;\n\t}\n\n\t/* make local copies of heavily-used constant fields */\n\thashp->keysize = hctl->keysize;\n\thashp->ssize = hctl->ssize;\n\thashp->sshift = hctl->sshift;\n\n\t/* Build the hash directory structure */\n\tif (!init_htab(hashp, nelem))\n\t\telog(ERROR, \"failed to initialize hash table \\\"%s\\\"\", hashp->tabname);\n\n\t/*\n\t * For a shared hash table, preallocate the requested number of elements.\n\t * This reduces problems with run-time out-of-shared-memory conditions.\n\t *\n\t * For a non-shared hash table, preallocate the requested number of\n\t * elements if it's less than our chosen nelem_alloc.  This avoids wasting\n\t * space if the caller correctly estimates a small table size.\n\t */\n\tif ((flags & HASH_SHARED_MEM) ||\n\t\tnelem < hctl->nelem_alloc)\n\t{\n\t\tint\t\t\ti,\n\t\t\t\t\tfreelist_partitions,\n\t\t\t\t\tnelem_alloc,\n\t\t\t\t\tnelem_alloc_first;\n\n\t\t/*\n\t\t * If hash table is partitioned, give each freelist an equal share of\n\t\t * the initial allocation.  Otherwise only freeList[0] is used.\n\t\t */\n\t\tif (IS_PARTITIONED(hashp->hctl))\n\t\t\tfreelist_partitions = NUM_FREELISTS;\n\t\telse\n\t\t\tfreelist_partitions = 1;\n\n\t\tnelem_alloc = nelem / freelist_partitions;\n\t\tif (nelem_alloc <= 0)\n\t\t\tnelem_alloc = 1;\n\n\t\t/*\n\t\t * Make sure we'll allocate all the requested elements; freeList[0]\n\t\t * gets the excess if the request isn't divisible by NUM_FREELISTS.\n\t\t */\n\t\tif (nelem_alloc * freelist_partitions < nelem)\n\t\t\tnelem_alloc_first =\n\t\t\t\tnelem - nelem_alloc * (freelist_partitions - 1);\n\t\telse\n\t\t\tnelem_alloc_first = nelem_alloc;\n\n\t\tfor (i = 0; i < freelist_partitions; i++)\n\t\t{\n\t\t\tint\t\t\ttemp = (i == 0) ? nelem_alloc_first : nelem_alloc;\n\n\t\t\tif (!element_alloc(hashp, temp, i))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t\t errmsg(\"out of memory\")));\n\t\t}\n\t}\n\n\tif (flags & HASH_FIXED_SIZE)\n\t\thashp->isfixed = true;\n\treturn hashp;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NUM_FREELISTS\t\t\t32"
          ],
          "globals_used": [
            "static void *DynaHashAlloc(Size size);",
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static int\tchoose_nelem_alloc(Size entrysize);",
            "static bool init_htab(HTAB *hashp, long nelem);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);",
            "static MemoryContext CurrentDynaHashCxt = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define NUM_FREELISTS\t\t\t32\n\nstatic void *DynaHashAlloc(Size size);\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic int\tchoose_nelem_alloc(Size entrysize);\nstatic bool init_htab(HTAB *hashp, long nelem);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\nstatic MemoryContext CurrentDynaHashCxt = NULL;\n\nHTAB *\nhash_create(const char *tabname, long nelem, HASHCTL *info, int flags)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\n\t/*\n\t * For shared hash tables, we have a local hash header (HTAB struct) that\n\t * we allocate in TopMemoryContext; all else is in shared memory.\n\t *\n\t * For non-shared hash tables, everything including the hash header is in\n\t * a memory context created specially for the hash table --- this makes\n\t * hash_destroy very simple.  The memory context is made a child of either\n\t * a context specified by the caller, or TopMemoryContext if nothing is\n\t * specified.\n\t */\n\tif (flags & HASH_SHARED_MEM)\n\t{\n\t\t/* Set up to allocate the hash header */\n\t\tCurrentDynaHashCxt = TopMemoryContext;\n\t}\n\telse\n\t{\n\t\t/* Create the hash table's private memory context */\n\t\tif (flags & HASH_CONTEXT)\n\t\t\tCurrentDynaHashCxt = info->hcxt;\n\t\telse\n\t\t\tCurrentDynaHashCxt = TopMemoryContext;\n\t\tCurrentDynaHashCxt = AllocSetContextCreate(CurrentDynaHashCxt,\n\t\t\t\t\t\t\t\t\t\t\t\t   \"dynahash\",\n\t\t\t\t\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n\t}\n\n\t/* Initialize the hash header, plus a copy of the table name */\n\thashp = (HTAB *) DynaHashAlloc(sizeof(HTAB) + strlen(tabname) + 1);\n\tMemSet(hashp, 0, sizeof(HTAB));\n\n\thashp->tabname = (char *) (hashp + 1);\n\tstrcpy(hashp->tabname, tabname);\n\n\t/* If we have a private context, label it with hashtable's name */\n\tif (!(flags & HASH_SHARED_MEM))\n\t\tMemoryContextSetIdentifier(CurrentDynaHashCxt, hashp->tabname);\n\n\t/*\n\t * Select the appropriate hash function (see comments at head of file).\n\t */\n\tif (flags & HASH_FUNCTION)\n\t\thashp->hash = info->hash;\n\telse if (flags & HASH_BLOBS)\n\t{\n\t\t/* We can optimize hashing for common key sizes */\n\t\tAssert(flags & HASH_ELEM);\n\t\tif (info->keysize == sizeof(uint32))\n\t\t\thashp->hash = uint32_hash;\n\t\telse\n\t\t\thashp->hash = tag_hash;\n\t}\n\telse\n\t\thashp->hash = string_hash;\t/* default hash function */\n\n\t/*\n\t * If you don't specify a match function, it defaults to string_compare if\n\t * you used string_hash (either explicitly or by default) and to memcmp\n\t * otherwise.\n\t *\n\t * Note: explicitly specifying string_hash is deprecated, because this\n\t * might not work for callers in loadable modules on some platforms due to\n\t * referencing a trampoline instead of the string_hash function proper.\n\t * Just let it default, eh?\n\t */\n\tif (flags & HASH_COMPARE)\n\t\thashp->match = info->match;\n\telse if (hashp->hash == string_hash)\n\t\thashp->match = (HashCompareFunc) string_compare;\n\telse\n\t\thashp->match = memcmp;\n\n\t/*\n\t * Similarly, the key-copying function defaults to strlcpy or memcpy.\n\t */\n\tif (flags & HASH_KEYCOPY)\n\t\thashp->keycopy = info->keycopy;\n\telse if (hashp->hash == string_hash)\n\t\thashp->keycopy = (HashCopyFunc) strlcpy;\n\telse\n\t\thashp->keycopy = memcpy;\n\n\t/* And select the entry allocation function, too. */\n\tif (flags & HASH_ALLOC)\n\t\thashp->alloc = info->alloc;\n\telse\n\t\thashp->alloc = DynaHashAlloc;\n\n\tif (flags & HASH_SHARED_MEM)\n\t{\n\t\t/*\n\t\t * ctl structure and directory are preallocated for shared memory\n\t\t * tables.  Note that HASH_DIRSIZE and HASH_ALLOC had better be set as\n\t\t * well.\n\t\t */\n\t\thashp->hctl = info->hctl;\n\t\thashp->dir = (HASHSEGMENT *) (((char *) info->hctl) + sizeof(HASHHDR));\n\t\thashp->hcxt = NULL;\n\t\thashp->isshared = true;\n\n\t\t/* hash table already exists, we're just attaching to it */\n\t\tif (flags & HASH_ATTACH)\n\t\t{\n\t\t\t/* make local copies of some heavily-used values */\n\t\t\thctl = hashp->hctl;\n\t\t\thashp->keysize = hctl->keysize;\n\t\t\thashp->ssize = hctl->ssize;\n\t\t\thashp->sshift = hctl->sshift;\n\n\t\t\treturn hashp;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* setup hash table defaults */\n\t\thashp->hctl = NULL;\n\t\thashp->dir = NULL;\n\t\thashp->hcxt = CurrentDynaHashCxt;\n\t\thashp->isshared = false;\n\t}\n\n\tif (!hashp->hctl)\n\t{\n\t\thashp->hctl = (HASHHDR *) hashp->alloc(sizeof(HASHHDR));\n\t\tif (!hashp->hctl)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t errmsg(\"out of memory\")));\n\t}\n\n\thashp->frozen = false;\n\n\thdefault(hashp);\n\n\thctl = hashp->hctl;\n\n\tif (flags & HASH_PARTITION)\n\t{\n\t\t/* Doesn't make sense to partition a local hash table */\n\t\tAssert(flags & HASH_SHARED_MEM);\n\n\t\t/*\n\t\t * The number of partitions had better be a power of 2. Also, it must\n\t\t * be less than INT_MAX (see init_htab()), so call the int version of\n\t\t * next_pow2.\n\t\t */\n\t\tAssert(info->num_partitions == next_pow2_int(info->num_partitions));\n\n\t\thctl->num_partitions = info->num_partitions;\n\t}\n\n\tif (flags & HASH_SEGMENT)\n\t{\n\t\thctl->ssize = info->ssize;\n\t\thctl->sshift = my_log2(info->ssize);\n\t\t/* ssize had better be a power of 2 */\n\t\tAssert(hctl->ssize == (1L << hctl->sshift));\n\t}\n\tif (flags & HASH_FFACTOR)\n\t\thctl->ffactor = info->ffactor;\n\n\t/*\n\t * SHM hash tables have fixed directory size passed by the caller.\n\t */\n\tif (flags & HASH_DIRSIZE)\n\t{\n\t\thctl->max_dsize = info->max_dsize;\n\t\thctl->dsize = info->dsize;\n\t}\n\n\t/*\n\t * hash table now allocates space for key and data but you have to say how\n\t * much space to allocate\n\t */\n\tif (flags & HASH_ELEM)\n\t{\n\t\tAssert(info->entrysize >= info->keysize);\n\t\thctl->keysize = info->keysize;\n\t\thctl->entrysize = info->entrysize;\n\t}\n\n\t/* make local copies of heavily-used constant fields */\n\thashp->keysize = hctl->keysize;\n\thashp->ssize = hctl->ssize;\n\thashp->sshift = hctl->sshift;\n\n\t/* Build the hash directory structure */\n\tif (!init_htab(hashp, nelem))\n\t\telog(ERROR, \"failed to initialize hash table \\\"%s\\\"\", hashp->tabname);\n\n\t/*\n\t * For a shared hash table, preallocate the requested number of elements.\n\t * This reduces problems with run-time out-of-shared-memory conditions.\n\t *\n\t * For a non-shared hash table, preallocate the requested number of\n\t * elements if it's less than our chosen nelem_alloc.  This avoids wasting\n\t * space if the caller correctly estimates a small table size.\n\t */\n\tif ((flags & HASH_SHARED_MEM) ||\n\t\tnelem < hctl->nelem_alloc)\n\t{\n\t\tint\t\t\ti,\n\t\t\t\t\tfreelist_partitions,\n\t\t\t\t\tnelem_alloc,\n\t\t\t\t\tnelem_alloc_first;\n\n\t\t/*\n\t\t * If hash table is partitioned, give each freelist an equal share of\n\t\t * the initial allocation.  Otherwise only freeList[0] is used.\n\t\t */\n\t\tif (IS_PARTITIONED(hashp->hctl))\n\t\t\tfreelist_partitions = NUM_FREELISTS;\n\t\telse\n\t\t\tfreelist_partitions = 1;\n\n\t\tnelem_alloc = nelem / freelist_partitions;\n\t\tif (nelem_alloc <= 0)\n\t\t\tnelem_alloc = 1;\n\n\t\t/*\n\t\t * Make sure we'll allocate all the requested elements; freeList[0]\n\t\t * gets the excess if the request isn't divisible by NUM_FREELISTS.\n\t\t */\n\t\tif (nelem_alloc * freelist_partitions < nelem)\n\t\t\tnelem_alloc_first =\n\t\t\t\tnelem - nelem_alloc * (freelist_partitions - 1);\n\t\telse\n\t\t\tnelem_alloc_first = nelem_alloc;\n\n\t\tfor (i = 0; i < freelist_partitions; i++)\n\t\t{\n\t\t\tint\t\t\ttemp = (i == 0) ? nelem_alloc_first : nelem_alloc;\n\n\t\t\tif (!element_alloc(hashp, temp, i))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t\t errmsg(\"out of memory\")));\n\t\t}\n\t}\n\n\tif (flags & HASH_FIXED_SIZE)\n\t\thashp->isfixed = true;\n\treturn hashp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&hash_ctl",
            "0",
            "sizeof(hash_ctl)"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextAlloc",
          "args": [
            "TopTransactionContext",
            "sizeof(ComboCidKeyData) * CCID_ARRAY_SIZE"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1079-1106",
          "snippet": "void *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/combocid.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\n#define CCID_ARRAY_SIZE\t\t\t100\n#define CCID_HASH_SIZE\t\t\t100\n\nstatic HTAB *comboHash = NULL;\nstatic ComboCidKey comboCids = NULL;\nstatic int\tusedComboCids = 0;\nstatic int\tsizeComboCids = 0;\nstatic CommandId GetComboCommandId(CommandId cmin, CommandId cmax);\nstatic CommandId GetRealCmin(CommandId combocid);\nstatic CommandId GetRealCmax(CommandId combocid);\n\nstatic CommandId\nGetComboCommandId(CommandId cmin, CommandId cmax)\n{\n\tCommandId\tcombocid;\n\tComboCidKeyData key;\n\tComboCidEntry entry;\n\tbool\t\tfound;\n\n\t/*\n\t * Create the hash table and array the first time we need to use combo\n\t * cids in the transaction.\n\t */\n\tif (comboHash == NULL)\n\t{\n\t\tHASHCTL\t\thash_ctl;\n\n\t\t/* Make array first; existence of hash table asserts array exists */\n\t\tcomboCids = (ComboCidKeyData *)\n\t\t\tMemoryContextAlloc(TopTransactionContext,\n\t\t\t\t\t\t\t   sizeof(ComboCidKeyData) * CCID_ARRAY_SIZE);\n\t\tsizeComboCids = CCID_ARRAY_SIZE;\n\t\tusedComboCids = 0;\n\n\t\tmemset(&hash_ctl, 0, sizeof(hash_ctl));\n\t\thash_ctl.keysize = sizeof(ComboCidKeyData);\n\t\thash_ctl.entrysize = sizeof(ComboCidEntryData);\n\t\thash_ctl.hcxt = TopTransactionContext;\n\n\t\tcomboHash = hash_create(\"Combo CIDs\",\n\t\t\t\t\t\t\t\tCCID_HASH_SIZE,\n\t\t\t\t\t\t\t\t&hash_ctl,\n\t\t\t\t\t\t\t\tHASH_ELEM | HASH_BLOBS | HASH_CONTEXT);\n\t}\n\n\t/*\n\t * Grow the array if there's not at least one free slot.  We must do this\n\t * before possibly entering a new hashtable entry, else failure to\n\t * repalloc would leave a corrupt hashtable entry behind.\n\t */\n\tif (usedComboCids >= sizeComboCids)\n\t{\n\t\tint\t\t\tnewsize = sizeComboCids * 2;\n\n\t\tcomboCids = (ComboCidKeyData *)\n\t\t\trepalloc(comboCids, sizeof(ComboCidKeyData) * newsize);\n\t\tsizeComboCids = newsize;\n\t}\n\n\t/* Lookup or create a hash entry with the desired cmin/cmax */\n\n\t/* We assume there is no struct padding in ComboCidKeyData! */\n\tkey.cmin = cmin;\n\tkey.cmax = cmax;\n\tentry = (ComboCidEntry) hash_search(comboHash,\n\t\t\t\t\t\t\t\t\t\t(void *) &key,\n\t\t\t\t\t\t\t\t\t\tHASH_ENTER,\n\t\t\t\t\t\t\t\t\t\t&found);\n\n\tif (found)\n\t{\n\t\t/* Reuse an existing combo cid */\n\t\treturn entry->combocid;\n\t}\n\n\t/* We have to create a new combo cid; we already made room in the array */\n\tcombocid = usedComboCids;\n\n\tcomboCids[combocid].cmin = cmin;\n\tcomboCids[combocid].cmax = cmax;\n\tusedComboCids++;\n\n\tentry->combocid = combocid;\n\n\treturn combocid;\n}"
  },
  {
    "function_name": "AtEOXact_ComboCid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/combocid.c",
    "lines": "182-194",
    "snippet": "void\nAtEOXact_ComboCid(void)\n{\n\t/*\n\t * Don't bother to pfree. These are allocated in TopTransactionContext, so\n\t * they're going to go away at the end of transaction anyway.\n\t */\n\tcomboHash = NULL;\n\n\tcomboCids = NULL;\n\tusedComboCids = 0;\n\tsizeComboCids = 0;\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/combocid.h\"",
      "#include \"storage/shmem.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"miscadmin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static HTAB *comboHash = NULL;",
      "static ComboCidKey comboCids = NULL;",
      "static int\tusedComboCids = 0;",
      "static int\tsizeComboCids = 0;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/combocid.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic HTAB *comboHash = NULL;\nstatic ComboCidKey comboCids = NULL;\nstatic int\tusedComboCids = 0;\nstatic int\tsizeComboCids = 0;\n\nvoid\nAtEOXact_ComboCid(void)\n{\n\t/*\n\t * Don't bother to pfree. These are allocated in TopTransactionContext, so\n\t * they're going to go away at the end of transaction anyway.\n\t */\n\tcomboHash = NULL;\n\n\tcomboCids = NULL;\n\tusedComboCids = 0;\n\tsizeComboCids = 0;\n}"
  },
  {
    "function_name": "HeapTupleHeaderAdjustCmax",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/combocid.c",
    "lines": "153-176",
    "snippet": "void\nHeapTupleHeaderAdjustCmax(HeapTupleHeader tup,\n\t\t\t\t\t\t  CommandId *cmax,\n\t\t\t\t\t\t  bool *iscombo)\n{\n\t/*\n\t * If we're marking a tuple deleted that was inserted by (any\n\t * subtransaction of) our transaction, we need to use a combo command id.\n\t * Test for HeapTupleHeaderXminCommitted() first, because it's cheaper\n\t * than a TransactionIdIsCurrentTransactionId call.\n\t */\n\tif (!HeapTupleHeaderXminCommitted(tup) &&\n\t\tTransactionIdIsCurrentTransactionId(HeapTupleHeaderGetRawXmin(tup)))\n\t{\n\t\tCommandId\tcmin = HeapTupleHeaderGetCmin(tup);\n\n\t\t*cmax = GetComboCommandId(cmin, *cmax);\n\t\t*iscombo = true;\n\t}\n\telse\n\t{\n\t\t*iscombo = false;\n\t}\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/combocid.h\"",
      "#include \"storage/shmem.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"miscadmin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static CommandId GetComboCommandId(CommandId cmin, CommandId cmax);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetComboCommandId",
          "args": [
            "cmin",
            "*cmax"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "GetComboCommandId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/combocid.c",
          "lines": "204-278",
          "snippet": "static CommandId\nGetComboCommandId(CommandId cmin, CommandId cmax)\n{\n\tCommandId\tcombocid;\n\tComboCidKeyData key;\n\tComboCidEntry entry;\n\tbool\t\tfound;\n\n\t/*\n\t * Create the hash table and array the first time we need to use combo\n\t * cids in the transaction.\n\t */\n\tif (comboHash == NULL)\n\t{\n\t\tHASHCTL\t\thash_ctl;\n\n\t\t/* Make array first; existence of hash table asserts array exists */\n\t\tcomboCids = (ComboCidKeyData *)\n\t\t\tMemoryContextAlloc(TopTransactionContext,\n\t\t\t\t\t\t\t   sizeof(ComboCidKeyData) * CCID_ARRAY_SIZE);\n\t\tsizeComboCids = CCID_ARRAY_SIZE;\n\t\tusedComboCids = 0;\n\n\t\tmemset(&hash_ctl, 0, sizeof(hash_ctl));\n\t\thash_ctl.keysize = sizeof(ComboCidKeyData);\n\t\thash_ctl.entrysize = sizeof(ComboCidEntryData);\n\t\thash_ctl.hcxt = TopTransactionContext;\n\n\t\tcomboHash = hash_create(\"Combo CIDs\",\n\t\t\t\t\t\t\t\tCCID_HASH_SIZE,\n\t\t\t\t\t\t\t\t&hash_ctl,\n\t\t\t\t\t\t\t\tHASH_ELEM | HASH_BLOBS | HASH_CONTEXT);\n\t}\n\n\t/*\n\t * Grow the array if there's not at least one free slot.  We must do this\n\t * before possibly entering a new hashtable entry, else failure to\n\t * repalloc would leave a corrupt hashtable entry behind.\n\t */\n\tif (usedComboCids >= sizeComboCids)\n\t{\n\t\tint\t\t\tnewsize = sizeComboCids * 2;\n\n\t\tcomboCids = (ComboCidKeyData *)\n\t\t\trepalloc(comboCids, sizeof(ComboCidKeyData) * newsize);\n\t\tsizeComboCids = newsize;\n\t}\n\n\t/* Lookup or create a hash entry with the desired cmin/cmax */\n\n\t/* We assume there is no struct padding in ComboCidKeyData! */\n\tkey.cmin = cmin;\n\tkey.cmax = cmax;\n\tentry = (ComboCidEntry) hash_search(comboHash,\n\t\t\t\t\t\t\t\t\t\t(void *) &key,\n\t\t\t\t\t\t\t\t\t\tHASH_ENTER,\n\t\t\t\t\t\t\t\t\t\t&found);\n\n\tif (found)\n\t{\n\t\t/* Reuse an existing combo cid */\n\t\treturn entry->combocid;\n\t}\n\n\t/* We have to create a new combo cid; we already made room in the array */\n\tcombocid = usedComboCids;\n\n\tcomboCids[combocid].cmin = cmin;\n\tcomboCids[combocid].cmax = cmax;\n\tusedComboCids++;\n\n\tentry->combocid = combocid;\n\n\treturn combocid;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/combocid.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"miscadmin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define CCID_ARRAY_SIZE\t\t\t100",
            "#define CCID_HASH_SIZE\t\t\t100"
          ],
          "globals_used": [
            "static HTAB *comboHash = NULL;",
            "static ComboCidKey comboCids = NULL;",
            "static int\tusedComboCids = 0;",
            "static int\tsizeComboCids = 0;",
            "static CommandId GetComboCommandId(CommandId cmin, CommandId cmax);",
            "static CommandId GetRealCmin(CommandId combocid);",
            "static CommandId GetRealCmax(CommandId combocid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/combocid.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\n#define CCID_ARRAY_SIZE\t\t\t100\n#define CCID_HASH_SIZE\t\t\t100\n\nstatic HTAB *comboHash = NULL;\nstatic ComboCidKey comboCids = NULL;\nstatic int\tusedComboCids = 0;\nstatic int\tsizeComboCids = 0;\nstatic CommandId GetComboCommandId(CommandId cmin, CommandId cmax);\nstatic CommandId GetRealCmin(CommandId combocid);\nstatic CommandId GetRealCmax(CommandId combocid);\n\nstatic CommandId\nGetComboCommandId(CommandId cmin, CommandId cmax)\n{\n\tCommandId\tcombocid;\n\tComboCidKeyData key;\n\tComboCidEntry entry;\n\tbool\t\tfound;\n\n\t/*\n\t * Create the hash table and array the first time we need to use combo\n\t * cids in the transaction.\n\t */\n\tif (comboHash == NULL)\n\t{\n\t\tHASHCTL\t\thash_ctl;\n\n\t\t/* Make array first; existence of hash table asserts array exists */\n\t\tcomboCids = (ComboCidKeyData *)\n\t\t\tMemoryContextAlloc(TopTransactionContext,\n\t\t\t\t\t\t\t   sizeof(ComboCidKeyData) * CCID_ARRAY_SIZE);\n\t\tsizeComboCids = CCID_ARRAY_SIZE;\n\t\tusedComboCids = 0;\n\n\t\tmemset(&hash_ctl, 0, sizeof(hash_ctl));\n\t\thash_ctl.keysize = sizeof(ComboCidKeyData);\n\t\thash_ctl.entrysize = sizeof(ComboCidEntryData);\n\t\thash_ctl.hcxt = TopTransactionContext;\n\n\t\tcomboHash = hash_create(\"Combo CIDs\",\n\t\t\t\t\t\t\t\tCCID_HASH_SIZE,\n\t\t\t\t\t\t\t\t&hash_ctl,\n\t\t\t\t\t\t\t\tHASH_ELEM | HASH_BLOBS | HASH_CONTEXT);\n\t}\n\n\t/*\n\t * Grow the array if there's not at least one free slot.  We must do this\n\t * before possibly entering a new hashtable entry, else failure to\n\t * repalloc would leave a corrupt hashtable entry behind.\n\t */\n\tif (usedComboCids >= sizeComboCids)\n\t{\n\t\tint\t\t\tnewsize = sizeComboCids * 2;\n\n\t\tcomboCids = (ComboCidKeyData *)\n\t\t\trepalloc(comboCids, sizeof(ComboCidKeyData) * newsize);\n\t\tsizeComboCids = newsize;\n\t}\n\n\t/* Lookup or create a hash entry with the desired cmin/cmax */\n\n\t/* We assume there is no struct padding in ComboCidKeyData! */\n\tkey.cmin = cmin;\n\tkey.cmax = cmax;\n\tentry = (ComboCidEntry) hash_search(comboHash,\n\t\t\t\t\t\t\t\t\t\t(void *) &key,\n\t\t\t\t\t\t\t\t\t\tHASH_ENTER,\n\t\t\t\t\t\t\t\t\t\t&found);\n\n\tif (found)\n\t{\n\t\t/* Reuse an existing combo cid */\n\t\treturn entry->combocid;\n\t}\n\n\t/* We have to create a new combo cid; we already made room in the array */\n\tcombocid = usedComboCids;\n\n\tcomboCids[combocid].cmin = cmin;\n\tcomboCids[combocid].cmax = cmax;\n\tusedComboCids++;\n\n\tentry->combocid = combocid;\n\n\treturn combocid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetCmin",
          "args": [
            "tup"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "HeapTupleHeaderGetCmin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/combocid.c",
          "lines": "104-116",
          "snippet": "CommandId\nHeapTupleHeaderGetCmin(HeapTupleHeader tup)\n{\n\tCommandId\tcid = HeapTupleHeaderGetRawCommandId(tup);\n\n\tAssert(!(tup->t_infomask & HEAP_MOVED));\n\tAssert(TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetXmin(tup)));\n\n\tif (tup->t_infomask & HEAP_COMBOCID)\n\t\treturn GetRealCmin(cid);\n\telse\n\t\treturn cid;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/combocid.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"miscadmin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/combocid.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nCommandId\nHeapTupleHeaderGetCmin(HeapTupleHeader tup)\n{\n\tCommandId\tcid = HeapTupleHeaderGetRawCommandId(tup);\n\n\tAssert(!(tup->t_infomask & HEAP_MOVED));\n\tAssert(TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetXmin(tup)));\n\n\tif (tup->t_infomask & HEAP_COMBOCID)\n\t\treturn GetRealCmin(cid);\n\telse\n\t\treturn cid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TransactionIdIsCurrentTransactionId",
          "args": [
            "HeapTupleHeaderGetRawXmin(tup)"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawXmin",
          "args": [
            "tup"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderXminCommitted",
          "args": [
            "tup"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/combocid.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic CommandId GetComboCommandId(CommandId cmin, CommandId cmax);\n\nvoid\nHeapTupleHeaderAdjustCmax(HeapTupleHeader tup,\n\t\t\t\t\t\t  CommandId *cmax,\n\t\t\t\t\t\t  bool *iscombo)\n{\n\t/*\n\t * If we're marking a tuple deleted that was inserted by (any\n\t * subtransaction of) our transaction, we need to use a combo command id.\n\t * Test for HeapTupleHeaderXminCommitted() first, because it's cheaper\n\t * than a TransactionIdIsCurrentTransactionId call.\n\t */\n\tif (!HeapTupleHeaderXminCommitted(tup) &&\n\t\tTransactionIdIsCurrentTransactionId(HeapTupleHeaderGetRawXmin(tup)))\n\t{\n\t\tCommandId\tcmin = HeapTupleHeaderGetCmin(tup);\n\n\t\t*cmax = GetComboCommandId(cmin, *cmax);\n\t\t*iscombo = true;\n\t}\n\telse\n\t{\n\t\t*iscombo = false;\n\t}\n}"
  },
  {
    "function_name": "HeapTupleHeaderGetCmax",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/combocid.c",
    "lines": "118-138",
    "snippet": "CommandId\nHeapTupleHeaderGetCmax(HeapTupleHeader tup)\n{\n\tCommandId\tcid = HeapTupleHeaderGetRawCommandId(tup);\n\n\tAssert(!(tup->t_infomask & HEAP_MOVED));\n\n\t/*\n\t * Because GetUpdateXid() performs memory allocations if xmax is a\n\t * multixact we can't Assert() if we're inside a critical section. This\n\t * weakens the check, but not using GetCmax() inside one would complicate\n\t * things too much.\n\t */\n\tAssert(CritSectionCount > 0 ||\n\t\t   TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetUpdateXid(tup)));\n\n\tif (tup->t_infomask & HEAP_COMBOCID)\n\t\treturn GetRealCmax(cid);\n\telse\n\t\treturn cid;\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/combocid.h\"",
      "#include \"storage/shmem.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"miscadmin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetRealCmax",
          "args": [
            "cid"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "GetRealCmax",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/combocid.c",
          "lines": "287-292",
          "snippet": "static CommandId\nGetRealCmax(CommandId combocid)\n{\n\tAssert(combocid < usedComboCids);\n\treturn comboCids[combocid].cmax;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/combocid.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"miscadmin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ComboCidKey comboCids = NULL;",
            "static int\tusedComboCids = 0;",
            "static CommandId GetComboCommandId(CommandId cmin, CommandId cmax);",
            "static CommandId GetRealCmin(CommandId combocid);",
            "static CommandId GetRealCmax(CommandId combocid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/combocid.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic ComboCidKey comboCids = NULL;\nstatic int\tusedComboCids = 0;\nstatic CommandId GetComboCommandId(CommandId cmin, CommandId cmax);\nstatic CommandId GetRealCmin(CommandId combocid);\nstatic CommandId GetRealCmax(CommandId combocid);\n\nstatic CommandId\nGetRealCmax(CommandId combocid)\n{\n\tAssert(combocid < usedComboCids);\n\treturn comboCids[combocid].cmax;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "CritSectionCount > 0 ||\n\t\t   TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetUpdateXid(tup))"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsCurrentTransactionId",
          "args": [
            "HeapTupleHeaderGetUpdateXid(tup)"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetUpdateXid",
          "args": [
            "tup"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!(tup->t_infomask & HEAP_MOVED)"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawCommandId",
          "args": [
            "tup"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/combocid.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nCommandId\nHeapTupleHeaderGetCmax(HeapTupleHeader tup)\n{\n\tCommandId\tcid = HeapTupleHeaderGetRawCommandId(tup);\n\n\tAssert(!(tup->t_infomask & HEAP_MOVED));\n\n\t/*\n\t * Because GetUpdateXid() performs memory allocations if xmax is a\n\t * multixact we can't Assert() if we're inside a critical section. This\n\t * weakens the check, but not using GetCmax() inside one would complicate\n\t * things too much.\n\t */\n\tAssert(CritSectionCount > 0 ||\n\t\t   TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetUpdateXid(tup)));\n\n\tif (tup->t_infomask & HEAP_COMBOCID)\n\t\treturn GetRealCmax(cid);\n\telse\n\t\treturn cid;\n}"
  },
  {
    "function_name": "HeapTupleHeaderGetCmin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/combocid.c",
    "lines": "104-116",
    "snippet": "CommandId\nHeapTupleHeaderGetCmin(HeapTupleHeader tup)\n{\n\tCommandId\tcid = HeapTupleHeaderGetRawCommandId(tup);\n\n\tAssert(!(tup->t_infomask & HEAP_MOVED));\n\tAssert(TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetXmin(tup)));\n\n\tif (tup->t_infomask & HEAP_COMBOCID)\n\t\treturn GetRealCmin(cid);\n\telse\n\t\treturn cid;\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/combocid.h\"",
      "#include \"storage/shmem.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"miscadmin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetRealCmin",
          "args": [
            "cid"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "GetRealCmin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/combocid.c",
          "lines": "280-285",
          "snippet": "static CommandId\nGetRealCmin(CommandId combocid)\n{\n\tAssert(combocid < usedComboCids);\n\treturn comboCids[combocid].cmin;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/combocid.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"miscadmin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ComboCidKey comboCids = NULL;",
            "static int\tusedComboCids = 0;",
            "static CommandId GetRealCmin(CommandId combocid);",
            "static CommandId GetRealCmax(CommandId combocid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/combocid.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic ComboCidKey comboCids = NULL;\nstatic int\tusedComboCids = 0;\nstatic CommandId GetRealCmin(CommandId combocid);\nstatic CommandId GetRealCmax(CommandId combocid);\n\nstatic CommandId\nGetRealCmin(CommandId combocid)\n{\n\tAssert(combocid < usedComboCids);\n\treturn comboCids[combocid].cmin;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetXmin(tup))"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsCurrentTransactionId",
          "args": [
            "HeapTupleHeaderGetXmin(tup)"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetXmin",
          "args": [
            "tup"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!(tup->t_infomask & HEAP_MOVED)"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawCommandId",
          "args": [
            "tup"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/combocid.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nCommandId\nHeapTupleHeaderGetCmin(HeapTupleHeader tup)\n{\n\tCommandId\tcid = HeapTupleHeaderGetRawCommandId(tup);\n\n\tAssert(!(tup->t_infomask & HEAP_MOVED));\n\tAssert(TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetXmin(tup)));\n\n\tif (tup->t_infomask & HEAP_COMBOCID)\n\t\treturn GetRealCmin(cid);\n\telse\n\t\treturn cid;\n}"
  }
]