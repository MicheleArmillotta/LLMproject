[
  {
    "function_name": "SlabCheck",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/slab.c",
    "lines": "691-785",
    "snippet": "static void\nSlabCheck(MemoryContext context)\n{\n\tint\t\t\ti;\n\tSlabContext *slab = castNode(SlabContext, context);\n\tconst char *name = slab->header.name;\n\tchar\t   *freechunks;\n\n\tAssert(slab);\n\tAssert(slab->chunksPerBlock > 0);\n\n\t/* bitmap of free chunks on a block */\n\tfreechunks = palloc(slab->chunksPerBlock * sizeof(bool));\n\n\t/* walk all the freelists */\n\tfor (i = 0; i <= slab->chunksPerBlock; i++)\n\t{\n\t\tint\t\t\tj,\n\t\t\t\t\tnfree;\n\t\tdlist_iter\titer;\n\n\t\t/* walk all blocks on this freelist */\n\t\tdlist_foreach(iter, &slab->freelist[i])\n\t\t{\n\t\t\tint\t\t\tidx;\n\t\t\tSlabBlock  *block = dlist_container(SlabBlock, node, iter.cur);\n\n\t\t\t/*\n\t\t\t * Make sure the number of free chunks (in the block header)\n\t\t\t * matches position in the freelist.\n\t\t\t */\n\t\t\tif (block->nfree != i)\n\t\t\t\telog(WARNING, \"problem in slab %s: number of free chunks %d in block %p does not match freelist %d\",\n\t\t\t\t\t name, block->nfree, block, i);\n\n\t\t\t/* reset the bitmap of free chunks for this block */\n\t\t\tmemset(freechunks, 0, (slab->chunksPerBlock * sizeof(bool)));\n\t\t\tidx = block->firstFreeChunk;\n\n\t\t\t/*\n\t\t\t * Now walk through the chunks, count the free ones and also\n\t\t\t * perform some additional checks for the used ones. As the chunk\n\t\t\t * freelist is stored within the chunks themselves, we have to\n\t\t\t * walk through the chunks and construct our own bitmap.\n\t\t\t */\n\n\t\t\tnfree = 0;\n\t\t\twhile (idx < slab->chunksPerBlock)\n\t\t\t{\n\t\t\t\tSlabChunk  *chunk;\n\n\t\t\t\t/* count the chunk as free, add it to the bitmap */\n\t\t\t\tnfree++;\n\t\t\t\tfreechunks[idx] = true;\n\n\t\t\t\t/* read index of the next free chunk */\n\t\t\t\tchunk = SlabBlockGetChunk(slab, block, idx);\n\t\t\t\tVALGRIND_MAKE_MEM_DEFINED(SlabChunkGetPointer(chunk), sizeof(int32));\n\t\t\t\tidx = *(int32 *) SlabChunkGetPointer(chunk);\n\t\t\t}\n\n\t\t\tfor (j = 0; j < slab->chunksPerBlock; j++)\n\t\t\t{\n\t\t\t\t/* non-zero bit in the bitmap means chunk the chunk is used */\n\t\t\t\tif (!freechunks[j])\n\t\t\t\t{\n\t\t\t\t\tSlabChunk  *chunk = SlabBlockGetChunk(slab, block, j);\n\n\t\t\t\t\t/* chunks have both block and slab pointers, so check both */\n\t\t\t\t\tif (chunk->block != block)\n\t\t\t\t\t\telog(WARNING, \"problem in slab %s: bogus block link in block %p, chunk %p\",\n\t\t\t\t\t\t\t name, block, chunk);\n\n\t\t\t\t\tif (chunk->slab != slab)\n\t\t\t\t\t\telog(WARNING, \"problem in slab %s: bogus slab link in block %p, chunk %p\",\n\t\t\t\t\t\t\t name, block, chunk);\n\n\t\t\t\t\t/* there might be sentinel (thanks to alignment) */\n\t\t\t\t\tif (slab->chunkSize < (slab->fullChunkSize - sizeof(SlabChunk)))\n\t\t\t\t\t\tif (!sentinel_ok(chunk, slab->chunkSize))\n\t\t\t\t\t\t\telog(WARNING, \"problem in slab %s: detected write past chunk end in block %p, chunk %p\",\n\t\t\t\t\t\t\t\t name, block, chunk);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Make sure we got the expected number of free chunks (as tracked\n\t\t\t * in the block header).\n\t\t\t */\n\t\t\tif (nfree != block->nfree)\n\t\t\t\telog(WARNING, \"problem in slab %s: number of free chunks %d in block %p does not match bitmap %d\",\n\t\t\t\t\t name, block->nfree, block, nfree);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"lib/ilist.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void SlabReset(MemoryContext context);",
      "static void SlabDelete(MemoryContext context);",
      "static bool SlabIsEmpty(MemoryContext context);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "WARNING",
            "\"problem in slab %s: number of free chunks %d in block %p does not match bitmap %d\"",
            "name",
            "block->nfree",
            "block",
            "nfree"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sentinel_ok",
          "args": [
            "chunk",
            "slab->chunkSize"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SlabBlockGetChunk",
          "args": [
            "slab",
            "block",
            "j"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SlabChunkGetPointer",
          "args": [
            "chunk"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALGRIND_MAKE_MEM_DEFINED",
          "args": [
            "SlabChunkGetPointer(chunk)",
            "sizeof(int32)"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SlabChunkGetPointer",
          "args": [
            "chunk"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SlabBlockGetChunk",
          "args": [
            "slab",
            "block",
            "idx"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "freechunks",
            "0",
            "(slab->chunksPerBlock * sizeof(bool))"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlist_container",
          "args": [
            "SlabBlock",
            "node",
            "iter.cur"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlist_foreach",
          "args": [
            "iter",
            "&slab->freelist[i]"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "slab->chunksPerBlock * sizeof(bool)"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "slab->chunksPerBlock > 0"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "slab"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "castNode",
          "args": [
            "SlabContext",
            "context"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lib/ilist.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"postgres.h\"\n\nstatic void SlabReset(MemoryContext context);\nstatic void SlabDelete(MemoryContext context);\nstatic bool SlabIsEmpty(MemoryContext context);\n\nstatic void\nSlabCheck(MemoryContext context)\n{\n\tint\t\t\ti;\n\tSlabContext *slab = castNode(SlabContext, context);\n\tconst char *name = slab->header.name;\n\tchar\t   *freechunks;\n\n\tAssert(slab);\n\tAssert(slab->chunksPerBlock > 0);\n\n\t/* bitmap of free chunks on a block */\n\tfreechunks = palloc(slab->chunksPerBlock * sizeof(bool));\n\n\t/* walk all the freelists */\n\tfor (i = 0; i <= slab->chunksPerBlock; i++)\n\t{\n\t\tint\t\t\tj,\n\t\t\t\t\tnfree;\n\t\tdlist_iter\titer;\n\n\t\t/* walk all blocks on this freelist */\n\t\tdlist_foreach(iter, &slab->freelist[i])\n\t\t{\n\t\t\tint\t\t\tidx;\n\t\t\tSlabBlock  *block = dlist_container(SlabBlock, node, iter.cur);\n\n\t\t\t/*\n\t\t\t * Make sure the number of free chunks (in the block header)\n\t\t\t * matches position in the freelist.\n\t\t\t */\n\t\t\tif (block->nfree != i)\n\t\t\t\telog(WARNING, \"problem in slab %s: number of free chunks %d in block %p does not match freelist %d\",\n\t\t\t\t\t name, block->nfree, block, i);\n\n\t\t\t/* reset the bitmap of free chunks for this block */\n\t\t\tmemset(freechunks, 0, (slab->chunksPerBlock * sizeof(bool)));\n\t\t\tidx = block->firstFreeChunk;\n\n\t\t\t/*\n\t\t\t * Now walk through the chunks, count the free ones and also\n\t\t\t * perform some additional checks for the used ones. As the chunk\n\t\t\t * freelist is stored within the chunks themselves, we have to\n\t\t\t * walk through the chunks and construct our own bitmap.\n\t\t\t */\n\n\t\t\tnfree = 0;\n\t\t\twhile (idx < slab->chunksPerBlock)\n\t\t\t{\n\t\t\t\tSlabChunk  *chunk;\n\n\t\t\t\t/* count the chunk as free, add it to the bitmap */\n\t\t\t\tnfree++;\n\t\t\t\tfreechunks[idx] = true;\n\n\t\t\t\t/* read index of the next free chunk */\n\t\t\t\tchunk = SlabBlockGetChunk(slab, block, idx);\n\t\t\t\tVALGRIND_MAKE_MEM_DEFINED(SlabChunkGetPointer(chunk), sizeof(int32));\n\t\t\t\tidx = *(int32 *) SlabChunkGetPointer(chunk);\n\t\t\t}\n\n\t\t\tfor (j = 0; j < slab->chunksPerBlock; j++)\n\t\t\t{\n\t\t\t\t/* non-zero bit in the bitmap means chunk the chunk is used */\n\t\t\t\tif (!freechunks[j])\n\t\t\t\t{\n\t\t\t\t\tSlabChunk  *chunk = SlabBlockGetChunk(slab, block, j);\n\n\t\t\t\t\t/* chunks have both block and slab pointers, so check both */\n\t\t\t\t\tif (chunk->block != block)\n\t\t\t\t\t\telog(WARNING, \"problem in slab %s: bogus block link in block %p, chunk %p\",\n\t\t\t\t\t\t\t name, block, chunk);\n\n\t\t\t\t\tif (chunk->slab != slab)\n\t\t\t\t\t\telog(WARNING, \"problem in slab %s: bogus slab link in block %p, chunk %p\",\n\t\t\t\t\t\t\t name, block, chunk);\n\n\t\t\t\t\t/* there might be sentinel (thanks to alignment) */\n\t\t\t\t\tif (slab->chunkSize < (slab->fullChunkSize - sizeof(SlabChunk)))\n\t\t\t\t\t\tif (!sentinel_ok(chunk, slab->chunkSize))\n\t\t\t\t\t\t\telog(WARNING, \"problem in slab %s: detected write past chunk end in block %p, chunk %p\",\n\t\t\t\t\t\t\t\t name, block, chunk);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Make sure we got the expected number of free chunks (as tracked\n\t\t\t * in the block header).\n\t\t\t */\n\t\t\tif (nfree != block->nfree)\n\t\t\t\telog(WARNING, \"problem in slab %s: number of free chunks %d in block %p does not match bitmap %d\",\n\t\t\t\t\t name, block->nfree, block, nfree);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "SlabStats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/slab.c",
    "lines": "630-678",
    "snippet": "static void\nSlabStats(MemoryContext context,\n\t\t  MemoryStatsPrintFunc printfunc, void *passthru,\n\t\t  MemoryContextCounters *totals)\n{\n\tSlabContext *slab = castNode(SlabContext, context);\n\tSize\t\tnblocks = 0;\n\tSize\t\tfreechunks = 0;\n\tSize\t\ttotalspace;\n\tSize\t\tfreespace = 0;\n\tint\t\t\ti;\n\n\t/* Include context header in totalspace */\n\ttotalspace = slab->headerSize;\n\n\tfor (i = 0; i <= slab->chunksPerBlock; i++)\n\t{\n\t\tdlist_iter\titer;\n\n\t\tdlist_foreach(iter, &slab->freelist[i])\n\t\t{\n\t\t\tSlabBlock  *block = dlist_container(SlabBlock, node, iter.cur);\n\n\t\t\tnblocks++;\n\t\t\ttotalspace += slab->blockSize;\n\t\t\tfreespace += slab->fullChunkSize * block->nfree;\n\t\t\tfreechunks += block->nfree;\n\t\t}\n\t}\n\n\tif (printfunc)\n\t{\n\t\tchar\t\tstats_string[200];\n\n\t\tsnprintf(stats_string, sizeof(stats_string),\n\t\t\t\t \"%zu total in %zd blocks; %zu free (%zd chunks); %zu used\",\n\t\t\t\t totalspace, nblocks, freespace, freechunks,\n\t\t\t\t totalspace - freespace);\n\t\tprintfunc(context, passthru, stats_string);\n\t}\n\n\tif (totals)\n\t{\n\t\ttotals->nblocks += nblocks;\n\t\ttotals->freechunks += freechunks;\n\t\ttotals->totalspace += totalspace;\n\t\ttotals->freespace += freespace;\n\t}\n}",
    "includes": [
      "#include \"lib/ilist.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void SlabReset(MemoryContext context);",
      "static void SlabDelete(MemoryContext context);",
      "static bool SlabIsEmpty(MemoryContext context);",
      "static void SlabStats(MemoryContext context,\n\t\t  MemoryStatsPrintFunc printfunc, void *passthru,\n\t\t  MemoryContextCounters *totals);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printfunc",
          "args": [
            "context",
            "passthru",
            "stats_string"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "stats_string",
            "sizeof(stats_string)",
            "\"%zu total in %zd blocks; %zu free (%zd chunks); %zu used\"",
            "totalspace",
            "nblocks",
            "freespace",
            "freechunks",
            "totalspace - freespace"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlist_container",
          "args": [
            "SlabBlock",
            "node",
            "iter.cur"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlist_foreach",
          "args": [
            "iter",
            "&slab->freelist[i]"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "castNode",
          "args": [
            "SlabContext",
            "context"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lib/ilist.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"postgres.h\"\n\nstatic void SlabReset(MemoryContext context);\nstatic void SlabDelete(MemoryContext context);\nstatic bool SlabIsEmpty(MemoryContext context);\nstatic void SlabStats(MemoryContext context,\n\t\t  MemoryStatsPrintFunc printfunc, void *passthru,\n\t\t  MemoryContextCounters *totals);\n\nstatic void\nSlabStats(MemoryContext context,\n\t\t  MemoryStatsPrintFunc printfunc, void *passthru,\n\t\t  MemoryContextCounters *totals)\n{\n\tSlabContext *slab = castNode(SlabContext, context);\n\tSize\t\tnblocks = 0;\n\tSize\t\tfreechunks = 0;\n\tSize\t\ttotalspace;\n\tSize\t\tfreespace = 0;\n\tint\t\t\ti;\n\n\t/* Include context header in totalspace */\n\ttotalspace = slab->headerSize;\n\n\tfor (i = 0; i <= slab->chunksPerBlock; i++)\n\t{\n\t\tdlist_iter\titer;\n\n\t\tdlist_foreach(iter, &slab->freelist[i])\n\t\t{\n\t\t\tSlabBlock  *block = dlist_container(SlabBlock, node, iter.cur);\n\n\t\t\tnblocks++;\n\t\t\ttotalspace += slab->blockSize;\n\t\t\tfreespace += slab->fullChunkSize * block->nfree;\n\t\t\tfreechunks += block->nfree;\n\t\t}\n\t}\n\n\tif (printfunc)\n\t{\n\t\tchar\t\tstats_string[200];\n\n\t\tsnprintf(stats_string, sizeof(stats_string),\n\t\t\t\t \"%zu total in %zd blocks; %zu free (%zd chunks); %zu used\",\n\t\t\t\t totalspace, nblocks, freespace, freechunks,\n\t\t\t\t totalspace - freespace);\n\t\tprintfunc(context, passthru, stats_string);\n\t}\n\n\tif (totals)\n\t{\n\t\ttotals->nblocks += nblocks;\n\t\ttotals->freechunks += freechunks;\n\t\ttotals->totalspace += totalspace;\n\t\ttotals->freespace += freespace;\n\t}\n}"
  },
  {
    "function_name": "SlabIsEmpty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/slab.c",
    "lines": "612-620",
    "snippet": "static bool\nSlabIsEmpty(MemoryContext context)\n{\n\tSlabContext *slab = castNode(SlabContext, context);\n\n\tAssert(slab);\n\n\treturn (slab->nblocks == 0);\n}",
    "includes": [
      "#include \"lib/ilist.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void SlabReset(MemoryContext context);",
      "static void SlabDelete(MemoryContext context);",
      "static bool SlabIsEmpty(MemoryContext context);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "slab"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "castNode",
          "args": [
            "SlabContext",
            "context"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lib/ilist.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"postgres.h\"\n\nstatic void SlabReset(MemoryContext context);\nstatic void SlabDelete(MemoryContext context);\nstatic bool SlabIsEmpty(MemoryContext context);\n\nstatic bool\nSlabIsEmpty(MemoryContext context)\n{\n\tSlabContext *slab = castNode(SlabContext, context);\n\n\tAssert(slab);\n\n\treturn (slab->nblocks == 0);\n}"
  },
  {
    "function_name": "SlabGetChunkSpace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/slab.c",
    "lines": "598-606",
    "snippet": "static Size\nSlabGetChunkSpace(MemoryContext context, void *pointer)\n{\n\tSlabContext *slab = castNode(SlabContext, context);\n\n\tAssert(slab);\n\n\treturn slab->fullChunkSize;\n}",
    "includes": [
      "#include \"lib/ilist.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void SlabFree(MemoryContext context, void *pointer);",
      "static void SlabReset(MemoryContext context);",
      "static void SlabDelete(MemoryContext context);",
      "static Size SlabGetChunkSpace(MemoryContext context, void *pointer);",
      "static bool SlabIsEmpty(MemoryContext context);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "slab"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "castNode",
          "args": [
            "SlabContext",
            "context"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lib/ilist.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"postgres.h\"\n\nstatic void SlabFree(MemoryContext context, void *pointer);\nstatic void SlabReset(MemoryContext context);\nstatic void SlabDelete(MemoryContext context);\nstatic Size SlabGetChunkSpace(MemoryContext context, void *pointer);\nstatic bool SlabIsEmpty(MemoryContext context);\n\nstatic Size\nSlabGetChunkSpace(MemoryContext context, void *pointer)\n{\n\tSlabContext *slab = castNode(SlabContext, context);\n\n\tAssert(slab);\n\n\treturn slab->fullChunkSize;\n}"
  },
  {
    "function_name": "SlabRealloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/slab.c",
    "lines": "578-591",
    "snippet": "static void *\nSlabRealloc(MemoryContext context, void *pointer, Size size)\n{\n\tSlabContext *slab = castNode(SlabContext, context);\n\n\tAssert(slab);\n\n\t/* can't do actual realloc with slab, but let's try to be gentle */\n\tif (size == slab->chunkSize)\n\t\treturn pointer;\n\n\telog(ERROR, \"slab allocator does not support realloc()\");\n\treturn NULL;\t\t\t\t/* keep compiler quiet */\n}",
    "includes": [
      "#include \"lib/ilist.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void *SlabAlloc(MemoryContext context, Size size);",
      "static void SlabFree(MemoryContext context, void *pointer);",
      "static void *SlabRealloc(MemoryContext context, void *pointer, Size size);",
      "static void SlabReset(MemoryContext context);",
      "static void SlabDelete(MemoryContext context);",
      "static Size SlabGetChunkSpace(MemoryContext context, void *pointer);",
      "static bool SlabIsEmpty(MemoryContext context);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"slab allocator does not support realloc()\""
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "slab"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "castNode",
          "args": [
            "SlabContext",
            "context"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lib/ilist.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"postgres.h\"\n\nstatic void *SlabAlloc(MemoryContext context, Size size);\nstatic void SlabFree(MemoryContext context, void *pointer);\nstatic void *SlabRealloc(MemoryContext context, void *pointer, Size size);\nstatic void SlabReset(MemoryContext context);\nstatic void SlabDelete(MemoryContext context);\nstatic Size SlabGetChunkSpace(MemoryContext context, void *pointer);\nstatic bool SlabIsEmpty(MemoryContext context);\n\nstatic void *\nSlabRealloc(MemoryContext context, void *pointer, Size size)\n{\n\tSlabContext *slab = castNode(SlabContext, context);\n\n\tAssert(slab);\n\n\t/* can't do actual realloc with slab, but let's try to be gentle */\n\tif (size == slab->chunkSize)\n\t\treturn pointer;\n\n\telog(ERROR, \"slab allocator does not support realloc()\");\n\treturn NULL;\t\t\t\t/* keep compiler quiet */\n}"
  },
  {
    "function_name": "SlabFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/slab.c",
    "lines": "490-563",
    "snippet": "static void\nSlabFree(MemoryContext context, void *pointer)\n{\n\tint\t\t\tidx;\n\tSlabContext *slab = castNode(SlabContext, context);\n\tSlabChunk  *chunk = SlabPointerGetChunk(pointer);\n\tSlabBlock  *block = chunk->block;\n\n\tSlabFreeInfo(slab, chunk);\n\n#ifdef MEMORY_CONTEXT_CHECKING\n\t/* Test for someone scribbling on unused space in chunk */\n\tif (slab->chunkSize < (slab->fullChunkSize - sizeof(SlabChunk)))\n\t\tif (!sentinel_ok(pointer, slab->chunkSize))\n\t\t\telog(WARNING, \"detected write past chunk end in %s %p\",\n\t\t\t\t slab->header.name, chunk);\n#endif\n\n\t/* compute index of the chunk with respect to block start */\n\tidx = SlabChunkIndex(slab, block, chunk);\n\n\t/* add chunk to freelist, and update block nfree count */\n\t*(int32 *) pointer = block->firstFreeChunk;\n\tblock->firstFreeChunk = idx;\n\tblock->nfree++;\n\n\tAssert(block->nfree > 0);\n\tAssert(block->nfree <= slab->chunksPerBlock);\n\n#ifdef CLOBBER_FREED_MEMORY\n\t/* XXX don't wipe the int32 index, used for block-level freelist */\n\twipe_mem((char *) pointer + sizeof(int32),\n\t\t\t slab->chunkSize - sizeof(int32));\n#endif\n\n\t/* remove the block from a freelist */\n\tdlist_delete(&block->node);\n\n\t/*\n\t * See if we need to update the minFreeChunks field for the slab - we only\n\t * need to do that if there the block had that number of free chunks\n\t * before we freed one. In that case, we check if there still are blocks\n\t * in the original freelist and we either keep the current value (if there\n\t * still are blocks) or increment it by one (the new block is still the\n\t * one with minimum free chunks).\n\t *\n\t * The one exception is when the block will get completely free - in that\n\t * case we will free it, se we can't use it for minFreeChunks. It however\n\t * means there are no more blocks with free chunks.\n\t */\n\tif (slab->minFreeChunks == (block->nfree - 1))\n\t{\n\t\t/* Have we removed the last chunk from the freelist? */\n\t\tif (dlist_is_empty(&slab->freelist[slab->minFreeChunks]))\n\t\t{\n\t\t\t/* but if we made the block entirely free, we'll free it */\n\t\t\tif (block->nfree == slab->chunksPerBlock)\n\t\t\t\tslab->minFreeChunks = 0;\n\t\t\telse\n\t\t\t\tslab->minFreeChunks++;\n\t\t}\n\t}\n\n\t/* If the block is now completely empty, free it. */\n\tif (block->nfree == slab->chunksPerBlock)\n\t{\n\t\tfree(block);\n\t\tslab->nblocks--;\n\t}\n\telse\n\t\tdlist_push_head(&slab->freelist[block->nfree], &block->node);\n\n\tAssert(slab->nblocks >= 0);\n}",
    "includes": [
      "#include \"lib/ilist.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void SlabFree(MemoryContext context, void *pointer);",
      "static void SlabReset(MemoryContext context);",
      "static void SlabDelete(MemoryContext context);",
      "static Size SlabGetChunkSpace(MemoryContext context, void *pointer);",
      "static bool SlabIsEmpty(MemoryContext context);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "slab->nblocks >= 0"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlist_push_head",
          "args": [
            "&slab->freelist[block->nfree]",
            "&block->node"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "block"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlist_is_empty",
          "args": [
            "&slab->freelist[slab->minFreeChunks]"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlist_delete",
          "args": [
            "&block->node"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wipe_mem",
          "args": [
            "(char *) pointer + sizeof(int32)",
            "slab->chunkSize - sizeof(int32)"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "block->nfree <= slab->chunksPerBlock"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "block->nfree > 0"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SlabChunkIndex",
          "args": [
            "slab",
            "block",
            "chunk"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "WARNING",
            "\"detected write past chunk end in %s %p\"",
            "slab->header.name",
            "chunk"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sentinel_ok",
          "args": [
            "pointer",
            "slab->chunkSize"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SlabFreeInfo",
          "args": [
            "slab",
            "chunk"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SlabPointerGetChunk",
          "args": [
            "pointer"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "castNode",
          "args": [
            "SlabContext",
            "context"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lib/ilist.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"postgres.h\"\n\nstatic void SlabFree(MemoryContext context, void *pointer);\nstatic void SlabReset(MemoryContext context);\nstatic void SlabDelete(MemoryContext context);\nstatic Size SlabGetChunkSpace(MemoryContext context, void *pointer);\nstatic bool SlabIsEmpty(MemoryContext context);\n\nstatic void\nSlabFree(MemoryContext context, void *pointer)\n{\n\tint\t\t\tidx;\n\tSlabContext *slab = castNode(SlabContext, context);\n\tSlabChunk  *chunk = SlabPointerGetChunk(pointer);\n\tSlabBlock  *block = chunk->block;\n\n\tSlabFreeInfo(slab, chunk);\n\n#ifdef MEMORY_CONTEXT_CHECKING\n\t/* Test for someone scribbling on unused space in chunk */\n\tif (slab->chunkSize < (slab->fullChunkSize - sizeof(SlabChunk)))\n\t\tif (!sentinel_ok(pointer, slab->chunkSize))\n\t\t\telog(WARNING, \"detected write past chunk end in %s %p\",\n\t\t\t\t slab->header.name, chunk);\n#endif\n\n\t/* compute index of the chunk with respect to block start */\n\tidx = SlabChunkIndex(slab, block, chunk);\n\n\t/* add chunk to freelist, and update block nfree count */\n\t*(int32 *) pointer = block->firstFreeChunk;\n\tblock->firstFreeChunk = idx;\n\tblock->nfree++;\n\n\tAssert(block->nfree > 0);\n\tAssert(block->nfree <= slab->chunksPerBlock);\n\n#ifdef CLOBBER_FREED_MEMORY\n\t/* XXX don't wipe the int32 index, used for block-level freelist */\n\twipe_mem((char *) pointer + sizeof(int32),\n\t\t\t slab->chunkSize - sizeof(int32));\n#endif\n\n\t/* remove the block from a freelist */\n\tdlist_delete(&block->node);\n\n\t/*\n\t * See if we need to update the minFreeChunks field for the slab - we only\n\t * need to do that if there the block had that number of free chunks\n\t * before we freed one. In that case, we check if there still are blocks\n\t * in the original freelist and we either keep the current value (if there\n\t * still are blocks) or increment it by one (the new block is still the\n\t * one with minimum free chunks).\n\t *\n\t * The one exception is when the block will get completely free - in that\n\t * case we will free it, se we can't use it for minFreeChunks. It however\n\t * means there are no more blocks with free chunks.\n\t */\n\tif (slab->minFreeChunks == (block->nfree - 1))\n\t{\n\t\t/* Have we removed the last chunk from the freelist? */\n\t\tif (dlist_is_empty(&slab->freelist[slab->minFreeChunks]))\n\t\t{\n\t\t\t/* but if we made the block entirely free, we'll free it */\n\t\t\tif (block->nfree == slab->chunksPerBlock)\n\t\t\t\tslab->minFreeChunks = 0;\n\t\t\telse\n\t\t\t\tslab->minFreeChunks++;\n\t\t}\n\t}\n\n\t/* If the block is now completely empty, free it. */\n\tif (block->nfree == slab->chunksPerBlock)\n\t{\n\t\tfree(block);\n\t\tslab->nblocks--;\n\t}\n\telse\n\t\tdlist_push_head(&slab->freelist[block->nfree], &block->node);\n\n\tAssert(slab->nblocks >= 0);\n}"
  },
  {
    "function_name": "SlabAlloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/slab.c",
    "lines": "334-484",
    "snippet": "static void *\nSlabAlloc(MemoryContext context, Size size)\n{\n\tSlabContext *slab = castNode(SlabContext, context);\n\tSlabBlock  *block;\n\tSlabChunk  *chunk;\n\tint\t\t\tidx;\n\n\tAssert(slab);\n\n\tAssert((slab->minFreeChunks >= 0) &&\n\t\t   (slab->minFreeChunks < slab->chunksPerBlock));\n\n\t/* make sure we only allow correct request size */\n\tif (size != slab->chunkSize)\n\t\telog(ERROR, \"unexpected alloc chunk size %zu (expected %zu)\",\n\t\t\t size, slab->chunkSize);\n\n\t/*\n\t * If there are no free chunks in any existing block, create a new block\n\t * and put it to the last freelist bucket.\n\t *\n\t * slab->minFreeChunks == 0 means there are no blocks with free chunks,\n\t * thanks to how minFreeChunks is updated at the end of SlabAlloc().\n\t */\n\tif (slab->minFreeChunks == 0)\n\t{\n\t\tblock = (SlabBlock *) malloc(slab->blockSize);\n\n\t\tif (block == NULL)\n\t\t\treturn NULL;\n\n\t\tblock->nfree = slab->chunksPerBlock;\n\t\tblock->firstFreeChunk = 0;\n\n\t\t/*\n\t\t * Put all the chunks on a freelist. Walk the chunks and point each\n\t\t * one to the next one.\n\t\t */\n\t\tfor (idx = 0; idx < slab->chunksPerBlock; idx++)\n\t\t{\n\t\t\tchunk = SlabBlockGetChunk(slab, block, idx);\n\t\t\t*(int32 *) SlabChunkGetPointer(chunk) = (idx + 1);\n\t\t}\n\n\t\t/*\n\t\t * And add it to the last freelist with all chunks empty.\n\t\t *\n\t\t * We know there are no blocks in the freelist, otherwise we wouldn't\n\t\t * need a new block.\n\t\t */\n\t\tAssert(dlist_is_empty(&slab->freelist[slab->chunksPerBlock]));\n\n\t\tdlist_push_head(&slab->freelist[slab->chunksPerBlock], &block->node);\n\n\t\tslab->minFreeChunks = slab->chunksPerBlock;\n\t\tslab->nblocks += 1;\n\t}\n\n\t/* grab the block from the freelist (even the new block is there) */\n\tblock = dlist_head_element(SlabBlock, node,\n\t\t\t\t\t\t\t   &slab->freelist[slab->minFreeChunks]);\n\n\t/* make sure we actually got a valid block, with matching nfree */\n\tAssert(block != NULL);\n\tAssert(slab->minFreeChunks == block->nfree);\n\tAssert(block->nfree > 0);\n\n\t/* we know index of the first free chunk in the block */\n\tidx = block->firstFreeChunk;\n\n\t/* make sure the chunk index is valid, and that it's marked as empty */\n\tAssert((idx >= 0) && (idx < slab->chunksPerBlock));\n\n\t/* compute the chunk location block start (after the block header) */\n\tchunk = SlabBlockGetChunk(slab, block, idx);\n\n\t/*\n\t * Update the block nfree count, and also the minFreeChunks as we've\n\t * decreased nfree for a block with the minimum number of free chunks\n\t * (because that's how we chose the block).\n\t */\n\tblock->nfree--;\n\tslab->minFreeChunks = block->nfree;\n\n\t/*\n\t * Remove the chunk from the freelist head. The index of the next free\n\t * chunk is stored in the chunk itself.\n\t */\n\tVALGRIND_MAKE_MEM_DEFINED(SlabChunkGetPointer(chunk), sizeof(int32));\n\tblock->firstFreeChunk = *(int32 *) SlabChunkGetPointer(chunk);\n\n\tAssert(block->firstFreeChunk >= 0);\n\tAssert(block->firstFreeChunk <= slab->chunksPerBlock);\n\n\tAssert((block->nfree != 0 &&\n\t\t\tblock->firstFreeChunk < slab->chunksPerBlock) ||\n\t\t   (block->nfree == 0 &&\n\t\t\tblock->firstFreeChunk == slab->chunksPerBlock));\n\n\t/* move the whole block to the right place in the freelist */\n\tdlist_delete(&block->node);\n\tdlist_push_head(&slab->freelist[block->nfree], &block->node);\n\n\t/*\n\t * And finally update minFreeChunks, i.e. the index to the block with the\n\t * lowest number of free chunks. We only need to do that when the block\n\t * got full (otherwise we know the current block is the right one). We'll\n\t * simply walk the freelist until we find a non-empty entry.\n\t */\n\tif (slab->minFreeChunks == 0)\n\t{\n\t\tfor (idx = 1; idx <= slab->chunksPerBlock; idx++)\n\t\t{\n\t\t\tif (dlist_is_empty(&slab->freelist[idx]))\n\t\t\t\tcontinue;\n\n\t\t\t/* found a non-empty freelist */\n\t\t\tslab->minFreeChunks = idx;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (slab->minFreeChunks == slab->chunksPerBlock)\n\t\tslab->minFreeChunks = 0;\n\n\t/* Prepare to initialize the chunk header. */\n\tVALGRIND_MAKE_MEM_UNDEFINED(chunk, sizeof(SlabChunk));\n\n\tchunk->block = block;\n\tchunk->slab = slab;\n\n#ifdef MEMORY_CONTEXT_CHECKING\n\t/* slab mark to catch clobber of \"unused\" space */\n\tif (slab->chunkSize < (slab->fullChunkSize - sizeof(SlabChunk)))\n\t{\n\t\tset_sentinel(SlabChunkGetPointer(chunk), size);\n\t\tVALGRIND_MAKE_MEM_NOACCESS(((char *) chunk) +\n\t\t\t\t\t\t\t\t   sizeof(SlabChunk) + slab->chunkSize,\n\t\t\t\t\t\t\t\t   slab->fullChunkSize -\n\t\t\t\t\t\t\t\t   (slab->chunkSize + sizeof(SlabChunk)));\n\t}\n#endif\n#ifdef RANDOMIZE_ALLOCATED_MEMORY\n\t/* fill the allocated space with junk */\n\trandomize_mem((char *) SlabChunkGetPointer(chunk), size);\n#endif\n\n\tSlabAllocInfo(slab, chunk);\n\treturn SlabChunkGetPointer(chunk);\n}",
    "includes": [
      "#include \"lib/ilist.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void *SlabAlloc(MemoryContext context, Size size);",
      "static void *SlabRealloc(MemoryContext context, void *pointer, Size size);",
      "static void SlabReset(MemoryContext context);",
      "static void SlabDelete(MemoryContext context);",
      "static bool SlabIsEmpty(MemoryContext context);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SlabChunkGetPointer",
          "args": [
            "chunk"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SlabAllocInfo",
          "args": [
            "slab",
            "chunk"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "randomize_mem",
          "args": [
            "(char *) SlabChunkGetPointer(chunk)",
            "size"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "randomize_mem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/memdebug.c",
          "lines": "74-91",
          "snippet": "void\nrandomize_mem(char *ptr, size_t size)\n{\n\tstatic int\tsave_ctr = 1;\n\tsize_t\t\tremaining = size;\n\tint\t\t\tctr;\n\n\tctr = save_ctr;\n\tVALGRIND_MAKE_MEM_UNDEFINED(ptr, size);\n\twhile (remaining-- > 0)\n\t{\n\t\t*ptr++ = ctr;\n\t\tif (++ctr > 251)\n\t\t\tctr = 1;\n\t}\n\tVALGRIND_MAKE_MEM_UNDEFINED(ptr - size, size);\n\tsave_ctr = ctr;\n}",
          "includes": [
            "#include \"utils/memdebug.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memdebug.h\"\n#include \"postgres.h\"\n\nvoid\nrandomize_mem(char *ptr, size_t size)\n{\n\tstatic int\tsave_ctr = 1;\n\tsize_t\t\tremaining = size;\n\tint\t\t\tctr;\n\n\tctr = save_ctr;\n\tVALGRIND_MAKE_MEM_UNDEFINED(ptr, size);\n\twhile (remaining-- > 0)\n\t{\n\t\t*ptr++ = ctr;\n\t\tif (++ctr > 251)\n\t\t\tctr = 1;\n\t}\n\tVALGRIND_MAKE_MEM_UNDEFINED(ptr - size, size);\n\tsave_ctr = ctr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SlabChunkGetPointer",
          "args": [
            "chunk"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALGRIND_MAKE_MEM_NOACCESS",
          "args": [
            "((char *) chunk) +\n\t\t\t\t\t\t\t\t   sizeof(SlabChunk) + slab->chunkSize",
            "slab->fullChunkSize -\n\t\t\t\t\t\t\t\t   (slab->chunkSize + sizeof(SlabChunk))"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_sentinel",
          "args": [
            "SlabChunkGetPointer(chunk)",
            "size"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SlabChunkGetPointer",
          "args": [
            "chunk"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALGRIND_MAKE_MEM_UNDEFINED",
          "args": [
            "chunk",
            "sizeof(SlabChunk)"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlist_is_empty",
          "args": [
            "&slab->freelist[idx]"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlist_push_head",
          "args": [
            "&slab->freelist[block->nfree]",
            "&block->node"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlist_delete",
          "args": [
            "&block->node"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "(block->nfree != 0 &&\n\t\t\tblock->firstFreeChunk < slab->chunksPerBlock) ||\n\t\t   (block->nfree == 0 &&\n\t\t\tblock->firstFreeChunk == slab->chunksPerBlock)"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "block->firstFreeChunk <= slab->chunksPerBlock"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "block->firstFreeChunk >= 0"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SlabChunkGetPointer",
          "args": [
            "chunk"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALGRIND_MAKE_MEM_DEFINED",
          "args": [
            "SlabChunkGetPointer(chunk)",
            "sizeof(int32)"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SlabChunkGetPointer",
          "args": [
            "chunk"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SlabBlockGetChunk",
          "args": [
            "slab",
            "block",
            "idx"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "(idx >= 0) && (idx < slab->chunksPerBlock)"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "block->nfree > 0"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "slab->minFreeChunks == block->nfree"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "block != NULL"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlist_head_element",
          "args": [
            "SlabBlock",
            "node",
            "&slab->freelist[slab->minFreeChunks]"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlist_push_head",
          "args": [
            "&slab->freelist[slab->chunksPerBlock]",
            "&block->node"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "dlist_is_empty(&slab->freelist[slab->chunksPerBlock])"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlist_is_empty",
          "args": [
            "&slab->freelist[slab->chunksPerBlock]"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SlabChunkGetPointer",
          "args": [
            "chunk"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SlabBlockGetChunk",
          "args": [
            "slab",
            "block",
            "idx"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "slab->blockSize"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unexpected alloc chunk size %zu (expected %zu)\"",
            "size",
            "slab->chunkSize"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "(slab->minFreeChunks >= 0) &&\n\t\t   (slab->minFreeChunks < slab->chunksPerBlock)"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "slab"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "castNode",
          "args": [
            "SlabContext",
            "context"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lib/ilist.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"postgres.h\"\n\nstatic void *SlabAlloc(MemoryContext context, Size size);\nstatic void *SlabRealloc(MemoryContext context, void *pointer, Size size);\nstatic void SlabReset(MemoryContext context);\nstatic void SlabDelete(MemoryContext context);\nstatic bool SlabIsEmpty(MemoryContext context);\n\nstatic void *\nSlabAlloc(MemoryContext context, Size size)\n{\n\tSlabContext *slab = castNode(SlabContext, context);\n\tSlabBlock  *block;\n\tSlabChunk  *chunk;\n\tint\t\t\tidx;\n\n\tAssert(slab);\n\n\tAssert((slab->minFreeChunks >= 0) &&\n\t\t   (slab->minFreeChunks < slab->chunksPerBlock));\n\n\t/* make sure we only allow correct request size */\n\tif (size != slab->chunkSize)\n\t\telog(ERROR, \"unexpected alloc chunk size %zu (expected %zu)\",\n\t\t\t size, slab->chunkSize);\n\n\t/*\n\t * If there are no free chunks in any existing block, create a new block\n\t * and put it to the last freelist bucket.\n\t *\n\t * slab->minFreeChunks == 0 means there are no blocks with free chunks,\n\t * thanks to how minFreeChunks is updated at the end of SlabAlloc().\n\t */\n\tif (slab->minFreeChunks == 0)\n\t{\n\t\tblock = (SlabBlock *) malloc(slab->blockSize);\n\n\t\tif (block == NULL)\n\t\t\treturn NULL;\n\n\t\tblock->nfree = slab->chunksPerBlock;\n\t\tblock->firstFreeChunk = 0;\n\n\t\t/*\n\t\t * Put all the chunks on a freelist. Walk the chunks and point each\n\t\t * one to the next one.\n\t\t */\n\t\tfor (idx = 0; idx < slab->chunksPerBlock; idx++)\n\t\t{\n\t\t\tchunk = SlabBlockGetChunk(slab, block, idx);\n\t\t\t*(int32 *) SlabChunkGetPointer(chunk) = (idx + 1);\n\t\t}\n\n\t\t/*\n\t\t * And add it to the last freelist with all chunks empty.\n\t\t *\n\t\t * We know there are no blocks in the freelist, otherwise we wouldn't\n\t\t * need a new block.\n\t\t */\n\t\tAssert(dlist_is_empty(&slab->freelist[slab->chunksPerBlock]));\n\n\t\tdlist_push_head(&slab->freelist[slab->chunksPerBlock], &block->node);\n\n\t\tslab->minFreeChunks = slab->chunksPerBlock;\n\t\tslab->nblocks += 1;\n\t}\n\n\t/* grab the block from the freelist (even the new block is there) */\n\tblock = dlist_head_element(SlabBlock, node,\n\t\t\t\t\t\t\t   &slab->freelist[slab->minFreeChunks]);\n\n\t/* make sure we actually got a valid block, with matching nfree */\n\tAssert(block != NULL);\n\tAssert(slab->minFreeChunks == block->nfree);\n\tAssert(block->nfree > 0);\n\n\t/* we know index of the first free chunk in the block */\n\tidx = block->firstFreeChunk;\n\n\t/* make sure the chunk index is valid, and that it's marked as empty */\n\tAssert((idx >= 0) && (idx < slab->chunksPerBlock));\n\n\t/* compute the chunk location block start (after the block header) */\n\tchunk = SlabBlockGetChunk(slab, block, idx);\n\n\t/*\n\t * Update the block nfree count, and also the minFreeChunks as we've\n\t * decreased nfree for a block with the minimum number of free chunks\n\t * (because that's how we chose the block).\n\t */\n\tblock->nfree--;\n\tslab->minFreeChunks = block->nfree;\n\n\t/*\n\t * Remove the chunk from the freelist head. The index of the next free\n\t * chunk is stored in the chunk itself.\n\t */\n\tVALGRIND_MAKE_MEM_DEFINED(SlabChunkGetPointer(chunk), sizeof(int32));\n\tblock->firstFreeChunk = *(int32 *) SlabChunkGetPointer(chunk);\n\n\tAssert(block->firstFreeChunk >= 0);\n\tAssert(block->firstFreeChunk <= slab->chunksPerBlock);\n\n\tAssert((block->nfree != 0 &&\n\t\t\tblock->firstFreeChunk < slab->chunksPerBlock) ||\n\t\t   (block->nfree == 0 &&\n\t\t\tblock->firstFreeChunk == slab->chunksPerBlock));\n\n\t/* move the whole block to the right place in the freelist */\n\tdlist_delete(&block->node);\n\tdlist_push_head(&slab->freelist[block->nfree], &block->node);\n\n\t/*\n\t * And finally update minFreeChunks, i.e. the index to the block with the\n\t * lowest number of free chunks. We only need to do that when the block\n\t * got full (otherwise we know the current block is the right one). We'll\n\t * simply walk the freelist until we find a non-empty entry.\n\t */\n\tif (slab->minFreeChunks == 0)\n\t{\n\t\tfor (idx = 1; idx <= slab->chunksPerBlock; idx++)\n\t\t{\n\t\t\tif (dlist_is_empty(&slab->freelist[idx]))\n\t\t\t\tcontinue;\n\n\t\t\t/* found a non-empty freelist */\n\t\t\tslab->minFreeChunks = idx;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (slab->minFreeChunks == slab->chunksPerBlock)\n\t\tslab->minFreeChunks = 0;\n\n\t/* Prepare to initialize the chunk header. */\n\tVALGRIND_MAKE_MEM_UNDEFINED(chunk, sizeof(SlabChunk));\n\n\tchunk->block = block;\n\tchunk->slab = slab;\n\n#ifdef MEMORY_CONTEXT_CHECKING\n\t/* slab mark to catch clobber of \"unused\" space */\n\tif (slab->chunkSize < (slab->fullChunkSize - sizeof(SlabChunk)))\n\t{\n\t\tset_sentinel(SlabChunkGetPointer(chunk), size);\n\t\tVALGRIND_MAKE_MEM_NOACCESS(((char *) chunk) +\n\t\t\t\t\t\t\t\t   sizeof(SlabChunk) + slab->chunkSize,\n\t\t\t\t\t\t\t\t   slab->fullChunkSize -\n\t\t\t\t\t\t\t\t   (slab->chunkSize + sizeof(SlabChunk)));\n\t}\n#endif\n#ifdef RANDOMIZE_ALLOCATED_MEMORY\n\t/* fill the allocated space with junk */\n\trandomize_mem((char *) SlabChunkGetPointer(chunk), size);\n#endif\n\n\tSlabAllocInfo(slab, chunk);\n\treturn SlabChunkGetPointer(chunk);\n}"
  },
  {
    "function_name": "SlabDelete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/slab.c",
    "lines": "320-327",
    "snippet": "static void\nSlabDelete(MemoryContext context)\n{\n\t/* Reset to release all the SlabBlocks */\n\tSlabReset(context);\n\t/* And free the context header */\n\tfree(context);\n}",
    "includes": [
      "#include \"lib/ilist.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void SlabReset(MemoryContext context);",
      "static void SlabDelete(MemoryContext context);",
      "static bool SlabIsEmpty(MemoryContext context);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "context"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SlabReset",
          "args": [
            "context"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "SlabReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/slab.c",
          "lines": "279-314",
          "snippet": "static void\nSlabReset(MemoryContext context)\n{\n\tint\t\t\ti;\n\tSlabContext *slab = castNode(SlabContext, context);\n\n\tAssert(slab);\n\n#ifdef MEMORY_CONTEXT_CHECKING\n\t/* Check for corruption and leaks before freeing */\n\tSlabCheck(context);\n#endif\n\n\t/* walk over freelists and free the blocks */\n\tfor (i = 0; i <= slab->chunksPerBlock; i++)\n\t{\n\t\tdlist_mutable_iter miter;\n\n\t\tdlist_foreach_modify(miter, &slab->freelist[i])\n\t\t{\n\t\t\tSlabBlock  *block = dlist_container(SlabBlock, node, miter.cur);\n\n\t\t\tdlist_delete(miter.cur);\n\n#ifdef CLOBBER_FREED_MEMORY\n\t\t\twipe_mem(block, slab->blockSize);\n#endif\n\t\t\tfree(block);\n\t\t\tslab->nblocks--;\n\t\t}\n\t}\n\n\tslab->minFreeChunks = 0;\n\n\tAssert(slab->nblocks == 0);\n}",
          "includes": [
            "#include \"lib/ilist.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void SlabReset(MemoryContext context);",
            "static void SlabDelete(MemoryContext context);",
            "static bool SlabIsEmpty(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lib/ilist.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"postgres.h\"\n\nstatic void SlabReset(MemoryContext context);\nstatic void SlabDelete(MemoryContext context);\nstatic bool SlabIsEmpty(MemoryContext context);\n\nstatic void\nSlabReset(MemoryContext context)\n{\n\tint\t\t\ti;\n\tSlabContext *slab = castNode(SlabContext, context);\n\n\tAssert(slab);\n\n#ifdef MEMORY_CONTEXT_CHECKING\n\t/* Check for corruption and leaks before freeing */\n\tSlabCheck(context);\n#endif\n\n\t/* walk over freelists and free the blocks */\n\tfor (i = 0; i <= slab->chunksPerBlock; i++)\n\t{\n\t\tdlist_mutable_iter miter;\n\n\t\tdlist_foreach_modify(miter, &slab->freelist[i])\n\t\t{\n\t\t\tSlabBlock  *block = dlist_container(SlabBlock, node, miter.cur);\n\n\t\t\tdlist_delete(miter.cur);\n\n#ifdef CLOBBER_FREED_MEMORY\n\t\t\twipe_mem(block, slab->blockSize);\n#endif\n\t\t\tfree(block);\n\t\t\tslab->nblocks--;\n\t\t}\n\t}\n\n\tslab->minFreeChunks = 0;\n\n\tAssert(slab->nblocks == 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lib/ilist.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"postgres.h\"\n\nstatic void SlabReset(MemoryContext context);\nstatic void SlabDelete(MemoryContext context);\nstatic bool SlabIsEmpty(MemoryContext context);\n\nstatic void\nSlabDelete(MemoryContext context)\n{\n\t/* Reset to release all the SlabBlocks */\n\tSlabReset(context);\n\t/* And free the context header */\n\tfree(context);\n}"
  },
  {
    "function_name": "SlabReset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/slab.c",
    "lines": "279-314",
    "snippet": "static void\nSlabReset(MemoryContext context)\n{\n\tint\t\t\ti;\n\tSlabContext *slab = castNode(SlabContext, context);\n\n\tAssert(slab);\n\n#ifdef MEMORY_CONTEXT_CHECKING\n\t/* Check for corruption and leaks before freeing */\n\tSlabCheck(context);\n#endif\n\n\t/* walk over freelists and free the blocks */\n\tfor (i = 0; i <= slab->chunksPerBlock; i++)\n\t{\n\t\tdlist_mutable_iter miter;\n\n\t\tdlist_foreach_modify(miter, &slab->freelist[i])\n\t\t{\n\t\t\tSlabBlock  *block = dlist_container(SlabBlock, node, miter.cur);\n\n\t\t\tdlist_delete(miter.cur);\n\n#ifdef CLOBBER_FREED_MEMORY\n\t\t\twipe_mem(block, slab->blockSize);\n#endif\n\t\t\tfree(block);\n\t\t\tslab->nblocks--;\n\t\t}\n\t}\n\n\tslab->minFreeChunks = 0;\n\n\tAssert(slab->nblocks == 0);\n}",
    "includes": [
      "#include \"lib/ilist.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void SlabReset(MemoryContext context);",
      "static void SlabDelete(MemoryContext context);",
      "static bool SlabIsEmpty(MemoryContext context);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "slab->nblocks == 0"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "block"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wipe_mem",
          "args": [
            "block",
            "slab->blockSize"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlist_delete",
          "args": [
            "miter.cur"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlist_container",
          "args": [
            "SlabBlock",
            "node",
            "miter.cur"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlist_foreach_modify",
          "args": [
            "miter",
            "&slab->freelist[i]"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SlabCheck",
          "args": [
            "context"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "SlabCheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/slab.c",
          "lines": "691-785",
          "snippet": "static void\nSlabCheck(MemoryContext context)\n{\n\tint\t\t\ti;\n\tSlabContext *slab = castNode(SlabContext, context);\n\tconst char *name = slab->header.name;\n\tchar\t   *freechunks;\n\n\tAssert(slab);\n\tAssert(slab->chunksPerBlock > 0);\n\n\t/* bitmap of free chunks on a block */\n\tfreechunks = palloc(slab->chunksPerBlock * sizeof(bool));\n\n\t/* walk all the freelists */\n\tfor (i = 0; i <= slab->chunksPerBlock; i++)\n\t{\n\t\tint\t\t\tj,\n\t\t\t\t\tnfree;\n\t\tdlist_iter\titer;\n\n\t\t/* walk all blocks on this freelist */\n\t\tdlist_foreach(iter, &slab->freelist[i])\n\t\t{\n\t\t\tint\t\t\tidx;\n\t\t\tSlabBlock  *block = dlist_container(SlabBlock, node, iter.cur);\n\n\t\t\t/*\n\t\t\t * Make sure the number of free chunks (in the block header)\n\t\t\t * matches position in the freelist.\n\t\t\t */\n\t\t\tif (block->nfree != i)\n\t\t\t\telog(WARNING, \"problem in slab %s: number of free chunks %d in block %p does not match freelist %d\",\n\t\t\t\t\t name, block->nfree, block, i);\n\n\t\t\t/* reset the bitmap of free chunks for this block */\n\t\t\tmemset(freechunks, 0, (slab->chunksPerBlock * sizeof(bool)));\n\t\t\tidx = block->firstFreeChunk;\n\n\t\t\t/*\n\t\t\t * Now walk through the chunks, count the free ones and also\n\t\t\t * perform some additional checks for the used ones. As the chunk\n\t\t\t * freelist is stored within the chunks themselves, we have to\n\t\t\t * walk through the chunks and construct our own bitmap.\n\t\t\t */\n\n\t\t\tnfree = 0;\n\t\t\twhile (idx < slab->chunksPerBlock)\n\t\t\t{\n\t\t\t\tSlabChunk  *chunk;\n\n\t\t\t\t/* count the chunk as free, add it to the bitmap */\n\t\t\t\tnfree++;\n\t\t\t\tfreechunks[idx] = true;\n\n\t\t\t\t/* read index of the next free chunk */\n\t\t\t\tchunk = SlabBlockGetChunk(slab, block, idx);\n\t\t\t\tVALGRIND_MAKE_MEM_DEFINED(SlabChunkGetPointer(chunk), sizeof(int32));\n\t\t\t\tidx = *(int32 *) SlabChunkGetPointer(chunk);\n\t\t\t}\n\n\t\t\tfor (j = 0; j < slab->chunksPerBlock; j++)\n\t\t\t{\n\t\t\t\t/* non-zero bit in the bitmap means chunk the chunk is used */\n\t\t\t\tif (!freechunks[j])\n\t\t\t\t{\n\t\t\t\t\tSlabChunk  *chunk = SlabBlockGetChunk(slab, block, j);\n\n\t\t\t\t\t/* chunks have both block and slab pointers, so check both */\n\t\t\t\t\tif (chunk->block != block)\n\t\t\t\t\t\telog(WARNING, \"problem in slab %s: bogus block link in block %p, chunk %p\",\n\t\t\t\t\t\t\t name, block, chunk);\n\n\t\t\t\t\tif (chunk->slab != slab)\n\t\t\t\t\t\telog(WARNING, \"problem in slab %s: bogus slab link in block %p, chunk %p\",\n\t\t\t\t\t\t\t name, block, chunk);\n\n\t\t\t\t\t/* there might be sentinel (thanks to alignment) */\n\t\t\t\t\tif (slab->chunkSize < (slab->fullChunkSize - sizeof(SlabChunk)))\n\t\t\t\t\t\tif (!sentinel_ok(chunk, slab->chunkSize))\n\t\t\t\t\t\t\telog(WARNING, \"problem in slab %s: detected write past chunk end in block %p, chunk %p\",\n\t\t\t\t\t\t\t\t name, block, chunk);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Make sure we got the expected number of free chunks (as tracked\n\t\t\t * in the block header).\n\t\t\t */\n\t\t\tif (nfree != block->nfree)\n\t\t\t\telog(WARNING, \"problem in slab %s: number of free chunks %d in block %p does not match bitmap %d\",\n\t\t\t\t\t name, block->nfree, block, nfree);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"lib/ilist.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void SlabReset(MemoryContext context);",
            "static void SlabDelete(MemoryContext context);",
            "static bool SlabIsEmpty(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lib/ilist.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"postgres.h\"\n\nstatic void SlabReset(MemoryContext context);\nstatic void SlabDelete(MemoryContext context);\nstatic bool SlabIsEmpty(MemoryContext context);\n\nstatic void\nSlabCheck(MemoryContext context)\n{\n\tint\t\t\ti;\n\tSlabContext *slab = castNode(SlabContext, context);\n\tconst char *name = slab->header.name;\n\tchar\t   *freechunks;\n\n\tAssert(slab);\n\tAssert(slab->chunksPerBlock > 0);\n\n\t/* bitmap of free chunks on a block */\n\tfreechunks = palloc(slab->chunksPerBlock * sizeof(bool));\n\n\t/* walk all the freelists */\n\tfor (i = 0; i <= slab->chunksPerBlock; i++)\n\t{\n\t\tint\t\t\tj,\n\t\t\t\t\tnfree;\n\t\tdlist_iter\titer;\n\n\t\t/* walk all blocks on this freelist */\n\t\tdlist_foreach(iter, &slab->freelist[i])\n\t\t{\n\t\t\tint\t\t\tidx;\n\t\t\tSlabBlock  *block = dlist_container(SlabBlock, node, iter.cur);\n\n\t\t\t/*\n\t\t\t * Make sure the number of free chunks (in the block header)\n\t\t\t * matches position in the freelist.\n\t\t\t */\n\t\t\tif (block->nfree != i)\n\t\t\t\telog(WARNING, \"problem in slab %s: number of free chunks %d in block %p does not match freelist %d\",\n\t\t\t\t\t name, block->nfree, block, i);\n\n\t\t\t/* reset the bitmap of free chunks for this block */\n\t\t\tmemset(freechunks, 0, (slab->chunksPerBlock * sizeof(bool)));\n\t\t\tidx = block->firstFreeChunk;\n\n\t\t\t/*\n\t\t\t * Now walk through the chunks, count the free ones and also\n\t\t\t * perform some additional checks for the used ones. As the chunk\n\t\t\t * freelist is stored within the chunks themselves, we have to\n\t\t\t * walk through the chunks and construct our own bitmap.\n\t\t\t */\n\n\t\t\tnfree = 0;\n\t\t\twhile (idx < slab->chunksPerBlock)\n\t\t\t{\n\t\t\t\tSlabChunk  *chunk;\n\n\t\t\t\t/* count the chunk as free, add it to the bitmap */\n\t\t\t\tnfree++;\n\t\t\t\tfreechunks[idx] = true;\n\n\t\t\t\t/* read index of the next free chunk */\n\t\t\t\tchunk = SlabBlockGetChunk(slab, block, idx);\n\t\t\t\tVALGRIND_MAKE_MEM_DEFINED(SlabChunkGetPointer(chunk), sizeof(int32));\n\t\t\t\tidx = *(int32 *) SlabChunkGetPointer(chunk);\n\t\t\t}\n\n\t\t\tfor (j = 0; j < slab->chunksPerBlock; j++)\n\t\t\t{\n\t\t\t\t/* non-zero bit in the bitmap means chunk the chunk is used */\n\t\t\t\tif (!freechunks[j])\n\t\t\t\t{\n\t\t\t\t\tSlabChunk  *chunk = SlabBlockGetChunk(slab, block, j);\n\n\t\t\t\t\t/* chunks have both block and slab pointers, so check both */\n\t\t\t\t\tif (chunk->block != block)\n\t\t\t\t\t\telog(WARNING, \"problem in slab %s: bogus block link in block %p, chunk %p\",\n\t\t\t\t\t\t\t name, block, chunk);\n\n\t\t\t\t\tif (chunk->slab != slab)\n\t\t\t\t\t\telog(WARNING, \"problem in slab %s: bogus slab link in block %p, chunk %p\",\n\t\t\t\t\t\t\t name, block, chunk);\n\n\t\t\t\t\t/* there might be sentinel (thanks to alignment) */\n\t\t\t\t\tif (slab->chunkSize < (slab->fullChunkSize - sizeof(SlabChunk)))\n\t\t\t\t\t\tif (!sentinel_ok(chunk, slab->chunkSize))\n\t\t\t\t\t\t\telog(WARNING, \"problem in slab %s: detected write past chunk end in block %p, chunk %p\",\n\t\t\t\t\t\t\t\t name, block, chunk);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Make sure we got the expected number of free chunks (as tracked\n\t\t\t * in the block header).\n\t\t\t */\n\t\t\tif (nfree != block->nfree)\n\t\t\t\telog(WARNING, \"problem in slab %s: number of free chunks %d in block %p does not match bitmap %d\",\n\t\t\t\t\t name, block->nfree, block, nfree);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "slab"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "castNode",
          "args": [
            "SlabContext",
            "context"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lib/ilist.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"postgres.h\"\n\nstatic void SlabReset(MemoryContext context);\nstatic void SlabDelete(MemoryContext context);\nstatic bool SlabIsEmpty(MemoryContext context);\n\nstatic void\nSlabReset(MemoryContext context)\n{\n\tint\t\t\ti;\n\tSlabContext *slab = castNode(SlabContext, context);\n\n\tAssert(slab);\n\n#ifdef MEMORY_CONTEXT_CHECKING\n\t/* Check for corruption and leaks before freeing */\n\tSlabCheck(context);\n#endif\n\n\t/* walk over freelists and free the blocks */\n\tfor (i = 0; i <= slab->chunksPerBlock; i++)\n\t{\n\t\tdlist_mutable_iter miter;\n\n\t\tdlist_foreach_modify(miter, &slab->freelist[i])\n\t\t{\n\t\t\tSlabBlock  *block = dlist_container(SlabBlock, node, miter.cur);\n\n\t\t\tdlist_delete(miter.cur);\n\n#ifdef CLOBBER_FREED_MEMORY\n\t\t\twipe_mem(block, slab->blockSize);\n#endif\n\t\t\tfree(block);\n\t\t\tslab->nblocks--;\n\t\t}\n\t}\n\n\tslab->minFreeChunks = 0;\n\n\tAssert(slab->nblocks == 0);\n}"
  },
  {
    "function_name": "SlabContextCreate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/slab.c",
    "lines": "187-270",
    "snippet": "MemoryContext\nSlabContextCreate(MemoryContext parent,\n\t\t\t\t  const char *name,\n\t\t\t\t  Size blockSize,\n\t\t\t\t  Size chunkSize)\n{\n\tint\t\t\tchunksPerBlock;\n\tSize\t\tfullChunkSize;\n\tSize\t\tfreelistSize;\n\tSize\t\theaderSize;\n\tSlabContext *slab;\n\tint\t\t\ti;\n\n\t/* Assert we padded SlabChunk properly */\n\tStaticAssertStmt(sizeof(SlabChunk) == MAXALIGN(sizeof(SlabChunk)),\n\t\t\t\t\t \"sizeof(SlabChunk) is not maxaligned\");\n\tStaticAssertStmt(offsetof(SlabChunk, slab) + sizeof(MemoryContext) ==\n\t\t\t\t\t sizeof(SlabChunk),\n\t\t\t\t\t \"padding calculation in SlabChunk is wrong\");\n\n\t/* Make sure the linked list node fits inside a freed chunk */\n\tif (chunkSize < sizeof(int))\n\t\tchunkSize = sizeof(int);\n\n\t/* chunk, including SLAB header (both addresses nicely aligned) */\n\tfullChunkSize = sizeof(SlabChunk) + MAXALIGN(chunkSize);\n\n\t/* Make sure the block can store at least one chunk. */\n\tif (blockSize < fullChunkSize + sizeof(SlabBlock))\n\t\telog(ERROR, \"block size %zu for slab is too small for %zu chunks\",\n\t\t\t blockSize, chunkSize);\n\n\t/* Compute maximum number of chunks per block */\n\tchunksPerBlock = (blockSize - sizeof(SlabBlock)) / fullChunkSize;\n\n\t/* The freelist starts with 0, ends with chunksPerBlock. */\n\tfreelistSize = sizeof(dlist_head) * (chunksPerBlock + 1);\n\n\t/*\n\t * Allocate the context header.  Unlike aset.c, we never try to combine\n\t * this with the first regular block; not worth the extra complication.\n\t */\n\n\t/* Size of the memory context header */\n\theaderSize = offsetof(SlabContext, freelist) + freelistSize;\n\n\tslab = (SlabContext *) malloc(headerSize);\n\tif (slab == NULL)\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed while creating memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   name)));\n\t}\n\n\t/*\n\t * Avoid writing code that can fail between here and MemoryContextCreate;\n\t * we'd leak the header if we ereport in this stretch.\n\t */\n\n\t/* Fill in SlabContext-specific header fields */\n\tslab->chunkSize = chunkSize;\n\tslab->fullChunkSize = fullChunkSize;\n\tslab->blockSize = blockSize;\n\tslab->headerSize = headerSize;\n\tslab->chunksPerBlock = chunksPerBlock;\n\tslab->minFreeChunks = 0;\n\tslab->nblocks = 0;\n\n\t/* initialize the freelist slots */\n\tfor (i = 0; i < (slab->chunksPerBlock + 1); i++)\n\t\tdlist_init(&slab->freelist[i]);\n\n\t/* Finally, do the type-independent part of context creation */\n\tMemoryContextCreate((MemoryContext) slab,\n\t\t\t\t\t\tT_SlabContext,\n\t\t\t\t\t\t&SlabMethods,\n\t\t\t\t\t\tparent,\n\t\t\t\t\t\tname);\n\n\treturn (MemoryContext) slab;\n}",
    "includes": [
      "#include \"lib/ilist.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void *SlabAlloc(MemoryContext context, Size size);",
      "static void *SlabRealloc(MemoryContext context, void *pointer, Size size);",
      "static void SlabReset(MemoryContext context);",
      "static void SlabDelete(MemoryContext context);",
      "static bool SlabIsEmpty(MemoryContext context);",
      "static const MemoryContextMethods SlabMethods = {\n\tSlabAlloc,\n\tSlabFree,\n\tSlabRealloc,\n\tSlabReset,\n\tSlabDelete,\n\tSlabGetChunkSpace,\n\tSlabIsEmpty,\n\tSlabStats\n#ifdef MEMORY_CONTEXT_CHECKING\n\t,SlabCheck\n#endif\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextCreate",
          "args": [
            "(MemoryContext) slab",
            "T_SlabContext",
            "&SlabMethods",
            "parent",
            "name"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextCreate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "723-761",
          "snippet": "void\nMemoryContextCreate(MemoryContext node,\n\t\t\t\t\tNodeTag tag,\n\t\t\t\t\tconst MemoryContextMethods *methods,\n\t\t\t\t\tMemoryContext parent,\n\t\t\t\t\tconst char *name)\n{\n\t/* Creating new memory contexts is not allowed in a critical section */\n\tAssert(CritSectionCount == 0);\n\n\t/* Initialize all standard fields of memory context header */\n\tnode->type = tag;\n\tnode->isReset = true;\n\tnode->methods = methods;\n\tnode->parent = parent;\n\tnode->firstchild = NULL;\n\tnode->prevchild = NULL;\n\tnode->name = name;\n\tnode->ident = NULL;\n\tnode->reset_cbs = NULL;\n\n\t/* OK to link node into context tree */\n\tif (parent)\n\t{\n\t\tnode->nextchild = parent->firstchild;\n\t\tif (parent->firstchild != NULL)\n\t\t\tparent->firstchild->prevchild = node;\n\t\tparent->firstchild = node;\n\t\t/* inherit allowInCritSection flag from parent */\n\t\tnode->allowInCritSection = parent->allowInCritSection;\n\t}\n\telse\n\t{\n\t\tnode->nextchild = NULL;\n\t\tnode->allowInCritSection = false;\n\t}\n\n\tVALGRIND_CREATE_MEMPOOL(node, 0, false);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\nMemoryContextCreate(MemoryContext node,\n\t\t\t\t\tNodeTag tag,\n\t\t\t\t\tconst MemoryContextMethods *methods,\n\t\t\t\t\tMemoryContext parent,\n\t\t\t\t\tconst char *name)\n{\n\t/* Creating new memory contexts is not allowed in a critical section */\n\tAssert(CritSectionCount == 0);\n\n\t/* Initialize all standard fields of memory context header */\n\tnode->type = tag;\n\tnode->isReset = true;\n\tnode->methods = methods;\n\tnode->parent = parent;\n\tnode->firstchild = NULL;\n\tnode->prevchild = NULL;\n\tnode->name = name;\n\tnode->ident = NULL;\n\tnode->reset_cbs = NULL;\n\n\t/* OK to link node into context tree */\n\tif (parent)\n\t{\n\t\tnode->nextchild = parent->firstchild;\n\t\tif (parent->firstchild != NULL)\n\t\t\tparent->firstchild->prevchild = node;\n\t\tparent->firstchild = node;\n\t\t/* inherit allowInCritSection flag from parent */\n\t\tnode->allowInCritSection = parent->allowInCritSection;\n\t}\n\telse\n\t{\n\t\tnode->nextchild = NULL;\n\t\tnode->allowInCritSection = false;\n\t}\n\n\tVALGRIND_CREATE_MEMPOOL(node, 0, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlist_init",
          "args": [
            "&slab->freelist[i]"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed while creating memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   name))"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errdetail",
          "args": [
            "\"Failed while creating memory context \\\"%s\\\".\"",
            "name"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "errdetail_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "918-933",
          "snippet": "int\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"out of memory\""
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_OUT_OF_MEMORY"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextStats",
          "args": [
            "TopMemoryContext"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextStats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "473-478",
          "snippet": "void\nMemoryContextStats(MemoryContext context)\n{\n\t/* A hard-wired limit on the number of children is usually good enough */\n\tMemoryContextStatsDetail(context, 100);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\nMemoryContextStats(MemoryContext context)\n{\n\t/* A hard-wired limit on the number of children is usually good enough */\n\tMemoryContextStatsDetail(context, 100);\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "headerSize"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"block size %zu for slab is too small for %zu chunks\"",
            "blockSize",
            "chunkSize"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MAXALIGN",
          "args": [
            "chunkSize"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StaticAssertStmt",
          "args": [
            "offsetof(SlabChunk, slab) + sizeof(MemoryContext) ==\n\t\t\t\t\t sizeof(SlabChunk)",
            "\"padding calculation in SlabChunk is wrong\""
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StaticAssertStmt",
          "args": [
            "sizeof(SlabChunk) == MAXALIGN(sizeof(SlabChunk))",
            "\"sizeof(SlabChunk) is not maxaligned\""
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAXALIGN",
          "args": [
            "sizeof(SlabChunk)"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lib/ilist.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"postgres.h\"\n\nstatic void *SlabAlloc(MemoryContext context, Size size);\nstatic void *SlabRealloc(MemoryContext context, void *pointer, Size size);\nstatic void SlabReset(MemoryContext context);\nstatic void SlabDelete(MemoryContext context);\nstatic bool SlabIsEmpty(MemoryContext context);\nstatic const MemoryContextMethods SlabMethods = {\n\tSlabAlloc,\n\tSlabFree,\n\tSlabRealloc,\n\tSlabReset,\n\tSlabDelete,\n\tSlabGetChunkSpace,\n\tSlabIsEmpty,\n\tSlabStats\n#ifdef MEMORY_CONTEXT_CHECKING\n\t,SlabCheck\n#endif\n};\n\nMemoryContext\nSlabContextCreate(MemoryContext parent,\n\t\t\t\t  const char *name,\n\t\t\t\t  Size blockSize,\n\t\t\t\t  Size chunkSize)\n{\n\tint\t\t\tchunksPerBlock;\n\tSize\t\tfullChunkSize;\n\tSize\t\tfreelistSize;\n\tSize\t\theaderSize;\n\tSlabContext *slab;\n\tint\t\t\ti;\n\n\t/* Assert we padded SlabChunk properly */\n\tStaticAssertStmt(sizeof(SlabChunk) == MAXALIGN(sizeof(SlabChunk)),\n\t\t\t\t\t \"sizeof(SlabChunk) is not maxaligned\");\n\tStaticAssertStmt(offsetof(SlabChunk, slab) + sizeof(MemoryContext) ==\n\t\t\t\t\t sizeof(SlabChunk),\n\t\t\t\t\t \"padding calculation in SlabChunk is wrong\");\n\n\t/* Make sure the linked list node fits inside a freed chunk */\n\tif (chunkSize < sizeof(int))\n\t\tchunkSize = sizeof(int);\n\n\t/* chunk, including SLAB header (both addresses nicely aligned) */\n\tfullChunkSize = sizeof(SlabChunk) + MAXALIGN(chunkSize);\n\n\t/* Make sure the block can store at least one chunk. */\n\tif (blockSize < fullChunkSize + sizeof(SlabBlock))\n\t\telog(ERROR, \"block size %zu for slab is too small for %zu chunks\",\n\t\t\t blockSize, chunkSize);\n\n\t/* Compute maximum number of chunks per block */\n\tchunksPerBlock = (blockSize - sizeof(SlabBlock)) / fullChunkSize;\n\n\t/* The freelist starts with 0, ends with chunksPerBlock. */\n\tfreelistSize = sizeof(dlist_head) * (chunksPerBlock + 1);\n\n\t/*\n\t * Allocate the context header.  Unlike aset.c, we never try to combine\n\t * this with the first regular block; not worth the extra complication.\n\t */\n\n\t/* Size of the memory context header */\n\theaderSize = offsetof(SlabContext, freelist) + freelistSize;\n\n\tslab = (SlabContext *) malloc(headerSize);\n\tif (slab == NULL)\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed while creating memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   name)));\n\t}\n\n\t/*\n\t * Avoid writing code that can fail between here and MemoryContextCreate;\n\t * we'd leak the header if we ereport in this stretch.\n\t */\n\n\t/* Fill in SlabContext-specific header fields */\n\tslab->chunkSize = chunkSize;\n\tslab->fullChunkSize = fullChunkSize;\n\tslab->blockSize = blockSize;\n\tslab->headerSize = headerSize;\n\tslab->chunksPerBlock = chunksPerBlock;\n\tslab->minFreeChunks = 0;\n\tslab->nblocks = 0;\n\n\t/* initialize the freelist slots */\n\tfor (i = 0; i < (slab->chunksPerBlock + 1); i++)\n\t\tdlist_init(&slab->freelist[i]);\n\n\t/* Finally, do the type-independent part of context creation */\n\tMemoryContextCreate((MemoryContext) slab,\n\t\t\t\t\t\tT_SlabContext,\n\t\t\t\t\t\t&SlabMethods,\n\t\t\t\t\t\tparent,\n\t\t\t\t\t\tname);\n\n\treturn (MemoryContext) slab;\n}"
  }
]