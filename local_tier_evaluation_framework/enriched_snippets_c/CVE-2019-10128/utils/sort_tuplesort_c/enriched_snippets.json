[
  {
    "function_name": "free_sort_tuple",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "4578-4583",
    "snippet": "static void\nfree_sort_tuple(Tuplesortstate *state, SortTuple *stup)\n{\n\tFREEMEM(state, GetMemoryChunkSpace(stup->tuple));\n\tpfree(stup->tuple);\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);",
      "static void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "stup->tuple"
          ],
          "line": 4582
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "FREEMEM",
          "args": [
            "state",
            "GetMemoryChunkSpace(stup->tuple)"
          ],
          "line": 4581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetMemoryChunkSpace",
          "args": [
            "stup->tuple"
          ],
          "line": 4581
        },
        "resolved": true,
        "details": {
          "function_name": "GetMemoryChunkSpace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "426-432",
          "snippet": "Size\nGetMemoryChunkSpace(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\treturn context->methods->get_chunk_space(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nSize\nGetMemoryChunkSpace(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\treturn context->methods->get_chunk_space(context, pointer);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\nstatic void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);\n\nstatic void\nfree_sort_tuple(Tuplesortstate *state, SortTuple *stup)\n{\n\tFREEMEM(state, GetMemoryChunkSpace(stup->tuple));\n\tpfree(stup->tuple);\n}"
  },
  {
    "function_name": "leader_takeover_tapes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "4513-4573",
    "snippet": "static void\nleader_takeover_tapes(Tuplesortstate *state)\n{\n\tSharedsort *shared = state->shared;\n\tint\t\t\tnParticipants = state->nParticipants;\n\tint\t\t\tworkersFinished;\n\tint\t\t\tj;\n\n\tAssert(LEADER(state));\n\tAssert(nParticipants >= 1);\n\n\tSpinLockAcquire(&shared->mutex);\n\tworkersFinished = shared->workersFinished;\n\tSpinLockRelease(&shared->mutex);\n\n\tif (nParticipants != workersFinished)\n\t\telog(ERROR, \"cannot take over tapes before all workers finish\");\n\n\t/*\n\t * Create the tapeset from worker tapes, including a leader-owned tape at\n\t * the end.  Parallel workers are far more expensive than logical tapes,\n\t * so the number of tapes allocated here should never be excessive.\n\t *\n\t * We still have a leader tape, though it's not possible to write to it\n\t * due to restrictions in the shared fileset infrastructure used by\n\t * logtape.c.  It will never be written to in practice because\n\t * randomAccess is disallowed for parallel sorts.\n\t */\n\tinittapestate(state, nParticipants + 1);\n\tstate->tapeset = LogicalTapeSetCreate(nParticipants + 1, shared->tapes,\n\t\t\t\t\t\t\t\t\t\t  &shared->fileset, state->worker);\n\n\t/* mergeruns() relies on currentRun for # of runs (in one-pass cases) */\n\tstate->currentRun = nParticipants;\n\n\t/*\n\t * Initialize variables of Algorithm D to be consistent with runs from\n\t * workers having been generated in the leader.\n\t *\n\t * There will always be exactly 1 run per worker, and exactly one input\n\t * tape per run, because workers always output exactly 1 run, even when\n\t * there were no input tuples for workers to sort.\n\t */\n\tfor (j = 0; j < state->maxTapes; j++)\n\t{\n\t\t/* One real run; no dummy runs for worker tapes */\n\t\tstate->tp_fib[j] = 1;\n\t\tstate->tp_runs[j] = 1;\n\t\tstate->tp_dummy[j] = 0;\n\t\tstate->tp_tapenum[j] = j;\n\t}\n\t/* Leader tape gets one dummy run, and no real runs */\n\tstate->tp_fib[state->tapeRange] = 0;\n\tstate->tp_runs[state->tapeRange] = 0;\n\tstate->tp_dummy[state->tapeRange] = 1;\n\n\tstate->Level = 1;\n\tstate->destTape = 0;\n\n\tstate->status = TSS_BUILDRUNS;\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);",
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void inittapes(Tuplesortstate *state, bool mergeruns);",
      "static void inittapestate(Tuplesortstate *state, int maxTapes);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LogicalTapeSetCreate",
          "args": [
            "nParticipants + 1",
            "shared->tapes",
            "&shared->fileset",
            "state->worker"
          ],
          "line": 4542
        },
        "resolved": true,
        "details": {
          "function_name": "LogicalTapeSetCreate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/logtape.c",
          "lines": "509-578",
          "snippet": "LogicalTapeSet *\nLogicalTapeSetCreate(int ntapes, TapeShare *shared, SharedFileSet *fileset,\n\t\t\t\t\t int worker)\n{\n\tLogicalTapeSet *lts;\n\tLogicalTape *lt;\n\tint\t\t\ti;\n\n\t/*\n\t * Create top-level struct including per-tape LogicalTape structs.\n\t */\n\tAssert(ntapes > 0);\n\tlts = (LogicalTapeSet *) palloc(offsetof(LogicalTapeSet, tapes) +\n\t\t\t\t\t\t\t\t\tntapes * sizeof(LogicalTape));\n\tlts->nBlocksAllocated = 0L;\n\tlts->nBlocksWritten = 0L;\n\tlts->nHoleBlocks = 0L;\n\tlts->forgetFreeSpace = false;\n\tlts->blocksSorted = true;\t/* a zero-length array is sorted ... */\n\tlts->freeBlocksLen = 32;\t/* reasonable initial guess */\n\tlts->freeBlocks = (long *) palloc(lts->freeBlocksLen * sizeof(long));\n\tlts->nFreeBlocks = 0;\n\tlts->nTapes = ntapes;\n\n\t/*\n\t * Initialize per-tape structs.  Note we allocate the I/O buffer and the\n\t * first block for a tape only when it is first actually written to.  This\n\t * avoids wasting memory space when tuplesort.c overestimates the number\n\t * of tapes needed.\n\t */\n\tfor (i = 0; i < ntapes; i++)\n\t{\n\t\tlt = &lts->tapes[i];\n\t\tlt->writing = true;\n\t\tlt->frozen = false;\n\t\tlt->dirty = false;\n\t\tlt->firstBlockNumber = -1L;\n\t\tlt->curBlockNumber = -1L;\n\t\tlt->nextBlockNumber = -1L;\n\t\tlt->offsetBlockNumber = 0L;\n\t\tlt->buffer = NULL;\n\t\tlt->buffer_size = 0;\n\t\t/* palloc() larger than MaxAllocSize would fail */\n\t\tlt->max_size = MaxAllocSize;\n\t\tlt->pos = 0;\n\t\tlt->nbytes = 0;\n\t}\n\n\t/*\n\t * Create temp BufFile storage as required.\n\t *\n\t * Leader concatenates worker tapes, which requires special adjustment to\n\t * final tapeset data.  Things are simpler for the worker case and the\n\t * serial case, though.  They are generally very similar -- workers use a\n\t * shared fileset, whereas serial sorts use a conventional serial BufFile.\n\t */\n\tif (shared)\n\t\tltsConcatWorkerTapes(lts, shared, fileset);\n\telse if (fileset)\n\t{\n\t\tchar\t\tfilename[MAXPGPATH];\n\n\t\tpg_itoa(worker, filename);\n\t\tlts->pfile = BufFileCreateShared(fileset, filename);\n\t}\n\telse\n\t\tlts->pfile = BufFileCreateTemp(false);\n\n\treturn lts;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
            "static void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
            "static long ltsGetFreeBlock(LogicalTapeSet *lts);",
            "static void ltsConcatWorkerTapes(LogicalTapeSet *lts, TapeShare *shared,\n\t\t\t\t\t SharedFileSet *fileset);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/logtape.h\"\n#include \"utils/builtins.h\"\n#include \"storage/buffile.h\"\n#include \"postgres.h\"\n\nstatic void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic long ltsGetFreeBlock(LogicalTapeSet *lts);\nstatic void ltsConcatWorkerTapes(LogicalTapeSet *lts, TapeShare *shared,\n\t\t\t\t\t SharedFileSet *fileset);\n\nLogicalTapeSet *\nLogicalTapeSetCreate(int ntapes, TapeShare *shared, SharedFileSet *fileset,\n\t\t\t\t\t int worker)\n{\n\tLogicalTapeSet *lts;\n\tLogicalTape *lt;\n\tint\t\t\ti;\n\n\t/*\n\t * Create top-level struct including per-tape LogicalTape structs.\n\t */\n\tAssert(ntapes > 0);\n\tlts = (LogicalTapeSet *) palloc(offsetof(LogicalTapeSet, tapes) +\n\t\t\t\t\t\t\t\t\tntapes * sizeof(LogicalTape));\n\tlts->nBlocksAllocated = 0L;\n\tlts->nBlocksWritten = 0L;\n\tlts->nHoleBlocks = 0L;\n\tlts->forgetFreeSpace = false;\n\tlts->blocksSorted = true;\t/* a zero-length array is sorted ... */\n\tlts->freeBlocksLen = 32;\t/* reasonable initial guess */\n\tlts->freeBlocks = (long *) palloc(lts->freeBlocksLen * sizeof(long));\n\tlts->nFreeBlocks = 0;\n\tlts->nTapes = ntapes;\n\n\t/*\n\t * Initialize per-tape structs.  Note we allocate the I/O buffer and the\n\t * first block for a tape only when it is first actually written to.  This\n\t * avoids wasting memory space when tuplesort.c overestimates the number\n\t * of tapes needed.\n\t */\n\tfor (i = 0; i < ntapes; i++)\n\t{\n\t\tlt = &lts->tapes[i];\n\t\tlt->writing = true;\n\t\tlt->frozen = false;\n\t\tlt->dirty = false;\n\t\tlt->firstBlockNumber = -1L;\n\t\tlt->curBlockNumber = -1L;\n\t\tlt->nextBlockNumber = -1L;\n\t\tlt->offsetBlockNumber = 0L;\n\t\tlt->buffer = NULL;\n\t\tlt->buffer_size = 0;\n\t\t/* palloc() larger than MaxAllocSize would fail */\n\t\tlt->max_size = MaxAllocSize;\n\t\tlt->pos = 0;\n\t\tlt->nbytes = 0;\n\t}\n\n\t/*\n\t * Create temp BufFile storage as required.\n\t *\n\t * Leader concatenates worker tapes, which requires special adjustment to\n\t * final tapeset data.  Things are simpler for the worker case and the\n\t * serial case, though.  They are generally very similar -- workers use a\n\t * shared fileset, whereas serial sorts use a conventional serial BufFile.\n\t */\n\tif (shared)\n\t\tltsConcatWorkerTapes(lts, shared, fileset);\n\telse if (fileset)\n\t{\n\t\tchar\t\tfilename[MAXPGPATH];\n\n\t\tpg_itoa(worker, filename);\n\t\tlts->pfile = BufFileCreateShared(fileset, filename);\n\t}\n\telse\n\t\tlts->pfile = BufFileCreateTemp(false);\n\n\treturn lts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inittapestate",
          "args": [
            "state",
            "nParticipants + 1"
          ],
          "line": 4541
        },
        "resolved": true,
        "details": {
          "function_name": "inittapestate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "2448-2484",
          "snippet": "static void\ninittapestate(Tuplesortstate *state, int maxTapes)\n{\n\tint64\t\ttapeSpace;\n\n\t/*\n\t * Decrease availMem to reflect the space needed for tape buffers; but\n\t * don't decrease it to the point that we have no room for tuples. (That\n\t * case is only likely to occur if sorting pass-by-value Datums; in all\n\t * other scenarios the memtuples[] array is unlikely to occupy more than\n\t * half of allowedMem.  In the pass-by-value case it's not important to\n\t * account for tuple space, so we don't care if LACKMEM becomes\n\t * inaccurate.)\n\t */\n\ttapeSpace = (int64) maxTapes * TAPE_BUFFER_OVERHEAD;\n\n\tif (tapeSpace + GetMemoryChunkSpace(state->memtuples) < state->allowedMem)\n\t\tUSEMEM(state, tapeSpace);\n\n\t/*\n\t * Make sure that the temp file(s) underlying the tape set are created in\n\t * suitable temp tablespaces.  For parallel sorts, this should have been\n\t * called already, but it doesn't matter if it is called a second time.\n\t */\n\tPrepareTempTablespaces();\n\n\tstate->mergeactive = (bool *) palloc0(maxTapes * sizeof(bool));\n\tstate->tp_fib = (int *) palloc0(maxTapes * sizeof(int));\n\tstate->tp_runs = (int *) palloc0(maxTapes * sizeof(int));\n\tstate->tp_dummy = (int *) palloc0(maxTapes * sizeof(int));\n\tstate->tp_tapenum = (int *) palloc0(maxTapes * sizeof(int));\n\n\t/* Record # of tapes allocated (for duration of sort) */\n\tstate->maxTapes = maxTapes;\n\t/* Record maximum # of tapes usable as inputs when merging */\n\tstate->tapeRange = maxTapes - 1;\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TAPE_BUFFER_OVERHEAD\t\tBLCKSZ"
          ],
          "globals_used": [
            "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void inittapestate(Tuplesortstate *state, int maxTapes);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TAPE_BUFFER_OVERHEAD\t\tBLCKSZ\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void inittapestate(Tuplesortstate *state, int maxTapes);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic void\ninittapestate(Tuplesortstate *state, int maxTapes)\n{\n\tint64\t\ttapeSpace;\n\n\t/*\n\t * Decrease availMem to reflect the space needed for tape buffers; but\n\t * don't decrease it to the point that we have no room for tuples. (That\n\t * case is only likely to occur if sorting pass-by-value Datums; in all\n\t * other scenarios the memtuples[] array is unlikely to occupy more than\n\t * half of allowedMem.  In the pass-by-value case it's not important to\n\t * account for tuple space, so we don't care if LACKMEM becomes\n\t * inaccurate.)\n\t */\n\ttapeSpace = (int64) maxTapes * TAPE_BUFFER_OVERHEAD;\n\n\tif (tapeSpace + GetMemoryChunkSpace(state->memtuples) < state->allowedMem)\n\t\tUSEMEM(state, tapeSpace);\n\n\t/*\n\t * Make sure that the temp file(s) underlying the tape set are created in\n\t * suitable temp tablespaces.  For parallel sorts, this should have been\n\t * called already, but it doesn't matter if it is called a second time.\n\t */\n\tPrepareTempTablespaces();\n\n\tstate->mergeactive = (bool *) palloc0(maxTapes * sizeof(bool));\n\tstate->tp_fib = (int *) palloc0(maxTapes * sizeof(int));\n\tstate->tp_runs = (int *) palloc0(maxTapes * sizeof(int));\n\tstate->tp_dummy = (int *) palloc0(maxTapes * sizeof(int));\n\tstate->tp_tapenum = (int *) palloc0(maxTapes * sizeof(int));\n\n\t/* Record # of tapes allocated (for duration of sort) */\n\tstate->maxTapes = maxTapes;\n\t/* Record maximum # of tapes usable as inputs when merging */\n\tstate->tapeRange = maxTapes - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"cannot take over tapes before all workers finish\""
          ],
          "line": 4529
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SpinLockRelease",
          "args": [
            "&shared->mutex"
          ],
          "line": 4526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SpinLockAcquire",
          "args": [
            "&shared->mutex"
          ],
          "line": 4524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "nParticipants >= 1"
          ],
          "line": 4522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "LEADER(state)"
          ],
          "line": 4521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LEADER",
          "args": [
            "state"
          ],
          "line": 4521
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void inittapes(Tuplesortstate *state, bool mergeruns);\nstatic void inittapestate(Tuplesortstate *state, int maxTapes);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic void\nleader_takeover_tapes(Tuplesortstate *state)\n{\n\tSharedsort *shared = state->shared;\n\tint\t\t\tnParticipants = state->nParticipants;\n\tint\t\t\tworkersFinished;\n\tint\t\t\tj;\n\n\tAssert(LEADER(state));\n\tAssert(nParticipants >= 1);\n\n\tSpinLockAcquire(&shared->mutex);\n\tworkersFinished = shared->workersFinished;\n\tSpinLockRelease(&shared->mutex);\n\n\tif (nParticipants != workersFinished)\n\t\telog(ERROR, \"cannot take over tapes before all workers finish\");\n\n\t/*\n\t * Create the tapeset from worker tapes, including a leader-owned tape at\n\t * the end.  Parallel workers are far more expensive than logical tapes,\n\t * so the number of tapes allocated here should never be excessive.\n\t *\n\t * We still have a leader tape, though it's not possible to write to it\n\t * due to restrictions in the shared fileset infrastructure used by\n\t * logtape.c.  It will never be written to in practice because\n\t * randomAccess is disallowed for parallel sorts.\n\t */\n\tinittapestate(state, nParticipants + 1);\n\tstate->tapeset = LogicalTapeSetCreate(nParticipants + 1, shared->tapes,\n\t\t\t\t\t\t\t\t\t\t  &shared->fileset, state->worker);\n\n\t/* mergeruns() relies on currentRun for # of runs (in one-pass cases) */\n\tstate->currentRun = nParticipants;\n\n\t/*\n\t * Initialize variables of Algorithm D to be consistent with runs from\n\t * workers having been generated in the leader.\n\t *\n\t * There will always be exactly 1 run per worker, and exactly one input\n\t * tape per run, because workers always output exactly 1 run, even when\n\t * there were no input tuples for workers to sort.\n\t */\n\tfor (j = 0; j < state->maxTapes; j++)\n\t{\n\t\t/* One real run; no dummy runs for worker tapes */\n\t\tstate->tp_fib[j] = 1;\n\t\tstate->tp_runs[j] = 1;\n\t\tstate->tp_dummy[j] = 0;\n\t\tstate->tp_tapenum[j] = j;\n\t}\n\t/* Leader tape gets one dummy run, and no real runs */\n\tstate->tp_fib[state->tapeRange] = 0;\n\tstate->tp_runs[state->tapeRange] = 0;\n\tstate->tp_dummy[state->tapeRange] = 1;\n\n\tstate->Level = 1;\n\tstate->destTape = 0;\n\n\tstate->status = TSS_BUILDRUNS;\n}"
  },
  {
    "function_name": "worker_nomergeruns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "4492-4500",
    "snippet": "static void\nworker_nomergeruns(Tuplesortstate *state)\n{\n\tAssert(WORKER(state));\n\tAssert(state->result_tape == -1);\n\n\tstate->result_tape = state->tp_tapenum[state->destTape];\n\tworker_freeze_result_tape(state);\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "worker_freeze_result_tape",
          "args": [
            "state"
          ],
          "line": 4499
        },
        "resolved": true,
        "details": {
          "function_name": "worker_freeze_result_tape",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "4454-4484",
          "snippet": "static void\nworker_freeze_result_tape(Tuplesortstate *state)\n{\n\tSharedsort *shared = state->shared;\n\tTapeShare\toutput;\n\n\tAssert(WORKER(state));\n\tAssert(state->result_tape != -1);\n\tAssert(state->memtupcount == 0);\n\n\t/*\n\t * Free most remaining memory, in case caller is sensitive to our holding\n\t * on to it.  memtuples may not be a tiny merge heap at this point.\n\t */\n\tpfree(state->memtuples);\n\t/* Be tidy */\n\tstate->memtuples = NULL;\n\tstate->memtupsize = 0;\n\n\t/*\n\t * Parallel worker requires result tape metadata, which is to be stored in\n\t * shared memory for leader\n\t */\n\tLogicalTapeFreeze(state->tapeset, state->result_tape, &output);\n\n\t/* Store properties of output tape, and update finished worker count */\n\tSpinLockAcquire(&shared->mutex);\n\tshared->tapes[state->worker] = output;\n\tshared->workersFinished++;\n\tSpinLockRelease(&shared->mutex);\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic void\nworker_freeze_result_tape(Tuplesortstate *state)\n{\n\tSharedsort *shared = state->shared;\n\tTapeShare\toutput;\n\n\tAssert(WORKER(state));\n\tAssert(state->result_tape != -1);\n\tAssert(state->memtupcount == 0);\n\n\t/*\n\t * Free most remaining memory, in case caller is sensitive to our holding\n\t * on to it.  memtuples may not be a tiny merge heap at this point.\n\t */\n\tpfree(state->memtuples);\n\t/* Be tidy */\n\tstate->memtuples = NULL;\n\tstate->memtupsize = 0;\n\n\t/*\n\t * Parallel worker requires result tape metadata, which is to be stored in\n\t * shared memory for leader\n\t */\n\tLogicalTapeFreeze(state->tapeset, state->result_tape, &output);\n\n\t/* Store properties of output tape, and update finished worker count */\n\tSpinLockAcquire(&shared->mutex);\n\tshared->tapes[state->worker] = output;\n\tshared->workersFinished++;\n\tSpinLockRelease(&shared->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "state->result_tape == -1"
          ],
          "line": 4496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "WORKER(state)"
          ],
          "line": 4495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WORKER",
          "args": [
            "state"
          ],
          "line": 4495
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic void\nworker_nomergeruns(Tuplesortstate *state)\n{\n\tAssert(WORKER(state));\n\tAssert(state->result_tape == -1);\n\n\tstate->result_tape = state->tp_tapenum[state->destTape];\n\tworker_freeze_result_tape(state);\n}"
  },
  {
    "function_name": "worker_freeze_result_tape",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "4454-4484",
    "snippet": "static void\nworker_freeze_result_tape(Tuplesortstate *state)\n{\n\tSharedsort *shared = state->shared;\n\tTapeShare\toutput;\n\n\tAssert(WORKER(state));\n\tAssert(state->result_tape != -1);\n\tAssert(state->memtupcount == 0);\n\n\t/*\n\t * Free most remaining memory, in case caller is sensitive to our holding\n\t * on to it.  memtuples may not be a tiny merge heap at this point.\n\t */\n\tpfree(state->memtuples);\n\t/* Be tidy */\n\tstate->memtuples = NULL;\n\tstate->memtupsize = 0;\n\n\t/*\n\t * Parallel worker requires result tape metadata, which is to be stored in\n\t * shared memory for leader\n\t */\n\tLogicalTapeFreeze(state->tapeset, state->result_tape, &output);\n\n\t/* Store properties of output tape, and update finished worker count */\n\tSpinLockAcquire(&shared->mutex);\n\tshared->tapes[state->worker] = output;\n\tshared->workersFinished++;\n\tSpinLockRelease(&shared->mutex);\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SpinLockRelease",
          "args": [
            "&shared->mutex"
          ],
          "line": 4483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SpinLockAcquire",
          "args": [
            "&shared->mutex"
          ],
          "line": 4480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LogicalTapeFreeze",
          "args": [
            "state->tapeset",
            "state->result_tape",
            "&output"
          ],
          "line": 4477
        },
        "resolved": true,
        "details": {
          "function_name": "LogicalTapeFreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/logtape.c",
          "lines": "875-944",
          "snippet": "void\nLogicalTapeFreeze(LogicalTapeSet *lts, int tapenum, TapeShare *share)\n{\n\tLogicalTape *lt;\n\n\tAssert(tapenum >= 0 && tapenum < lts->nTapes);\n\tlt = &lts->tapes[tapenum];\n\tAssert(lt->writing);\n\tAssert(lt->offsetBlockNumber == 0L);\n\n\t/*\n\t * Completion of a write phase.  Flush last partial data block, and rewind\n\t * for nondestructive read.\n\t */\n\tif (lt->dirty)\n\t{\n\t\t/*\n\t\t * As long as we've filled the buffer at least once, its contents are\n\t\t * entirely defined from valgrind's point of view, even though\n\t\t * contents beyond the current end point may be stale.  But it's\n\t\t * possible - at least in the case of a parallel sort - to sort such\n\t\t * small amount of data that we do not fill the buffer even once. Tell\n\t\t * valgrind that its contents are defined, so it doesn't bleat.\n\t\t */\n\t\tVALGRIND_MAKE_MEM_DEFINED(lt->buffer + lt->nbytes,\n\t\t\t\t\t\t\t\t  lt->buffer_size - lt->nbytes);\n\n\t\tTapeBlockSetNBytes(lt->buffer, lt->nbytes);\n\t\tltsWriteBlock(lts, lt->curBlockNumber, (void *) lt->buffer);\n\t\tlt->writing = false;\n\t}\n\tlt->writing = false;\n\tlt->frozen = true;\n\n\t/*\n\t * The seek and backspace functions assume a single block read buffer.\n\t * That's OK with current usage.  A larger buffer is helpful to make the\n\t * read pattern of the backing file look more sequential to the OS, when\n\t * we're reading from multiple tapes.  But at the end of a sort, when a\n\t * tape is frozen, we only read from a single tape anyway.\n\t */\n\tif (!lt->buffer || lt->buffer_size != BLCKSZ)\n\t{\n\t\tif (lt->buffer)\n\t\t\tpfree(lt->buffer);\n\t\tlt->buffer = palloc(BLCKSZ);\n\t\tlt->buffer_size = BLCKSZ;\n\t}\n\n\t/* Read the first block, or reset if tape is empty */\n\tlt->curBlockNumber = lt->firstBlockNumber;\n\tlt->pos = 0;\n\tlt->nbytes = 0;\n\n\tif (lt->firstBlockNumber == -1L)\n\t\tlt->nextBlockNumber = -1L;\n\tltsReadBlock(lts, lt->curBlockNumber, (void *) lt->buffer);\n\tif (TapeBlockIsLast(lt->buffer))\n\t\tlt->nextBlockNumber = -1L;\n\telse\n\t\tlt->nextBlockNumber = TapeBlockGetTrailer(lt->buffer)->next;\n\tlt->nbytes = TapeBlockGetNBytes(lt->buffer);\n\n\t/* Handle extra steps when caller is to share its tapeset */\n\tif (share)\n\t{\n\t\tBufFileExportShared(lts->pfile);\n\t\tshare->firstblocknumber = lt->firstBlockNumber;\n\t}\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
            "static void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
            "static long ltsGetFreeBlock(LogicalTapeSet *lts);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/logtape.h\"\n#include \"utils/builtins.h\"\n#include \"storage/buffile.h\"\n#include \"postgres.h\"\n\nstatic void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic long ltsGetFreeBlock(LogicalTapeSet *lts);\n\nvoid\nLogicalTapeFreeze(LogicalTapeSet *lts, int tapenum, TapeShare *share)\n{\n\tLogicalTape *lt;\n\n\tAssert(tapenum >= 0 && tapenum < lts->nTapes);\n\tlt = &lts->tapes[tapenum];\n\tAssert(lt->writing);\n\tAssert(lt->offsetBlockNumber == 0L);\n\n\t/*\n\t * Completion of a write phase.  Flush last partial data block, and rewind\n\t * for nondestructive read.\n\t */\n\tif (lt->dirty)\n\t{\n\t\t/*\n\t\t * As long as we've filled the buffer at least once, its contents are\n\t\t * entirely defined from valgrind's point of view, even though\n\t\t * contents beyond the current end point may be stale.  But it's\n\t\t * possible - at least in the case of a parallel sort - to sort such\n\t\t * small amount of data that we do not fill the buffer even once. Tell\n\t\t * valgrind that its contents are defined, so it doesn't bleat.\n\t\t */\n\t\tVALGRIND_MAKE_MEM_DEFINED(lt->buffer + lt->nbytes,\n\t\t\t\t\t\t\t\t  lt->buffer_size - lt->nbytes);\n\n\t\tTapeBlockSetNBytes(lt->buffer, lt->nbytes);\n\t\tltsWriteBlock(lts, lt->curBlockNumber, (void *) lt->buffer);\n\t\tlt->writing = false;\n\t}\n\tlt->writing = false;\n\tlt->frozen = true;\n\n\t/*\n\t * The seek and backspace functions assume a single block read buffer.\n\t * That's OK with current usage.  A larger buffer is helpful to make the\n\t * read pattern of the backing file look more sequential to the OS, when\n\t * we're reading from multiple tapes.  But at the end of a sort, when a\n\t * tape is frozen, we only read from a single tape anyway.\n\t */\n\tif (!lt->buffer || lt->buffer_size != BLCKSZ)\n\t{\n\t\tif (lt->buffer)\n\t\t\tpfree(lt->buffer);\n\t\tlt->buffer = palloc(BLCKSZ);\n\t\tlt->buffer_size = BLCKSZ;\n\t}\n\n\t/* Read the first block, or reset if tape is empty */\n\tlt->curBlockNumber = lt->firstBlockNumber;\n\tlt->pos = 0;\n\tlt->nbytes = 0;\n\n\tif (lt->firstBlockNumber == -1L)\n\t\tlt->nextBlockNumber = -1L;\n\tltsReadBlock(lts, lt->curBlockNumber, (void *) lt->buffer);\n\tif (TapeBlockIsLast(lt->buffer))\n\t\tlt->nextBlockNumber = -1L;\n\telse\n\t\tlt->nextBlockNumber = TapeBlockGetTrailer(lt->buffer)->next;\n\tlt->nbytes = TapeBlockGetNBytes(lt->buffer);\n\n\t/* Handle extra steps when caller is to share its tapeset */\n\tif (share)\n\t{\n\t\tBufFileExportShared(lts->pfile);\n\t\tshare->firstblocknumber = lt->firstBlockNumber;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "state->memtuples"
          ],
          "line": 4468
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "state->memtupcount == 0"
          ],
          "line": 4462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "state->result_tape != -1"
          ],
          "line": 4461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "WORKER(state)"
          ],
          "line": 4460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WORKER",
          "args": [
            "state"
          ],
          "line": 4460
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic void\nworker_freeze_result_tape(Tuplesortstate *state)\n{\n\tSharedsort *shared = state->shared;\n\tTapeShare\toutput;\n\n\tAssert(WORKER(state));\n\tAssert(state->result_tape != -1);\n\tAssert(state->memtupcount == 0);\n\n\t/*\n\t * Free most remaining memory, in case caller is sensitive to our holding\n\t * on to it.  memtuples may not be a tiny merge heap at this point.\n\t */\n\tpfree(state->memtuples);\n\t/* Be tidy */\n\tstate->memtuples = NULL;\n\tstate->memtupsize = 0;\n\n\t/*\n\t * Parallel worker requires result tape metadata, which is to be stored in\n\t * shared memory for leader\n\t */\n\tLogicalTapeFreeze(state->tapeset, state->result_tape, &output);\n\n\t/* Store properties of output tape, and update finished worker count */\n\tSpinLockAcquire(&shared->mutex);\n\tshared->tapes[state->worker] = output;\n\tshared->workersFinished++;\n\tSpinLockRelease(&shared->mutex);\n}"
  },
  {
    "function_name": "worker_get_identifier",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "4426-4439",
    "snippet": "static int\nworker_get_identifier(Tuplesortstate *state)\n{\n\tSharedsort *shared = state->shared;\n\tint\t\t\tworker;\n\n\tAssert(WORKER(state));\n\n\tSpinLockAcquire(&shared->mutex);\n\tworker = shared->currentWorker++;\n\tSpinLockRelease(&shared->mutex);\n\n\treturn worker;\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SpinLockRelease",
          "args": [
            "&shared->mutex"
          ],
          "line": 4436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SpinLockAcquire",
          "args": [
            "&shared->mutex"
          ],
          "line": 4434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "WORKER(state)"
          ],
          "line": 4432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WORKER",
          "args": [
            "state"
          ],
          "line": 4432
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic int\nworker_get_identifier(Tuplesortstate *state)\n{\n\tSharedsort *shared = state->shared;\n\tint\t\t\tworker;\n\n\tAssert(WORKER(state));\n\n\tSpinLockAcquire(&shared->mutex);\n\tworker = shared->currentWorker++;\n\tSpinLockRelease(&shared->mutex);\n\n\treturn worker;\n}"
  },
  {
    "function_name": "tuplesort_attach_shared",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "4406-4411",
    "snippet": "void\ntuplesort_attach_shared(Sharedsort *shared, dsm_segment *seg)\n{\n\t/* Attach to SharedFileSet */\n\tSharedFileSetAttach(&shared->fileset, seg);\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SharedFileSetAttach",
          "args": [
            "&shared->fileset",
            "seg"
          ],
          "line": 4410
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nvoid\ntuplesort_attach_shared(Sharedsort *shared, dsm_segment *seg)\n{\n\t/* Attach to SharedFileSet */\n\tSharedFileSetAttach(&shared->fileset, seg);\n}"
  },
  {
    "function_name": "tuplesort_initialize_shared",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "4383-4399",
    "snippet": "void\ntuplesort_initialize_shared(Sharedsort *shared, int nWorkers, dsm_segment *seg)\n{\n\tint\t\t\ti;\n\n\tAssert(nWorkers > 0);\n\n\tSpinLockInit(&shared->mutex);\n\tshared->currentWorker = 0;\n\tshared->workersFinished = 0;\n\tSharedFileSetInit(&shared->fileset, seg);\n\tshared->nTapes = nWorkers;\n\tfor (i = 0; i < nWorkers; i++)\n\t{\n\t\tshared->tapes[i].firstblocknumber = 0L;\n\t}\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SharedFileSetInit",
          "args": [
            "&shared->fileset",
            "seg"
          ],
          "line": 4393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SpinLockInit",
          "args": [
            "&shared->mutex"
          ],
          "line": 4390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "nWorkers > 0"
          ],
          "line": 4388
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nvoid\ntuplesort_initialize_shared(Sharedsort *shared, int nWorkers, dsm_segment *seg)\n{\n\tint\t\t\ti;\n\n\tAssert(nWorkers > 0);\n\n\tSpinLockInit(&shared->mutex);\n\tshared->currentWorker = 0;\n\tshared->workersFinished = 0;\n\tSharedFileSetInit(&shared->fileset, seg);\n\tshared->nTapes = nWorkers;\n\tfor (i = 0; i < nWorkers; i++)\n\t{\n\t\tshared->tapes[i].firstblocknumber = 0L;\n\t}\n}"
  },
  {
    "function_name": "tuplesort_estimate_shared",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "4362-4374",
    "snippet": "Size\ntuplesort_estimate_shared(int nWorkers)\n{\n\tSize\t\ttapesSize;\n\n\tAssert(nWorkers > 0);\n\n\t/* Make sure that BufFile shared state is MAXALIGN'd */\n\ttapesSize = mul_size(sizeof(TapeShare), nWorkers);\n\ttapesSize = MAXALIGN(add_size(tapesSize, offsetof(Sharedsort, tapes)));\n\n\treturn tapesSize;\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MAXALIGN",
          "args": [
            "add_size(tapesSize, offsetof(Sharedsort, tapes))"
          ],
          "line": 4371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_size",
          "args": [
            "tapesSize",
            "offsetof(Sharedsort, tapes)"
          ],
          "line": 4371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mul_size",
          "args": [
            "sizeof(TapeShare)",
            "nWorkers"
          ],
          "line": 4370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "nWorkers > 0"
          ],
          "line": 4367
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nSize\ntuplesort_estimate_shared(int nWorkers)\n{\n\tSize\t\ttapesSize;\n\n\tAssert(nWorkers > 0);\n\n\t/* Make sure that BufFile shared state is MAXALIGN'd */\n\ttapesSize = mul_size(sizeof(TapeShare), nWorkers);\n\ttapesSize = MAXALIGN(add_size(tapesSize, offsetof(Sharedsort, tapes)));\n\n\treturn tapesSize;\n}"
  },
  {
    "function_name": "readtup_datum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "4315-4350",
    "snippet": "static void\nreadtup_datum(Tuplesortstate *state, SortTuple *stup,\n\t\t\t  int tapenum, unsigned int len)\n{\n\tunsigned int tuplen = len - sizeof(unsigned int);\n\n\tif (tuplen == 0)\n\t{\n\t\t/* it's NULL */\n\t\tstup->datum1 = (Datum) 0;\n\t\tstup->isnull1 = true;\n\t\tstup->tuple = NULL;\n\t}\n\telse if (!state->tuples)\n\t{\n\t\tAssert(tuplen == sizeof(Datum));\n\t\tLogicalTapeReadExact(state->tapeset, tapenum,\n\t\t\t\t\t\t\t &stup->datum1, tuplen);\n\t\tstup->isnull1 = false;\n\t\tstup->tuple = NULL;\n\t}\n\telse\n\t{\n\t\tvoid\t   *raddr = readtup_alloc(state, tuplen);\n\n\t\tLogicalTapeReadExact(state->tapeset, tapenum,\n\t\t\t\t\t\t\t raddr, tuplen);\n\t\tstup->datum1 = PointerGetDatum(raddr);\n\t\tstup->isnull1 = false;\n\t\tstup->tuple = raddr;\n\t}\n\n\tif (state->randomAccess)\t/* need trailing length word? */\n\t\tLogicalTapeReadExact(state->tapeset, tapenum,\n\t\t\t\t\t\t\t &tuplen, sizeof(tuplen));\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);",
      "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static void markrunend(Tuplesortstate *state, int tapenum);",
      "static void *readtup_alloc(Tuplesortstate *state, Size tuplen);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);",
      "static void readtup_heap(Tuplesortstate *state, SortTuple *stup,\n\t\t\t int tapenum, unsigned int len);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);",
      "static void readtup_cluster(Tuplesortstate *state, SortTuple *stup,\n\t\t\t\tint tapenum, unsigned int len);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
      "static void readtup_index(Tuplesortstate *state, SortTuple *stup,\n\t\t\t  int tapenum, unsigned int len);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
      "static void readtup_datum(Tuplesortstate *state, SortTuple *stup,\n\t\t\t  int tapenum, unsigned int len);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);",
      "static void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LogicalTapeReadExact",
          "args": [
            "state->tapeset",
            "tapenum",
            "&tuplen",
            "sizeof(tuplen)"
          ],
          "line": 4348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "raddr"
          ],
          "line": 4342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LogicalTapeReadExact",
          "args": [
            "state->tapeset",
            "tapenum",
            "raddr",
            "tuplen"
          ],
          "line": 4340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readtup_alloc",
          "args": [
            "state",
            "tuplen"
          ],
          "line": 4338
        },
        "resolved": true,
        "details": {
          "function_name": "readtup_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "3480-3501",
          "snippet": "static void *\nreadtup_alloc(Tuplesortstate *state, Size tuplen)\n{\n\tSlabSlot   *buf;\n\n\t/*\n\t * We pre-allocate enough slots in the slab arena that we should never run\n\t * out.\n\t */\n\tAssert(state->slabFreeHead);\n\n\tif (tuplen > SLAB_SLOT_SIZE || !state->slabFreeHead)\n\t\treturn MemoryContextAlloc(state->sortcontext, tuplen);\n\telse\n\t{\n\t\tbuf = state->slabFreeHead;\n\t\t/* Reuse this slot */\n\t\tstate->slabFreeHead = buf->nextfree;\n\n\t\treturn buf;\n\t}\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define SLAB_SLOT_SIZE 1024"
          ],
          "globals_used": [
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static void *readtup_alloc(Tuplesortstate *state, Size tuplen);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define SLAB_SLOT_SIZE 1024\n\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic void *readtup_alloc(Tuplesortstate *state, Size tuplen);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic void *\nreadtup_alloc(Tuplesortstate *state, Size tuplen)\n{\n\tSlabSlot   *buf;\n\n\t/*\n\t * We pre-allocate enough slots in the slab arena that we should never run\n\t * out.\n\t */\n\tAssert(state->slabFreeHead);\n\n\tif (tuplen > SLAB_SLOT_SIZE || !state->slabFreeHead)\n\t\treturn MemoryContextAlloc(state->sortcontext, tuplen);\n\telse\n\t{\n\t\tbuf = state->slabFreeHead;\n\t\t/* Reuse this slot */\n\t\tstate->slabFreeHead = buf->nextfree;\n\n\t\treturn buf;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "LogicalTapeReadExact",
          "args": [
            "state->tapeset",
            "tapenum",
            "&stup->datum1",
            "tuplen"
          ],
          "line": 4331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "tuplen == sizeof(Datum)"
          ],
          "line": 4330
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic void markrunend(Tuplesortstate *state, int tapenum);\nstatic void *readtup_alloc(Tuplesortstate *state, Size tuplen);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);\nstatic void readtup_heap(Tuplesortstate *state, SortTuple *stup,\n\t\t\t int tapenum, unsigned int len);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);\nstatic void readtup_cluster(Tuplesortstate *state, SortTuple *stup,\n\t\t\t\tint tapenum, unsigned int len);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic void readtup_index(Tuplesortstate *state, SortTuple *stup,\n\t\t\t  int tapenum, unsigned int len);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic void readtup_datum(Tuplesortstate *state, SortTuple *stup,\n\t\t\t  int tapenum, unsigned int len);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\nstatic void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);\n\nstatic void\nreadtup_datum(Tuplesortstate *state, SortTuple *stup,\n\t\t\t  int tapenum, unsigned int len)\n{\n\tunsigned int tuplen = len - sizeof(unsigned int);\n\n\tif (tuplen == 0)\n\t{\n\t\t/* it's NULL */\n\t\tstup->datum1 = (Datum) 0;\n\t\tstup->isnull1 = true;\n\t\tstup->tuple = NULL;\n\t}\n\telse if (!state->tuples)\n\t{\n\t\tAssert(tuplen == sizeof(Datum));\n\t\tLogicalTapeReadExact(state->tapeset, tapenum,\n\t\t\t\t\t\t\t &stup->datum1, tuplen);\n\t\tstup->isnull1 = false;\n\t\tstup->tuple = NULL;\n\t}\n\telse\n\t{\n\t\tvoid\t   *raddr = readtup_alloc(state, tuplen);\n\n\t\tLogicalTapeReadExact(state->tapeset, tapenum,\n\t\t\t\t\t\t\t raddr, tuplen);\n\t\tstup->datum1 = PointerGetDatum(raddr);\n\t\tstup->isnull1 = false;\n\t\tstup->tuple = raddr;\n\t}\n\n\tif (state->randomAccess)\t/* need trailing length word? */\n\t\tLogicalTapeReadExact(state->tapeset, tapenum,\n\t\t\t\t\t\t\t &tuplen, sizeof(tuplen));\n}"
  },
  {
    "function_name": "writetup_datum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "4274-4313",
    "snippet": "static void\nwritetup_datum(Tuplesortstate *state, int tapenum, SortTuple *stup)\n{\n\tvoid\t   *waddr;\n\tunsigned int tuplen;\n\tunsigned int writtenlen;\n\n\tif (stup->isnull1)\n\t{\n\t\twaddr = NULL;\n\t\ttuplen = 0;\n\t}\n\telse if (!state->tuples)\n\t{\n\t\twaddr = &stup->datum1;\n\t\ttuplen = sizeof(Datum);\n\t}\n\telse\n\t{\n\t\twaddr = stup->tuple;\n\t\ttuplen = datumGetSize(PointerGetDatum(stup->tuple), false, state->datumTypeLen);\n\t\tAssert(tuplen != 0);\n\t}\n\n\twrittenlen = tuplen + sizeof(unsigned int);\n\n\tLogicalTapeWrite(state->tapeset, tapenum,\n\t\t\t\t\t (void *) &writtenlen, sizeof(writtenlen));\n\tLogicalTapeWrite(state->tapeset, tapenum,\n\t\t\t\t\t waddr, tuplen);\n\tif (state->randomAccess)\t/* need trailing length word? */\n\t\tLogicalTapeWrite(state->tapeset, tapenum,\n\t\t\t\t\t\t (void *) &writtenlen, sizeof(writtenlen));\n\n\tif (!state->slabAllocatorUsed && stup->tuple)\n\t{\n\t\tFREEMEM(state, GetMemoryChunkSpace(stup->tuple));\n\t\tpfree(stup->tuple);\n\t}\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);",
      "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static void markrunend(Tuplesortstate *state, int tapenum);",
      "static void *readtup_alloc(Tuplesortstate *state, Size tuplen);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);",
      "static void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "stup->tuple"
          ],
          "line": 4311
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "FREEMEM",
          "args": [
            "state",
            "GetMemoryChunkSpace(stup->tuple)"
          ],
          "line": 4310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetMemoryChunkSpace",
          "args": [
            "stup->tuple"
          ],
          "line": 4310
        },
        "resolved": true,
        "details": {
          "function_name": "GetMemoryChunkSpace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "426-432",
          "snippet": "Size\nGetMemoryChunkSpace(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\treturn context->methods->get_chunk_space(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nSize\nGetMemoryChunkSpace(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\treturn context->methods->get_chunk_space(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "LogicalTapeWrite",
          "args": [
            "state->tapeset",
            "tapenum",
            "(void *) &writtenlen",
            "sizeof(writtenlen)"
          ],
          "line": 4305
        },
        "resolved": true,
        "details": {
          "function_name": "LogicalTapeWrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/logtape.c",
          "lines": "620-694",
          "snippet": "void\nLogicalTapeWrite(LogicalTapeSet *lts, int tapenum,\n\t\t\t\t void *ptr, size_t size)\n{\n\tLogicalTape *lt;\n\tsize_t\t\tnthistime;\n\n\tAssert(tapenum >= 0 && tapenum < lts->nTapes);\n\tlt = &lts->tapes[tapenum];\n\tAssert(lt->writing);\n\tAssert(lt->offsetBlockNumber == 0L);\n\n\t/* Allocate data buffer and first block on first write */\n\tif (lt->buffer == NULL)\n\t{\n\t\tlt->buffer = (char *) palloc(BLCKSZ);\n\t\tlt->buffer_size = BLCKSZ;\n\t}\n\tif (lt->curBlockNumber == -1)\n\t{\n\t\tAssert(lt->firstBlockNumber == -1);\n\t\tAssert(lt->pos == 0);\n\n\t\tlt->curBlockNumber = ltsGetFreeBlock(lts);\n\t\tlt->firstBlockNumber = lt->curBlockNumber;\n\n\t\tTapeBlockGetTrailer(lt->buffer)->prev = -1L;\n\t}\n\n\tAssert(lt->buffer_size == BLCKSZ);\n\twhile (size > 0)\n\t{\n\t\tif (lt->pos >= TapeBlockPayloadSize)\n\t\t{\n\t\t\t/* Buffer full, dump it out */\n\t\t\tlong\t\tnextBlockNumber;\n\n\t\t\tif (!lt->dirty)\n\t\t\t{\n\t\t\t\t/* Hmm, went directly from reading to writing? */\n\t\t\t\telog(ERROR, \"invalid logtape state: should be dirty\");\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * First allocate the next block, so that we can store it in the\n\t\t\t * 'next' pointer of this block.\n\t\t\t */\n\t\t\tnextBlockNumber = ltsGetFreeBlock(lts);\n\n\t\t\t/* set the next-pointer and dump the current block. */\n\t\t\tTapeBlockGetTrailer(lt->buffer)->next = nextBlockNumber;\n\t\t\tltsWriteBlock(lts, lt->curBlockNumber, (void *) lt->buffer);\n\n\t\t\t/* initialize the prev-pointer of the next block */\n\t\t\tTapeBlockGetTrailer(lt->buffer)->prev = lt->curBlockNumber;\n\t\t\tlt->curBlockNumber = nextBlockNumber;\n\t\t\tlt->pos = 0;\n\t\t\tlt->nbytes = 0;\n\t\t}\n\n\t\tnthistime = TapeBlockPayloadSize - lt->pos;\n\t\tif (nthistime > size)\n\t\t\tnthistime = size;\n\t\tAssert(nthistime > 0);\n\n\t\tmemcpy(lt->buffer + lt->pos, ptr, nthistime);\n\n\t\tlt->dirty = true;\n\t\tlt->pos += nthistime;\n\t\tif (lt->nbytes < lt->pos)\n\t\t\tlt->nbytes = lt->pos;\n\t\tptr = (void *) ((char *) ptr + nthistime);\n\t\tsize -= nthistime;\n\t}\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TapeBlockPayloadSize  (BLCKSZ - sizeof(TapeBlockTrailer))"
          ],
          "globals_used": [
            "static void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
            "static void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
            "static long ltsGetFreeBlock(LogicalTapeSet *lts);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/logtape.h\"\n#include \"utils/builtins.h\"\n#include \"storage/buffile.h\"\n#include \"postgres.h\"\n\n#define TapeBlockPayloadSize  (BLCKSZ - sizeof(TapeBlockTrailer))\n\nstatic void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic long ltsGetFreeBlock(LogicalTapeSet *lts);\n\nvoid\nLogicalTapeWrite(LogicalTapeSet *lts, int tapenum,\n\t\t\t\t void *ptr, size_t size)\n{\n\tLogicalTape *lt;\n\tsize_t\t\tnthistime;\n\n\tAssert(tapenum >= 0 && tapenum < lts->nTapes);\n\tlt = &lts->tapes[tapenum];\n\tAssert(lt->writing);\n\tAssert(lt->offsetBlockNumber == 0L);\n\n\t/* Allocate data buffer and first block on first write */\n\tif (lt->buffer == NULL)\n\t{\n\t\tlt->buffer = (char *) palloc(BLCKSZ);\n\t\tlt->buffer_size = BLCKSZ;\n\t}\n\tif (lt->curBlockNumber == -1)\n\t{\n\t\tAssert(lt->firstBlockNumber == -1);\n\t\tAssert(lt->pos == 0);\n\n\t\tlt->curBlockNumber = ltsGetFreeBlock(lts);\n\t\tlt->firstBlockNumber = lt->curBlockNumber;\n\n\t\tTapeBlockGetTrailer(lt->buffer)->prev = -1L;\n\t}\n\n\tAssert(lt->buffer_size == BLCKSZ);\n\twhile (size > 0)\n\t{\n\t\tif (lt->pos >= TapeBlockPayloadSize)\n\t\t{\n\t\t\t/* Buffer full, dump it out */\n\t\t\tlong\t\tnextBlockNumber;\n\n\t\t\tif (!lt->dirty)\n\t\t\t{\n\t\t\t\t/* Hmm, went directly from reading to writing? */\n\t\t\t\telog(ERROR, \"invalid logtape state: should be dirty\");\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * First allocate the next block, so that we can store it in the\n\t\t\t * 'next' pointer of this block.\n\t\t\t */\n\t\t\tnextBlockNumber = ltsGetFreeBlock(lts);\n\n\t\t\t/* set the next-pointer and dump the current block. */\n\t\t\tTapeBlockGetTrailer(lt->buffer)->next = nextBlockNumber;\n\t\t\tltsWriteBlock(lts, lt->curBlockNumber, (void *) lt->buffer);\n\n\t\t\t/* initialize the prev-pointer of the next block */\n\t\t\tTapeBlockGetTrailer(lt->buffer)->prev = lt->curBlockNumber;\n\t\t\tlt->curBlockNumber = nextBlockNumber;\n\t\t\tlt->pos = 0;\n\t\t\tlt->nbytes = 0;\n\t\t}\n\n\t\tnthistime = TapeBlockPayloadSize - lt->pos;\n\t\tif (nthistime > size)\n\t\t\tnthistime = size;\n\t\tAssert(nthistime > 0);\n\n\t\tmemcpy(lt->buffer + lt->pos, ptr, nthistime);\n\n\t\tlt->dirty = true;\n\t\tlt->pos += nthistime;\n\t\tif (lt->nbytes < lt->pos)\n\t\t\tlt->nbytes = lt->pos;\n\t\tptr = (void *) ((char *) ptr + nthistime);\n\t\tsize -= nthistime;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "tuplen != 0"
          ],
          "line": 4295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "datumGetSize",
          "args": [
            "PointerGetDatum(stup->tuple)",
            "false",
            "state->datumTypeLen"
          ],
          "line": 4294
        },
        "resolved": true,
        "details": {
          "function_name": "datumGetSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datum.c",
          "lines": "60-110",
          "snippet": "Size\ndatumGetSize(Datum value, bool typByVal, int typLen)\n{\n\tSize\t\tsize;\n\n\tif (typByVal)\n\t{\n\t\t/* Pass-by-value types are always fixed-length */\n\t\tAssert(typLen > 0 && typLen <= sizeof(Datum));\n\t\tsize = (Size) typLen;\n\t}\n\telse\n\t{\n\t\tif (typLen > 0)\n\t\t{\n\t\t\t/* Fixed-length pass-by-ref type */\n\t\t\tsize = (Size) typLen;\n\t\t}\n\t\telse if (typLen == -1)\n\t\t{\n\t\t\t/* It is a varlena datatype */\n\t\t\tstruct varlena *s = (struct varlena *) DatumGetPointer(value);\n\n\t\t\tif (!PointerIsValid(s))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t\t\t errmsg(\"invalid Datum pointer\")));\n\n\t\t\tsize = (Size) VARSIZE_ANY(s);\n\t\t}\n\t\telse if (typLen == -2)\n\t\t{\n\t\t\t/* It is a cstring datatype */\n\t\t\tchar\t   *s = (char *) DatumGetPointer(value);\n\n\t\t\tif (!PointerIsValid(s))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t\t\t errmsg(\"invalid Datum pointer\")));\n\n\t\t\tsize = (Size) (strlen(s) + 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\telog(ERROR, \"invalid typLen: %d\", typLen);\n\t\t\tsize = 0;\t\t\t/* keep compiler quiet */\n\t\t}\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"utils/expandeddatum.h\"",
            "#include \"utils/datum.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/expandeddatum.h\"\n#include \"utils/datum.h\"\n#include \"postgres.h\"\n\nSize\ndatumGetSize(Datum value, bool typByVal, int typLen)\n{\n\tSize\t\tsize;\n\n\tif (typByVal)\n\t{\n\t\t/* Pass-by-value types are always fixed-length */\n\t\tAssert(typLen > 0 && typLen <= sizeof(Datum));\n\t\tsize = (Size) typLen;\n\t}\n\telse\n\t{\n\t\tif (typLen > 0)\n\t\t{\n\t\t\t/* Fixed-length pass-by-ref type */\n\t\t\tsize = (Size) typLen;\n\t\t}\n\t\telse if (typLen == -1)\n\t\t{\n\t\t\t/* It is a varlena datatype */\n\t\t\tstruct varlena *s = (struct varlena *) DatumGetPointer(value);\n\n\t\t\tif (!PointerIsValid(s))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t\t\t errmsg(\"invalid Datum pointer\")));\n\n\t\t\tsize = (Size) VARSIZE_ANY(s);\n\t\t}\n\t\telse if (typLen == -2)\n\t\t{\n\t\t\t/* It is a cstring datatype */\n\t\t\tchar\t   *s = (char *) DatumGetPointer(value);\n\n\t\t\tif (!PointerIsValid(s))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t\t\t errmsg(\"invalid Datum pointer\")));\n\n\t\t\tsize = (Size) (strlen(s) + 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\telog(ERROR, \"invalid typLen: %d\", typLen);\n\t\t\tsize = 0;\t\t\t/* keep compiler quiet */\n\t\t}\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "stup->tuple"
          ],
          "line": 4294
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic void markrunend(Tuplesortstate *state, int tapenum);\nstatic void *readtup_alloc(Tuplesortstate *state, Size tuplen);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\nstatic void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);\n\nstatic void\nwritetup_datum(Tuplesortstate *state, int tapenum, SortTuple *stup)\n{\n\tvoid\t   *waddr;\n\tunsigned int tuplen;\n\tunsigned int writtenlen;\n\n\tif (stup->isnull1)\n\t{\n\t\twaddr = NULL;\n\t\ttuplen = 0;\n\t}\n\telse if (!state->tuples)\n\t{\n\t\twaddr = &stup->datum1;\n\t\ttuplen = sizeof(Datum);\n\t}\n\telse\n\t{\n\t\twaddr = stup->tuple;\n\t\ttuplen = datumGetSize(PointerGetDatum(stup->tuple), false, state->datumTypeLen);\n\t\tAssert(tuplen != 0);\n\t}\n\n\twrittenlen = tuplen + sizeof(unsigned int);\n\n\tLogicalTapeWrite(state->tapeset, tapenum,\n\t\t\t\t\t (void *) &writtenlen, sizeof(writtenlen));\n\tLogicalTapeWrite(state->tapeset, tapenum,\n\t\t\t\t\t waddr, tuplen);\n\tif (state->randomAccess)\t/* need trailing length word? */\n\t\tLogicalTapeWrite(state->tapeset, tapenum,\n\t\t\t\t\t\t (void *) &writtenlen, sizeof(writtenlen));\n\n\tif (!state->slabAllocatorUsed && stup->tuple)\n\t{\n\t\tFREEMEM(state, GetMemoryChunkSpace(stup->tuple));\n\t\tpfree(stup->tuple);\n\t}\n}"
  },
  {
    "function_name": "copytup_datum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "4267-4272",
    "snippet": "static void\ncopytup_datum(Tuplesortstate *state, SortTuple *stup, void *tup)\n{\n\t/* Not currently needed */\n\telog(ERROR, \"copytup_datum() should not be called\");\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static void copytup_heap(Tuplesortstate *state, SortTuple *stup, void *tup);",
      "static void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static void copytup_cluster(Tuplesortstate *state, SortTuple *stup, void *tup);",
      "static void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static void copytup_index(Tuplesortstate *state, SortTuple *stup, void *tup);",
      "static void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static void copytup_datum(Tuplesortstate *state, SortTuple *stup, void *tup);",
      "static void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);",
      "static void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"copytup_datum() should not be called\""
          ],
          "line": 4271
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic void copytup_heap(Tuplesortstate *state, SortTuple *stup, void *tup);\nstatic void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic void copytup_cluster(Tuplesortstate *state, SortTuple *stup, void *tup);\nstatic void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic void copytup_index(Tuplesortstate *state, SortTuple *stup, void *tup);\nstatic void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic void copytup_datum(Tuplesortstate *state, SortTuple *stup, void *tup);\nstatic void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\nstatic void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);\n\nstatic void\ncopytup_datum(Tuplesortstate *state, SortTuple *stup, void *tup)\n{\n\t/* Not currently needed */\n\telog(ERROR, \"copytup_datum() should not be called\");\n}"
  },
  {
    "function_name": "comparetup_datum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "4246-4265",
    "snippet": "static int\ncomparetup_datum(const SortTuple *a, const SortTuple *b, Tuplesortstate *state)\n{\n\tint\t\t\tcompare;\n\n\tcompare = ApplySortComparator(a->datum1, a->isnull1,\n\t\t\t\t\t\t\t\t  b->datum1, b->isnull1,\n\t\t\t\t\t\t\t\t  state->sortKeys);\n\tif (compare != 0)\n\t\treturn compare;\n\n\t/* if we have abbreviations, then \"tuple\" has the original value */\n\n\tif (state->sortKeys->abbrev_converter)\n\t\tcompare = ApplySortAbbrevFullComparator(PointerGetDatum(a->tuple), a->isnull1,\n\t\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(b->tuple), b->isnull1,\n\t\t\t\t\t\t\t\t\t\t\t\tstate->sortKeys);\n\n\treturn compare;\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ApplySortAbbrevFullComparator",
          "args": [
            "PointerGetDatum(a->tuple)",
            "a->isnull1",
            "PointerGetDatum(b->tuple)",
            "b->isnull1",
            "state->sortKeys"
          ],
          "line": 4260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "b->tuple"
          ],
          "line": 4261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "a->tuple"
          ],
          "line": 4260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ApplySortComparator",
          "args": [
            "a->datum1",
            "a->isnull1",
            "b->datum1",
            "b->isnull1",
            "state->sortKeys"
          ],
          "line": 4251
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic int\ncomparetup_datum(const SortTuple *a, const SortTuple *b, Tuplesortstate *state)\n{\n\tint\t\t\tcompare;\n\n\tcompare = ApplySortComparator(a->datum1, a->isnull1,\n\t\t\t\t\t\t\t\t  b->datum1, b->isnull1,\n\t\t\t\t\t\t\t\t  state->sortKeys);\n\tif (compare != 0)\n\t\treturn compare;\n\n\t/* if we have abbreviations, then \"tuple\" has the original value */\n\n\tif (state->sortKeys->abbrev_converter)\n\t\tcompare = ApplySortAbbrevFullComparator(PointerGetDatum(a->tuple), a->isnull1,\n\t\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(b->tuple), b->isnull1,\n\t\t\t\t\t\t\t\t\t\t\t\tstate->sortKeys);\n\n\treturn compare;\n}"
  },
  {
    "function_name": "readtup_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "4222-4240",
    "snippet": "static void\nreadtup_index(Tuplesortstate *state, SortTuple *stup,\n\t\t\t  int tapenum, unsigned int len)\n{\n\tunsigned int tuplen = len - sizeof(unsigned int);\n\tIndexTuple\ttuple = (IndexTuple) readtup_alloc(state, tuplen);\n\n\tLogicalTapeReadExact(state->tapeset, tapenum,\n\t\t\t\t\t\t tuple, tuplen);\n\tif (state->randomAccess)\t/* need trailing length word? */\n\t\tLogicalTapeReadExact(state->tapeset, tapenum,\n\t\t\t\t\t\t\t &tuplen, sizeof(tuplen));\n\tstup->tuple = (void *) tuple;\n\t/* set up first-column key value */\n\tstup->datum1 = index_getattr(tuple,\n\t\t\t\t\t\t\t\t 1,\n\t\t\t\t\t\t\t\t RelationGetDescr(state->indexRel),\n\t\t\t\t\t\t\t\t &stup->isnull1);\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);",
      "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static void markrunend(Tuplesortstate *state, int tapenum);",
      "static void *readtup_alloc(Tuplesortstate *state, Size tuplen);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);",
      "static void readtup_heap(Tuplesortstate *state, SortTuple *stup,\n\t\t\t int tapenum, unsigned int len);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);",
      "static void readtup_cluster(Tuplesortstate *state, SortTuple *stup,\n\t\t\t\tint tapenum, unsigned int len);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
      "static void readtup_index(Tuplesortstate *state, SortTuple *stup,\n\t\t\t  int tapenum, unsigned int len);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
      "static void readtup_datum(Tuplesortstate *state, SortTuple *stup,\n\t\t\t  int tapenum, unsigned int len);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);",
      "static void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "index_getattr",
          "args": [
            "tuple",
            "1",
            "RelationGetDescr(state->indexRel)",
            "&stup->isnull1"
          ],
          "line": 4236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetDescr",
          "args": [
            "state->indexRel"
          ],
          "line": 4238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LogicalTapeReadExact",
          "args": [
            "state->tapeset",
            "tapenum",
            "&tuplen",
            "sizeof(tuplen)"
          ],
          "line": 4232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LogicalTapeReadExact",
          "args": [
            "state->tapeset",
            "tapenum",
            "tuple",
            "tuplen"
          ],
          "line": 4229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readtup_alloc",
          "args": [
            "state",
            "tuplen"
          ],
          "line": 4227
        },
        "resolved": true,
        "details": {
          "function_name": "readtup_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "3480-3501",
          "snippet": "static void *\nreadtup_alloc(Tuplesortstate *state, Size tuplen)\n{\n\tSlabSlot   *buf;\n\n\t/*\n\t * We pre-allocate enough slots in the slab arena that we should never run\n\t * out.\n\t */\n\tAssert(state->slabFreeHead);\n\n\tif (tuplen > SLAB_SLOT_SIZE || !state->slabFreeHead)\n\t\treturn MemoryContextAlloc(state->sortcontext, tuplen);\n\telse\n\t{\n\t\tbuf = state->slabFreeHead;\n\t\t/* Reuse this slot */\n\t\tstate->slabFreeHead = buf->nextfree;\n\n\t\treturn buf;\n\t}\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define SLAB_SLOT_SIZE 1024"
          ],
          "globals_used": [
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static void *readtup_alloc(Tuplesortstate *state, Size tuplen);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define SLAB_SLOT_SIZE 1024\n\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic void *readtup_alloc(Tuplesortstate *state, Size tuplen);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic void *\nreadtup_alloc(Tuplesortstate *state, Size tuplen)\n{\n\tSlabSlot   *buf;\n\n\t/*\n\t * We pre-allocate enough slots in the slab arena that we should never run\n\t * out.\n\t */\n\tAssert(state->slabFreeHead);\n\n\tif (tuplen > SLAB_SLOT_SIZE || !state->slabFreeHead)\n\t\treturn MemoryContextAlloc(state->sortcontext, tuplen);\n\telse\n\t{\n\t\tbuf = state->slabFreeHead;\n\t\t/* Reuse this slot */\n\t\tstate->slabFreeHead = buf->nextfree;\n\n\t\treturn buf;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic void markrunend(Tuplesortstate *state, int tapenum);\nstatic void *readtup_alloc(Tuplesortstate *state, Size tuplen);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);\nstatic void readtup_heap(Tuplesortstate *state, SortTuple *stup,\n\t\t\t int tapenum, unsigned int len);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);\nstatic void readtup_cluster(Tuplesortstate *state, SortTuple *stup,\n\t\t\t\tint tapenum, unsigned int len);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic void readtup_index(Tuplesortstate *state, SortTuple *stup,\n\t\t\t  int tapenum, unsigned int len);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic void readtup_datum(Tuplesortstate *state, SortTuple *stup,\n\t\t\t  int tapenum, unsigned int len);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\nstatic void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);\n\nstatic void\nreadtup_index(Tuplesortstate *state, SortTuple *stup,\n\t\t\t  int tapenum, unsigned int len)\n{\n\tunsigned int tuplen = len - sizeof(unsigned int);\n\tIndexTuple\ttuple = (IndexTuple) readtup_alloc(state, tuplen);\n\n\tLogicalTapeReadExact(state->tapeset, tapenum,\n\t\t\t\t\t\t tuple, tuplen);\n\tif (state->randomAccess)\t/* need trailing length word? */\n\t\tLogicalTapeReadExact(state->tapeset, tapenum,\n\t\t\t\t\t\t\t &tuplen, sizeof(tuplen));\n\tstup->tuple = (void *) tuple;\n\t/* set up first-column key value */\n\tstup->datum1 = index_getattr(tuple,\n\t\t\t\t\t\t\t\t 1,\n\t\t\t\t\t\t\t\t RelationGetDescr(state->indexRel),\n\t\t\t\t\t\t\t\t &stup->isnull1);\n}"
  },
  {
    "function_name": "writetup_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "4200-4220",
    "snippet": "static void\nwritetup_index(Tuplesortstate *state, int tapenum, SortTuple *stup)\n{\n\tIndexTuple\ttuple = (IndexTuple) stup->tuple;\n\tunsigned int tuplen;\n\n\ttuplen = IndexTupleSize(tuple) + sizeof(tuplen);\n\tLogicalTapeWrite(state->tapeset, tapenum,\n\t\t\t\t\t (void *) &tuplen, sizeof(tuplen));\n\tLogicalTapeWrite(state->tapeset, tapenum,\n\t\t\t\t\t (void *) tuple, IndexTupleSize(tuple));\n\tif (state->randomAccess)\t/* need trailing length word? */\n\t\tLogicalTapeWrite(state->tapeset, tapenum,\n\t\t\t\t\t\t (void *) &tuplen, sizeof(tuplen));\n\n\tif (!state->slabAllocatorUsed)\n\t{\n\t\tFREEMEM(state, GetMemoryChunkSpace(tuple));\n\t\tpfree(tuple);\n\t}\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);",
      "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static void markrunend(Tuplesortstate *state, int tapenum);",
      "static void *readtup_alloc(Tuplesortstate *state, Size tuplen);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);",
      "static void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "tuple"
          ],
          "line": 4218
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "FREEMEM",
          "args": [
            "state",
            "GetMemoryChunkSpace(tuple)"
          ],
          "line": 4217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetMemoryChunkSpace",
          "args": [
            "tuple"
          ],
          "line": 4217
        },
        "resolved": true,
        "details": {
          "function_name": "GetMemoryChunkSpace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "426-432",
          "snippet": "Size\nGetMemoryChunkSpace(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\treturn context->methods->get_chunk_space(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nSize\nGetMemoryChunkSpace(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\treturn context->methods->get_chunk_space(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "LogicalTapeWrite",
          "args": [
            "state->tapeset",
            "tapenum",
            "(void *) &tuplen",
            "sizeof(tuplen)"
          ],
          "line": 4212
        },
        "resolved": true,
        "details": {
          "function_name": "LogicalTapeWrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/logtape.c",
          "lines": "620-694",
          "snippet": "void\nLogicalTapeWrite(LogicalTapeSet *lts, int tapenum,\n\t\t\t\t void *ptr, size_t size)\n{\n\tLogicalTape *lt;\n\tsize_t\t\tnthistime;\n\n\tAssert(tapenum >= 0 && tapenum < lts->nTapes);\n\tlt = &lts->tapes[tapenum];\n\tAssert(lt->writing);\n\tAssert(lt->offsetBlockNumber == 0L);\n\n\t/* Allocate data buffer and first block on first write */\n\tif (lt->buffer == NULL)\n\t{\n\t\tlt->buffer = (char *) palloc(BLCKSZ);\n\t\tlt->buffer_size = BLCKSZ;\n\t}\n\tif (lt->curBlockNumber == -1)\n\t{\n\t\tAssert(lt->firstBlockNumber == -1);\n\t\tAssert(lt->pos == 0);\n\n\t\tlt->curBlockNumber = ltsGetFreeBlock(lts);\n\t\tlt->firstBlockNumber = lt->curBlockNumber;\n\n\t\tTapeBlockGetTrailer(lt->buffer)->prev = -1L;\n\t}\n\n\tAssert(lt->buffer_size == BLCKSZ);\n\twhile (size > 0)\n\t{\n\t\tif (lt->pos >= TapeBlockPayloadSize)\n\t\t{\n\t\t\t/* Buffer full, dump it out */\n\t\t\tlong\t\tnextBlockNumber;\n\n\t\t\tif (!lt->dirty)\n\t\t\t{\n\t\t\t\t/* Hmm, went directly from reading to writing? */\n\t\t\t\telog(ERROR, \"invalid logtape state: should be dirty\");\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * First allocate the next block, so that we can store it in the\n\t\t\t * 'next' pointer of this block.\n\t\t\t */\n\t\t\tnextBlockNumber = ltsGetFreeBlock(lts);\n\n\t\t\t/* set the next-pointer and dump the current block. */\n\t\t\tTapeBlockGetTrailer(lt->buffer)->next = nextBlockNumber;\n\t\t\tltsWriteBlock(lts, lt->curBlockNumber, (void *) lt->buffer);\n\n\t\t\t/* initialize the prev-pointer of the next block */\n\t\t\tTapeBlockGetTrailer(lt->buffer)->prev = lt->curBlockNumber;\n\t\t\tlt->curBlockNumber = nextBlockNumber;\n\t\t\tlt->pos = 0;\n\t\t\tlt->nbytes = 0;\n\t\t}\n\n\t\tnthistime = TapeBlockPayloadSize - lt->pos;\n\t\tif (nthistime > size)\n\t\t\tnthistime = size;\n\t\tAssert(nthistime > 0);\n\n\t\tmemcpy(lt->buffer + lt->pos, ptr, nthistime);\n\n\t\tlt->dirty = true;\n\t\tlt->pos += nthistime;\n\t\tif (lt->nbytes < lt->pos)\n\t\t\tlt->nbytes = lt->pos;\n\t\tptr = (void *) ((char *) ptr + nthistime);\n\t\tsize -= nthistime;\n\t}\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TapeBlockPayloadSize  (BLCKSZ - sizeof(TapeBlockTrailer))"
          ],
          "globals_used": [
            "static void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
            "static void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
            "static long ltsGetFreeBlock(LogicalTapeSet *lts);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/logtape.h\"\n#include \"utils/builtins.h\"\n#include \"storage/buffile.h\"\n#include \"postgres.h\"\n\n#define TapeBlockPayloadSize  (BLCKSZ - sizeof(TapeBlockTrailer))\n\nstatic void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic long ltsGetFreeBlock(LogicalTapeSet *lts);\n\nvoid\nLogicalTapeWrite(LogicalTapeSet *lts, int tapenum,\n\t\t\t\t void *ptr, size_t size)\n{\n\tLogicalTape *lt;\n\tsize_t\t\tnthistime;\n\n\tAssert(tapenum >= 0 && tapenum < lts->nTapes);\n\tlt = &lts->tapes[tapenum];\n\tAssert(lt->writing);\n\tAssert(lt->offsetBlockNumber == 0L);\n\n\t/* Allocate data buffer and first block on first write */\n\tif (lt->buffer == NULL)\n\t{\n\t\tlt->buffer = (char *) palloc(BLCKSZ);\n\t\tlt->buffer_size = BLCKSZ;\n\t}\n\tif (lt->curBlockNumber == -1)\n\t{\n\t\tAssert(lt->firstBlockNumber == -1);\n\t\tAssert(lt->pos == 0);\n\n\t\tlt->curBlockNumber = ltsGetFreeBlock(lts);\n\t\tlt->firstBlockNumber = lt->curBlockNumber;\n\n\t\tTapeBlockGetTrailer(lt->buffer)->prev = -1L;\n\t}\n\n\tAssert(lt->buffer_size == BLCKSZ);\n\twhile (size > 0)\n\t{\n\t\tif (lt->pos >= TapeBlockPayloadSize)\n\t\t{\n\t\t\t/* Buffer full, dump it out */\n\t\t\tlong\t\tnextBlockNumber;\n\n\t\t\tif (!lt->dirty)\n\t\t\t{\n\t\t\t\t/* Hmm, went directly from reading to writing? */\n\t\t\t\telog(ERROR, \"invalid logtape state: should be dirty\");\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * First allocate the next block, so that we can store it in the\n\t\t\t * 'next' pointer of this block.\n\t\t\t */\n\t\t\tnextBlockNumber = ltsGetFreeBlock(lts);\n\n\t\t\t/* set the next-pointer and dump the current block. */\n\t\t\tTapeBlockGetTrailer(lt->buffer)->next = nextBlockNumber;\n\t\t\tltsWriteBlock(lts, lt->curBlockNumber, (void *) lt->buffer);\n\n\t\t\t/* initialize the prev-pointer of the next block */\n\t\t\tTapeBlockGetTrailer(lt->buffer)->prev = lt->curBlockNumber;\n\t\t\tlt->curBlockNumber = nextBlockNumber;\n\t\t\tlt->pos = 0;\n\t\t\tlt->nbytes = 0;\n\t\t}\n\n\t\tnthistime = TapeBlockPayloadSize - lt->pos;\n\t\tif (nthistime > size)\n\t\t\tnthistime = size;\n\t\tAssert(nthistime > 0);\n\n\t\tmemcpy(lt->buffer + lt->pos, ptr, nthistime);\n\n\t\tlt->dirty = true;\n\t\tlt->pos += nthistime;\n\t\tif (lt->nbytes < lt->pos)\n\t\t\tlt->nbytes = lt->pos;\n\t\tptr = (void *) ((char *) ptr + nthistime);\n\t\tsize -= nthistime;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IndexTupleSize",
          "args": [
            "tuple"
          ],
          "line": 4210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IndexTupleSize",
          "args": [
            "tuple"
          ],
          "line": 4206
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic void markrunend(Tuplesortstate *state, int tapenum);\nstatic void *readtup_alloc(Tuplesortstate *state, Size tuplen);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\nstatic void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);\n\nstatic void\nwritetup_index(Tuplesortstate *state, int tapenum, SortTuple *stup)\n{\n\tIndexTuple\ttuple = (IndexTuple) stup->tuple;\n\tunsigned int tuplen;\n\n\ttuplen = IndexTupleSize(tuple) + sizeof(tuplen);\n\tLogicalTapeWrite(state->tapeset, tapenum,\n\t\t\t\t\t (void *) &tuplen, sizeof(tuplen));\n\tLogicalTapeWrite(state->tapeset, tapenum,\n\t\t\t\t\t (void *) tuple, IndexTupleSize(tuple));\n\tif (state->randomAccess)\t/* need trailing length word? */\n\t\tLogicalTapeWrite(state->tapeset, tapenum,\n\t\t\t\t\t\t (void *) &tuplen, sizeof(tuplen));\n\n\tif (!state->slabAllocatorUsed)\n\t{\n\t\tFREEMEM(state, GetMemoryChunkSpace(tuple));\n\t\tpfree(tuple);\n\t}\n}"
  },
  {
    "function_name": "copytup_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "4134-4198",
    "snippet": "static void\ncopytup_index(Tuplesortstate *state, SortTuple *stup, void *tup)\n{\n\tIndexTuple\ttuple = (IndexTuple) tup;\n\tunsigned int tuplen = IndexTupleSize(tuple);\n\tIndexTuple\tnewtuple;\n\tDatum\t\toriginal;\n\n\t/* copy the tuple into sort storage */\n\tnewtuple = (IndexTuple) MemoryContextAlloc(state->tuplecontext, tuplen);\n\tmemcpy(newtuple, tuple, tuplen);\n\tUSEMEM(state, GetMemoryChunkSpace(newtuple));\n\tstup->tuple = (void *) newtuple;\n\t/* set up first-column key value */\n\toriginal = index_getattr(newtuple,\n\t\t\t\t\t\t\t 1,\n\t\t\t\t\t\t\t RelationGetDescr(state->indexRel),\n\t\t\t\t\t\t\t &stup->isnull1);\n\n\tif (!state->sortKeys->abbrev_converter || stup->isnull1)\n\t{\n\t\t/*\n\t\t * Store ordinary Datum representation, or NULL value.  If there is a\n\t\t * converter it won't expect NULL values, and cost model is not\n\t\t * required to account for NULL, so in that case we avoid calling\n\t\t * converter and just set datum1 to zeroed representation (to be\n\t\t * consistent, and to support cheap inequality tests for NULL\n\t\t * abbreviated keys).\n\t\t */\n\t\tstup->datum1 = original;\n\t}\n\telse if (!consider_abort_common(state))\n\t{\n\t\t/* Store abbreviated key representation */\n\t\tstup->datum1 = state->sortKeys->abbrev_converter(original,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t state->sortKeys);\n\t}\n\telse\n\t{\n\t\t/* Abort abbreviation */\n\t\tint\t\t\ti;\n\n\t\tstup->datum1 = original;\n\n\t\t/*\n\t\t * Set state to be consistent with never trying abbreviation.\n\t\t *\n\t\t * Alter datum1 representation in already-copied tuples, so as to\n\t\t * ensure a consistent representation (current tuple was just\n\t\t * handled).  It does not matter if some dumped tuples are already\n\t\t * sorted on tape, since serialized tuples lack abbreviated keys\n\t\t * (TSS_BUILDRUNS state prevents control reaching here in any case).\n\t\t */\n\t\tfor (i = 0; i < state->memtupcount; i++)\n\t\t{\n\t\t\tSortTuple  *mtup = &state->memtuples[i];\n\n\t\t\ttuple = (IndexTuple) mtup->tuple;\n\t\t\tmtup->datum1 = index_getattr(tuple,\n\t\t\t\t\t\t\t\t\t\t 1,\n\t\t\t\t\t\t\t\t\t\t RelationGetDescr(state->indexRel),\n\t\t\t\t\t\t\t\t\t\t &mtup->isnull1);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static void *readtup_alloc(Tuplesortstate *state, Size tuplen);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static void copytup_heap(Tuplesortstate *state, SortTuple *stup, void *tup);",
      "static void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static void copytup_cluster(Tuplesortstate *state, SortTuple *stup, void *tup);",
      "static void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static void copytup_index(Tuplesortstate *state, SortTuple *stup, void *tup);",
      "static void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static void copytup_datum(Tuplesortstate *state, SortTuple *stup, void *tup);",
      "static void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);",
      "static void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "index_getattr",
          "args": [
            "tuple",
            "1",
            "RelationGetDescr(state->indexRel)",
            "&mtup->isnull1"
          ],
          "line": 4192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetDescr",
          "args": [
            "state->indexRel"
          ],
          "line": 4194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "state->sortKeys->abbrev_converter",
          "args": [
            "original",
            "state->sortKeys"
          ],
          "line": 4168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "consider_abort_common",
          "args": [
            "state"
          ],
          "line": 4165
        },
        "resolved": true,
        "details": {
          "function_name": "consider_abort_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "1745-1784",
          "snippet": "static bool\nconsider_abort_common(Tuplesortstate *state)\n{\n\tAssert(state->sortKeys[0].abbrev_converter != NULL);\n\tAssert(state->sortKeys[0].abbrev_abort != NULL);\n\tAssert(state->sortKeys[0].abbrev_full_comparator != NULL);\n\n\t/*\n\t * Check effectiveness of abbreviation optimization.  Consider aborting\n\t * when still within memory limit.\n\t */\n\tif (state->status == TSS_INITIAL &&\n\t\tstate->memtupcount >= state->abbrevNext)\n\t{\n\t\tstate->abbrevNext *= 2;\n\n\t\t/*\n\t\t * Check opclass-supplied abbreviation abort routine.  It may indicate\n\t\t * that abbreviation should not proceed.\n\t\t */\n\t\tif (!state->sortKeys->abbrev_abort(state->memtupcount,\n\t\t\t\t\t\t\t\t\t\t   state->sortKeys))\n\t\t\treturn false;\n\n\t\t/*\n\t\t * Finally, restore authoritative comparator, and indicate that\n\t\t * abbreviation is not in play by setting abbrev_converter to NULL\n\t\t */\n\t\tstate->sortKeys[0].comparator = state->sortKeys[0].abbrev_full_comparator;\n\t\tstate->sortKeys[0].abbrev_converter = NULL;\n\t\t/* Not strictly necessary, but be tidy */\n\t\tstate->sortKeys[0].abbrev_abort = NULL;\n\t\tstate->sortKeys[0].abbrev_full_comparator = NULL;\n\n\t\t/* Give up - expect original pass-by-value representation */\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic bool\nconsider_abort_common(Tuplesortstate *state)\n{\n\tAssert(state->sortKeys[0].abbrev_converter != NULL);\n\tAssert(state->sortKeys[0].abbrev_abort != NULL);\n\tAssert(state->sortKeys[0].abbrev_full_comparator != NULL);\n\n\t/*\n\t * Check effectiveness of abbreviation optimization.  Consider aborting\n\t * when still within memory limit.\n\t */\n\tif (state->status == TSS_INITIAL &&\n\t\tstate->memtupcount >= state->abbrevNext)\n\t{\n\t\tstate->abbrevNext *= 2;\n\n\t\t/*\n\t\t * Check opclass-supplied abbreviation abort routine.  It may indicate\n\t\t * that abbreviation should not proceed.\n\t\t */\n\t\tif (!state->sortKeys->abbrev_abort(state->memtupcount,\n\t\t\t\t\t\t\t\t\t\t   state->sortKeys))\n\t\t\treturn false;\n\n\t\t/*\n\t\t * Finally, restore authoritative comparator, and indicate that\n\t\t * abbreviation is not in play by setting abbrev_converter to NULL\n\t\t */\n\t\tstate->sortKeys[0].comparator = state->sortKeys[0].abbrev_full_comparator;\n\t\tstate->sortKeys[0].abbrev_converter = NULL;\n\t\t/* Not strictly necessary, but be tidy */\n\t\tstate->sortKeys[0].abbrev_abort = NULL;\n\t\tstate->sortKeys[0].abbrev_full_comparator = NULL;\n\n\t\t/* Give up - expect original pass-by-value representation */\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_getattr",
          "args": [
            "newtuple",
            "1",
            "RelationGetDescr(state->indexRel)",
            "&stup->isnull1"
          ],
          "line": 4148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetDescr",
          "args": [
            "state->indexRel"
          ],
          "line": 4150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USEMEM",
          "args": [
            "state",
            "GetMemoryChunkSpace(newtuple)"
          ],
          "line": 4145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetMemoryChunkSpace",
          "args": [
            "newtuple"
          ],
          "line": 4145
        },
        "resolved": true,
        "details": {
          "function_name": "GetMemoryChunkSpace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "426-432",
          "snippet": "Size\nGetMemoryChunkSpace(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\treturn context->methods->get_chunk_space(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nSize\nGetMemoryChunkSpace(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\treturn context->methods->get_chunk_space(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "newtuple",
            "tuple",
            "tuplen"
          ],
          "line": 4144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextAlloc",
          "args": [
            "state->tuplecontext",
            "tuplen"
          ],
          "line": 4143
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1079-1106",
          "snippet": "void *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IndexTupleSize",
          "args": [
            "tuple"
          ],
          "line": 4138
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic void *readtup_alloc(Tuplesortstate *state, Size tuplen);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic void copytup_heap(Tuplesortstate *state, SortTuple *stup, void *tup);\nstatic void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic void copytup_cluster(Tuplesortstate *state, SortTuple *stup, void *tup);\nstatic void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic void copytup_index(Tuplesortstate *state, SortTuple *stup, void *tup);\nstatic void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic void copytup_datum(Tuplesortstate *state, SortTuple *stup, void *tup);\nstatic void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\nstatic void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);\n\nstatic void\ncopytup_index(Tuplesortstate *state, SortTuple *stup, void *tup)\n{\n\tIndexTuple\ttuple = (IndexTuple) tup;\n\tunsigned int tuplen = IndexTupleSize(tuple);\n\tIndexTuple\tnewtuple;\n\tDatum\t\toriginal;\n\n\t/* copy the tuple into sort storage */\n\tnewtuple = (IndexTuple) MemoryContextAlloc(state->tuplecontext, tuplen);\n\tmemcpy(newtuple, tuple, tuplen);\n\tUSEMEM(state, GetMemoryChunkSpace(newtuple));\n\tstup->tuple = (void *) newtuple;\n\t/* set up first-column key value */\n\toriginal = index_getattr(newtuple,\n\t\t\t\t\t\t\t 1,\n\t\t\t\t\t\t\t RelationGetDescr(state->indexRel),\n\t\t\t\t\t\t\t &stup->isnull1);\n\n\tif (!state->sortKeys->abbrev_converter || stup->isnull1)\n\t{\n\t\t/*\n\t\t * Store ordinary Datum representation, or NULL value.  If there is a\n\t\t * converter it won't expect NULL values, and cost model is not\n\t\t * required to account for NULL, so in that case we avoid calling\n\t\t * converter and just set datum1 to zeroed representation (to be\n\t\t * consistent, and to support cheap inequality tests for NULL\n\t\t * abbreviated keys).\n\t\t */\n\t\tstup->datum1 = original;\n\t}\n\telse if (!consider_abort_common(state))\n\t{\n\t\t/* Store abbreviated key representation */\n\t\tstup->datum1 = state->sortKeys->abbrev_converter(original,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t state->sortKeys);\n\t}\n\telse\n\t{\n\t\t/* Abort abbreviation */\n\t\tint\t\t\ti;\n\n\t\tstup->datum1 = original;\n\n\t\t/*\n\t\t * Set state to be consistent with never trying abbreviation.\n\t\t *\n\t\t * Alter datum1 representation in already-copied tuples, so as to\n\t\t * ensure a consistent representation (current tuple was just\n\t\t * handled).  It does not matter if some dumped tuples are already\n\t\t * sorted on tape, since serialized tuples lack abbreviated keys\n\t\t * (TSS_BUILDRUNS state prevents control reaching here in any case).\n\t\t */\n\t\tfor (i = 0; i < state->memtupcount; i++)\n\t\t{\n\t\t\tSortTuple  *mtup = &state->memtuples[i];\n\n\t\t\ttuple = (IndexTuple) mtup->tuple;\n\t\t\tmtup->datum1 = index_getattr(tuple,\n\t\t\t\t\t\t\t\t\t\t 1,\n\t\t\t\t\t\t\t\t\t\t RelationGetDescr(state->indexRel),\n\t\t\t\t\t\t\t\t\t\t &mtup->isnull1);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "comparetup_index_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "4082-4132",
    "snippet": "static int\ncomparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state)\n{\n\tBucket\t\tbucket1;\n\tBucket\t\tbucket2;\n\tIndexTuple\ttuple1;\n\tIndexTuple\ttuple2;\n\n\t/*\n\t * Fetch hash keys and mask off bits we don't want to sort by. We know\n\t * that the first column of the index tuple is the hash key.\n\t */\n\tAssert(!a->isnull1);\n\tbucket1 = _hash_hashkey2bucket(DatumGetUInt32(a->datum1),\n\t\t\t\t\t\t\t\t   state->max_buckets, state->high_mask,\n\t\t\t\t\t\t\t\t   state->low_mask);\n\tAssert(!b->isnull1);\n\tbucket2 = _hash_hashkey2bucket(DatumGetUInt32(b->datum1),\n\t\t\t\t\t\t\t\t   state->max_buckets, state->high_mask,\n\t\t\t\t\t\t\t\t   state->low_mask);\n\tif (bucket1 > bucket2)\n\t\treturn 1;\n\telse if (bucket1 < bucket2)\n\t\treturn -1;\n\n\t/*\n\t * If hash values are equal, we sort on ItemPointer.  This does not affect\n\t * validity of the finished index, but it may be useful to have index\n\t * scans in physical order.\n\t */\n\ttuple1 = (IndexTuple) a->tuple;\n\ttuple2 = (IndexTuple) b->tuple;\n\n\t{\n\t\tBlockNumber blk1 = ItemPointerGetBlockNumber(&tuple1->t_tid);\n\t\tBlockNumber blk2 = ItemPointerGetBlockNumber(&tuple2->t_tid);\n\n\t\tif (blk1 != blk2)\n\t\t\treturn (blk1 < blk2) ? -1 : 1;\n\t}\n\t{\n\t\tOffsetNumber pos1 = ItemPointerGetOffsetNumber(&tuple1->t_tid);\n\t\tOffsetNumber pos2 = ItemPointerGetOffsetNumber(&tuple2->t_tid);\n\n\t\tif (pos1 != pos2)\n\t\t\treturn (pos1 < pos2) ? -1 : 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ItemPointerGetOffsetNumber",
          "args": [
            "&tuple2->t_tid"
          ],
          "line": 4125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ItemPointerGetOffsetNumber",
          "args": [
            "&tuple1->t_tid"
          ],
          "line": 4124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ItemPointerGetBlockNumber",
          "args": [
            "&tuple2->t_tid"
          ],
          "line": 4118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ItemPointerGetBlockNumber",
          "args": [
            "&tuple1->t_tid"
          ],
          "line": 4117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_hash_hashkey2bucket",
          "args": [
            "DatumGetUInt32(b->datum1)",
            "state->max_buckets",
            "state->high_mask",
            "state->low_mask"
          ],
          "line": 4100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetUInt32",
          "args": [
            "b->datum1"
          ],
          "line": 4100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!b->isnull1"
          ],
          "line": 4099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_hash_hashkey2bucket",
          "args": [
            "DatumGetUInt32(a->datum1)",
            "state->max_buckets",
            "state->high_mask",
            "state->low_mask"
          ],
          "line": 4096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetUInt32",
          "args": [
            "a->datum1"
          ],
          "line": 4096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!a->isnull1"
          ],
          "line": 4095
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic int\ncomparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state)\n{\n\tBucket\t\tbucket1;\n\tBucket\t\tbucket2;\n\tIndexTuple\ttuple1;\n\tIndexTuple\ttuple2;\n\n\t/*\n\t * Fetch hash keys and mask off bits we don't want to sort by. We know\n\t * that the first column of the index tuple is the hash key.\n\t */\n\tAssert(!a->isnull1);\n\tbucket1 = _hash_hashkey2bucket(DatumGetUInt32(a->datum1),\n\t\t\t\t\t\t\t\t   state->max_buckets, state->high_mask,\n\t\t\t\t\t\t\t\t   state->low_mask);\n\tAssert(!b->isnull1);\n\tbucket2 = _hash_hashkey2bucket(DatumGetUInt32(b->datum1),\n\t\t\t\t\t\t\t\t   state->max_buckets, state->high_mask,\n\t\t\t\t\t\t\t\t   state->low_mask);\n\tif (bucket1 > bucket2)\n\t\treturn 1;\n\telse if (bucket1 < bucket2)\n\t\treturn -1;\n\n\t/*\n\t * If hash values are equal, we sort on ItemPointer.  This does not affect\n\t * validity of the finished index, but it may be useful to have index\n\t * scans in physical order.\n\t */\n\ttuple1 = (IndexTuple) a->tuple;\n\ttuple2 = (IndexTuple) b->tuple;\n\n\t{\n\t\tBlockNumber blk1 = ItemPointerGetBlockNumber(&tuple1->t_tid);\n\t\tBlockNumber blk2 = ItemPointerGetBlockNumber(&tuple2->t_tid);\n\n\t\tif (blk1 != blk2)\n\t\t\treturn (blk1 < blk2) ? -1 : 1;\n\t}\n\t{\n\t\tOffsetNumber pos1 = ItemPointerGetOffsetNumber(&tuple1->t_tid);\n\t\tOffsetNumber pos2 = ItemPointerGetOffsetNumber(&tuple2->t_tid);\n\n\t\tif (pos1 != pos2)\n\t\t\treturn (pos1 < pos2) ? -1 : 1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "comparetup_index_btree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "3953-4080",
    "snippet": "static int\ncomparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state)\n{\n\t/*\n\t * This is similar to comparetup_heap(), but expects index tuples.  There\n\t * is also special handling for enforcing uniqueness, and special\n\t * treatment for equal keys at the end.\n\t */\n\tSortSupport sortKey = state->sortKeys;\n\tIndexTuple\ttuple1;\n\tIndexTuple\ttuple2;\n\tint\t\t\tkeysz;\n\tTupleDesc\ttupDes;\n\tbool\t\tequal_hasnull = false;\n\tint\t\t\tnkey;\n\tint32\t\tcompare;\n\tDatum\t\tdatum1,\n\t\t\t\tdatum2;\n\tbool\t\tisnull1,\n\t\t\t\tisnull2;\n\n\n\t/* Compare the leading sort key */\n\tcompare = ApplySortComparator(a->datum1, a->isnull1,\n\t\t\t\t\t\t\t\t  b->datum1, b->isnull1,\n\t\t\t\t\t\t\t\t  sortKey);\n\tif (compare != 0)\n\t\treturn compare;\n\n\t/* Compare additional sort keys */\n\ttuple1 = (IndexTuple) a->tuple;\n\ttuple2 = (IndexTuple) b->tuple;\n\tkeysz = state->nKeys;\n\ttupDes = RelationGetDescr(state->indexRel);\n\n\tif (sortKey->abbrev_converter)\n\t{\n\t\tdatum1 = index_getattr(tuple1, 1, tupDes, &isnull1);\n\t\tdatum2 = index_getattr(tuple2, 1, tupDes, &isnull2);\n\n\t\tcompare = ApplySortAbbrevFullComparator(datum1, isnull1,\n\t\t\t\t\t\t\t\t\t\t\t\tdatum2, isnull2,\n\t\t\t\t\t\t\t\t\t\t\t\tsortKey);\n\t\tif (compare != 0)\n\t\t\treturn compare;\n\t}\n\n\t/* they are equal, so we only need to examine one null flag */\n\tif (a->isnull1)\n\t\tequal_hasnull = true;\n\n\tsortKey++;\n\tfor (nkey = 2; nkey <= keysz; nkey++, sortKey++)\n\t{\n\t\tdatum1 = index_getattr(tuple1, nkey, tupDes, &isnull1);\n\t\tdatum2 = index_getattr(tuple2, nkey, tupDes, &isnull2);\n\n\t\tcompare = ApplySortComparator(datum1, isnull1,\n\t\t\t\t\t\t\t\t\t  datum2, isnull2,\n\t\t\t\t\t\t\t\t\t  sortKey);\n\t\tif (compare != 0)\n\t\t\treturn compare;\t\t/* done when we find unequal attributes */\n\n\t\t/* they are equal, so we only need to examine one null flag */\n\t\tif (isnull1)\n\t\t\tequal_hasnull = true;\n\t}\n\n\t/*\n\t * If btree has asked us to enforce uniqueness, complain if two equal\n\t * tuples are detected (unless there was at least one NULL field).\n\t *\n\t * It is sufficient to make the test here, because if two tuples are equal\n\t * they *must* get compared at some stage of the sort --- otherwise the\n\t * sort algorithm wouldn't have checked whether one must appear before the\n\t * other.\n\t */\n\tif (state->enforceUnique && !equal_hasnull)\n\t{\n\t\tDatum\t\tvalues[INDEX_MAX_KEYS];\n\t\tbool\t\tisnull[INDEX_MAX_KEYS];\n\t\tchar\t   *key_desc;\n\n\t\t/*\n\t\t * Some rather brain-dead implementations of qsort (such as the one in\n\t\t * QNX 4) will sometimes call the comparison routine to compare a\n\t\t * value to itself, but we always use our own implementation, which\n\t\t * does not.\n\t\t */\n\t\tAssert(tuple1 != tuple2);\n\n\t\tindex_deform_tuple(tuple1, tupDes, values, isnull);\n\n\t\tkey_desc = BuildIndexValueDescription(state->indexRel, values, isnull);\n\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNIQUE_VIOLATION),\n\t\t\t\t errmsg(\"could not create unique index \\\"%s\\\"\",\n\t\t\t\t\t\tRelationGetRelationName(state->indexRel)),\n\t\t\t\t key_desc ? errdetail(\"Key %s is duplicated.\", key_desc) :\n\t\t\t\t errdetail(\"Duplicate keys exist.\"),\n\t\t\t\t errtableconstraint(state->heapRel,\n\t\t\t\t\t\t\t\t\tRelationGetRelationName(state->indexRel))));\n\t}\n\n\t/*\n\t * If key values are equal, we sort on ItemPointer.  This does not affect\n\t * validity of the finished index, but it may be useful to have index\n\t * scans in physical order.\n\t */\n\t{\n\t\tBlockNumber blk1 = ItemPointerGetBlockNumber(&tuple1->t_tid);\n\t\tBlockNumber blk2 = ItemPointerGetBlockNumber(&tuple2->t_tid);\n\n\t\tif (blk1 != blk2)\n\t\t\treturn (blk1 < blk2) ? -1 : 1;\n\t}\n\t{\n\t\tOffsetNumber pos1 = ItemPointerGetOffsetNumber(&tuple1->t_tid);\n\t\tOffsetNumber pos2 = ItemPointerGetOffsetNumber(&tuple2->t_tid);\n\n\t\tif (pos1 != pos2)\n\t\t\treturn (pos1 < pos2) ? -1 : 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ItemPointerGetOffsetNumber",
          "args": [
            "&tuple2->t_tid"
          ],
          "line": 4073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ItemPointerGetOffsetNumber",
          "args": [
            "&tuple1->t_tid"
          ],
          "line": 4072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ItemPointerGetBlockNumber",
          "args": [
            "&tuple2->t_tid"
          ],
          "line": 4066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ItemPointerGetBlockNumber",
          "args": [
            "&tuple1->t_tid"
          ],
          "line": 4065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_UNIQUE_VIOLATION),\n\t\t\t\t errmsg(\"could not create unique index \\\"%s\\\"\",\n\t\t\t\t\t\tRelationGetRelationName(state->indexRel)),\n\t\t\t\t key_desc ? errdetail(\"Key %s is duplicated.\", key_desc) :\n\t\t\t\t errdetail(\"Duplicate keys exist.\"),\n\t\t\t\t errtableconstraint(state->heapRel,\n\t\t\t\t\t\t\t\t\tRelationGetRelationName(state->indexRel)))"
          ],
          "line": 4049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errtableconstraint",
          "args": [
            "state->heapRel",
            "RelationGetRelationName(state->indexRel)"
          ],
          "line": 4055
        },
        "resolved": true,
        "details": {
          "function_name": "errtableconstraint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "5336-5343",
          "snippet": "int\nerrtableconstraint(Relation rel, const char *conname)\n{\n\terrtable(rel);\n\terr_generic_string(PG_DIAG_CONSTRAINT_NAME, conname);\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nint\nerrtableconstraint(Relation rel, const char *conname)\n{\n\terrtable(rel);\n\terr_generic_string(PG_DIAG_CONSTRAINT_NAME, conname);\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationGetRelationName",
          "args": [
            "state->indexRel"
          ],
          "line": 4056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errdetail",
          "args": [
            "\"Duplicate keys exist.\""
          ],
          "line": 4054
        },
        "resolved": true,
        "details": {
          "function_name": "errdetail_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "918-933",
          "snippet": "int\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not create unique index \\\"%s\\\"\"",
            "RelationGetRelationName(state->indexRel)"
          ],
          "line": 4051
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationGetRelationName",
          "args": [
            "state->indexRel"
          ],
          "line": 4052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_UNIQUE_VIOLATION"
          ],
          "line": 4050
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "BuildIndexValueDescription",
          "args": [
            "state->indexRel",
            "values",
            "isnull"
          ],
          "line": 4047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "index_deform_tuple",
          "args": [
            "tuple1",
            "tupDes",
            "values",
            "isnull"
          ],
          "line": 4045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "tuple1 != tuple2"
          ],
          "line": 4043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ApplySortComparator",
          "args": [
            "datum1",
            "isnull1",
            "datum2",
            "isnull2",
            "sortKey"
          ],
          "line": 4011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "index_getattr",
          "args": [
            "tuple2",
            "nkey",
            "tupDes",
            "&isnull2"
          ],
          "line": 4009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "index_getattr",
          "args": [
            "tuple1",
            "nkey",
            "tupDes",
            "&isnull1"
          ],
          "line": 4008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ApplySortAbbrevFullComparator",
          "args": [
            "datum1",
            "isnull1",
            "datum2",
            "isnull2",
            "sortKey"
          ],
          "line": 3994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "index_getattr",
          "args": [
            "tuple2",
            "1",
            "tupDes",
            "&isnull2"
          ],
          "line": 3992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "index_getattr",
          "args": [
            "tuple1",
            "1",
            "tupDes",
            "&isnull1"
          ],
          "line": 3991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetDescr",
          "args": [
            "state->indexRel"
          ],
          "line": 3987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ApplySortComparator",
          "args": [
            "a->datum1",
            "a->isnull1",
            "b->datum1",
            "b->isnull1",
            "sortKey"
          ],
          "line": 3977
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic int\ncomparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state)\n{\n\t/*\n\t * This is similar to comparetup_heap(), but expects index tuples.  There\n\t * is also special handling for enforcing uniqueness, and special\n\t * treatment for equal keys at the end.\n\t */\n\tSortSupport sortKey = state->sortKeys;\n\tIndexTuple\ttuple1;\n\tIndexTuple\ttuple2;\n\tint\t\t\tkeysz;\n\tTupleDesc\ttupDes;\n\tbool\t\tequal_hasnull = false;\n\tint\t\t\tnkey;\n\tint32\t\tcompare;\n\tDatum\t\tdatum1,\n\t\t\t\tdatum2;\n\tbool\t\tisnull1,\n\t\t\t\tisnull2;\n\n\n\t/* Compare the leading sort key */\n\tcompare = ApplySortComparator(a->datum1, a->isnull1,\n\t\t\t\t\t\t\t\t  b->datum1, b->isnull1,\n\t\t\t\t\t\t\t\t  sortKey);\n\tif (compare != 0)\n\t\treturn compare;\n\n\t/* Compare additional sort keys */\n\ttuple1 = (IndexTuple) a->tuple;\n\ttuple2 = (IndexTuple) b->tuple;\n\tkeysz = state->nKeys;\n\ttupDes = RelationGetDescr(state->indexRel);\n\n\tif (sortKey->abbrev_converter)\n\t{\n\t\tdatum1 = index_getattr(tuple1, 1, tupDes, &isnull1);\n\t\tdatum2 = index_getattr(tuple2, 1, tupDes, &isnull2);\n\n\t\tcompare = ApplySortAbbrevFullComparator(datum1, isnull1,\n\t\t\t\t\t\t\t\t\t\t\t\tdatum2, isnull2,\n\t\t\t\t\t\t\t\t\t\t\t\tsortKey);\n\t\tif (compare != 0)\n\t\t\treturn compare;\n\t}\n\n\t/* they are equal, so we only need to examine one null flag */\n\tif (a->isnull1)\n\t\tequal_hasnull = true;\n\n\tsortKey++;\n\tfor (nkey = 2; nkey <= keysz; nkey++, sortKey++)\n\t{\n\t\tdatum1 = index_getattr(tuple1, nkey, tupDes, &isnull1);\n\t\tdatum2 = index_getattr(tuple2, nkey, tupDes, &isnull2);\n\n\t\tcompare = ApplySortComparator(datum1, isnull1,\n\t\t\t\t\t\t\t\t\t  datum2, isnull2,\n\t\t\t\t\t\t\t\t\t  sortKey);\n\t\tif (compare != 0)\n\t\t\treturn compare;\t\t/* done when we find unequal attributes */\n\n\t\t/* they are equal, so we only need to examine one null flag */\n\t\tif (isnull1)\n\t\t\tequal_hasnull = true;\n\t}\n\n\t/*\n\t * If btree has asked us to enforce uniqueness, complain if two equal\n\t * tuples are detected (unless there was at least one NULL field).\n\t *\n\t * It is sufficient to make the test here, because if two tuples are equal\n\t * they *must* get compared at some stage of the sort --- otherwise the\n\t * sort algorithm wouldn't have checked whether one must appear before the\n\t * other.\n\t */\n\tif (state->enforceUnique && !equal_hasnull)\n\t{\n\t\tDatum\t\tvalues[INDEX_MAX_KEYS];\n\t\tbool\t\tisnull[INDEX_MAX_KEYS];\n\t\tchar\t   *key_desc;\n\n\t\t/*\n\t\t * Some rather brain-dead implementations of qsort (such as the one in\n\t\t * QNX 4) will sometimes call the comparison routine to compare a\n\t\t * value to itself, but we always use our own implementation, which\n\t\t * does not.\n\t\t */\n\t\tAssert(tuple1 != tuple2);\n\n\t\tindex_deform_tuple(tuple1, tupDes, values, isnull);\n\n\t\tkey_desc = BuildIndexValueDescription(state->indexRel, values, isnull);\n\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNIQUE_VIOLATION),\n\t\t\t\t errmsg(\"could not create unique index \\\"%s\\\"\",\n\t\t\t\t\t\tRelationGetRelationName(state->indexRel)),\n\t\t\t\t key_desc ? errdetail(\"Key %s is duplicated.\", key_desc) :\n\t\t\t\t errdetail(\"Duplicate keys exist.\"),\n\t\t\t\t errtableconstraint(state->heapRel,\n\t\t\t\t\t\t\t\t\tRelationGetRelationName(state->indexRel))));\n\t}\n\n\t/*\n\t * If key values are equal, we sort on ItemPointer.  This does not affect\n\t * validity of the finished index, but it may be useful to have index\n\t * scans in physical order.\n\t */\n\t{\n\t\tBlockNumber blk1 = ItemPointerGetBlockNumber(&tuple1->t_tid);\n\t\tBlockNumber blk2 = ItemPointerGetBlockNumber(&tuple2->t_tid);\n\n\t\tif (blk1 != blk2)\n\t\t\treturn (blk1 < blk2) ? -1 : 1;\n\t}\n\t{\n\t\tOffsetNumber pos1 = ItemPointerGetOffsetNumber(&tuple1->t_tid);\n\t\tOffsetNumber pos2 = ItemPointerGetOffsetNumber(&tuple2->t_tid);\n\n\t\tif (pos1 != pos2)\n\t\t\treturn (pos1 < pos2) ? -1 : 1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "readtup_cluster",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "3915-3943",
    "snippet": "static void\nreadtup_cluster(Tuplesortstate *state, SortTuple *stup,\n\t\t\t\tint tapenum, unsigned int tuplen)\n{\n\tunsigned int t_len = tuplen - sizeof(ItemPointerData) - sizeof(int);\n\tHeapTuple\ttuple = (HeapTuple) readtup_alloc(state,\n\t\t\t\t\t\t\t\t\t\t\t\t  t_len + HEAPTUPLESIZE);\n\n\t/* Reconstruct the HeapTupleData header */\n\ttuple->t_data = (HeapTupleHeader) ((char *) tuple + HEAPTUPLESIZE);\n\ttuple->t_len = t_len;\n\tLogicalTapeReadExact(state->tapeset, tapenum,\n\t\t\t\t\t\t &tuple->t_self, sizeof(ItemPointerData));\n\t/* We don't currently bother to reconstruct t_tableOid */\n\ttuple->t_tableOid = InvalidOid;\n\t/* Read in the tuple body */\n\tLogicalTapeReadExact(state->tapeset, tapenum,\n\t\t\t\t\t\t tuple->t_data, tuple->t_len);\n\tif (state->randomAccess)\t/* need trailing length word? */\n\t\tLogicalTapeReadExact(state->tapeset, tapenum,\n\t\t\t\t\t\t\t &tuplen, sizeof(tuplen));\n\tstup->tuple = (void *) tuple;\n\t/* set up first-column key value, if it's a simple column */\n\tif (state->indexInfo->ii_IndexAttrNumbers[0] != 0)\n\t\tstup->datum1 = heap_getattr(tuple,\n\t\t\t\t\t\t\t\t\tstate->indexInfo->ii_IndexAttrNumbers[0],\n\t\t\t\t\t\t\t\t\tstate->tupDesc,\n\t\t\t\t\t\t\t\t\t&stup->isnull1);\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);",
      "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static void markrunend(Tuplesortstate *state, int tapenum);",
      "static void *readtup_alloc(Tuplesortstate *state, Size tuplen);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);",
      "static void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "heap_getattr",
          "args": [
            "tuple",
            "state->indexInfo->ii_IndexAttrNumbers[0]",
            "state->tupDesc",
            "&stup->isnull1"
          ],
          "line": 3939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LogicalTapeReadExact",
          "args": [
            "state->tapeset",
            "tapenum",
            "&tuplen",
            "sizeof(tuplen)"
          ],
          "line": 3934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LogicalTapeReadExact",
          "args": [
            "state->tapeset",
            "tapenum",
            "tuple->t_data",
            "tuple->t_len"
          ],
          "line": 3931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LogicalTapeReadExact",
          "args": [
            "state->tapeset",
            "tapenum",
            "&tuple->t_self",
            "sizeof(ItemPointerData)"
          ],
          "line": 3926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(char *) tuple + HEAPTUPLESIZE"
          ],
          "line": 3924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readtup_alloc",
          "args": [
            "state",
            "t_len + HEAPTUPLESIZE"
          ],
          "line": 3920
        },
        "resolved": true,
        "details": {
          "function_name": "readtup_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "3480-3501",
          "snippet": "static void *\nreadtup_alloc(Tuplesortstate *state, Size tuplen)\n{\n\tSlabSlot   *buf;\n\n\t/*\n\t * We pre-allocate enough slots in the slab arena that we should never run\n\t * out.\n\t */\n\tAssert(state->slabFreeHead);\n\n\tif (tuplen > SLAB_SLOT_SIZE || !state->slabFreeHead)\n\t\treturn MemoryContextAlloc(state->sortcontext, tuplen);\n\telse\n\t{\n\t\tbuf = state->slabFreeHead;\n\t\t/* Reuse this slot */\n\t\tstate->slabFreeHead = buf->nextfree;\n\n\t\treturn buf;\n\t}\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define SLAB_SLOT_SIZE 1024"
          ],
          "globals_used": [
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static void *readtup_alloc(Tuplesortstate *state, Size tuplen);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define SLAB_SLOT_SIZE 1024\n\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic void *readtup_alloc(Tuplesortstate *state, Size tuplen);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic void *\nreadtup_alloc(Tuplesortstate *state, Size tuplen)\n{\n\tSlabSlot   *buf;\n\n\t/*\n\t * We pre-allocate enough slots in the slab arena that we should never run\n\t * out.\n\t */\n\tAssert(state->slabFreeHead);\n\n\tif (tuplen > SLAB_SLOT_SIZE || !state->slabFreeHead)\n\t\treturn MemoryContextAlloc(state->sortcontext, tuplen);\n\telse\n\t{\n\t\tbuf = state->slabFreeHead;\n\t\t/* Reuse this slot */\n\t\tstate->slabFreeHead = buf->nextfree;\n\n\t\treturn buf;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic void markrunend(Tuplesortstate *state, int tapenum);\nstatic void *readtup_alloc(Tuplesortstate *state, Size tuplen);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\nstatic void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);\n\nstatic void\nreadtup_cluster(Tuplesortstate *state, SortTuple *stup,\n\t\t\t\tint tapenum, unsigned int tuplen)\n{\n\tunsigned int t_len = tuplen - sizeof(ItemPointerData) - sizeof(int);\n\tHeapTuple\ttuple = (HeapTuple) readtup_alloc(state,\n\t\t\t\t\t\t\t\t\t\t\t\t  t_len + HEAPTUPLESIZE);\n\n\t/* Reconstruct the HeapTupleData header */\n\ttuple->t_data = (HeapTupleHeader) ((char *) tuple + HEAPTUPLESIZE);\n\ttuple->t_len = t_len;\n\tLogicalTapeReadExact(state->tapeset, tapenum,\n\t\t\t\t\t\t &tuple->t_self, sizeof(ItemPointerData));\n\t/* We don't currently bother to reconstruct t_tableOid */\n\ttuple->t_tableOid = InvalidOid;\n\t/* Read in the tuple body */\n\tLogicalTapeReadExact(state->tapeset, tapenum,\n\t\t\t\t\t\t tuple->t_data, tuple->t_len);\n\tif (state->randomAccess)\t/* need trailing length word? */\n\t\tLogicalTapeReadExact(state->tapeset, tapenum,\n\t\t\t\t\t\t\t &tuplen, sizeof(tuplen));\n\tstup->tuple = (void *) tuple;\n\t/* set up first-column key value, if it's a simple column */\n\tif (state->indexInfo->ii_IndexAttrNumbers[0] != 0)\n\t\tstup->datum1 = heap_getattr(tuple,\n\t\t\t\t\t\t\t\t\tstate->indexInfo->ii_IndexAttrNumbers[0],\n\t\t\t\t\t\t\t\t\tstate->tupDesc,\n\t\t\t\t\t\t\t\t\t&stup->isnull1);\n}"
  },
  {
    "function_name": "writetup_cluster",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "3891-3913",
    "snippet": "static void\nwritetup_cluster(Tuplesortstate *state, int tapenum, SortTuple *stup)\n{\n\tHeapTuple\ttuple = (HeapTuple) stup->tuple;\n\tunsigned int tuplen = tuple->t_len + sizeof(ItemPointerData) + sizeof(int);\n\n\t/* We need to store t_self, but not other fields of HeapTupleData */\n\tLogicalTapeWrite(state->tapeset, tapenum,\n\t\t\t\t\t &tuplen, sizeof(tuplen));\n\tLogicalTapeWrite(state->tapeset, tapenum,\n\t\t\t\t\t &tuple->t_self, sizeof(ItemPointerData));\n\tLogicalTapeWrite(state->tapeset, tapenum,\n\t\t\t\t\t tuple->t_data, tuple->t_len);\n\tif (state->randomAccess)\t/* need trailing length word? */\n\t\tLogicalTapeWrite(state->tapeset, tapenum,\n\t\t\t\t\t\t &tuplen, sizeof(tuplen));\n\n\tif (!state->slabAllocatorUsed)\n\t{\n\t\tFREEMEM(state, GetMemoryChunkSpace(tuple));\n\t\theap_freetuple(tuple);\n\t}\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);",
      "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static void markrunend(Tuplesortstate *state, int tapenum);",
      "static void *readtup_alloc(Tuplesortstate *state, Size tuplen);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);",
      "static void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "heap_freetuple",
          "args": [
            "tuple"
          ],
          "line": 3911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FREEMEM",
          "args": [
            "state",
            "GetMemoryChunkSpace(tuple)"
          ],
          "line": 3910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetMemoryChunkSpace",
          "args": [
            "tuple"
          ],
          "line": 3910
        },
        "resolved": true,
        "details": {
          "function_name": "GetMemoryChunkSpace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "426-432",
          "snippet": "Size\nGetMemoryChunkSpace(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\treturn context->methods->get_chunk_space(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nSize\nGetMemoryChunkSpace(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\treturn context->methods->get_chunk_space(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "LogicalTapeWrite",
          "args": [
            "state->tapeset",
            "tapenum",
            "&tuplen",
            "sizeof(tuplen)"
          ],
          "line": 3905
        },
        "resolved": true,
        "details": {
          "function_name": "LogicalTapeWrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/logtape.c",
          "lines": "620-694",
          "snippet": "void\nLogicalTapeWrite(LogicalTapeSet *lts, int tapenum,\n\t\t\t\t void *ptr, size_t size)\n{\n\tLogicalTape *lt;\n\tsize_t\t\tnthistime;\n\n\tAssert(tapenum >= 0 && tapenum < lts->nTapes);\n\tlt = &lts->tapes[tapenum];\n\tAssert(lt->writing);\n\tAssert(lt->offsetBlockNumber == 0L);\n\n\t/* Allocate data buffer and first block on first write */\n\tif (lt->buffer == NULL)\n\t{\n\t\tlt->buffer = (char *) palloc(BLCKSZ);\n\t\tlt->buffer_size = BLCKSZ;\n\t}\n\tif (lt->curBlockNumber == -1)\n\t{\n\t\tAssert(lt->firstBlockNumber == -1);\n\t\tAssert(lt->pos == 0);\n\n\t\tlt->curBlockNumber = ltsGetFreeBlock(lts);\n\t\tlt->firstBlockNumber = lt->curBlockNumber;\n\n\t\tTapeBlockGetTrailer(lt->buffer)->prev = -1L;\n\t}\n\n\tAssert(lt->buffer_size == BLCKSZ);\n\twhile (size > 0)\n\t{\n\t\tif (lt->pos >= TapeBlockPayloadSize)\n\t\t{\n\t\t\t/* Buffer full, dump it out */\n\t\t\tlong\t\tnextBlockNumber;\n\n\t\t\tif (!lt->dirty)\n\t\t\t{\n\t\t\t\t/* Hmm, went directly from reading to writing? */\n\t\t\t\telog(ERROR, \"invalid logtape state: should be dirty\");\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * First allocate the next block, so that we can store it in the\n\t\t\t * 'next' pointer of this block.\n\t\t\t */\n\t\t\tnextBlockNumber = ltsGetFreeBlock(lts);\n\n\t\t\t/* set the next-pointer and dump the current block. */\n\t\t\tTapeBlockGetTrailer(lt->buffer)->next = nextBlockNumber;\n\t\t\tltsWriteBlock(lts, lt->curBlockNumber, (void *) lt->buffer);\n\n\t\t\t/* initialize the prev-pointer of the next block */\n\t\t\tTapeBlockGetTrailer(lt->buffer)->prev = lt->curBlockNumber;\n\t\t\tlt->curBlockNumber = nextBlockNumber;\n\t\t\tlt->pos = 0;\n\t\t\tlt->nbytes = 0;\n\t\t}\n\n\t\tnthistime = TapeBlockPayloadSize - lt->pos;\n\t\tif (nthistime > size)\n\t\t\tnthistime = size;\n\t\tAssert(nthistime > 0);\n\n\t\tmemcpy(lt->buffer + lt->pos, ptr, nthistime);\n\n\t\tlt->dirty = true;\n\t\tlt->pos += nthistime;\n\t\tif (lt->nbytes < lt->pos)\n\t\t\tlt->nbytes = lt->pos;\n\t\tptr = (void *) ((char *) ptr + nthistime);\n\t\tsize -= nthistime;\n\t}\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TapeBlockPayloadSize  (BLCKSZ - sizeof(TapeBlockTrailer))"
          ],
          "globals_used": [
            "static void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
            "static void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
            "static long ltsGetFreeBlock(LogicalTapeSet *lts);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/logtape.h\"\n#include \"utils/builtins.h\"\n#include \"storage/buffile.h\"\n#include \"postgres.h\"\n\n#define TapeBlockPayloadSize  (BLCKSZ - sizeof(TapeBlockTrailer))\n\nstatic void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic long ltsGetFreeBlock(LogicalTapeSet *lts);\n\nvoid\nLogicalTapeWrite(LogicalTapeSet *lts, int tapenum,\n\t\t\t\t void *ptr, size_t size)\n{\n\tLogicalTape *lt;\n\tsize_t\t\tnthistime;\n\n\tAssert(tapenum >= 0 && tapenum < lts->nTapes);\n\tlt = &lts->tapes[tapenum];\n\tAssert(lt->writing);\n\tAssert(lt->offsetBlockNumber == 0L);\n\n\t/* Allocate data buffer and first block on first write */\n\tif (lt->buffer == NULL)\n\t{\n\t\tlt->buffer = (char *) palloc(BLCKSZ);\n\t\tlt->buffer_size = BLCKSZ;\n\t}\n\tif (lt->curBlockNumber == -1)\n\t{\n\t\tAssert(lt->firstBlockNumber == -1);\n\t\tAssert(lt->pos == 0);\n\n\t\tlt->curBlockNumber = ltsGetFreeBlock(lts);\n\t\tlt->firstBlockNumber = lt->curBlockNumber;\n\n\t\tTapeBlockGetTrailer(lt->buffer)->prev = -1L;\n\t}\n\n\tAssert(lt->buffer_size == BLCKSZ);\n\twhile (size > 0)\n\t{\n\t\tif (lt->pos >= TapeBlockPayloadSize)\n\t\t{\n\t\t\t/* Buffer full, dump it out */\n\t\t\tlong\t\tnextBlockNumber;\n\n\t\t\tif (!lt->dirty)\n\t\t\t{\n\t\t\t\t/* Hmm, went directly from reading to writing? */\n\t\t\t\telog(ERROR, \"invalid logtape state: should be dirty\");\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * First allocate the next block, so that we can store it in the\n\t\t\t * 'next' pointer of this block.\n\t\t\t */\n\t\t\tnextBlockNumber = ltsGetFreeBlock(lts);\n\n\t\t\t/* set the next-pointer and dump the current block. */\n\t\t\tTapeBlockGetTrailer(lt->buffer)->next = nextBlockNumber;\n\t\t\tltsWriteBlock(lts, lt->curBlockNumber, (void *) lt->buffer);\n\n\t\t\t/* initialize the prev-pointer of the next block */\n\t\t\tTapeBlockGetTrailer(lt->buffer)->prev = lt->curBlockNumber;\n\t\t\tlt->curBlockNumber = nextBlockNumber;\n\t\t\tlt->pos = 0;\n\t\t\tlt->nbytes = 0;\n\t\t}\n\n\t\tnthistime = TapeBlockPayloadSize - lt->pos;\n\t\tif (nthistime > size)\n\t\t\tnthistime = size;\n\t\tAssert(nthistime > 0);\n\n\t\tmemcpy(lt->buffer + lt->pos, ptr, nthistime);\n\n\t\tlt->dirty = true;\n\t\tlt->pos += nthistime;\n\t\tif (lt->nbytes < lt->pos)\n\t\t\tlt->nbytes = lt->pos;\n\t\tptr = (void *) ((char *) ptr + nthistime);\n\t\tsize -= nthistime;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic void markrunend(Tuplesortstate *state, int tapenum);\nstatic void *readtup_alloc(Tuplesortstate *state, Size tuplen);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\nstatic void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);\n\nstatic void\nwritetup_cluster(Tuplesortstate *state, int tapenum, SortTuple *stup)\n{\n\tHeapTuple\ttuple = (HeapTuple) stup->tuple;\n\tunsigned int tuplen = tuple->t_len + sizeof(ItemPointerData) + sizeof(int);\n\n\t/* We need to store t_self, but not other fields of HeapTupleData */\n\tLogicalTapeWrite(state->tapeset, tapenum,\n\t\t\t\t\t &tuplen, sizeof(tuplen));\n\tLogicalTapeWrite(state->tapeset, tapenum,\n\t\t\t\t\t &tuple->t_self, sizeof(ItemPointerData));\n\tLogicalTapeWrite(state->tapeset, tapenum,\n\t\t\t\t\t tuple->t_data, tuple->t_len);\n\tif (state->randomAccess)\t/* need trailing length word? */\n\t\tLogicalTapeWrite(state->tapeset, tapenum,\n\t\t\t\t\t\t &tuplen, sizeof(tuplen));\n\n\tif (!state->slabAllocatorUsed)\n\t{\n\t\tFREEMEM(state, GetMemoryChunkSpace(tuple));\n\t\theap_freetuple(tuple);\n\t}\n}"
  },
  {
    "function_name": "copytup_cluster",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "3818-3889",
    "snippet": "static void\ncopytup_cluster(Tuplesortstate *state, SortTuple *stup, void *tup)\n{\n\tHeapTuple\ttuple = (HeapTuple) tup;\n\tDatum\t\toriginal;\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->tuplecontext);\n\n\t/* copy the tuple into sort storage */\n\ttuple = heap_copytuple(tuple);\n\tstup->tuple = (void *) tuple;\n\tUSEMEM(state, GetMemoryChunkSpace(tuple));\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\t/*\n\t * set up first-column key value, and potentially abbreviate, if it's a\n\t * simple column\n\t */\n\tif (state->indexInfo->ii_IndexAttrNumbers[0] == 0)\n\t\treturn;\n\n\toriginal = heap_getattr(tuple,\n\t\t\t\t\t\t\tstate->indexInfo->ii_IndexAttrNumbers[0],\n\t\t\t\t\t\t\tstate->tupDesc,\n\t\t\t\t\t\t\t&stup->isnull1);\n\n\tif (!state->sortKeys->abbrev_converter || stup->isnull1)\n\t{\n\t\t/*\n\t\t * Store ordinary Datum representation, or NULL value.  If there is a\n\t\t * converter it won't expect NULL values, and cost model is not\n\t\t * required to account for NULL, so in that case we avoid calling\n\t\t * converter and just set datum1 to zeroed representation (to be\n\t\t * consistent, and to support cheap inequality tests for NULL\n\t\t * abbreviated keys).\n\t\t */\n\t\tstup->datum1 = original;\n\t}\n\telse if (!consider_abort_common(state))\n\t{\n\t\t/* Store abbreviated key representation */\n\t\tstup->datum1 = state->sortKeys->abbrev_converter(original,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t state->sortKeys);\n\t}\n\telse\n\t{\n\t\t/* Abort abbreviation */\n\t\tint\t\t\ti;\n\n\t\tstup->datum1 = original;\n\n\t\t/*\n\t\t * Set state to be consistent with never trying abbreviation.\n\t\t *\n\t\t * Alter datum1 representation in already-copied tuples, so as to\n\t\t * ensure a consistent representation (current tuple was just\n\t\t * handled).  It does not matter if some dumped tuples are already\n\t\t * sorted on tape, since serialized tuples lack abbreviated keys\n\t\t * (TSS_BUILDRUNS state prevents control reaching here in any case).\n\t\t */\n\t\tfor (i = 0; i < state->memtupcount; i++)\n\t\t{\n\t\t\tSortTuple  *mtup = &state->memtuples[i];\n\n\t\t\ttuple = (HeapTuple) mtup->tuple;\n\t\t\tmtup->datum1 = heap_getattr(tuple,\n\t\t\t\t\t\t\t\t\t\tstate->indexInfo->ii_IndexAttrNumbers[0],\n\t\t\t\t\t\t\t\t\t\tstate->tupDesc,\n\t\t\t\t\t\t\t\t\t\t&mtup->isnull1);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static void copytup_heap(Tuplesortstate *state, SortTuple *stup, void *tup);",
      "static void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static void copytup_cluster(Tuplesortstate *state, SortTuple *stup, void *tup);",
      "static void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static void copytup_index(Tuplesortstate *state, SortTuple *stup, void *tup);",
      "static void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static void copytup_datum(Tuplesortstate *state, SortTuple *stup, void *tup);",
      "static void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);",
      "static void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "heap_getattr",
          "args": [
            "tuple",
            "state->indexInfo->ii_IndexAttrNumbers[0]",
            "state->tupDesc",
            "&mtup->isnull1"
          ],
          "line": 3883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "state->sortKeys->abbrev_converter",
          "args": [
            "original",
            "state->sortKeys"
          ],
          "line": 3859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "consider_abort_common",
          "args": [
            "state"
          ],
          "line": 3856
        },
        "resolved": true,
        "details": {
          "function_name": "consider_abort_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "1745-1784",
          "snippet": "static bool\nconsider_abort_common(Tuplesortstate *state)\n{\n\tAssert(state->sortKeys[0].abbrev_converter != NULL);\n\tAssert(state->sortKeys[0].abbrev_abort != NULL);\n\tAssert(state->sortKeys[0].abbrev_full_comparator != NULL);\n\n\t/*\n\t * Check effectiveness of abbreviation optimization.  Consider aborting\n\t * when still within memory limit.\n\t */\n\tif (state->status == TSS_INITIAL &&\n\t\tstate->memtupcount >= state->abbrevNext)\n\t{\n\t\tstate->abbrevNext *= 2;\n\n\t\t/*\n\t\t * Check opclass-supplied abbreviation abort routine.  It may indicate\n\t\t * that abbreviation should not proceed.\n\t\t */\n\t\tif (!state->sortKeys->abbrev_abort(state->memtupcount,\n\t\t\t\t\t\t\t\t\t\t   state->sortKeys))\n\t\t\treturn false;\n\n\t\t/*\n\t\t * Finally, restore authoritative comparator, and indicate that\n\t\t * abbreviation is not in play by setting abbrev_converter to NULL\n\t\t */\n\t\tstate->sortKeys[0].comparator = state->sortKeys[0].abbrev_full_comparator;\n\t\tstate->sortKeys[0].abbrev_converter = NULL;\n\t\t/* Not strictly necessary, but be tidy */\n\t\tstate->sortKeys[0].abbrev_abort = NULL;\n\t\tstate->sortKeys[0].abbrev_full_comparator = NULL;\n\n\t\t/* Give up - expect original pass-by-value representation */\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic bool\nconsider_abort_common(Tuplesortstate *state)\n{\n\tAssert(state->sortKeys[0].abbrev_converter != NULL);\n\tAssert(state->sortKeys[0].abbrev_abort != NULL);\n\tAssert(state->sortKeys[0].abbrev_full_comparator != NULL);\n\n\t/*\n\t * Check effectiveness of abbreviation optimization.  Consider aborting\n\t * when still within memory limit.\n\t */\n\tif (state->status == TSS_INITIAL &&\n\t\tstate->memtupcount >= state->abbrevNext)\n\t{\n\t\tstate->abbrevNext *= 2;\n\n\t\t/*\n\t\t * Check opclass-supplied abbreviation abort routine.  It may indicate\n\t\t * that abbreviation should not proceed.\n\t\t */\n\t\tif (!state->sortKeys->abbrev_abort(state->memtupcount,\n\t\t\t\t\t\t\t\t\t\t   state->sortKeys))\n\t\t\treturn false;\n\n\t\t/*\n\t\t * Finally, restore authoritative comparator, and indicate that\n\t\t * abbreviation is not in play by setting abbrev_converter to NULL\n\t\t */\n\t\tstate->sortKeys[0].comparator = state->sortKeys[0].abbrev_full_comparator;\n\t\tstate->sortKeys[0].abbrev_converter = NULL;\n\t\t/* Not strictly necessary, but be tidy */\n\t\tstate->sortKeys[0].abbrev_abort = NULL;\n\t\tstate->sortKeys[0].abbrev_full_comparator = NULL;\n\n\t\t/* Give up - expect original pass-by-value representation */\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "heap_getattr",
          "args": [
            "tuple",
            "state->indexInfo->ii_IndexAttrNumbers[0]",
            "state->tupDesc",
            "&stup->isnull1"
          ],
          "line": 3839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 3830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USEMEM",
          "args": [
            "state",
            "GetMemoryChunkSpace(tuple)"
          ],
          "line": 3828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetMemoryChunkSpace",
          "args": [
            "tuple"
          ],
          "line": 3828
        },
        "resolved": true,
        "details": {
          "function_name": "GetMemoryChunkSpace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "426-432",
          "snippet": "Size\nGetMemoryChunkSpace(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\treturn context->methods->get_chunk_space(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nSize\nGetMemoryChunkSpace(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\treturn context->methods->get_chunk_space(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "heap_copytuple",
          "args": [
            "tuple"
          ],
          "line": 3826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "state->tuplecontext"
          ],
          "line": 3823
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic void copytup_heap(Tuplesortstate *state, SortTuple *stup, void *tup);\nstatic void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic void copytup_cluster(Tuplesortstate *state, SortTuple *stup, void *tup);\nstatic void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic void copytup_index(Tuplesortstate *state, SortTuple *stup, void *tup);\nstatic void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic void copytup_datum(Tuplesortstate *state, SortTuple *stup, void *tup);\nstatic void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\nstatic void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);\n\nstatic void\ncopytup_cluster(Tuplesortstate *state, SortTuple *stup, void *tup)\n{\n\tHeapTuple\ttuple = (HeapTuple) tup;\n\tDatum\t\toriginal;\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->tuplecontext);\n\n\t/* copy the tuple into sort storage */\n\ttuple = heap_copytuple(tuple);\n\tstup->tuple = (void *) tuple;\n\tUSEMEM(state, GetMemoryChunkSpace(tuple));\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\t/*\n\t * set up first-column key value, and potentially abbreviate, if it's a\n\t * simple column\n\t */\n\tif (state->indexInfo->ii_IndexAttrNumbers[0] == 0)\n\t\treturn;\n\n\toriginal = heap_getattr(tuple,\n\t\t\t\t\t\t\tstate->indexInfo->ii_IndexAttrNumbers[0],\n\t\t\t\t\t\t\tstate->tupDesc,\n\t\t\t\t\t\t\t&stup->isnull1);\n\n\tif (!state->sortKeys->abbrev_converter || stup->isnull1)\n\t{\n\t\t/*\n\t\t * Store ordinary Datum representation, or NULL value.  If there is a\n\t\t * converter it won't expect NULL values, and cost model is not\n\t\t * required to account for NULL, so in that case we avoid calling\n\t\t * converter and just set datum1 to zeroed representation (to be\n\t\t * consistent, and to support cheap inequality tests for NULL\n\t\t * abbreviated keys).\n\t\t */\n\t\tstup->datum1 = original;\n\t}\n\telse if (!consider_abort_common(state))\n\t{\n\t\t/* Store abbreviated key representation */\n\t\tstup->datum1 = state->sortKeys->abbrev_converter(original,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t state->sortKeys);\n\t}\n\telse\n\t{\n\t\t/* Abort abbreviation */\n\t\tint\t\t\ti;\n\n\t\tstup->datum1 = original;\n\n\t\t/*\n\t\t * Set state to be consistent with never trying abbreviation.\n\t\t *\n\t\t * Alter datum1 representation in already-copied tuples, so as to\n\t\t * ensure a consistent representation (current tuple was just\n\t\t * handled).  It does not matter if some dumped tuples are already\n\t\t * sorted on tape, since serialized tuples lack abbreviated keys\n\t\t * (TSS_BUILDRUNS state prevents control reaching here in any case).\n\t\t */\n\t\tfor (i = 0; i < state->memtupcount; i++)\n\t\t{\n\t\t\tSortTuple  *mtup = &state->memtuples[i];\n\n\t\t\ttuple = (HeapTuple) mtup->tuple;\n\t\t\tmtup->datum1 = heap_getattr(tuple,\n\t\t\t\t\t\t\t\t\t\tstate->indexInfo->ii_IndexAttrNumbers[0],\n\t\t\t\t\t\t\t\t\t\tstate->tupDesc,\n\t\t\t\t\t\t\t\t\t\t&mtup->isnull1);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "comparetup_cluster",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "3707-3816",
    "snippet": "static int\ncomparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state)\n{\n\tSortSupport sortKey = state->sortKeys;\n\tHeapTuple\tltup;\n\tHeapTuple\trtup;\n\tTupleDesc\ttupDesc;\n\tint\t\t\tnkey;\n\tint32\t\tcompare;\n\tDatum\t\tdatum1,\n\t\t\t\tdatum2;\n\tbool\t\tisnull1,\n\t\t\t\tisnull2;\n\tAttrNumber\tleading = state->indexInfo->ii_IndexAttrNumbers[0];\n\n\t/* Be prepared to compare additional sort keys */\n\tltup = (HeapTuple) a->tuple;\n\trtup = (HeapTuple) b->tuple;\n\ttupDesc = state->tupDesc;\n\n\t/* Compare the leading sort key, if it's simple */\n\tif (leading != 0)\n\t{\n\t\tcompare = ApplySortComparator(a->datum1, a->isnull1,\n\t\t\t\t\t\t\t\t\t  b->datum1, b->isnull1,\n\t\t\t\t\t\t\t\t\t  sortKey);\n\t\tif (compare != 0)\n\t\t\treturn compare;\n\n\t\tif (sortKey->abbrev_converter)\n\t\t{\n\t\t\tdatum1 = heap_getattr(ltup, leading, tupDesc, &isnull1);\n\t\t\tdatum2 = heap_getattr(rtup, leading, tupDesc, &isnull2);\n\n\t\t\tcompare = ApplySortAbbrevFullComparator(datum1, isnull1,\n\t\t\t\t\t\t\t\t\t\t\t\t\tdatum2, isnull2,\n\t\t\t\t\t\t\t\t\t\t\t\t\tsortKey);\n\t\t}\n\t\tif (compare != 0 || state->nKeys == 1)\n\t\t\treturn compare;\n\t\t/* Compare additional columns the hard way */\n\t\tsortKey++;\n\t\tnkey = 1;\n\t}\n\telse\n\t{\n\t\t/* Must compare all keys the hard way */\n\t\tnkey = 0;\n\t}\n\n\tif (state->indexInfo->ii_Expressions == NULL)\n\t{\n\t\t/* If not expression index, just compare the proper heap attrs */\n\n\t\tfor (; nkey < state->nKeys; nkey++, sortKey++)\n\t\t{\n\t\t\tAttrNumber\tattno = state->indexInfo->ii_IndexAttrNumbers[nkey];\n\n\t\t\tdatum1 = heap_getattr(ltup, attno, tupDesc, &isnull1);\n\t\t\tdatum2 = heap_getattr(rtup, attno, tupDesc, &isnull2);\n\n\t\t\tcompare = ApplySortComparator(datum1, isnull1,\n\t\t\t\t\t\t\t\t\t\t  datum2, isnull2,\n\t\t\t\t\t\t\t\t\t\t  sortKey);\n\t\t\tif (compare != 0)\n\t\t\t\treturn compare;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * In the expression index case, compute the whole index tuple and\n\t\t * then compare values.  It would perhaps be faster to compute only as\n\t\t * many columns as we need to compare, but that would require\n\t\t * duplicating all the logic in FormIndexDatum.\n\t\t */\n\t\tDatum\t\tl_index_values[INDEX_MAX_KEYS];\n\t\tbool\t\tl_index_isnull[INDEX_MAX_KEYS];\n\t\tDatum\t\tr_index_values[INDEX_MAX_KEYS];\n\t\tbool\t\tr_index_isnull[INDEX_MAX_KEYS];\n\t\tTupleTableSlot *ecxt_scantuple;\n\n\t\t/* Reset context each time to prevent memory leakage */\n\t\tResetPerTupleExprContext(state->estate);\n\n\t\tecxt_scantuple = GetPerTupleExprContext(state->estate)->ecxt_scantuple;\n\n\t\tExecStoreTuple(ltup, ecxt_scantuple, InvalidBuffer, false);\n\t\tFormIndexDatum(state->indexInfo, ecxt_scantuple, state->estate,\n\t\t\t\t\t   l_index_values, l_index_isnull);\n\n\t\tExecStoreTuple(rtup, ecxt_scantuple, InvalidBuffer, false);\n\t\tFormIndexDatum(state->indexInfo, ecxt_scantuple, state->estate,\n\t\t\t\t\t   r_index_values, r_index_isnull);\n\n\t\tfor (; nkey < state->nKeys; nkey++, sortKey++)\n\t\t{\n\t\t\tcompare = ApplySortComparator(l_index_values[nkey],\n\t\t\t\t\t\t\t\t\t\t  l_index_isnull[nkey],\n\t\t\t\t\t\t\t\t\t\t  r_index_values[nkey],\n\t\t\t\t\t\t\t\t\t\t  r_index_isnull[nkey],\n\t\t\t\t\t\t\t\t\t\t  sortKey);\n\t\t\tif (compare != 0)\n\t\t\t\treturn compare;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ApplySortComparator",
          "args": [
            "l_index_values[nkey]",
            "l_index_isnull[nkey]",
            "r_index_values[nkey]",
            "r_index_isnull[nkey]",
            "sortKey"
          ],
          "line": 3805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FormIndexDatum",
          "args": [
            "state->indexInfo",
            "ecxt_scantuple",
            "state->estate",
            "r_index_values",
            "r_index_isnull"
          ],
          "line": 3800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ExecStoreTuple",
          "args": [
            "rtup",
            "ecxt_scantuple",
            "InvalidBuffer",
            "false"
          ],
          "line": 3799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FormIndexDatum",
          "args": [
            "state->indexInfo",
            "ecxt_scantuple",
            "state->estate",
            "l_index_values",
            "l_index_isnull"
          ],
          "line": 3796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ExecStoreTuple",
          "args": [
            "ltup",
            "ecxt_scantuple",
            "InvalidBuffer",
            "false"
          ],
          "line": 3795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetPerTupleExprContext",
          "args": [
            "state->estate"
          ],
          "line": 3793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ResetPerTupleExprContext",
          "args": [
            "state->estate"
          ],
          "line": 3791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ApplySortComparator",
          "args": [
            "datum1",
            "isnull1",
            "datum2",
            "isnull2",
            "sortKey"
          ],
          "line": 3769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_getattr",
          "args": [
            "rtup",
            "attno",
            "tupDesc",
            "&isnull2"
          ],
          "line": 3767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_getattr",
          "args": [
            "ltup",
            "attno",
            "tupDesc",
            "&isnull1"
          ],
          "line": 3766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ApplySortAbbrevFullComparator",
          "args": [
            "datum1",
            "isnull1",
            "datum2",
            "isnull2",
            "sortKey"
          ],
          "line": 3742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_getattr",
          "args": [
            "rtup",
            "leading",
            "tupDesc",
            "&isnull2"
          ],
          "line": 3740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_getattr",
          "args": [
            "ltup",
            "leading",
            "tupDesc",
            "&isnull1"
          ],
          "line": 3739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ApplySortComparator",
          "args": [
            "a->datum1",
            "a->isnull1",
            "b->datum1",
            "b->isnull1",
            "sortKey"
          ],
          "line": 3731
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic int\ncomparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state)\n{\n\tSortSupport sortKey = state->sortKeys;\n\tHeapTuple\tltup;\n\tHeapTuple\trtup;\n\tTupleDesc\ttupDesc;\n\tint\t\t\tnkey;\n\tint32\t\tcompare;\n\tDatum\t\tdatum1,\n\t\t\t\tdatum2;\n\tbool\t\tisnull1,\n\t\t\t\tisnull2;\n\tAttrNumber\tleading = state->indexInfo->ii_IndexAttrNumbers[0];\n\n\t/* Be prepared to compare additional sort keys */\n\tltup = (HeapTuple) a->tuple;\n\trtup = (HeapTuple) b->tuple;\n\ttupDesc = state->tupDesc;\n\n\t/* Compare the leading sort key, if it's simple */\n\tif (leading != 0)\n\t{\n\t\tcompare = ApplySortComparator(a->datum1, a->isnull1,\n\t\t\t\t\t\t\t\t\t  b->datum1, b->isnull1,\n\t\t\t\t\t\t\t\t\t  sortKey);\n\t\tif (compare != 0)\n\t\t\treturn compare;\n\n\t\tif (sortKey->abbrev_converter)\n\t\t{\n\t\t\tdatum1 = heap_getattr(ltup, leading, tupDesc, &isnull1);\n\t\t\tdatum2 = heap_getattr(rtup, leading, tupDesc, &isnull2);\n\n\t\t\tcompare = ApplySortAbbrevFullComparator(datum1, isnull1,\n\t\t\t\t\t\t\t\t\t\t\t\t\tdatum2, isnull2,\n\t\t\t\t\t\t\t\t\t\t\t\t\tsortKey);\n\t\t}\n\t\tif (compare != 0 || state->nKeys == 1)\n\t\t\treturn compare;\n\t\t/* Compare additional columns the hard way */\n\t\tsortKey++;\n\t\tnkey = 1;\n\t}\n\telse\n\t{\n\t\t/* Must compare all keys the hard way */\n\t\tnkey = 0;\n\t}\n\n\tif (state->indexInfo->ii_Expressions == NULL)\n\t{\n\t\t/* If not expression index, just compare the proper heap attrs */\n\n\t\tfor (; nkey < state->nKeys; nkey++, sortKey++)\n\t\t{\n\t\t\tAttrNumber\tattno = state->indexInfo->ii_IndexAttrNumbers[nkey];\n\n\t\t\tdatum1 = heap_getattr(ltup, attno, tupDesc, &isnull1);\n\t\t\tdatum2 = heap_getattr(rtup, attno, tupDesc, &isnull2);\n\n\t\t\tcompare = ApplySortComparator(datum1, isnull1,\n\t\t\t\t\t\t\t\t\t\t  datum2, isnull2,\n\t\t\t\t\t\t\t\t\t\t  sortKey);\n\t\t\tif (compare != 0)\n\t\t\t\treturn compare;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * In the expression index case, compute the whole index tuple and\n\t\t * then compare values.  It would perhaps be faster to compute only as\n\t\t * many columns as we need to compare, but that would require\n\t\t * duplicating all the logic in FormIndexDatum.\n\t\t */\n\t\tDatum\t\tl_index_values[INDEX_MAX_KEYS];\n\t\tbool\t\tl_index_isnull[INDEX_MAX_KEYS];\n\t\tDatum\t\tr_index_values[INDEX_MAX_KEYS];\n\t\tbool\t\tr_index_isnull[INDEX_MAX_KEYS];\n\t\tTupleTableSlot *ecxt_scantuple;\n\n\t\t/* Reset context each time to prevent memory leakage */\n\t\tResetPerTupleExprContext(state->estate);\n\n\t\tecxt_scantuple = GetPerTupleExprContext(state->estate)->ecxt_scantuple;\n\n\t\tExecStoreTuple(ltup, ecxt_scantuple, InvalidBuffer, false);\n\t\tFormIndexDatum(state->indexInfo, ecxt_scantuple, state->estate,\n\t\t\t\t\t   l_index_values, l_index_isnull);\n\n\t\tExecStoreTuple(rtup, ecxt_scantuple, InvalidBuffer, false);\n\t\tFormIndexDatum(state->indexInfo, ecxt_scantuple, state->estate,\n\t\t\t\t\t   r_index_values, r_index_isnull);\n\n\t\tfor (; nkey < state->nKeys; nkey++, sortKey++)\n\t\t{\n\t\t\tcompare = ApplySortComparator(l_index_values[nkey],\n\t\t\t\t\t\t\t\t\t\t  l_index_isnull[nkey],\n\t\t\t\t\t\t\t\t\t\t  r_index_values[nkey],\n\t\t\t\t\t\t\t\t\t\t  r_index_isnull[nkey],\n\t\t\t\t\t\t\t\t\t\t  sortKey);\n\t\t\tif (compare != 0)\n\t\t\t\treturn compare;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "readtup_heap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "3675-3700",
    "snippet": "static void\nreadtup_heap(Tuplesortstate *state, SortTuple *stup,\n\t\t\t int tapenum, unsigned int len)\n{\n\tunsigned int tupbodylen = len - sizeof(int);\n\tunsigned int tuplen = tupbodylen + MINIMAL_TUPLE_DATA_OFFSET;\n\tMinimalTuple tuple = (MinimalTuple) readtup_alloc(state, tuplen);\n\tchar\t   *tupbody = (char *) tuple + MINIMAL_TUPLE_DATA_OFFSET;\n\tHeapTupleData htup;\n\n\t/* read in the tuple proper */\n\ttuple->t_len = tuplen;\n\tLogicalTapeReadExact(state->tapeset, tapenum,\n\t\t\t\t\t\t tupbody, tupbodylen);\n\tif (state->randomAccess)\t/* need trailing length word? */\n\t\tLogicalTapeReadExact(state->tapeset, tapenum,\n\t\t\t\t\t\t\t &tuplen, sizeof(tuplen));\n\tstup->tuple = (void *) tuple;\n\t/* set up first-column key value */\n\thtup.t_len = tuple->t_len + MINIMAL_TUPLE_OFFSET;\n\thtup.t_data = (HeapTupleHeader) ((char *) tuple - MINIMAL_TUPLE_OFFSET);\n\tstup->datum1 = heap_getattr(&htup,\n\t\t\t\t\t\t\t\tstate->sortKeys[0].ssup_attno,\n\t\t\t\t\t\t\t\tstate->tupDesc,\n\t\t\t\t\t\t\t\t&stup->isnull1);\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);",
      "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static void markrunend(Tuplesortstate *state, int tapenum);",
      "static void *readtup_alloc(Tuplesortstate *state, Size tuplen);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);",
      "static void readtup_heap(Tuplesortstate *state, SortTuple *stup,\n\t\t\t int tapenum, unsigned int len);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);",
      "static void readtup_cluster(Tuplesortstate *state, SortTuple *stup,\n\t\t\t\tint tapenum, unsigned int len);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
      "static void readtup_index(Tuplesortstate *state, SortTuple *stup,\n\t\t\t  int tapenum, unsigned int len);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
      "static void readtup_datum(Tuplesortstate *state, SortTuple *stup,\n\t\t\t  int tapenum, unsigned int len);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);",
      "static void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "heap_getattr",
          "args": [
            "&htup",
            "state->sortKeys[0].ssup_attno",
            "state->tupDesc",
            "&stup->isnull1"
          ],
          "line": 3696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(char *) tuple - MINIMAL_TUPLE_OFFSET"
          ],
          "line": 3695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LogicalTapeReadExact",
          "args": [
            "state->tapeset",
            "tapenum",
            "&tuplen",
            "sizeof(tuplen)"
          ],
          "line": 3690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LogicalTapeReadExact",
          "args": [
            "state->tapeset",
            "tapenum",
            "tupbody",
            "tupbodylen"
          ],
          "line": 3687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readtup_alloc",
          "args": [
            "state",
            "tuplen"
          ],
          "line": 3681
        },
        "resolved": true,
        "details": {
          "function_name": "readtup_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "3480-3501",
          "snippet": "static void *\nreadtup_alloc(Tuplesortstate *state, Size tuplen)\n{\n\tSlabSlot   *buf;\n\n\t/*\n\t * We pre-allocate enough slots in the slab arena that we should never run\n\t * out.\n\t */\n\tAssert(state->slabFreeHead);\n\n\tif (tuplen > SLAB_SLOT_SIZE || !state->slabFreeHead)\n\t\treturn MemoryContextAlloc(state->sortcontext, tuplen);\n\telse\n\t{\n\t\tbuf = state->slabFreeHead;\n\t\t/* Reuse this slot */\n\t\tstate->slabFreeHead = buf->nextfree;\n\n\t\treturn buf;\n\t}\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define SLAB_SLOT_SIZE 1024"
          ],
          "globals_used": [
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static void *readtup_alloc(Tuplesortstate *state, Size tuplen);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define SLAB_SLOT_SIZE 1024\n\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic void *readtup_alloc(Tuplesortstate *state, Size tuplen);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic void *\nreadtup_alloc(Tuplesortstate *state, Size tuplen)\n{\n\tSlabSlot   *buf;\n\n\t/*\n\t * We pre-allocate enough slots in the slab arena that we should never run\n\t * out.\n\t */\n\tAssert(state->slabFreeHead);\n\n\tif (tuplen > SLAB_SLOT_SIZE || !state->slabFreeHead)\n\t\treturn MemoryContextAlloc(state->sortcontext, tuplen);\n\telse\n\t{\n\t\tbuf = state->slabFreeHead;\n\t\t/* Reuse this slot */\n\t\tstate->slabFreeHead = buf->nextfree;\n\n\t\treturn buf;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic void markrunend(Tuplesortstate *state, int tapenum);\nstatic void *readtup_alloc(Tuplesortstate *state, Size tuplen);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);\nstatic void readtup_heap(Tuplesortstate *state, SortTuple *stup,\n\t\t\t int tapenum, unsigned int len);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);\nstatic void readtup_cluster(Tuplesortstate *state, SortTuple *stup,\n\t\t\t\tint tapenum, unsigned int len);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic void readtup_index(Tuplesortstate *state, SortTuple *stup,\n\t\t\t  int tapenum, unsigned int len);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic void readtup_datum(Tuplesortstate *state, SortTuple *stup,\n\t\t\t  int tapenum, unsigned int len);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\nstatic void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);\n\nstatic void\nreadtup_heap(Tuplesortstate *state, SortTuple *stup,\n\t\t\t int tapenum, unsigned int len)\n{\n\tunsigned int tupbodylen = len - sizeof(int);\n\tunsigned int tuplen = tupbodylen + MINIMAL_TUPLE_DATA_OFFSET;\n\tMinimalTuple tuple = (MinimalTuple) readtup_alloc(state, tuplen);\n\tchar\t   *tupbody = (char *) tuple + MINIMAL_TUPLE_DATA_OFFSET;\n\tHeapTupleData htup;\n\n\t/* read in the tuple proper */\n\ttuple->t_len = tuplen;\n\tLogicalTapeReadExact(state->tapeset, tapenum,\n\t\t\t\t\t\t tupbody, tupbodylen);\n\tif (state->randomAccess)\t/* need trailing length word? */\n\t\tLogicalTapeReadExact(state->tapeset, tapenum,\n\t\t\t\t\t\t\t &tuplen, sizeof(tuplen));\n\tstup->tuple = (void *) tuple;\n\t/* set up first-column key value */\n\thtup.t_len = tuple->t_len + MINIMAL_TUPLE_OFFSET;\n\thtup.t_data = (HeapTupleHeader) ((char *) tuple - MINIMAL_TUPLE_OFFSET);\n\tstup->datum1 = heap_getattr(&htup,\n\t\t\t\t\t\t\t\tstate->sortKeys[0].ssup_attno,\n\t\t\t\t\t\t\t\tstate->tupDesc,\n\t\t\t\t\t\t\t\t&stup->isnull1);\n}"
  },
  {
    "function_name": "writetup_heap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "3648-3673",
    "snippet": "static void\nwritetup_heap(Tuplesortstate *state, int tapenum, SortTuple *stup)\n{\n\tMinimalTuple tuple = (MinimalTuple) stup->tuple;\n\n\t/* the part of the MinimalTuple we'll write: */\n\tchar\t   *tupbody = (char *) tuple + MINIMAL_TUPLE_DATA_OFFSET;\n\tunsigned int tupbodylen = tuple->t_len - MINIMAL_TUPLE_DATA_OFFSET;\n\n\t/* total on-disk footprint: */\n\tunsigned int tuplen = tupbodylen + sizeof(int);\n\n\tLogicalTapeWrite(state->tapeset, tapenum,\n\t\t\t\t\t (void *) &tuplen, sizeof(tuplen));\n\tLogicalTapeWrite(state->tapeset, tapenum,\n\t\t\t\t\t (void *) tupbody, tupbodylen);\n\tif (state->randomAccess)\t/* need trailing length word? */\n\t\tLogicalTapeWrite(state->tapeset, tapenum,\n\t\t\t\t\t\t (void *) &tuplen, sizeof(tuplen));\n\n\tif (!state->slabAllocatorUsed)\n\t{\n\t\tFREEMEM(state, GetMemoryChunkSpace(tuple));\n\t\theap_free_minimal_tuple(tuple);\n\t}\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);",
      "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static void markrunend(Tuplesortstate *state, int tapenum);",
      "static void *readtup_alloc(Tuplesortstate *state, Size tuplen);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);",
      "static void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "heap_free_minimal_tuple",
          "args": [
            "tuple"
          ],
          "line": 3671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FREEMEM",
          "args": [
            "state",
            "GetMemoryChunkSpace(tuple)"
          ],
          "line": 3670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetMemoryChunkSpace",
          "args": [
            "tuple"
          ],
          "line": 3670
        },
        "resolved": true,
        "details": {
          "function_name": "GetMemoryChunkSpace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "426-432",
          "snippet": "Size\nGetMemoryChunkSpace(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\treturn context->methods->get_chunk_space(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nSize\nGetMemoryChunkSpace(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\treturn context->methods->get_chunk_space(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "LogicalTapeWrite",
          "args": [
            "state->tapeset",
            "tapenum",
            "(void *) &tuplen",
            "sizeof(tuplen)"
          ],
          "line": 3665
        },
        "resolved": true,
        "details": {
          "function_name": "LogicalTapeWrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/logtape.c",
          "lines": "620-694",
          "snippet": "void\nLogicalTapeWrite(LogicalTapeSet *lts, int tapenum,\n\t\t\t\t void *ptr, size_t size)\n{\n\tLogicalTape *lt;\n\tsize_t\t\tnthistime;\n\n\tAssert(tapenum >= 0 && tapenum < lts->nTapes);\n\tlt = &lts->tapes[tapenum];\n\tAssert(lt->writing);\n\tAssert(lt->offsetBlockNumber == 0L);\n\n\t/* Allocate data buffer and first block on first write */\n\tif (lt->buffer == NULL)\n\t{\n\t\tlt->buffer = (char *) palloc(BLCKSZ);\n\t\tlt->buffer_size = BLCKSZ;\n\t}\n\tif (lt->curBlockNumber == -1)\n\t{\n\t\tAssert(lt->firstBlockNumber == -1);\n\t\tAssert(lt->pos == 0);\n\n\t\tlt->curBlockNumber = ltsGetFreeBlock(lts);\n\t\tlt->firstBlockNumber = lt->curBlockNumber;\n\n\t\tTapeBlockGetTrailer(lt->buffer)->prev = -1L;\n\t}\n\n\tAssert(lt->buffer_size == BLCKSZ);\n\twhile (size > 0)\n\t{\n\t\tif (lt->pos >= TapeBlockPayloadSize)\n\t\t{\n\t\t\t/* Buffer full, dump it out */\n\t\t\tlong\t\tnextBlockNumber;\n\n\t\t\tif (!lt->dirty)\n\t\t\t{\n\t\t\t\t/* Hmm, went directly from reading to writing? */\n\t\t\t\telog(ERROR, \"invalid logtape state: should be dirty\");\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * First allocate the next block, so that we can store it in the\n\t\t\t * 'next' pointer of this block.\n\t\t\t */\n\t\t\tnextBlockNumber = ltsGetFreeBlock(lts);\n\n\t\t\t/* set the next-pointer and dump the current block. */\n\t\t\tTapeBlockGetTrailer(lt->buffer)->next = nextBlockNumber;\n\t\t\tltsWriteBlock(lts, lt->curBlockNumber, (void *) lt->buffer);\n\n\t\t\t/* initialize the prev-pointer of the next block */\n\t\t\tTapeBlockGetTrailer(lt->buffer)->prev = lt->curBlockNumber;\n\t\t\tlt->curBlockNumber = nextBlockNumber;\n\t\t\tlt->pos = 0;\n\t\t\tlt->nbytes = 0;\n\t\t}\n\n\t\tnthistime = TapeBlockPayloadSize - lt->pos;\n\t\tif (nthistime > size)\n\t\t\tnthistime = size;\n\t\tAssert(nthistime > 0);\n\n\t\tmemcpy(lt->buffer + lt->pos, ptr, nthistime);\n\n\t\tlt->dirty = true;\n\t\tlt->pos += nthistime;\n\t\tif (lt->nbytes < lt->pos)\n\t\t\tlt->nbytes = lt->pos;\n\t\tptr = (void *) ((char *) ptr + nthistime);\n\t\tsize -= nthistime;\n\t}\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TapeBlockPayloadSize  (BLCKSZ - sizeof(TapeBlockTrailer))"
          ],
          "globals_used": [
            "static void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
            "static void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
            "static long ltsGetFreeBlock(LogicalTapeSet *lts);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/logtape.h\"\n#include \"utils/builtins.h\"\n#include \"storage/buffile.h\"\n#include \"postgres.h\"\n\n#define TapeBlockPayloadSize  (BLCKSZ - sizeof(TapeBlockTrailer))\n\nstatic void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic long ltsGetFreeBlock(LogicalTapeSet *lts);\n\nvoid\nLogicalTapeWrite(LogicalTapeSet *lts, int tapenum,\n\t\t\t\t void *ptr, size_t size)\n{\n\tLogicalTape *lt;\n\tsize_t\t\tnthistime;\n\n\tAssert(tapenum >= 0 && tapenum < lts->nTapes);\n\tlt = &lts->tapes[tapenum];\n\tAssert(lt->writing);\n\tAssert(lt->offsetBlockNumber == 0L);\n\n\t/* Allocate data buffer and first block on first write */\n\tif (lt->buffer == NULL)\n\t{\n\t\tlt->buffer = (char *) palloc(BLCKSZ);\n\t\tlt->buffer_size = BLCKSZ;\n\t}\n\tif (lt->curBlockNumber == -1)\n\t{\n\t\tAssert(lt->firstBlockNumber == -1);\n\t\tAssert(lt->pos == 0);\n\n\t\tlt->curBlockNumber = ltsGetFreeBlock(lts);\n\t\tlt->firstBlockNumber = lt->curBlockNumber;\n\n\t\tTapeBlockGetTrailer(lt->buffer)->prev = -1L;\n\t}\n\n\tAssert(lt->buffer_size == BLCKSZ);\n\twhile (size > 0)\n\t{\n\t\tif (lt->pos >= TapeBlockPayloadSize)\n\t\t{\n\t\t\t/* Buffer full, dump it out */\n\t\t\tlong\t\tnextBlockNumber;\n\n\t\t\tif (!lt->dirty)\n\t\t\t{\n\t\t\t\t/* Hmm, went directly from reading to writing? */\n\t\t\t\telog(ERROR, \"invalid logtape state: should be dirty\");\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * First allocate the next block, so that we can store it in the\n\t\t\t * 'next' pointer of this block.\n\t\t\t */\n\t\t\tnextBlockNumber = ltsGetFreeBlock(lts);\n\n\t\t\t/* set the next-pointer and dump the current block. */\n\t\t\tTapeBlockGetTrailer(lt->buffer)->next = nextBlockNumber;\n\t\t\tltsWriteBlock(lts, lt->curBlockNumber, (void *) lt->buffer);\n\n\t\t\t/* initialize the prev-pointer of the next block */\n\t\t\tTapeBlockGetTrailer(lt->buffer)->prev = lt->curBlockNumber;\n\t\t\tlt->curBlockNumber = nextBlockNumber;\n\t\t\tlt->pos = 0;\n\t\t\tlt->nbytes = 0;\n\t\t}\n\n\t\tnthistime = TapeBlockPayloadSize - lt->pos;\n\t\tif (nthistime > size)\n\t\t\tnthistime = size;\n\t\tAssert(nthistime > 0);\n\n\t\tmemcpy(lt->buffer + lt->pos, ptr, nthistime);\n\n\t\tlt->dirty = true;\n\t\tlt->pos += nthistime;\n\t\tif (lt->nbytes < lt->pos)\n\t\t\tlt->nbytes = lt->pos;\n\t\tptr = (void *) ((char *) ptr + nthistime);\n\t\tsize -= nthistime;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic void markrunend(Tuplesortstate *state, int tapenum);\nstatic void *readtup_alloc(Tuplesortstate *state, Size tuplen);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\nstatic void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);\n\nstatic void\nwritetup_heap(Tuplesortstate *state, int tapenum, SortTuple *stup)\n{\n\tMinimalTuple tuple = (MinimalTuple) stup->tuple;\n\n\t/* the part of the MinimalTuple we'll write: */\n\tchar\t   *tupbody = (char *) tuple + MINIMAL_TUPLE_DATA_OFFSET;\n\tunsigned int tupbodylen = tuple->t_len - MINIMAL_TUPLE_DATA_OFFSET;\n\n\t/* total on-disk footprint: */\n\tunsigned int tuplen = tupbodylen + sizeof(int);\n\n\tLogicalTapeWrite(state->tapeset, tapenum,\n\t\t\t\t\t (void *) &tuplen, sizeof(tuplen));\n\tLogicalTapeWrite(state->tapeset, tapenum,\n\t\t\t\t\t (void *) tupbody, tupbodylen);\n\tif (state->randomAccess)\t/* need trailing length word? */\n\t\tLogicalTapeWrite(state->tapeset, tapenum,\n\t\t\t\t\t\t (void *) &tuplen, sizeof(tuplen));\n\n\tif (!state->slabAllocatorUsed)\n\t{\n\t\tFREEMEM(state, GetMemoryChunkSpace(tuple));\n\t\theap_free_minimal_tuple(tuple);\n\t}\n}"
  },
  {
    "function_name": "copytup_heap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "3570-3646",
    "snippet": "static void\ncopytup_heap(Tuplesortstate *state, SortTuple *stup, void *tup)\n{\n\t/*\n\t * We expect the passed \"tup\" to be a TupleTableSlot, and form a\n\t * MinimalTuple using the exported interface for that.\n\t */\n\tTupleTableSlot *slot = (TupleTableSlot *) tup;\n\tDatum\t\toriginal;\n\tMinimalTuple tuple;\n\tHeapTupleData htup;\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->tuplecontext);\n\n\t/* copy the tuple into sort storage */\n\ttuple = ExecCopySlotMinimalTuple(slot);\n\tstup->tuple = (void *) tuple;\n\tUSEMEM(state, GetMemoryChunkSpace(tuple));\n\t/* set up first-column key value */\n\thtup.t_len = tuple->t_len + MINIMAL_TUPLE_OFFSET;\n\thtup.t_data = (HeapTupleHeader) ((char *) tuple - MINIMAL_TUPLE_OFFSET);\n\toriginal = heap_getattr(&htup,\n\t\t\t\t\t\t\tstate->sortKeys[0].ssup_attno,\n\t\t\t\t\t\t\tstate->tupDesc,\n\t\t\t\t\t\t\t&stup->isnull1);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\tif (!state->sortKeys->abbrev_converter || stup->isnull1)\n\t{\n\t\t/*\n\t\t * Store ordinary Datum representation, or NULL value.  If there is a\n\t\t * converter it won't expect NULL values, and cost model is not\n\t\t * required to account for NULL, so in that case we avoid calling\n\t\t * converter and just set datum1 to zeroed representation (to be\n\t\t * consistent, and to support cheap inequality tests for NULL\n\t\t * abbreviated keys).\n\t\t */\n\t\tstup->datum1 = original;\n\t}\n\telse if (!consider_abort_common(state))\n\t{\n\t\t/* Store abbreviated key representation */\n\t\tstup->datum1 = state->sortKeys->abbrev_converter(original,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t state->sortKeys);\n\t}\n\telse\n\t{\n\t\t/* Abort abbreviation */\n\t\tint\t\t\ti;\n\n\t\tstup->datum1 = original;\n\n\t\t/*\n\t\t * Set state to be consistent with never trying abbreviation.\n\t\t *\n\t\t * Alter datum1 representation in already-copied tuples, so as to\n\t\t * ensure a consistent representation (current tuple was just\n\t\t * handled).  It does not matter if some dumped tuples are already\n\t\t * sorted on tape, since serialized tuples lack abbreviated keys\n\t\t * (TSS_BUILDRUNS state prevents control reaching here in any case).\n\t\t */\n\t\tfor (i = 0; i < state->memtupcount; i++)\n\t\t{\n\t\t\tSortTuple  *mtup = &state->memtuples[i];\n\n\t\t\thtup.t_len = ((MinimalTuple) mtup->tuple)->t_len +\n\t\t\t\tMINIMAL_TUPLE_OFFSET;\n\t\t\thtup.t_data = (HeapTupleHeader) ((char *) mtup->tuple -\n\t\t\t\t\t\t\t\t\t\t\t MINIMAL_TUPLE_OFFSET);\n\n\t\t\tmtup->datum1 = heap_getattr(&htup,\n\t\t\t\t\t\t\t\t\t\tstate->sortKeys[0].ssup_attno,\n\t\t\t\t\t\t\t\t\t\tstate->tupDesc,\n\t\t\t\t\t\t\t\t\t\t&mtup->isnull1);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static void copytup_heap(Tuplesortstate *state, SortTuple *stup, void *tup);",
      "static void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static void copytup_cluster(Tuplesortstate *state, SortTuple *stup, void *tup);",
      "static void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static void copytup_index(Tuplesortstate *state, SortTuple *stup, void *tup);",
      "static void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static void copytup_datum(Tuplesortstate *state, SortTuple *stup, void *tup);",
      "static void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);",
      "static void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "heap_getattr",
          "args": [
            "&htup",
            "state->sortKeys[0].ssup_attno",
            "state->tupDesc",
            "&mtup->isnull1"
          ],
          "line": 3640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(char *) mtup->tuple -\n\t\t\t\t\t\t\t\t\t\t\t MINIMAL_TUPLE_OFFSET"
          ],
          "line": 3637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "state->sortKeys->abbrev_converter",
          "args": [
            "original",
            "state->sortKeys"
          ],
          "line": 3612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "consider_abort_common",
          "args": [
            "state"
          ],
          "line": 3609
        },
        "resolved": true,
        "details": {
          "function_name": "consider_abort_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "1745-1784",
          "snippet": "static bool\nconsider_abort_common(Tuplesortstate *state)\n{\n\tAssert(state->sortKeys[0].abbrev_converter != NULL);\n\tAssert(state->sortKeys[0].abbrev_abort != NULL);\n\tAssert(state->sortKeys[0].abbrev_full_comparator != NULL);\n\n\t/*\n\t * Check effectiveness of abbreviation optimization.  Consider aborting\n\t * when still within memory limit.\n\t */\n\tif (state->status == TSS_INITIAL &&\n\t\tstate->memtupcount >= state->abbrevNext)\n\t{\n\t\tstate->abbrevNext *= 2;\n\n\t\t/*\n\t\t * Check opclass-supplied abbreviation abort routine.  It may indicate\n\t\t * that abbreviation should not proceed.\n\t\t */\n\t\tif (!state->sortKeys->abbrev_abort(state->memtupcount,\n\t\t\t\t\t\t\t\t\t\t   state->sortKeys))\n\t\t\treturn false;\n\n\t\t/*\n\t\t * Finally, restore authoritative comparator, and indicate that\n\t\t * abbreviation is not in play by setting abbrev_converter to NULL\n\t\t */\n\t\tstate->sortKeys[0].comparator = state->sortKeys[0].abbrev_full_comparator;\n\t\tstate->sortKeys[0].abbrev_converter = NULL;\n\t\t/* Not strictly necessary, but be tidy */\n\t\tstate->sortKeys[0].abbrev_abort = NULL;\n\t\tstate->sortKeys[0].abbrev_full_comparator = NULL;\n\n\t\t/* Give up - expect original pass-by-value representation */\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic bool\nconsider_abort_common(Tuplesortstate *state)\n{\n\tAssert(state->sortKeys[0].abbrev_converter != NULL);\n\tAssert(state->sortKeys[0].abbrev_abort != NULL);\n\tAssert(state->sortKeys[0].abbrev_full_comparator != NULL);\n\n\t/*\n\t * Check effectiveness of abbreviation optimization.  Consider aborting\n\t * when still within memory limit.\n\t */\n\tif (state->status == TSS_INITIAL &&\n\t\tstate->memtupcount >= state->abbrevNext)\n\t{\n\t\tstate->abbrevNext *= 2;\n\n\t\t/*\n\t\t * Check opclass-supplied abbreviation abort routine.  It may indicate\n\t\t * that abbreviation should not proceed.\n\t\t */\n\t\tif (!state->sortKeys->abbrev_abort(state->memtupcount,\n\t\t\t\t\t\t\t\t\t\t   state->sortKeys))\n\t\t\treturn false;\n\n\t\t/*\n\t\t * Finally, restore authoritative comparator, and indicate that\n\t\t * abbreviation is not in play by setting abbrev_converter to NULL\n\t\t */\n\t\tstate->sortKeys[0].comparator = state->sortKeys[0].abbrev_full_comparator;\n\t\tstate->sortKeys[0].abbrev_converter = NULL;\n\t\t/* Not strictly necessary, but be tidy */\n\t\tstate->sortKeys[0].abbrev_abort = NULL;\n\t\tstate->sortKeys[0].abbrev_full_comparator = NULL;\n\n\t\t/* Give up - expect original pass-by-value representation */\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 3595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_getattr",
          "args": [
            "&htup",
            "state->sortKeys[0].ssup_attno",
            "state->tupDesc",
            "&stup->isnull1"
          ],
          "line": 3590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(char *) tuple - MINIMAL_TUPLE_OFFSET"
          ],
          "line": 3589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USEMEM",
          "args": [
            "state",
            "GetMemoryChunkSpace(tuple)"
          ],
          "line": 3586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetMemoryChunkSpace",
          "args": [
            "tuple"
          ],
          "line": 3586
        },
        "resolved": true,
        "details": {
          "function_name": "GetMemoryChunkSpace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "426-432",
          "snippet": "Size\nGetMemoryChunkSpace(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\treturn context->methods->get_chunk_space(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nSize\nGetMemoryChunkSpace(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\treturn context->methods->get_chunk_space(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ExecCopySlotMinimalTuple",
          "args": [
            "slot"
          ],
          "line": 3584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "state->tuplecontext"
          ],
          "line": 3581
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic void copytup_heap(Tuplesortstate *state, SortTuple *stup, void *tup);\nstatic void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic void copytup_cluster(Tuplesortstate *state, SortTuple *stup, void *tup);\nstatic void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic void copytup_index(Tuplesortstate *state, SortTuple *stup, void *tup);\nstatic void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic void copytup_datum(Tuplesortstate *state, SortTuple *stup, void *tup);\nstatic void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\nstatic void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);\n\nstatic void\ncopytup_heap(Tuplesortstate *state, SortTuple *stup, void *tup)\n{\n\t/*\n\t * We expect the passed \"tup\" to be a TupleTableSlot, and form a\n\t * MinimalTuple using the exported interface for that.\n\t */\n\tTupleTableSlot *slot = (TupleTableSlot *) tup;\n\tDatum\t\toriginal;\n\tMinimalTuple tuple;\n\tHeapTupleData htup;\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->tuplecontext);\n\n\t/* copy the tuple into sort storage */\n\ttuple = ExecCopySlotMinimalTuple(slot);\n\tstup->tuple = (void *) tuple;\n\tUSEMEM(state, GetMemoryChunkSpace(tuple));\n\t/* set up first-column key value */\n\thtup.t_len = tuple->t_len + MINIMAL_TUPLE_OFFSET;\n\thtup.t_data = (HeapTupleHeader) ((char *) tuple - MINIMAL_TUPLE_OFFSET);\n\toriginal = heap_getattr(&htup,\n\t\t\t\t\t\t\tstate->sortKeys[0].ssup_attno,\n\t\t\t\t\t\t\tstate->tupDesc,\n\t\t\t\t\t\t\t&stup->isnull1);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\tif (!state->sortKeys->abbrev_converter || stup->isnull1)\n\t{\n\t\t/*\n\t\t * Store ordinary Datum representation, or NULL value.  If there is a\n\t\t * converter it won't expect NULL values, and cost model is not\n\t\t * required to account for NULL, so in that case we avoid calling\n\t\t * converter and just set datum1 to zeroed representation (to be\n\t\t * consistent, and to support cheap inequality tests for NULL\n\t\t * abbreviated keys).\n\t\t */\n\t\tstup->datum1 = original;\n\t}\n\telse if (!consider_abort_common(state))\n\t{\n\t\t/* Store abbreviated key representation */\n\t\tstup->datum1 = state->sortKeys->abbrev_converter(original,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t state->sortKeys);\n\t}\n\telse\n\t{\n\t\t/* Abort abbreviation */\n\t\tint\t\t\ti;\n\n\t\tstup->datum1 = original;\n\n\t\t/*\n\t\t * Set state to be consistent with never trying abbreviation.\n\t\t *\n\t\t * Alter datum1 representation in already-copied tuples, so as to\n\t\t * ensure a consistent representation (current tuple was just\n\t\t * handled).  It does not matter if some dumped tuples are already\n\t\t * sorted on tape, since serialized tuples lack abbreviated keys\n\t\t * (TSS_BUILDRUNS state prevents control reaching here in any case).\n\t\t */\n\t\tfor (i = 0; i < state->memtupcount; i++)\n\t\t{\n\t\t\tSortTuple  *mtup = &state->memtuples[i];\n\n\t\t\thtup.t_len = ((MinimalTuple) mtup->tuple)->t_len +\n\t\t\t\tMINIMAL_TUPLE_OFFSET;\n\t\t\thtup.t_data = (HeapTupleHeader) ((char *) mtup->tuple -\n\t\t\t\t\t\t\t\t\t\t\t MINIMAL_TUPLE_OFFSET);\n\n\t\t\tmtup->datum1 = heap_getattr(&htup,\n\t\t\t\t\t\t\t\t\t\tstate->sortKeys[0].ssup_attno,\n\t\t\t\t\t\t\t\t\t\tstate->tupDesc,\n\t\t\t\t\t\t\t\t\t\t&mtup->isnull1);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "comparetup_heap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "3508-3568",
    "snippet": "static int\ncomparetup_heap(const SortTuple *a, const SortTuple *b, Tuplesortstate *state)\n{\n\tSortSupport sortKey = state->sortKeys;\n\tHeapTupleData ltup;\n\tHeapTupleData rtup;\n\tTupleDesc\ttupDesc;\n\tint\t\t\tnkey;\n\tint32\t\tcompare;\n\tAttrNumber\tattno;\n\tDatum\t\tdatum1,\n\t\t\t\tdatum2;\n\tbool\t\tisnull1,\n\t\t\t\tisnull2;\n\n\n\t/* Compare the leading sort key */\n\tcompare = ApplySortComparator(a->datum1, a->isnull1,\n\t\t\t\t\t\t\t\t  b->datum1, b->isnull1,\n\t\t\t\t\t\t\t\t  sortKey);\n\tif (compare != 0)\n\t\treturn compare;\n\n\t/* Compare additional sort keys */\n\tltup.t_len = ((MinimalTuple) a->tuple)->t_len + MINIMAL_TUPLE_OFFSET;\n\tltup.t_data = (HeapTupleHeader) ((char *) a->tuple - MINIMAL_TUPLE_OFFSET);\n\trtup.t_len = ((MinimalTuple) b->tuple)->t_len + MINIMAL_TUPLE_OFFSET;\n\trtup.t_data = (HeapTupleHeader) ((char *) b->tuple - MINIMAL_TUPLE_OFFSET);\n\ttupDesc = state->tupDesc;\n\n\tif (sortKey->abbrev_converter)\n\t{\n\t\tattno = sortKey->ssup_attno;\n\n\t\tdatum1 = heap_getattr(&ltup, attno, tupDesc, &isnull1);\n\t\tdatum2 = heap_getattr(&rtup, attno, tupDesc, &isnull2);\n\n\t\tcompare = ApplySortAbbrevFullComparator(datum1, isnull1,\n\t\t\t\t\t\t\t\t\t\t\t\tdatum2, isnull2,\n\t\t\t\t\t\t\t\t\t\t\t\tsortKey);\n\t\tif (compare != 0)\n\t\t\treturn compare;\n\t}\n\n\tsortKey++;\n\tfor (nkey = 1; nkey < state->nKeys; nkey++, sortKey++)\n\t{\n\t\tattno = sortKey->ssup_attno;\n\n\t\tdatum1 = heap_getattr(&ltup, attno, tupDesc, &isnull1);\n\t\tdatum2 = heap_getattr(&rtup, attno, tupDesc, &isnull2);\n\n\t\tcompare = ApplySortComparator(datum1, isnull1,\n\t\t\t\t\t\t\t\t\t  datum2, isnull2,\n\t\t\t\t\t\t\t\t\t  sortKey);\n\t\tif (compare != 0)\n\t\t\treturn compare;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ApplySortComparator",
          "args": [
            "datum1",
            "isnull1",
            "datum2",
            "isnull2",
            "sortKey"
          ],
          "line": 3560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_getattr",
          "args": [
            "&rtup",
            "attno",
            "tupDesc",
            "&isnull2"
          ],
          "line": 3558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_getattr",
          "args": [
            "&ltup",
            "attno",
            "tupDesc",
            "&isnull1"
          ],
          "line": 3557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ApplySortAbbrevFullComparator",
          "args": [
            "datum1",
            "isnull1",
            "datum2",
            "isnull2",
            "sortKey"
          ],
          "line": 3545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_getattr",
          "args": [
            "&rtup",
            "attno",
            "tupDesc",
            "&isnull2"
          ],
          "line": 3543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_getattr",
          "args": [
            "&ltup",
            "attno",
            "tupDesc",
            "&isnull1"
          ],
          "line": 3542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(char *) b->tuple - MINIMAL_TUPLE_OFFSET"
          ],
          "line": 3535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(char *) a->tuple - MINIMAL_TUPLE_OFFSET"
          ],
          "line": 3533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ApplySortComparator",
          "args": [
            "a->datum1",
            "a->isnull1",
            "b->datum1",
            "b->isnull1",
            "sortKey"
          ],
          "line": 3525
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic int\ncomparetup_heap(const SortTuple *a, const SortTuple *b, Tuplesortstate *state)\n{\n\tSortSupport sortKey = state->sortKeys;\n\tHeapTupleData ltup;\n\tHeapTupleData rtup;\n\tTupleDesc\ttupDesc;\n\tint\t\t\tnkey;\n\tint32\t\tcompare;\n\tAttrNumber\tattno;\n\tDatum\t\tdatum1,\n\t\t\t\tdatum2;\n\tbool\t\tisnull1,\n\t\t\t\tisnull2;\n\n\n\t/* Compare the leading sort key */\n\tcompare = ApplySortComparator(a->datum1, a->isnull1,\n\t\t\t\t\t\t\t\t  b->datum1, b->isnull1,\n\t\t\t\t\t\t\t\t  sortKey);\n\tif (compare != 0)\n\t\treturn compare;\n\n\t/* Compare additional sort keys */\n\tltup.t_len = ((MinimalTuple) a->tuple)->t_len + MINIMAL_TUPLE_OFFSET;\n\tltup.t_data = (HeapTupleHeader) ((char *) a->tuple - MINIMAL_TUPLE_OFFSET);\n\trtup.t_len = ((MinimalTuple) b->tuple)->t_len + MINIMAL_TUPLE_OFFSET;\n\trtup.t_data = (HeapTupleHeader) ((char *) b->tuple - MINIMAL_TUPLE_OFFSET);\n\ttupDesc = state->tupDesc;\n\n\tif (sortKey->abbrev_converter)\n\t{\n\t\tattno = sortKey->ssup_attno;\n\n\t\tdatum1 = heap_getattr(&ltup, attno, tupDesc, &isnull1);\n\t\tdatum2 = heap_getattr(&rtup, attno, tupDesc, &isnull2);\n\n\t\tcompare = ApplySortAbbrevFullComparator(datum1, isnull1,\n\t\t\t\t\t\t\t\t\t\t\t\tdatum2, isnull2,\n\t\t\t\t\t\t\t\t\t\t\t\tsortKey);\n\t\tif (compare != 0)\n\t\t\treturn compare;\n\t}\n\n\tsortKey++;\n\tfor (nkey = 1; nkey < state->nKeys; nkey++, sortKey++)\n\t{\n\t\tattno = sortKey->ssup_attno;\n\n\t\tdatum1 = heap_getattr(&ltup, attno, tupDesc, &isnull1);\n\t\tdatum2 = heap_getattr(&rtup, attno, tupDesc, &isnull2);\n\n\t\tcompare = ApplySortComparator(datum1, isnull1,\n\t\t\t\t\t\t\t\t\t  datum2, isnull2,\n\t\t\t\t\t\t\t\t\t  sortKey);\n\t\tif (compare != 0)\n\t\t\treturn compare;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "readtup_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "3480-3501",
    "snippet": "static void *\nreadtup_alloc(Tuplesortstate *state, Size tuplen)\n{\n\tSlabSlot   *buf;\n\n\t/*\n\t * We pre-allocate enough slots in the slab arena that we should never run\n\t * out.\n\t */\n\tAssert(state->slabFreeHead);\n\n\tif (tuplen > SLAB_SLOT_SIZE || !state->slabFreeHead)\n\t\treturn MemoryContextAlloc(state->sortcontext, tuplen);\n\telse\n\t{\n\t\tbuf = state->slabFreeHead;\n\t\t/* Reuse this slot */\n\t\tstate->slabFreeHead = buf->nextfree;\n\n\t\treturn buf;\n\t}\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define SLAB_SLOT_SIZE 1024"
    ],
    "globals_used": [
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static void *readtup_alloc(Tuplesortstate *state, Size tuplen);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextAlloc",
          "args": [
            "state->sortcontext",
            "tuplen"
          ],
          "line": 3492
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1079-1106",
          "snippet": "void *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "state->slabFreeHead"
          ],
          "line": 3489
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define SLAB_SLOT_SIZE 1024\n\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic void *readtup_alloc(Tuplesortstate *state, Size tuplen);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic void *\nreadtup_alloc(Tuplesortstate *state, Size tuplen)\n{\n\tSlabSlot   *buf;\n\n\t/*\n\t * We pre-allocate enough slots in the slab arena that we should never run\n\t * out.\n\t */\n\tAssert(state->slabFreeHead);\n\n\tif (tuplen > SLAB_SLOT_SIZE || !state->slabFreeHead)\n\t\treturn MemoryContextAlloc(state->sortcontext, tuplen);\n\telse\n\t{\n\t\tbuf = state->slabFreeHead;\n\t\t/* Reuse this slot */\n\t\tstate->slabFreeHead = buf->nextfree;\n\n\t\treturn buf;\n\t}\n}"
  },
  {
    "function_name": "markrunend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "3466-3472",
    "snippet": "static void\nmarkrunend(Tuplesortstate *state, int tapenum)\n{\n\tunsigned int len = 0;\n\n\tLogicalTapeWrite(state->tapeset, tapenum, (void *) &len, sizeof(len));\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static void markrunend(Tuplesortstate *state, int tapenum);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static void readtup_heap(Tuplesortstate *state, SortTuple *stup,\n\t\t\t int tapenum, unsigned int len);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static void readtup_cluster(Tuplesortstate *state, SortTuple *stup,\n\t\t\t\tint tapenum, unsigned int len);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static void readtup_index(Tuplesortstate *state, SortTuple *stup,\n\t\t\t  int tapenum, unsigned int len);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static void readtup_datum(Tuplesortstate *state, SortTuple *stup,\n\t\t\t  int tapenum, unsigned int len);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LogicalTapeWrite",
          "args": [
            "state->tapeset",
            "tapenum",
            "(void *) &len",
            "sizeof(len)"
          ],
          "line": 3471
        },
        "resolved": true,
        "details": {
          "function_name": "LogicalTapeWrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/logtape.c",
          "lines": "620-694",
          "snippet": "void\nLogicalTapeWrite(LogicalTapeSet *lts, int tapenum,\n\t\t\t\t void *ptr, size_t size)\n{\n\tLogicalTape *lt;\n\tsize_t\t\tnthistime;\n\n\tAssert(tapenum >= 0 && tapenum < lts->nTapes);\n\tlt = &lts->tapes[tapenum];\n\tAssert(lt->writing);\n\tAssert(lt->offsetBlockNumber == 0L);\n\n\t/* Allocate data buffer and first block on first write */\n\tif (lt->buffer == NULL)\n\t{\n\t\tlt->buffer = (char *) palloc(BLCKSZ);\n\t\tlt->buffer_size = BLCKSZ;\n\t}\n\tif (lt->curBlockNumber == -1)\n\t{\n\t\tAssert(lt->firstBlockNumber == -1);\n\t\tAssert(lt->pos == 0);\n\n\t\tlt->curBlockNumber = ltsGetFreeBlock(lts);\n\t\tlt->firstBlockNumber = lt->curBlockNumber;\n\n\t\tTapeBlockGetTrailer(lt->buffer)->prev = -1L;\n\t}\n\n\tAssert(lt->buffer_size == BLCKSZ);\n\twhile (size > 0)\n\t{\n\t\tif (lt->pos >= TapeBlockPayloadSize)\n\t\t{\n\t\t\t/* Buffer full, dump it out */\n\t\t\tlong\t\tnextBlockNumber;\n\n\t\t\tif (!lt->dirty)\n\t\t\t{\n\t\t\t\t/* Hmm, went directly from reading to writing? */\n\t\t\t\telog(ERROR, \"invalid logtape state: should be dirty\");\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * First allocate the next block, so that we can store it in the\n\t\t\t * 'next' pointer of this block.\n\t\t\t */\n\t\t\tnextBlockNumber = ltsGetFreeBlock(lts);\n\n\t\t\t/* set the next-pointer and dump the current block. */\n\t\t\tTapeBlockGetTrailer(lt->buffer)->next = nextBlockNumber;\n\t\t\tltsWriteBlock(lts, lt->curBlockNumber, (void *) lt->buffer);\n\n\t\t\t/* initialize the prev-pointer of the next block */\n\t\t\tTapeBlockGetTrailer(lt->buffer)->prev = lt->curBlockNumber;\n\t\t\tlt->curBlockNumber = nextBlockNumber;\n\t\t\tlt->pos = 0;\n\t\t\tlt->nbytes = 0;\n\t\t}\n\n\t\tnthistime = TapeBlockPayloadSize - lt->pos;\n\t\tif (nthistime > size)\n\t\t\tnthistime = size;\n\t\tAssert(nthistime > 0);\n\n\t\tmemcpy(lt->buffer + lt->pos, ptr, nthistime);\n\n\t\tlt->dirty = true;\n\t\tlt->pos += nthistime;\n\t\tif (lt->nbytes < lt->pos)\n\t\t\tlt->nbytes = lt->pos;\n\t\tptr = (void *) ((char *) ptr + nthistime);\n\t\tsize -= nthistime;\n\t}\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TapeBlockPayloadSize  (BLCKSZ - sizeof(TapeBlockTrailer))"
          ],
          "globals_used": [
            "static void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
            "static void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
            "static long ltsGetFreeBlock(LogicalTapeSet *lts);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/logtape.h\"\n#include \"utils/builtins.h\"\n#include \"storage/buffile.h\"\n#include \"postgres.h\"\n\n#define TapeBlockPayloadSize  (BLCKSZ - sizeof(TapeBlockTrailer))\n\nstatic void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic long ltsGetFreeBlock(LogicalTapeSet *lts);\n\nvoid\nLogicalTapeWrite(LogicalTapeSet *lts, int tapenum,\n\t\t\t\t void *ptr, size_t size)\n{\n\tLogicalTape *lt;\n\tsize_t\t\tnthistime;\n\n\tAssert(tapenum >= 0 && tapenum < lts->nTapes);\n\tlt = &lts->tapes[tapenum];\n\tAssert(lt->writing);\n\tAssert(lt->offsetBlockNumber == 0L);\n\n\t/* Allocate data buffer and first block on first write */\n\tif (lt->buffer == NULL)\n\t{\n\t\tlt->buffer = (char *) palloc(BLCKSZ);\n\t\tlt->buffer_size = BLCKSZ;\n\t}\n\tif (lt->curBlockNumber == -1)\n\t{\n\t\tAssert(lt->firstBlockNumber == -1);\n\t\tAssert(lt->pos == 0);\n\n\t\tlt->curBlockNumber = ltsGetFreeBlock(lts);\n\t\tlt->firstBlockNumber = lt->curBlockNumber;\n\n\t\tTapeBlockGetTrailer(lt->buffer)->prev = -1L;\n\t}\n\n\tAssert(lt->buffer_size == BLCKSZ);\n\twhile (size > 0)\n\t{\n\t\tif (lt->pos >= TapeBlockPayloadSize)\n\t\t{\n\t\t\t/* Buffer full, dump it out */\n\t\t\tlong\t\tnextBlockNumber;\n\n\t\t\tif (!lt->dirty)\n\t\t\t{\n\t\t\t\t/* Hmm, went directly from reading to writing? */\n\t\t\t\telog(ERROR, \"invalid logtape state: should be dirty\");\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * First allocate the next block, so that we can store it in the\n\t\t\t * 'next' pointer of this block.\n\t\t\t */\n\t\t\tnextBlockNumber = ltsGetFreeBlock(lts);\n\n\t\t\t/* set the next-pointer and dump the current block. */\n\t\t\tTapeBlockGetTrailer(lt->buffer)->next = nextBlockNumber;\n\t\t\tltsWriteBlock(lts, lt->curBlockNumber, (void *) lt->buffer);\n\n\t\t\t/* initialize the prev-pointer of the next block */\n\t\t\tTapeBlockGetTrailer(lt->buffer)->prev = lt->curBlockNumber;\n\t\t\tlt->curBlockNumber = nextBlockNumber;\n\t\t\tlt->pos = 0;\n\t\t\tlt->nbytes = 0;\n\t\t}\n\n\t\tnthistime = TapeBlockPayloadSize - lt->pos;\n\t\tif (nthistime > size)\n\t\t\tnthistime = size;\n\t\tAssert(nthistime > 0);\n\n\t\tmemcpy(lt->buffer + lt->pos, ptr, nthistime);\n\n\t\tlt->dirty = true;\n\t\tlt->pos += nthistime;\n\t\tif (lt->nbytes < lt->pos)\n\t\t\tlt->nbytes = lt->pos;\n\t\tptr = (void *) ((char *) ptr + nthistime);\n\t\tsize -= nthistime;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic void markrunend(Tuplesortstate *state, int tapenum);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic void readtup_heap(Tuplesortstate *state, SortTuple *stup,\n\t\t\t int tapenum, unsigned int len);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic void readtup_cluster(Tuplesortstate *state, SortTuple *stup,\n\t\t\t\tint tapenum, unsigned int len);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic void readtup_index(Tuplesortstate *state, SortTuple *stup,\n\t\t\t  int tapenum, unsigned int len);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic void readtup_datum(Tuplesortstate *state, SortTuple *stup,\n\t\t\t  int tapenum, unsigned int len);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic void\nmarkrunend(Tuplesortstate *state, int tapenum)\n{\n\tunsigned int len = 0;\n\n\tLogicalTapeWrite(state->tapeset, tapenum, (void *) &len, sizeof(len));\n}"
  },
  {
    "function_name": "getlen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "3453-3464",
    "snippet": "static unsigned int\ngetlen(Tuplesortstate *state, int tapenum, bool eofOK)\n{\n\tunsigned int len;\n\n\tif (LogicalTapeRead(state->tapeset, tapenum,\n\t\t\t\t\t\t&len, sizeof(len)) != sizeof(len))\n\t\telog(ERROR, \"unexpected end of tape\");\n\tif (len == 0 && !eofOK)\n\t\telog(ERROR, \"unexpected end of data\");\n\treturn len;\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static unsigned int getlen(Tuplesortstate *state, int tapenum, bool eofOK);",
      "static void markrunend(Tuplesortstate *state, int tapenum);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static void readtup_heap(Tuplesortstate *state, SortTuple *stup,\n\t\t\t int tapenum, unsigned int len);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static void readtup_cluster(Tuplesortstate *state, SortTuple *stup,\n\t\t\t\tint tapenum, unsigned int len);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static void readtup_index(Tuplesortstate *state, SortTuple *stup,\n\t\t\t  int tapenum, unsigned int len);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static void readtup_datum(Tuplesortstate *state, SortTuple *stup,\n\t\t\t  int tapenum, unsigned int len);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unexpected end of data\""
          ],
          "line": 3462
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LogicalTapeRead",
          "args": [
            "state->tapeset",
            "tapenum",
            "&len",
            "sizeof(len)"
          ],
          "line": 3458
        },
        "resolved": true,
        "details": {
          "function_name": "LogicalTapeRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/logtape.c",
          "lines": "821-856",
          "snippet": "size_t\nLogicalTapeRead(LogicalTapeSet *lts, int tapenum,\n\t\t\t\tvoid *ptr, size_t size)\n{\n\tLogicalTape *lt;\n\tsize_t\t\tnread = 0;\n\tsize_t\t\tnthistime;\n\n\tAssert(tapenum >= 0 && tapenum < lts->nTapes);\n\tlt = &lts->tapes[tapenum];\n\tAssert(!lt->writing);\n\n\twhile (size > 0)\n\t{\n\t\tif (lt->pos >= lt->nbytes)\n\t\t{\n\t\t\t/* Try to load more data into buffer. */\n\t\t\tif (!ltsReadFillBuffer(lts, lt))\n\t\t\t\tbreak;\t\t\t/* EOF */\n\t\t}\n\n\t\tnthistime = lt->nbytes - lt->pos;\n\t\tif (nthistime > size)\n\t\t\tnthistime = size;\n\t\tAssert(nthistime > 0);\n\n\t\tmemcpy(ptr, lt->buffer + lt->pos, nthistime);\n\n\t\tlt->pos += nthistime;\n\t\tptr = (void *) ((char *) ptr + nthistime);\n\t\tsize -= nthistime;\n\t\tnread += nthistime;\n\t}\n\n\treturn nread;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
            "static void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
            "static long ltsGetFreeBlock(LogicalTapeSet *lts);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/logtape.h\"\n#include \"utils/builtins.h\"\n#include \"storage/buffile.h\"\n#include \"postgres.h\"\n\nstatic void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic long ltsGetFreeBlock(LogicalTapeSet *lts);\n\nsize_t\nLogicalTapeRead(LogicalTapeSet *lts, int tapenum,\n\t\t\t\tvoid *ptr, size_t size)\n{\n\tLogicalTape *lt;\n\tsize_t\t\tnread = 0;\n\tsize_t\t\tnthistime;\n\n\tAssert(tapenum >= 0 && tapenum < lts->nTapes);\n\tlt = &lts->tapes[tapenum];\n\tAssert(!lt->writing);\n\n\twhile (size > 0)\n\t{\n\t\tif (lt->pos >= lt->nbytes)\n\t\t{\n\t\t\t/* Try to load more data into buffer. */\n\t\t\tif (!ltsReadFillBuffer(lts, lt))\n\t\t\t\tbreak;\t\t\t/* EOF */\n\t\t}\n\n\t\tnthistime = lt->nbytes - lt->pos;\n\t\tif (nthistime > size)\n\t\t\tnthistime = size;\n\t\tAssert(nthistime > 0);\n\n\t\tmemcpy(ptr, lt->buffer + lt->pos, nthistime);\n\n\t\tlt->pos += nthistime;\n\t\tptr = (void *) ((char *) ptr + nthistime);\n\t\tsize -= nthistime;\n\t\tnread += nthistime;\n\t}\n\n\treturn nread;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic unsigned int getlen(Tuplesortstate *state, int tapenum, bool eofOK);\nstatic void markrunend(Tuplesortstate *state, int tapenum);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic void readtup_heap(Tuplesortstate *state, SortTuple *stup,\n\t\t\t int tapenum, unsigned int len);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic void readtup_cluster(Tuplesortstate *state, SortTuple *stup,\n\t\t\t\tint tapenum, unsigned int len);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic void readtup_index(Tuplesortstate *state, SortTuple *stup,\n\t\t\t  int tapenum, unsigned int len);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic void readtup_datum(Tuplesortstate *state, SortTuple *stup,\n\t\t\t  int tapenum, unsigned int len);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic unsigned int\ngetlen(Tuplesortstate *state, int tapenum, bool eofOK)\n{\n\tunsigned int len;\n\n\tif (LogicalTapeRead(state->tapeset, tapenum,\n\t\t\t\t\t\t&len, sizeof(len)) != sizeof(len))\n\t\telog(ERROR, \"unexpected end of tape\");\n\tif (len == 0 && !eofOK)\n\t\telog(ERROR, \"unexpected end of data\");\n\treturn len;\n}"
  },
  {
    "function_name": "reversedirection",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "3435-3446",
    "snippet": "static void\nreversedirection(Tuplesortstate *state)\n{\n\tSortSupport sortKey = state->sortKeys;\n\tint\t\t\tnkey;\n\n\tfor (nkey = 0; nkey < state->nKeys; nkey++, sortKey++)\n\t{\n\t\tsortKey->ssup_reverse = !sortKey->ssup_reverse;\n\t\tsortKey->ssup_nulls_first = !sortKey->ssup_nulls_first;\n\t}\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic void\nreversedirection(Tuplesortstate *state)\n{\n\tSortSupport sortKey = state->sortKeys;\n\tint\t\t\tnkey;\n\n\tfor (nkey = 0; nkey < state->nKeys; nkey++, sortKey++)\n\t{\n\t\tsortKey->ssup_reverse = !sortKey->ssup_reverse;\n\t\tsortKey->ssup_nulls_first = !sortKey->ssup_nulls_first;\n\t}\n}"
  },
  {
    "function_name": "tuplesort_heap_replace_top",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "3395-3428",
    "snippet": "static void\ntuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple)\n{\n\tSortTuple  *memtuples = state->memtuples;\n\tunsigned int i,\n\t\t\t\tn;\n\n\tAssert(state->memtupcount >= 1);\n\n\tCHECK_FOR_INTERRUPTS();\n\n\t/*\n\t * state->memtupcount is \"int\", but we use \"unsigned int\" for i, j, n.\n\t * This prevents overflow in the \"2 * i + 1\" calculation, since at the top\n\t * of the loop we must have i < n <= INT_MAX <= UINT_MAX/2.\n\t */\n\tn = state->memtupcount;\n\ti = 0;\t\t\t\t\t\t/* i is where the \"hole\" is */\n\tfor (;;)\n\t{\n\t\tunsigned int j = 2 * i + 1;\n\n\t\tif (j >= n)\n\t\t\tbreak;\n\t\tif (j + 1 < n &&\n\t\t\tCOMPARETUP(state, &memtuples[j], &memtuples[j + 1]) > 0)\n\t\t\tj++;\n\t\tif (COMPARETUP(state, tuple, &memtuples[j]) <= 0)\n\t\t\tbreak;\n\t\tmemtuples[i] = memtuples[j];\n\t\ti = j;\n\t}\n\tmemtuples[i] = *tuple;\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "COMPARETUP",
          "args": [
            "state",
            "tuple",
            "&memtuples[j]"
          ],
          "line": 3422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COMPARETUP",
          "args": [
            "state",
            "&memtuples[j]",
            "&memtuples[j + 1]"
          ],
          "line": 3420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_FOR_INTERRUPTS",
          "args": [],
          "line": 3404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "state->memtupcount >= 1"
          ],
          "line": 3402
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic void\ntuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple)\n{\n\tSortTuple  *memtuples = state->memtuples;\n\tunsigned int i,\n\t\t\t\tn;\n\n\tAssert(state->memtupcount >= 1);\n\n\tCHECK_FOR_INTERRUPTS();\n\n\t/*\n\t * state->memtupcount is \"int\", but we use \"unsigned int\" for i, j, n.\n\t * This prevents overflow in the \"2 * i + 1\" calculation, since at the top\n\t * of the loop we must have i < n <= INT_MAX <= UINT_MAX/2.\n\t */\n\tn = state->memtupcount;\n\ti = 0;\t\t\t\t\t\t/* i is where the \"hole\" is */\n\tfor (;;)\n\t{\n\t\tunsigned int j = 2 * i + 1;\n\n\t\tif (j >= n)\n\t\t\tbreak;\n\t\tif (j + 1 < n &&\n\t\t\tCOMPARETUP(state, &memtuples[j], &memtuples[j + 1]) > 0)\n\t\t\tj++;\n\t\tif (COMPARETUP(state, tuple, &memtuples[j]) <= 0)\n\t\t\tbreak;\n\t\tmemtuples[i] = memtuples[j];\n\t\ti = j;\n\t}\n\tmemtuples[i] = *tuple;\n}"
  },
  {
    "function_name": "tuplesort_heap_delete_top",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "3371-3386",
    "snippet": "static void\ntuplesort_heap_delete_top(Tuplesortstate *state)\n{\n\tSortTuple  *memtuples = state->memtuples;\n\tSortTuple  *tuple;\n\n\tif (--state->memtupcount <= 0)\n\t\treturn;\n\n\t/*\n\t * Remove the last tuple in the heap, and re-insert it, by replacing the\n\t * current top node with it.\n\t */\n\ttuple = &memtuples[state->memtupcount];\n\ttuplesort_heap_replace_top(state, tuple);\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tuplesort_heap_replace_top",
          "args": [
            "state",
            "tuple"
          ],
          "line": 3385
        },
        "resolved": true,
        "details": {
          "function_name": "tuplesort_heap_replace_top",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "3395-3428",
          "snippet": "static void\ntuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple)\n{\n\tSortTuple  *memtuples = state->memtuples;\n\tunsigned int i,\n\t\t\t\tn;\n\n\tAssert(state->memtupcount >= 1);\n\n\tCHECK_FOR_INTERRUPTS();\n\n\t/*\n\t * state->memtupcount is \"int\", but we use \"unsigned int\" for i, j, n.\n\t * This prevents overflow in the \"2 * i + 1\" calculation, since at the top\n\t * of the loop we must have i < n <= INT_MAX <= UINT_MAX/2.\n\t */\n\tn = state->memtupcount;\n\ti = 0;\t\t\t\t\t\t/* i is where the \"hole\" is */\n\tfor (;;)\n\t{\n\t\tunsigned int j = 2 * i + 1;\n\n\t\tif (j >= n)\n\t\t\tbreak;\n\t\tif (j + 1 < n &&\n\t\t\tCOMPARETUP(state, &memtuples[j], &memtuples[j + 1]) > 0)\n\t\t\tj++;\n\t\tif (COMPARETUP(state, tuple, &memtuples[j]) <= 0)\n\t\t\tbreak;\n\t\tmemtuples[i] = memtuples[j];\n\t\ti = j;\n\t}\n\tmemtuples[i] = *tuple;\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic void\ntuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple)\n{\n\tSortTuple  *memtuples = state->memtuples;\n\tunsigned int i,\n\t\t\t\tn;\n\n\tAssert(state->memtupcount >= 1);\n\n\tCHECK_FOR_INTERRUPTS();\n\n\t/*\n\t * state->memtupcount is \"int\", but we use \"unsigned int\" for i, j, n.\n\t * This prevents overflow in the \"2 * i + 1\" calculation, since at the top\n\t * of the loop we must have i < n <= INT_MAX <= UINT_MAX/2.\n\t */\n\tn = state->memtupcount;\n\ti = 0;\t\t\t\t\t\t/* i is where the \"hole\" is */\n\tfor (;;)\n\t{\n\t\tunsigned int j = 2 * i + 1;\n\n\t\tif (j >= n)\n\t\t\tbreak;\n\t\tif (j + 1 < n &&\n\t\t\tCOMPARETUP(state, &memtuples[j], &memtuples[j + 1]) > 0)\n\t\t\tj++;\n\t\tif (COMPARETUP(state, tuple, &memtuples[j]) <= 0)\n\t\t\tbreak;\n\t\tmemtuples[i] = memtuples[j];\n\t\ti = j;\n\t}\n\tmemtuples[i] = *tuple;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic void\ntuplesort_heap_delete_top(Tuplesortstate *state)\n{\n\tSortTuple  *memtuples = state->memtuples;\n\tSortTuple  *tuple;\n\n\tif (--state->memtupcount <= 0)\n\t\treturn;\n\n\t/*\n\t * Remove the last tuple in the heap, and re-insert it, by replacing the\n\t * current top node with it.\n\t */\n\ttuple = &memtuples[state->memtupcount];\n\ttuplesort_heap_replace_top(state, tuple);\n}"
  },
  {
    "function_name": "tuplesort_heap_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "3336-3362",
    "snippet": "static void\ntuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple)\n{\n\tSortTuple  *memtuples;\n\tint\t\t\tj;\n\n\tmemtuples = state->memtuples;\n\tAssert(state->memtupcount < state->memtupsize);\n\n\tCHECK_FOR_INTERRUPTS();\n\n\t/*\n\t * Sift-up the new entry, per Knuth 5.2.3 exercise 16. Note that Knuth is\n\t * using 1-based array indexes, not 0-based.\n\t */\n\tj = state->memtupcount++;\n\twhile (j > 0)\n\t{\n\t\tint\t\t\ti = (j - 1) >> 1;\n\n\t\tif (COMPARETUP(state, tuple, &memtuples[i]) >= 0)\n\t\t\tbreak;\n\t\tmemtuples[j] = memtuples[i];\n\t\tj = i;\n\t}\n\tmemtuples[j] = *tuple;\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "COMPARETUP",
          "args": [
            "state",
            "tuple",
            "&memtuples[i]"
          ],
          "line": 3356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_FOR_INTERRUPTS",
          "args": [],
          "line": 3345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "state->memtupcount < state->memtupsize"
          ],
          "line": 3343
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic void\ntuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple)\n{\n\tSortTuple  *memtuples;\n\tint\t\t\tj;\n\n\tmemtuples = state->memtuples;\n\tAssert(state->memtupcount < state->memtupsize);\n\n\tCHECK_FOR_INTERRUPTS();\n\n\t/*\n\t * Sift-up the new entry, per Knuth 5.2.3 exercise 16. Note that Knuth is\n\t * using 1-based array indexes, not 0-based.\n\t */\n\tj = state->memtupcount++;\n\twhile (j > 0)\n\t{\n\t\tint\t\t\ti = (j - 1) >> 1;\n\n\t\tif (COMPARETUP(state, tuple, &memtuples[i]) >= 0)\n\t\t\tbreak;\n\t\tmemtuples[j] = memtuples[i];\n\t\tj = i;\n\t}\n\tmemtuples[j] = *tuple;\n}"
  },
  {
    "function_name": "tuplesort_sort_memtuples",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "3308-3325",
    "snippet": "static void\ntuplesort_sort_memtuples(Tuplesortstate *state)\n{\n\tAssert(!LEADER(state));\n\n\tif (state->memtupcount > 1)\n\t{\n\t\t/* Can we use the single-key sort function? */\n\t\tif (state->onlyKey != NULL)\n\t\t\tqsort_ssup(state->memtuples, state->memtupcount,\n\t\t\t\t\t   state->onlyKey);\n\t\telse\n\t\t\tqsort_tuple(state->memtuples,\n\t\t\t\t\t\tstate->memtupcount,\n\t\t\t\t\t\tstate->comparetup,\n\t\t\t\t\t\tstate);\n\t}\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "qsort_tuple",
          "args": [
            "state->memtuples",
            "state->memtupcount",
            "state->comparetup",
            "state"
          ],
          "line": 3320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qsort_ssup",
          "args": [
            "state->memtuples",
            "state->memtupcount",
            "state->onlyKey"
          ],
          "line": 3317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!LEADER(state)"
          ],
          "line": 3311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LEADER",
          "args": [
            "state"
          ],
          "line": 3311
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic void\ntuplesort_sort_memtuples(Tuplesortstate *state)\n{\n\tAssert(!LEADER(state));\n\n\tif (state->memtupcount > 1)\n\t{\n\t\t/* Can we use the single-key sort function? */\n\t\tif (state->onlyKey != NULL)\n\t\t\tqsort_ssup(state->memtuples, state->memtupcount,\n\t\t\t\t\t   state->onlyKey);\n\t\telse\n\t\t\tqsort_tuple(state->memtuples,\n\t\t\t\t\t\tstate->memtupcount,\n\t\t\t\t\t\tstate->comparetup,\n\t\t\t\t\t\tstate);\n\t}\n}"
  },
  {
    "function_name": "sort_bounded_heap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "3268-3301",
    "snippet": "static void\nsort_bounded_heap(Tuplesortstate *state)\n{\n\tint\t\t\ttupcount = state->memtupcount;\n\n\tAssert(state->status == TSS_BOUNDED);\n\tAssert(state->bounded);\n\tAssert(tupcount == state->bound);\n\tAssert(SERIAL(state));\n\n\t/*\n\t * We can unheapify in place because each delete-top call will remove the\n\t * largest entry, which we can promptly store in the newly freed slot at\n\t * the end.  Once we're down to a single-entry heap, we're done.\n\t */\n\twhile (state->memtupcount > 1)\n\t{\n\t\tSortTuple\tstup = state->memtuples[0];\n\n\t\t/* this sifts-up the next-largest entry and decreases memtupcount */\n\t\ttuplesort_heap_delete_top(state);\n\t\tstate->memtuples[state->memtupcount] = stup;\n\t}\n\tstate->memtupcount = tupcount;\n\n\t/*\n\t * Reverse sort direction back to the original state.  This is not\n\t * actually necessary but seems like a good idea for tidiness.\n\t */\n\treversedirection(state);\n\n\tstate->status = TSS_SORTEDINMEM;\n\tstate->boundUsed = true;\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);",
      "static void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reversedirection",
          "args": [
            "state"
          ],
          "line": 3297
        },
        "resolved": true,
        "details": {
          "function_name": "reversedirection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "3435-3446",
          "snippet": "static void\nreversedirection(Tuplesortstate *state)\n{\n\tSortSupport sortKey = state->sortKeys;\n\tint\t\t\tnkey;\n\n\tfor (nkey = 0; nkey < state->nKeys; nkey++, sortKey++)\n\t{\n\t\tsortKey->ssup_reverse = !sortKey->ssup_reverse;\n\t\tsortKey->ssup_nulls_first = !sortKey->ssup_nulls_first;\n\t}\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic void\nreversedirection(Tuplesortstate *state)\n{\n\tSortSupport sortKey = state->sortKeys;\n\tint\t\t\tnkey;\n\n\tfor (nkey = 0; nkey < state->nKeys; nkey++, sortKey++)\n\t{\n\t\tsortKey->ssup_reverse = !sortKey->ssup_reverse;\n\t\tsortKey->ssup_nulls_first = !sortKey->ssup_nulls_first;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tuplesort_heap_delete_top",
          "args": [
            "state"
          ],
          "line": 3288
        },
        "resolved": true,
        "details": {
          "function_name": "tuplesort_heap_delete_top",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "3371-3386",
          "snippet": "static void\ntuplesort_heap_delete_top(Tuplesortstate *state)\n{\n\tSortTuple  *memtuples = state->memtuples;\n\tSortTuple  *tuple;\n\n\tif (--state->memtupcount <= 0)\n\t\treturn;\n\n\t/*\n\t * Remove the last tuple in the heap, and re-insert it, by replacing the\n\t * current top node with it.\n\t */\n\ttuple = &memtuples[state->memtupcount];\n\ttuplesort_heap_replace_top(state, tuple);\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic void\ntuplesort_heap_delete_top(Tuplesortstate *state)\n{\n\tSortTuple  *memtuples = state->memtuples;\n\tSortTuple  *tuple;\n\n\tif (--state->memtupcount <= 0)\n\t\treturn;\n\n\t/*\n\t * Remove the last tuple in the heap, and re-insert it, by replacing the\n\t * current top node with it.\n\t */\n\ttuple = &memtuples[state->memtupcount];\n\ttuplesort_heap_replace_top(state, tuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "SERIAL(state)"
          ],
          "line": 3276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SERIAL",
          "args": [
            "state"
          ],
          "line": 3276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "tupcount == state->bound"
          ],
          "line": 3275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "state->bounded"
          ],
          "line": 3274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "state->status == TSS_BOUNDED"
          ],
          "line": 3273
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\nstatic void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);\n\nstatic void\nsort_bounded_heap(Tuplesortstate *state)\n{\n\tint\t\t\ttupcount = state->memtupcount;\n\n\tAssert(state->status == TSS_BOUNDED);\n\tAssert(state->bounded);\n\tAssert(tupcount == state->bound);\n\tAssert(SERIAL(state));\n\n\t/*\n\t * We can unheapify in place because each delete-top call will remove the\n\t * largest entry, which we can promptly store in the newly freed slot at\n\t * the end.  Once we're down to a single-entry heap, we're done.\n\t */\n\twhile (state->memtupcount > 1)\n\t{\n\t\tSortTuple\tstup = state->memtuples[0];\n\n\t\t/* this sifts-up the next-largest entry and decreases memtupcount */\n\t\ttuplesort_heap_delete_top(state);\n\t\tstate->memtuples[state->memtupcount] = stup;\n\t}\n\tstate->memtupcount = tupcount;\n\n\t/*\n\t * Reverse sort direction back to the original state.  This is not\n\t * actually necessary but seems like a good idea for tidiness.\n\t */\n\treversedirection(state);\n\n\tstate->status = TSS_SORTEDINMEM;\n\tstate->boundUsed = true;\n}"
  },
  {
    "function_name": "make_bounded_heap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "3219-3263",
    "snippet": "static void\nmake_bounded_heap(Tuplesortstate *state)\n{\n\tint\t\t\ttupcount = state->memtupcount;\n\tint\t\t\ti;\n\n\tAssert(state->status == TSS_INITIAL);\n\tAssert(state->bounded);\n\tAssert(tupcount >= state->bound);\n\tAssert(SERIAL(state));\n\n\t/* Reverse sort direction so largest entry will be at root */\n\treversedirection(state);\n\n\tstate->memtupcount = 0;\t\t/* make the heap empty */\n\tfor (i = 0; i < tupcount; i++)\n\t{\n\t\tif (state->memtupcount < state->bound)\n\t\t{\n\t\t\t/* Insert next tuple into heap */\n\t\t\t/* Must copy source tuple to avoid possible overwrite */\n\t\t\tSortTuple\tstup = state->memtuples[i];\n\n\t\t\ttuplesort_heap_insert(state, &stup);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * The heap is full.  Replace the largest entry with the new\n\t\t\t * tuple, or just discard it, if it's larger than anything already\n\t\t\t * in the heap.\n\t\t\t */\n\t\t\tif (COMPARETUP(state, &state->memtuples[i], &state->memtuples[0]) <= 0)\n\t\t\t{\n\t\t\t\tfree_sort_tuple(state, &state->memtuples[i]);\n\t\t\t\tCHECK_FOR_INTERRUPTS();\n\t\t\t}\n\t\t\telse\n\t\t\t\ttuplesort_heap_replace_top(state, &state->memtuples[i]);\n\t\t}\n\t}\n\n\tAssert(state->memtupcount == state->bound);\n\tstate->status = TSS_BOUNDED;\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);",
      "static void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "state->memtupcount == state->bound"
          ],
          "line": 3261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tuplesort_heap_replace_top",
          "args": [
            "state",
            "&state->memtuples[i]"
          ],
          "line": 3257
        },
        "resolved": true,
        "details": {
          "function_name": "tuplesort_heap_replace_top",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "3395-3428",
          "snippet": "static void\ntuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple)\n{\n\tSortTuple  *memtuples = state->memtuples;\n\tunsigned int i,\n\t\t\t\tn;\n\n\tAssert(state->memtupcount >= 1);\n\n\tCHECK_FOR_INTERRUPTS();\n\n\t/*\n\t * state->memtupcount is \"int\", but we use \"unsigned int\" for i, j, n.\n\t * This prevents overflow in the \"2 * i + 1\" calculation, since at the top\n\t * of the loop we must have i < n <= INT_MAX <= UINT_MAX/2.\n\t */\n\tn = state->memtupcount;\n\ti = 0;\t\t\t\t\t\t/* i is where the \"hole\" is */\n\tfor (;;)\n\t{\n\t\tunsigned int j = 2 * i + 1;\n\n\t\tif (j >= n)\n\t\t\tbreak;\n\t\tif (j + 1 < n &&\n\t\t\tCOMPARETUP(state, &memtuples[j], &memtuples[j + 1]) > 0)\n\t\t\tj++;\n\t\tif (COMPARETUP(state, tuple, &memtuples[j]) <= 0)\n\t\t\tbreak;\n\t\tmemtuples[i] = memtuples[j];\n\t\ti = j;\n\t}\n\tmemtuples[i] = *tuple;\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic void\ntuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple)\n{\n\tSortTuple  *memtuples = state->memtuples;\n\tunsigned int i,\n\t\t\t\tn;\n\n\tAssert(state->memtupcount >= 1);\n\n\tCHECK_FOR_INTERRUPTS();\n\n\t/*\n\t * state->memtupcount is \"int\", but we use \"unsigned int\" for i, j, n.\n\t * This prevents overflow in the \"2 * i + 1\" calculation, since at the top\n\t * of the loop we must have i < n <= INT_MAX <= UINT_MAX/2.\n\t */\n\tn = state->memtupcount;\n\ti = 0;\t\t\t\t\t\t/* i is where the \"hole\" is */\n\tfor (;;)\n\t{\n\t\tunsigned int j = 2 * i + 1;\n\n\t\tif (j >= n)\n\t\t\tbreak;\n\t\tif (j + 1 < n &&\n\t\t\tCOMPARETUP(state, &memtuples[j], &memtuples[j + 1]) > 0)\n\t\t\tj++;\n\t\tif (COMPARETUP(state, tuple, &memtuples[j]) <= 0)\n\t\t\tbreak;\n\t\tmemtuples[i] = memtuples[j];\n\t\ti = j;\n\t}\n\tmemtuples[i] = *tuple;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHECK_FOR_INTERRUPTS",
          "args": [],
          "line": 3254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_sort_tuple",
          "args": [
            "state",
            "&state->memtuples[i]"
          ],
          "line": 3253
        },
        "resolved": true,
        "details": {
          "function_name": "free_sort_tuple",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "4578-4583",
          "snippet": "static void\nfree_sort_tuple(Tuplesortstate *state, SortTuple *stup)\n{\n\tFREEMEM(state, GetMemoryChunkSpace(stup->tuple));\n\tpfree(stup->tuple);\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);",
            "static void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\nstatic void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);\n\nstatic void\nfree_sort_tuple(Tuplesortstate *state, SortTuple *stup)\n{\n\tFREEMEM(state, GetMemoryChunkSpace(stup->tuple));\n\tpfree(stup->tuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "COMPARETUP",
          "args": [
            "state",
            "&state->memtuples[i]",
            "&state->memtuples[0]"
          ],
          "line": 3251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tuplesort_heap_insert",
          "args": [
            "state",
            "&stup"
          ],
          "line": 3242
        },
        "resolved": true,
        "details": {
          "function_name": "tuplesort_heap_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "3336-3362",
          "snippet": "static void\ntuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple)\n{\n\tSortTuple  *memtuples;\n\tint\t\t\tj;\n\n\tmemtuples = state->memtuples;\n\tAssert(state->memtupcount < state->memtupsize);\n\n\tCHECK_FOR_INTERRUPTS();\n\n\t/*\n\t * Sift-up the new entry, per Knuth 5.2.3 exercise 16. Note that Knuth is\n\t * using 1-based array indexes, not 0-based.\n\t */\n\tj = state->memtupcount++;\n\twhile (j > 0)\n\t{\n\t\tint\t\t\ti = (j - 1) >> 1;\n\n\t\tif (COMPARETUP(state, tuple, &memtuples[i]) >= 0)\n\t\t\tbreak;\n\t\tmemtuples[j] = memtuples[i];\n\t\tj = i;\n\t}\n\tmemtuples[j] = *tuple;\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic void\ntuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple)\n{\n\tSortTuple  *memtuples;\n\tint\t\t\tj;\n\n\tmemtuples = state->memtuples;\n\tAssert(state->memtupcount < state->memtupsize);\n\n\tCHECK_FOR_INTERRUPTS();\n\n\t/*\n\t * Sift-up the new entry, per Knuth 5.2.3 exercise 16. Note that Knuth is\n\t * using 1-based array indexes, not 0-based.\n\t */\n\tj = state->memtupcount++;\n\twhile (j > 0)\n\t{\n\t\tint\t\t\ti = (j - 1) >> 1;\n\n\t\tif (COMPARETUP(state, tuple, &memtuples[i]) >= 0)\n\t\t\tbreak;\n\t\tmemtuples[j] = memtuples[i];\n\t\tj = i;\n\t}\n\tmemtuples[j] = *tuple;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reversedirection",
          "args": [
            "state"
          ],
          "line": 3231
        },
        "resolved": true,
        "details": {
          "function_name": "reversedirection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "3435-3446",
          "snippet": "static void\nreversedirection(Tuplesortstate *state)\n{\n\tSortSupport sortKey = state->sortKeys;\n\tint\t\t\tnkey;\n\n\tfor (nkey = 0; nkey < state->nKeys; nkey++, sortKey++)\n\t{\n\t\tsortKey->ssup_reverse = !sortKey->ssup_reverse;\n\t\tsortKey->ssup_nulls_first = !sortKey->ssup_nulls_first;\n\t}\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic void\nreversedirection(Tuplesortstate *state)\n{\n\tSortSupport sortKey = state->sortKeys;\n\tint\t\t\tnkey;\n\n\tfor (nkey = 0; nkey < state->nKeys; nkey++, sortKey++)\n\t{\n\t\tsortKey->ssup_reverse = !sortKey->ssup_reverse;\n\t\tsortKey->ssup_nulls_first = !sortKey->ssup_nulls_first;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "SERIAL(state)"
          ],
          "line": 3228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SERIAL",
          "args": [
            "state"
          ],
          "line": 3228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "tupcount >= state->bound"
          ],
          "line": 3227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "state->bounded"
          ],
          "line": 3226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "state->status == TSS_INITIAL"
          ],
          "line": 3225
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\nstatic void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);\n\nstatic void\nmake_bounded_heap(Tuplesortstate *state)\n{\n\tint\t\t\ttupcount = state->memtupcount;\n\tint\t\t\ti;\n\n\tAssert(state->status == TSS_INITIAL);\n\tAssert(state->bounded);\n\tAssert(tupcount >= state->bound);\n\tAssert(SERIAL(state));\n\n\t/* Reverse sort direction so largest entry will be at root */\n\treversedirection(state);\n\n\tstate->memtupcount = 0;\t\t/* make the heap empty */\n\tfor (i = 0; i < tupcount; i++)\n\t{\n\t\tif (state->memtupcount < state->bound)\n\t\t{\n\t\t\t/* Insert next tuple into heap */\n\t\t\t/* Must copy source tuple to avoid possible overwrite */\n\t\t\tSortTuple\tstup = state->memtuples[i];\n\n\t\t\ttuplesort_heap_insert(state, &stup);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * The heap is full.  Replace the largest entry with the new\n\t\t\t * tuple, or just discard it, if it's larger than anything already\n\t\t\t * in the heap.\n\t\t\t */\n\t\t\tif (COMPARETUP(state, &state->memtuples[i], &state->memtuples[0]) <= 0)\n\t\t\t{\n\t\t\t\tfree_sort_tuple(state, &state->memtuples[i]);\n\t\t\t\tCHECK_FOR_INTERRUPTS();\n\t\t\t}\n\t\t\telse\n\t\t\t\ttuplesort_heap_replace_top(state, &state->memtuples[i]);\n\t\t}\n\t}\n\n\tAssert(state->memtupcount == state->bound);\n\tstate->status = TSS_BOUNDED;\n}"
  },
  {
    "function_name": "tuplesort_space_type_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "3198-3203",
    "snippet": "const char *\ntuplesort_space_type_name(TuplesortSpaceType t)\n{\n\tAssert(t == SORT_SPACE_TYPE_DISK || t == SORT_SPACE_TYPE_MEMORY);\n\treturn t == SORT_SPACE_TYPE_DISK ? \"Disk\" : \"Memory\";\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "t == SORT_SPACE_TYPE_DISK || t == SORT_SPACE_TYPE_MEMORY"
          ],
          "line": 3201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nconst char *\ntuplesort_space_type_name(TuplesortSpaceType t)\n{\n\tAssert(t == SORT_SPACE_TYPE_DISK || t == SORT_SPACE_TYPE_MEMORY);\n\treturn t == SORT_SPACE_TYPE_DISK ? \"Disk\" : \"Memory\";\n}"
  },
  {
    "function_name": "tuplesort_method_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "3175-3193",
    "snippet": "const char *\ntuplesort_method_name(TuplesortMethod m)\n{\n\tswitch (m)\n\t{\n\t\tcase SORT_TYPE_STILL_IN_PROGRESS:\n\t\t\treturn \"still in progress\";\n\t\tcase SORT_TYPE_TOP_N_HEAPSORT:\n\t\t\treturn \"top-N heapsort\";\n\t\tcase SORT_TYPE_QUICKSORT:\n\t\t\treturn \"quicksort\";\n\t\tcase SORT_TYPE_EXTERNAL_SORT:\n\t\t\treturn \"external sort\";\n\t\tcase SORT_TYPE_EXTERNAL_MERGE:\n\t\t\treturn \"external merge\";\n\t}\n\n\treturn \"unknown\";\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nconst char *\ntuplesort_method_name(TuplesortMethod m)\n{\n\tswitch (m)\n\t{\n\t\tcase SORT_TYPE_STILL_IN_PROGRESS:\n\t\t\treturn \"still in progress\";\n\t\tcase SORT_TYPE_TOP_N_HEAPSORT:\n\t\t\treturn \"top-N heapsort\";\n\t\tcase SORT_TYPE_QUICKSORT:\n\t\t\treturn \"quicksort\";\n\t\tcase SORT_TYPE_EXTERNAL_SORT:\n\t\t\treturn \"external sort\";\n\t\tcase SORT_TYPE_EXTERNAL_MERGE:\n\t\t\treturn \"external merge\";\n\t}\n\n\treturn \"unknown\";\n}"
  },
  {
    "function_name": "tuplesort_get_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "3128-3170",
    "snippet": "void\ntuplesort_get_stats(Tuplesortstate *state,\n\t\t\t\t\tTuplesortInstrumentation *stats)\n{\n\t/*\n\t * Note: it might seem we should provide both memory and disk usage for a\n\t * disk-based sort.  However, the current code doesn't track memory space\n\t * accurately once we have begun to return tuples to the caller (since we\n\t * don't account for pfree's the caller is expected to do), so we cannot\n\t * rely on availMem in a disk sort.  This does not seem worth the overhead\n\t * to fix.  Is it worth creating an API for the memory context code to\n\t * tell us how much is actually used in sortcontext?\n\t */\n\tif (state->tapeset)\n\t{\n\t\tstats->spaceType = SORT_SPACE_TYPE_DISK;\n\t\tstats->spaceUsed = LogicalTapeSetBlocks(state->tapeset) * (BLCKSZ / 1024);\n\t}\n\telse\n\t{\n\t\tstats->spaceType = SORT_SPACE_TYPE_MEMORY;\n\t\tstats->spaceUsed = (state->allowedMem - state->availMem + 1023) / 1024;\n\t}\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_SORTEDINMEM:\n\t\t\tif (state->boundUsed)\n\t\t\t\tstats->sortMethod = SORT_TYPE_TOP_N_HEAPSORT;\n\t\t\telse\n\t\t\t\tstats->sortMethod = SORT_TYPE_QUICKSORT;\n\t\t\tbreak;\n\t\tcase TSS_SORTEDONTAPE:\n\t\t\tstats->sortMethod = SORT_TYPE_EXTERNAL_SORT;\n\t\t\tbreak;\n\t\tcase TSS_FINALMERGE:\n\t\t\tstats->sortMethod = SORT_TYPE_EXTERNAL_MERGE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstats->sortMethod = SORT_TYPE_STILL_IN_PROGRESS;\n\t\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LogicalTapeSetBlocks",
          "args": [
            "state->tapeset"
          ],
          "line": 3144
        },
        "resolved": true,
        "details": {
          "function_name": "LogicalTapeSetBlocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/logtape.c",
          "lines": "1081-1085",
          "snippet": "long\nLogicalTapeSetBlocks(LogicalTapeSet *lts)\n{\n\treturn lts->nBlocksAllocated - lts->nHoleBlocks;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long ltsGetFreeBlock(LogicalTapeSet *lts);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/logtape.h\"\n#include \"utils/builtins.h\"\n#include \"storage/buffile.h\"\n#include \"postgres.h\"\n\nstatic long ltsGetFreeBlock(LogicalTapeSet *lts);\n\nlong\nLogicalTapeSetBlocks(LogicalTapeSet *lts)\n{\n\treturn lts->nBlocksAllocated - lts->nHoleBlocks;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nvoid\ntuplesort_get_stats(Tuplesortstate *state,\n\t\t\t\t\tTuplesortInstrumentation *stats)\n{\n\t/*\n\t * Note: it might seem we should provide both memory and disk usage for a\n\t * disk-based sort.  However, the current code doesn't track memory space\n\t * accurately once we have begun to return tuples to the caller (since we\n\t * don't account for pfree's the caller is expected to do), so we cannot\n\t * rely on availMem in a disk sort.  This does not seem worth the overhead\n\t * to fix.  Is it worth creating an API for the memory context code to\n\t * tell us how much is actually used in sortcontext?\n\t */\n\tif (state->tapeset)\n\t{\n\t\tstats->spaceType = SORT_SPACE_TYPE_DISK;\n\t\tstats->spaceUsed = LogicalTapeSetBlocks(state->tapeset) * (BLCKSZ / 1024);\n\t}\n\telse\n\t{\n\t\tstats->spaceType = SORT_SPACE_TYPE_MEMORY;\n\t\tstats->spaceUsed = (state->allowedMem - state->availMem + 1023) / 1024;\n\t}\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_SORTEDINMEM:\n\t\t\tif (state->boundUsed)\n\t\t\t\tstats->sortMethod = SORT_TYPE_TOP_N_HEAPSORT;\n\t\t\telse\n\t\t\t\tstats->sortMethod = SORT_TYPE_QUICKSORT;\n\t\t\tbreak;\n\t\tcase TSS_SORTEDONTAPE:\n\t\t\tstats->sortMethod = SORT_TYPE_EXTERNAL_SORT;\n\t\t\tbreak;\n\t\tcase TSS_FINALMERGE:\n\t\t\tstats->sortMethod = SORT_TYPE_EXTERNAL_MERGE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstats->sortMethod = SORT_TYPE_STILL_IN_PROGRESS;\n\t\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "tuplesort_restorepos",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "3094-3120",
    "snippet": "void\ntuplesort_restorepos(Tuplesortstate *state)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\n\tAssert(state->randomAccess);\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_SORTEDINMEM:\n\t\t\tstate->current = state->markpos_offset;\n\t\t\tstate->eof_reached = state->markpos_eof;\n\t\t\tbreak;\n\t\tcase TSS_SORTEDONTAPE:\n\t\t\tLogicalTapeSeek(state->tapeset,\n\t\t\t\t\t\t\tstate->result_tape,\n\t\t\t\t\t\t\tstate->markpos_block,\n\t\t\t\t\t\t\tstate->markpos_offset);\n\t\t\tstate->eof_reached = state->markpos_eof;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplesort state\");\n\t\t\tbreak;\n\t}\n\n\tMemoryContextSwitchTo(oldcontext);\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);",
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 3119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"invalid tuplesort state\""
          ],
          "line": 3115
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LogicalTapeSeek",
          "args": [
            "state->tapeset",
            "state->result_tape",
            "state->markpos_block",
            "state->markpos_offset"
          ],
          "line": 3108
        },
        "resolved": true,
        "details": {
          "function_name": "LogicalTapeSeek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/logtape.c",
          "lines": "1030-1053",
          "snippet": "void\nLogicalTapeSeek(LogicalTapeSet *lts, int tapenum,\n\t\t\t\tlong blocknum, int offset)\n{\n\tLogicalTape *lt;\n\n\tAssert(tapenum >= 0 && tapenum < lts->nTapes);\n\tlt = &lts->tapes[tapenum];\n\tAssert(lt->frozen);\n\tAssert(offset >= 0 && offset <= TapeBlockPayloadSize);\n\tAssert(lt->buffer_size == BLCKSZ);\n\n\tif (blocknum != lt->curBlockNumber)\n\t{\n\t\tltsReadBlock(lts, blocknum, (void *) lt->buffer);\n\t\tlt->curBlockNumber = blocknum;\n\t\tlt->nbytes = TapeBlockPayloadSize;\n\t\tlt->nextBlockNumber = TapeBlockGetTrailer(lt->buffer)->next;\n\t}\n\n\tif (offset > lt->nbytes)\n\t\telog(ERROR, \"invalid tape seek position\");\n\tlt->pos = offset;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TapeBlockPayloadSize  (BLCKSZ - sizeof(TapeBlockTrailer))"
          ],
          "globals_used": [
            "static void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
            "static void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
            "static long ltsGetFreeBlock(LogicalTapeSet *lts);",
            "static void ltsReleaseBlock(LogicalTapeSet *lts, long blocknum);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/logtape.h\"\n#include \"utils/builtins.h\"\n#include \"storage/buffile.h\"\n#include \"postgres.h\"\n\n#define TapeBlockPayloadSize  (BLCKSZ - sizeof(TapeBlockTrailer))\n\nstatic void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic long ltsGetFreeBlock(LogicalTapeSet *lts);\nstatic void ltsReleaseBlock(LogicalTapeSet *lts, long blocknum);\n\nvoid\nLogicalTapeSeek(LogicalTapeSet *lts, int tapenum,\n\t\t\t\tlong blocknum, int offset)\n{\n\tLogicalTape *lt;\n\n\tAssert(tapenum >= 0 && tapenum < lts->nTapes);\n\tlt = &lts->tapes[tapenum];\n\tAssert(lt->frozen);\n\tAssert(offset >= 0 && offset <= TapeBlockPayloadSize);\n\tAssert(lt->buffer_size == BLCKSZ);\n\n\tif (blocknum != lt->curBlockNumber)\n\t{\n\t\tltsReadBlock(lts, blocknum, (void *) lt->buffer);\n\t\tlt->curBlockNumber = blocknum;\n\t\tlt->nbytes = TapeBlockPayloadSize;\n\t\tlt->nextBlockNumber = TapeBlockGetTrailer(lt->buffer)->next;\n\t}\n\n\tif (offset > lt->nbytes)\n\t\telog(ERROR, \"invalid tape seek position\");\n\tlt->pos = offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "state->randomAccess"
          ],
          "line": 3099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "state->sortcontext"
          ],
          "line": 3097
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nvoid\ntuplesort_restorepos(Tuplesortstate *state)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\n\tAssert(state->randomAccess);\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_SORTEDINMEM:\n\t\t\tstate->current = state->markpos_offset;\n\t\t\tstate->eof_reached = state->markpos_eof;\n\t\t\tbreak;\n\t\tcase TSS_SORTEDONTAPE:\n\t\t\tLogicalTapeSeek(state->tapeset,\n\t\t\t\t\t\t\tstate->result_tape,\n\t\t\t\t\t\t\tstate->markpos_block,\n\t\t\t\t\t\t\tstate->markpos_offset);\n\t\t\tstate->eof_reached = state->markpos_eof;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplesort state\");\n\t\t\tbreak;\n\t}\n\n\tMemoryContextSwitchTo(oldcontext);\n}"
  },
  {
    "function_name": "tuplesort_markpos",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "3062-3088",
    "snippet": "void\ntuplesort_markpos(Tuplesortstate *state)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\n\tAssert(state->randomAccess);\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_SORTEDINMEM:\n\t\t\tstate->markpos_offset = state->current;\n\t\t\tstate->markpos_eof = state->eof_reached;\n\t\t\tbreak;\n\t\tcase TSS_SORTEDONTAPE:\n\t\t\tLogicalTapeTell(state->tapeset,\n\t\t\t\t\t\t\tstate->result_tape,\n\t\t\t\t\t\t\t&state->markpos_block,\n\t\t\t\t\t\t\t&state->markpos_offset);\n\t\t\tstate->markpos_eof = state->eof_reached;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplesort state\");\n\t\t\tbreak;\n\t}\n\n\tMemoryContextSwitchTo(oldcontext);\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);",
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 3087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"invalid tuplesort state\""
          ],
          "line": 3083
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LogicalTapeTell",
          "args": [
            "state->tapeset",
            "state->result_tape",
            "&state->markpos_block",
            "&state->markpos_offset"
          ],
          "line": 3076
        },
        "resolved": true,
        "details": {
          "function_name": "LogicalTapeTell",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/logtape.c",
          "lines": "1061-1076",
          "snippet": "void\nLogicalTapeTell(LogicalTapeSet *lts, int tapenum,\n\t\t\t\tlong *blocknum, int *offset)\n{\n\tLogicalTape *lt;\n\n\tAssert(tapenum >= 0 && tapenum < lts->nTapes);\n\tlt = &lts->tapes[tapenum];\n\tAssert(lt->offsetBlockNumber == 0L);\n\n\t/* With a larger buffer, 'pos' wouldn't be the same as offset within page */\n\tAssert(lt->buffer_size == BLCKSZ);\n\n\t*blocknum = lt->curBlockNumber;\n\t*offset = lt->pos;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
            "static void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
            "static long ltsGetFreeBlock(LogicalTapeSet *lts);",
            "static void ltsReleaseBlock(LogicalTapeSet *lts, long blocknum);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/logtape.h\"\n#include \"utils/builtins.h\"\n#include \"storage/buffile.h\"\n#include \"postgres.h\"\n\nstatic void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic long ltsGetFreeBlock(LogicalTapeSet *lts);\nstatic void ltsReleaseBlock(LogicalTapeSet *lts, long blocknum);\n\nvoid\nLogicalTapeTell(LogicalTapeSet *lts, int tapenum,\n\t\t\t\tlong *blocknum, int *offset)\n{\n\tLogicalTape *lt;\n\n\tAssert(tapenum >= 0 && tapenum < lts->nTapes);\n\tlt = &lts->tapes[tapenum];\n\tAssert(lt->offsetBlockNumber == 0L);\n\n\t/* With a larger buffer, 'pos' wouldn't be the same as offset within page */\n\tAssert(lt->buffer_size == BLCKSZ);\n\n\t*blocknum = lt->curBlockNumber;\n\t*offset = lt->pos;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "state->randomAccess"
          ],
          "line": 3067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "state->sortcontext"
          ],
          "line": 3065
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nvoid\ntuplesort_markpos(Tuplesortstate *state)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\n\tAssert(state->randomAccess);\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_SORTEDINMEM:\n\t\t\tstate->markpos_offset = state->current;\n\t\t\tstate->markpos_eof = state->eof_reached;\n\t\t\tbreak;\n\t\tcase TSS_SORTEDONTAPE:\n\t\t\tLogicalTapeTell(state->tapeset,\n\t\t\t\t\t\t\tstate->result_tape,\n\t\t\t\t\t\t\t&state->markpos_block,\n\t\t\t\t\t\t\t&state->markpos_offset);\n\t\t\tstate->markpos_eof = state->eof_reached;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplesort state\");\n\t\t\tbreak;\n\t}\n\n\tMemoryContextSwitchTo(oldcontext);\n}"
  },
  {
    "function_name": "tuplesort_rescan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "3027-3057",
    "snippet": "void\ntuplesort_rescan(Tuplesortstate *state)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\n\tAssert(state->randomAccess);\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_SORTEDINMEM:\n\t\t\tstate->current = 0;\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tbreak;\n\t\tcase TSS_SORTEDONTAPE:\n\t\t\tLogicalTapeRewindForRead(state->tapeset,\n\t\t\t\t\t\t\t\t\t state->result_tape,\n\t\t\t\t\t\t\t\t\t 0);\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_block = 0L;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplesort state\");\n\t\t\tbreak;\n\t}\n\n\tMemoryContextSwitchTo(oldcontext);\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);",
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 3056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"invalid tuplesort state\""
          ],
          "line": 3052
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LogicalTapeRewindForRead",
          "args": [
            "state->tapeset",
            "state->result_tape",
            "0"
          ],
          "line": 3043
        },
        "resolved": true,
        "details": {
          "function_name": "LogicalTapeRewindForRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/logtape.c",
          "lines": "708-785",
          "snippet": "void\nLogicalTapeRewindForRead(LogicalTapeSet *lts, int tapenum, size_t buffer_size)\n{\n\tLogicalTape *lt;\n\n\tAssert(tapenum >= 0 && tapenum < lts->nTapes);\n\tlt = &lts->tapes[tapenum];\n\n\t/*\n\t * Round and cap buffer_size if needed.\n\t */\n\tif (lt->frozen)\n\t\tbuffer_size = BLCKSZ;\n\telse\n\t{\n\t\t/* need at least one block */\n\t\tif (buffer_size < BLCKSZ)\n\t\t\tbuffer_size = BLCKSZ;\n\n\t\t/* palloc() larger than max_size is unlikely to be helpful */\n\t\tif (buffer_size > lt->max_size)\n\t\t\tbuffer_size = lt->max_size;\n\n\t\t/* round down to BLCKSZ boundary */\n\t\tbuffer_size -= buffer_size % BLCKSZ;\n\t}\n\n\tif (lt->writing)\n\t{\n\t\t/*\n\t\t * Completion of a write phase.  Flush last partial data block, and\n\t\t * rewind for normal (destructive) read.\n\t\t */\n\t\tif (lt->dirty)\n\t\t{\n\t\t\t/*\n\t\t\t * As long as we've filled the buffer at least once, its contents\n\t\t\t * are entirely defined from valgrind's point of view, even though\n\t\t\t * contents beyond the current end point may be stale.  But it's\n\t\t\t * possible - at least in the case of a parallel sort - to sort\n\t\t\t * such small amount of data that we do not fill the buffer even\n\t\t\t * once.  Tell valgrind that its contents are defined, so it\n\t\t\t * doesn't bleat.\n\t\t\t */\n\t\t\tVALGRIND_MAKE_MEM_DEFINED(lt->buffer + lt->nbytes,\n\t\t\t\t\t\t\t\t\t  lt->buffer_size - lt->nbytes);\n\n\t\t\tTapeBlockSetNBytes(lt->buffer, lt->nbytes);\n\t\t\tltsWriteBlock(lts, lt->curBlockNumber, (void *) lt->buffer);\n\t\t}\n\t\tlt->writing = false;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * This is only OK if tape is frozen; we rewind for (another) read\n\t\t * pass.\n\t\t */\n\t\tAssert(lt->frozen);\n\t}\n\n\t/* Allocate a read buffer (unless the tape is empty) */\n\tif (lt->buffer)\n\t\tpfree(lt->buffer);\n\tlt->buffer = NULL;\n\tlt->buffer_size = 0;\n\tif (lt->firstBlockNumber != -1L)\n\t{\n\t\tlt->buffer = palloc(buffer_size);\n\t\tlt->buffer_size = buffer_size;\n\t}\n\n\t/* Read the first block, or reset if tape is empty */\n\tlt->nextBlockNumber = lt->firstBlockNumber;\n\tlt->pos = 0;\n\tlt->nbytes = 0;\n\tltsReadFillBuffer(lts, lt);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
            "static void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
            "static long ltsGetFreeBlock(LogicalTapeSet *lts);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/logtape.h\"\n#include \"utils/builtins.h\"\n#include \"storage/buffile.h\"\n#include \"postgres.h\"\n\nstatic void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic long ltsGetFreeBlock(LogicalTapeSet *lts);\n\nvoid\nLogicalTapeRewindForRead(LogicalTapeSet *lts, int tapenum, size_t buffer_size)\n{\n\tLogicalTape *lt;\n\n\tAssert(tapenum >= 0 && tapenum < lts->nTapes);\n\tlt = &lts->tapes[tapenum];\n\n\t/*\n\t * Round and cap buffer_size if needed.\n\t */\n\tif (lt->frozen)\n\t\tbuffer_size = BLCKSZ;\n\telse\n\t{\n\t\t/* need at least one block */\n\t\tif (buffer_size < BLCKSZ)\n\t\t\tbuffer_size = BLCKSZ;\n\n\t\t/* palloc() larger than max_size is unlikely to be helpful */\n\t\tif (buffer_size > lt->max_size)\n\t\t\tbuffer_size = lt->max_size;\n\n\t\t/* round down to BLCKSZ boundary */\n\t\tbuffer_size -= buffer_size % BLCKSZ;\n\t}\n\n\tif (lt->writing)\n\t{\n\t\t/*\n\t\t * Completion of a write phase.  Flush last partial data block, and\n\t\t * rewind for normal (destructive) read.\n\t\t */\n\t\tif (lt->dirty)\n\t\t{\n\t\t\t/*\n\t\t\t * As long as we've filled the buffer at least once, its contents\n\t\t\t * are entirely defined from valgrind's point of view, even though\n\t\t\t * contents beyond the current end point may be stale.  But it's\n\t\t\t * possible - at least in the case of a parallel sort - to sort\n\t\t\t * such small amount of data that we do not fill the buffer even\n\t\t\t * once.  Tell valgrind that its contents are defined, so it\n\t\t\t * doesn't bleat.\n\t\t\t */\n\t\t\tVALGRIND_MAKE_MEM_DEFINED(lt->buffer + lt->nbytes,\n\t\t\t\t\t\t\t\t\t  lt->buffer_size - lt->nbytes);\n\n\t\t\tTapeBlockSetNBytes(lt->buffer, lt->nbytes);\n\t\t\tltsWriteBlock(lts, lt->curBlockNumber, (void *) lt->buffer);\n\t\t}\n\t\tlt->writing = false;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * This is only OK if tape is frozen; we rewind for (another) read\n\t\t * pass.\n\t\t */\n\t\tAssert(lt->frozen);\n\t}\n\n\t/* Allocate a read buffer (unless the tape is empty) */\n\tif (lt->buffer)\n\t\tpfree(lt->buffer);\n\tlt->buffer = NULL;\n\tlt->buffer_size = 0;\n\tif (lt->firstBlockNumber != -1L)\n\t{\n\t\tlt->buffer = palloc(buffer_size);\n\t\tlt->buffer_size = buffer_size;\n\t}\n\n\t/* Read the first block, or reset if tape is empty */\n\tlt->nextBlockNumber = lt->firstBlockNumber;\n\tlt->pos = 0;\n\tlt->nbytes = 0;\n\tltsReadFillBuffer(lts, lt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "state->randomAccess"
          ],
          "line": 3032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "state->sortcontext"
          ],
          "line": 3030
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nvoid\ntuplesort_rescan(Tuplesortstate *state)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\n\tAssert(state->randomAccess);\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_SORTEDINMEM:\n\t\t\tstate->current = 0;\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tbreak;\n\t\tcase TSS_SORTEDONTAPE:\n\t\t\tLogicalTapeRewindForRead(state->tapeset,\n\t\t\t\t\t\t\t\t\t state->result_tape,\n\t\t\t\t\t\t\t\t\t 0);\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_block = 0L;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplesort state\");\n\t\t\tbreak;\n\t}\n\n\tMemoryContextSwitchTo(oldcontext);\n}"
  },
  {
    "function_name": "dumptuples",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "2924-3022",
    "snippet": "static void\ndumptuples(Tuplesortstate *state, bool alltuples)\n{\n\tint\t\t\tmemtupwrite;\n\tint\t\t\ti;\n\n\t/*\n\t * Nothing to do if we still fit in available memory and have array slots,\n\t * unless this is the final call during initial run generation.\n\t */\n\tif (state->memtupcount < state->memtupsize && !LACKMEM(state) &&\n\t\t!alltuples)\n\t\treturn;\n\n\t/*\n\t * Final call might require no sorting, in rare cases where we just so\n\t * happen to have previously LACKMEM()'d at the point where exactly all\n\t * remaining tuples are loaded into memory, just before input was\n\t * exhausted.\n\t *\n\t * In general, short final runs are quite possible.  Rather than allowing\n\t * a special case where there was a superfluous selectnewtape() call (i.e.\n\t * a call with no subsequent run actually written to destTape), we prefer\n\t * to write out a 0 tuple run.\n\t *\n\t * mergereadnext() is prepared for 0 tuple runs, and will reliably mark\n\t * the tape inactive for the merge when called from beginmerge().  This\n\t * case is therefore similar to the case where mergeonerun() finds a dummy\n\t * run for the tape, and so doesn't need to merge a run from the tape (or\n\t * conceptually \"merges\" the dummy run, if you prefer).  According to\n\t * Knuth, Algorithm D \"isn't strictly optimal\" in its method of\n\t * distribution and dummy run assignment; this edge case seems very\n\t * unlikely to make that appreciably worse.\n\t */\n\tAssert(state->status == TSS_BUILDRUNS);\n\n\t/*\n\t * It seems unlikely that this limit will ever be exceeded, but take no\n\t * chances\n\t */\n\tif (state->currentRun == INT_MAX)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"cannot have more than %d runs for an external sort\",\n\t\t\t\t\t\tINT_MAX)));\n\n\tstate->currentRun++;\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\telog(LOG, \"worker %d starting quicksort of run %d: %s\",\n\t\t\t state->worker, state->currentRun,\n\t\t\t pg_rusage_show(&state->ru_start));\n#endif\n\n\t/*\n\t * Sort all tuples accumulated within the allowed amount of memory for\n\t * this run using quicksort\n\t */\n\ttuplesort_sort_memtuples(state);\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\telog(LOG, \"worker %d finished quicksort of run %d: %s\",\n\t\t\t state->worker, state->currentRun,\n\t\t\t pg_rusage_show(&state->ru_start));\n#endif\n\n\tmemtupwrite = state->memtupcount;\n\tfor (i = 0; i < memtupwrite; i++)\n\t{\n\t\tWRITETUP(state, state->tp_tapenum[state->destTape],\n\t\t\t\t &state->memtuples[i]);\n\t\tstate->memtupcount--;\n\t}\n\n\t/*\n\t * Reset tuple memory.  We've freed all of the tuples that we previously\n\t * allocated.  It's important to avoid fragmentation when there is a stark\n\t * change in the sizes of incoming tuples.  Fragmentation due to\n\t * AllocSetFree's bucketing by size class might be particularly bad if\n\t * this step wasn't taken.\n\t */\n\tMemoryContextReset(state->tuplecontext);\n\n\tmarkrunend(state, state->tp_tapenum[state->destTape]);\n\tstate->tp_runs[state->destTape]++;\n\tstate->tp_dummy[state->destTape]--; /* per Alg D step D2 */\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\telog(LOG, \"worker %d finished writing run %d to tape %d: %s\",\n\t\t\t state->worker, state->currentRun, state->destTape,\n\t\t\t pg_rusage_show(&state->ru_start));\n#endif\n\n\tif (!alltuples)\n\t\tselectnewtape(state);\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static void dumptuples(Tuplesortstate *state, bool alltuples);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "selectnewtape",
          "args": [
            "state"
          ],
          "line": 3021
        },
        "resolved": true,
        "details": {
          "function_name": "selectnewtape",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "2492-2519",
          "snippet": "static void\nselectnewtape(Tuplesortstate *state)\n{\n\tint\t\t\tj;\n\tint\t\t\ta;\n\n\t/* Step D3: advance j (destTape) */\n\tif (state->tp_dummy[state->destTape] < state->tp_dummy[state->destTape + 1])\n\t{\n\t\tstate->destTape++;\n\t\treturn;\n\t}\n\tif (state->tp_dummy[state->destTape] != 0)\n\t{\n\t\tstate->destTape = 0;\n\t\treturn;\n\t}\n\n\t/* Step D4: increase level */\n\tstate->Level++;\n\ta = state->tp_fib[0];\n\tfor (j = 0; j < state->tapeRange; j++)\n\t{\n\t\tstate->tp_dummy[j] = a + state->tp_fib[j + 1] - state->tp_fib[j];\n\t\tstate->tp_fib[j] = a + state->tp_fib[j + 1];\n\t}\n\tstate->destTape = 0;\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic void\nselectnewtape(Tuplesortstate *state)\n{\n\tint\t\t\tj;\n\tint\t\t\ta;\n\n\t/* Step D3: advance j (destTape) */\n\tif (state->tp_dummy[state->destTape] < state->tp_dummy[state->destTape + 1])\n\t{\n\t\tstate->destTape++;\n\t\treturn;\n\t}\n\tif (state->tp_dummy[state->destTape] != 0)\n\t{\n\t\tstate->destTape = 0;\n\t\treturn;\n\t}\n\n\t/* Step D4: increase level */\n\tstate->Level++;\n\ta = state->tp_fib[0];\n\tfor (j = 0; j < state->tapeRange; j++)\n\t{\n\t\tstate->tp_dummy[j] = a + state->tp_fib[j + 1] - state->tp_fib[j];\n\t\tstate->tp_fib[j] = a + state->tp_fib[j + 1];\n\t}\n\tstate->destTape = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "LOG",
            "\"worker %d finished writing run %d to tape %d: %s\"",
            "state->worker",
            "state->currentRun",
            "state->destTape",
            "pg_rusage_show(&state->ru_start)"
          ],
          "line": 3015
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_rusage_show",
          "args": [
            "&state->ru_start"
          ],
          "line": 3017
        },
        "resolved": true,
        "details": {
          "function_name": "pg_rusage_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/pg_rusage.c",
          "lines": "39-73",
          "snippet": "const char *\npg_rusage_show(const PGRUsage *ru0)\n{\n\tstatic char result[100];\n\tPGRUsage\tru1;\n\n\tpg_rusage_init(&ru1);\n\n\tif (ru1.tv.tv_usec < ru0->tv.tv_usec)\n\t{\n\t\tru1.tv.tv_sec--;\n\t\tru1.tv.tv_usec += 1000000;\n\t}\n\tif (ru1.ru.ru_stime.tv_usec < ru0->ru.ru_stime.tv_usec)\n\t{\n\t\tru1.ru.ru_stime.tv_sec--;\n\t\tru1.ru.ru_stime.tv_usec += 1000000;\n\t}\n\tif (ru1.ru.ru_utime.tv_usec < ru0->ru.ru_utime.tv_usec)\n\t{\n\t\tru1.ru.ru_utime.tv_sec--;\n\t\tru1.ru.ru_utime.tv_usec += 1000000;\n\t}\n\n\tsnprintf(result, sizeof(result),\n\t\t\t _(\"CPU: user: %d.%02d s, system: %d.%02d s, elapsed: %d.%02d s\"),\n\t\t\t (int) (ru1.ru.ru_utime.tv_sec - ru0->ru.ru_utime.tv_sec),\n\t\t\t (int) (ru1.ru.ru_utime.tv_usec - ru0->ru.ru_utime.tv_usec) / 10000,\n\t\t\t (int) (ru1.ru.ru_stime.tv_sec - ru0->ru.ru_stime.tv_sec),\n\t\t\t (int) (ru1.ru.ru_stime.tv_usec - ru0->ru.ru_stime.tv_usec) / 10000,\n\t\t\t (int) (ru1.tv.tv_sec - ru0->tv.tv_sec),\n\t\t\t (int) (ru1.tv.tv_usec - ru0->tv.tv_usec) / 10000);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/pg_rusage.h\"",
            "#include <unistd.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_rusage.h\"\n#include <unistd.h>\n#include \"postgres.h\"\n\nconst char *\npg_rusage_show(const PGRUsage *ru0)\n{\n\tstatic char result[100];\n\tPGRUsage\tru1;\n\n\tpg_rusage_init(&ru1);\n\n\tif (ru1.tv.tv_usec < ru0->tv.tv_usec)\n\t{\n\t\tru1.tv.tv_sec--;\n\t\tru1.tv.tv_usec += 1000000;\n\t}\n\tif (ru1.ru.ru_stime.tv_usec < ru0->ru.ru_stime.tv_usec)\n\t{\n\t\tru1.ru.ru_stime.tv_sec--;\n\t\tru1.ru.ru_stime.tv_usec += 1000000;\n\t}\n\tif (ru1.ru.ru_utime.tv_usec < ru0->ru.ru_utime.tv_usec)\n\t{\n\t\tru1.ru.ru_utime.tv_sec--;\n\t\tru1.ru.ru_utime.tv_usec += 1000000;\n\t}\n\n\tsnprintf(result, sizeof(result),\n\t\t\t _(\"CPU: user: %d.%02d s, system: %d.%02d s, elapsed: %d.%02d s\"),\n\t\t\t (int) (ru1.ru.ru_utime.tv_sec - ru0->ru.ru_utime.tv_sec),\n\t\t\t (int) (ru1.ru.ru_utime.tv_usec - ru0->ru.ru_utime.tv_usec) / 10000,\n\t\t\t (int) (ru1.ru.ru_stime.tv_sec - ru0->ru.ru_stime.tv_sec),\n\t\t\t (int) (ru1.ru.ru_stime.tv_usec - ru0->ru.ru_stime.tv_usec) / 10000,\n\t\t\t (int) (ru1.tv.tv_sec - ru0->tv.tv_sec),\n\t\t\t (int) (ru1.tv.tv_usec - ru0->tv.tv_usec) / 10000);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "markrunend",
          "args": [
            "state",
            "state->tp_tapenum[state->destTape]"
          ],
          "line": 3009
        },
        "resolved": true,
        "details": {
          "function_name": "markrunend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "3466-3472",
          "snippet": "static void\nmarkrunend(Tuplesortstate *state, int tapenum)\n{\n\tunsigned int len = 0;\n\n\tLogicalTapeWrite(state->tapeset, tapenum, (void *) &len, sizeof(len));\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static void markrunend(Tuplesortstate *state, int tapenum);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static void readtup_heap(Tuplesortstate *state, SortTuple *stup,\n\t\t\t int tapenum, unsigned int len);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static void readtup_cluster(Tuplesortstate *state, SortTuple *stup,\n\t\t\t\tint tapenum, unsigned int len);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static void readtup_index(Tuplesortstate *state, SortTuple *stup,\n\t\t\t  int tapenum, unsigned int len);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static void readtup_datum(Tuplesortstate *state, SortTuple *stup,\n\t\t\t  int tapenum, unsigned int len);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic void markrunend(Tuplesortstate *state, int tapenum);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic void readtup_heap(Tuplesortstate *state, SortTuple *stup,\n\t\t\t int tapenum, unsigned int len);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic void readtup_cluster(Tuplesortstate *state, SortTuple *stup,\n\t\t\t\tint tapenum, unsigned int len);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic void readtup_index(Tuplesortstate *state, SortTuple *stup,\n\t\t\t  int tapenum, unsigned int len);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic void readtup_datum(Tuplesortstate *state, SortTuple *stup,\n\t\t\t  int tapenum, unsigned int len);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic void\nmarkrunend(Tuplesortstate *state, int tapenum)\n{\n\tunsigned int len = 0;\n\n\tLogicalTapeWrite(state->tapeset, tapenum, (void *) &len, sizeof(len));\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextReset",
          "args": [
            "state->tuplecontext"
          ],
          "line": 3007
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextResetChildren",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "187-199",
          "snippet": "void\nMemoryContextResetChildren(MemoryContext context)\n{\n\tMemoryContext child;\n\n\tAssertArg(MemoryContextIsValid(context));\n\n\tfor (child = context->firstchild; child != NULL; child = child->nextchild)\n\t{\n\t\tMemoryContextResetChildren(child);\n\t\tMemoryContextResetOnly(child);\n\t}\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\nMemoryContextResetChildren(MemoryContext context)\n{\n\tMemoryContext child;\n\n\tAssertArg(MemoryContextIsValid(context));\n\n\tfor (child = context->firstchild; child != NULL; child = child->nextchild)\n\t{\n\t\tMemoryContextResetChildren(child);\n\t\tMemoryContextResetOnly(child);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITETUP",
          "args": [
            "state",
            "state->tp_tapenum[state->destTape]",
            "&state->memtuples[i]"
          ],
          "line": 2995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tuplesort_sort_memtuples",
          "args": [
            "state"
          ],
          "line": 2983
        },
        "resolved": true,
        "details": {
          "function_name": "tuplesort_sort_memtuples",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "3308-3325",
          "snippet": "static void\ntuplesort_sort_memtuples(Tuplesortstate *state)\n{\n\tAssert(!LEADER(state));\n\n\tif (state->memtupcount > 1)\n\t{\n\t\t/* Can we use the single-key sort function? */\n\t\tif (state->onlyKey != NULL)\n\t\t\tqsort_ssup(state->memtuples, state->memtupcount,\n\t\t\t\t\t   state->onlyKey);\n\t\telse\n\t\t\tqsort_tuple(state->memtuples,\n\t\t\t\t\t\tstate->memtupcount,\n\t\t\t\t\t\tstate->comparetup,\n\t\t\t\t\t\tstate);\n\t}\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic void\ntuplesort_sort_memtuples(Tuplesortstate *state)\n{\n\tAssert(!LEADER(state));\n\n\tif (state->memtupcount > 1)\n\t{\n\t\t/* Can we use the single-key sort function? */\n\t\tif (state->onlyKey != NULL)\n\t\t\tqsort_ssup(state->memtuples, state->memtupcount,\n\t\t\t\t\t   state->onlyKey);\n\t\telse\n\t\t\tqsort_tuple(state->memtuples,\n\t\t\t\t\t\tstate->memtupcount,\n\t\t\t\t\t\tstate->comparetup,\n\t\t\t\t\t\tstate);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"cannot have more than %d runs for an external sort\",\n\t\t\t\t\t\tINT_MAX))"
          ],
          "line": 2965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"cannot have more than %d runs for an external sort\"",
            "INT_MAX"
          ],
          "line": 2967
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_PROGRAM_LIMIT_EXCEEDED"
          ],
          "line": 2966
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "state->status == TSS_BUILDRUNS"
          ],
          "line": 2958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LACKMEM",
          "args": [
            "state"
          ],
          "line": 2934
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void dumptuples(Tuplesortstate *state, bool alltuples);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic void\ndumptuples(Tuplesortstate *state, bool alltuples)\n{\n\tint\t\t\tmemtupwrite;\n\tint\t\t\ti;\n\n\t/*\n\t * Nothing to do if we still fit in available memory and have array slots,\n\t * unless this is the final call during initial run generation.\n\t */\n\tif (state->memtupcount < state->memtupsize && !LACKMEM(state) &&\n\t\t!alltuples)\n\t\treturn;\n\n\t/*\n\t * Final call might require no sorting, in rare cases where we just so\n\t * happen to have previously LACKMEM()'d at the point where exactly all\n\t * remaining tuples are loaded into memory, just before input was\n\t * exhausted.\n\t *\n\t * In general, short final runs are quite possible.  Rather than allowing\n\t * a special case where there was a superfluous selectnewtape() call (i.e.\n\t * a call with no subsequent run actually written to destTape), we prefer\n\t * to write out a 0 tuple run.\n\t *\n\t * mergereadnext() is prepared for 0 tuple runs, and will reliably mark\n\t * the tape inactive for the merge when called from beginmerge().  This\n\t * case is therefore similar to the case where mergeonerun() finds a dummy\n\t * run for the tape, and so doesn't need to merge a run from the tape (or\n\t * conceptually \"merges\" the dummy run, if you prefer).  According to\n\t * Knuth, Algorithm D \"isn't strictly optimal\" in its method of\n\t * distribution and dummy run assignment; this edge case seems very\n\t * unlikely to make that appreciably worse.\n\t */\n\tAssert(state->status == TSS_BUILDRUNS);\n\n\t/*\n\t * It seems unlikely that this limit will ever be exceeded, but take no\n\t * chances\n\t */\n\tif (state->currentRun == INT_MAX)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"cannot have more than %d runs for an external sort\",\n\t\t\t\t\t\tINT_MAX)));\n\n\tstate->currentRun++;\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\telog(LOG, \"worker %d starting quicksort of run %d: %s\",\n\t\t\t state->worker, state->currentRun,\n\t\t\t pg_rusage_show(&state->ru_start));\n#endif\n\n\t/*\n\t * Sort all tuples accumulated within the allowed amount of memory for\n\t * this run using quicksort\n\t */\n\ttuplesort_sort_memtuples(state);\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\telog(LOG, \"worker %d finished quicksort of run %d: %s\",\n\t\t\t state->worker, state->currentRun,\n\t\t\t pg_rusage_show(&state->ru_start));\n#endif\n\n\tmemtupwrite = state->memtupcount;\n\tfor (i = 0; i < memtupwrite; i++)\n\t{\n\t\tWRITETUP(state, state->tp_tapenum[state->destTape],\n\t\t\t\t &state->memtuples[i]);\n\t\tstate->memtupcount--;\n\t}\n\n\t/*\n\t * Reset tuple memory.  We've freed all of the tuples that we previously\n\t * allocated.  It's important to avoid fragmentation when there is a stark\n\t * change in the sizes of incoming tuples.  Fragmentation due to\n\t * AllocSetFree's bucketing by size class might be particularly bad if\n\t * this step wasn't taken.\n\t */\n\tMemoryContextReset(state->tuplecontext);\n\n\tmarkrunend(state, state->tp_tapenum[state->destTape]);\n\tstate->tp_runs[state->destTape]++;\n\tstate->tp_dummy[state->destTape]--; /* per Alg D step D2 */\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\telog(LOG, \"worker %d finished writing run %d to tape %d: %s\",\n\t\t\t state->worker, state->currentRun, state->destTape,\n\t\t\t pg_rusage_show(&state->ru_start));\n#endif\n\n\tif (!alltuples)\n\t\tselectnewtape(state);\n}"
  },
  {
    "function_name": "mergereadnext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "2899-2916",
    "snippet": "static bool\nmergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup)\n{\n\tunsigned int tuplen;\n\n\tif (!state->mergeactive[srcTape])\n\t\treturn false;\t\t\t/* tape's run is already exhausted */\n\n\t/* read next tuple, if any */\n\tif ((tuplen = getlen(state, srcTape, true)) == 0)\n\t{\n\t\tstate->mergeactive[srcTape] = false;\n\t\treturn false;\n\t}\n\tREADTUP(state, stup, srcTape, tuplen);\n\n\treturn true;\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static void *readtup_alloc(Tuplesortstate *state, Size tuplen);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);",
      "static void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "READTUP",
          "args": [
            "state",
            "stup",
            "srcTape",
            "tuplen"
          ],
          "line": 2913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getlen",
          "args": [
            "state",
            "srcTape",
            "true"
          ],
          "line": 2908
        },
        "resolved": true,
        "details": {
          "function_name": "getlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "3453-3464",
          "snippet": "static unsigned int\ngetlen(Tuplesortstate *state, int tapenum, bool eofOK)\n{\n\tunsigned int len;\n\n\tif (LogicalTapeRead(state->tapeset, tapenum,\n\t\t\t\t\t\t&len, sizeof(len)) != sizeof(len))\n\t\telog(ERROR, \"unexpected end of tape\");\n\tif (len == 0 && !eofOK)\n\t\telog(ERROR, \"unexpected end of data\");\n\treturn len;\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static unsigned int getlen(Tuplesortstate *state, int tapenum, bool eofOK);",
            "static void markrunend(Tuplesortstate *state, int tapenum);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static void readtup_heap(Tuplesortstate *state, SortTuple *stup,\n\t\t\t int tapenum, unsigned int len);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static void readtup_cluster(Tuplesortstate *state, SortTuple *stup,\n\t\t\t\tint tapenum, unsigned int len);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static void readtup_index(Tuplesortstate *state, SortTuple *stup,\n\t\t\t  int tapenum, unsigned int len);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static void readtup_datum(Tuplesortstate *state, SortTuple *stup,\n\t\t\t  int tapenum, unsigned int len);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic unsigned int getlen(Tuplesortstate *state, int tapenum, bool eofOK);\nstatic void markrunend(Tuplesortstate *state, int tapenum);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic void readtup_heap(Tuplesortstate *state, SortTuple *stup,\n\t\t\t int tapenum, unsigned int len);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic void readtup_cluster(Tuplesortstate *state, SortTuple *stup,\n\t\t\t\tint tapenum, unsigned int len);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic void readtup_index(Tuplesortstate *state, SortTuple *stup,\n\t\t\t  int tapenum, unsigned int len);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic void readtup_datum(Tuplesortstate *state, SortTuple *stup,\n\t\t\t  int tapenum, unsigned int len);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic unsigned int\ngetlen(Tuplesortstate *state, int tapenum, bool eofOK)\n{\n\tunsigned int len;\n\n\tif (LogicalTapeRead(state->tapeset, tapenum,\n\t\t\t\t\t\t&len, sizeof(len)) != sizeof(len))\n\t\telog(ERROR, \"unexpected end of tape\");\n\tif (len == 0 && !eofOK)\n\t\telog(ERROR, \"unexpected end of data\");\n\treturn len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic void *readtup_alloc(Tuplesortstate *state, Size tuplen);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\nstatic void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);\n\nstatic bool\nmergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup)\n{\n\tunsigned int tuplen;\n\n\tif (!state->mergeactive[srcTape])\n\t\treturn false;\t\t\t/* tape's run is already exhausted */\n\n\t/* read next tuple, if any */\n\tif ((tuplen = getlen(state, srcTape, true)) == 0)\n\t{\n\t\tstate->mergeactive[srcTape] = false;\n\t\treturn false;\n\t}\n\tREADTUP(state, stup, srcTape, tuplen);\n\n\treturn true;\n}"
  },
  {
    "function_name": "beginmerge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "2851-2892",
    "snippet": "static void\nbeginmerge(Tuplesortstate *state)\n{\n\tint\t\t\tactiveTapes;\n\tint\t\t\ttapenum;\n\tint\t\t\tsrcTape;\n\n\t/* Heap should be empty here */\n\tAssert(state->memtupcount == 0);\n\n\t/* Adjust run counts and mark the active tapes */\n\tmemset(state->mergeactive, 0,\n\t\t   state->maxTapes * sizeof(*state->mergeactive));\n\tactiveTapes = 0;\n\tfor (tapenum = 0; tapenum < state->tapeRange; tapenum++)\n\t{\n\t\tif (state->tp_dummy[tapenum] > 0)\n\t\t\tstate->tp_dummy[tapenum]--;\n\t\telse\n\t\t{\n\t\t\tAssert(state->tp_runs[tapenum] > 0);\n\t\t\tstate->tp_runs[tapenum]--;\n\t\t\tsrcTape = state->tp_tapenum[tapenum];\n\t\t\tstate->mergeactive[srcTape] = true;\n\t\t\tactiveTapes++;\n\t\t}\n\t}\n\tAssert(activeTapes > 0);\n\tstate->activeTapes = activeTapes;\n\n\t/* Load the merge heap with the first tuple from each input tape */\n\tfor (srcTape = 0; srcTape < state->maxTapes; srcTape++)\n\t{\n\t\tSortTuple\ttup;\n\n\t\tif (mergereadnext(state, srcTape, &tup))\n\t\t{\n\t\t\ttup.tupindex = srcTape;\n\t\t\ttuplesort_heap_insert(state, &tup);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void inittapestate(Tuplesortstate *state, int maxTapes);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static void markrunend(Tuplesortstate *state, int tapenum);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static void copytup_heap(Tuplesortstate *state, SortTuple *stup, void *tup);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static void copytup_cluster(Tuplesortstate *state, SortTuple *stup, void *tup);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static void copytup_index(Tuplesortstate *state, SortTuple *stup, void *tup);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static void copytup_datum(Tuplesortstate *state, SortTuple *stup, void *tup);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tuplesort_heap_insert",
          "args": [
            "state",
            "&tup"
          ],
          "line": 2889
        },
        "resolved": true,
        "details": {
          "function_name": "tuplesort_heap_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "3336-3362",
          "snippet": "static void\ntuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple)\n{\n\tSortTuple  *memtuples;\n\tint\t\t\tj;\n\n\tmemtuples = state->memtuples;\n\tAssert(state->memtupcount < state->memtupsize);\n\n\tCHECK_FOR_INTERRUPTS();\n\n\t/*\n\t * Sift-up the new entry, per Knuth 5.2.3 exercise 16. Note that Knuth is\n\t * using 1-based array indexes, not 0-based.\n\t */\n\tj = state->memtupcount++;\n\twhile (j > 0)\n\t{\n\t\tint\t\t\ti = (j - 1) >> 1;\n\n\t\tif (COMPARETUP(state, tuple, &memtuples[i]) >= 0)\n\t\t\tbreak;\n\t\tmemtuples[j] = memtuples[i];\n\t\tj = i;\n\t}\n\tmemtuples[j] = *tuple;\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic void\ntuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple)\n{\n\tSortTuple  *memtuples;\n\tint\t\t\tj;\n\n\tmemtuples = state->memtuples;\n\tAssert(state->memtupcount < state->memtupsize);\n\n\tCHECK_FOR_INTERRUPTS();\n\n\t/*\n\t * Sift-up the new entry, per Knuth 5.2.3 exercise 16. Note that Knuth is\n\t * using 1-based array indexes, not 0-based.\n\t */\n\tj = state->memtupcount++;\n\twhile (j > 0)\n\t{\n\t\tint\t\t\ti = (j - 1) >> 1;\n\n\t\tif (COMPARETUP(state, tuple, &memtuples[i]) >= 0)\n\t\t\tbreak;\n\t\tmemtuples[j] = memtuples[i];\n\t\tj = i;\n\t}\n\tmemtuples[j] = *tuple;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mergereadnext",
          "args": [
            "state",
            "srcTape",
            "&tup"
          ],
          "line": 2886
        },
        "resolved": true,
        "details": {
          "function_name": "mergereadnext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "2899-2916",
          "snippet": "static bool\nmergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup)\n{\n\tunsigned int tuplen;\n\n\tif (!state->mergeactive[srcTape])\n\t\treturn false;\t\t\t/* tape's run is already exhausted */\n\n\t/* read next tuple, if any */\n\tif ((tuplen = getlen(state, srcTape, true)) == 0)\n\t{\n\t\tstate->mergeactive[srcTape] = false;\n\t\treturn false;\n\t}\n\tREADTUP(state, stup, srcTape, tuplen);\n\n\treturn true;\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static void *readtup_alloc(Tuplesortstate *state, Size tuplen);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);",
            "static void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic void *readtup_alloc(Tuplesortstate *state, Size tuplen);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\nstatic void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);\n\nstatic bool\nmergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup)\n{\n\tunsigned int tuplen;\n\n\tif (!state->mergeactive[srcTape])\n\t\treturn false;\t\t\t/* tape's run is already exhausted */\n\n\t/* read next tuple, if any */\n\tif ((tuplen = getlen(state, srcTape, true)) == 0)\n\t{\n\t\tstate->mergeactive[srcTape] = false;\n\t\treturn false;\n\t}\n\tREADTUP(state, stup, srcTape, tuplen);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "activeTapes > 0"
          ],
          "line": 2878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "state->tp_runs[tapenum] > 0"
          ],
          "line": 2871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "state->mergeactive",
            "0",
            "state->maxTapes * sizeof(*state->mergeactive)"
          ],
          "line": 2862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "state->memtupcount == 0"
          ],
          "line": 2859
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void inittapestate(Tuplesortstate *state, int maxTapes);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic void markrunend(Tuplesortstate *state, int tapenum);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic void copytup_heap(Tuplesortstate *state, SortTuple *stup, void *tup);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic void copytup_cluster(Tuplesortstate *state, SortTuple *stup, void *tup);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic void copytup_index(Tuplesortstate *state, SortTuple *stup, void *tup);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic void copytup_datum(Tuplesortstate *state, SortTuple *stup, void *tup);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic void\nbeginmerge(Tuplesortstate *state)\n{\n\tint\t\t\tactiveTapes;\n\tint\t\t\ttapenum;\n\tint\t\t\tsrcTape;\n\n\t/* Heap should be empty here */\n\tAssert(state->memtupcount == 0);\n\n\t/* Adjust run counts and mark the active tapes */\n\tmemset(state->mergeactive, 0,\n\t\t   state->maxTapes * sizeof(*state->mergeactive));\n\tactiveTapes = 0;\n\tfor (tapenum = 0; tapenum < state->tapeRange; tapenum++)\n\t{\n\t\tif (state->tp_dummy[tapenum] > 0)\n\t\t\tstate->tp_dummy[tapenum]--;\n\t\telse\n\t\t{\n\t\t\tAssert(state->tp_runs[tapenum] > 0);\n\t\t\tstate->tp_runs[tapenum]--;\n\t\t\tsrcTape = state->tp_tapenum[tapenum];\n\t\t\tstate->mergeactive[srcTape] = true;\n\t\t\tactiveTapes++;\n\t\t}\n\t}\n\tAssert(activeTapes > 0);\n\tstate->activeTapes = activeTapes;\n\n\t/* Load the merge heap with the first tuple from each input tape */\n\tfor (srcTape = 0; srcTape < state->maxTapes; srcTape++)\n\t{\n\t\tSortTuple\ttup;\n\n\t\tif (mergereadnext(state, srcTape, &tup))\n\t\t{\n\t\t\ttup.tupindex = srcTape;\n\t\t\ttuplesort_heap_insert(state, &tup);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "mergeonerun",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "2787-2842",
    "snippet": "static void\nmergeonerun(Tuplesortstate *state)\n{\n\tint\t\t\tdestTape = state->tp_tapenum[state->tapeRange];\n\tint\t\t\tsrcTape;\n\n\t/*\n\t * Start the merge by loading one tuple from each active source tape into\n\t * the heap.  We can also decrease the input run/dummy run counts.\n\t */\n\tbeginmerge(state);\n\n\t/*\n\t * Execute merge by repeatedly extracting lowest tuple in heap, writing it\n\t * out, and replacing it with next tuple from same tape (if there is\n\t * another one).\n\t */\n\twhile (state->memtupcount > 0)\n\t{\n\t\tSortTuple\tstup;\n\n\t\t/* write the tuple to destTape */\n\t\tsrcTape = state->memtuples[0].tupindex;\n\t\tWRITETUP(state, destTape, &state->memtuples[0]);\n\n\t\t/* recycle the slot of the tuple we just wrote out, for the next read */\n\t\tif (state->memtuples[0].tuple)\n\t\t\tRELEASE_SLAB_SLOT(state, state->memtuples[0].tuple);\n\n\t\t/*\n\t\t * pull next tuple from the tape, and replace the written-out tuple in\n\t\t * the heap with it.\n\t\t */\n\t\tif (mergereadnext(state, srcTape, &stup))\n\t\t{\n\t\t\tstup.tupindex = srcTape;\n\t\t\ttuplesort_heap_replace_top(state, &stup);\n\n\t\t}\n\t\telse\n\t\t\ttuplesort_heap_delete_top(state);\n\t}\n\n\t/*\n\t * When the heap empties, we're done.  Write an end-of-run marker on the\n\t * output tape, and increment its count of real runs.\n\t */\n\tmarkrunend(state, destTape);\n\tstate->tp_runs[state->tapeRange]++;\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\telog(LOG, \"worker %d finished %d-way merge step: %s\", state->worker,\n\t\t\t state->activeTapes, pg_rusage_show(&state->ru_start));\n#endif\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);",
      "static void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "LOG",
            "\"worker %d finished %d-way merge step: %s\"",
            "state->worker",
            "state->activeTapes",
            "pg_rusage_show(&state->ru_start)"
          ],
          "line": 2839
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_rusage_show",
          "args": [
            "&state->ru_start"
          ],
          "line": 2840
        },
        "resolved": true,
        "details": {
          "function_name": "pg_rusage_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/pg_rusage.c",
          "lines": "39-73",
          "snippet": "const char *\npg_rusage_show(const PGRUsage *ru0)\n{\n\tstatic char result[100];\n\tPGRUsage\tru1;\n\n\tpg_rusage_init(&ru1);\n\n\tif (ru1.tv.tv_usec < ru0->tv.tv_usec)\n\t{\n\t\tru1.tv.tv_sec--;\n\t\tru1.tv.tv_usec += 1000000;\n\t}\n\tif (ru1.ru.ru_stime.tv_usec < ru0->ru.ru_stime.tv_usec)\n\t{\n\t\tru1.ru.ru_stime.tv_sec--;\n\t\tru1.ru.ru_stime.tv_usec += 1000000;\n\t}\n\tif (ru1.ru.ru_utime.tv_usec < ru0->ru.ru_utime.tv_usec)\n\t{\n\t\tru1.ru.ru_utime.tv_sec--;\n\t\tru1.ru.ru_utime.tv_usec += 1000000;\n\t}\n\n\tsnprintf(result, sizeof(result),\n\t\t\t _(\"CPU: user: %d.%02d s, system: %d.%02d s, elapsed: %d.%02d s\"),\n\t\t\t (int) (ru1.ru.ru_utime.tv_sec - ru0->ru.ru_utime.tv_sec),\n\t\t\t (int) (ru1.ru.ru_utime.tv_usec - ru0->ru.ru_utime.tv_usec) / 10000,\n\t\t\t (int) (ru1.ru.ru_stime.tv_sec - ru0->ru.ru_stime.tv_sec),\n\t\t\t (int) (ru1.ru.ru_stime.tv_usec - ru0->ru.ru_stime.tv_usec) / 10000,\n\t\t\t (int) (ru1.tv.tv_sec - ru0->tv.tv_sec),\n\t\t\t (int) (ru1.tv.tv_usec - ru0->tv.tv_usec) / 10000);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/pg_rusage.h\"",
            "#include <unistd.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_rusage.h\"\n#include <unistd.h>\n#include \"postgres.h\"\n\nconst char *\npg_rusage_show(const PGRUsage *ru0)\n{\n\tstatic char result[100];\n\tPGRUsage\tru1;\n\n\tpg_rusage_init(&ru1);\n\n\tif (ru1.tv.tv_usec < ru0->tv.tv_usec)\n\t{\n\t\tru1.tv.tv_sec--;\n\t\tru1.tv.tv_usec += 1000000;\n\t}\n\tif (ru1.ru.ru_stime.tv_usec < ru0->ru.ru_stime.tv_usec)\n\t{\n\t\tru1.ru.ru_stime.tv_sec--;\n\t\tru1.ru.ru_stime.tv_usec += 1000000;\n\t}\n\tif (ru1.ru.ru_utime.tv_usec < ru0->ru.ru_utime.tv_usec)\n\t{\n\t\tru1.ru.ru_utime.tv_sec--;\n\t\tru1.ru.ru_utime.tv_usec += 1000000;\n\t}\n\n\tsnprintf(result, sizeof(result),\n\t\t\t _(\"CPU: user: %d.%02d s, system: %d.%02d s, elapsed: %d.%02d s\"),\n\t\t\t (int) (ru1.ru.ru_utime.tv_sec - ru0->ru.ru_utime.tv_sec),\n\t\t\t (int) (ru1.ru.ru_utime.tv_usec - ru0->ru.ru_utime.tv_usec) / 10000,\n\t\t\t (int) (ru1.ru.ru_stime.tv_sec - ru0->ru.ru_stime.tv_sec),\n\t\t\t (int) (ru1.ru.ru_stime.tv_usec - ru0->ru.ru_stime.tv_usec) / 10000,\n\t\t\t (int) (ru1.tv.tv_sec - ru0->tv.tv_sec),\n\t\t\t (int) (ru1.tv.tv_usec - ru0->tv.tv_usec) / 10000);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "markrunend",
          "args": [
            "state",
            "destTape"
          ],
          "line": 2834
        },
        "resolved": true,
        "details": {
          "function_name": "markrunend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "3466-3472",
          "snippet": "static void\nmarkrunend(Tuplesortstate *state, int tapenum)\n{\n\tunsigned int len = 0;\n\n\tLogicalTapeWrite(state->tapeset, tapenum, (void *) &len, sizeof(len));\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static void markrunend(Tuplesortstate *state, int tapenum);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static void readtup_heap(Tuplesortstate *state, SortTuple *stup,\n\t\t\t int tapenum, unsigned int len);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static void readtup_cluster(Tuplesortstate *state, SortTuple *stup,\n\t\t\t\tint tapenum, unsigned int len);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static void readtup_index(Tuplesortstate *state, SortTuple *stup,\n\t\t\t  int tapenum, unsigned int len);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static void readtup_datum(Tuplesortstate *state, SortTuple *stup,\n\t\t\t  int tapenum, unsigned int len);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic void markrunend(Tuplesortstate *state, int tapenum);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic void readtup_heap(Tuplesortstate *state, SortTuple *stup,\n\t\t\t int tapenum, unsigned int len);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic void readtup_cluster(Tuplesortstate *state, SortTuple *stup,\n\t\t\t\tint tapenum, unsigned int len);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic void readtup_index(Tuplesortstate *state, SortTuple *stup,\n\t\t\t  int tapenum, unsigned int len);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic void readtup_datum(Tuplesortstate *state, SortTuple *stup,\n\t\t\t  int tapenum, unsigned int len);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic void\nmarkrunend(Tuplesortstate *state, int tapenum)\n{\n\tunsigned int len = 0;\n\n\tLogicalTapeWrite(state->tapeset, tapenum, (void *) &len, sizeof(len));\n}"
        }
      },
      {
        "call_info": {
          "callee": "tuplesort_heap_delete_top",
          "args": [
            "state"
          ],
          "line": 2827
        },
        "resolved": true,
        "details": {
          "function_name": "tuplesort_heap_delete_top",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "3371-3386",
          "snippet": "static void\ntuplesort_heap_delete_top(Tuplesortstate *state)\n{\n\tSortTuple  *memtuples = state->memtuples;\n\tSortTuple  *tuple;\n\n\tif (--state->memtupcount <= 0)\n\t\treturn;\n\n\t/*\n\t * Remove the last tuple in the heap, and re-insert it, by replacing the\n\t * current top node with it.\n\t */\n\ttuple = &memtuples[state->memtupcount];\n\ttuplesort_heap_replace_top(state, tuple);\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic void\ntuplesort_heap_delete_top(Tuplesortstate *state)\n{\n\tSortTuple  *memtuples = state->memtuples;\n\tSortTuple  *tuple;\n\n\tif (--state->memtupcount <= 0)\n\t\treturn;\n\n\t/*\n\t * Remove the last tuple in the heap, and re-insert it, by replacing the\n\t * current top node with it.\n\t */\n\ttuple = &memtuples[state->memtupcount];\n\ttuplesort_heap_replace_top(state, tuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tuplesort_heap_replace_top",
          "args": [
            "state",
            "&stup"
          ],
          "line": 2823
        },
        "resolved": true,
        "details": {
          "function_name": "tuplesort_heap_replace_top",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "3395-3428",
          "snippet": "static void\ntuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple)\n{\n\tSortTuple  *memtuples = state->memtuples;\n\tunsigned int i,\n\t\t\t\tn;\n\n\tAssert(state->memtupcount >= 1);\n\n\tCHECK_FOR_INTERRUPTS();\n\n\t/*\n\t * state->memtupcount is \"int\", but we use \"unsigned int\" for i, j, n.\n\t * This prevents overflow in the \"2 * i + 1\" calculation, since at the top\n\t * of the loop we must have i < n <= INT_MAX <= UINT_MAX/2.\n\t */\n\tn = state->memtupcount;\n\ti = 0;\t\t\t\t\t\t/* i is where the \"hole\" is */\n\tfor (;;)\n\t{\n\t\tunsigned int j = 2 * i + 1;\n\n\t\tif (j >= n)\n\t\t\tbreak;\n\t\tif (j + 1 < n &&\n\t\t\tCOMPARETUP(state, &memtuples[j], &memtuples[j + 1]) > 0)\n\t\t\tj++;\n\t\tif (COMPARETUP(state, tuple, &memtuples[j]) <= 0)\n\t\t\tbreak;\n\t\tmemtuples[i] = memtuples[j];\n\t\ti = j;\n\t}\n\tmemtuples[i] = *tuple;\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic void\ntuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple)\n{\n\tSortTuple  *memtuples = state->memtuples;\n\tunsigned int i,\n\t\t\t\tn;\n\n\tAssert(state->memtupcount >= 1);\n\n\tCHECK_FOR_INTERRUPTS();\n\n\t/*\n\t * state->memtupcount is \"int\", but we use \"unsigned int\" for i, j, n.\n\t * This prevents overflow in the \"2 * i + 1\" calculation, since at the top\n\t * of the loop we must have i < n <= INT_MAX <= UINT_MAX/2.\n\t */\n\tn = state->memtupcount;\n\ti = 0;\t\t\t\t\t\t/* i is where the \"hole\" is */\n\tfor (;;)\n\t{\n\t\tunsigned int j = 2 * i + 1;\n\n\t\tif (j >= n)\n\t\t\tbreak;\n\t\tif (j + 1 < n &&\n\t\t\tCOMPARETUP(state, &memtuples[j], &memtuples[j + 1]) > 0)\n\t\t\tj++;\n\t\tif (COMPARETUP(state, tuple, &memtuples[j]) <= 0)\n\t\t\tbreak;\n\t\tmemtuples[i] = memtuples[j];\n\t\ti = j;\n\t}\n\tmemtuples[i] = *tuple;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mergereadnext",
          "args": [
            "state",
            "srcTape",
            "&stup"
          ],
          "line": 2820
        },
        "resolved": true,
        "details": {
          "function_name": "mergereadnext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "2899-2916",
          "snippet": "static bool\nmergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup)\n{\n\tunsigned int tuplen;\n\n\tif (!state->mergeactive[srcTape])\n\t\treturn false;\t\t\t/* tape's run is already exhausted */\n\n\t/* read next tuple, if any */\n\tif ((tuplen = getlen(state, srcTape, true)) == 0)\n\t{\n\t\tstate->mergeactive[srcTape] = false;\n\t\treturn false;\n\t}\n\tREADTUP(state, stup, srcTape, tuplen);\n\n\treturn true;\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static void *readtup_alloc(Tuplesortstate *state, Size tuplen);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);",
            "static void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic void *readtup_alloc(Tuplesortstate *state, Size tuplen);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\nstatic void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);\n\nstatic bool\nmergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup)\n{\n\tunsigned int tuplen;\n\n\tif (!state->mergeactive[srcTape])\n\t\treturn false;\t\t\t/* tape's run is already exhausted */\n\n\t/* read next tuple, if any */\n\tif ((tuplen = getlen(state, srcTape, true)) == 0)\n\t{\n\t\tstate->mergeactive[srcTape] = false;\n\t\treturn false;\n\t}\n\tREADTUP(state, stup, srcTape, tuplen);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RELEASE_SLAB_SLOT",
          "args": [
            "state",
            "state->memtuples[0].tuple"
          ],
          "line": 2814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITETUP",
          "args": [
            "state",
            "destTape",
            "&state->memtuples[0]"
          ],
          "line": 2810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "beginmerge",
          "args": [
            "state"
          ],
          "line": 2797
        },
        "resolved": true,
        "details": {
          "function_name": "beginmerge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "2851-2892",
          "snippet": "static void\nbeginmerge(Tuplesortstate *state)\n{\n\tint\t\t\tactiveTapes;\n\tint\t\t\ttapenum;\n\tint\t\t\tsrcTape;\n\n\t/* Heap should be empty here */\n\tAssert(state->memtupcount == 0);\n\n\t/* Adjust run counts and mark the active tapes */\n\tmemset(state->mergeactive, 0,\n\t\t   state->maxTapes * sizeof(*state->mergeactive));\n\tactiveTapes = 0;\n\tfor (tapenum = 0; tapenum < state->tapeRange; tapenum++)\n\t{\n\t\tif (state->tp_dummy[tapenum] > 0)\n\t\t\tstate->tp_dummy[tapenum]--;\n\t\telse\n\t\t{\n\t\t\tAssert(state->tp_runs[tapenum] > 0);\n\t\t\tstate->tp_runs[tapenum]--;\n\t\t\tsrcTape = state->tp_tapenum[tapenum];\n\t\t\tstate->mergeactive[srcTape] = true;\n\t\t\tactiveTapes++;\n\t\t}\n\t}\n\tAssert(activeTapes > 0);\n\tstate->activeTapes = activeTapes;\n\n\t/* Load the merge heap with the first tuple from each input tape */\n\tfor (srcTape = 0; srcTape < state->maxTapes; srcTape++)\n\t{\n\t\tSortTuple\ttup;\n\n\t\tif (mergereadnext(state, srcTape, &tup))\n\t\t{\n\t\t\ttup.tupindex = srcTape;\n\t\t\ttuplesort_heap_insert(state, &tup);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void inittapestate(Tuplesortstate *state, int maxTapes);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static void markrunend(Tuplesortstate *state, int tapenum);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static void copytup_heap(Tuplesortstate *state, SortTuple *stup, void *tup);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static void copytup_cluster(Tuplesortstate *state, SortTuple *stup, void *tup);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static void copytup_index(Tuplesortstate *state, SortTuple *stup, void *tup);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static void copytup_datum(Tuplesortstate *state, SortTuple *stup, void *tup);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void inittapestate(Tuplesortstate *state, int maxTapes);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic void markrunend(Tuplesortstate *state, int tapenum);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic void copytup_heap(Tuplesortstate *state, SortTuple *stup, void *tup);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic void copytup_cluster(Tuplesortstate *state, SortTuple *stup, void *tup);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic void copytup_index(Tuplesortstate *state, SortTuple *stup, void *tup);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic void copytup_datum(Tuplesortstate *state, SortTuple *stup, void *tup);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic void\nbeginmerge(Tuplesortstate *state)\n{\n\tint\t\t\tactiveTapes;\n\tint\t\t\ttapenum;\n\tint\t\t\tsrcTape;\n\n\t/* Heap should be empty here */\n\tAssert(state->memtupcount == 0);\n\n\t/* Adjust run counts and mark the active tapes */\n\tmemset(state->mergeactive, 0,\n\t\t   state->maxTapes * sizeof(*state->mergeactive));\n\tactiveTapes = 0;\n\tfor (tapenum = 0; tapenum < state->tapeRange; tapenum++)\n\t{\n\t\tif (state->tp_dummy[tapenum] > 0)\n\t\t\tstate->tp_dummy[tapenum]--;\n\t\telse\n\t\t{\n\t\t\tAssert(state->tp_runs[tapenum] > 0);\n\t\t\tstate->tp_runs[tapenum]--;\n\t\t\tsrcTape = state->tp_tapenum[tapenum];\n\t\t\tstate->mergeactive[srcTape] = true;\n\t\t\tactiveTapes++;\n\t\t}\n\t}\n\tAssert(activeTapes > 0);\n\tstate->activeTapes = activeTapes;\n\n\t/* Load the merge heap with the first tuple from each input tape */\n\tfor (srcTape = 0; srcTape < state->maxTapes; srcTape++)\n\t{\n\t\tSortTuple\ttup;\n\n\t\tif (mergereadnext(state, srcTape, &tup))\n\t\t{\n\t\t\ttup.tupindex = srcTape;\n\t\t\ttuplesort_heap_insert(state, &tup);\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\nstatic void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);\n\nstatic void\nmergeonerun(Tuplesortstate *state)\n{\n\tint\t\t\tdestTape = state->tp_tapenum[state->tapeRange];\n\tint\t\t\tsrcTape;\n\n\t/*\n\t * Start the merge by loading one tuple from each active source tape into\n\t * the heap.  We can also decrease the input run/dummy run counts.\n\t */\n\tbeginmerge(state);\n\n\t/*\n\t * Execute merge by repeatedly extracting lowest tuple in heap, writing it\n\t * out, and replacing it with next tuple from same tape (if there is\n\t * another one).\n\t */\n\twhile (state->memtupcount > 0)\n\t{\n\t\tSortTuple\tstup;\n\n\t\t/* write the tuple to destTape */\n\t\tsrcTape = state->memtuples[0].tupindex;\n\t\tWRITETUP(state, destTape, &state->memtuples[0]);\n\n\t\t/* recycle the slot of the tuple we just wrote out, for the next read */\n\t\tif (state->memtuples[0].tuple)\n\t\t\tRELEASE_SLAB_SLOT(state, state->memtuples[0].tuple);\n\n\t\t/*\n\t\t * pull next tuple from the tape, and replace the written-out tuple in\n\t\t * the heap with it.\n\t\t */\n\t\tif (mergereadnext(state, srcTape, &stup))\n\t\t{\n\t\t\tstup.tupindex = srcTape;\n\t\t\ttuplesort_heap_replace_top(state, &stup);\n\n\t\t}\n\t\telse\n\t\t\ttuplesort_heap_delete_top(state);\n\t}\n\n\t/*\n\t * When the heap empties, we're done.  Write an end-of-run marker on the\n\t * output tape, and increment its count of real runs.\n\t */\n\tmarkrunend(state, destTape);\n\tstate->tp_runs[state->tapeRange]++;\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\telog(LOG, \"worker %d finished %d-way merge step: %s\", state->worker,\n\t\t\t state->activeTapes, pg_rusage_show(&state->ru_start));\n#endif\n}"
  },
  {
    "function_name": "mergeruns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "2560-2779",
    "snippet": "static void\nmergeruns(Tuplesortstate *state)\n{\n\tint\t\t\ttapenum,\n\t\t\t\tsvTape,\n\t\t\t\tsvRuns,\n\t\t\t\tsvDummy;\n\tint\t\t\tnumTapes;\n\tint\t\t\tnumInputTapes;\n\n\tAssert(state->status == TSS_BUILDRUNS);\n\tAssert(state->memtupcount == 0);\n\n\tif (state->sortKeys != NULL && state->sortKeys->abbrev_converter != NULL)\n\t{\n\t\t/*\n\t\t * If there are multiple runs to be merged, when we go to read back\n\t\t * tuples from disk, abbreviated keys will not have been stored, and\n\t\t * we don't care to regenerate them.  Disable abbreviation from this\n\t\t * point on.\n\t\t */\n\t\tstate->sortKeys->abbrev_converter = NULL;\n\t\tstate->sortKeys->comparator = state->sortKeys->abbrev_full_comparator;\n\n\t\t/* Not strictly necessary, but be tidy */\n\t\tstate->sortKeys->abbrev_abort = NULL;\n\t\tstate->sortKeys->abbrev_full_comparator = NULL;\n\t}\n\n\t/*\n\t * Reset tuple memory.  We've freed all the tuples that we previously\n\t * allocated.  We will use the slab allocator from now on.\n\t */\n\tMemoryContextDelete(state->tuplecontext);\n\tstate->tuplecontext = NULL;\n\n\t/*\n\t * We no longer need a large memtuples array.  (We will allocate a smaller\n\t * one for the heap later.)\n\t */\n\tFREEMEM(state, GetMemoryChunkSpace(state->memtuples));\n\tpfree(state->memtuples);\n\tstate->memtuples = NULL;\n\n\t/*\n\t * If we had fewer runs than tapes, refund the memory that we imagined we\n\t * would need for the tape buffers of the unused tapes.\n\t *\n\t * numTapes and numInputTapes reflect the actual number of tapes we will\n\t * use.  Note that the output tape's tape number is maxTapes - 1, so the\n\t * tape numbers of the used tapes are not consecutive, and you cannot just\n\t * loop from 0 to numTapes to visit all used tapes!\n\t */\n\tif (state->Level == 1)\n\t{\n\t\tnumInputTapes = state->currentRun;\n\t\tnumTapes = numInputTapes + 1;\n\t\tFREEMEM(state, (state->maxTapes - numTapes) * TAPE_BUFFER_OVERHEAD);\n\t}\n\telse\n\t{\n\t\tnumInputTapes = state->tapeRange;\n\t\tnumTapes = state->maxTapes;\n\t}\n\n\t/*\n\t * Initialize the slab allocator.  We need one slab slot per input tape,\n\t * for the tuples in the heap, plus one to hold the tuple last returned\n\t * from tuplesort_gettuple.  (If we're sorting pass-by-val Datums,\n\t * however, we don't need to do allocate anything.)\n\t *\n\t * From this point on, we no longer use the USEMEM()/LACKMEM() mechanism\n\t * to track memory usage of individual tuples.\n\t */\n\tif (state->tuples)\n\t\tinit_slab_allocator(state, numInputTapes + 1);\n\telse\n\t\tinit_slab_allocator(state, 0);\n\n\t/*\n\t * Allocate a new 'memtuples' array, for the heap.  It will hold one tuple\n\t * from each input tape.\n\t */\n\tstate->memtupsize = numInputTapes;\n\tstate->memtuples = (SortTuple *) palloc(numInputTapes * sizeof(SortTuple));\n\tUSEMEM(state, GetMemoryChunkSpace(state->memtuples));\n\n\t/*\n\t * Use all the remaining memory we have available for read buffers among\n\t * the input tapes.\n\t *\n\t * We don't try to \"rebalance\" the memory among tapes, when we start a new\n\t * merge phase, even if some tapes are inactive in the new phase.  That\n\t * would be hard, because logtape.c doesn't know where one run ends and\n\t * another begins.  When a new merge phase begins, and a tape doesn't\n\t * participate in it, its buffer nevertheless already contains tuples from\n\t * the next run on same tape, so we cannot release the buffer.  That's OK\n\t * in practice, merge performance isn't that sensitive to the amount of\n\t * buffers used, and most merge phases use all or almost all tapes,\n\t * anyway.\n\t */\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\telog(LOG, \"worker %d using \" INT64_FORMAT \" KB of memory for read buffers among %d input tapes\",\n\t\t\t state->worker, state->availMem / 1024, numInputTapes);\n#endif\n\n\tstate->read_buffer_size = Max(state->availMem / numInputTapes, 0);\n\tUSEMEM(state, state->read_buffer_size * numInputTapes);\n\n\t/* End of step D2: rewind all output tapes to prepare for merging */\n\tfor (tapenum = 0; tapenum < state->tapeRange; tapenum++)\n\t\tLogicalTapeRewindForRead(state->tapeset, tapenum, state->read_buffer_size);\n\n\tfor (;;)\n\t{\n\t\t/*\n\t\t * At this point we know that tape[T] is empty.  If there's just one\n\t\t * (real or dummy) run left on each input tape, then only one merge\n\t\t * pass remains.  If we don't have to produce a materialized sorted\n\t\t * tape, we can stop at this point and do the final merge on-the-fly.\n\t\t */\n\t\tif (!state->randomAccess && !WORKER(state))\n\t\t{\n\t\t\tbool\t\tallOneRun = true;\n\n\t\t\tAssert(state->tp_runs[state->tapeRange] == 0);\n\t\t\tfor (tapenum = 0; tapenum < state->tapeRange; tapenum++)\n\t\t\t{\n\t\t\t\tif (state->tp_runs[tapenum] + state->tp_dummy[tapenum] != 1)\n\t\t\t\t{\n\t\t\t\t\tallOneRun = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (allOneRun)\n\t\t\t{\n\t\t\t\t/* Tell logtape.c we won't be writing anymore */\n\t\t\t\tLogicalTapeSetForgetFreeSpace(state->tapeset);\n\t\t\t\t/* Initialize for the final merge pass */\n\t\t\t\tbeginmerge(state);\n\t\t\t\tstate->status = TSS_FINALMERGE;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t/* Step D5: merge runs onto tape[T] until tape[P] is empty */\n\t\twhile (state->tp_runs[state->tapeRange - 1] ||\n\t\t\t   state->tp_dummy[state->tapeRange - 1])\n\t\t{\n\t\t\tbool\t\tallDummy = true;\n\n\t\t\tfor (tapenum = 0; tapenum < state->tapeRange; tapenum++)\n\t\t\t{\n\t\t\t\tif (state->tp_dummy[tapenum] == 0)\n\t\t\t\t{\n\t\t\t\t\tallDummy = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (allDummy)\n\t\t\t{\n\t\t\t\tstate->tp_dummy[state->tapeRange]++;\n\t\t\t\tfor (tapenum = 0; tapenum < state->tapeRange; tapenum++)\n\t\t\t\t\tstate->tp_dummy[tapenum]--;\n\t\t\t}\n\t\t\telse\n\t\t\t\tmergeonerun(state);\n\t\t}\n\n\t\t/* Step D6: decrease level */\n\t\tif (--state->Level == 0)\n\t\t\tbreak;\n\t\t/* rewind output tape T to use as new input */\n\t\tLogicalTapeRewindForRead(state->tapeset, state->tp_tapenum[state->tapeRange],\n\t\t\t\t\t\t\t\t state->read_buffer_size);\n\t\t/* rewind used-up input tape P, and prepare it for write pass */\n\t\tLogicalTapeRewindForWrite(state->tapeset, state->tp_tapenum[state->tapeRange - 1]);\n\t\tstate->tp_runs[state->tapeRange - 1] = 0;\n\n\t\t/*\n\t\t * reassign tape units per step D6; note we no longer care about A[]\n\t\t */\n\t\tsvTape = state->tp_tapenum[state->tapeRange];\n\t\tsvDummy = state->tp_dummy[state->tapeRange];\n\t\tsvRuns = state->tp_runs[state->tapeRange];\n\t\tfor (tapenum = state->tapeRange; tapenum > 0; tapenum--)\n\t\t{\n\t\t\tstate->tp_tapenum[tapenum] = state->tp_tapenum[tapenum - 1];\n\t\t\tstate->tp_dummy[tapenum] = state->tp_dummy[tapenum - 1];\n\t\t\tstate->tp_runs[tapenum] = state->tp_runs[tapenum - 1];\n\t\t}\n\t\tstate->tp_tapenum[0] = svTape;\n\t\tstate->tp_dummy[0] = svDummy;\n\t\tstate->tp_runs[0] = svRuns;\n\t}\n\n\t/*\n\t * Done.  Knuth says that the result is on TAPE[1], but since we exited\n\t * the loop without performing the last iteration of step D6, we have not\n\t * rearranged the tape unit assignment, and therefore the result is on\n\t * TAPE[T].  We need to do it this way so that we can freeze the final\n\t * output tape while rewinding it.  The last iteration of step D6 would be\n\t * a waste of cycles anyway...\n\t */\n\tstate->result_tape = state->tp_tapenum[state->tapeRange];\n\tif (!WORKER(state))\n\t\tLogicalTapeFreeze(state->tapeset, state->result_tape, NULL);\n\telse\n\t\tworker_freeze_result_tape(state);\n\tstate->status = TSS_SORTEDONTAPE;\n\n\t/* Release the read buffers of all the other tapes, by rewinding them. */\n\tfor (tapenum = 0; tapenum < state->maxTapes; tapenum++)\n\t{\n\t\tif (tapenum != state->result_tape)\n\t\t\tLogicalTapeRewindForWrite(state->tapeset, tapenum);\n\t}\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define TAPE_BUFFER_OVERHEAD\t\tBLCKSZ"
    ],
    "globals_used": [
      "static Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);",
      "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void inittapes(Tuplesortstate *state, bool mergeruns);",
      "static void inittapestate(Tuplesortstate *state, int maxTapes);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static void markrunend(Tuplesortstate *state, int tapenum);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LogicalTapeRewindForWrite",
          "args": [
            "state->tapeset",
            "tapenum"
          ],
          "line": 2777
        },
        "resolved": true,
        "details": {
          "function_name": "LogicalTapeRewindForWrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/logtape.c",
          "lines": "795-814",
          "snippet": "void\nLogicalTapeRewindForWrite(LogicalTapeSet *lts, int tapenum)\n{\n\tLogicalTape *lt;\n\n\tAssert(tapenum >= 0 && tapenum < lts->nTapes);\n\tlt = &lts->tapes[tapenum];\n\n\tAssert(!lt->writing && !lt->frozen);\n\tlt->writing = true;\n\tlt->dirty = false;\n\tlt->firstBlockNumber = -1L;\n\tlt->curBlockNumber = -1L;\n\tlt->pos = 0;\n\tlt->nbytes = 0;\n\tif (lt->buffer)\n\t\tpfree(lt->buffer);\n\tlt->buffer = NULL;\n\tlt->buffer_size = 0;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
            "static void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
            "static long ltsGetFreeBlock(LogicalTapeSet *lts);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/logtape.h\"\n#include \"utils/builtins.h\"\n#include \"storage/buffile.h\"\n#include \"postgres.h\"\n\nstatic void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic long ltsGetFreeBlock(LogicalTapeSet *lts);\n\nvoid\nLogicalTapeRewindForWrite(LogicalTapeSet *lts, int tapenum)\n{\n\tLogicalTape *lt;\n\n\tAssert(tapenum >= 0 && tapenum < lts->nTapes);\n\tlt = &lts->tapes[tapenum];\n\n\tAssert(!lt->writing && !lt->frozen);\n\tlt->writing = true;\n\tlt->dirty = false;\n\tlt->firstBlockNumber = -1L;\n\tlt->curBlockNumber = -1L;\n\tlt->pos = 0;\n\tlt->nbytes = 0;\n\tif (lt->buffer)\n\t\tpfree(lt->buffer);\n\tlt->buffer = NULL;\n\tlt->buffer_size = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "worker_freeze_result_tape",
          "args": [
            "state"
          ],
          "line": 2770
        },
        "resolved": true,
        "details": {
          "function_name": "worker_freeze_result_tape",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "4454-4484",
          "snippet": "static void\nworker_freeze_result_tape(Tuplesortstate *state)\n{\n\tSharedsort *shared = state->shared;\n\tTapeShare\toutput;\n\n\tAssert(WORKER(state));\n\tAssert(state->result_tape != -1);\n\tAssert(state->memtupcount == 0);\n\n\t/*\n\t * Free most remaining memory, in case caller is sensitive to our holding\n\t * on to it.  memtuples may not be a tiny merge heap at this point.\n\t */\n\tpfree(state->memtuples);\n\t/* Be tidy */\n\tstate->memtuples = NULL;\n\tstate->memtupsize = 0;\n\n\t/*\n\t * Parallel worker requires result tape metadata, which is to be stored in\n\t * shared memory for leader\n\t */\n\tLogicalTapeFreeze(state->tapeset, state->result_tape, &output);\n\n\t/* Store properties of output tape, and update finished worker count */\n\tSpinLockAcquire(&shared->mutex);\n\tshared->tapes[state->worker] = output;\n\tshared->workersFinished++;\n\tSpinLockRelease(&shared->mutex);\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic void\nworker_freeze_result_tape(Tuplesortstate *state)\n{\n\tSharedsort *shared = state->shared;\n\tTapeShare\toutput;\n\n\tAssert(WORKER(state));\n\tAssert(state->result_tape != -1);\n\tAssert(state->memtupcount == 0);\n\n\t/*\n\t * Free most remaining memory, in case caller is sensitive to our holding\n\t * on to it.  memtuples may not be a tiny merge heap at this point.\n\t */\n\tpfree(state->memtuples);\n\t/* Be tidy */\n\tstate->memtuples = NULL;\n\tstate->memtupsize = 0;\n\n\t/*\n\t * Parallel worker requires result tape metadata, which is to be stored in\n\t * shared memory for leader\n\t */\n\tLogicalTapeFreeze(state->tapeset, state->result_tape, &output);\n\n\t/* Store properties of output tape, and update finished worker count */\n\tSpinLockAcquire(&shared->mutex);\n\tshared->tapes[state->worker] = output;\n\tshared->workersFinished++;\n\tSpinLockRelease(&shared->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "LogicalTapeFreeze",
          "args": [
            "state->tapeset",
            "state->result_tape",
            "NULL"
          ],
          "line": 2768
        },
        "resolved": true,
        "details": {
          "function_name": "LogicalTapeFreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/logtape.c",
          "lines": "875-944",
          "snippet": "void\nLogicalTapeFreeze(LogicalTapeSet *lts, int tapenum, TapeShare *share)\n{\n\tLogicalTape *lt;\n\n\tAssert(tapenum >= 0 && tapenum < lts->nTapes);\n\tlt = &lts->tapes[tapenum];\n\tAssert(lt->writing);\n\tAssert(lt->offsetBlockNumber == 0L);\n\n\t/*\n\t * Completion of a write phase.  Flush last partial data block, and rewind\n\t * for nondestructive read.\n\t */\n\tif (lt->dirty)\n\t{\n\t\t/*\n\t\t * As long as we've filled the buffer at least once, its contents are\n\t\t * entirely defined from valgrind's point of view, even though\n\t\t * contents beyond the current end point may be stale.  But it's\n\t\t * possible - at least in the case of a parallel sort - to sort such\n\t\t * small amount of data that we do not fill the buffer even once. Tell\n\t\t * valgrind that its contents are defined, so it doesn't bleat.\n\t\t */\n\t\tVALGRIND_MAKE_MEM_DEFINED(lt->buffer + lt->nbytes,\n\t\t\t\t\t\t\t\t  lt->buffer_size - lt->nbytes);\n\n\t\tTapeBlockSetNBytes(lt->buffer, lt->nbytes);\n\t\tltsWriteBlock(lts, lt->curBlockNumber, (void *) lt->buffer);\n\t\tlt->writing = false;\n\t}\n\tlt->writing = false;\n\tlt->frozen = true;\n\n\t/*\n\t * The seek and backspace functions assume a single block read buffer.\n\t * That's OK with current usage.  A larger buffer is helpful to make the\n\t * read pattern of the backing file look more sequential to the OS, when\n\t * we're reading from multiple tapes.  But at the end of a sort, when a\n\t * tape is frozen, we only read from a single tape anyway.\n\t */\n\tif (!lt->buffer || lt->buffer_size != BLCKSZ)\n\t{\n\t\tif (lt->buffer)\n\t\t\tpfree(lt->buffer);\n\t\tlt->buffer = palloc(BLCKSZ);\n\t\tlt->buffer_size = BLCKSZ;\n\t}\n\n\t/* Read the first block, or reset if tape is empty */\n\tlt->curBlockNumber = lt->firstBlockNumber;\n\tlt->pos = 0;\n\tlt->nbytes = 0;\n\n\tif (lt->firstBlockNumber == -1L)\n\t\tlt->nextBlockNumber = -1L;\n\tltsReadBlock(lts, lt->curBlockNumber, (void *) lt->buffer);\n\tif (TapeBlockIsLast(lt->buffer))\n\t\tlt->nextBlockNumber = -1L;\n\telse\n\t\tlt->nextBlockNumber = TapeBlockGetTrailer(lt->buffer)->next;\n\tlt->nbytes = TapeBlockGetNBytes(lt->buffer);\n\n\t/* Handle extra steps when caller is to share its tapeset */\n\tif (share)\n\t{\n\t\tBufFileExportShared(lts->pfile);\n\t\tshare->firstblocknumber = lt->firstBlockNumber;\n\t}\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
            "static void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
            "static long ltsGetFreeBlock(LogicalTapeSet *lts);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/logtape.h\"\n#include \"utils/builtins.h\"\n#include \"storage/buffile.h\"\n#include \"postgres.h\"\n\nstatic void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic long ltsGetFreeBlock(LogicalTapeSet *lts);\n\nvoid\nLogicalTapeFreeze(LogicalTapeSet *lts, int tapenum, TapeShare *share)\n{\n\tLogicalTape *lt;\n\n\tAssert(tapenum >= 0 && tapenum < lts->nTapes);\n\tlt = &lts->tapes[tapenum];\n\tAssert(lt->writing);\n\tAssert(lt->offsetBlockNumber == 0L);\n\n\t/*\n\t * Completion of a write phase.  Flush last partial data block, and rewind\n\t * for nondestructive read.\n\t */\n\tif (lt->dirty)\n\t{\n\t\t/*\n\t\t * As long as we've filled the buffer at least once, its contents are\n\t\t * entirely defined from valgrind's point of view, even though\n\t\t * contents beyond the current end point may be stale.  But it's\n\t\t * possible - at least in the case of a parallel sort - to sort such\n\t\t * small amount of data that we do not fill the buffer even once. Tell\n\t\t * valgrind that its contents are defined, so it doesn't bleat.\n\t\t */\n\t\tVALGRIND_MAKE_MEM_DEFINED(lt->buffer + lt->nbytes,\n\t\t\t\t\t\t\t\t  lt->buffer_size - lt->nbytes);\n\n\t\tTapeBlockSetNBytes(lt->buffer, lt->nbytes);\n\t\tltsWriteBlock(lts, lt->curBlockNumber, (void *) lt->buffer);\n\t\tlt->writing = false;\n\t}\n\tlt->writing = false;\n\tlt->frozen = true;\n\n\t/*\n\t * The seek and backspace functions assume a single block read buffer.\n\t * That's OK with current usage.  A larger buffer is helpful to make the\n\t * read pattern of the backing file look more sequential to the OS, when\n\t * we're reading from multiple tapes.  But at the end of a sort, when a\n\t * tape is frozen, we only read from a single tape anyway.\n\t */\n\tif (!lt->buffer || lt->buffer_size != BLCKSZ)\n\t{\n\t\tif (lt->buffer)\n\t\t\tpfree(lt->buffer);\n\t\tlt->buffer = palloc(BLCKSZ);\n\t\tlt->buffer_size = BLCKSZ;\n\t}\n\n\t/* Read the first block, or reset if tape is empty */\n\tlt->curBlockNumber = lt->firstBlockNumber;\n\tlt->pos = 0;\n\tlt->nbytes = 0;\n\n\tif (lt->firstBlockNumber == -1L)\n\t\tlt->nextBlockNumber = -1L;\n\tltsReadBlock(lts, lt->curBlockNumber, (void *) lt->buffer);\n\tif (TapeBlockIsLast(lt->buffer))\n\t\tlt->nextBlockNumber = -1L;\n\telse\n\t\tlt->nextBlockNumber = TapeBlockGetTrailer(lt->buffer)->next;\n\tlt->nbytes = TapeBlockGetNBytes(lt->buffer);\n\n\t/* Handle extra steps when caller is to share its tapeset */\n\tif (share)\n\t{\n\t\tBufFileExportShared(lts->pfile);\n\t\tshare->firstblocknumber = lt->firstBlockNumber;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WORKER",
          "args": [
            "state"
          ],
          "line": 2767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LogicalTapeRewindForRead",
          "args": [
            "state->tapeset",
            "state->tp_tapenum[state->tapeRange]",
            "state->read_buffer_size"
          ],
          "line": 2735
        },
        "resolved": true,
        "details": {
          "function_name": "LogicalTapeRewindForRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/logtape.c",
          "lines": "708-785",
          "snippet": "void\nLogicalTapeRewindForRead(LogicalTapeSet *lts, int tapenum, size_t buffer_size)\n{\n\tLogicalTape *lt;\n\n\tAssert(tapenum >= 0 && tapenum < lts->nTapes);\n\tlt = &lts->tapes[tapenum];\n\n\t/*\n\t * Round and cap buffer_size if needed.\n\t */\n\tif (lt->frozen)\n\t\tbuffer_size = BLCKSZ;\n\telse\n\t{\n\t\t/* need at least one block */\n\t\tif (buffer_size < BLCKSZ)\n\t\t\tbuffer_size = BLCKSZ;\n\n\t\t/* palloc() larger than max_size is unlikely to be helpful */\n\t\tif (buffer_size > lt->max_size)\n\t\t\tbuffer_size = lt->max_size;\n\n\t\t/* round down to BLCKSZ boundary */\n\t\tbuffer_size -= buffer_size % BLCKSZ;\n\t}\n\n\tif (lt->writing)\n\t{\n\t\t/*\n\t\t * Completion of a write phase.  Flush last partial data block, and\n\t\t * rewind for normal (destructive) read.\n\t\t */\n\t\tif (lt->dirty)\n\t\t{\n\t\t\t/*\n\t\t\t * As long as we've filled the buffer at least once, its contents\n\t\t\t * are entirely defined from valgrind's point of view, even though\n\t\t\t * contents beyond the current end point may be stale.  But it's\n\t\t\t * possible - at least in the case of a parallel sort - to sort\n\t\t\t * such small amount of data that we do not fill the buffer even\n\t\t\t * once.  Tell valgrind that its contents are defined, so it\n\t\t\t * doesn't bleat.\n\t\t\t */\n\t\t\tVALGRIND_MAKE_MEM_DEFINED(lt->buffer + lt->nbytes,\n\t\t\t\t\t\t\t\t\t  lt->buffer_size - lt->nbytes);\n\n\t\t\tTapeBlockSetNBytes(lt->buffer, lt->nbytes);\n\t\t\tltsWriteBlock(lts, lt->curBlockNumber, (void *) lt->buffer);\n\t\t}\n\t\tlt->writing = false;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * This is only OK if tape is frozen; we rewind for (another) read\n\t\t * pass.\n\t\t */\n\t\tAssert(lt->frozen);\n\t}\n\n\t/* Allocate a read buffer (unless the tape is empty) */\n\tif (lt->buffer)\n\t\tpfree(lt->buffer);\n\tlt->buffer = NULL;\n\tlt->buffer_size = 0;\n\tif (lt->firstBlockNumber != -1L)\n\t{\n\t\tlt->buffer = palloc(buffer_size);\n\t\tlt->buffer_size = buffer_size;\n\t}\n\n\t/* Read the first block, or reset if tape is empty */\n\tlt->nextBlockNumber = lt->firstBlockNumber;\n\tlt->pos = 0;\n\tlt->nbytes = 0;\n\tltsReadFillBuffer(lts, lt);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
            "static void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
            "static long ltsGetFreeBlock(LogicalTapeSet *lts);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/logtape.h\"\n#include \"utils/builtins.h\"\n#include \"storage/buffile.h\"\n#include \"postgres.h\"\n\nstatic void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic long ltsGetFreeBlock(LogicalTapeSet *lts);\n\nvoid\nLogicalTapeRewindForRead(LogicalTapeSet *lts, int tapenum, size_t buffer_size)\n{\n\tLogicalTape *lt;\n\n\tAssert(tapenum >= 0 && tapenum < lts->nTapes);\n\tlt = &lts->tapes[tapenum];\n\n\t/*\n\t * Round and cap buffer_size if needed.\n\t */\n\tif (lt->frozen)\n\t\tbuffer_size = BLCKSZ;\n\telse\n\t{\n\t\t/* need at least one block */\n\t\tif (buffer_size < BLCKSZ)\n\t\t\tbuffer_size = BLCKSZ;\n\n\t\t/* palloc() larger than max_size is unlikely to be helpful */\n\t\tif (buffer_size > lt->max_size)\n\t\t\tbuffer_size = lt->max_size;\n\n\t\t/* round down to BLCKSZ boundary */\n\t\tbuffer_size -= buffer_size % BLCKSZ;\n\t}\n\n\tif (lt->writing)\n\t{\n\t\t/*\n\t\t * Completion of a write phase.  Flush last partial data block, and\n\t\t * rewind for normal (destructive) read.\n\t\t */\n\t\tif (lt->dirty)\n\t\t{\n\t\t\t/*\n\t\t\t * As long as we've filled the buffer at least once, its contents\n\t\t\t * are entirely defined from valgrind's point of view, even though\n\t\t\t * contents beyond the current end point may be stale.  But it's\n\t\t\t * possible - at least in the case of a parallel sort - to sort\n\t\t\t * such small amount of data that we do not fill the buffer even\n\t\t\t * once.  Tell valgrind that its contents are defined, so it\n\t\t\t * doesn't bleat.\n\t\t\t */\n\t\t\tVALGRIND_MAKE_MEM_DEFINED(lt->buffer + lt->nbytes,\n\t\t\t\t\t\t\t\t\t  lt->buffer_size - lt->nbytes);\n\n\t\t\tTapeBlockSetNBytes(lt->buffer, lt->nbytes);\n\t\t\tltsWriteBlock(lts, lt->curBlockNumber, (void *) lt->buffer);\n\t\t}\n\t\tlt->writing = false;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * This is only OK if tape is frozen; we rewind for (another) read\n\t\t * pass.\n\t\t */\n\t\tAssert(lt->frozen);\n\t}\n\n\t/* Allocate a read buffer (unless the tape is empty) */\n\tif (lt->buffer)\n\t\tpfree(lt->buffer);\n\tlt->buffer = NULL;\n\tlt->buffer_size = 0;\n\tif (lt->firstBlockNumber != -1L)\n\t{\n\t\tlt->buffer = palloc(buffer_size);\n\t\tlt->buffer_size = buffer_size;\n\t}\n\n\t/* Read the first block, or reset if tape is empty */\n\tlt->nextBlockNumber = lt->firstBlockNumber;\n\tlt->pos = 0;\n\tlt->nbytes = 0;\n\tltsReadFillBuffer(lts, lt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mergeonerun",
          "args": [
            "state"
          ],
          "line": 2728
        },
        "resolved": true,
        "details": {
          "function_name": "mergeonerun",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "2787-2842",
          "snippet": "static void\nmergeonerun(Tuplesortstate *state)\n{\n\tint\t\t\tdestTape = state->tp_tapenum[state->tapeRange];\n\tint\t\t\tsrcTape;\n\n\t/*\n\t * Start the merge by loading one tuple from each active source tape into\n\t * the heap.  We can also decrease the input run/dummy run counts.\n\t */\n\tbeginmerge(state);\n\n\t/*\n\t * Execute merge by repeatedly extracting lowest tuple in heap, writing it\n\t * out, and replacing it with next tuple from same tape (if there is\n\t * another one).\n\t */\n\twhile (state->memtupcount > 0)\n\t{\n\t\tSortTuple\tstup;\n\n\t\t/* write the tuple to destTape */\n\t\tsrcTape = state->memtuples[0].tupindex;\n\t\tWRITETUP(state, destTape, &state->memtuples[0]);\n\n\t\t/* recycle the slot of the tuple we just wrote out, for the next read */\n\t\tif (state->memtuples[0].tuple)\n\t\t\tRELEASE_SLAB_SLOT(state, state->memtuples[0].tuple);\n\n\t\t/*\n\t\t * pull next tuple from the tape, and replace the written-out tuple in\n\t\t * the heap with it.\n\t\t */\n\t\tif (mergereadnext(state, srcTape, &stup))\n\t\t{\n\t\t\tstup.tupindex = srcTape;\n\t\t\ttuplesort_heap_replace_top(state, &stup);\n\n\t\t}\n\t\telse\n\t\t\ttuplesort_heap_delete_top(state);\n\t}\n\n\t/*\n\t * When the heap empties, we're done.  Write an end-of-run marker on the\n\t * output tape, and increment its count of real runs.\n\t */\n\tmarkrunend(state, destTape);\n\tstate->tp_runs[state->tapeRange]++;\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\telog(LOG, \"worker %d finished %d-way merge step: %s\", state->worker,\n\t\t\t state->activeTapes, pg_rusage_show(&state->ru_start));\n#endif\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);",
            "static void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\nstatic void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);\n\nstatic void\nmergeonerun(Tuplesortstate *state)\n{\n\tint\t\t\tdestTape = state->tp_tapenum[state->tapeRange];\n\tint\t\t\tsrcTape;\n\n\t/*\n\t * Start the merge by loading one tuple from each active source tape into\n\t * the heap.  We can also decrease the input run/dummy run counts.\n\t */\n\tbeginmerge(state);\n\n\t/*\n\t * Execute merge by repeatedly extracting lowest tuple in heap, writing it\n\t * out, and replacing it with next tuple from same tape (if there is\n\t * another one).\n\t */\n\twhile (state->memtupcount > 0)\n\t{\n\t\tSortTuple\tstup;\n\n\t\t/* write the tuple to destTape */\n\t\tsrcTape = state->memtuples[0].tupindex;\n\t\tWRITETUP(state, destTape, &state->memtuples[0]);\n\n\t\t/* recycle the slot of the tuple we just wrote out, for the next read */\n\t\tif (state->memtuples[0].tuple)\n\t\t\tRELEASE_SLAB_SLOT(state, state->memtuples[0].tuple);\n\n\t\t/*\n\t\t * pull next tuple from the tape, and replace the written-out tuple in\n\t\t * the heap with it.\n\t\t */\n\t\tif (mergereadnext(state, srcTape, &stup))\n\t\t{\n\t\t\tstup.tupindex = srcTape;\n\t\t\ttuplesort_heap_replace_top(state, &stup);\n\n\t\t}\n\t\telse\n\t\t\ttuplesort_heap_delete_top(state);\n\t}\n\n\t/*\n\t * When the heap empties, we're done.  Write an end-of-run marker on the\n\t * output tape, and increment its count of real runs.\n\t */\n\tmarkrunend(state, destTape);\n\tstate->tp_runs[state->tapeRange]++;\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\telog(LOG, \"worker %d finished %d-way merge step: %s\", state->worker,\n\t\t\t state->activeTapes, pg_rusage_show(&state->ru_start));\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "beginmerge",
          "args": [
            "state"
          ],
          "line": 2700
        },
        "resolved": true,
        "details": {
          "function_name": "beginmerge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "2851-2892",
          "snippet": "static void\nbeginmerge(Tuplesortstate *state)\n{\n\tint\t\t\tactiveTapes;\n\tint\t\t\ttapenum;\n\tint\t\t\tsrcTape;\n\n\t/* Heap should be empty here */\n\tAssert(state->memtupcount == 0);\n\n\t/* Adjust run counts and mark the active tapes */\n\tmemset(state->mergeactive, 0,\n\t\t   state->maxTapes * sizeof(*state->mergeactive));\n\tactiveTapes = 0;\n\tfor (tapenum = 0; tapenum < state->tapeRange; tapenum++)\n\t{\n\t\tif (state->tp_dummy[tapenum] > 0)\n\t\t\tstate->tp_dummy[tapenum]--;\n\t\telse\n\t\t{\n\t\t\tAssert(state->tp_runs[tapenum] > 0);\n\t\t\tstate->tp_runs[tapenum]--;\n\t\t\tsrcTape = state->tp_tapenum[tapenum];\n\t\t\tstate->mergeactive[srcTape] = true;\n\t\t\tactiveTapes++;\n\t\t}\n\t}\n\tAssert(activeTapes > 0);\n\tstate->activeTapes = activeTapes;\n\n\t/* Load the merge heap with the first tuple from each input tape */\n\tfor (srcTape = 0; srcTape < state->maxTapes; srcTape++)\n\t{\n\t\tSortTuple\ttup;\n\n\t\tif (mergereadnext(state, srcTape, &tup))\n\t\t{\n\t\t\ttup.tupindex = srcTape;\n\t\t\ttuplesort_heap_insert(state, &tup);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void inittapestate(Tuplesortstate *state, int maxTapes);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static void markrunend(Tuplesortstate *state, int tapenum);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static void copytup_heap(Tuplesortstate *state, SortTuple *stup, void *tup);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static void copytup_cluster(Tuplesortstate *state, SortTuple *stup, void *tup);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static void copytup_index(Tuplesortstate *state, SortTuple *stup, void *tup);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static void copytup_datum(Tuplesortstate *state, SortTuple *stup, void *tup);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void inittapestate(Tuplesortstate *state, int maxTapes);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic void markrunend(Tuplesortstate *state, int tapenum);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic void copytup_heap(Tuplesortstate *state, SortTuple *stup, void *tup);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic void copytup_cluster(Tuplesortstate *state, SortTuple *stup, void *tup);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic void copytup_index(Tuplesortstate *state, SortTuple *stup, void *tup);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic void copytup_datum(Tuplesortstate *state, SortTuple *stup, void *tup);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic void\nbeginmerge(Tuplesortstate *state)\n{\n\tint\t\t\tactiveTapes;\n\tint\t\t\ttapenum;\n\tint\t\t\tsrcTape;\n\n\t/* Heap should be empty here */\n\tAssert(state->memtupcount == 0);\n\n\t/* Adjust run counts and mark the active tapes */\n\tmemset(state->mergeactive, 0,\n\t\t   state->maxTapes * sizeof(*state->mergeactive));\n\tactiveTapes = 0;\n\tfor (tapenum = 0; tapenum < state->tapeRange; tapenum++)\n\t{\n\t\tif (state->tp_dummy[tapenum] > 0)\n\t\t\tstate->tp_dummy[tapenum]--;\n\t\telse\n\t\t{\n\t\t\tAssert(state->tp_runs[tapenum] > 0);\n\t\t\tstate->tp_runs[tapenum]--;\n\t\t\tsrcTape = state->tp_tapenum[tapenum];\n\t\t\tstate->mergeactive[srcTape] = true;\n\t\t\tactiveTapes++;\n\t\t}\n\t}\n\tAssert(activeTapes > 0);\n\tstate->activeTapes = activeTapes;\n\n\t/* Load the merge heap with the first tuple from each input tape */\n\tfor (srcTape = 0; srcTape < state->maxTapes; srcTape++)\n\t{\n\t\tSortTuple\ttup;\n\n\t\tif (mergereadnext(state, srcTape, &tup))\n\t\t{\n\t\t\ttup.tupindex = srcTape;\n\t\t\ttuplesort_heap_insert(state, &tup);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "LogicalTapeSetForgetFreeSpace",
          "args": [
            "state->tapeset"
          ],
          "line": 2698
        },
        "resolved": true,
        "details": {
          "function_name": "LogicalTapeSetForgetFreeSpace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/logtape.c",
          "lines": "609-613",
          "snippet": "void\nLogicalTapeSetForgetFreeSpace(LogicalTapeSet *lts)\n{\n\tlts->forgetFreeSpace = true;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long ltsGetFreeBlock(LogicalTapeSet *lts);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/logtape.h\"\n#include \"utils/builtins.h\"\n#include \"storage/buffile.h\"\n#include \"postgres.h\"\n\nstatic long ltsGetFreeBlock(LogicalTapeSet *lts);\n\nvoid\nLogicalTapeSetForgetFreeSpace(LogicalTapeSet *lts)\n{\n\tlts->forgetFreeSpace = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "state->tp_runs[state->tapeRange] == 0"
          ],
          "line": 2686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WORKER",
          "args": [
            "state"
          ],
          "line": 2682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USEMEM",
          "args": [
            "state",
            "state->read_buffer_size * numInputTapes"
          ],
          "line": 2668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Max",
          "args": [
            "state->availMem / numInputTapes",
            "0"
          ],
          "line": 2667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "LOG",
            "\"worker %d using \" INT64_FORMAT \" KB of memory for read buffers among %d input tapes\"",
            "state->worker",
            "state->availMem / 1024",
            "numInputTapes"
          ],
          "line": 2663
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "USEMEM",
          "args": [
            "state",
            "GetMemoryChunkSpace(state->memtuples)"
          ],
          "line": 2645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetMemoryChunkSpace",
          "args": [
            "state->memtuples"
          ],
          "line": 2645
        },
        "resolved": true,
        "details": {
          "function_name": "GetMemoryChunkSpace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "426-432",
          "snippet": "Size\nGetMemoryChunkSpace(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\treturn context->methods->get_chunk_space(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nSize\nGetMemoryChunkSpace(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\treturn context->methods->get_chunk_space(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "numInputTapes * sizeof(SortTuple)"
          ],
          "line": 2644
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_slab_allocator",
          "args": [
            "state",
            "0"
          ],
          "line": 2637
        },
        "resolved": true,
        "details": {
          "function_name": "init_slab_allocator",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "2524-2552",
          "snippet": "static void\ninit_slab_allocator(Tuplesortstate *state, int numSlots)\n{\n\tif (numSlots > 0)\n\t{\n\t\tchar\t   *p;\n\t\tint\t\t\ti;\n\n\t\tstate->slabMemoryBegin = palloc(numSlots * SLAB_SLOT_SIZE);\n\t\tstate->slabMemoryEnd = state->slabMemoryBegin +\n\t\t\tnumSlots * SLAB_SLOT_SIZE;\n\t\tstate->slabFreeHead = (SlabSlot *) state->slabMemoryBegin;\n\t\tUSEMEM(state, numSlots * SLAB_SLOT_SIZE);\n\n\t\tp = state->slabMemoryBegin;\n\t\tfor (i = 0; i < numSlots - 1; i++)\n\t\t{\n\t\t\t((SlabSlot *) p)->nextfree = (SlabSlot *) (p + SLAB_SLOT_SIZE);\n\t\t\tp += SLAB_SLOT_SIZE;\n\t\t}\n\t\t((SlabSlot *) p)->nextfree = NULL;\n\t}\n\telse\n\t{\n\t\tstate->slabMemoryBegin = state->slabMemoryEnd = NULL;\n\t\tstate->slabFreeHead = NULL;\n\t}\n\tstate->slabAllocatorUsed = true;\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define SLAB_SLOT_SIZE 1024"
          ],
          "globals_used": [
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void init_slab_allocator(Tuplesortstate *state, int numSlots);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define SLAB_SLOT_SIZE 1024\n\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void init_slab_allocator(Tuplesortstate *state, int numSlots);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic void\ninit_slab_allocator(Tuplesortstate *state, int numSlots)\n{\n\tif (numSlots > 0)\n\t{\n\t\tchar\t   *p;\n\t\tint\t\t\ti;\n\n\t\tstate->slabMemoryBegin = palloc(numSlots * SLAB_SLOT_SIZE);\n\t\tstate->slabMemoryEnd = state->slabMemoryBegin +\n\t\t\tnumSlots * SLAB_SLOT_SIZE;\n\t\tstate->slabFreeHead = (SlabSlot *) state->slabMemoryBegin;\n\t\tUSEMEM(state, numSlots * SLAB_SLOT_SIZE);\n\n\t\tp = state->slabMemoryBegin;\n\t\tfor (i = 0; i < numSlots - 1; i++)\n\t\t{\n\t\t\t((SlabSlot *) p)->nextfree = (SlabSlot *) (p + SLAB_SLOT_SIZE);\n\t\t\tp += SLAB_SLOT_SIZE;\n\t\t}\n\t\t((SlabSlot *) p)->nextfree = NULL;\n\t}\n\telse\n\t{\n\t\tstate->slabMemoryBegin = state->slabMemoryEnd = NULL;\n\t\tstate->slabFreeHead = NULL;\n\t}\n\tstate->slabAllocatorUsed = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FREEMEM",
          "args": [
            "state",
            "(state->maxTapes - numTapes) * TAPE_BUFFER_OVERHEAD"
          ],
          "line": 2617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "state->memtuples"
          ],
          "line": 2601
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "FREEMEM",
          "args": [
            "state",
            "GetMemoryChunkSpace(state->memtuples)"
          ],
          "line": 2600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextDelete",
          "args": [
            "state->tuplecontext"
          ],
          "line": 2593
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextDeleteChildren",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "255-266",
          "snippet": "void\nMemoryContextDeleteChildren(MemoryContext context)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\n\t/*\n\t * MemoryContextDelete will delink the child from me, so just iterate as\n\t * long as there is a child.\n\t */\n\twhile (context->firstchild != NULL)\n\t\tMemoryContextDelete(context->firstchild);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\nMemoryContextDeleteChildren(MemoryContext context)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\n\t/*\n\t * MemoryContextDelete will delink the child from me, so just iterate as\n\t * long as there is a child.\n\t */\n\twhile (context->firstchild != NULL)\n\t\tMemoryContextDelete(context->firstchild);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "state->memtupcount == 0"
          ],
          "line": 2571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "state->status == TSS_BUILDRUNS"
          ],
          "line": 2570
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TAPE_BUFFER_OVERHEAD\t\tBLCKSZ\n\nstatic Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void inittapes(Tuplesortstate *state, bool mergeruns);\nstatic void inittapestate(Tuplesortstate *state, int maxTapes);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic void markrunend(Tuplesortstate *state, int tapenum);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic void\nmergeruns(Tuplesortstate *state)\n{\n\tint\t\t\ttapenum,\n\t\t\t\tsvTape,\n\t\t\t\tsvRuns,\n\t\t\t\tsvDummy;\n\tint\t\t\tnumTapes;\n\tint\t\t\tnumInputTapes;\n\n\tAssert(state->status == TSS_BUILDRUNS);\n\tAssert(state->memtupcount == 0);\n\n\tif (state->sortKeys != NULL && state->sortKeys->abbrev_converter != NULL)\n\t{\n\t\t/*\n\t\t * If there are multiple runs to be merged, when we go to read back\n\t\t * tuples from disk, abbreviated keys will not have been stored, and\n\t\t * we don't care to regenerate them.  Disable abbreviation from this\n\t\t * point on.\n\t\t */\n\t\tstate->sortKeys->abbrev_converter = NULL;\n\t\tstate->sortKeys->comparator = state->sortKeys->abbrev_full_comparator;\n\n\t\t/* Not strictly necessary, but be tidy */\n\t\tstate->sortKeys->abbrev_abort = NULL;\n\t\tstate->sortKeys->abbrev_full_comparator = NULL;\n\t}\n\n\t/*\n\t * Reset tuple memory.  We've freed all the tuples that we previously\n\t * allocated.  We will use the slab allocator from now on.\n\t */\n\tMemoryContextDelete(state->tuplecontext);\n\tstate->tuplecontext = NULL;\n\n\t/*\n\t * We no longer need a large memtuples array.  (We will allocate a smaller\n\t * one for the heap later.)\n\t */\n\tFREEMEM(state, GetMemoryChunkSpace(state->memtuples));\n\tpfree(state->memtuples);\n\tstate->memtuples = NULL;\n\n\t/*\n\t * If we had fewer runs than tapes, refund the memory that we imagined we\n\t * would need for the tape buffers of the unused tapes.\n\t *\n\t * numTapes and numInputTapes reflect the actual number of tapes we will\n\t * use.  Note that the output tape's tape number is maxTapes - 1, so the\n\t * tape numbers of the used tapes are not consecutive, and you cannot just\n\t * loop from 0 to numTapes to visit all used tapes!\n\t */\n\tif (state->Level == 1)\n\t{\n\t\tnumInputTapes = state->currentRun;\n\t\tnumTapes = numInputTapes + 1;\n\t\tFREEMEM(state, (state->maxTapes - numTapes) * TAPE_BUFFER_OVERHEAD);\n\t}\n\telse\n\t{\n\t\tnumInputTapes = state->tapeRange;\n\t\tnumTapes = state->maxTapes;\n\t}\n\n\t/*\n\t * Initialize the slab allocator.  We need one slab slot per input tape,\n\t * for the tuples in the heap, plus one to hold the tuple last returned\n\t * from tuplesort_gettuple.  (If we're sorting pass-by-val Datums,\n\t * however, we don't need to do allocate anything.)\n\t *\n\t * From this point on, we no longer use the USEMEM()/LACKMEM() mechanism\n\t * to track memory usage of individual tuples.\n\t */\n\tif (state->tuples)\n\t\tinit_slab_allocator(state, numInputTapes + 1);\n\telse\n\t\tinit_slab_allocator(state, 0);\n\n\t/*\n\t * Allocate a new 'memtuples' array, for the heap.  It will hold one tuple\n\t * from each input tape.\n\t */\n\tstate->memtupsize = numInputTapes;\n\tstate->memtuples = (SortTuple *) palloc(numInputTapes * sizeof(SortTuple));\n\tUSEMEM(state, GetMemoryChunkSpace(state->memtuples));\n\n\t/*\n\t * Use all the remaining memory we have available for read buffers among\n\t * the input tapes.\n\t *\n\t * We don't try to \"rebalance\" the memory among tapes, when we start a new\n\t * merge phase, even if some tapes are inactive in the new phase.  That\n\t * would be hard, because logtape.c doesn't know where one run ends and\n\t * another begins.  When a new merge phase begins, and a tape doesn't\n\t * participate in it, its buffer nevertheless already contains tuples from\n\t * the next run on same tape, so we cannot release the buffer.  That's OK\n\t * in practice, merge performance isn't that sensitive to the amount of\n\t * buffers used, and most merge phases use all or almost all tapes,\n\t * anyway.\n\t */\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\telog(LOG, \"worker %d using \" INT64_FORMAT \" KB of memory for read buffers among %d input tapes\",\n\t\t\t state->worker, state->availMem / 1024, numInputTapes);\n#endif\n\n\tstate->read_buffer_size = Max(state->availMem / numInputTapes, 0);\n\tUSEMEM(state, state->read_buffer_size * numInputTapes);\n\n\t/* End of step D2: rewind all output tapes to prepare for merging */\n\tfor (tapenum = 0; tapenum < state->tapeRange; tapenum++)\n\t\tLogicalTapeRewindForRead(state->tapeset, tapenum, state->read_buffer_size);\n\n\tfor (;;)\n\t{\n\t\t/*\n\t\t * At this point we know that tape[T] is empty.  If there's just one\n\t\t * (real or dummy) run left on each input tape, then only one merge\n\t\t * pass remains.  If we don't have to produce a materialized sorted\n\t\t * tape, we can stop at this point and do the final merge on-the-fly.\n\t\t */\n\t\tif (!state->randomAccess && !WORKER(state))\n\t\t{\n\t\t\tbool\t\tallOneRun = true;\n\n\t\t\tAssert(state->tp_runs[state->tapeRange] == 0);\n\t\t\tfor (tapenum = 0; tapenum < state->tapeRange; tapenum++)\n\t\t\t{\n\t\t\t\tif (state->tp_runs[tapenum] + state->tp_dummy[tapenum] != 1)\n\t\t\t\t{\n\t\t\t\t\tallOneRun = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (allOneRun)\n\t\t\t{\n\t\t\t\t/* Tell logtape.c we won't be writing anymore */\n\t\t\t\tLogicalTapeSetForgetFreeSpace(state->tapeset);\n\t\t\t\t/* Initialize for the final merge pass */\n\t\t\t\tbeginmerge(state);\n\t\t\t\tstate->status = TSS_FINALMERGE;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t/* Step D5: merge runs onto tape[T] until tape[P] is empty */\n\t\twhile (state->tp_runs[state->tapeRange - 1] ||\n\t\t\t   state->tp_dummy[state->tapeRange - 1])\n\t\t{\n\t\t\tbool\t\tallDummy = true;\n\n\t\t\tfor (tapenum = 0; tapenum < state->tapeRange; tapenum++)\n\t\t\t{\n\t\t\t\tif (state->tp_dummy[tapenum] == 0)\n\t\t\t\t{\n\t\t\t\t\tallDummy = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (allDummy)\n\t\t\t{\n\t\t\t\tstate->tp_dummy[state->tapeRange]++;\n\t\t\t\tfor (tapenum = 0; tapenum < state->tapeRange; tapenum++)\n\t\t\t\t\tstate->tp_dummy[tapenum]--;\n\t\t\t}\n\t\t\telse\n\t\t\t\tmergeonerun(state);\n\t\t}\n\n\t\t/* Step D6: decrease level */\n\t\tif (--state->Level == 0)\n\t\t\tbreak;\n\t\t/* rewind output tape T to use as new input */\n\t\tLogicalTapeRewindForRead(state->tapeset, state->tp_tapenum[state->tapeRange],\n\t\t\t\t\t\t\t\t state->read_buffer_size);\n\t\t/* rewind used-up input tape P, and prepare it for write pass */\n\t\tLogicalTapeRewindForWrite(state->tapeset, state->tp_tapenum[state->tapeRange - 1]);\n\t\tstate->tp_runs[state->tapeRange - 1] = 0;\n\n\t\t/*\n\t\t * reassign tape units per step D6; note we no longer care about A[]\n\t\t */\n\t\tsvTape = state->tp_tapenum[state->tapeRange];\n\t\tsvDummy = state->tp_dummy[state->tapeRange];\n\t\tsvRuns = state->tp_runs[state->tapeRange];\n\t\tfor (tapenum = state->tapeRange; tapenum > 0; tapenum--)\n\t\t{\n\t\t\tstate->tp_tapenum[tapenum] = state->tp_tapenum[tapenum - 1];\n\t\t\tstate->tp_dummy[tapenum] = state->tp_dummy[tapenum - 1];\n\t\t\tstate->tp_runs[tapenum] = state->tp_runs[tapenum - 1];\n\t\t}\n\t\tstate->tp_tapenum[0] = svTape;\n\t\tstate->tp_dummy[0] = svDummy;\n\t\tstate->tp_runs[0] = svRuns;\n\t}\n\n\t/*\n\t * Done.  Knuth says that the result is on TAPE[1], but since we exited\n\t * the loop without performing the last iteration of step D6, we have not\n\t * rearranged the tape unit assignment, and therefore the result is on\n\t * TAPE[T].  We need to do it this way so that we can freeze the final\n\t * output tape while rewinding it.  The last iteration of step D6 would be\n\t * a waste of cycles anyway...\n\t */\n\tstate->result_tape = state->tp_tapenum[state->tapeRange];\n\tif (!WORKER(state))\n\t\tLogicalTapeFreeze(state->tapeset, state->result_tape, NULL);\n\telse\n\t\tworker_freeze_result_tape(state);\n\tstate->status = TSS_SORTEDONTAPE;\n\n\t/* Release the read buffers of all the other tapes, by rewinding them. */\n\tfor (tapenum = 0; tapenum < state->maxTapes; tapenum++)\n\t{\n\t\tif (tapenum != state->result_tape)\n\t\t\tLogicalTapeRewindForWrite(state->tapeset, tapenum);\n\t}\n}"
  },
  {
    "function_name": "init_slab_allocator",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "2524-2552",
    "snippet": "static void\ninit_slab_allocator(Tuplesortstate *state, int numSlots)\n{\n\tif (numSlots > 0)\n\t{\n\t\tchar\t   *p;\n\t\tint\t\t\ti;\n\n\t\tstate->slabMemoryBegin = palloc(numSlots * SLAB_SLOT_SIZE);\n\t\tstate->slabMemoryEnd = state->slabMemoryBegin +\n\t\t\tnumSlots * SLAB_SLOT_SIZE;\n\t\tstate->slabFreeHead = (SlabSlot *) state->slabMemoryBegin;\n\t\tUSEMEM(state, numSlots * SLAB_SLOT_SIZE);\n\n\t\tp = state->slabMemoryBegin;\n\t\tfor (i = 0; i < numSlots - 1; i++)\n\t\t{\n\t\t\t((SlabSlot *) p)->nextfree = (SlabSlot *) (p + SLAB_SLOT_SIZE);\n\t\t\tp += SLAB_SLOT_SIZE;\n\t\t}\n\t\t((SlabSlot *) p)->nextfree = NULL;\n\t}\n\telse\n\t{\n\t\tstate->slabMemoryBegin = state->slabMemoryEnd = NULL;\n\t\tstate->slabFreeHead = NULL;\n\t}\n\tstate->slabAllocatorUsed = true;\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define SLAB_SLOT_SIZE 1024"
    ],
    "globals_used": [
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void init_slab_allocator(Tuplesortstate *state, int numSlots);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "USEMEM",
          "args": [
            "state",
            "numSlots * SLAB_SLOT_SIZE"
          ],
          "line": 2536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "numSlots * SLAB_SLOT_SIZE"
          ],
          "line": 2532
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define SLAB_SLOT_SIZE 1024\n\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void init_slab_allocator(Tuplesortstate *state, int numSlots);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic void\ninit_slab_allocator(Tuplesortstate *state, int numSlots)\n{\n\tif (numSlots > 0)\n\t{\n\t\tchar\t   *p;\n\t\tint\t\t\ti;\n\n\t\tstate->slabMemoryBegin = palloc(numSlots * SLAB_SLOT_SIZE);\n\t\tstate->slabMemoryEnd = state->slabMemoryBegin +\n\t\t\tnumSlots * SLAB_SLOT_SIZE;\n\t\tstate->slabFreeHead = (SlabSlot *) state->slabMemoryBegin;\n\t\tUSEMEM(state, numSlots * SLAB_SLOT_SIZE);\n\n\t\tp = state->slabMemoryBegin;\n\t\tfor (i = 0; i < numSlots - 1; i++)\n\t\t{\n\t\t\t((SlabSlot *) p)->nextfree = (SlabSlot *) (p + SLAB_SLOT_SIZE);\n\t\t\tp += SLAB_SLOT_SIZE;\n\t\t}\n\t\t((SlabSlot *) p)->nextfree = NULL;\n\t}\n\telse\n\t{\n\t\tstate->slabMemoryBegin = state->slabMemoryEnd = NULL;\n\t\tstate->slabFreeHead = NULL;\n\t}\n\tstate->slabAllocatorUsed = true;\n}"
  },
  {
    "function_name": "selectnewtape",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "2492-2519",
    "snippet": "static void\nselectnewtape(Tuplesortstate *state)\n{\n\tint\t\t\tj;\n\tint\t\t\ta;\n\n\t/* Step D3: advance j (destTape) */\n\tif (state->tp_dummy[state->destTape] < state->tp_dummy[state->destTape + 1])\n\t{\n\t\tstate->destTape++;\n\t\treturn;\n\t}\n\tif (state->tp_dummy[state->destTape] != 0)\n\t{\n\t\tstate->destTape = 0;\n\t\treturn;\n\t}\n\n\t/* Step D4: increase level */\n\tstate->Level++;\n\ta = state->tp_fib[0];\n\tfor (j = 0; j < state->tapeRange; j++)\n\t{\n\t\tstate->tp_dummy[j] = a + state->tp_fib[j + 1] - state->tp_fib[j];\n\t\tstate->tp_fib[j] = a + state->tp_fib[j + 1];\n\t}\n\tstate->destTape = 0;\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic void\nselectnewtape(Tuplesortstate *state)\n{\n\tint\t\t\tj;\n\tint\t\t\ta;\n\n\t/* Step D3: advance j (destTape) */\n\tif (state->tp_dummy[state->destTape] < state->tp_dummy[state->destTape + 1])\n\t{\n\t\tstate->destTape++;\n\t\treturn;\n\t}\n\tif (state->tp_dummy[state->destTape] != 0)\n\t{\n\t\tstate->destTape = 0;\n\t\treturn;\n\t}\n\n\t/* Step D4: increase level */\n\tstate->Level++;\n\ta = state->tp_fib[0];\n\tfor (j = 0; j < state->tapeRange; j++)\n\t{\n\t\tstate->tp_dummy[j] = a + state->tp_fib[j + 1] - state->tp_fib[j];\n\t\tstate->tp_fib[j] = a + state->tp_fib[j + 1];\n\t}\n\tstate->destTape = 0;\n}"
  },
  {
    "function_name": "inittapestate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "2448-2484",
    "snippet": "static void\ninittapestate(Tuplesortstate *state, int maxTapes)\n{\n\tint64\t\ttapeSpace;\n\n\t/*\n\t * Decrease availMem to reflect the space needed for tape buffers; but\n\t * don't decrease it to the point that we have no room for tuples. (That\n\t * case is only likely to occur if sorting pass-by-value Datums; in all\n\t * other scenarios the memtuples[] array is unlikely to occupy more than\n\t * half of allowedMem.  In the pass-by-value case it's not important to\n\t * account for tuple space, so we don't care if LACKMEM becomes\n\t * inaccurate.)\n\t */\n\ttapeSpace = (int64) maxTapes * TAPE_BUFFER_OVERHEAD;\n\n\tif (tapeSpace + GetMemoryChunkSpace(state->memtuples) < state->allowedMem)\n\t\tUSEMEM(state, tapeSpace);\n\n\t/*\n\t * Make sure that the temp file(s) underlying the tape set are created in\n\t * suitable temp tablespaces.  For parallel sorts, this should have been\n\t * called already, but it doesn't matter if it is called a second time.\n\t */\n\tPrepareTempTablespaces();\n\n\tstate->mergeactive = (bool *) palloc0(maxTapes * sizeof(bool));\n\tstate->tp_fib = (int *) palloc0(maxTapes * sizeof(int));\n\tstate->tp_runs = (int *) palloc0(maxTapes * sizeof(int));\n\tstate->tp_dummy = (int *) palloc0(maxTapes * sizeof(int));\n\tstate->tp_tapenum = (int *) palloc0(maxTapes * sizeof(int));\n\n\t/* Record # of tapes allocated (for duration of sort) */\n\tstate->maxTapes = maxTapes;\n\t/* Record maximum # of tapes usable as inputs when merging */\n\tstate->tapeRange = maxTapes - 1;\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define TAPE_BUFFER_OVERHEAD\t\tBLCKSZ"
    ],
    "globals_used": [
      "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void inittapestate(Tuplesortstate *state, int maxTapes);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "maxTapes * sizeof(int)"
          ],
          "line": 2478
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PrepareTempTablespaces",
          "args": [],
          "line": 2472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USEMEM",
          "args": [
            "state",
            "tapeSpace"
          ],
          "line": 2465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetMemoryChunkSpace",
          "args": [
            "state->memtuples"
          ],
          "line": 2464
        },
        "resolved": true,
        "details": {
          "function_name": "GetMemoryChunkSpace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "426-432",
          "snippet": "Size\nGetMemoryChunkSpace(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\treturn context->methods->get_chunk_space(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nSize\nGetMemoryChunkSpace(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\treturn context->methods->get_chunk_space(context, pointer);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TAPE_BUFFER_OVERHEAD\t\tBLCKSZ\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void inittapestate(Tuplesortstate *state, int maxTapes);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic void\ninittapestate(Tuplesortstate *state, int maxTapes)\n{\n\tint64\t\ttapeSpace;\n\n\t/*\n\t * Decrease availMem to reflect the space needed for tape buffers; but\n\t * don't decrease it to the point that we have no room for tuples. (That\n\t * case is only likely to occur if sorting pass-by-value Datums; in all\n\t * other scenarios the memtuples[] array is unlikely to occupy more than\n\t * half of allowedMem.  In the pass-by-value case it's not important to\n\t * account for tuple space, so we don't care if LACKMEM becomes\n\t * inaccurate.)\n\t */\n\ttapeSpace = (int64) maxTapes * TAPE_BUFFER_OVERHEAD;\n\n\tif (tapeSpace + GetMemoryChunkSpace(state->memtuples) < state->allowedMem)\n\t\tUSEMEM(state, tapeSpace);\n\n\t/*\n\t * Make sure that the temp file(s) underlying the tape set are created in\n\t * suitable temp tablespaces.  For parallel sorts, this should have been\n\t * called already, but it doesn't matter if it is called a second time.\n\t */\n\tPrepareTempTablespaces();\n\n\tstate->mergeactive = (bool *) palloc0(maxTapes * sizeof(bool));\n\tstate->tp_fib = (int *) palloc0(maxTapes * sizeof(int));\n\tstate->tp_runs = (int *) palloc0(maxTapes * sizeof(int));\n\tstate->tp_dummy = (int *) palloc0(maxTapes * sizeof(int));\n\tstate->tp_tapenum = (int *) palloc0(maxTapes * sizeof(int));\n\n\t/* Record # of tapes allocated (for duration of sort) */\n\tstate->maxTapes = maxTapes;\n\t/* Record maximum # of tapes usable as inputs when merging */\n\tstate->tapeRange = maxTapes - 1;\n}"
  },
  {
    "function_name": "inittapes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "2391-2443",
    "snippet": "static void\ninittapes(Tuplesortstate *state, bool mergeruns)\n{\n\tint\t\t\tmaxTapes,\n\t\t\t\tj;\n\n\tAssert(!LEADER(state));\n\n\tif (mergeruns)\n\t{\n\t\t/* Compute number of tapes to use: merge order plus 1 */\n\t\tmaxTapes = tuplesort_merge_order(state->allowedMem) + 1;\n\t}\n\telse\n\t{\n\t\t/* Workers can sometimes produce single run, output without merge */\n\t\tAssert(WORKER(state));\n\t\tmaxTapes = MINORDER + 1;\n\t}\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\telog(LOG, \"worker %d switching to external sort with %d tapes: %s\",\n\t\t\t state->worker, maxTapes, pg_rusage_show(&state->ru_start));\n#endif\n\n\t/* Create the tape set and allocate the per-tape data arrays */\n\tinittapestate(state, maxTapes);\n\tstate->tapeset =\n\t\tLogicalTapeSetCreate(maxTapes, NULL,\n\t\t\t\t\t\t\t state->shared ? &state->shared->fileset : NULL,\n\t\t\t\t\t\t\t state->worker);\n\n\tstate->currentRun = 0;\n\n\t/*\n\t * Initialize variables of Algorithm D (step D1).\n\t */\n\tfor (j = 0; j < maxTapes; j++)\n\t{\n\t\tstate->tp_fib[j] = 1;\n\t\tstate->tp_runs[j] = 0;\n\t\tstate->tp_dummy[j] = 1;\n\t\tstate->tp_tapenum[j] = j;\n\t}\n\tstate->tp_fib[state->tapeRange] = 0;\n\tstate->tp_dummy[state->tapeRange] = 0;\n\n\tstate->Level = 1;\n\tstate->destTape = 0;\n\n\tstate->status = TSS_BUILDRUNS;\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define MINORDER\t\t6\t\t/* minimum merge order */"
    ],
    "globals_used": [
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void inittapes(Tuplesortstate *state, bool mergeruns);",
      "static void inittapestate(Tuplesortstate *state, int maxTapes);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LogicalTapeSetCreate",
          "args": [
            "maxTapes",
            "NULL",
            "state->shared ? &state->shared->fileset : NULL",
            "state->worker"
          ],
          "line": 2420
        },
        "resolved": true,
        "details": {
          "function_name": "LogicalTapeSetCreate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/logtape.c",
          "lines": "509-578",
          "snippet": "LogicalTapeSet *\nLogicalTapeSetCreate(int ntapes, TapeShare *shared, SharedFileSet *fileset,\n\t\t\t\t\t int worker)\n{\n\tLogicalTapeSet *lts;\n\tLogicalTape *lt;\n\tint\t\t\ti;\n\n\t/*\n\t * Create top-level struct including per-tape LogicalTape structs.\n\t */\n\tAssert(ntapes > 0);\n\tlts = (LogicalTapeSet *) palloc(offsetof(LogicalTapeSet, tapes) +\n\t\t\t\t\t\t\t\t\tntapes * sizeof(LogicalTape));\n\tlts->nBlocksAllocated = 0L;\n\tlts->nBlocksWritten = 0L;\n\tlts->nHoleBlocks = 0L;\n\tlts->forgetFreeSpace = false;\n\tlts->blocksSorted = true;\t/* a zero-length array is sorted ... */\n\tlts->freeBlocksLen = 32;\t/* reasonable initial guess */\n\tlts->freeBlocks = (long *) palloc(lts->freeBlocksLen * sizeof(long));\n\tlts->nFreeBlocks = 0;\n\tlts->nTapes = ntapes;\n\n\t/*\n\t * Initialize per-tape structs.  Note we allocate the I/O buffer and the\n\t * first block for a tape only when it is first actually written to.  This\n\t * avoids wasting memory space when tuplesort.c overestimates the number\n\t * of tapes needed.\n\t */\n\tfor (i = 0; i < ntapes; i++)\n\t{\n\t\tlt = &lts->tapes[i];\n\t\tlt->writing = true;\n\t\tlt->frozen = false;\n\t\tlt->dirty = false;\n\t\tlt->firstBlockNumber = -1L;\n\t\tlt->curBlockNumber = -1L;\n\t\tlt->nextBlockNumber = -1L;\n\t\tlt->offsetBlockNumber = 0L;\n\t\tlt->buffer = NULL;\n\t\tlt->buffer_size = 0;\n\t\t/* palloc() larger than MaxAllocSize would fail */\n\t\tlt->max_size = MaxAllocSize;\n\t\tlt->pos = 0;\n\t\tlt->nbytes = 0;\n\t}\n\n\t/*\n\t * Create temp BufFile storage as required.\n\t *\n\t * Leader concatenates worker tapes, which requires special adjustment to\n\t * final tapeset data.  Things are simpler for the worker case and the\n\t * serial case, though.  They are generally very similar -- workers use a\n\t * shared fileset, whereas serial sorts use a conventional serial BufFile.\n\t */\n\tif (shared)\n\t\tltsConcatWorkerTapes(lts, shared, fileset);\n\telse if (fileset)\n\t{\n\t\tchar\t\tfilename[MAXPGPATH];\n\n\t\tpg_itoa(worker, filename);\n\t\tlts->pfile = BufFileCreateShared(fileset, filename);\n\t}\n\telse\n\t\tlts->pfile = BufFileCreateTemp(false);\n\n\treturn lts;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
            "static void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
            "static long ltsGetFreeBlock(LogicalTapeSet *lts);",
            "static void ltsConcatWorkerTapes(LogicalTapeSet *lts, TapeShare *shared,\n\t\t\t\t\t SharedFileSet *fileset);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/logtape.h\"\n#include \"utils/builtins.h\"\n#include \"storage/buffile.h\"\n#include \"postgres.h\"\n\nstatic void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic long ltsGetFreeBlock(LogicalTapeSet *lts);\nstatic void ltsConcatWorkerTapes(LogicalTapeSet *lts, TapeShare *shared,\n\t\t\t\t\t SharedFileSet *fileset);\n\nLogicalTapeSet *\nLogicalTapeSetCreate(int ntapes, TapeShare *shared, SharedFileSet *fileset,\n\t\t\t\t\t int worker)\n{\n\tLogicalTapeSet *lts;\n\tLogicalTape *lt;\n\tint\t\t\ti;\n\n\t/*\n\t * Create top-level struct including per-tape LogicalTape structs.\n\t */\n\tAssert(ntapes > 0);\n\tlts = (LogicalTapeSet *) palloc(offsetof(LogicalTapeSet, tapes) +\n\t\t\t\t\t\t\t\t\tntapes * sizeof(LogicalTape));\n\tlts->nBlocksAllocated = 0L;\n\tlts->nBlocksWritten = 0L;\n\tlts->nHoleBlocks = 0L;\n\tlts->forgetFreeSpace = false;\n\tlts->blocksSorted = true;\t/* a zero-length array is sorted ... */\n\tlts->freeBlocksLen = 32;\t/* reasonable initial guess */\n\tlts->freeBlocks = (long *) palloc(lts->freeBlocksLen * sizeof(long));\n\tlts->nFreeBlocks = 0;\n\tlts->nTapes = ntapes;\n\n\t/*\n\t * Initialize per-tape structs.  Note we allocate the I/O buffer and the\n\t * first block for a tape only when it is first actually written to.  This\n\t * avoids wasting memory space when tuplesort.c overestimates the number\n\t * of tapes needed.\n\t */\n\tfor (i = 0; i < ntapes; i++)\n\t{\n\t\tlt = &lts->tapes[i];\n\t\tlt->writing = true;\n\t\tlt->frozen = false;\n\t\tlt->dirty = false;\n\t\tlt->firstBlockNumber = -1L;\n\t\tlt->curBlockNumber = -1L;\n\t\tlt->nextBlockNumber = -1L;\n\t\tlt->offsetBlockNumber = 0L;\n\t\tlt->buffer = NULL;\n\t\tlt->buffer_size = 0;\n\t\t/* palloc() larger than MaxAllocSize would fail */\n\t\tlt->max_size = MaxAllocSize;\n\t\tlt->pos = 0;\n\t\tlt->nbytes = 0;\n\t}\n\n\t/*\n\t * Create temp BufFile storage as required.\n\t *\n\t * Leader concatenates worker tapes, which requires special adjustment to\n\t * final tapeset data.  Things are simpler for the worker case and the\n\t * serial case, though.  They are generally very similar -- workers use a\n\t * shared fileset, whereas serial sorts use a conventional serial BufFile.\n\t */\n\tif (shared)\n\t\tltsConcatWorkerTapes(lts, shared, fileset);\n\telse if (fileset)\n\t{\n\t\tchar\t\tfilename[MAXPGPATH];\n\n\t\tpg_itoa(worker, filename);\n\t\tlts->pfile = BufFileCreateShared(fileset, filename);\n\t}\n\telse\n\t\tlts->pfile = BufFileCreateTemp(false);\n\n\treturn lts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inittapestate",
          "args": [
            "state",
            "maxTapes"
          ],
          "line": 2418
        },
        "resolved": true,
        "details": {
          "function_name": "inittapestate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "2448-2484",
          "snippet": "static void\ninittapestate(Tuplesortstate *state, int maxTapes)\n{\n\tint64\t\ttapeSpace;\n\n\t/*\n\t * Decrease availMem to reflect the space needed for tape buffers; but\n\t * don't decrease it to the point that we have no room for tuples. (That\n\t * case is only likely to occur if sorting pass-by-value Datums; in all\n\t * other scenarios the memtuples[] array is unlikely to occupy more than\n\t * half of allowedMem.  In the pass-by-value case it's not important to\n\t * account for tuple space, so we don't care if LACKMEM becomes\n\t * inaccurate.)\n\t */\n\ttapeSpace = (int64) maxTapes * TAPE_BUFFER_OVERHEAD;\n\n\tif (tapeSpace + GetMemoryChunkSpace(state->memtuples) < state->allowedMem)\n\t\tUSEMEM(state, tapeSpace);\n\n\t/*\n\t * Make sure that the temp file(s) underlying the tape set are created in\n\t * suitable temp tablespaces.  For parallel sorts, this should have been\n\t * called already, but it doesn't matter if it is called a second time.\n\t */\n\tPrepareTempTablespaces();\n\n\tstate->mergeactive = (bool *) palloc0(maxTapes * sizeof(bool));\n\tstate->tp_fib = (int *) palloc0(maxTapes * sizeof(int));\n\tstate->tp_runs = (int *) palloc0(maxTapes * sizeof(int));\n\tstate->tp_dummy = (int *) palloc0(maxTapes * sizeof(int));\n\tstate->tp_tapenum = (int *) palloc0(maxTapes * sizeof(int));\n\n\t/* Record # of tapes allocated (for duration of sort) */\n\tstate->maxTapes = maxTapes;\n\t/* Record maximum # of tapes usable as inputs when merging */\n\tstate->tapeRange = maxTapes - 1;\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TAPE_BUFFER_OVERHEAD\t\tBLCKSZ"
          ],
          "globals_used": [
            "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void inittapestate(Tuplesortstate *state, int maxTapes);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TAPE_BUFFER_OVERHEAD\t\tBLCKSZ\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void inittapestate(Tuplesortstate *state, int maxTapes);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic void\ninittapestate(Tuplesortstate *state, int maxTapes)\n{\n\tint64\t\ttapeSpace;\n\n\t/*\n\t * Decrease availMem to reflect the space needed for tape buffers; but\n\t * don't decrease it to the point that we have no room for tuples. (That\n\t * case is only likely to occur if sorting pass-by-value Datums; in all\n\t * other scenarios the memtuples[] array is unlikely to occupy more than\n\t * half of allowedMem.  In the pass-by-value case it's not important to\n\t * account for tuple space, so we don't care if LACKMEM becomes\n\t * inaccurate.)\n\t */\n\ttapeSpace = (int64) maxTapes * TAPE_BUFFER_OVERHEAD;\n\n\tif (tapeSpace + GetMemoryChunkSpace(state->memtuples) < state->allowedMem)\n\t\tUSEMEM(state, tapeSpace);\n\n\t/*\n\t * Make sure that the temp file(s) underlying the tape set are created in\n\t * suitable temp tablespaces.  For parallel sorts, this should have been\n\t * called already, but it doesn't matter if it is called a second time.\n\t */\n\tPrepareTempTablespaces();\n\n\tstate->mergeactive = (bool *) palloc0(maxTapes * sizeof(bool));\n\tstate->tp_fib = (int *) palloc0(maxTapes * sizeof(int));\n\tstate->tp_runs = (int *) palloc0(maxTapes * sizeof(int));\n\tstate->tp_dummy = (int *) palloc0(maxTapes * sizeof(int));\n\tstate->tp_tapenum = (int *) palloc0(maxTapes * sizeof(int));\n\n\t/* Record # of tapes allocated (for duration of sort) */\n\tstate->maxTapes = maxTapes;\n\t/* Record maximum # of tapes usable as inputs when merging */\n\tstate->tapeRange = maxTapes - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "LOG",
            "\"worker %d switching to external sort with %d tapes: %s\"",
            "state->worker",
            "maxTapes",
            "pg_rusage_show(&state->ru_start)"
          ],
          "line": 2413
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_rusage_show",
          "args": [
            "&state->ru_start"
          ],
          "line": 2414
        },
        "resolved": true,
        "details": {
          "function_name": "pg_rusage_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/pg_rusage.c",
          "lines": "39-73",
          "snippet": "const char *\npg_rusage_show(const PGRUsage *ru0)\n{\n\tstatic char result[100];\n\tPGRUsage\tru1;\n\n\tpg_rusage_init(&ru1);\n\n\tif (ru1.tv.tv_usec < ru0->tv.tv_usec)\n\t{\n\t\tru1.tv.tv_sec--;\n\t\tru1.tv.tv_usec += 1000000;\n\t}\n\tif (ru1.ru.ru_stime.tv_usec < ru0->ru.ru_stime.tv_usec)\n\t{\n\t\tru1.ru.ru_stime.tv_sec--;\n\t\tru1.ru.ru_stime.tv_usec += 1000000;\n\t}\n\tif (ru1.ru.ru_utime.tv_usec < ru0->ru.ru_utime.tv_usec)\n\t{\n\t\tru1.ru.ru_utime.tv_sec--;\n\t\tru1.ru.ru_utime.tv_usec += 1000000;\n\t}\n\n\tsnprintf(result, sizeof(result),\n\t\t\t _(\"CPU: user: %d.%02d s, system: %d.%02d s, elapsed: %d.%02d s\"),\n\t\t\t (int) (ru1.ru.ru_utime.tv_sec - ru0->ru.ru_utime.tv_sec),\n\t\t\t (int) (ru1.ru.ru_utime.tv_usec - ru0->ru.ru_utime.tv_usec) / 10000,\n\t\t\t (int) (ru1.ru.ru_stime.tv_sec - ru0->ru.ru_stime.tv_sec),\n\t\t\t (int) (ru1.ru.ru_stime.tv_usec - ru0->ru.ru_stime.tv_usec) / 10000,\n\t\t\t (int) (ru1.tv.tv_sec - ru0->tv.tv_sec),\n\t\t\t (int) (ru1.tv.tv_usec - ru0->tv.tv_usec) / 10000);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/pg_rusage.h\"",
            "#include <unistd.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_rusage.h\"\n#include <unistd.h>\n#include \"postgres.h\"\n\nconst char *\npg_rusage_show(const PGRUsage *ru0)\n{\n\tstatic char result[100];\n\tPGRUsage\tru1;\n\n\tpg_rusage_init(&ru1);\n\n\tif (ru1.tv.tv_usec < ru0->tv.tv_usec)\n\t{\n\t\tru1.tv.tv_sec--;\n\t\tru1.tv.tv_usec += 1000000;\n\t}\n\tif (ru1.ru.ru_stime.tv_usec < ru0->ru.ru_stime.tv_usec)\n\t{\n\t\tru1.ru.ru_stime.tv_sec--;\n\t\tru1.ru.ru_stime.tv_usec += 1000000;\n\t}\n\tif (ru1.ru.ru_utime.tv_usec < ru0->ru.ru_utime.tv_usec)\n\t{\n\t\tru1.ru.ru_utime.tv_sec--;\n\t\tru1.ru.ru_utime.tv_usec += 1000000;\n\t}\n\n\tsnprintf(result, sizeof(result),\n\t\t\t _(\"CPU: user: %d.%02d s, system: %d.%02d s, elapsed: %d.%02d s\"),\n\t\t\t (int) (ru1.ru.ru_utime.tv_sec - ru0->ru.ru_utime.tv_sec),\n\t\t\t (int) (ru1.ru.ru_utime.tv_usec - ru0->ru.ru_utime.tv_usec) / 10000,\n\t\t\t (int) (ru1.ru.ru_stime.tv_sec - ru0->ru.ru_stime.tv_sec),\n\t\t\t (int) (ru1.ru.ru_stime.tv_usec - ru0->ru.ru_stime.tv_usec) / 10000,\n\t\t\t (int) (ru1.tv.tv_sec - ru0->tv.tv_sec),\n\t\t\t (int) (ru1.tv.tv_usec - ru0->tv.tv_usec) / 10000);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "WORKER(state)"
          ],
          "line": 2407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WORKER",
          "args": [
            "state"
          ],
          "line": 2407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tuplesort_merge_order",
          "args": [
            "state->allowedMem"
          ],
          "line": 2402
        },
        "resolved": true,
        "details": {
          "function_name": "tuplesort_merge_order",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "2351-2384",
          "snippet": "int\ntuplesort_merge_order(int64 allowedMem)\n{\n\tint\t\t\tmOrder;\n\n\t/*\n\t * We need one tape for each merge input, plus another one for the output,\n\t * and each of these tapes needs buffer space.  In addition we want\n\t * MERGE_BUFFER_SIZE workspace per input tape (but the output tape doesn't\n\t * count).\n\t *\n\t * Note: you might be thinking we need to account for the memtuples[]\n\t * array in this calculation, but we effectively treat that as part of the\n\t * MERGE_BUFFER_SIZE workspace.\n\t */\n\tmOrder = (allowedMem - TAPE_BUFFER_OVERHEAD) /\n\t\t(MERGE_BUFFER_SIZE + TAPE_BUFFER_OVERHEAD);\n\n\t/*\n\t * Even in minimum memory, use at least a MINORDER merge.  On the other\n\t * hand, even when we have lots of memory, do not use more than a MAXORDER\n\t * merge.  Tapes are pretty cheap, but they're not entirely free.  Each\n\t * additional tape reduces the amount of memory available to build runs,\n\t * which in turn can cause the same sort to need more runs, which makes\n\t * merging slower even if it can still be done in a single pass.  Also,\n\t * high order merges are quite slow due to CPU cache effects; it can be\n\t * faster to pay the I/O cost of a polyphase merge than to perform a\n\t * single merge pass across many hundreds of tapes.\n\t */\n\tmOrder = Max(mOrder, MINORDER);\n\tmOrder = Min(mOrder, MAXORDER);\n\n\treturn mOrder;\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MERGE_BUFFER_SIZE\t\t\t(BLCKSZ * 32)",
            "#define TAPE_BUFFER_OVERHEAD\t\tBLCKSZ",
            "#define MAXORDER\t\t500\t\t/* maximum merge order */",
            "#define MINORDER\t\t6\t\t/* minimum merge order */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define MERGE_BUFFER_SIZE\t\t\t(BLCKSZ * 32)\n#define TAPE_BUFFER_OVERHEAD\t\tBLCKSZ\n#define MAXORDER\t\t500\t\t/* maximum merge order */\n#define MINORDER\t\t6\t\t/* minimum merge order */\n\nint\ntuplesort_merge_order(int64 allowedMem)\n{\n\tint\t\t\tmOrder;\n\n\t/*\n\t * We need one tape for each merge input, plus another one for the output,\n\t * and each of these tapes needs buffer space.  In addition we want\n\t * MERGE_BUFFER_SIZE workspace per input tape (but the output tape doesn't\n\t * count).\n\t *\n\t * Note: you might be thinking we need to account for the memtuples[]\n\t * array in this calculation, but we effectively treat that as part of the\n\t * MERGE_BUFFER_SIZE workspace.\n\t */\n\tmOrder = (allowedMem - TAPE_BUFFER_OVERHEAD) /\n\t\t(MERGE_BUFFER_SIZE + TAPE_BUFFER_OVERHEAD);\n\n\t/*\n\t * Even in minimum memory, use at least a MINORDER merge.  On the other\n\t * hand, even when we have lots of memory, do not use more than a MAXORDER\n\t * merge.  Tapes are pretty cheap, but they're not entirely free.  Each\n\t * additional tape reduces the amount of memory available to build runs,\n\t * which in turn can cause the same sort to need more runs, which makes\n\t * merging slower even if it can still be done in a single pass.  Also,\n\t * high order merges are quite slow due to CPU cache effects; it can be\n\t * faster to pay the I/O cost of a polyphase merge than to perform a\n\t * single merge pass across many hundreds of tapes.\n\t */\n\tmOrder = Max(mOrder, MINORDER);\n\tmOrder = Min(mOrder, MAXORDER);\n\n\treturn mOrder;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!LEADER(state)"
          ],
          "line": 2397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LEADER",
          "args": [
            "state"
          ],
          "line": 2397
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define MINORDER\t\t6\t\t/* minimum merge order */\n\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void inittapes(Tuplesortstate *state, bool mergeruns);\nstatic void inittapestate(Tuplesortstate *state, int maxTapes);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic void\ninittapes(Tuplesortstate *state, bool mergeruns)\n{\n\tint\t\t\tmaxTapes,\n\t\t\t\tj;\n\n\tAssert(!LEADER(state));\n\n\tif (mergeruns)\n\t{\n\t\t/* Compute number of tapes to use: merge order plus 1 */\n\t\tmaxTapes = tuplesort_merge_order(state->allowedMem) + 1;\n\t}\n\telse\n\t{\n\t\t/* Workers can sometimes produce single run, output without merge */\n\t\tAssert(WORKER(state));\n\t\tmaxTapes = MINORDER + 1;\n\t}\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\telog(LOG, \"worker %d switching to external sort with %d tapes: %s\",\n\t\t\t state->worker, maxTapes, pg_rusage_show(&state->ru_start));\n#endif\n\n\t/* Create the tape set and allocate the per-tape data arrays */\n\tinittapestate(state, maxTapes);\n\tstate->tapeset =\n\t\tLogicalTapeSetCreate(maxTapes, NULL,\n\t\t\t\t\t\t\t state->shared ? &state->shared->fileset : NULL,\n\t\t\t\t\t\t\t state->worker);\n\n\tstate->currentRun = 0;\n\n\t/*\n\t * Initialize variables of Algorithm D (step D1).\n\t */\n\tfor (j = 0; j < maxTapes; j++)\n\t{\n\t\tstate->tp_fib[j] = 1;\n\t\tstate->tp_runs[j] = 0;\n\t\tstate->tp_dummy[j] = 1;\n\t\tstate->tp_tapenum[j] = j;\n\t}\n\tstate->tp_fib[state->tapeRange] = 0;\n\tstate->tp_dummy[state->tapeRange] = 0;\n\n\tstate->Level = 1;\n\tstate->destTape = 0;\n\n\tstate->status = TSS_BUILDRUNS;\n}"
  },
  {
    "function_name": "tuplesort_merge_order",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "2351-2384",
    "snippet": "int\ntuplesort_merge_order(int64 allowedMem)\n{\n\tint\t\t\tmOrder;\n\n\t/*\n\t * We need one tape for each merge input, plus another one for the output,\n\t * and each of these tapes needs buffer space.  In addition we want\n\t * MERGE_BUFFER_SIZE workspace per input tape (but the output tape doesn't\n\t * count).\n\t *\n\t * Note: you might be thinking we need to account for the memtuples[]\n\t * array in this calculation, but we effectively treat that as part of the\n\t * MERGE_BUFFER_SIZE workspace.\n\t */\n\tmOrder = (allowedMem - TAPE_BUFFER_OVERHEAD) /\n\t\t(MERGE_BUFFER_SIZE + TAPE_BUFFER_OVERHEAD);\n\n\t/*\n\t * Even in minimum memory, use at least a MINORDER merge.  On the other\n\t * hand, even when we have lots of memory, do not use more than a MAXORDER\n\t * merge.  Tapes are pretty cheap, but they're not entirely free.  Each\n\t * additional tape reduces the amount of memory available to build runs,\n\t * which in turn can cause the same sort to need more runs, which makes\n\t * merging slower even if it can still be done in a single pass.  Also,\n\t * high order merges are quite slow due to CPU cache effects; it can be\n\t * faster to pay the I/O cost of a polyphase merge than to perform a\n\t * single merge pass across many hundreds of tapes.\n\t */\n\tmOrder = Max(mOrder, MINORDER);\n\tmOrder = Min(mOrder, MAXORDER);\n\n\treturn mOrder;\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define MERGE_BUFFER_SIZE\t\t\t(BLCKSZ * 32)",
      "#define TAPE_BUFFER_OVERHEAD\t\tBLCKSZ",
      "#define MAXORDER\t\t500\t\t/* maximum merge order */",
      "#define MINORDER\t\t6\t\t/* minimum merge order */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "mOrder",
            "MAXORDER"
          ],
          "line": 2381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Max",
          "args": [
            "mOrder",
            "MINORDER"
          ],
          "line": 2380
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define MERGE_BUFFER_SIZE\t\t\t(BLCKSZ * 32)\n#define TAPE_BUFFER_OVERHEAD\t\tBLCKSZ\n#define MAXORDER\t\t500\t\t/* maximum merge order */\n#define MINORDER\t\t6\t\t/* minimum merge order */\n\nint\ntuplesort_merge_order(int64 allowedMem)\n{\n\tint\t\t\tmOrder;\n\n\t/*\n\t * We need one tape for each merge input, plus another one for the output,\n\t * and each of these tapes needs buffer space.  In addition we want\n\t * MERGE_BUFFER_SIZE workspace per input tape (but the output tape doesn't\n\t * count).\n\t *\n\t * Note: you might be thinking we need to account for the memtuples[]\n\t * array in this calculation, but we effectively treat that as part of the\n\t * MERGE_BUFFER_SIZE workspace.\n\t */\n\tmOrder = (allowedMem - TAPE_BUFFER_OVERHEAD) /\n\t\t(MERGE_BUFFER_SIZE + TAPE_BUFFER_OVERHEAD);\n\n\t/*\n\t * Even in minimum memory, use at least a MINORDER merge.  On the other\n\t * hand, even when we have lots of memory, do not use more than a MAXORDER\n\t * merge.  Tapes are pretty cheap, but they're not entirely free.  Each\n\t * additional tape reduces the amount of memory available to build runs,\n\t * which in turn can cause the same sort to need more runs, which makes\n\t * merging slower even if it can still be done in a single pass.  Also,\n\t * high order merges are quite slow due to CPU cache effects; it can be\n\t * faster to pay the I/O cost of a polyphase merge than to perform a\n\t * single merge pass across many hundreds of tapes.\n\t */\n\tmOrder = Max(mOrder, MINORDER);\n\tmOrder = Min(mOrder, MAXORDER);\n\n\treturn mOrder;\n}"
  },
  {
    "function_name": "tuplesort_skiptuples",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "2283-2343",
    "snippet": "bool\ntuplesort_skiptuples(Tuplesortstate *state, int64 ntuples, bool forward)\n{\n\tMemoryContext oldcontext;\n\n\t/*\n\t * We don't actually support backwards skip yet, because no callers need\n\t * it.  The API is designed to allow for that later, though.\n\t */\n\tAssert(forward);\n\tAssert(ntuples >= 0);\n\tAssert(!WORKER(state));\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_SORTEDINMEM:\n\t\t\tif (state->memtupcount - state->current >= ntuples)\n\t\t\t{\n\t\t\t\tstate->current += ntuples;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tstate->current = state->memtupcount;\n\t\t\tstate->eof_reached = true;\n\n\t\t\t/*\n\t\t\t * Complain if caller tries to retrieve more tuples than\n\t\t\t * originally asked for in a bounded sort.  This is because\n\t\t\t * returning EOF here might be the wrong thing.\n\t\t\t */\n\t\t\tif (state->bounded && state->current >= state->bound)\n\t\t\t\telog(ERROR, \"retrieved too many tuples in a bounded sort\");\n\n\t\t\treturn false;\n\n\t\tcase TSS_SORTEDONTAPE:\n\t\tcase TSS_FINALMERGE:\n\n\t\t\t/*\n\t\t\t * We could probably optimize these cases better, but for now it's\n\t\t\t * not worth the trouble.\n\t\t\t */\n\t\t\toldcontext = MemoryContextSwitchTo(state->sortcontext);\n\t\t\twhile (ntuples-- > 0)\n\t\t\t{\n\t\t\t\tSortTuple\tstup;\n\n\t\t\t\tif (!tuplesort_gettuple_common(state, forward, &stup))\n\t\t\t\t{\n\t\t\t\t\tMemoryContextSwitchTo(oldcontext);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tCHECK_FOR_INTERRUPTS();\n\t\t\t}\n\t\t\tMemoryContextSwitchTo(oldcontext);\n\t\t\treturn true;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplesort state\");\n\t\t\treturn false;\t\t/* keep compiler quiet */\n\t}\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);",
      "static void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"invalid tuplesort state\""
          ],
          "line": 2340
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 2336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_FOR_INTERRUPTS",
          "args": [],
          "line": 2334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 2331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tuplesort_gettuple_common",
          "args": [
            "state",
            "forward",
            "&stup"
          ],
          "line": 2329
        },
        "resolved": true,
        "details": {
          "function_name": "tuplesort_gettuple_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "1900-2135",
          "snippet": "static bool\ntuplesort_gettuple_common(Tuplesortstate *state, bool forward,\n\t\t\t\t\t\t  SortTuple *stup)\n{\n\tunsigned int tuplen;\n\tsize_t\t\tnmoved;\n\n\tAssert(!WORKER(state));\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_SORTEDINMEM:\n\t\t\tAssert(forward || state->randomAccess);\n\t\t\tAssert(!state->slabAllocatorUsed);\n\t\t\tif (forward)\n\t\t\t{\n\t\t\t\tif (state->current < state->memtupcount)\n\t\t\t\t{\n\t\t\t\t\t*stup = state->memtuples[state->current++];\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tstate->eof_reached = true;\n\n\t\t\t\t/*\n\t\t\t\t * Complain if caller tries to retrieve more tuples than\n\t\t\t\t * originally asked for in a bounded sort.  This is because\n\t\t\t\t * returning EOF here might be the wrong thing.\n\t\t\t\t */\n\t\t\t\tif (state->bounded && state->current >= state->bound)\n\t\t\t\t\telog(ERROR, \"retrieved too many tuples in a bounded sort\");\n\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (state->current <= 0)\n\t\t\t\t\treturn false;\n\n\t\t\t\t/*\n\t\t\t\t * if all tuples are fetched already then we return last\n\t\t\t\t * tuple, else - tuple before last returned.\n\t\t\t\t */\n\t\t\t\tif (state->eof_reached)\n\t\t\t\t\tstate->eof_reached = false;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstate->current--;\t/* last returned tuple */\n\t\t\t\t\tif (state->current <= 0)\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t*stup = state->memtuples[state->current - 1];\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TSS_SORTEDONTAPE:\n\t\t\tAssert(forward || state->randomAccess);\n\t\t\tAssert(state->slabAllocatorUsed);\n\n\t\t\t/*\n\t\t\t * The slot that held the tuple that we returned in previous\n\t\t\t * gettuple call can now be reused.\n\t\t\t */\n\t\t\tif (state->lastReturnedTuple)\n\t\t\t{\n\t\t\t\tRELEASE_SLAB_SLOT(state, state->lastReturnedTuple);\n\t\t\t\tstate->lastReturnedTuple = NULL;\n\t\t\t}\n\n\t\t\tif (forward)\n\t\t\t{\n\t\t\t\tif (state->eof_reached)\n\t\t\t\t\treturn false;\n\n\t\t\t\tif ((tuplen = getlen(state, state->result_tape, true)) != 0)\n\t\t\t\t{\n\t\t\t\t\tREADTUP(state, stup, state->result_tape, tuplen);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Remember the tuple we return, so that we can recycle\n\t\t\t\t\t * its memory on next call.  (This can be NULL, in the\n\t\t\t\t\t * !state->tuples case).\n\t\t\t\t\t */\n\t\t\t\t\tstate->lastReturnedTuple = stup->tuple;\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstate->eof_reached = true;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Backward.\n\t\t\t *\n\t\t\t * if all tuples are fetched already then we return last tuple,\n\t\t\t * else - tuple before last returned.\n\t\t\t */\n\t\t\tif (state->eof_reached)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Seek position is pointing just past the zero tuplen at the\n\t\t\t\t * end of file; back up to fetch last tuple's ending length\n\t\t\t\t * word.  If seek fails we must have a completely empty file.\n\t\t\t\t */\n\t\t\t\tnmoved = LogicalTapeBackspace(state->tapeset,\n\t\t\t\t\t\t\t\t\t\t\t  state->result_tape,\n\t\t\t\t\t\t\t\t\t\t\t  2 * sizeof(unsigned int));\n\t\t\t\tif (nmoved == 0)\n\t\t\t\t\treturn false;\n\t\t\t\telse if (nmoved != 2 * sizeof(unsigned int))\n\t\t\t\t\telog(ERROR, \"unexpected tape position\");\n\t\t\t\tstate->eof_reached = false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Back up and fetch previously-returned tuple's ending length\n\t\t\t\t * word.  If seek fails, assume we are at start of file.\n\t\t\t\t */\n\t\t\t\tnmoved = LogicalTapeBackspace(state->tapeset,\n\t\t\t\t\t\t\t\t\t\t\t  state->result_tape,\n\t\t\t\t\t\t\t\t\t\t\t  sizeof(unsigned int));\n\t\t\t\tif (nmoved == 0)\n\t\t\t\t\treturn false;\n\t\t\t\telse if (nmoved != sizeof(unsigned int))\n\t\t\t\t\telog(ERROR, \"unexpected tape position\");\n\t\t\t\ttuplen = getlen(state, state->result_tape, false);\n\n\t\t\t\t/*\n\t\t\t\t * Back up to get ending length word of tuple before it.\n\t\t\t\t */\n\t\t\t\tnmoved = LogicalTapeBackspace(state->tapeset,\n\t\t\t\t\t\t\t\t\t\t\t  state->result_tape,\n\t\t\t\t\t\t\t\t\t\t\t  tuplen + 2 * sizeof(unsigned int));\n\t\t\t\tif (nmoved == tuplen + sizeof(unsigned int))\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * We backed up over the previous tuple, but there was no\n\t\t\t\t\t * ending length word before it.  That means that the prev\n\t\t\t\t\t * tuple is the first tuple in the file.  It is now the\n\t\t\t\t\t * next to read in forward direction (not obviously right,\n\t\t\t\t\t * but that is what in-memory case does).\n\t\t\t\t\t */\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\telse if (nmoved != tuplen + 2 * sizeof(unsigned int))\n\t\t\t\t\telog(ERROR, \"bogus tuple length in backward scan\");\n\t\t\t}\n\n\t\t\ttuplen = getlen(state, state->result_tape, false);\n\n\t\t\t/*\n\t\t\t * Now we have the length of the prior tuple, back up and read it.\n\t\t\t * Note: READTUP expects we are positioned after the initial\n\t\t\t * length word of the tuple, so back up to that point.\n\t\t\t */\n\t\t\tnmoved = LogicalTapeBackspace(state->tapeset,\n\t\t\t\t\t\t\t\t\t\t  state->result_tape,\n\t\t\t\t\t\t\t\t\t\t  tuplen);\n\t\t\tif (nmoved != tuplen)\n\t\t\t\telog(ERROR, \"bogus tuple length in backward scan\");\n\t\t\tREADTUP(state, stup, state->result_tape, tuplen);\n\n\t\t\t/*\n\t\t\t * Remember the tuple we return, so that we can recycle its memory\n\t\t\t * on next call. (This can be NULL, in the Datum case).\n\t\t\t */\n\t\t\tstate->lastReturnedTuple = stup->tuple;\n\n\t\t\treturn true;\n\n\t\tcase TSS_FINALMERGE:\n\t\t\tAssert(forward);\n\t\t\t/* We are managing memory ourselves, with the slab allocator. */\n\t\t\tAssert(state->slabAllocatorUsed);\n\n\t\t\t/*\n\t\t\t * The slab slot holding the tuple that we returned in previous\n\t\t\t * gettuple call can now be reused.\n\t\t\t */\n\t\t\tif (state->lastReturnedTuple)\n\t\t\t{\n\t\t\t\tRELEASE_SLAB_SLOT(state, state->lastReturnedTuple);\n\t\t\t\tstate->lastReturnedTuple = NULL;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * This code should match the inner loop of mergeonerun().\n\t\t\t */\n\t\t\tif (state->memtupcount > 0)\n\t\t\t{\n\t\t\t\tint\t\t\tsrcTape = state->memtuples[0].tupindex;\n\t\t\t\tSortTuple\tnewtup;\n\n\t\t\t\t*stup = state->memtuples[0];\n\n\t\t\t\t/*\n\t\t\t\t * Remember the tuple we return, so that we can recycle its\n\t\t\t\t * memory on next call. (This can be NULL, in the Datum case).\n\t\t\t\t */\n\t\t\t\tstate->lastReturnedTuple = stup->tuple;\n\n\t\t\t\t/*\n\t\t\t\t * Pull next tuple from tape, and replace the returned tuple\n\t\t\t\t * at top of the heap with it.\n\t\t\t\t */\n\t\t\t\tif (!mergereadnext(state, srcTape, &newtup))\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * If no more data, we've reached end of run on this tape.\n\t\t\t\t\t * Remove the top node from the heap.\n\t\t\t\t\t */\n\t\t\t\t\ttuplesort_heap_delete_top(state);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Rewind to free the read buffer.  It'd go away at the\n\t\t\t\t\t * end of the sort anyway, but better to release the\n\t\t\t\t\t * memory early.\n\t\t\t\t\t */\n\t\t\t\t\tLogicalTapeRewindForWrite(state->tapeset, srcTape);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tnewtup.tupindex = srcTape;\n\t\t\t\ttuplesort_heap_replace_top(state, &newtup);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplesort state\");\n\t\t\treturn false;\t\t/* keep compiler quiet */\n\t}\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);",
            "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static void *readtup_alloc(Tuplesortstate *state, Size tuplen);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);",
            "static void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic void *readtup_alloc(Tuplesortstate *state, Size tuplen);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\nstatic void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);\n\nstatic bool\ntuplesort_gettuple_common(Tuplesortstate *state, bool forward,\n\t\t\t\t\t\t  SortTuple *stup)\n{\n\tunsigned int tuplen;\n\tsize_t\t\tnmoved;\n\n\tAssert(!WORKER(state));\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_SORTEDINMEM:\n\t\t\tAssert(forward || state->randomAccess);\n\t\t\tAssert(!state->slabAllocatorUsed);\n\t\t\tif (forward)\n\t\t\t{\n\t\t\t\tif (state->current < state->memtupcount)\n\t\t\t\t{\n\t\t\t\t\t*stup = state->memtuples[state->current++];\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tstate->eof_reached = true;\n\n\t\t\t\t/*\n\t\t\t\t * Complain if caller tries to retrieve more tuples than\n\t\t\t\t * originally asked for in a bounded sort.  This is because\n\t\t\t\t * returning EOF here might be the wrong thing.\n\t\t\t\t */\n\t\t\t\tif (state->bounded && state->current >= state->bound)\n\t\t\t\t\telog(ERROR, \"retrieved too many tuples in a bounded sort\");\n\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (state->current <= 0)\n\t\t\t\t\treturn false;\n\n\t\t\t\t/*\n\t\t\t\t * if all tuples are fetched already then we return last\n\t\t\t\t * tuple, else - tuple before last returned.\n\t\t\t\t */\n\t\t\t\tif (state->eof_reached)\n\t\t\t\t\tstate->eof_reached = false;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstate->current--;\t/* last returned tuple */\n\t\t\t\t\tif (state->current <= 0)\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t*stup = state->memtuples[state->current - 1];\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TSS_SORTEDONTAPE:\n\t\t\tAssert(forward || state->randomAccess);\n\t\t\tAssert(state->slabAllocatorUsed);\n\n\t\t\t/*\n\t\t\t * The slot that held the tuple that we returned in previous\n\t\t\t * gettuple call can now be reused.\n\t\t\t */\n\t\t\tif (state->lastReturnedTuple)\n\t\t\t{\n\t\t\t\tRELEASE_SLAB_SLOT(state, state->lastReturnedTuple);\n\t\t\t\tstate->lastReturnedTuple = NULL;\n\t\t\t}\n\n\t\t\tif (forward)\n\t\t\t{\n\t\t\t\tif (state->eof_reached)\n\t\t\t\t\treturn false;\n\n\t\t\t\tif ((tuplen = getlen(state, state->result_tape, true)) != 0)\n\t\t\t\t{\n\t\t\t\t\tREADTUP(state, stup, state->result_tape, tuplen);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Remember the tuple we return, so that we can recycle\n\t\t\t\t\t * its memory on next call.  (This can be NULL, in the\n\t\t\t\t\t * !state->tuples case).\n\t\t\t\t\t */\n\t\t\t\t\tstate->lastReturnedTuple = stup->tuple;\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstate->eof_reached = true;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Backward.\n\t\t\t *\n\t\t\t * if all tuples are fetched already then we return last tuple,\n\t\t\t * else - tuple before last returned.\n\t\t\t */\n\t\t\tif (state->eof_reached)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Seek position is pointing just past the zero tuplen at the\n\t\t\t\t * end of file; back up to fetch last tuple's ending length\n\t\t\t\t * word.  If seek fails we must have a completely empty file.\n\t\t\t\t */\n\t\t\t\tnmoved = LogicalTapeBackspace(state->tapeset,\n\t\t\t\t\t\t\t\t\t\t\t  state->result_tape,\n\t\t\t\t\t\t\t\t\t\t\t  2 * sizeof(unsigned int));\n\t\t\t\tif (nmoved == 0)\n\t\t\t\t\treturn false;\n\t\t\t\telse if (nmoved != 2 * sizeof(unsigned int))\n\t\t\t\t\telog(ERROR, \"unexpected tape position\");\n\t\t\t\tstate->eof_reached = false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Back up and fetch previously-returned tuple's ending length\n\t\t\t\t * word.  If seek fails, assume we are at start of file.\n\t\t\t\t */\n\t\t\t\tnmoved = LogicalTapeBackspace(state->tapeset,\n\t\t\t\t\t\t\t\t\t\t\t  state->result_tape,\n\t\t\t\t\t\t\t\t\t\t\t  sizeof(unsigned int));\n\t\t\t\tif (nmoved == 0)\n\t\t\t\t\treturn false;\n\t\t\t\telse if (nmoved != sizeof(unsigned int))\n\t\t\t\t\telog(ERROR, \"unexpected tape position\");\n\t\t\t\ttuplen = getlen(state, state->result_tape, false);\n\n\t\t\t\t/*\n\t\t\t\t * Back up to get ending length word of tuple before it.\n\t\t\t\t */\n\t\t\t\tnmoved = LogicalTapeBackspace(state->tapeset,\n\t\t\t\t\t\t\t\t\t\t\t  state->result_tape,\n\t\t\t\t\t\t\t\t\t\t\t  tuplen + 2 * sizeof(unsigned int));\n\t\t\t\tif (nmoved == tuplen + sizeof(unsigned int))\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * We backed up over the previous tuple, but there was no\n\t\t\t\t\t * ending length word before it.  That means that the prev\n\t\t\t\t\t * tuple is the first tuple in the file.  It is now the\n\t\t\t\t\t * next to read in forward direction (not obviously right,\n\t\t\t\t\t * but that is what in-memory case does).\n\t\t\t\t\t */\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\telse if (nmoved != tuplen + 2 * sizeof(unsigned int))\n\t\t\t\t\telog(ERROR, \"bogus tuple length in backward scan\");\n\t\t\t}\n\n\t\t\ttuplen = getlen(state, state->result_tape, false);\n\n\t\t\t/*\n\t\t\t * Now we have the length of the prior tuple, back up and read it.\n\t\t\t * Note: READTUP expects we are positioned after the initial\n\t\t\t * length word of the tuple, so back up to that point.\n\t\t\t */\n\t\t\tnmoved = LogicalTapeBackspace(state->tapeset,\n\t\t\t\t\t\t\t\t\t\t  state->result_tape,\n\t\t\t\t\t\t\t\t\t\t  tuplen);\n\t\t\tif (nmoved != tuplen)\n\t\t\t\telog(ERROR, \"bogus tuple length in backward scan\");\n\t\t\tREADTUP(state, stup, state->result_tape, tuplen);\n\n\t\t\t/*\n\t\t\t * Remember the tuple we return, so that we can recycle its memory\n\t\t\t * on next call. (This can be NULL, in the Datum case).\n\t\t\t */\n\t\t\tstate->lastReturnedTuple = stup->tuple;\n\n\t\t\treturn true;\n\n\t\tcase TSS_FINALMERGE:\n\t\t\tAssert(forward);\n\t\t\t/* We are managing memory ourselves, with the slab allocator. */\n\t\t\tAssert(state->slabAllocatorUsed);\n\n\t\t\t/*\n\t\t\t * The slab slot holding the tuple that we returned in previous\n\t\t\t * gettuple call can now be reused.\n\t\t\t */\n\t\t\tif (state->lastReturnedTuple)\n\t\t\t{\n\t\t\t\tRELEASE_SLAB_SLOT(state, state->lastReturnedTuple);\n\t\t\t\tstate->lastReturnedTuple = NULL;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * This code should match the inner loop of mergeonerun().\n\t\t\t */\n\t\t\tif (state->memtupcount > 0)\n\t\t\t{\n\t\t\t\tint\t\t\tsrcTape = state->memtuples[0].tupindex;\n\t\t\t\tSortTuple\tnewtup;\n\n\t\t\t\t*stup = state->memtuples[0];\n\n\t\t\t\t/*\n\t\t\t\t * Remember the tuple we return, so that we can recycle its\n\t\t\t\t * memory on next call. (This can be NULL, in the Datum case).\n\t\t\t\t */\n\t\t\t\tstate->lastReturnedTuple = stup->tuple;\n\n\t\t\t\t/*\n\t\t\t\t * Pull next tuple from tape, and replace the returned tuple\n\t\t\t\t * at top of the heap with it.\n\t\t\t\t */\n\t\t\t\tif (!mergereadnext(state, srcTape, &newtup))\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * If no more data, we've reached end of run on this tape.\n\t\t\t\t\t * Remove the top node from the heap.\n\t\t\t\t\t */\n\t\t\t\t\ttuplesort_heap_delete_top(state);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Rewind to free the read buffer.  It'd go away at the\n\t\t\t\t\t * end of the sort anyway, but better to release the\n\t\t\t\t\t * memory early.\n\t\t\t\t\t */\n\t\t\t\t\tLogicalTapeRewindForWrite(state->tapeset, srcTape);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tnewtup.tupindex = srcTape;\n\t\t\t\ttuplesort_heap_replace_top(state, &newtup);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplesort state\");\n\t\t\treturn false;\t\t/* keep compiler quiet */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "state->sortcontext"
          ],
          "line": 2324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!WORKER(state)"
          ],
          "line": 2294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WORKER",
          "args": [
            "state"
          ],
          "line": 2294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "ntuples >= 0"
          ],
          "line": 2293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "forward"
          ],
          "line": 2292
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\nstatic void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);\n\nbool\ntuplesort_skiptuples(Tuplesortstate *state, int64 ntuples, bool forward)\n{\n\tMemoryContext oldcontext;\n\n\t/*\n\t * We don't actually support backwards skip yet, because no callers need\n\t * it.  The API is designed to allow for that later, though.\n\t */\n\tAssert(forward);\n\tAssert(ntuples >= 0);\n\tAssert(!WORKER(state));\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_SORTEDINMEM:\n\t\t\tif (state->memtupcount - state->current >= ntuples)\n\t\t\t{\n\t\t\t\tstate->current += ntuples;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tstate->current = state->memtupcount;\n\t\t\tstate->eof_reached = true;\n\n\t\t\t/*\n\t\t\t * Complain if caller tries to retrieve more tuples than\n\t\t\t * originally asked for in a bounded sort.  This is because\n\t\t\t * returning EOF here might be the wrong thing.\n\t\t\t */\n\t\t\tif (state->bounded && state->current >= state->bound)\n\t\t\t\telog(ERROR, \"retrieved too many tuples in a bounded sort\");\n\n\t\t\treturn false;\n\n\t\tcase TSS_SORTEDONTAPE:\n\t\tcase TSS_FINALMERGE:\n\n\t\t\t/*\n\t\t\t * We could probably optimize these cases better, but for now it's\n\t\t\t * not worth the trouble.\n\t\t\t */\n\t\t\toldcontext = MemoryContextSwitchTo(state->sortcontext);\n\t\t\twhile (ntuples-- > 0)\n\t\t\t{\n\t\t\t\tSortTuple\tstup;\n\n\t\t\t\tif (!tuplesort_gettuple_common(state, forward, &stup))\n\t\t\t\t{\n\t\t\t\t\tMemoryContextSwitchTo(oldcontext);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tCHECK_FOR_INTERRUPTS();\n\t\t\t}\n\t\t\tMemoryContextSwitchTo(oldcontext);\n\t\t\treturn true;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplesort state\");\n\t\t\treturn false;\t\t/* keep compiler quiet */\n\t}\n}"
  },
  {
    "function_name": "tuplesort_getdatum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "2243-2276",
    "snippet": "bool\ntuplesort_getdatum(Tuplesortstate *state, bool forward,\n\t\t\t\t   Datum *val, bool *isNull, Datum *abbrev)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\tSortTuple\tstup;\n\n\tif (!tuplesort_gettuple_common(state, forward, &stup))\n\t{\n\t\tMemoryContextSwitchTo(oldcontext);\n\t\treturn false;\n\t}\n\n\t/* Ensure we copy into caller's memory context */\n\tMemoryContextSwitchTo(oldcontext);\n\n\t/* Record abbreviated key for caller */\n\tif (state->sortKeys->abbrev_converter && abbrev)\n\t\t*abbrev = stup.datum1;\n\n\tif (stup.isnull1 || !state->tuples)\n\t{\n\t\t*val = stup.datum1;\n\t\t*isNull = stup.isnull1;\n\t}\n\telse\n\t{\n\t\t/* use stup.tuple because stup.datum1 may be an abbreviation */\n\t\t*val = datumCopy(PointerGetDatum(stup.tuple), false, state->datumTypeLen);\n\t\t*isNull = false;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);",
      "static void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "datumCopy",
          "args": [
            "PointerGetDatum(stup.tuple)",
            "false",
            "state->datumTypeLen"
          ],
          "line": 2271
        },
        "resolved": true,
        "details": {
          "function_name": "datumCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datum.c",
          "lines": "127-176",
          "snippet": "Datum\ndatumCopy(Datum value, bool typByVal, int typLen)\n{\n\tDatum\t\tres;\n\n\tif (typByVal)\n\t\tres = value;\n\telse if (typLen == -1)\n\t{\n\t\t/* It is a varlena datatype */\n\t\tstruct varlena *vl = (struct varlena *) DatumGetPointer(value);\n\n\t\tif (VARATT_IS_EXTERNAL_EXPANDED(vl))\n\t\t{\n\t\t\t/* Flatten into the caller's memory context */\n\t\t\tExpandedObjectHeader *eoh = DatumGetEOHP(value);\n\t\t\tSize\t\tresultsize;\n\t\t\tchar\t   *resultptr;\n\n\t\t\tresultsize = EOH_get_flat_size(eoh);\n\t\t\tresultptr = (char *) palloc(resultsize);\n\t\t\tEOH_flatten_into(eoh, (void *) resultptr, resultsize);\n\t\t\tres = PointerGetDatum(resultptr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Otherwise, just copy the varlena datum verbatim */\n\t\t\tSize\t\trealSize;\n\t\t\tchar\t   *resultptr;\n\n\t\t\trealSize = (Size) VARSIZE_ANY(vl);\n\t\t\tresultptr = (char *) palloc(realSize);\n\t\t\tmemcpy(resultptr, vl, realSize);\n\t\t\tres = PointerGetDatum(resultptr);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Pass by reference, but not varlena, so not toasted */\n\t\tSize\t\trealSize;\n\t\tchar\t   *resultptr;\n\n\t\trealSize = datumGetSize(value, typByVal, typLen);\n\n\t\tresultptr = (char *) palloc(realSize);\n\t\tmemcpy(resultptr, DatumGetPointer(value), realSize);\n\t\tres = PointerGetDatum(resultptr);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"utils/expandeddatum.h\"",
            "#include \"utils/datum.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/expandeddatum.h\"\n#include \"utils/datum.h\"\n#include \"postgres.h\"\n\nDatum\ndatumCopy(Datum value, bool typByVal, int typLen)\n{\n\tDatum\t\tres;\n\n\tif (typByVal)\n\t\tres = value;\n\telse if (typLen == -1)\n\t{\n\t\t/* It is a varlena datatype */\n\t\tstruct varlena *vl = (struct varlena *) DatumGetPointer(value);\n\n\t\tif (VARATT_IS_EXTERNAL_EXPANDED(vl))\n\t\t{\n\t\t\t/* Flatten into the caller's memory context */\n\t\t\tExpandedObjectHeader *eoh = DatumGetEOHP(value);\n\t\t\tSize\t\tresultsize;\n\t\t\tchar\t   *resultptr;\n\n\t\t\tresultsize = EOH_get_flat_size(eoh);\n\t\t\tresultptr = (char *) palloc(resultsize);\n\t\t\tEOH_flatten_into(eoh, (void *) resultptr, resultsize);\n\t\t\tres = PointerGetDatum(resultptr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Otherwise, just copy the varlena datum verbatim */\n\t\t\tSize\t\trealSize;\n\t\t\tchar\t   *resultptr;\n\n\t\t\trealSize = (Size) VARSIZE_ANY(vl);\n\t\t\tresultptr = (char *) palloc(realSize);\n\t\t\tmemcpy(resultptr, vl, realSize);\n\t\t\tres = PointerGetDatum(resultptr);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Pass by reference, but not varlena, so not toasted */\n\t\tSize\t\trealSize;\n\t\tchar\t   *resultptr;\n\n\t\trealSize = datumGetSize(value, typByVal, typLen);\n\n\t\tresultptr = (char *) palloc(realSize);\n\t\tmemcpy(resultptr, DatumGetPointer(value), realSize);\n\t\tres = PointerGetDatum(resultptr);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "stup.tuple"
          ],
          "line": 2271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 2257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 2252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tuplesort_gettuple_common",
          "args": [
            "state",
            "forward",
            "&stup"
          ],
          "line": 2250
        },
        "resolved": true,
        "details": {
          "function_name": "tuplesort_gettuple_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "1900-2135",
          "snippet": "static bool\ntuplesort_gettuple_common(Tuplesortstate *state, bool forward,\n\t\t\t\t\t\t  SortTuple *stup)\n{\n\tunsigned int tuplen;\n\tsize_t\t\tnmoved;\n\n\tAssert(!WORKER(state));\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_SORTEDINMEM:\n\t\t\tAssert(forward || state->randomAccess);\n\t\t\tAssert(!state->slabAllocatorUsed);\n\t\t\tif (forward)\n\t\t\t{\n\t\t\t\tif (state->current < state->memtupcount)\n\t\t\t\t{\n\t\t\t\t\t*stup = state->memtuples[state->current++];\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tstate->eof_reached = true;\n\n\t\t\t\t/*\n\t\t\t\t * Complain if caller tries to retrieve more tuples than\n\t\t\t\t * originally asked for in a bounded sort.  This is because\n\t\t\t\t * returning EOF here might be the wrong thing.\n\t\t\t\t */\n\t\t\t\tif (state->bounded && state->current >= state->bound)\n\t\t\t\t\telog(ERROR, \"retrieved too many tuples in a bounded sort\");\n\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (state->current <= 0)\n\t\t\t\t\treturn false;\n\n\t\t\t\t/*\n\t\t\t\t * if all tuples are fetched already then we return last\n\t\t\t\t * tuple, else - tuple before last returned.\n\t\t\t\t */\n\t\t\t\tif (state->eof_reached)\n\t\t\t\t\tstate->eof_reached = false;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstate->current--;\t/* last returned tuple */\n\t\t\t\t\tif (state->current <= 0)\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t*stup = state->memtuples[state->current - 1];\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TSS_SORTEDONTAPE:\n\t\t\tAssert(forward || state->randomAccess);\n\t\t\tAssert(state->slabAllocatorUsed);\n\n\t\t\t/*\n\t\t\t * The slot that held the tuple that we returned in previous\n\t\t\t * gettuple call can now be reused.\n\t\t\t */\n\t\t\tif (state->lastReturnedTuple)\n\t\t\t{\n\t\t\t\tRELEASE_SLAB_SLOT(state, state->lastReturnedTuple);\n\t\t\t\tstate->lastReturnedTuple = NULL;\n\t\t\t}\n\n\t\t\tif (forward)\n\t\t\t{\n\t\t\t\tif (state->eof_reached)\n\t\t\t\t\treturn false;\n\n\t\t\t\tif ((tuplen = getlen(state, state->result_tape, true)) != 0)\n\t\t\t\t{\n\t\t\t\t\tREADTUP(state, stup, state->result_tape, tuplen);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Remember the tuple we return, so that we can recycle\n\t\t\t\t\t * its memory on next call.  (This can be NULL, in the\n\t\t\t\t\t * !state->tuples case).\n\t\t\t\t\t */\n\t\t\t\t\tstate->lastReturnedTuple = stup->tuple;\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstate->eof_reached = true;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Backward.\n\t\t\t *\n\t\t\t * if all tuples are fetched already then we return last tuple,\n\t\t\t * else - tuple before last returned.\n\t\t\t */\n\t\t\tif (state->eof_reached)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Seek position is pointing just past the zero tuplen at the\n\t\t\t\t * end of file; back up to fetch last tuple's ending length\n\t\t\t\t * word.  If seek fails we must have a completely empty file.\n\t\t\t\t */\n\t\t\t\tnmoved = LogicalTapeBackspace(state->tapeset,\n\t\t\t\t\t\t\t\t\t\t\t  state->result_tape,\n\t\t\t\t\t\t\t\t\t\t\t  2 * sizeof(unsigned int));\n\t\t\t\tif (nmoved == 0)\n\t\t\t\t\treturn false;\n\t\t\t\telse if (nmoved != 2 * sizeof(unsigned int))\n\t\t\t\t\telog(ERROR, \"unexpected tape position\");\n\t\t\t\tstate->eof_reached = false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Back up and fetch previously-returned tuple's ending length\n\t\t\t\t * word.  If seek fails, assume we are at start of file.\n\t\t\t\t */\n\t\t\t\tnmoved = LogicalTapeBackspace(state->tapeset,\n\t\t\t\t\t\t\t\t\t\t\t  state->result_tape,\n\t\t\t\t\t\t\t\t\t\t\t  sizeof(unsigned int));\n\t\t\t\tif (nmoved == 0)\n\t\t\t\t\treturn false;\n\t\t\t\telse if (nmoved != sizeof(unsigned int))\n\t\t\t\t\telog(ERROR, \"unexpected tape position\");\n\t\t\t\ttuplen = getlen(state, state->result_tape, false);\n\n\t\t\t\t/*\n\t\t\t\t * Back up to get ending length word of tuple before it.\n\t\t\t\t */\n\t\t\t\tnmoved = LogicalTapeBackspace(state->tapeset,\n\t\t\t\t\t\t\t\t\t\t\t  state->result_tape,\n\t\t\t\t\t\t\t\t\t\t\t  tuplen + 2 * sizeof(unsigned int));\n\t\t\t\tif (nmoved == tuplen + sizeof(unsigned int))\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * We backed up over the previous tuple, but there was no\n\t\t\t\t\t * ending length word before it.  That means that the prev\n\t\t\t\t\t * tuple is the first tuple in the file.  It is now the\n\t\t\t\t\t * next to read in forward direction (not obviously right,\n\t\t\t\t\t * but that is what in-memory case does).\n\t\t\t\t\t */\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\telse if (nmoved != tuplen + 2 * sizeof(unsigned int))\n\t\t\t\t\telog(ERROR, \"bogus tuple length in backward scan\");\n\t\t\t}\n\n\t\t\ttuplen = getlen(state, state->result_tape, false);\n\n\t\t\t/*\n\t\t\t * Now we have the length of the prior tuple, back up and read it.\n\t\t\t * Note: READTUP expects we are positioned after the initial\n\t\t\t * length word of the tuple, so back up to that point.\n\t\t\t */\n\t\t\tnmoved = LogicalTapeBackspace(state->tapeset,\n\t\t\t\t\t\t\t\t\t\t  state->result_tape,\n\t\t\t\t\t\t\t\t\t\t  tuplen);\n\t\t\tif (nmoved != tuplen)\n\t\t\t\telog(ERROR, \"bogus tuple length in backward scan\");\n\t\t\tREADTUP(state, stup, state->result_tape, tuplen);\n\n\t\t\t/*\n\t\t\t * Remember the tuple we return, so that we can recycle its memory\n\t\t\t * on next call. (This can be NULL, in the Datum case).\n\t\t\t */\n\t\t\tstate->lastReturnedTuple = stup->tuple;\n\n\t\t\treturn true;\n\n\t\tcase TSS_FINALMERGE:\n\t\t\tAssert(forward);\n\t\t\t/* We are managing memory ourselves, with the slab allocator. */\n\t\t\tAssert(state->slabAllocatorUsed);\n\n\t\t\t/*\n\t\t\t * The slab slot holding the tuple that we returned in previous\n\t\t\t * gettuple call can now be reused.\n\t\t\t */\n\t\t\tif (state->lastReturnedTuple)\n\t\t\t{\n\t\t\t\tRELEASE_SLAB_SLOT(state, state->lastReturnedTuple);\n\t\t\t\tstate->lastReturnedTuple = NULL;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * This code should match the inner loop of mergeonerun().\n\t\t\t */\n\t\t\tif (state->memtupcount > 0)\n\t\t\t{\n\t\t\t\tint\t\t\tsrcTape = state->memtuples[0].tupindex;\n\t\t\t\tSortTuple\tnewtup;\n\n\t\t\t\t*stup = state->memtuples[0];\n\n\t\t\t\t/*\n\t\t\t\t * Remember the tuple we return, so that we can recycle its\n\t\t\t\t * memory on next call. (This can be NULL, in the Datum case).\n\t\t\t\t */\n\t\t\t\tstate->lastReturnedTuple = stup->tuple;\n\n\t\t\t\t/*\n\t\t\t\t * Pull next tuple from tape, and replace the returned tuple\n\t\t\t\t * at top of the heap with it.\n\t\t\t\t */\n\t\t\t\tif (!mergereadnext(state, srcTape, &newtup))\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * If no more data, we've reached end of run on this tape.\n\t\t\t\t\t * Remove the top node from the heap.\n\t\t\t\t\t */\n\t\t\t\t\ttuplesort_heap_delete_top(state);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Rewind to free the read buffer.  It'd go away at the\n\t\t\t\t\t * end of the sort anyway, but better to release the\n\t\t\t\t\t * memory early.\n\t\t\t\t\t */\n\t\t\t\t\tLogicalTapeRewindForWrite(state->tapeset, srcTape);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tnewtup.tupindex = srcTape;\n\t\t\t\ttuplesort_heap_replace_top(state, &newtup);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplesort state\");\n\t\t\treturn false;\t\t/* keep compiler quiet */\n\t}\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);",
            "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static void *readtup_alloc(Tuplesortstate *state, Size tuplen);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);",
            "static void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic void *readtup_alloc(Tuplesortstate *state, Size tuplen);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\nstatic void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);\n\nstatic bool\ntuplesort_gettuple_common(Tuplesortstate *state, bool forward,\n\t\t\t\t\t\t  SortTuple *stup)\n{\n\tunsigned int tuplen;\n\tsize_t\t\tnmoved;\n\n\tAssert(!WORKER(state));\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_SORTEDINMEM:\n\t\t\tAssert(forward || state->randomAccess);\n\t\t\tAssert(!state->slabAllocatorUsed);\n\t\t\tif (forward)\n\t\t\t{\n\t\t\t\tif (state->current < state->memtupcount)\n\t\t\t\t{\n\t\t\t\t\t*stup = state->memtuples[state->current++];\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tstate->eof_reached = true;\n\n\t\t\t\t/*\n\t\t\t\t * Complain if caller tries to retrieve more tuples than\n\t\t\t\t * originally asked for in a bounded sort.  This is because\n\t\t\t\t * returning EOF here might be the wrong thing.\n\t\t\t\t */\n\t\t\t\tif (state->bounded && state->current >= state->bound)\n\t\t\t\t\telog(ERROR, \"retrieved too many tuples in a bounded sort\");\n\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (state->current <= 0)\n\t\t\t\t\treturn false;\n\n\t\t\t\t/*\n\t\t\t\t * if all tuples are fetched already then we return last\n\t\t\t\t * tuple, else - tuple before last returned.\n\t\t\t\t */\n\t\t\t\tif (state->eof_reached)\n\t\t\t\t\tstate->eof_reached = false;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstate->current--;\t/* last returned tuple */\n\t\t\t\t\tif (state->current <= 0)\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t*stup = state->memtuples[state->current - 1];\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TSS_SORTEDONTAPE:\n\t\t\tAssert(forward || state->randomAccess);\n\t\t\tAssert(state->slabAllocatorUsed);\n\n\t\t\t/*\n\t\t\t * The slot that held the tuple that we returned in previous\n\t\t\t * gettuple call can now be reused.\n\t\t\t */\n\t\t\tif (state->lastReturnedTuple)\n\t\t\t{\n\t\t\t\tRELEASE_SLAB_SLOT(state, state->lastReturnedTuple);\n\t\t\t\tstate->lastReturnedTuple = NULL;\n\t\t\t}\n\n\t\t\tif (forward)\n\t\t\t{\n\t\t\t\tif (state->eof_reached)\n\t\t\t\t\treturn false;\n\n\t\t\t\tif ((tuplen = getlen(state, state->result_tape, true)) != 0)\n\t\t\t\t{\n\t\t\t\t\tREADTUP(state, stup, state->result_tape, tuplen);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Remember the tuple we return, so that we can recycle\n\t\t\t\t\t * its memory on next call.  (This can be NULL, in the\n\t\t\t\t\t * !state->tuples case).\n\t\t\t\t\t */\n\t\t\t\t\tstate->lastReturnedTuple = stup->tuple;\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstate->eof_reached = true;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Backward.\n\t\t\t *\n\t\t\t * if all tuples are fetched already then we return last tuple,\n\t\t\t * else - tuple before last returned.\n\t\t\t */\n\t\t\tif (state->eof_reached)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Seek position is pointing just past the zero tuplen at the\n\t\t\t\t * end of file; back up to fetch last tuple's ending length\n\t\t\t\t * word.  If seek fails we must have a completely empty file.\n\t\t\t\t */\n\t\t\t\tnmoved = LogicalTapeBackspace(state->tapeset,\n\t\t\t\t\t\t\t\t\t\t\t  state->result_tape,\n\t\t\t\t\t\t\t\t\t\t\t  2 * sizeof(unsigned int));\n\t\t\t\tif (nmoved == 0)\n\t\t\t\t\treturn false;\n\t\t\t\telse if (nmoved != 2 * sizeof(unsigned int))\n\t\t\t\t\telog(ERROR, \"unexpected tape position\");\n\t\t\t\tstate->eof_reached = false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Back up and fetch previously-returned tuple's ending length\n\t\t\t\t * word.  If seek fails, assume we are at start of file.\n\t\t\t\t */\n\t\t\t\tnmoved = LogicalTapeBackspace(state->tapeset,\n\t\t\t\t\t\t\t\t\t\t\t  state->result_tape,\n\t\t\t\t\t\t\t\t\t\t\t  sizeof(unsigned int));\n\t\t\t\tif (nmoved == 0)\n\t\t\t\t\treturn false;\n\t\t\t\telse if (nmoved != sizeof(unsigned int))\n\t\t\t\t\telog(ERROR, \"unexpected tape position\");\n\t\t\t\ttuplen = getlen(state, state->result_tape, false);\n\n\t\t\t\t/*\n\t\t\t\t * Back up to get ending length word of tuple before it.\n\t\t\t\t */\n\t\t\t\tnmoved = LogicalTapeBackspace(state->tapeset,\n\t\t\t\t\t\t\t\t\t\t\t  state->result_tape,\n\t\t\t\t\t\t\t\t\t\t\t  tuplen + 2 * sizeof(unsigned int));\n\t\t\t\tif (nmoved == tuplen + sizeof(unsigned int))\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * We backed up over the previous tuple, but there was no\n\t\t\t\t\t * ending length word before it.  That means that the prev\n\t\t\t\t\t * tuple is the first tuple in the file.  It is now the\n\t\t\t\t\t * next to read in forward direction (not obviously right,\n\t\t\t\t\t * but that is what in-memory case does).\n\t\t\t\t\t */\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\telse if (nmoved != tuplen + 2 * sizeof(unsigned int))\n\t\t\t\t\telog(ERROR, \"bogus tuple length in backward scan\");\n\t\t\t}\n\n\t\t\ttuplen = getlen(state, state->result_tape, false);\n\n\t\t\t/*\n\t\t\t * Now we have the length of the prior tuple, back up and read it.\n\t\t\t * Note: READTUP expects we are positioned after the initial\n\t\t\t * length word of the tuple, so back up to that point.\n\t\t\t */\n\t\t\tnmoved = LogicalTapeBackspace(state->tapeset,\n\t\t\t\t\t\t\t\t\t\t  state->result_tape,\n\t\t\t\t\t\t\t\t\t\t  tuplen);\n\t\t\tif (nmoved != tuplen)\n\t\t\t\telog(ERROR, \"bogus tuple length in backward scan\");\n\t\t\tREADTUP(state, stup, state->result_tape, tuplen);\n\n\t\t\t/*\n\t\t\t * Remember the tuple we return, so that we can recycle its memory\n\t\t\t * on next call. (This can be NULL, in the Datum case).\n\t\t\t */\n\t\t\tstate->lastReturnedTuple = stup->tuple;\n\n\t\t\treturn true;\n\n\t\tcase TSS_FINALMERGE:\n\t\t\tAssert(forward);\n\t\t\t/* We are managing memory ourselves, with the slab allocator. */\n\t\t\tAssert(state->slabAllocatorUsed);\n\n\t\t\t/*\n\t\t\t * The slab slot holding the tuple that we returned in previous\n\t\t\t * gettuple call can now be reused.\n\t\t\t */\n\t\t\tif (state->lastReturnedTuple)\n\t\t\t{\n\t\t\t\tRELEASE_SLAB_SLOT(state, state->lastReturnedTuple);\n\t\t\t\tstate->lastReturnedTuple = NULL;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * This code should match the inner loop of mergeonerun().\n\t\t\t */\n\t\t\tif (state->memtupcount > 0)\n\t\t\t{\n\t\t\t\tint\t\t\tsrcTape = state->memtuples[0].tupindex;\n\t\t\t\tSortTuple\tnewtup;\n\n\t\t\t\t*stup = state->memtuples[0];\n\n\t\t\t\t/*\n\t\t\t\t * Remember the tuple we return, so that we can recycle its\n\t\t\t\t * memory on next call. (This can be NULL, in the Datum case).\n\t\t\t\t */\n\t\t\t\tstate->lastReturnedTuple = stup->tuple;\n\n\t\t\t\t/*\n\t\t\t\t * Pull next tuple from tape, and replace the returned tuple\n\t\t\t\t * at top of the heap with it.\n\t\t\t\t */\n\t\t\t\tif (!mergereadnext(state, srcTape, &newtup))\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * If no more data, we've reached end of run on this tape.\n\t\t\t\t\t * Remove the top node from the heap.\n\t\t\t\t\t */\n\t\t\t\t\ttuplesort_heap_delete_top(state);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Rewind to free the read buffer.  It'd go away at the\n\t\t\t\t\t * end of the sort anyway, but better to release the\n\t\t\t\t\t * memory early.\n\t\t\t\t\t */\n\t\t\t\t\tLogicalTapeRewindForWrite(state->tapeset, srcTape);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tnewtup.tupindex = srcTape;\n\t\t\t\ttuplesort_heap_replace_top(state, &newtup);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplesort state\");\n\t\t\treturn false;\t\t/* keep compiler quiet */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "state->sortcontext"
          ],
          "line": 2247
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\nstatic void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);\n\nbool\ntuplesort_getdatum(Tuplesortstate *state, bool forward,\n\t\t\t\t   Datum *val, bool *isNull, Datum *abbrev)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\tSortTuple\tstup;\n\n\tif (!tuplesort_gettuple_common(state, forward, &stup))\n\t{\n\t\tMemoryContextSwitchTo(oldcontext);\n\t\treturn false;\n\t}\n\n\t/* Ensure we copy into caller's memory context */\n\tMemoryContextSwitchTo(oldcontext);\n\n\t/* Record abbreviated key for caller */\n\tif (state->sortKeys->abbrev_converter && abbrev)\n\t\t*abbrev = stup.datum1;\n\n\tif (stup.isnull1 || !state->tuples)\n\t{\n\t\t*val = stup.datum1;\n\t\t*isNull = stup.isnull1;\n\t}\n\telse\n\t{\n\t\t/* use stup.tuple because stup.datum1 may be an abbreviation */\n\t\t*val = datumCopy(PointerGetDatum(stup.tuple), false, state->datumTypeLen);\n\t\t*isNull = false;\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "tuplesort_getindextuple",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "2214-2226",
    "snippet": "IndexTuple\ntuplesort_getindextuple(Tuplesortstate *state, bool forward)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\tSortTuple\tstup;\n\n\tif (!tuplesort_gettuple_common(state, forward, &stup))\n\t\tstup.tuple = NULL;\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn (IndexTuple) stup.tuple;\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);",
      "static void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 2223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tuplesort_gettuple_common",
          "args": [
            "state",
            "forward",
            "&stup"
          ],
          "line": 2220
        },
        "resolved": true,
        "details": {
          "function_name": "tuplesort_gettuple_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "1900-2135",
          "snippet": "static bool\ntuplesort_gettuple_common(Tuplesortstate *state, bool forward,\n\t\t\t\t\t\t  SortTuple *stup)\n{\n\tunsigned int tuplen;\n\tsize_t\t\tnmoved;\n\n\tAssert(!WORKER(state));\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_SORTEDINMEM:\n\t\t\tAssert(forward || state->randomAccess);\n\t\t\tAssert(!state->slabAllocatorUsed);\n\t\t\tif (forward)\n\t\t\t{\n\t\t\t\tif (state->current < state->memtupcount)\n\t\t\t\t{\n\t\t\t\t\t*stup = state->memtuples[state->current++];\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tstate->eof_reached = true;\n\n\t\t\t\t/*\n\t\t\t\t * Complain if caller tries to retrieve more tuples than\n\t\t\t\t * originally asked for in a bounded sort.  This is because\n\t\t\t\t * returning EOF here might be the wrong thing.\n\t\t\t\t */\n\t\t\t\tif (state->bounded && state->current >= state->bound)\n\t\t\t\t\telog(ERROR, \"retrieved too many tuples in a bounded sort\");\n\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (state->current <= 0)\n\t\t\t\t\treturn false;\n\n\t\t\t\t/*\n\t\t\t\t * if all tuples are fetched already then we return last\n\t\t\t\t * tuple, else - tuple before last returned.\n\t\t\t\t */\n\t\t\t\tif (state->eof_reached)\n\t\t\t\t\tstate->eof_reached = false;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstate->current--;\t/* last returned tuple */\n\t\t\t\t\tif (state->current <= 0)\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t*stup = state->memtuples[state->current - 1];\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TSS_SORTEDONTAPE:\n\t\t\tAssert(forward || state->randomAccess);\n\t\t\tAssert(state->slabAllocatorUsed);\n\n\t\t\t/*\n\t\t\t * The slot that held the tuple that we returned in previous\n\t\t\t * gettuple call can now be reused.\n\t\t\t */\n\t\t\tif (state->lastReturnedTuple)\n\t\t\t{\n\t\t\t\tRELEASE_SLAB_SLOT(state, state->lastReturnedTuple);\n\t\t\t\tstate->lastReturnedTuple = NULL;\n\t\t\t}\n\n\t\t\tif (forward)\n\t\t\t{\n\t\t\t\tif (state->eof_reached)\n\t\t\t\t\treturn false;\n\n\t\t\t\tif ((tuplen = getlen(state, state->result_tape, true)) != 0)\n\t\t\t\t{\n\t\t\t\t\tREADTUP(state, stup, state->result_tape, tuplen);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Remember the tuple we return, so that we can recycle\n\t\t\t\t\t * its memory on next call.  (This can be NULL, in the\n\t\t\t\t\t * !state->tuples case).\n\t\t\t\t\t */\n\t\t\t\t\tstate->lastReturnedTuple = stup->tuple;\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstate->eof_reached = true;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Backward.\n\t\t\t *\n\t\t\t * if all tuples are fetched already then we return last tuple,\n\t\t\t * else - tuple before last returned.\n\t\t\t */\n\t\t\tif (state->eof_reached)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Seek position is pointing just past the zero tuplen at the\n\t\t\t\t * end of file; back up to fetch last tuple's ending length\n\t\t\t\t * word.  If seek fails we must have a completely empty file.\n\t\t\t\t */\n\t\t\t\tnmoved = LogicalTapeBackspace(state->tapeset,\n\t\t\t\t\t\t\t\t\t\t\t  state->result_tape,\n\t\t\t\t\t\t\t\t\t\t\t  2 * sizeof(unsigned int));\n\t\t\t\tif (nmoved == 0)\n\t\t\t\t\treturn false;\n\t\t\t\telse if (nmoved != 2 * sizeof(unsigned int))\n\t\t\t\t\telog(ERROR, \"unexpected tape position\");\n\t\t\t\tstate->eof_reached = false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Back up and fetch previously-returned tuple's ending length\n\t\t\t\t * word.  If seek fails, assume we are at start of file.\n\t\t\t\t */\n\t\t\t\tnmoved = LogicalTapeBackspace(state->tapeset,\n\t\t\t\t\t\t\t\t\t\t\t  state->result_tape,\n\t\t\t\t\t\t\t\t\t\t\t  sizeof(unsigned int));\n\t\t\t\tif (nmoved == 0)\n\t\t\t\t\treturn false;\n\t\t\t\telse if (nmoved != sizeof(unsigned int))\n\t\t\t\t\telog(ERROR, \"unexpected tape position\");\n\t\t\t\ttuplen = getlen(state, state->result_tape, false);\n\n\t\t\t\t/*\n\t\t\t\t * Back up to get ending length word of tuple before it.\n\t\t\t\t */\n\t\t\t\tnmoved = LogicalTapeBackspace(state->tapeset,\n\t\t\t\t\t\t\t\t\t\t\t  state->result_tape,\n\t\t\t\t\t\t\t\t\t\t\t  tuplen + 2 * sizeof(unsigned int));\n\t\t\t\tif (nmoved == tuplen + sizeof(unsigned int))\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * We backed up over the previous tuple, but there was no\n\t\t\t\t\t * ending length word before it.  That means that the prev\n\t\t\t\t\t * tuple is the first tuple in the file.  It is now the\n\t\t\t\t\t * next to read in forward direction (not obviously right,\n\t\t\t\t\t * but that is what in-memory case does).\n\t\t\t\t\t */\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\telse if (nmoved != tuplen + 2 * sizeof(unsigned int))\n\t\t\t\t\telog(ERROR, \"bogus tuple length in backward scan\");\n\t\t\t}\n\n\t\t\ttuplen = getlen(state, state->result_tape, false);\n\n\t\t\t/*\n\t\t\t * Now we have the length of the prior tuple, back up and read it.\n\t\t\t * Note: READTUP expects we are positioned after the initial\n\t\t\t * length word of the tuple, so back up to that point.\n\t\t\t */\n\t\t\tnmoved = LogicalTapeBackspace(state->tapeset,\n\t\t\t\t\t\t\t\t\t\t  state->result_tape,\n\t\t\t\t\t\t\t\t\t\t  tuplen);\n\t\t\tif (nmoved != tuplen)\n\t\t\t\telog(ERROR, \"bogus tuple length in backward scan\");\n\t\t\tREADTUP(state, stup, state->result_tape, tuplen);\n\n\t\t\t/*\n\t\t\t * Remember the tuple we return, so that we can recycle its memory\n\t\t\t * on next call. (This can be NULL, in the Datum case).\n\t\t\t */\n\t\t\tstate->lastReturnedTuple = stup->tuple;\n\n\t\t\treturn true;\n\n\t\tcase TSS_FINALMERGE:\n\t\t\tAssert(forward);\n\t\t\t/* We are managing memory ourselves, with the slab allocator. */\n\t\t\tAssert(state->slabAllocatorUsed);\n\n\t\t\t/*\n\t\t\t * The slab slot holding the tuple that we returned in previous\n\t\t\t * gettuple call can now be reused.\n\t\t\t */\n\t\t\tif (state->lastReturnedTuple)\n\t\t\t{\n\t\t\t\tRELEASE_SLAB_SLOT(state, state->lastReturnedTuple);\n\t\t\t\tstate->lastReturnedTuple = NULL;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * This code should match the inner loop of mergeonerun().\n\t\t\t */\n\t\t\tif (state->memtupcount > 0)\n\t\t\t{\n\t\t\t\tint\t\t\tsrcTape = state->memtuples[0].tupindex;\n\t\t\t\tSortTuple\tnewtup;\n\n\t\t\t\t*stup = state->memtuples[0];\n\n\t\t\t\t/*\n\t\t\t\t * Remember the tuple we return, so that we can recycle its\n\t\t\t\t * memory on next call. (This can be NULL, in the Datum case).\n\t\t\t\t */\n\t\t\t\tstate->lastReturnedTuple = stup->tuple;\n\n\t\t\t\t/*\n\t\t\t\t * Pull next tuple from tape, and replace the returned tuple\n\t\t\t\t * at top of the heap with it.\n\t\t\t\t */\n\t\t\t\tif (!mergereadnext(state, srcTape, &newtup))\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * If no more data, we've reached end of run on this tape.\n\t\t\t\t\t * Remove the top node from the heap.\n\t\t\t\t\t */\n\t\t\t\t\ttuplesort_heap_delete_top(state);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Rewind to free the read buffer.  It'd go away at the\n\t\t\t\t\t * end of the sort anyway, but better to release the\n\t\t\t\t\t * memory early.\n\t\t\t\t\t */\n\t\t\t\t\tLogicalTapeRewindForWrite(state->tapeset, srcTape);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tnewtup.tupindex = srcTape;\n\t\t\t\ttuplesort_heap_replace_top(state, &newtup);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplesort state\");\n\t\t\treturn false;\t\t/* keep compiler quiet */\n\t}\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);",
            "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static void *readtup_alloc(Tuplesortstate *state, Size tuplen);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);",
            "static void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic void *readtup_alloc(Tuplesortstate *state, Size tuplen);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\nstatic void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);\n\nstatic bool\ntuplesort_gettuple_common(Tuplesortstate *state, bool forward,\n\t\t\t\t\t\t  SortTuple *stup)\n{\n\tunsigned int tuplen;\n\tsize_t\t\tnmoved;\n\n\tAssert(!WORKER(state));\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_SORTEDINMEM:\n\t\t\tAssert(forward || state->randomAccess);\n\t\t\tAssert(!state->slabAllocatorUsed);\n\t\t\tif (forward)\n\t\t\t{\n\t\t\t\tif (state->current < state->memtupcount)\n\t\t\t\t{\n\t\t\t\t\t*stup = state->memtuples[state->current++];\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tstate->eof_reached = true;\n\n\t\t\t\t/*\n\t\t\t\t * Complain if caller tries to retrieve more tuples than\n\t\t\t\t * originally asked for in a bounded sort.  This is because\n\t\t\t\t * returning EOF here might be the wrong thing.\n\t\t\t\t */\n\t\t\t\tif (state->bounded && state->current >= state->bound)\n\t\t\t\t\telog(ERROR, \"retrieved too many tuples in a bounded sort\");\n\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (state->current <= 0)\n\t\t\t\t\treturn false;\n\n\t\t\t\t/*\n\t\t\t\t * if all tuples are fetched already then we return last\n\t\t\t\t * tuple, else - tuple before last returned.\n\t\t\t\t */\n\t\t\t\tif (state->eof_reached)\n\t\t\t\t\tstate->eof_reached = false;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstate->current--;\t/* last returned tuple */\n\t\t\t\t\tif (state->current <= 0)\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t*stup = state->memtuples[state->current - 1];\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TSS_SORTEDONTAPE:\n\t\t\tAssert(forward || state->randomAccess);\n\t\t\tAssert(state->slabAllocatorUsed);\n\n\t\t\t/*\n\t\t\t * The slot that held the tuple that we returned in previous\n\t\t\t * gettuple call can now be reused.\n\t\t\t */\n\t\t\tif (state->lastReturnedTuple)\n\t\t\t{\n\t\t\t\tRELEASE_SLAB_SLOT(state, state->lastReturnedTuple);\n\t\t\t\tstate->lastReturnedTuple = NULL;\n\t\t\t}\n\n\t\t\tif (forward)\n\t\t\t{\n\t\t\t\tif (state->eof_reached)\n\t\t\t\t\treturn false;\n\n\t\t\t\tif ((tuplen = getlen(state, state->result_tape, true)) != 0)\n\t\t\t\t{\n\t\t\t\t\tREADTUP(state, stup, state->result_tape, tuplen);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Remember the tuple we return, so that we can recycle\n\t\t\t\t\t * its memory on next call.  (This can be NULL, in the\n\t\t\t\t\t * !state->tuples case).\n\t\t\t\t\t */\n\t\t\t\t\tstate->lastReturnedTuple = stup->tuple;\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstate->eof_reached = true;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Backward.\n\t\t\t *\n\t\t\t * if all tuples are fetched already then we return last tuple,\n\t\t\t * else - tuple before last returned.\n\t\t\t */\n\t\t\tif (state->eof_reached)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Seek position is pointing just past the zero tuplen at the\n\t\t\t\t * end of file; back up to fetch last tuple's ending length\n\t\t\t\t * word.  If seek fails we must have a completely empty file.\n\t\t\t\t */\n\t\t\t\tnmoved = LogicalTapeBackspace(state->tapeset,\n\t\t\t\t\t\t\t\t\t\t\t  state->result_tape,\n\t\t\t\t\t\t\t\t\t\t\t  2 * sizeof(unsigned int));\n\t\t\t\tif (nmoved == 0)\n\t\t\t\t\treturn false;\n\t\t\t\telse if (nmoved != 2 * sizeof(unsigned int))\n\t\t\t\t\telog(ERROR, \"unexpected tape position\");\n\t\t\t\tstate->eof_reached = false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Back up and fetch previously-returned tuple's ending length\n\t\t\t\t * word.  If seek fails, assume we are at start of file.\n\t\t\t\t */\n\t\t\t\tnmoved = LogicalTapeBackspace(state->tapeset,\n\t\t\t\t\t\t\t\t\t\t\t  state->result_tape,\n\t\t\t\t\t\t\t\t\t\t\t  sizeof(unsigned int));\n\t\t\t\tif (nmoved == 0)\n\t\t\t\t\treturn false;\n\t\t\t\telse if (nmoved != sizeof(unsigned int))\n\t\t\t\t\telog(ERROR, \"unexpected tape position\");\n\t\t\t\ttuplen = getlen(state, state->result_tape, false);\n\n\t\t\t\t/*\n\t\t\t\t * Back up to get ending length word of tuple before it.\n\t\t\t\t */\n\t\t\t\tnmoved = LogicalTapeBackspace(state->tapeset,\n\t\t\t\t\t\t\t\t\t\t\t  state->result_tape,\n\t\t\t\t\t\t\t\t\t\t\t  tuplen + 2 * sizeof(unsigned int));\n\t\t\t\tif (nmoved == tuplen + sizeof(unsigned int))\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * We backed up over the previous tuple, but there was no\n\t\t\t\t\t * ending length word before it.  That means that the prev\n\t\t\t\t\t * tuple is the first tuple in the file.  It is now the\n\t\t\t\t\t * next to read in forward direction (not obviously right,\n\t\t\t\t\t * but that is what in-memory case does).\n\t\t\t\t\t */\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\telse if (nmoved != tuplen + 2 * sizeof(unsigned int))\n\t\t\t\t\telog(ERROR, \"bogus tuple length in backward scan\");\n\t\t\t}\n\n\t\t\ttuplen = getlen(state, state->result_tape, false);\n\n\t\t\t/*\n\t\t\t * Now we have the length of the prior tuple, back up and read it.\n\t\t\t * Note: READTUP expects we are positioned after the initial\n\t\t\t * length word of the tuple, so back up to that point.\n\t\t\t */\n\t\t\tnmoved = LogicalTapeBackspace(state->tapeset,\n\t\t\t\t\t\t\t\t\t\t  state->result_tape,\n\t\t\t\t\t\t\t\t\t\t  tuplen);\n\t\t\tif (nmoved != tuplen)\n\t\t\t\telog(ERROR, \"bogus tuple length in backward scan\");\n\t\t\tREADTUP(state, stup, state->result_tape, tuplen);\n\n\t\t\t/*\n\t\t\t * Remember the tuple we return, so that we can recycle its memory\n\t\t\t * on next call. (This can be NULL, in the Datum case).\n\t\t\t */\n\t\t\tstate->lastReturnedTuple = stup->tuple;\n\n\t\t\treturn true;\n\n\t\tcase TSS_FINALMERGE:\n\t\t\tAssert(forward);\n\t\t\t/* We are managing memory ourselves, with the slab allocator. */\n\t\t\tAssert(state->slabAllocatorUsed);\n\n\t\t\t/*\n\t\t\t * The slab slot holding the tuple that we returned in previous\n\t\t\t * gettuple call can now be reused.\n\t\t\t */\n\t\t\tif (state->lastReturnedTuple)\n\t\t\t{\n\t\t\t\tRELEASE_SLAB_SLOT(state, state->lastReturnedTuple);\n\t\t\t\tstate->lastReturnedTuple = NULL;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * This code should match the inner loop of mergeonerun().\n\t\t\t */\n\t\t\tif (state->memtupcount > 0)\n\t\t\t{\n\t\t\t\tint\t\t\tsrcTape = state->memtuples[0].tupindex;\n\t\t\t\tSortTuple\tnewtup;\n\n\t\t\t\t*stup = state->memtuples[0];\n\n\t\t\t\t/*\n\t\t\t\t * Remember the tuple we return, so that we can recycle its\n\t\t\t\t * memory on next call. (This can be NULL, in the Datum case).\n\t\t\t\t */\n\t\t\t\tstate->lastReturnedTuple = stup->tuple;\n\n\t\t\t\t/*\n\t\t\t\t * Pull next tuple from tape, and replace the returned tuple\n\t\t\t\t * at top of the heap with it.\n\t\t\t\t */\n\t\t\t\tif (!mergereadnext(state, srcTape, &newtup))\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * If no more data, we've reached end of run on this tape.\n\t\t\t\t\t * Remove the top node from the heap.\n\t\t\t\t\t */\n\t\t\t\t\ttuplesort_heap_delete_top(state);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Rewind to free the read buffer.  It'd go away at the\n\t\t\t\t\t * end of the sort anyway, but better to release the\n\t\t\t\t\t * memory early.\n\t\t\t\t\t */\n\t\t\t\t\tLogicalTapeRewindForWrite(state->tapeset, srcTape);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tnewtup.tupindex = srcTape;\n\t\t\t\ttuplesort_heap_replace_top(state, &newtup);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplesort state\");\n\t\t\treturn false;\t\t/* keep compiler quiet */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "state->sortcontext"
          ],
          "line": 2217
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\nstatic void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);\n\nIndexTuple\ntuplesort_getindextuple(Tuplesortstate *state, bool forward)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\tSortTuple\tstup;\n\n\tif (!tuplesort_gettuple_common(state, forward, &stup))\n\t\tstup.tuple = NULL;\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn (IndexTuple) stup.tuple;\n}"
  },
  {
    "function_name": "tuplesort_getheaptuple",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "2194-2206",
    "snippet": "HeapTuple\ntuplesort_getheaptuple(Tuplesortstate *state, bool forward)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\tSortTuple\tstup;\n\n\tif (!tuplesort_gettuple_common(state, forward, &stup))\n\t\tstup.tuple = NULL;\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn stup.tuple;\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);",
      "static void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 2203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tuplesort_gettuple_common",
          "args": [
            "state",
            "forward",
            "&stup"
          ],
          "line": 2200
        },
        "resolved": true,
        "details": {
          "function_name": "tuplesort_gettuple_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "1900-2135",
          "snippet": "static bool\ntuplesort_gettuple_common(Tuplesortstate *state, bool forward,\n\t\t\t\t\t\t  SortTuple *stup)\n{\n\tunsigned int tuplen;\n\tsize_t\t\tnmoved;\n\n\tAssert(!WORKER(state));\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_SORTEDINMEM:\n\t\t\tAssert(forward || state->randomAccess);\n\t\t\tAssert(!state->slabAllocatorUsed);\n\t\t\tif (forward)\n\t\t\t{\n\t\t\t\tif (state->current < state->memtupcount)\n\t\t\t\t{\n\t\t\t\t\t*stup = state->memtuples[state->current++];\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tstate->eof_reached = true;\n\n\t\t\t\t/*\n\t\t\t\t * Complain if caller tries to retrieve more tuples than\n\t\t\t\t * originally asked for in a bounded sort.  This is because\n\t\t\t\t * returning EOF here might be the wrong thing.\n\t\t\t\t */\n\t\t\t\tif (state->bounded && state->current >= state->bound)\n\t\t\t\t\telog(ERROR, \"retrieved too many tuples in a bounded sort\");\n\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (state->current <= 0)\n\t\t\t\t\treturn false;\n\n\t\t\t\t/*\n\t\t\t\t * if all tuples are fetched already then we return last\n\t\t\t\t * tuple, else - tuple before last returned.\n\t\t\t\t */\n\t\t\t\tif (state->eof_reached)\n\t\t\t\t\tstate->eof_reached = false;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstate->current--;\t/* last returned tuple */\n\t\t\t\t\tif (state->current <= 0)\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t*stup = state->memtuples[state->current - 1];\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TSS_SORTEDONTAPE:\n\t\t\tAssert(forward || state->randomAccess);\n\t\t\tAssert(state->slabAllocatorUsed);\n\n\t\t\t/*\n\t\t\t * The slot that held the tuple that we returned in previous\n\t\t\t * gettuple call can now be reused.\n\t\t\t */\n\t\t\tif (state->lastReturnedTuple)\n\t\t\t{\n\t\t\t\tRELEASE_SLAB_SLOT(state, state->lastReturnedTuple);\n\t\t\t\tstate->lastReturnedTuple = NULL;\n\t\t\t}\n\n\t\t\tif (forward)\n\t\t\t{\n\t\t\t\tif (state->eof_reached)\n\t\t\t\t\treturn false;\n\n\t\t\t\tif ((tuplen = getlen(state, state->result_tape, true)) != 0)\n\t\t\t\t{\n\t\t\t\t\tREADTUP(state, stup, state->result_tape, tuplen);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Remember the tuple we return, so that we can recycle\n\t\t\t\t\t * its memory on next call.  (This can be NULL, in the\n\t\t\t\t\t * !state->tuples case).\n\t\t\t\t\t */\n\t\t\t\t\tstate->lastReturnedTuple = stup->tuple;\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstate->eof_reached = true;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Backward.\n\t\t\t *\n\t\t\t * if all tuples are fetched already then we return last tuple,\n\t\t\t * else - tuple before last returned.\n\t\t\t */\n\t\t\tif (state->eof_reached)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Seek position is pointing just past the zero tuplen at the\n\t\t\t\t * end of file; back up to fetch last tuple's ending length\n\t\t\t\t * word.  If seek fails we must have a completely empty file.\n\t\t\t\t */\n\t\t\t\tnmoved = LogicalTapeBackspace(state->tapeset,\n\t\t\t\t\t\t\t\t\t\t\t  state->result_tape,\n\t\t\t\t\t\t\t\t\t\t\t  2 * sizeof(unsigned int));\n\t\t\t\tif (nmoved == 0)\n\t\t\t\t\treturn false;\n\t\t\t\telse if (nmoved != 2 * sizeof(unsigned int))\n\t\t\t\t\telog(ERROR, \"unexpected tape position\");\n\t\t\t\tstate->eof_reached = false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Back up and fetch previously-returned tuple's ending length\n\t\t\t\t * word.  If seek fails, assume we are at start of file.\n\t\t\t\t */\n\t\t\t\tnmoved = LogicalTapeBackspace(state->tapeset,\n\t\t\t\t\t\t\t\t\t\t\t  state->result_tape,\n\t\t\t\t\t\t\t\t\t\t\t  sizeof(unsigned int));\n\t\t\t\tif (nmoved == 0)\n\t\t\t\t\treturn false;\n\t\t\t\telse if (nmoved != sizeof(unsigned int))\n\t\t\t\t\telog(ERROR, \"unexpected tape position\");\n\t\t\t\ttuplen = getlen(state, state->result_tape, false);\n\n\t\t\t\t/*\n\t\t\t\t * Back up to get ending length word of tuple before it.\n\t\t\t\t */\n\t\t\t\tnmoved = LogicalTapeBackspace(state->tapeset,\n\t\t\t\t\t\t\t\t\t\t\t  state->result_tape,\n\t\t\t\t\t\t\t\t\t\t\t  tuplen + 2 * sizeof(unsigned int));\n\t\t\t\tif (nmoved == tuplen + sizeof(unsigned int))\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * We backed up over the previous tuple, but there was no\n\t\t\t\t\t * ending length word before it.  That means that the prev\n\t\t\t\t\t * tuple is the first tuple in the file.  It is now the\n\t\t\t\t\t * next to read in forward direction (not obviously right,\n\t\t\t\t\t * but that is what in-memory case does).\n\t\t\t\t\t */\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\telse if (nmoved != tuplen + 2 * sizeof(unsigned int))\n\t\t\t\t\telog(ERROR, \"bogus tuple length in backward scan\");\n\t\t\t}\n\n\t\t\ttuplen = getlen(state, state->result_tape, false);\n\n\t\t\t/*\n\t\t\t * Now we have the length of the prior tuple, back up and read it.\n\t\t\t * Note: READTUP expects we are positioned after the initial\n\t\t\t * length word of the tuple, so back up to that point.\n\t\t\t */\n\t\t\tnmoved = LogicalTapeBackspace(state->tapeset,\n\t\t\t\t\t\t\t\t\t\t  state->result_tape,\n\t\t\t\t\t\t\t\t\t\t  tuplen);\n\t\t\tif (nmoved != tuplen)\n\t\t\t\telog(ERROR, \"bogus tuple length in backward scan\");\n\t\t\tREADTUP(state, stup, state->result_tape, tuplen);\n\n\t\t\t/*\n\t\t\t * Remember the tuple we return, so that we can recycle its memory\n\t\t\t * on next call. (This can be NULL, in the Datum case).\n\t\t\t */\n\t\t\tstate->lastReturnedTuple = stup->tuple;\n\n\t\t\treturn true;\n\n\t\tcase TSS_FINALMERGE:\n\t\t\tAssert(forward);\n\t\t\t/* We are managing memory ourselves, with the slab allocator. */\n\t\t\tAssert(state->slabAllocatorUsed);\n\n\t\t\t/*\n\t\t\t * The slab slot holding the tuple that we returned in previous\n\t\t\t * gettuple call can now be reused.\n\t\t\t */\n\t\t\tif (state->lastReturnedTuple)\n\t\t\t{\n\t\t\t\tRELEASE_SLAB_SLOT(state, state->lastReturnedTuple);\n\t\t\t\tstate->lastReturnedTuple = NULL;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * This code should match the inner loop of mergeonerun().\n\t\t\t */\n\t\t\tif (state->memtupcount > 0)\n\t\t\t{\n\t\t\t\tint\t\t\tsrcTape = state->memtuples[0].tupindex;\n\t\t\t\tSortTuple\tnewtup;\n\n\t\t\t\t*stup = state->memtuples[0];\n\n\t\t\t\t/*\n\t\t\t\t * Remember the tuple we return, so that we can recycle its\n\t\t\t\t * memory on next call. (This can be NULL, in the Datum case).\n\t\t\t\t */\n\t\t\t\tstate->lastReturnedTuple = stup->tuple;\n\n\t\t\t\t/*\n\t\t\t\t * Pull next tuple from tape, and replace the returned tuple\n\t\t\t\t * at top of the heap with it.\n\t\t\t\t */\n\t\t\t\tif (!mergereadnext(state, srcTape, &newtup))\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * If no more data, we've reached end of run on this tape.\n\t\t\t\t\t * Remove the top node from the heap.\n\t\t\t\t\t */\n\t\t\t\t\ttuplesort_heap_delete_top(state);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Rewind to free the read buffer.  It'd go away at the\n\t\t\t\t\t * end of the sort anyway, but better to release the\n\t\t\t\t\t * memory early.\n\t\t\t\t\t */\n\t\t\t\t\tLogicalTapeRewindForWrite(state->tapeset, srcTape);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tnewtup.tupindex = srcTape;\n\t\t\t\ttuplesort_heap_replace_top(state, &newtup);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplesort state\");\n\t\t\treturn false;\t\t/* keep compiler quiet */\n\t}\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);",
            "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static void *readtup_alloc(Tuplesortstate *state, Size tuplen);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);",
            "static void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic void *readtup_alloc(Tuplesortstate *state, Size tuplen);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\nstatic void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);\n\nstatic bool\ntuplesort_gettuple_common(Tuplesortstate *state, bool forward,\n\t\t\t\t\t\t  SortTuple *stup)\n{\n\tunsigned int tuplen;\n\tsize_t\t\tnmoved;\n\n\tAssert(!WORKER(state));\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_SORTEDINMEM:\n\t\t\tAssert(forward || state->randomAccess);\n\t\t\tAssert(!state->slabAllocatorUsed);\n\t\t\tif (forward)\n\t\t\t{\n\t\t\t\tif (state->current < state->memtupcount)\n\t\t\t\t{\n\t\t\t\t\t*stup = state->memtuples[state->current++];\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tstate->eof_reached = true;\n\n\t\t\t\t/*\n\t\t\t\t * Complain if caller tries to retrieve more tuples than\n\t\t\t\t * originally asked for in a bounded sort.  This is because\n\t\t\t\t * returning EOF here might be the wrong thing.\n\t\t\t\t */\n\t\t\t\tif (state->bounded && state->current >= state->bound)\n\t\t\t\t\telog(ERROR, \"retrieved too many tuples in a bounded sort\");\n\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (state->current <= 0)\n\t\t\t\t\treturn false;\n\n\t\t\t\t/*\n\t\t\t\t * if all tuples are fetched already then we return last\n\t\t\t\t * tuple, else - tuple before last returned.\n\t\t\t\t */\n\t\t\t\tif (state->eof_reached)\n\t\t\t\t\tstate->eof_reached = false;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstate->current--;\t/* last returned tuple */\n\t\t\t\t\tif (state->current <= 0)\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t*stup = state->memtuples[state->current - 1];\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TSS_SORTEDONTAPE:\n\t\t\tAssert(forward || state->randomAccess);\n\t\t\tAssert(state->slabAllocatorUsed);\n\n\t\t\t/*\n\t\t\t * The slot that held the tuple that we returned in previous\n\t\t\t * gettuple call can now be reused.\n\t\t\t */\n\t\t\tif (state->lastReturnedTuple)\n\t\t\t{\n\t\t\t\tRELEASE_SLAB_SLOT(state, state->lastReturnedTuple);\n\t\t\t\tstate->lastReturnedTuple = NULL;\n\t\t\t}\n\n\t\t\tif (forward)\n\t\t\t{\n\t\t\t\tif (state->eof_reached)\n\t\t\t\t\treturn false;\n\n\t\t\t\tif ((tuplen = getlen(state, state->result_tape, true)) != 0)\n\t\t\t\t{\n\t\t\t\t\tREADTUP(state, stup, state->result_tape, tuplen);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Remember the tuple we return, so that we can recycle\n\t\t\t\t\t * its memory on next call.  (This can be NULL, in the\n\t\t\t\t\t * !state->tuples case).\n\t\t\t\t\t */\n\t\t\t\t\tstate->lastReturnedTuple = stup->tuple;\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstate->eof_reached = true;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Backward.\n\t\t\t *\n\t\t\t * if all tuples are fetched already then we return last tuple,\n\t\t\t * else - tuple before last returned.\n\t\t\t */\n\t\t\tif (state->eof_reached)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Seek position is pointing just past the zero tuplen at the\n\t\t\t\t * end of file; back up to fetch last tuple's ending length\n\t\t\t\t * word.  If seek fails we must have a completely empty file.\n\t\t\t\t */\n\t\t\t\tnmoved = LogicalTapeBackspace(state->tapeset,\n\t\t\t\t\t\t\t\t\t\t\t  state->result_tape,\n\t\t\t\t\t\t\t\t\t\t\t  2 * sizeof(unsigned int));\n\t\t\t\tif (nmoved == 0)\n\t\t\t\t\treturn false;\n\t\t\t\telse if (nmoved != 2 * sizeof(unsigned int))\n\t\t\t\t\telog(ERROR, \"unexpected tape position\");\n\t\t\t\tstate->eof_reached = false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Back up and fetch previously-returned tuple's ending length\n\t\t\t\t * word.  If seek fails, assume we are at start of file.\n\t\t\t\t */\n\t\t\t\tnmoved = LogicalTapeBackspace(state->tapeset,\n\t\t\t\t\t\t\t\t\t\t\t  state->result_tape,\n\t\t\t\t\t\t\t\t\t\t\t  sizeof(unsigned int));\n\t\t\t\tif (nmoved == 0)\n\t\t\t\t\treturn false;\n\t\t\t\telse if (nmoved != sizeof(unsigned int))\n\t\t\t\t\telog(ERROR, \"unexpected tape position\");\n\t\t\t\ttuplen = getlen(state, state->result_tape, false);\n\n\t\t\t\t/*\n\t\t\t\t * Back up to get ending length word of tuple before it.\n\t\t\t\t */\n\t\t\t\tnmoved = LogicalTapeBackspace(state->tapeset,\n\t\t\t\t\t\t\t\t\t\t\t  state->result_tape,\n\t\t\t\t\t\t\t\t\t\t\t  tuplen + 2 * sizeof(unsigned int));\n\t\t\t\tif (nmoved == tuplen + sizeof(unsigned int))\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * We backed up over the previous tuple, but there was no\n\t\t\t\t\t * ending length word before it.  That means that the prev\n\t\t\t\t\t * tuple is the first tuple in the file.  It is now the\n\t\t\t\t\t * next to read in forward direction (not obviously right,\n\t\t\t\t\t * but that is what in-memory case does).\n\t\t\t\t\t */\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\telse if (nmoved != tuplen + 2 * sizeof(unsigned int))\n\t\t\t\t\telog(ERROR, \"bogus tuple length in backward scan\");\n\t\t\t}\n\n\t\t\ttuplen = getlen(state, state->result_tape, false);\n\n\t\t\t/*\n\t\t\t * Now we have the length of the prior tuple, back up and read it.\n\t\t\t * Note: READTUP expects we are positioned after the initial\n\t\t\t * length word of the tuple, so back up to that point.\n\t\t\t */\n\t\t\tnmoved = LogicalTapeBackspace(state->tapeset,\n\t\t\t\t\t\t\t\t\t\t  state->result_tape,\n\t\t\t\t\t\t\t\t\t\t  tuplen);\n\t\t\tif (nmoved != tuplen)\n\t\t\t\telog(ERROR, \"bogus tuple length in backward scan\");\n\t\t\tREADTUP(state, stup, state->result_tape, tuplen);\n\n\t\t\t/*\n\t\t\t * Remember the tuple we return, so that we can recycle its memory\n\t\t\t * on next call. (This can be NULL, in the Datum case).\n\t\t\t */\n\t\t\tstate->lastReturnedTuple = stup->tuple;\n\n\t\t\treturn true;\n\n\t\tcase TSS_FINALMERGE:\n\t\t\tAssert(forward);\n\t\t\t/* We are managing memory ourselves, with the slab allocator. */\n\t\t\tAssert(state->slabAllocatorUsed);\n\n\t\t\t/*\n\t\t\t * The slab slot holding the tuple that we returned in previous\n\t\t\t * gettuple call can now be reused.\n\t\t\t */\n\t\t\tif (state->lastReturnedTuple)\n\t\t\t{\n\t\t\t\tRELEASE_SLAB_SLOT(state, state->lastReturnedTuple);\n\t\t\t\tstate->lastReturnedTuple = NULL;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * This code should match the inner loop of mergeonerun().\n\t\t\t */\n\t\t\tif (state->memtupcount > 0)\n\t\t\t{\n\t\t\t\tint\t\t\tsrcTape = state->memtuples[0].tupindex;\n\t\t\t\tSortTuple\tnewtup;\n\n\t\t\t\t*stup = state->memtuples[0];\n\n\t\t\t\t/*\n\t\t\t\t * Remember the tuple we return, so that we can recycle its\n\t\t\t\t * memory on next call. (This can be NULL, in the Datum case).\n\t\t\t\t */\n\t\t\t\tstate->lastReturnedTuple = stup->tuple;\n\n\t\t\t\t/*\n\t\t\t\t * Pull next tuple from tape, and replace the returned tuple\n\t\t\t\t * at top of the heap with it.\n\t\t\t\t */\n\t\t\t\tif (!mergereadnext(state, srcTape, &newtup))\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * If no more data, we've reached end of run on this tape.\n\t\t\t\t\t * Remove the top node from the heap.\n\t\t\t\t\t */\n\t\t\t\t\ttuplesort_heap_delete_top(state);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Rewind to free the read buffer.  It'd go away at the\n\t\t\t\t\t * end of the sort anyway, but better to release the\n\t\t\t\t\t * memory early.\n\t\t\t\t\t */\n\t\t\t\t\tLogicalTapeRewindForWrite(state->tapeset, srcTape);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tnewtup.tupindex = srcTape;\n\t\t\t\ttuplesort_heap_replace_top(state, &newtup);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplesort state\");\n\t\t\treturn false;\t\t/* keep compiler quiet */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "state->sortcontext"
          ],
          "line": 2197
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\nstatic void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);\n\nHeapTuple\ntuplesort_getheaptuple(Tuplesortstate *state, bool forward)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\tSortTuple\tstup;\n\n\tif (!tuplesort_gettuple_common(state, forward, &stup))\n\t\tstup.tuple = NULL;\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn stup.tuple;\n}"
  },
  {
    "function_name": "tuplesort_gettupleslot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "2157-2186",
    "snippet": "bool\ntuplesort_gettupleslot(Tuplesortstate *state, bool forward, bool copy,\n\t\t\t\t\t   TupleTableSlot *slot, Datum *abbrev)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\tSortTuple\tstup;\n\n\tif (!tuplesort_gettuple_common(state, forward, &stup))\n\t\tstup.tuple = NULL;\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\tif (stup.tuple)\n\t{\n\t\t/* Record abbreviated key for caller */\n\t\tif (state->sortKeys->abbrev_converter && abbrev)\n\t\t\t*abbrev = stup.datum1;\n\n\t\tif (copy)\n\t\t\tstup.tuple = heap_copy_minimal_tuple((MinimalTuple) stup.tuple);\n\n\t\tExecStoreMinimalTuple((MinimalTuple) stup.tuple, slot, copy);\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\tExecClearTuple(slot);\n\t\treturn false;\n\t}\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);",
      "static void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ExecClearTuple",
          "args": [
            "slot"
          ],
          "line": 2183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ExecStoreMinimalTuple",
          "args": [
            "(MinimalTuple) stup.tuple",
            "slot",
            "copy"
          ],
          "line": 2178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_copy_minimal_tuple",
          "args": [
            "(MinimalTuple) stup.tuple"
          ],
          "line": 2176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 2167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tuplesort_gettuple_common",
          "args": [
            "state",
            "forward",
            "&stup"
          ],
          "line": 2164
        },
        "resolved": true,
        "details": {
          "function_name": "tuplesort_gettuple_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "1900-2135",
          "snippet": "static bool\ntuplesort_gettuple_common(Tuplesortstate *state, bool forward,\n\t\t\t\t\t\t  SortTuple *stup)\n{\n\tunsigned int tuplen;\n\tsize_t\t\tnmoved;\n\n\tAssert(!WORKER(state));\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_SORTEDINMEM:\n\t\t\tAssert(forward || state->randomAccess);\n\t\t\tAssert(!state->slabAllocatorUsed);\n\t\t\tif (forward)\n\t\t\t{\n\t\t\t\tif (state->current < state->memtupcount)\n\t\t\t\t{\n\t\t\t\t\t*stup = state->memtuples[state->current++];\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tstate->eof_reached = true;\n\n\t\t\t\t/*\n\t\t\t\t * Complain if caller tries to retrieve more tuples than\n\t\t\t\t * originally asked for in a bounded sort.  This is because\n\t\t\t\t * returning EOF here might be the wrong thing.\n\t\t\t\t */\n\t\t\t\tif (state->bounded && state->current >= state->bound)\n\t\t\t\t\telog(ERROR, \"retrieved too many tuples in a bounded sort\");\n\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (state->current <= 0)\n\t\t\t\t\treturn false;\n\n\t\t\t\t/*\n\t\t\t\t * if all tuples are fetched already then we return last\n\t\t\t\t * tuple, else - tuple before last returned.\n\t\t\t\t */\n\t\t\t\tif (state->eof_reached)\n\t\t\t\t\tstate->eof_reached = false;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstate->current--;\t/* last returned tuple */\n\t\t\t\t\tif (state->current <= 0)\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t*stup = state->memtuples[state->current - 1];\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TSS_SORTEDONTAPE:\n\t\t\tAssert(forward || state->randomAccess);\n\t\t\tAssert(state->slabAllocatorUsed);\n\n\t\t\t/*\n\t\t\t * The slot that held the tuple that we returned in previous\n\t\t\t * gettuple call can now be reused.\n\t\t\t */\n\t\t\tif (state->lastReturnedTuple)\n\t\t\t{\n\t\t\t\tRELEASE_SLAB_SLOT(state, state->lastReturnedTuple);\n\t\t\t\tstate->lastReturnedTuple = NULL;\n\t\t\t}\n\n\t\t\tif (forward)\n\t\t\t{\n\t\t\t\tif (state->eof_reached)\n\t\t\t\t\treturn false;\n\n\t\t\t\tif ((tuplen = getlen(state, state->result_tape, true)) != 0)\n\t\t\t\t{\n\t\t\t\t\tREADTUP(state, stup, state->result_tape, tuplen);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Remember the tuple we return, so that we can recycle\n\t\t\t\t\t * its memory on next call.  (This can be NULL, in the\n\t\t\t\t\t * !state->tuples case).\n\t\t\t\t\t */\n\t\t\t\t\tstate->lastReturnedTuple = stup->tuple;\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstate->eof_reached = true;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Backward.\n\t\t\t *\n\t\t\t * if all tuples are fetched already then we return last tuple,\n\t\t\t * else - tuple before last returned.\n\t\t\t */\n\t\t\tif (state->eof_reached)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Seek position is pointing just past the zero tuplen at the\n\t\t\t\t * end of file; back up to fetch last tuple's ending length\n\t\t\t\t * word.  If seek fails we must have a completely empty file.\n\t\t\t\t */\n\t\t\t\tnmoved = LogicalTapeBackspace(state->tapeset,\n\t\t\t\t\t\t\t\t\t\t\t  state->result_tape,\n\t\t\t\t\t\t\t\t\t\t\t  2 * sizeof(unsigned int));\n\t\t\t\tif (nmoved == 0)\n\t\t\t\t\treturn false;\n\t\t\t\telse if (nmoved != 2 * sizeof(unsigned int))\n\t\t\t\t\telog(ERROR, \"unexpected tape position\");\n\t\t\t\tstate->eof_reached = false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Back up and fetch previously-returned tuple's ending length\n\t\t\t\t * word.  If seek fails, assume we are at start of file.\n\t\t\t\t */\n\t\t\t\tnmoved = LogicalTapeBackspace(state->tapeset,\n\t\t\t\t\t\t\t\t\t\t\t  state->result_tape,\n\t\t\t\t\t\t\t\t\t\t\t  sizeof(unsigned int));\n\t\t\t\tif (nmoved == 0)\n\t\t\t\t\treturn false;\n\t\t\t\telse if (nmoved != sizeof(unsigned int))\n\t\t\t\t\telog(ERROR, \"unexpected tape position\");\n\t\t\t\ttuplen = getlen(state, state->result_tape, false);\n\n\t\t\t\t/*\n\t\t\t\t * Back up to get ending length word of tuple before it.\n\t\t\t\t */\n\t\t\t\tnmoved = LogicalTapeBackspace(state->tapeset,\n\t\t\t\t\t\t\t\t\t\t\t  state->result_tape,\n\t\t\t\t\t\t\t\t\t\t\t  tuplen + 2 * sizeof(unsigned int));\n\t\t\t\tif (nmoved == tuplen + sizeof(unsigned int))\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * We backed up over the previous tuple, but there was no\n\t\t\t\t\t * ending length word before it.  That means that the prev\n\t\t\t\t\t * tuple is the first tuple in the file.  It is now the\n\t\t\t\t\t * next to read in forward direction (not obviously right,\n\t\t\t\t\t * but that is what in-memory case does).\n\t\t\t\t\t */\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\telse if (nmoved != tuplen + 2 * sizeof(unsigned int))\n\t\t\t\t\telog(ERROR, \"bogus tuple length in backward scan\");\n\t\t\t}\n\n\t\t\ttuplen = getlen(state, state->result_tape, false);\n\n\t\t\t/*\n\t\t\t * Now we have the length of the prior tuple, back up and read it.\n\t\t\t * Note: READTUP expects we are positioned after the initial\n\t\t\t * length word of the tuple, so back up to that point.\n\t\t\t */\n\t\t\tnmoved = LogicalTapeBackspace(state->tapeset,\n\t\t\t\t\t\t\t\t\t\t  state->result_tape,\n\t\t\t\t\t\t\t\t\t\t  tuplen);\n\t\t\tif (nmoved != tuplen)\n\t\t\t\telog(ERROR, \"bogus tuple length in backward scan\");\n\t\t\tREADTUP(state, stup, state->result_tape, tuplen);\n\n\t\t\t/*\n\t\t\t * Remember the tuple we return, so that we can recycle its memory\n\t\t\t * on next call. (This can be NULL, in the Datum case).\n\t\t\t */\n\t\t\tstate->lastReturnedTuple = stup->tuple;\n\n\t\t\treturn true;\n\n\t\tcase TSS_FINALMERGE:\n\t\t\tAssert(forward);\n\t\t\t/* We are managing memory ourselves, with the slab allocator. */\n\t\t\tAssert(state->slabAllocatorUsed);\n\n\t\t\t/*\n\t\t\t * The slab slot holding the tuple that we returned in previous\n\t\t\t * gettuple call can now be reused.\n\t\t\t */\n\t\t\tif (state->lastReturnedTuple)\n\t\t\t{\n\t\t\t\tRELEASE_SLAB_SLOT(state, state->lastReturnedTuple);\n\t\t\t\tstate->lastReturnedTuple = NULL;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * This code should match the inner loop of mergeonerun().\n\t\t\t */\n\t\t\tif (state->memtupcount > 0)\n\t\t\t{\n\t\t\t\tint\t\t\tsrcTape = state->memtuples[0].tupindex;\n\t\t\t\tSortTuple\tnewtup;\n\n\t\t\t\t*stup = state->memtuples[0];\n\n\t\t\t\t/*\n\t\t\t\t * Remember the tuple we return, so that we can recycle its\n\t\t\t\t * memory on next call. (This can be NULL, in the Datum case).\n\t\t\t\t */\n\t\t\t\tstate->lastReturnedTuple = stup->tuple;\n\n\t\t\t\t/*\n\t\t\t\t * Pull next tuple from tape, and replace the returned tuple\n\t\t\t\t * at top of the heap with it.\n\t\t\t\t */\n\t\t\t\tif (!mergereadnext(state, srcTape, &newtup))\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * If no more data, we've reached end of run on this tape.\n\t\t\t\t\t * Remove the top node from the heap.\n\t\t\t\t\t */\n\t\t\t\t\ttuplesort_heap_delete_top(state);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Rewind to free the read buffer.  It'd go away at the\n\t\t\t\t\t * end of the sort anyway, but better to release the\n\t\t\t\t\t * memory early.\n\t\t\t\t\t */\n\t\t\t\t\tLogicalTapeRewindForWrite(state->tapeset, srcTape);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tnewtup.tupindex = srcTape;\n\t\t\t\ttuplesort_heap_replace_top(state, &newtup);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplesort state\");\n\t\t\treturn false;\t\t/* keep compiler quiet */\n\t}\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);",
            "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static void *readtup_alloc(Tuplesortstate *state, Size tuplen);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);",
            "static void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic void *readtup_alloc(Tuplesortstate *state, Size tuplen);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\nstatic void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);\n\nstatic bool\ntuplesort_gettuple_common(Tuplesortstate *state, bool forward,\n\t\t\t\t\t\t  SortTuple *stup)\n{\n\tunsigned int tuplen;\n\tsize_t\t\tnmoved;\n\n\tAssert(!WORKER(state));\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_SORTEDINMEM:\n\t\t\tAssert(forward || state->randomAccess);\n\t\t\tAssert(!state->slabAllocatorUsed);\n\t\t\tif (forward)\n\t\t\t{\n\t\t\t\tif (state->current < state->memtupcount)\n\t\t\t\t{\n\t\t\t\t\t*stup = state->memtuples[state->current++];\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tstate->eof_reached = true;\n\n\t\t\t\t/*\n\t\t\t\t * Complain if caller tries to retrieve more tuples than\n\t\t\t\t * originally asked for in a bounded sort.  This is because\n\t\t\t\t * returning EOF here might be the wrong thing.\n\t\t\t\t */\n\t\t\t\tif (state->bounded && state->current >= state->bound)\n\t\t\t\t\telog(ERROR, \"retrieved too many tuples in a bounded sort\");\n\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (state->current <= 0)\n\t\t\t\t\treturn false;\n\n\t\t\t\t/*\n\t\t\t\t * if all tuples are fetched already then we return last\n\t\t\t\t * tuple, else - tuple before last returned.\n\t\t\t\t */\n\t\t\t\tif (state->eof_reached)\n\t\t\t\t\tstate->eof_reached = false;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstate->current--;\t/* last returned tuple */\n\t\t\t\t\tif (state->current <= 0)\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t*stup = state->memtuples[state->current - 1];\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TSS_SORTEDONTAPE:\n\t\t\tAssert(forward || state->randomAccess);\n\t\t\tAssert(state->slabAllocatorUsed);\n\n\t\t\t/*\n\t\t\t * The slot that held the tuple that we returned in previous\n\t\t\t * gettuple call can now be reused.\n\t\t\t */\n\t\t\tif (state->lastReturnedTuple)\n\t\t\t{\n\t\t\t\tRELEASE_SLAB_SLOT(state, state->lastReturnedTuple);\n\t\t\t\tstate->lastReturnedTuple = NULL;\n\t\t\t}\n\n\t\t\tif (forward)\n\t\t\t{\n\t\t\t\tif (state->eof_reached)\n\t\t\t\t\treturn false;\n\n\t\t\t\tif ((tuplen = getlen(state, state->result_tape, true)) != 0)\n\t\t\t\t{\n\t\t\t\t\tREADTUP(state, stup, state->result_tape, tuplen);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Remember the tuple we return, so that we can recycle\n\t\t\t\t\t * its memory on next call.  (This can be NULL, in the\n\t\t\t\t\t * !state->tuples case).\n\t\t\t\t\t */\n\t\t\t\t\tstate->lastReturnedTuple = stup->tuple;\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstate->eof_reached = true;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Backward.\n\t\t\t *\n\t\t\t * if all tuples are fetched already then we return last tuple,\n\t\t\t * else - tuple before last returned.\n\t\t\t */\n\t\t\tif (state->eof_reached)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Seek position is pointing just past the zero tuplen at the\n\t\t\t\t * end of file; back up to fetch last tuple's ending length\n\t\t\t\t * word.  If seek fails we must have a completely empty file.\n\t\t\t\t */\n\t\t\t\tnmoved = LogicalTapeBackspace(state->tapeset,\n\t\t\t\t\t\t\t\t\t\t\t  state->result_tape,\n\t\t\t\t\t\t\t\t\t\t\t  2 * sizeof(unsigned int));\n\t\t\t\tif (nmoved == 0)\n\t\t\t\t\treturn false;\n\t\t\t\telse if (nmoved != 2 * sizeof(unsigned int))\n\t\t\t\t\telog(ERROR, \"unexpected tape position\");\n\t\t\t\tstate->eof_reached = false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Back up and fetch previously-returned tuple's ending length\n\t\t\t\t * word.  If seek fails, assume we are at start of file.\n\t\t\t\t */\n\t\t\t\tnmoved = LogicalTapeBackspace(state->tapeset,\n\t\t\t\t\t\t\t\t\t\t\t  state->result_tape,\n\t\t\t\t\t\t\t\t\t\t\t  sizeof(unsigned int));\n\t\t\t\tif (nmoved == 0)\n\t\t\t\t\treturn false;\n\t\t\t\telse if (nmoved != sizeof(unsigned int))\n\t\t\t\t\telog(ERROR, \"unexpected tape position\");\n\t\t\t\ttuplen = getlen(state, state->result_tape, false);\n\n\t\t\t\t/*\n\t\t\t\t * Back up to get ending length word of tuple before it.\n\t\t\t\t */\n\t\t\t\tnmoved = LogicalTapeBackspace(state->tapeset,\n\t\t\t\t\t\t\t\t\t\t\t  state->result_tape,\n\t\t\t\t\t\t\t\t\t\t\t  tuplen + 2 * sizeof(unsigned int));\n\t\t\t\tif (nmoved == tuplen + sizeof(unsigned int))\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * We backed up over the previous tuple, but there was no\n\t\t\t\t\t * ending length word before it.  That means that the prev\n\t\t\t\t\t * tuple is the first tuple in the file.  It is now the\n\t\t\t\t\t * next to read in forward direction (not obviously right,\n\t\t\t\t\t * but that is what in-memory case does).\n\t\t\t\t\t */\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\telse if (nmoved != tuplen + 2 * sizeof(unsigned int))\n\t\t\t\t\telog(ERROR, \"bogus tuple length in backward scan\");\n\t\t\t}\n\n\t\t\ttuplen = getlen(state, state->result_tape, false);\n\n\t\t\t/*\n\t\t\t * Now we have the length of the prior tuple, back up and read it.\n\t\t\t * Note: READTUP expects we are positioned after the initial\n\t\t\t * length word of the tuple, so back up to that point.\n\t\t\t */\n\t\t\tnmoved = LogicalTapeBackspace(state->tapeset,\n\t\t\t\t\t\t\t\t\t\t  state->result_tape,\n\t\t\t\t\t\t\t\t\t\t  tuplen);\n\t\t\tif (nmoved != tuplen)\n\t\t\t\telog(ERROR, \"bogus tuple length in backward scan\");\n\t\t\tREADTUP(state, stup, state->result_tape, tuplen);\n\n\t\t\t/*\n\t\t\t * Remember the tuple we return, so that we can recycle its memory\n\t\t\t * on next call. (This can be NULL, in the Datum case).\n\t\t\t */\n\t\t\tstate->lastReturnedTuple = stup->tuple;\n\n\t\t\treturn true;\n\n\t\tcase TSS_FINALMERGE:\n\t\t\tAssert(forward);\n\t\t\t/* We are managing memory ourselves, with the slab allocator. */\n\t\t\tAssert(state->slabAllocatorUsed);\n\n\t\t\t/*\n\t\t\t * The slab slot holding the tuple that we returned in previous\n\t\t\t * gettuple call can now be reused.\n\t\t\t */\n\t\t\tif (state->lastReturnedTuple)\n\t\t\t{\n\t\t\t\tRELEASE_SLAB_SLOT(state, state->lastReturnedTuple);\n\t\t\t\tstate->lastReturnedTuple = NULL;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * This code should match the inner loop of mergeonerun().\n\t\t\t */\n\t\t\tif (state->memtupcount > 0)\n\t\t\t{\n\t\t\t\tint\t\t\tsrcTape = state->memtuples[0].tupindex;\n\t\t\t\tSortTuple\tnewtup;\n\n\t\t\t\t*stup = state->memtuples[0];\n\n\t\t\t\t/*\n\t\t\t\t * Remember the tuple we return, so that we can recycle its\n\t\t\t\t * memory on next call. (This can be NULL, in the Datum case).\n\t\t\t\t */\n\t\t\t\tstate->lastReturnedTuple = stup->tuple;\n\n\t\t\t\t/*\n\t\t\t\t * Pull next tuple from tape, and replace the returned tuple\n\t\t\t\t * at top of the heap with it.\n\t\t\t\t */\n\t\t\t\tif (!mergereadnext(state, srcTape, &newtup))\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * If no more data, we've reached end of run on this tape.\n\t\t\t\t\t * Remove the top node from the heap.\n\t\t\t\t\t */\n\t\t\t\t\ttuplesort_heap_delete_top(state);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Rewind to free the read buffer.  It'd go away at the\n\t\t\t\t\t * end of the sort anyway, but better to release the\n\t\t\t\t\t * memory early.\n\t\t\t\t\t */\n\t\t\t\t\tLogicalTapeRewindForWrite(state->tapeset, srcTape);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tnewtup.tupindex = srcTape;\n\t\t\t\ttuplesort_heap_replace_top(state, &newtup);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplesort state\");\n\t\t\treturn false;\t\t/* keep compiler quiet */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "state->sortcontext"
          ],
          "line": 2161
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\nstatic void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);\n\nbool\ntuplesort_gettupleslot(Tuplesortstate *state, bool forward, bool copy,\n\t\t\t\t\t   TupleTableSlot *slot, Datum *abbrev)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\tSortTuple\tstup;\n\n\tif (!tuplesort_gettuple_common(state, forward, &stup))\n\t\tstup.tuple = NULL;\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\tif (stup.tuple)\n\t{\n\t\t/* Record abbreviated key for caller */\n\t\tif (state->sortKeys->abbrev_converter && abbrev)\n\t\t\t*abbrev = stup.datum1;\n\n\t\tif (copy)\n\t\t\tstup.tuple = heap_copy_minimal_tuple((MinimalTuple) stup.tuple);\n\n\t\tExecStoreMinimalTuple((MinimalTuple) stup.tuple, slot, copy);\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\tExecClearTuple(slot);\n\t\treturn false;\n\t}\n}"
  },
  {
    "function_name": "tuplesort_gettuple_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "1900-2135",
    "snippet": "static bool\ntuplesort_gettuple_common(Tuplesortstate *state, bool forward,\n\t\t\t\t\t\t  SortTuple *stup)\n{\n\tunsigned int tuplen;\n\tsize_t\t\tnmoved;\n\n\tAssert(!WORKER(state));\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_SORTEDINMEM:\n\t\t\tAssert(forward || state->randomAccess);\n\t\t\tAssert(!state->slabAllocatorUsed);\n\t\t\tif (forward)\n\t\t\t{\n\t\t\t\tif (state->current < state->memtupcount)\n\t\t\t\t{\n\t\t\t\t\t*stup = state->memtuples[state->current++];\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tstate->eof_reached = true;\n\n\t\t\t\t/*\n\t\t\t\t * Complain if caller tries to retrieve more tuples than\n\t\t\t\t * originally asked for in a bounded sort.  This is because\n\t\t\t\t * returning EOF here might be the wrong thing.\n\t\t\t\t */\n\t\t\t\tif (state->bounded && state->current >= state->bound)\n\t\t\t\t\telog(ERROR, \"retrieved too many tuples in a bounded sort\");\n\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (state->current <= 0)\n\t\t\t\t\treturn false;\n\n\t\t\t\t/*\n\t\t\t\t * if all tuples are fetched already then we return last\n\t\t\t\t * tuple, else - tuple before last returned.\n\t\t\t\t */\n\t\t\t\tif (state->eof_reached)\n\t\t\t\t\tstate->eof_reached = false;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstate->current--;\t/* last returned tuple */\n\t\t\t\t\tif (state->current <= 0)\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t*stup = state->memtuples[state->current - 1];\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TSS_SORTEDONTAPE:\n\t\t\tAssert(forward || state->randomAccess);\n\t\t\tAssert(state->slabAllocatorUsed);\n\n\t\t\t/*\n\t\t\t * The slot that held the tuple that we returned in previous\n\t\t\t * gettuple call can now be reused.\n\t\t\t */\n\t\t\tif (state->lastReturnedTuple)\n\t\t\t{\n\t\t\t\tRELEASE_SLAB_SLOT(state, state->lastReturnedTuple);\n\t\t\t\tstate->lastReturnedTuple = NULL;\n\t\t\t}\n\n\t\t\tif (forward)\n\t\t\t{\n\t\t\t\tif (state->eof_reached)\n\t\t\t\t\treturn false;\n\n\t\t\t\tif ((tuplen = getlen(state, state->result_tape, true)) != 0)\n\t\t\t\t{\n\t\t\t\t\tREADTUP(state, stup, state->result_tape, tuplen);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Remember the tuple we return, so that we can recycle\n\t\t\t\t\t * its memory on next call.  (This can be NULL, in the\n\t\t\t\t\t * !state->tuples case).\n\t\t\t\t\t */\n\t\t\t\t\tstate->lastReturnedTuple = stup->tuple;\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstate->eof_reached = true;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Backward.\n\t\t\t *\n\t\t\t * if all tuples are fetched already then we return last tuple,\n\t\t\t * else - tuple before last returned.\n\t\t\t */\n\t\t\tif (state->eof_reached)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Seek position is pointing just past the zero tuplen at the\n\t\t\t\t * end of file; back up to fetch last tuple's ending length\n\t\t\t\t * word.  If seek fails we must have a completely empty file.\n\t\t\t\t */\n\t\t\t\tnmoved = LogicalTapeBackspace(state->tapeset,\n\t\t\t\t\t\t\t\t\t\t\t  state->result_tape,\n\t\t\t\t\t\t\t\t\t\t\t  2 * sizeof(unsigned int));\n\t\t\t\tif (nmoved == 0)\n\t\t\t\t\treturn false;\n\t\t\t\telse if (nmoved != 2 * sizeof(unsigned int))\n\t\t\t\t\telog(ERROR, \"unexpected tape position\");\n\t\t\t\tstate->eof_reached = false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Back up and fetch previously-returned tuple's ending length\n\t\t\t\t * word.  If seek fails, assume we are at start of file.\n\t\t\t\t */\n\t\t\t\tnmoved = LogicalTapeBackspace(state->tapeset,\n\t\t\t\t\t\t\t\t\t\t\t  state->result_tape,\n\t\t\t\t\t\t\t\t\t\t\t  sizeof(unsigned int));\n\t\t\t\tif (nmoved == 0)\n\t\t\t\t\treturn false;\n\t\t\t\telse if (nmoved != sizeof(unsigned int))\n\t\t\t\t\telog(ERROR, \"unexpected tape position\");\n\t\t\t\ttuplen = getlen(state, state->result_tape, false);\n\n\t\t\t\t/*\n\t\t\t\t * Back up to get ending length word of tuple before it.\n\t\t\t\t */\n\t\t\t\tnmoved = LogicalTapeBackspace(state->tapeset,\n\t\t\t\t\t\t\t\t\t\t\t  state->result_tape,\n\t\t\t\t\t\t\t\t\t\t\t  tuplen + 2 * sizeof(unsigned int));\n\t\t\t\tif (nmoved == tuplen + sizeof(unsigned int))\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * We backed up over the previous tuple, but there was no\n\t\t\t\t\t * ending length word before it.  That means that the prev\n\t\t\t\t\t * tuple is the first tuple in the file.  It is now the\n\t\t\t\t\t * next to read in forward direction (not obviously right,\n\t\t\t\t\t * but that is what in-memory case does).\n\t\t\t\t\t */\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\telse if (nmoved != tuplen + 2 * sizeof(unsigned int))\n\t\t\t\t\telog(ERROR, \"bogus tuple length in backward scan\");\n\t\t\t}\n\n\t\t\ttuplen = getlen(state, state->result_tape, false);\n\n\t\t\t/*\n\t\t\t * Now we have the length of the prior tuple, back up and read it.\n\t\t\t * Note: READTUP expects we are positioned after the initial\n\t\t\t * length word of the tuple, so back up to that point.\n\t\t\t */\n\t\t\tnmoved = LogicalTapeBackspace(state->tapeset,\n\t\t\t\t\t\t\t\t\t\t  state->result_tape,\n\t\t\t\t\t\t\t\t\t\t  tuplen);\n\t\t\tif (nmoved != tuplen)\n\t\t\t\telog(ERROR, \"bogus tuple length in backward scan\");\n\t\t\tREADTUP(state, stup, state->result_tape, tuplen);\n\n\t\t\t/*\n\t\t\t * Remember the tuple we return, so that we can recycle its memory\n\t\t\t * on next call. (This can be NULL, in the Datum case).\n\t\t\t */\n\t\t\tstate->lastReturnedTuple = stup->tuple;\n\n\t\t\treturn true;\n\n\t\tcase TSS_FINALMERGE:\n\t\t\tAssert(forward);\n\t\t\t/* We are managing memory ourselves, with the slab allocator. */\n\t\t\tAssert(state->slabAllocatorUsed);\n\n\t\t\t/*\n\t\t\t * The slab slot holding the tuple that we returned in previous\n\t\t\t * gettuple call can now be reused.\n\t\t\t */\n\t\t\tif (state->lastReturnedTuple)\n\t\t\t{\n\t\t\t\tRELEASE_SLAB_SLOT(state, state->lastReturnedTuple);\n\t\t\t\tstate->lastReturnedTuple = NULL;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * This code should match the inner loop of mergeonerun().\n\t\t\t */\n\t\t\tif (state->memtupcount > 0)\n\t\t\t{\n\t\t\t\tint\t\t\tsrcTape = state->memtuples[0].tupindex;\n\t\t\t\tSortTuple\tnewtup;\n\n\t\t\t\t*stup = state->memtuples[0];\n\n\t\t\t\t/*\n\t\t\t\t * Remember the tuple we return, so that we can recycle its\n\t\t\t\t * memory on next call. (This can be NULL, in the Datum case).\n\t\t\t\t */\n\t\t\t\tstate->lastReturnedTuple = stup->tuple;\n\n\t\t\t\t/*\n\t\t\t\t * Pull next tuple from tape, and replace the returned tuple\n\t\t\t\t * at top of the heap with it.\n\t\t\t\t */\n\t\t\t\tif (!mergereadnext(state, srcTape, &newtup))\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * If no more data, we've reached end of run on this tape.\n\t\t\t\t\t * Remove the top node from the heap.\n\t\t\t\t\t */\n\t\t\t\t\ttuplesort_heap_delete_top(state);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Rewind to free the read buffer.  It'd go away at the\n\t\t\t\t\t * end of the sort anyway, but better to release the\n\t\t\t\t\t * memory early.\n\t\t\t\t\t */\n\t\t\t\t\tLogicalTapeRewindForWrite(state->tapeset, srcTape);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tnewtup.tupindex = srcTape;\n\t\t\t\ttuplesort_heap_replace_top(state, &newtup);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplesort state\");\n\t\t\treturn false;\t\t/* keep compiler quiet */\n\t}\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);",
      "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static void *readtup_alloc(Tuplesortstate *state, Size tuplen);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);",
      "static void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"invalid tuplesort state\""
          ],
          "line": 2132
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tuplesort_heap_replace_top",
          "args": [
            "state",
            "&newtup"
          ],
          "line": 2126
        },
        "resolved": true,
        "details": {
          "function_name": "tuplesort_heap_replace_top",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "3395-3428",
          "snippet": "static void\ntuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple)\n{\n\tSortTuple  *memtuples = state->memtuples;\n\tunsigned int i,\n\t\t\t\tn;\n\n\tAssert(state->memtupcount >= 1);\n\n\tCHECK_FOR_INTERRUPTS();\n\n\t/*\n\t * state->memtupcount is \"int\", but we use \"unsigned int\" for i, j, n.\n\t * This prevents overflow in the \"2 * i + 1\" calculation, since at the top\n\t * of the loop we must have i < n <= INT_MAX <= UINT_MAX/2.\n\t */\n\tn = state->memtupcount;\n\ti = 0;\t\t\t\t\t\t/* i is where the \"hole\" is */\n\tfor (;;)\n\t{\n\t\tunsigned int j = 2 * i + 1;\n\n\t\tif (j >= n)\n\t\t\tbreak;\n\t\tif (j + 1 < n &&\n\t\t\tCOMPARETUP(state, &memtuples[j], &memtuples[j + 1]) > 0)\n\t\t\tj++;\n\t\tif (COMPARETUP(state, tuple, &memtuples[j]) <= 0)\n\t\t\tbreak;\n\t\tmemtuples[i] = memtuples[j];\n\t\ti = j;\n\t}\n\tmemtuples[i] = *tuple;\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic void\ntuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple)\n{\n\tSortTuple  *memtuples = state->memtuples;\n\tunsigned int i,\n\t\t\t\tn;\n\n\tAssert(state->memtupcount >= 1);\n\n\tCHECK_FOR_INTERRUPTS();\n\n\t/*\n\t * state->memtupcount is \"int\", but we use \"unsigned int\" for i, j, n.\n\t * This prevents overflow in the \"2 * i + 1\" calculation, since at the top\n\t * of the loop we must have i < n <= INT_MAX <= UINT_MAX/2.\n\t */\n\tn = state->memtupcount;\n\ti = 0;\t\t\t\t\t\t/* i is where the \"hole\" is */\n\tfor (;;)\n\t{\n\t\tunsigned int j = 2 * i + 1;\n\n\t\tif (j >= n)\n\t\t\tbreak;\n\t\tif (j + 1 < n &&\n\t\t\tCOMPARETUP(state, &memtuples[j], &memtuples[j + 1]) > 0)\n\t\t\tj++;\n\t\tif (COMPARETUP(state, tuple, &memtuples[j]) <= 0)\n\t\t\tbreak;\n\t\tmemtuples[i] = memtuples[j];\n\t\ti = j;\n\t}\n\tmemtuples[i] = *tuple;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LogicalTapeRewindForWrite",
          "args": [
            "state->tapeset",
            "srcTape"
          ],
          "line": 2122
        },
        "resolved": true,
        "details": {
          "function_name": "LogicalTapeRewindForWrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/logtape.c",
          "lines": "795-814",
          "snippet": "void\nLogicalTapeRewindForWrite(LogicalTapeSet *lts, int tapenum)\n{\n\tLogicalTape *lt;\n\n\tAssert(tapenum >= 0 && tapenum < lts->nTapes);\n\tlt = &lts->tapes[tapenum];\n\n\tAssert(!lt->writing && !lt->frozen);\n\tlt->writing = true;\n\tlt->dirty = false;\n\tlt->firstBlockNumber = -1L;\n\tlt->curBlockNumber = -1L;\n\tlt->pos = 0;\n\tlt->nbytes = 0;\n\tif (lt->buffer)\n\t\tpfree(lt->buffer);\n\tlt->buffer = NULL;\n\tlt->buffer_size = 0;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
            "static void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
            "static long ltsGetFreeBlock(LogicalTapeSet *lts);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/logtape.h\"\n#include \"utils/builtins.h\"\n#include \"storage/buffile.h\"\n#include \"postgres.h\"\n\nstatic void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic long ltsGetFreeBlock(LogicalTapeSet *lts);\n\nvoid\nLogicalTapeRewindForWrite(LogicalTapeSet *lts, int tapenum)\n{\n\tLogicalTape *lt;\n\n\tAssert(tapenum >= 0 && tapenum < lts->nTapes);\n\tlt = &lts->tapes[tapenum];\n\n\tAssert(!lt->writing && !lt->frozen);\n\tlt->writing = true;\n\tlt->dirty = false;\n\tlt->firstBlockNumber = -1L;\n\tlt->curBlockNumber = -1L;\n\tlt->pos = 0;\n\tlt->nbytes = 0;\n\tif (lt->buffer)\n\t\tpfree(lt->buffer);\n\tlt->buffer = NULL;\n\tlt->buffer_size = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tuplesort_heap_delete_top",
          "args": [
            "state"
          ],
          "line": 2115
        },
        "resolved": true,
        "details": {
          "function_name": "tuplesort_heap_delete_top",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "3371-3386",
          "snippet": "static void\ntuplesort_heap_delete_top(Tuplesortstate *state)\n{\n\tSortTuple  *memtuples = state->memtuples;\n\tSortTuple  *tuple;\n\n\tif (--state->memtupcount <= 0)\n\t\treturn;\n\n\t/*\n\t * Remove the last tuple in the heap, and re-insert it, by replacing the\n\t * current top node with it.\n\t */\n\ttuple = &memtuples[state->memtupcount];\n\ttuplesort_heap_replace_top(state, tuple);\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic void\ntuplesort_heap_delete_top(Tuplesortstate *state)\n{\n\tSortTuple  *memtuples = state->memtuples;\n\tSortTuple  *tuple;\n\n\tif (--state->memtupcount <= 0)\n\t\treturn;\n\n\t/*\n\t * Remove the last tuple in the heap, and re-insert it, by replacing the\n\t * current top node with it.\n\t */\n\ttuple = &memtuples[state->memtupcount];\n\ttuplesort_heap_replace_top(state, tuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mergereadnext",
          "args": [
            "state",
            "srcTape",
            "&newtup"
          ],
          "line": 2109
        },
        "resolved": true,
        "details": {
          "function_name": "mergereadnext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "2899-2916",
          "snippet": "static bool\nmergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup)\n{\n\tunsigned int tuplen;\n\n\tif (!state->mergeactive[srcTape])\n\t\treturn false;\t\t\t/* tape's run is already exhausted */\n\n\t/* read next tuple, if any */\n\tif ((tuplen = getlen(state, srcTape, true)) == 0)\n\t{\n\t\tstate->mergeactive[srcTape] = false;\n\t\treturn false;\n\t}\n\tREADTUP(state, stup, srcTape, tuplen);\n\n\treturn true;\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static void *readtup_alloc(Tuplesortstate *state, Size tuplen);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);",
            "static void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic void *readtup_alloc(Tuplesortstate *state, Size tuplen);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\nstatic void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);\n\nstatic bool\nmergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup)\n{\n\tunsigned int tuplen;\n\n\tif (!state->mergeactive[srcTape])\n\t\treturn false;\t\t\t/* tape's run is already exhausted */\n\n\t/* read next tuple, if any */\n\tif ((tuplen = getlen(state, srcTape, true)) == 0)\n\t{\n\t\tstate->mergeactive[srcTape] = false;\n\t\treturn false;\n\t}\n\tREADTUP(state, stup, srcTape, tuplen);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RELEASE_SLAB_SLOT",
          "args": [
            "state",
            "state->lastReturnedTuple"
          ],
          "line": 2085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "state->slabAllocatorUsed"
          ],
          "line": 2077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "forward"
          ],
          "line": 2075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READTUP",
          "args": [
            "state",
            "stup",
            "state->result_tape",
            "tuplen"
          ],
          "line": 2064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LogicalTapeBackspace",
          "args": [
            "state->tapeset",
            "state->result_tape",
            "tuplen"
          ],
          "line": 2059
        },
        "resolved": true,
        "details": {
          "function_name": "LogicalTapeBackspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/logtape.c",
          "lines": "959-1020",
          "snippet": "size_t\nLogicalTapeBackspace(LogicalTapeSet *lts, int tapenum, size_t size)\n{\n\tLogicalTape *lt;\n\tsize_t\t\tseekpos = 0;\n\n\tAssert(tapenum >= 0 && tapenum < lts->nTapes);\n\tlt = &lts->tapes[tapenum];\n\tAssert(lt->frozen);\n\tAssert(lt->buffer_size == BLCKSZ);\n\n\t/*\n\t * Easy case for seek within current block.\n\t */\n\tif (size <= (size_t) lt->pos)\n\t{\n\t\tlt->pos -= (int) size;\n\t\treturn size;\n\t}\n\n\t/*\n\t * Not-so-easy case, have to walk back the chain of blocks.  This\n\t * implementation would be pretty inefficient for long seeks, but we\n\t * really aren't doing that (a seek over one tuple is typical).\n\t */\n\tseekpos = (size_t) lt->pos; /* part within this block */\n\twhile (size > seekpos)\n\t{\n\t\tlong\t\tprev = TapeBlockGetTrailer(lt->buffer)->prev;\n\n\t\tif (prev == -1L)\n\t\t{\n\t\t\t/* Tried to back up beyond the beginning of tape. */\n\t\t\tif (lt->curBlockNumber != lt->firstBlockNumber)\n\t\t\t\telog(ERROR, \"unexpected end of tape\");\n\t\t\tlt->pos = 0;\n\t\t\treturn seekpos;\n\t\t}\n\n\t\tltsReadBlock(lts, prev, (void *) lt->buffer);\n\n\t\tif (TapeBlockGetTrailer(lt->buffer)->next != lt->curBlockNumber)\n\t\t\telog(ERROR, \"broken tape, next of block %ld is %ld, expected %ld\",\n\t\t\t\t prev,\n\t\t\t\t TapeBlockGetTrailer(lt->buffer)->next,\n\t\t\t\t lt->curBlockNumber);\n\n\t\tlt->nbytes = TapeBlockPayloadSize;\n\t\tlt->curBlockNumber = prev;\n\t\tlt->nextBlockNumber = TapeBlockGetTrailer(lt->buffer)->next;\n\n\t\tseekpos += TapeBlockPayloadSize;\n\t}\n\n\t/*\n\t * 'seekpos' can now be greater than 'size', because it points to the\n\t * beginning the target block.  The difference is the position within the\n\t * page.\n\t */\n\tlt->pos = seekpos - size;\n\treturn size;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TapeBlockPayloadSize  (BLCKSZ - sizeof(TapeBlockTrailer))"
          ],
          "globals_used": [
            "static void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
            "static void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
            "static long ltsGetFreeBlock(LogicalTapeSet *lts);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/logtape.h\"\n#include \"utils/builtins.h\"\n#include \"storage/buffile.h\"\n#include \"postgres.h\"\n\n#define TapeBlockPayloadSize  (BLCKSZ - sizeof(TapeBlockTrailer))\n\nstatic void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic long ltsGetFreeBlock(LogicalTapeSet *lts);\n\nsize_t\nLogicalTapeBackspace(LogicalTapeSet *lts, int tapenum, size_t size)\n{\n\tLogicalTape *lt;\n\tsize_t\t\tseekpos = 0;\n\n\tAssert(tapenum >= 0 && tapenum < lts->nTapes);\n\tlt = &lts->tapes[tapenum];\n\tAssert(lt->frozen);\n\tAssert(lt->buffer_size == BLCKSZ);\n\n\t/*\n\t * Easy case for seek within current block.\n\t */\n\tif (size <= (size_t) lt->pos)\n\t{\n\t\tlt->pos -= (int) size;\n\t\treturn size;\n\t}\n\n\t/*\n\t * Not-so-easy case, have to walk back the chain of blocks.  This\n\t * implementation would be pretty inefficient for long seeks, but we\n\t * really aren't doing that (a seek over one tuple is typical).\n\t */\n\tseekpos = (size_t) lt->pos; /* part within this block */\n\twhile (size > seekpos)\n\t{\n\t\tlong\t\tprev = TapeBlockGetTrailer(lt->buffer)->prev;\n\n\t\tif (prev == -1L)\n\t\t{\n\t\t\t/* Tried to back up beyond the beginning of tape. */\n\t\t\tif (lt->curBlockNumber != lt->firstBlockNumber)\n\t\t\t\telog(ERROR, \"unexpected end of tape\");\n\t\t\tlt->pos = 0;\n\t\t\treturn seekpos;\n\t\t}\n\n\t\tltsReadBlock(lts, prev, (void *) lt->buffer);\n\n\t\tif (TapeBlockGetTrailer(lt->buffer)->next != lt->curBlockNumber)\n\t\t\telog(ERROR, \"broken tape, next of block %ld is %ld, expected %ld\",\n\t\t\t\t prev,\n\t\t\t\t TapeBlockGetTrailer(lt->buffer)->next,\n\t\t\t\t lt->curBlockNumber);\n\n\t\tlt->nbytes = TapeBlockPayloadSize;\n\t\tlt->curBlockNumber = prev;\n\t\tlt->nextBlockNumber = TapeBlockGetTrailer(lt->buffer)->next;\n\n\t\tseekpos += TapeBlockPayloadSize;\n\t}\n\n\t/*\n\t * 'seekpos' can now be greater than 'size', because it points to the\n\t * beginning the target block.  The difference is the position within the\n\t * page.\n\t */\n\tlt->pos = seekpos - size;\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getlen",
          "args": [
            "state",
            "state->result_tape",
            "false"
          ],
          "line": 2052
        },
        "resolved": true,
        "details": {
          "function_name": "getlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "3453-3464",
          "snippet": "static unsigned int\ngetlen(Tuplesortstate *state, int tapenum, bool eofOK)\n{\n\tunsigned int len;\n\n\tif (LogicalTapeRead(state->tapeset, tapenum,\n\t\t\t\t\t\t&len, sizeof(len)) != sizeof(len))\n\t\telog(ERROR, \"unexpected end of tape\");\n\tif (len == 0 && !eofOK)\n\t\telog(ERROR, \"unexpected end of data\");\n\treturn len;\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static unsigned int getlen(Tuplesortstate *state, int tapenum, bool eofOK);",
            "static void markrunend(Tuplesortstate *state, int tapenum);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static void readtup_heap(Tuplesortstate *state, SortTuple *stup,\n\t\t\t int tapenum, unsigned int len);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static void readtup_cluster(Tuplesortstate *state, SortTuple *stup,\n\t\t\t\tint tapenum, unsigned int len);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static void readtup_index(Tuplesortstate *state, SortTuple *stup,\n\t\t\t  int tapenum, unsigned int len);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static void readtup_datum(Tuplesortstate *state, SortTuple *stup,\n\t\t\t  int tapenum, unsigned int len);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic unsigned int getlen(Tuplesortstate *state, int tapenum, bool eofOK);\nstatic void markrunend(Tuplesortstate *state, int tapenum);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic void readtup_heap(Tuplesortstate *state, SortTuple *stup,\n\t\t\t int tapenum, unsigned int len);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic void readtup_cluster(Tuplesortstate *state, SortTuple *stup,\n\t\t\t\tint tapenum, unsigned int len);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic void readtup_index(Tuplesortstate *state, SortTuple *stup,\n\t\t\t  int tapenum, unsigned int len);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic void readtup_datum(Tuplesortstate *state, SortTuple *stup,\n\t\t\t  int tapenum, unsigned int len);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic unsigned int\ngetlen(Tuplesortstate *state, int tapenum, bool eofOK)\n{\n\tunsigned int len;\n\n\tif (LogicalTapeRead(state->tapeset, tapenum,\n\t\t\t\t\t\t&len, sizeof(len)) != sizeof(len))\n\t\telog(ERROR, \"unexpected end of tape\");\n\tif (len == 0 && !eofOK)\n\t\telog(ERROR, \"unexpected end of data\");\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READTUP",
          "args": [
            "state",
            "stup",
            "state->result_tape",
            "tuplen"
          ],
          "line": 1976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RELEASE_SLAB_SLOT",
          "args": [
            "state",
            "state->lastReturnedTuple"
          ],
          "line": 1965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "state->slabAllocatorUsed"
          ],
          "line": 1957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "forward || state->randomAccess"
          ],
          "line": 1956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!state->slabAllocatorUsed"
          ],
          "line": 1913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "forward || state->randomAccess"
          ],
          "line": 1912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!WORKER(state)"
          ],
          "line": 1907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WORKER",
          "args": [
            "state"
          ],
          "line": 1907
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic void *readtup_alloc(Tuplesortstate *state, Size tuplen);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\nstatic void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);\n\nstatic bool\ntuplesort_gettuple_common(Tuplesortstate *state, bool forward,\n\t\t\t\t\t\t  SortTuple *stup)\n{\n\tunsigned int tuplen;\n\tsize_t\t\tnmoved;\n\n\tAssert(!WORKER(state));\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_SORTEDINMEM:\n\t\t\tAssert(forward || state->randomAccess);\n\t\t\tAssert(!state->slabAllocatorUsed);\n\t\t\tif (forward)\n\t\t\t{\n\t\t\t\tif (state->current < state->memtupcount)\n\t\t\t\t{\n\t\t\t\t\t*stup = state->memtuples[state->current++];\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tstate->eof_reached = true;\n\n\t\t\t\t/*\n\t\t\t\t * Complain if caller tries to retrieve more tuples than\n\t\t\t\t * originally asked for in a bounded sort.  This is because\n\t\t\t\t * returning EOF here might be the wrong thing.\n\t\t\t\t */\n\t\t\t\tif (state->bounded && state->current >= state->bound)\n\t\t\t\t\telog(ERROR, \"retrieved too many tuples in a bounded sort\");\n\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (state->current <= 0)\n\t\t\t\t\treturn false;\n\n\t\t\t\t/*\n\t\t\t\t * if all tuples are fetched already then we return last\n\t\t\t\t * tuple, else - tuple before last returned.\n\t\t\t\t */\n\t\t\t\tif (state->eof_reached)\n\t\t\t\t\tstate->eof_reached = false;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstate->current--;\t/* last returned tuple */\n\t\t\t\t\tif (state->current <= 0)\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t*stup = state->memtuples[state->current - 1];\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TSS_SORTEDONTAPE:\n\t\t\tAssert(forward || state->randomAccess);\n\t\t\tAssert(state->slabAllocatorUsed);\n\n\t\t\t/*\n\t\t\t * The slot that held the tuple that we returned in previous\n\t\t\t * gettuple call can now be reused.\n\t\t\t */\n\t\t\tif (state->lastReturnedTuple)\n\t\t\t{\n\t\t\t\tRELEASE_SLAB_SLOT(state, state->lastReturnedTuple);\n\t\t\t\tstate->lastReturnedTuple = NULL;\n\t\t\t}\n\n\t\t\tif (forward)\n\t\t\t{\n\t\t\t\tif (state->eof_reached)\n\t\t\t\t\treturn false;\n\n\t\t\t\tif ((tuplen = getlen(state, state->result_tape, true)) != 0)\n\t\t\t\t{\n\t\t\t\t\tREADTUP(state, stup, state->result_tape, tuplen);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Remember the tuple we return, so that we can recycle\n\t\t\t\t\t * its memory on next call.  (This can be NULL, in the\n\t\t\t\t\t * !state->tuples case).\n\t\t\t\t\t */\n\t\t\t\t\tstate->lastReturnedTuple = stup->tuple;\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstate->eof_reached = true;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Backward.\n\t\t\t *\n\t\t\t * if all tuples are fetched already then we return last tuple,\n\t\t\t * else - tuple before last returned.\n\t\t\t */\n\t\t\tif (state->eof_reached)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Seek position is pointing just past the zero tuplen at the\n\t\t\t\t * end of file; back up to fetch last tuple's ending length\n\t\t\t\t * word.  If seek fails we must have a completely empty file.\n\t\t\t\t */\n\t\t\t\tnmoved = LogicalTapeBackspace(state->tapeset,\n\t\t\t\t\t\t\t\t\t\t\t  state->result_tape,\n\t\t\t\t\t\t\t\t\t\t\t  2 * sizeof(unsigned int));\n\t\t\t\tif (nmoved == 0)\n\t\t\t\t\treturn false;\n\t\t\t\telse if (nmoved != 2 * sizeof(unsigned int))\n\t\t\t\t\telog(ERROR, \"unexpected tape position\");\n\t\t\t\tstate->eof_reached = false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Back up and fetch previously-returned tuple's ending length\n\t\t\t\t * word.  If seek fails, assume we are at start of file.\n\t\t\t\t */\n\t\t\t\tnmoved = LogicalTapeBackspace(state->tapeset,\n\t\t\t\t\t\t\t\t\t\t\t  state->result_tape,\n\t\t\t\t\t\t\t\t\t\t\t  sizeof(unsigned int));\n\t\t\t\tif (nmoved == 0)\n\t\t\t\t\treturn false;\n\t\t\t\telse if (nmoved != sizeof(unsigned int))\n\t\t\t\t\telog(ERROR, \"unexpected tape position\");\n\t\t\t\ttuplen = getlen(state, state->result_tape, false);\n\n\t\t\t\t/*\n\t\t\t\t * Back up to get ending length word of tuple before it.\n\t\t\t\t */\n\t\t\t\tnmoved = LogicalTapeBackspace(state->tapeset,\n\t\t\t\t\t\t\t\t\t\t\t  state->result_tape,\n\t\t\t\t\t\t\t\t\t\t\t  tuplen + 2 * sizeof(unsigned int));\n\t\t\t\tif (nmoved == tuplen + sizeof(unsigned int))\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * We backed up over the previous tuple, but there was no\n\t\t\t\t\t * ending length word before it.  That means that the prev\n\t\t\t\t\t * tuple is the first tuple in the file.  It is now the\n\t\t\t\t\t * next to read in forward direction (not obviously right,\n\t\t\t\t\t * but that is what in-memory case does).\n\t\t\t\t\t */\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\telse if (nmoved != tuplen + 2 * sizeof(unsigned int))\n\t\t\t\t\telog(ERROR, \"bogus tuple length in backward scan\");\n\t\t\t}\n\n\t\t\ttuplen = getlen(state, state->result_tape, false);\n\n\t\t\t/*\n\t\t\t * Now we have the length of the prior tuple, back up and read it.\n\t\t\t * Note: READTUP expects we are positioned after the initial\n\t\t\t * length word of the tuple, so back up to that point.\n\t\t\t */\n\t\t\tnmoved = LogicalTapeBackspace(state->tapeset,\n\t\t\t\t\t\t\t\t\t\t  state->result_tape,\n\t\t\t\t\t\t\t\t\t\t  tuplen);\n\t\t\tif (nmoved != tuplen)\n\t\t\t\telog(ERROR, \"bogus tuple length in backward scan\");\n\t\t\tREADTUP(state, stup, state->result_tape, tuplen);\n\n\t\t\t/*\n\t\t\t * Remember the tuple we return, so that we can recycle its memory\n\t\t\t * on next call. (This can be NULL, in the Datum case).\n\t\t\t */\n\t\t\tstate->lastReturnedTuple = stup->tuple;\n\n\t\t\treturn true;\n\n\t\tcase TSS_FINALMERGE:\n\t\t\tAssert(forward);\n\t\t\t/* We are managing memory ourselves, with the slab allocator. */\n\t\t\tAssert(state->slabAllocatorUsed);\n\n\t\t\t/*\n\t\t\t * The slab slot holding the tuple that we returned in previous\n\t\t\t * gettuple call can now be reused.\n\t\t\t */\n\t\t\tif (state->lastReturnedTuple)\n\t\t\t{\n\t\t\t\tRELEASE_SLAB_SLOT(state, state->lastReturnedTuple);\n\t\t\t\tstate->lastReturnedTuple = NULL;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * This code should match the inner loop of mergeonerun().\n\t\t\t */\n\t\t\tif (state->memtupcount > 0)\n\t\t\t{\n\t\t\t\tint\t\t\tsrcTape = state->memtuples[0].tupindex;\n\t\t\t\tSortTuple\tnewtup;\n\n\t\t\t\t*stup = state->memtuples[0];\n\n\t\t\t\t/*\n\t\t\t\t * Remember the tuple we return, so that we can recycle its\n\t\t\t\t * memory on next call. (This can be NULL, in the Datum case).\n\t\t\t\t */\n\t\t\t\tstate->lastReturnedTuple = stup->tuple;\n\n\t\t\t\t/*\n\t\t\t\t * Pull next tuple from tape, and replace the returned tuple\n\t\t\t\t * at top of the heap with it.\n\t\t\t\t */\n\t\t\t\tif (!mergereadnext(state, srcTape, &newtup))\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * If no more data, we've reached end of run on this tape.\n\t\t\t\t\t * Remove the top node from the heap.\n\t\t\t\t\t */\n\t\t\t\t\ttuplesort_heap_delete_top(state);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Rewind to free the read buffer.  It'd go away at the\n\t\t\t\t\t * end of the sort anyway, but better to release the\n\t\t\t\t\t * memory early.\n\t\t\t\t\t */\n\t\t\t\t\tLogicalTapeRewindForWrite(state->tapeset, srcTape);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tnewtup.tupindex = srcTape;\n\t\t\t\ttuplesort_heap_replace_top(state, &newtup);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplesort state\");\n\t\t\treturn false;\t\t/* keep compiler quiet */\n\t}\n}"
  },
  {
    "function_name": "tuplesort_performsort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "1789-1891",
    "snippet": "void\ntuplesort_performsort(Tuplesortstate *state)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\telog(LOG, \"performsort of worker %d starting: %s\",\n\t\t\t state->worker, pg_rusage_show(&state->ru_start));\n#endif\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INITIAL:\n\n\t\t\t/*\n\t\t\t * We were able to accumulate all the tuples within the allowed\n\t\t\t * amount of memory, or leader to take over worker tapes\n\t\t\t */\n\t\t\tif (SERIAL(state))\n\t\t\t{\n\t\t\t\t/* Just qsort 'em and we're done */\n\t\t\t\ttuplesort_sort_memtuples(state);\n\t\t\t\tstate->status = TSS_SORTEDINMEM;\n\t\t\t}\n\t\t\telse if (WORKER(state))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Parallel workers must still dump out tuples to tape.  No\n\t\t\t\t * merge is required to produce single output run, though.\n\t\t\t\t */\n\t\t\t\tinittapes(state, false);\n\t\t\t\tdumptuples(state, true);\n\t\t\t\tworker_nomergeruns(state);\n\t\t\t\tstate->status = TSS_SORTEDONTAPE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Leader will take over worker tapes and merge worker runs.\n\t\t\t\t * Note that mergeruns sets the correct state->status.\n\t\t\t\t */\n\t\t\t\tleader_takeover_tapes(state);\n\t\t\t\tmergeruns(state);\n\t\t\t}\n\t\t\tstate->current = 0;\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_block = 0L;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tbreak;\n\n\t\tcase TSS_BOUNDED:\n\n\t\t\t/*\n\t\t\t * We were able to accumulate all the tuples required for output\n\t\t\t * in memory, using a heap to eliminate excess tuples.  Now we\n\t\t\t * have to transform the heap to a properly-sorted array.\n\t\t\t */\n\t\t\tsort_bounded_heap(state);\n\t\t\tstate->current = 0;\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tstate->status = TSS_SORTEDINMEM;\n\t\t\tbreak;\n\n\t\tcase TSS_BUILDRUNS:\n\n\t\t\t/*\n\t\t\t * Finish tape-based sort.  First, flush all tuples remaining in\n\t\t\t * memory out to tape; then merge until we have a single remaining\n\t\t\t * run (or, if !randomAccess and !WORKER(), one run per tape).\n\t\t\t * Note that mergeruns sets the correct state->status.\n\t\t\t */\n\t\t\tdumptuples(state, true);\n\t\t\tmergeruns(state);\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_block = 0L;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplesort state\");\n\t\t\tbreak;\n\t}\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t{\n\t\tif (state->status == TSS_FINALMERGE)\n\t\t\telog(LOG, \"performsort of worker %d done (except %d-way final merge): %s\",\n\t\t\t\t state->worker, state->activeTapes,\n\t\t\t\t pg_rusage_show(&state->ru_start));\n\t\telse\n\t\t\telog(LOG, \"performsort of worker %d done: %s\",\n\t\t\t\t state->worker, pg_rusage_show(&state->ru_start));\n\t}\n#endif\n\n\tMemoryContextSwitchTo(oldcontext);\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);",
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void inittapes(Tuplesortstate *state, bool mergeruns);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 1890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "LOG",
            "\"performsort of worker %d done: %s\"",
            "state->worker",
            "pg_rusage_show(&state->ru_start)"
          ],
          "line": 1885
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_rusage_show",
          "args": [
            "&state->ru_start"
          ],
          "line": 1886
        },
        "resolved": true,
        "details": {
          "function_name": "pg_rusage_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/pg_rusage.c",
          "lines": "39-73",
          "snippet": "const char *\npg_rusage_show(const PGRUsage *ru0)\n{\n\tstatic char result[100];\n\tPGRUsage\tru1;\n\n\tpg_rusage_init(&ru1);\n\n\tif (ru1.tv.tv_usec < ru0->tv.tv_usec)\n\t{\n\t\tru1.tv.tv_sec--;\n\t\tru1.tv.tv_usec += 1000000;\n\t}\n\tif (ru1.ru.ru_stime.tv_usec < ru0->ru.ru_stime.tv_usec)\n\t{\n\t\tru1.ru.ru_stime.tv_sec--;\n\t\tru1.ru.ru_stime.tv_usec += 1000000;\n\t}\n\tif (ru1.ru.ru_utime.tv_usec < ru0->ru.ru_utime.tv_usec)\n\t{\n\t\tru1.ru.ru_utime.tv_sec--;\n\t\tru1.ru.ru_utime.tv_usec += 1000000;\n\t}\n\n\tsnprintf(result, sizeof(result),\n\t\t\t _(\"CPU: user: %d.%02d s, system: %d.%02d s, elapsed: %d.%02d s\"),\n\t\t\t (int) (ru1.ru.ru_utime.tv_sec - ru0->ru.ru_utime.tv_sec),\n\t\t\t (int) (ru1.ru.ru_utime.tv_usec - ru0->ru.ru_utime.tv_usec) / 10000,\n\t\t\t (int) (ru1.ru.ru_stime.tv_sec - ru0->ru.ru_stime.tv_sec),\n\t\t\t (int) (ru1.ru.ru_stime.tv_usec - ru0->ru.ru_stime.tv_usec) / 10000,\n\t\t\t (int) (ru1.tv.tv_sec - ru0->tv.tv_sec),\n\t\t\t (int) (ru1.tv.tv_usec - ru0->tv.tv_usec) / 10000);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/pg_rusage.h\"",
            "#include <unistd.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_rusage.h\"\n#include <unistd.h>\n#include \"postgres.h\"\n\nconst char *\npg_rusage_show(const PGRUsage *ru0)\n{\n\tstatic char result[100];\n\tPGRUsage\tru1;\n\n\tpg_rusage_init(&ru1);\n\n\tif (ru1.tv.tv_usec < ru0->tv.tv_usec)\n\t{\n\t\tru1.tv.tv_sec--;\n\t\tru1.tv.tv_usec += 1000000;\n\t}\n\tif (ru1.ru.ru_stime.tv_usec < ru0->ru.ru_stime.tv_usec)\n\t{\n\t\tru1.ru.ru_stime.tv_sec--;\n\t\tru1.ru.ru_stime.tv_usec += 1000000;\n\t}\n\tif (ru1.ru.ru_utime.tv_usec < ru0->ru.ru_utime.tv_usec)\n\t{\n\t\tru1.ru.ru_utime.tv_sec--;\n\t\tru1.ru.ru_utime.tv_usec += 1000000;\n\t}\n\n\tsnprintf(result, sizeof(result),\n\t\t\t _(\"CPU: user: %d.%02d s, system: %d.%02d s, elapsed: %d.%02d s\"),\n\t\t\t (int) (ru1.ru.ru_utime.tv_sec - ru0->ru.ru_utime.tv_sec),\n\t\t\t (int) (ru1.ru.ru_utime.tv_usec - ru0->ru.ru_utime.tv_usec) / 10000,\n\t\t\t (int) (ru1.ru.ru_stime.tv_sec - ru0->ru.ru_stime.tv_sec),\n\t\t\t (int) (ru1.ru.ru_stime.tv_usec - ru0->ru.ru_stime.tv_usec) / 10000,\n\t\t\t (int) (ru1.tv.tv_sec - ru0->tv.tv_sec),\n\t\t\t (int) (ru1.tv.tv_usec - ru0->tv.tv_usec) / 10000);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mergeruns",
          "args": [
            "state"
          ],
          "line": 1865
        },
        "resolved": true,
        "details": {
          "function_name": "worker_nomergeruns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "4492-4500",
          "snippet": "static void\nworker_nomergeruns(Tuplesortstate *state)\n{\n\tAssert(WORKER(state));\n\tAssert(state->result_tape == -1);\n\n\tstate->result_tape = state->tp_tapenum[state->destTape];\n\tworker_freeze_result_tape(state);\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic void\nworker_nomergeruns(Tuplesortstate *state)\n{\n\tAssert(WORKER(state));\n\tAssert(state->result_tape == -1);\n\n\tstate->result_tape = state->tp_tapenum[state->destTape];\n\tworker_freeze_result_tape(state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dumptuples",
          "args": [
            "state",
            "true"
          ],
          "line": 1864
        },
        "resolved": true,
        "details": {
          "function_name": "dumptuples",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "2924-3022",
          "snippet": "static void\ndumptuples(Tuplesortstate *state, bool alltuples)\n{\n\tint\t\t\tmemtupwrite;\n\tint\t\t\ti;\n\n\t/*\n\t * Nothing to do if we still fit in available memory and have array slots,\n\t * unless this is the final call during initial run generation.\n\t */\n\tif (state->memtupcount < state->memtupsize && !LACKMEM(state) &&\n\t\t!alltuples)\n\t\treturn;\n\n\t/*\n\t * Final call might require no sorting, in rare cases where we just so\n\t * happen to have previously LACKMEM()'d at the point where exactly all\n\t * remaining tuples are loaded into memory, just before input was\n\t * exhausted.\n\t *\n\t * In general, short final runs are quite possible.  Rather than allowing\n\t * a special case where there was a superfluous selectnewtape() call (i.e.\n\t * a call with no subsequent run actually written to destTape), we prefer\n\t * to write out a 0 tuple run.\n\t *\n\t * mergereadnext() is prepared for 0 tuple runs, and will reliably mark\n\t * the tape inactive for the merge when called from beginmerge().  This\n\t * case is therefore similar to the case where mergeonerun() finds a dummy\n\t * run for the tape, and so doesn't need to merge a run from the tape (or\n\t * conceptually \"merges\" the dummy run, if you prefer).  According to\n\t * Knuth, Algorithm D \"isn't strictly optimal\" in its method of\n\t * distribution and dummy run assignment; this edge case seems very\n\t * unlikely to make that appreciably worse.\n\t */\n\tAssert(state->status == TSS_BUILDRUNS);\n\n\t/*\n\t * It seems unlikely that this limit will ever be exceeded, but take no\n\t * chances\n\t */\n\tif (state->currentRun == INT_MAX)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"cannot have more than %d runs for an external sort\",\n\t\t\t\t\t\tINT_MAX)));\n\n\tstate->currentRun++;\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\telog(LOG, \"worker %d starting quicksort of run %d: %s\",\n\t\t\t state->worker, state->currentRun,\n\t\t\t pg_rusage_show(&state->ru_start));\n#endif\n\n\t/*\n\t * Sort all tuples accumulated within the allowed amount of memory for\n\t * this run using quicksort\n\t */\n\ttuplesort_sort_memtuples(state);\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\telog(LOG, \"worker %d finished quicksort of run %d: %s\",\n\t\t\t state->worker, state->currentRun,\n\t\t\t pg_rusage_show(&state->ru_start));\n#endif\n\n\tmemtupwrite = state->memtupcount;\n\tfor (i = 0; i < memtupwrite; i++)\n\t{\n\t\tWRITETUP(state, state->tp_tapenum[state->destTape],\n\t\t\t\t &state->memtuples[i]);\n\t\tstate->memtupcount--;\n\t}\n\n\t/*\n\t * Reset tuple memory.  We've freed all of the tuples that we previously\n\t * allocated.  It's important to avoid fragmentation when there is a stark\n\t * change in the sizes of incoming tuples.  Fragmentation due to\n\t * AllocSetFree's bucketing by size class might be particularly bad if\n\t * this step wasn't taken.\n\t */\n\tMemoryContextReset(state->tuplecontext);\n\n\tmarkrunend(state, state->tp_tapenum[state->destTape]);\n\tstate->tp_runs[state->destTape]++;\n\tstate->tp_dummy[state->destTape]--; /* per Alg D step D2 */\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\telog(LOG, \"worker %d finished writing run %d to tape %d: %s\",\n\t\t\t state->worker, state->currentRun, state->destTape,\n\t\t\t pg_rusage_show(&state->ru_start));\n#endif\n\n\tif (!alltuples)\n\t\tselectnewtape(state);\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void dumptuples(Tuplesortstate *state, bool alltuples);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void dumptuples(Tuplesortstate *state, bool alltuples);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic void\ndumptuples(Tuplesortstate *state, bool alltuples)\n{\n\tint\t\t\tmemtupwrite;\n\tint\t\t\ti;\n\n\t/*\n\t * Nothing to do if we still fit in available memory and have array slots,\n\t * unless this is the final call during initial run generation.\n\t */\n\tif (state->memtupcount < state->memtupsize && !LACKMEM(state) &&\n\t\t!alltuples)\n\t\treturn;\n\n\t/*\n\t * Final call might require no sorting, in rare cases where we just so\n\t * happen to have previously LACKMEM()'d at the point where exactly all\n\t * remaining tuples are loaded into memory, just before input was\n\t * exhausted.\n\t *\n\t * In general, short final runs are quite possible.  Rather than allowing\n\t * a special case where there was a superfluous selectnewtape() call (i.e.\n\t * a call with no subsequent run actually written to destTape), we prefer\n\t * to write out a 0 tuple run.\n\t *\n\t * mergereadnext() is prepared for 0 tuple runs, and will reliably mark\n\t * the tape inactive for the merge when called from beginmerge().  This\n\t * case is therefore similar to the case where mergeonerun() finds a dummy\n\t * run for the tape, and so doesn't need to merge a run from the tape (or\n\t * conceptually \"merges\" the dummy run, if you prefer).  According to\n\t * Knuth, Algorithm D \"isn't strictly optimal\" in its method of\n\t * distribution and dummy run assignment; this edge case seems very\n\t * unlikely to make that appreciably worse.\n\t */\n\tAssert(state->status == TSS_BUILDRUNS);\n\n\t/*\n\t * It seems unlikely that this limit will ever be exceeded, but take no\n\t * chances\n\t */\n\tif (state->currentRun == INT_MAX)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"cannot have more than %d runs for an external sort\",\n\t\t\t\t\t\tINT_MAX)));\n\n\tstate->currentRun++;\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\telog(LOG, \"worker %d starting quicksort of run %d: %s\",\n\t\t\t state->worker, state->currentRun,\n\t\t\t pg_rusage_show(&state->ru_start));\n#endif\n\n\t/*\n\t * Sort all tuples accumulated within the allowed amount of memory for\n\t * this run using quicksort\n\t */\n\ttuplesort_sort_memtuples(state);\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\telog(LOG, \"worker %d finished quicksort of run %d: %s\",\n\t\t\t state->worker, state->currentRun,\n\t\t\t pg_rusage_show(&state->ru_start));\n#endif\n\n\tmemtupwrite = state->memtupcount;\n\tfor (i = 0; i < memtupwrite; i++)\n\t{\n\t\tWRITETUP(state, state->tp_tapenum[state->destTape],\n\t\t\t\t &state->memtuples[i]);\n\t\tstate->memtupcount--;\n\t}\n\n\t/*\n\t * Reset tuple memory.  We've freed all of the tuples that we previously\n\t * allocated.  It's important to avoid fragmentation when there is a stark\n\t * change in the sizes of incoming tuples.  Fragmentation due to\n\t * AllocSetFree's bucketing by size class might be particularly bad if\n\t * this step wasn't taken.\n\t */\n\tMemoryContextReset(state->tuplecontext);\n\n\tmarkrunend(state, state->tp_tapenum[state->destTape]);\n\tstate->tp_runs[state->destTape]++;\n\tstate->tp_dummy[state->destTape]--; /* per Alg D step D2 */\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\telog(LOG, \"worker %d finished writing run %d to tape %d: %s\",\n\t\t\t state->worker, state->currentRun, state->destTape,\n\t\t\t pg_rusage_show(&state->ru_start));\n#endif\n\n\tif (!alltuples)\n\t\tselectnewtape(state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sort_bounded_heap",
          "args": [
            "state"
          ],
          "line": 1848
        },
        "resolved": true,
        "details": {
          "function_name": "sort_bounded_heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "3268-3301",
          "snippet": "static void\nsort_bounded_heap(Tuplesortstate *state)\n{\n\tint\t\t\ttupcount = state->memtupcount;\n\n\tAssert(state->status == TSS_BOUNDED);\n\tAssert(state->bounded);\n\tAssert(tupcount == state->bound);\n\tAssert(SERIAL(state));\n\n\t/*\n\t * We can unheapify in place because each delete-top call will remove the\n\t * largest entry, which we can promptly store in the newly freed slot at\n\t * the end.  Once we're down to a single-entry heap, we're done.\n\t */\n\twhile (state->memtupcount > 1)\n\t{\n\t\tSortTuple\tstup = state->memtuples[0];\n\n\t\t/* this sifts-up the next-largest entry and decreases memtupcount */\n\t\ttuplesort_heap_delete_top(state);\n\t\tstate->memtuples[state->memtupcount] = stup;\n\t}\n\tstate->memtupcount = tupcount;\n\n\t/*\n\t * Reverse sort direction back to the original state.  This is not\n\t * actually necessary but seems like a good idea for tidiness.\n\t */\n\treversedirection(state);\n\n\tstate->status = TSS_SORTEDINMEM;\n\tstate->boundUsed = true;\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);",
            "static void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\nstatic void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);\n\nstatic void\nsort_bounded_heap(Tuplesortstate *state)\n{\n\tint\t\t\ttupcount = state->memtupcount;\n\n\tAssert(state->status == TSS_BOUNDED);\n\tAssert(state->bounded);\n\tAssert(tupcount == state->bound);\n\tAssert(SERIAL(state));\n\n\t/*\n\t * We can unheapify in place because each delete-top call will remove the\n\t * largest entry, which we can promptly store in the newly freed slot at\n\t * the end.  Once we're down to a single-entry heap, we're done.\n\t */\n\twhile (state->memtupcount > 1)\n\t{\n\t\tSortTuple\tstup = state->memtuples[0];\n\n\t\t/* this sifts-up the next-largest entry and decreases memtupcount */\n\t\ttuplesort_heap_delete_top(state);\n\t\tstate->memtuples[state->memtupcount] = stup;\n\t}\n\tstate->memtupcount = tupcount;\n\n\t/*\n\t * Reverse sort direction back to the original state.  This is not\n\t * actually necessary but seems like a good idea for tidiness.\n\t */\n\treversedirection(state);\n\n\tstate->status = TSS_SORTEDINMEM;\n\tstate->boundUsed = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "leader_takeover_tapes",
          "args": [
            "state"
          ],
          "line": 1831
        },
        "resolved": true,
        "details": {
          "function_name": "leader_takeover_tapes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "4513-4573",
          "snippet": "static void\nleader_takeover_tapes(Tuplesortstate *state)\n{\n\tSharedsort *shared = state->shared;\n\tint\t\t\tnParticipants = state->nParticipants;\n\tint\t\t\tworkersFinished;\n\tint\t\t\tj;\n\n\tAssert(LEADER(state));\n\tAssert(nParticipants >= 1);\n\n\tSpinLockAcquire(&shared->mutex);\n\tworkersFinished = shared->workersFinished;\n\tSpinLockRelease(&shared->mutex);\n\n\tif (nParticipants != workersFinished)\n\t\telog(ERROR, \"cannot take over tapes before all workers finish\");\n\n\t/*\n\t * Create the tapeset from worker tapes, including a leader-owned tape at\n\t * the end.  Parallel workers are far more expensive than logical tapes,\n\t * so the number of tapes allocated here should never be excessive.\n\t *\n\t * We still have a leader tape, though it's not possible to write to it\n\t * due to restrictions in the shared fileset infrastructure used by\n\t * logtape.c.  It will never be written to in practice because\n\t * randomAccess is disallowed for parallel sorts.\n\t */\n\tinittapestate(state, nParticipants + 1);\n\tstate->tapeset = LogicalTapeSetCreate(nParticipants + 1, shared->tapes,\n\t\t\t\t\t\t\t\t\t\t  &shared->fileset, state->worker);\n\n\t/* mergeruns() relies on currentRun for # of runs (in one-pass cases) */\n\tstate->currentRun = nParticipants;\n\n\t/*\n\t * Initialize variables of Algorithm D to be consistent with runs from\n\t * workers having been generated in the leader.\n\t *\n\t * There will always be exactly 1 run per worker, and exactly one input\n\t * tape per run, because workers always output exactly 1 run, even when\n\t * there were no input tuples for workers to sort.\n\t */\n\tfor (j = 0; j < state->maxTapes; j++)\n\t{\n\t\t/* One real run; no dummy runs for worker tapes */\n\t\tstate->tp_fib[j] = 1;\n\t\tstate->tp_runs[j] = 1;\n\t\tstate->tp_dummy[j] = 0;\n\t\tstate->tp_tapenum[j] = j;\n\t}\n\t/* Leader tape gets one dummy run, and no real runs */\n\tstate->tp_fib[state->tapeRange] = 0;\n\tstate->tp_runs[state->tapeRange] = 0;\n\tstate->tp_dummy[state->tapeRange] = 1;\n\n\tstate->Level = 1;\n\tstate->destTape = 0;\n\n\tstate->status = TSS_BUILDRUNS;\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);",
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void inittapes(Tuplesortstate *state, bool mergeruns);",
            "static void inittapestate(Tuplesortstate *state, int maxTapes);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void inittapes(Tuplesortstate *state, bool mergeruns);\nstatic void inittapestate(Tuplesortstate *state, int maxTapes);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic void\nleader_takeover_tapes(Tuplesortstate *state)\n{\n\tSharedsort *shared = state->shared;\n\tint\t\t\tnParticipants = state->nParticipants;\n\tint\t\t\tworkersFinished;\n\tint\t\t\tj;\n\n\tAssert(LEADER(state));\n\tAssert(nParticipants >= 1);\n\n\tSpinLockAcquire(&shared->mutex);\n\tworkersFinished = shared->workersFinished;\n\tSpinLockRelease(&shared->mutex);\n\n\tif (nParticipants != workersFinished)\n\t\telog(ERROR, \"cannot take over tapes before all workers finish\");\n\n\t/*\n\t * Create the tapeset from worker tapes, including a leader-owned tape at\n\t * the end.  Parallel workers are far more expensive than logical tapes,\n\t * so the number of tapes allocated here should never be excessive.\n\t *\n\t * We still have a leader tape, though it's not possible to write to it\n\t * due to restrictions in the shared fileset infrastructure used by\n\t * logtape.c.  It will never be written to in practice because\n\t * randomAccess is disallowed for parallel sorts.\n\t */\n\tinittapestate(state, nParticipants + 1);\n\tstate->tapeset = LogicalTapeSetCreate(nParticipants + 1, shared->tapes,\n\t\t\t\t\t\t\t\t\t\t  &shared->fileset, state->worker);\n\n\t/* mergeruns() relies on currentRun for # of runs (in one-pass cases) */\n\tstate->currentRun = nParticipants;\n\n\t/*\n\t * Initialize variables of Algorithm D to be consistent with runs from\n\t * workers having been generated in the leader.\n\t *\n\t * There will always be exactly 1 run per worker, and exactly one input\n\t * tape per run, because workers always output exactly 1 run, even when\n\t * there were no input tuples for workers to sort.\n\t */\n\tfor (j = 0; j < state->maxTapes; j++)\n\t{\n\t\t/* One real run; no dummy runs for worker tapes */\n\t\tstate->tp_fib[j] = 1;\n\t\tstate->tp_runs[j] = 1;\n\t\tstate->tp_dummy[j] = 0;\n\t\tstate->tp_tapenum[j] = j;\n\t}\n\t/* Leader tape gets one dummy run, and no real runs */\n\tstate->tp_fib[state->tapeRange] = 0;\n\tstate->tp_runs[state->tapeRange] = 0;\n\tstate->tp_dummy[state->tapeRange] = 1;\n\n\tstate->Level = 1;\n\tstate->destTape = 0;\n\n\tstate->status = TSS_BUILDRUNS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inittapes",
          "args": [
            "state",
            "false"
          ],
          "line": 1820
        },
        "resolved": true,
        "details": {
          "function_name": "inittapestate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "2448-2484",
          "snippet": "static void\ninittapestate(Tuplesortstate *state, int maxTapes)\n{\n\tint64\t\ttapeSpace;\n\n\t/*\n\t * Decrease availMem to reflect the space needed for tape buffers; but\n\t * don't decrease it to the point that we have no room for tuples. (That\n\t * case is only likely to occur if sorting pass-by-value Datums; in all\n\t * other scenarios the memtuples[] array is unlikely to occupy more than\n\t * half of allowedMem.  In the pass-by-value case it's not important to\n\t * account for tuple space, so we don't care if LACKMEM becomes\n\t * inaccurate.)\n\t */\n\ttapeSpace = (int64) maxTapes * TAPE_BUFFER_OVERHEAD;\n\n\tif (tapeSpace + GetMemoryChunkSpace(state->memtuples) < state->allowedMem)\n\t\tUSEMEM(state, tapeSpace);\n\n\t/*\n\t * Make sure that the temp file(s) underlying the tape set are created in\n\t * suitable temp tablespaces.  For parallel sorts, this should have been\n\t * called already, but it doesn't matter if it is called a second time.\n\t */\n\tPrepareTempTablespaces();\n\n\tstate->mergeactive = (bool *) palloc0(maxTapes * sizeof(bool));\n\tstate->tp_fib = (int *) palloc0(maxTapes * sizeof(int));\n\tstate->tp_runs = (int *) palloc0(maxTapes * sizeof(int));\n\tstate->tp_dummy = (int *) palloc0(maxTapes * sizeof(int));\n\tstate->tp_tapenum = (int *) palloc0(maxTapes * sizeof(int));\n\n\t/* Record # of tapes allocated (for duration of sort) */\n\tstate->maxTapes = maxTapes;\n\t/* Record maximum # of tapes usable as inputs when merging */\n\tstate->tapeRange = maxTapes - 1;\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TAPE_BUFFER_OVERHEAD\t\tBLCKSZ"
          ],
          "globals_used": [
            "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void inittapestate(Tuplesortstate *state, int maxTapes);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TAPE_BUFFER_OVERHEAD\t\tBLCKSZ\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void inittapestate(Tuplesortstate *state, int maxTapes);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic void\ninittapestate(Tuplesortstate *state, int maxTapes)\n{\n\tint64\t\ttapeSpace;\n\n\t/*\n\t * Decrease availMem to reflect the space needed for tape buffers; but\n\t * don't decrease it to the point that we have no room for tuples. (That\n\t * case is only likely to occur if sorting pass-by-value Datums; in all\n\t * other scenarios the memtuples[] array is unlikely to occupy more than\n\t * half of allowedMem.  In the pass-by-value case it's not important to\n\t * account for tuple space, so we don't care if LACKMEM becomes\n\t * inaccurate.)\n\t */\n\ttapeSpace = (int64) maxTapes * TAPE_BUFFER_OVERHEAD;\n\n\tif (tapeSpace + GetMemoryChunkSpace(state->memtuples) < state->allowedMem)\n\t\tUSEMEM(state, tapeSpace);\n\n\t/*\n\t * Make sure that the temp file(s) underlying the tape set are created in\n\t * suitable temp tablespaces.  For parallel sorts, this should have been\n\t * called already, but it doesn't matter if it is called a second time.\n\t */\n\tPrepareTempTablespaces();\n\n\tstate->mergeactive = (bool *) palloc0(maxTapes * sizeof(bool));\n\tstate->tp_fib = (int *) palloc0(maxTapes * sizeof(int));\n\tstate->tp_runs = (int *) palloc0(maxTapes * sizeof(int));\n\tstate->tp_dummy = (int *) palloc0(maxTapes * sizeof(int));\n\tstate->tp_tapenum = (int *) palloc0(maxTapes * sizeof(int));\n\n\t/* Record # of tapes allocated (for duration of sort) */\n\tstate->maxTapes = maxTapes;\n\t/* Record maximum # of tapes usable as inputs when merging */\n\tstate->tapeRange = maxTapes - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WORKER",
          "args": [
            "state"
          ],
          "line": 1814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tuplesort_sort_memtuples",
          "args": [
            "state"
          ],
          "line": 1811
        },
        "resolved": true,
        "details": {
          "function_name": "tuplesort_sort_memtuples",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "3308-3325",
          "snippet": "static void\ntuplesort_sort_memtuples(Tuplesortstate *state)\n{\n\tAssert(!LEADER(state));\n\n\tif (state->memtupcount > 1)\n\t{\n\t\t/* Can we use the single-key sort function? */\n\t\tif (state->onlyKey != NULL)\n\t\t\tqsort_ssup(state->memtuples, state->memtupcount,\n\t\t\t\t\t   state->onlyKey);\n\t\telse\n\t\t\tqsort_tuple(state->memtuples,\n\t\t\t\t\t\tstate->memtupcount,\n\t\t\t\t\t\tstate->comparetup,\n\t\t\t\t\t\tstate);\n\t}\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic void\ntuplesort_sort_memtuples(Tuplesortstate *state)\n{\n\tAssert(!LEADER(state));\n\n\tif (state->memtupcount > 1)\n\t{\n\t\t/* Can we use the single-key sort function? */\n\t\tif (state->onlyKey != NULL)\n\t\t\tqsort_ssup(state->memtuples, state->memtupcount,\n\t\t\t\t\t   state->onlyKey);\n\t\telse\n\t\t\tqsort_tuple(state->memtuples,\n\t\t\t\t\t\tstate->memtupcount,\n\t\t\t\t\t\tstate->comparetup,\n\t\t\t\t\t\tstate);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "SERIAL",
          "args": [
            "state"
          ],
          "line": 1808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "state->sortcontext"
          ],
          "line": 1792
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void inittapes(Tuplesortstate *state, bool mergeruns);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nvoid\ntuplesort_performsort(Tuplesortstate *state)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\telog(LOG, \"performsort of worker %d starting: %s\",\n\t\t\t state->worker, pg_rusage_show(&state->ru_start));\n#endif\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INITIAL:\n\n\t\t\t/*\n\t\t\t * We were able to accumulate all the tuples within the allowed\n\t\t\t * amount of memory, or leader to take over worker tapes\n\t\t\t */\n\t\t\tif (SERIAL(state))\n\t\t\t{\n\t\t\t\t/* Just qsort 'em and we're done */\n\t\t\t\ttuplesort_sort_memtuples(state);\n\t\t\t\tstate->status = TSS_SORTEDINMEM;\n\t\t\t}\n\t\t\telse if (WORKER(state))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Parallel workers must still dump out tuples to tape.  No\n\t\t\t\t * merge is required to produce single output run, though.\n\t\t\t\t */\n\t\t\t\tinittapes(state, false);\n\t\t\t\tdumptuples(state, true);\n\t\t\t\tworker_nomergeruns(state);\n\t\t\t\tstate->status = TSS_SORTEDONTAPE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Leader will take over worker tapes and merge worker runs.\n\t\t\t\t * Note that mergeruns sets the correct state->status.\n\t\t\t\t */\n\t\t\t\tleader_takeover_tapes(state);\n\t\t\t\tmergeruns(state);\n\t\t\t}\n\t\t\tstate->current = 0;\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_block = 0L;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tbreak;\n\n\t\tcase TSS_BOUNDED:\n\n\t\t\t/*\n\t\t\t * We were able to accumulate all the tuples required for output\n\t\t\t * in memory, using a heap to eliminate excess tuples.  Now we\n\t\t\t * have to transform the heap to a properly-sorted array.\n\t\t\t */\n\t\t\tsort_bounded_heap(state);\n\t\t\tstate->current = 0;\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tstate->status = TSS_SORTEDINMEM;\n\t\t\tbreak;\n\n\t\tcase TSS_BUILDRUNS:\n\n\t\t\t/*\n\t\t\t * Finish tape-based sort.  First, flush all tuples remaining in\n\t\t\t * memory out to tape; then merge until we have a single remaining\n\t\t\t * run (or, if !randomAccess and !WORKER(), one run per tape).\n\t\t\t * Note that mergeruns sets the correct state->status.\n\t\t\t */\n\t\t\tdumptuples(state, true);\n\t\t\tmergeruns(state);\n\t\t\tstate->eof_reached = false;\n\t\t\tstate->markpos_block = 0L;\n\t\t\tstate->markpos_offset = 0;\n\t\t\tstate->markpos_eof = false;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplesort state\");\n\t\t\tbreak;\n\t}\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t{\n\t\tif (state->status == TSS_FINALMERGE)\n\t\t\telog(LOG, \"performsort of worker %d done (except %d-way final merge): %s\",\n\t\t\t\t state->worker, state->activeTapes,\n\t\t\t\t pg_rusage_show(&state->ru_start));\n\t\telse\n\t\t\telog(LOG, \"performsort of worker %d done: %s\",\n\t\t\t\t state->worker, pg_rusage_show(&state->ru_start));\n\t}\n#endif\n\n\tMemoryContextSwitchTo(oldcontext);\n}"
  },
  {
    "function_name": "consider_abort_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "1745-1784",
    "snippet": "static bool\nconsider_abort_common(Tuplesortstate *state)\n{\n\tAssert(state->sortKeys[0].abbrev_converter != NULL);\n\tAssert(state->sortKeys[0].abbrev_abort != NULL);\n\tAssert(state->sortKeys[0].abbrev_full_comparator != NULL);\n\n\t/*\n\t * Check effectiveness of abbreviation optimization.  Consider aborting\n\t * when still within memory limit.\n\t */\n\tif (state->status == TSS_INITIAL &&\n\t\tstate->memtupcount >= state->abbrevNext)\n\t{\n\t\tstate->abbrevNext *= 2;\n\n\t\t/*\n\t\t * Check opclass-supplied abbreviation abort routine.  It may indicate\n\t\t * that abbreviation should not proceed.\n\t\t */\n\t\tif (!state->sortKeys->abbrev_abort(state->memtupcount,\n\t\t\t\t\t\t\t\t\t\t   state->sortKeys))\n\t\t\treturn false;\n\n\t\t/*\n\t\t * Finally, restore authoritative comparator, and indicate that\n\t\t * abbreviation is not in play by setting abbrev_converter to NULL\n\t\t */\n\t\tstate->sortKeys[0].comparator = state->sortKeys[0].abbrev_full_comparator;\n\t\tstate->sortKeys[0].abbrev_converter = NULL;\n\t\t/* Not strictly necessary, but be tidy */\n\t\tstate->sortKeys[0].abbrev_abort = NULL;\n\t\tstate->sortKeys[0].abbrev_full_comparator = NULL;\n\n\t\t/* Give up - expect original pass-by-value representation */\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "state->sortKeys->abbrev_abort",
          "args": [
            "state->memtupcount",
            "state->sortKeys"
          ],
          "line": 1765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "state->sortKeys[0].abbrev_full_comparator != NULL"
          ],
          "line": 1750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "state->sortKeys[0].abbrev_abort != NULL"
          ],
          "line": 1749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "state->sortKeys[0].abbrev_converter != NULL"
          ],
          "line": 1748
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic bool\nconsider_abort_common(Tuplesortstate *state)\n{\n\tAssert(state->sortKeys[0].abbrev_converter != NULL);\n\tAssert(state->sortKeys[0].abbrev_abort != NULL);\n\tAssert(state->sortKeys[0].abbrev_full_comparator != NULL);\n\n\t/*\n\t * Check effectiveness of abbreviation optimization.  Consider aborting\n\t * when still within memory limit.\n\t */\n\tif (state->status == TSS_INITIAL &&\n\t\tstate->memtupcount >= state->abbrevNext)\n\t{\n\t\tstate->abbrevNext *= 2;\n\n\t\t/*\n\t\t * Check opclass-supplied abbreviation abort routine.  It may indicate\n\t\t * that abbreviation should not proceed.\n\t\t */\n\t\tif (!state->sortKeys->abbrev_abort(state->memtupcount,\n\t\t\t\t\t\t\t\t\t\t   state->sortKeys))\n\t\t\treturn false;\n\n\t\t/*\n\t\t * Finally, restore authoritative comparator, and indicate that\n\t\t * abbreviation is not in play by setting abbrev_converter to NULL\n\t\t */\n\t\tstate->sortKeys[0].comparator = state->sortKeys[0].abbrev_full_comparator;\n\t\tstate->sortKeys[0].abbrev_converter = NULL;\n\t\t/* Not strictly necessary, but be tidy */\n\t\tstate->sortKeys[0].abbrev_abort = NULL;\n\t\tstate->sortKeys[0].abbrev_full_comparator = NULL;\n\n\t\t/* Give up - expect original pass-by-value representation */\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "puttuple_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "1636-1743",
    "snippet": "static void\nputtuple_common(Tuplesortstate *state, SortTuple *tuple)\n{\n\tAssert(!LEADER(state));\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INITIAL:\n\n\t\t\t/*\n\t\t\t * Save the tuple into the unsorted array.  First, grow the array\n\t\t\t * as needed.  Note that we try to grow the array when there is\n\t\t\t * still one free slot remaining --- if we fail, there'll still be\n\t\t\t * room to store the incoming tuple, and then we'll switch to\n\t\t\t * tape-based operation.\n\t\t\t */\n\t\t\tif (state->memtupcount >= state->memtupsize - 1)\n\t\t\t{\n\t\t\t\t(void) grow_memtuples(state);\n\t\t\t\tAssert(state->memtupcount < state->memtupsize);\n\t\t\t}\n\t\t\tstate->memtuples[state->memtupcount++] = *tuple;\n\n\t\t\t/*\n\t\t\t * Check if it's time to switch over to a bounded heapsort. We do\n\t\t\t * so if the input tuple count exceeds twice the desired tuple\n\t\t\t * count (this is a heuristic for where heapsort becomes cheaper\n\t\t\t * than a quicksort), or if we've just filled workMem and have\n\t\t\t * enough tuples to meet the bound.\n\t\t\t *\n\t\t\t * Note that once we enter TSS_BOUNDED state we will always try to\n\t\t\t * complete the sort that way.  In the worst case, if later input\n\t\t\t * tuples are larger than earlier ones, this might cause us to\n\t\t\t * exceed workMem significantly.\n\t\t\t */\n\t\t\tif (state->bounded &&\n\t\t\t\t(state->memtupcount > state->bound * 2 ||\n\t\t\t\t (state->memtupcount > state->bound && LACKMEM(state))))\n\t\t\t{\n#ifdef TRACE_SORT\n\t\t\t\tif (trace_sort)\n\t\t\t\t\telog(LOG, \"switching to bounded heapsort at %d tuples: %s\",\n\t\t\t\t\t\t state->memtupcount,\n\t\t\t\t\t\t pg_rusage_show(&state->ru_start));\n#endif\n\t\t\t\tmake_bounded_heap(state);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Done if we still fit in available memory and have array slots.\n\t\t\t */\n\t\t\tif (state->memtupcount < state->memtupsize && !LACKMEM(state))\n\t\t\t\treturn;\n\n\t\t\t/*\n\t\t\t * Nope; time to switch to tape-based operation.\n\t\t\t */\n\t\t\tinittapes(state, true);\n\n\t\t\t/*\n\t\t\t * Dump all tuples.\n\t\t\t */\n\t\t\tdumptuples(state, false);\n\t\t\tbreak;\n\n\t\tcase TSS_BOUNDED:\n\n\t\t\t/*\n\t\t\t * We don't want to grow the array here, so check whether the new\n\t\t\t * tuple can be discarded before putting it in.  This should be a\n\t\t\t * good speed optimization, too, since when there are many more\n\t\t\t * input tuples than the bound, most input tuples can be discarded\n\t\t\t * with just this one comparison.  Note that because we currently\n\t\t\t * have the sort direction reversed, we must check for <= not >=.\n\t\t\t */\n\t\t\tif (COMPARETUP(state, tuple, &state->memtuples[0]) <= 0)\n\t\t\t{\n\t\t\t\t/* new tuple <= top of the heap, so we can discard it */\n\t\t\t\tfree_sort_tuple(state, tuple);\n\t\t\t\tCHECK_FOR_INTERRUPTS();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* discard top of heap, replacing it with the new tuple */\n\t\t\t\tfree_sort_tuple(state, &state->memtuples[0]);\n\t\t\t\ttuplesort_heap_replace_top(state, tuple);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TSS_BUILDRUNS:\n\n\t\t\t/*\n\t\t\t * Save the tuple into the unsorted array (there must be space)\n\t\t\t */\n\t\t\tstate->memtuples[state->memtupcount++] = *tuple;\n\n\t\t\t/*\n\t\t\t * If we are over the memory limit, dump all tuples.\n\t\t\t */\n\t\t\tdumptuples(state, false);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplesort state\");\n\t\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"invalid tuplesort state\""
          ],
          "line": 1740
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dumptuples",
          "args": [
            "state",
            "false"
          ],
          "line": 1736
        },
        "resolved": true,
        "details": {
          "function_name": "dumptuples",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "2924-3022",
          "snippet": "static void\ndumptuples(Tuplesortstate *state, bool alltuples)\n{\n\tint\t\t\tmemtupwrite;\n\tint\t\t\ti;\n\n\t/*\n\t * Nothing to do if we still fit in available memory and have array slots,\n\t * unless this is the final call during initial run generation.\n\t */\n\tif (state->memtupcount < state->memtupsize && !LACKMEM(state) &&\n\t\t!alltuples)\n\t\treturn;\n\n\t/*\n\t * Final call might require no sorting, in rare cases where we just so\n\t * happen to have previously LACKMEM()'d at the point where exactly all\n\t * remaining tuples are loaded into memory, just before input was\n\t * exhausted.\n\t *\n\t * In general, short final runs are quite possible.  Rather than allowing\n\t * a special case where there was a superfluous selectnewtape() call (i.e.\n\t * a call with no subsequent run actually written to destTape), we prefer\n\t * to write out a 0 tuple run.\n\t *\n\t * mergereadnext() is prepared for 0 tuple runs, and will reliably mark\n\t * the tape inactive for the merge when called from beginmerge().  This\n\t * case is therefore similar to the case where mergeonerun() finds a dummy\n\t * run for the tape, and so doesn't need to merge a run from the tape (or\n\t * conceptually \"merges\" the dummy run, if you prefer).  According to\n\t * Knuth, Algorithm D \"isn't strictly optimal\" in its method of\n\t * distribution and dummy run assignment; this edge case seems very\n\t * unlikely to make that appreciably worse.\n\t */\n\tAssert(state->status == TSS_BUILDRUNS);\n\n\t/*\n\t * It seems unlikely that this limit will ever be exceeded, but take no\n\t * chances\n\t */\n\tif (state->currentRun == INT_MAX)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"cannot have more than %d runs for an external sort\",\n\t\t\t\t\t\tINT_MAX)));\n\n\tstate->currentRun++;\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\telog(LOG, \"worker %d starting quicksort of run %d: %s\",\n\t\t\t state->worker, state->currentRun,\n\t\t\t pg_rusage_show(&state->ru_start));\n#endif\n\n\t/*\n\t * Sort all tuples accumulated within the allowed amount of memory for\n\t * this run using quicksort\n\t */\n\ttuplesort_sort_memtuples(state);\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\telog(LOG, \"worker %d finished quicksort of run %d: %s\",\n\t\t\t state->worker, state->currentRun,\n\t\t\t pg_rusage_show(&state->ru_start));\n#endif\n\n\tmemtupwrite = state->memtupcount;\n\tfor (i = 0; i < memtupwrite; i++)\n\t{\n\t\tWRITETUP(state, state->tp_tapenum[state->destTape],\n\t\t\t\t &state->memtuples[i]);\n\t\tstate->memtupcount--;\n\t}\n\n\t/*\n\t * Reset tuple memory.  We've freed all of the tuples that we previously\n\t * allocated.  It's important to avoid fragmentation when there is a stark\n\t * change in the sizes of incoming tuples.  Fragmentation due to\n\t * AllocSetFree's bucketing by size class might be particularly bad if\n\t * this step wasn't taken.\n\t */\n\tMemoryContextReset(state->tuplecontext);\n\n\tmarkrunend(state, state->tp_tapenum[state->destTape]);\n\tstate->tp_runs[state->destTape]++;\n\tstate->tp_dummy[state->destTape]--; /* per Alg D step D2 */\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\telog(LOG, \"worker %d finished writing run %d to tape %d: %s\",\n\t\t\t state->worker, state->currentRun, state->destTape,\n\t\t\t pg_rusage_show(&state->ru_start));\n#endif\n\n\tif (!alltuples)\n\t\tselectnewtape(state);\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void dumptuples(Tuplesortstate *state, bool alltuples);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void dumptuples(Tuplesortstate *state, bool alltuples);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic void\ndumptuples(Tuplesortstate *state, bool alltuples)\n{\n\tint\t\t\tmemtupwrite;\n\tint\t\t\ti;\n\n\t/*\n\t * Nothing to do if we still fit in available memory and have array slots,\n\t * unless this is the final call during initial run generation.\n\t */\n\tif (state->memtupcount < state->memtupsize && !LACKMEM(state) &&\n\t\t!alltuples)\n\t\treturn;\n\n\t/*\n\t * Final call might require no sorting, in rare cases where we just so\n\t * happen to have previously LACKMEM()'d at the point where exactly all\n\t * remaining tuples are loaded into memory, just before input was\n\t * exhausted.\n\t *\n\t * In general, short final runs are quite possible.  Rather than allowing\n\t * a special case where there was a superfluous selectnewtape() call (i.e.\n\t * a call with no subsequent run actually written to destTape), we prefer\n\t * to write out a 0 tuple run.\n\t *\n\t * mergereadnext() is prepared for 0 tuple runs, and will reliably mark\n\t * the tape inactive for the merge when called from beginmerge().  This\n\t * case is therefore similar to the case where mergeonerun() finds a dummy\n\t * run for the tape, and so doesn't need to merge a run from the tape (or\n\t * conceptually \"merges\" the dummy run, if you prefer).  According to\n\t * Knuth, Algorithm D \"isn't strictly optimal\" in its method of\n\t * distribution and dummy run assignment; this edge case seems very\n\t * unlikely to make that appreciably worse.\n\t */\n\tAssert(state->status == TSS_BUILDRUNS);\n\n\t/*\n\t * It seems unlikely that this limit will ever be exceeded, but take no\n\t * chances\n\t */\n\tif (state->currentRun == INT_MAX)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"cannot have more than %d runs for an external sort\",\n\t\t\t\t\t\tINT_MAX)));\n\n\tstate->currentRun++;\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\telog(LOG, \"worker %d starting quicksort of run %d: %s\",\n\t\t\t state->worker, state->currentRun,\n\t\t\t pg_rusage_show(&state->ru_start));\n#endif\n\n\t/*\n\t * Sort all tuples accumulated within the allowed amount of memory for\n\t * this run using quicksort\n\t */\n\ttuplesort_sort_memtuples(state);\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\telog(LOG, \"worker %d finished quicksort of run %d: %s\",\n\t\t\t state->worker, state->currentRun,\n\t\t\t pg_rusage_show(&state->ru_start));\n#endif\n\n\tmemtupwrite = state->memtupcount;\n\tfor (i = 0; i < memtupwrite; i++)\n\t{\n\t\tWRITETUP(state, state->tp_tapenum[state->destTape],\n\t\t\t\t &state->memtuples[i]);\n\t\tstate->memtupcount--;\n\t}\n\n\t/*\n\t * Reset tuple memory.  We've freed all of the tuples that we previously\n\t * allocated.  It's important to avoid fragmentation when there is a stark\n\t * change in the sizes of incoming tuples.  Fragmentation due to\n\t * AllocSetFree's bucketing by size class might be particularly bad if\n\t * this step wasn't taken.\n\t */\n\tMemoryContextReset(state->tuplecontext);\n\n\tmarkrunend(state, state->tp_tapenum[state->destTape]);\n\tstate->tp_runs[state->destTape]++;\n\tstate->tp_dummy[state->destTape]--; /* per Alg D step D2 */\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\telog(LOG, \"worker %d finished writing run %d to tape %d: %s\",\n\t\t\t state->worker, state->currentRun, state->destTape,\n\t\t\t pg_rusage_show(&state->ru_start));\n#endif\n\n\tif (!alltuples)\n\t\tselectnewtape(state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tuplesort_heap_replace_top",
          "args": [
            "state",
            "tuple"
          ],
          "line": 1722
        },
        "resolved": true,
        "details": {
          "function_name": "tuplesort_heap_replace_top",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "3395-3428",
          "snippet": "static void\ntuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple)\n{\n\tSortTuple  *memtuples = state->memtuples;\n\tunsigned int i,\n\t\t\t\tn;\n\n\tAssert(state->memtupcount >= 1);\n\n\tCHECK_FOR_INTERRUPTS();\n\n\t/*\n\t * state->memtupcount is \"int\", but we use \"unsigned int\" for i, j, n.\n\t * This prevents overflow in the \"2 * i + 1\" calculation, since at the top\n\t * of the loop we must have i < n <= INT_MAX <= UINT_MAX/2.\n\t */\n\tn = state->memtupcount;\n\ti = 0;\t\t\t\t\t\t/* i is where the \"hole\" is */\n\tfor (;;)\n\t{\n\t\tunsigned int j = 2 * i + 1;\n\n\t\tif (j >= n)\n\t\t\tbreak;\n\t\tif (j + 1 < n &&\n\t\t\tCOMPARETUP(state, &memtuples[j], &memtuples[j + 1]) > 0)\n\t\t\tj++;\n\t\tif (COMPARETUP(state, tuple, &memtuples[j]) <= 0)\n\t\t\tbreak;\n\t\tmemtuples[i] = memtuples[j];\n\t\ti = j;\n\t}\n\tmemtuples[i] = *tuple;\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic void\ntuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple)\n{\n\tSortTuple  *memtuples = state->memtuples;\n\tunsigned int i,\n\t\t\t\tn;\n\n\tAssert(state->memtupcount >= 1);\n\n\tCHECK_FOR_INTERRUPTS();\n\n\t/*\n\t * state->memtupcount is \"int\", but we use \"unsigned int\" for i, j, n.\n\t * This prevents overflow in the \"2 * i + 1\" calculation, since at the top\n\t * of the loop we must have i < n <= INT_MAX <= UINT_MAX/2.\n\t */\n\tn = state->memtupcount;\n\ti = 0;\t\t\t\t\t\t/* i is where the \"hole\" is */\n\tfor (;;)\n\t{\n\t\tunsigned int j = 2 * i + 1;\n\n\t\tif (j >= n)\n\t\t\tbreak;\n\t\tif (j + 1 < n &&\n\t\t\tCOMPARETUP(state, &memtuples[j], &memtuples[j + 1]) > 0)\n\t\t\tj++;\n\t\tif (COMPARETUP(state, tuple, &memtuples[j]) <= 0)\n\t\t\tbreak;\n\t\tmemtuples[i] = memtuples[j];\n\t\ti = j;\n\t}\n\tmemtuples[i] = *tuple;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_sort_tuple",
          "args": [
            "state",
            "&state->memtuples[0]"
          ],
          "line": 1721
        },
        "resolved": true,
        "details": {
          "function_name": "free_sort_tuple",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "4578-4583",
          "snippet": "static void\nfree_sort_tuple(Tuplesortstate *state, SortTuple *stup)\n{\n\tFREEMEM(state, GetMemoryChunkSpace(stup->tuple));\n\tpfree(stup->tuple);\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);",
            "static void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\nstatic void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);\n\nstatic void\nfree_sort_tuple(Tuplesortstate *state, SortTuple *stup)\n{\n\tFREEMEM(state, GetMemoryChunkSpace(stup->tuple));\n\tpfree(stup->tuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHECK_FOR_INTERRUPTS",
          "args": [],
          "line": 1716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COMPARETUP",
          "args": [
            "state",
            "tuple",
            "&state->memtuples[0]"
          ],
          "line": 1712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inittapes",
          "args": [
            "state",
            "true"
          ],
          "line": 1694
        },
        "resolved": true,
        "details": {
          "function_name": "inittapestate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "2448-2484",
          "snippet": "static void\ninittapestate(Tuplesortstate *state, int maxTapes)\n{\n\tint64\t\ttapeSpace;\n\n\t/*\n\t * Decrease availMem to reflect the space needed for tape buffers; but\n\t * don't decrease it to the point that we have no room for tuples. (That\n\t * case is only likely to occur if sorting pass-by-value Datums; in all\n\t * other scenarios the memtuples[] array is unlikely to occupy more than\n\t * half of allowedMem.  In the pass-by-value case it's not important to\n\t * account for tuple space, so we don't care if LACKMEM becomes\n\t * inaccurate.)\n\t */\n\ttapeSpace = (int64) maxTapes * TAPE_BUFFER_OVERHEAD;\n\n\tif (tapeSpace + GetMemoryChunkSpace(state->memtuples) < state->allowedMem)\n\t\tUSEMEM(state, tapeSpace);\n\n\t/*\n\t * Make sure that the temp file(s) underlying the tape set are created in\n\t * suitable temp tablespaces.  For parallel sorts, this should have been\n\t * called already, but it doesn't matter if it is called a second time.\n\t */\n\tPrepareTempTablespaces();\n\n\tstate->mergeactive = (bool *) palloc0(maxTapes * sizeof(bool));\n\tstate->tp_fib = (int *) palloc0(maxTapes * sizeof(int));\n\tstate->tp_runs = (int *) palloc0(maxTapes * sizeof(int));\n\tstate->tp_dummy = (int *) palloc0(maxTapes * sizeof(int));\n\tstate->tp_tapenum = (int *) palloc0(maxTapes * sizeof(int));\n\n\t/* Record # of tapes allocated (for duration of sort) */\n\tstate->maxTapes = maxTapes;\n\t/* Record maximum # of tapes usable as inputs when merging */\n\tstate->tapeRange = maxTapes - 1;\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TAPE_BUFFER_OVERHEAD\t\tBLCKSZ"
          ],
          "globals_used": [
            "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void inittapestate(Tuplesortstate *state, int maxTapes);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TAPE_BUFFER_OVERHEAD\t\tBLCKSZ\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void inittapestate(Tuplesortstate *state, int maxTapes);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic void\ninittapestate(Tuplesortstate *state, int maxTapes)\n{\n\tint64\t\ttapeSpace;\n\n\t/*\n\t * Decrease availMem to reflect the space needed for tape buffers; but\n\t * don't decrease it to the point that we have no room for tuples. (That\n\t * case is only likely to occur if sorting pass-by-value Datums; in all\n\t * other scenarios the memtuples[] array is unlikely to occupy more than\n\t * half of allowedMem.  In the pass-by-value case it's not important to\n\t * account for tuple space, so we don't care if LACKMEM becomes\n\t * inaccurate.)\n\t */\n\ttapeSpace = (int64) maxTapes * TAPE_BUFFER_OVERHEAD;\n\n\tif (tapeSpace + GetMemoryChunkSpace(state->memtuples) < state->allowedMem)\n\t\tUSEMEM(state, tapeSpace);\n\n\t/*\n\t * Make sure that the temp file(s) underlying the tape set are created in\n\t * suitable temp tablespaces.  For parallel sorts, this should have been\n\t * called already, but it doesn't matter if it is called a second time.\n\t */\n\tPrepareTempTablespaces();\n\n\tstate->mergeactive = (bool *) palloc0(maxTapes * sizeof(bool));\n\tstate->tp_fib = (int *) palloc0(maxTapes * sizeof(int));\n\tstate->tp_runs = (int *) palloc0(maxTapes * sizeof(int));\n\tstate->tp_dummy = (int *) palloc0(maxTapes * sizeof(int));\n\tstate->tp_tapenum = (int *) palloc0(maxTapes * sizeof(int));\n\n\t/* Record # of tapes allocated (for duration of sort) */\n\tstate->maxTapes = maxTapes;\n\t/* Record maximum # of tapes usable as inputs when merging */\n\tstate->tapeRange = maxTapes - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LACKMEM",
          "args": [
            "state"
          ],
          "line": 1688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_bounded_heap",
          "args": [
            "state"
          ],
          "line": 1681
        },
        "resolved": true,
        "details": {
          "function_name": "make_bounded_heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "3219-3263",
          "snippet": "static void\nmake_bounded_heap(Tuplesortstate *state)\n{\n\tint\t\t\ttupcount = state->memtupcount;\n\tint\t\t\ti;\n\n\tAssert(state->status == TSS_INITIAL);\n\tAssert(state->bounded);\n\tAssert(tupcount >= state->bound);\n\tAssert(SERIAL(state));\n\n\t/* Reverse sort direction so largest entry will be at root */\n\treversedirection(state);\n\n\tstate->memtupcount = 0;\t\t/* make the heap empty */\n\tfor (i = 0; i < tupcount; i++)\n\t{\n\t\tif (state->memtupcount < state->bound)\n\t\t{\n\t\t\t/* Insert next tuple into heap */\n\t\t\t/* Must copy source tuple to avoid possible overwrite */\n\t\t\tSortTuple\tstup = state->memtuples[i];\n\n\t\t\ttuplesort_heap_insert(state, &stup);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * The heap is full.  Replace the largest entry with the new\n\t\t\t * tuple, or just discard it, if it's larger than anything already\n\t\t\t * in the heap.\n\t\t\t */\n\t\t\tif (COMPARETUP(state, &state->memtuples[i], &state->memtuples[0]) <= 0)\n\t\t\t{\n\t\t\t\tfree_sort_tuple(state, &state->memtuples[i]);\n\t\t\t\tCHECK_FOR_INTERRUPTS();\n\t\t\t}\n\t\t\telse\n\t\t\t\ttuplesort_heap_replace_top(state, &state->memtuples[i]);\n\t\t}\n\t}\n\n\tAssert(state->memtupcount == state->bound);\n\tstate->status = TSS_BOUNDED;\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);",
            "static void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\nstatic void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);\n\nstatic void\nmake_bounded_heap(Tuplesortstate *state)\n{\n\tint\t\t\ttupcount = state->memtupcount;\n\tint\t\t\ti;\n\n\tAssert(state->status == TSS_INITIAL);\n\tAssert(state->bounded);\n\tAssert(tupcount >= state->bound);\n\tAssert(SERIAL(state));\n\n\t/* Reverse sort direction so largest entry will be at root */\n\treversedirection(state);\n\n\tstate->memtupcount = 0;\t\t/* make the heap empty */\n\tfor (i = 0; i < tupcount; i++)\n\t{\n\t\tif (state->memtupcount < state->bound)\n\t\t{\n\t\t\t/* Insert next tuple into heap */\n\t\t\t/* Must copy source tuple to avoid possible overwrite */\n\t\t\tSortTuple\tstup = state->memtuples[i];\n\n\t\t\ttuplesort_heap_insert(state, &stup);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * The heap is full.  Replace the largest entry with the new\n\t\t\t * tuple, or just discard it, if it's larger than anything already\n\t\t\t * in the heap.\n\t\t\t */\n\t\t\tif (COMPARETUP(state, &state->memtuples[i], &state->memtuples[0]) <= 0)\n\t\t\t{\n\t\t\t\tfree_sort_tuple(state, &state->memtuples[i]);\n\t\t\t\tCHECK_FOR_INTERRUPTS();\n\t\t\t}\n\t\t\telse\n\t\t\t\ttuplesort_heap_replace_top(state, &state->memtuples[i]);\n\t\t}\n\t}\n\n\tAssert(state->memtupcount == state->bound);\n\tstate->status = TSS_BOUNDED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_rusage_show",
          "args": [
            "&state->ru_start"
          ],
          "line": 1679
        },
        "resolved": true,
        "details": {
          "function_name": "pg_rusage_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/pg_rusage.c",
          "lines": "39-73",
          "snippet": "const char *\npg_rusage_show(const PGRUsage *ru0)\n{\n\tstatic char result[100];\n\tPGRUsage\tru1;\n\n\tpg_rusage_init(&ru1);\n\n\tif (ru1.tv.tv_usec < ru0->tv.tv_usec)\n\t{\n\t\tru1.tv.tv_sec--;\n\t\tru1.tv.tv_usec += 1000000;\n\t}\n\tif (ru1.ru.ru_stime.tv_usec < ru0->ru.ru_stime.tv_usec)\n\t{\n\t\tru1.ru.ru_stime.tv_sec--;\n\t\tru1.ru.ru_stime.tv_usec += 1000000;\n\t}\n\tif (ru1.ru.ru_utime.tv_usec < ru0->ru.ru_utime.tv_usec)\n\t{\n\t\tru1.ru.ru_utime.tv_sec--;\n\t\tru1.ru.ru_utime.tv_usec += 1000000;\n\t}\n\n\tsnprintf(result, sizeof(result),\n\t\t\t _(\"CPU: user: %d.%02d s, system: %d.%02d s, elapsed: %d.%02d s\"),\n\t\t\t (int) (ru1.ru.ru_utime.tv_sec - ru0->ru.ru_utime.tv_sec),\n\t\t\t (int) (ru1.ru.ru_utime.tv_usec - ru0->ru.ru_utime.tv_usec) / 10000,\n\t\t\t (int) (ru1.ru.ru_stime.tv_sec - ru0->ru.ru_stime.tv_sec),\n\t\t\t (int) (ru1.ru.ru_stime.tv_usec - ru0->ru.ru_stime.tv_usec) / 10000,\n\t\t\t (int) (ru1.tv.tv_sec - ru0->tv.tv_sec),\n\t\t\t (int) (ru1.tv.tv_usec - ru0->tv.tv_usec) / 10000);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/pg_rusage.h\"",
            "#include <unistd.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_rusage.h\"\n#include <unistd.h>\n#include \"postgres.h\"\n\nconst char *\npg_rusage_show(const PGRUsage *ru0)\n{\n\tstatic char result[100];\n\tPGRUsage\tru1;\n\n\tpg_rusage_init(&ru1);\n\n\tif (ru1.tv.tv_usec < ru0->tv.tv_usec)\n\t{\n\t\tru1.tv.tv_sec--;\n\t\tru1.tv.tv_usec += 1000000;\n\t}\n\tif (ru1.ru.ru_stime.tv_usec < ru0->ru.ru_stime.tv_usec)\n\t{\n\t\tru1.ru.ru_stime.tv_sec--;\n\t\tru1.ru.ru_stime.tv_usec += 1000000;\n\t}\n\tif (ru1.ru.ru_utime.tv_usec < ru0->ru.ru_utime.tv_usec)\n\t{\n\t\tru1.ru.ru_utime.tv_sec--;\n\t\tru1.ru.ru_utime.tv_usec += 1000000;\n\t}\n\n\tsnprintf(result, sizeof(result),\n\t\t\t _(\"CPU: user: %d.%02d s, system: %d.%02d s, elapsed: %d.%02d s\"),\n\t\t\t (int) (ru1.ru.ru_utime.tv_sec - ru0->ru.ru_utime.tv_sec),\n\t\t\t (int) (ru1.ru.ru_utime.tv_usec - ru0->ru.ru_utime.tv_usec) / 10000,\n\t\t\t (int) (ru1.ru.ru_stime.tv_sec - ru0->ru.ru_stime.tv_sec),\n\t\t\t (int) (ru1.ru.ru_stime.tv_usec - ru0->ru.ru_stime.tv_usec) / 10000,\n\t\t\t (int) (ru1.tv.tv_sec - ru0->tv.tv_sec),\n\t\t\t (int) (ru1.tv.tv_usec - ru0->tv.tv_usec) / 10000);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LACKMEM",
          "args": [
            "state"
          ],
          "line": 1673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "state->memtupcount < state->memtupsize"
          ],
          "line": 1655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grow_memtuples",
          "args": [
            "state"
          ],
          "line": 1654
        },
        "resolved": true,
        "details": {
          "function_name": "grow_memtuples",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "1314-1426",
          "snippet": "static bool\ngrow_memtuples(Tuplesortstate *state)\n{\n\tint\t\t\tnewmemtupsize;\n\tint\t\t\tmemtupsize = state->memtupsize;\n\tint64\t\tmemNowUsed = state->allowedMem - state->availMem;\n\n\t/* Forget it if we've already maxed out memtuples, per comment above */\n\tif (!state->growmemtuples)\n\t\treturn false;\n\n\t/* Select new value of memtupsize */\n\tif (memNowUsed <= state->availMem)\n\t{\n\t\t/*\n\t\t * We've used no more than half of allowedMem; double our usage,\n\t\t * clamping at INT_MAX tuples.\n\t\t */\n\t\tif (memtupsize < INT_MAX / 2)\n\t\t\tnewmemtupsize = memtupsize * 2;\n\t\telse\n\t\t{\n\t\t\tnewmemtupsize = INT_MAX;\n\t\t\tstate->growmemtuples = false;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * This will be the last increment of memtupsize.  Abandon doubling\n\t\t * strategy and instead increase as much as we safely can.\n\t\t *\n\t\t * To stay within allowedMem, we can't increase memtupsize by more\n\t\t * than availMem / sizeof(SortTuple) elements.  In practice, we want\n\t\t * to increase it by considerably less, because we need to leave some\n\t\t * space for the tuples to which the new array slots will refer.  We\n\t\t * assume the new tuples will be about the same size as the tuples\n\t\t * we've already seen, and thus we can extrapolate from the space\n\t\t * consumption so far to estimate an appropriate new size for the\n\t\t * memtuples array.  The optimal value might be higher or lower than\n\t\t * this estimate, but it's hard to know that in advance.  We again\n\t\t * clamp at INT_MAX tuples.\n\t\t *\n\t\t * This calculation is safe against enlarging the array so much that\n\t\t * LACKMEM becomes true, because the memory currently used includes\n\t\t * the present array; thus, there would be enough allowedMem for the\n\t\t * new array elements even if no other memory were currently used.\n\t\t *\n\t\t * We do the arithmetic in float8, because otherwise the product of\n\t\t * memtupsize and allowedMem could overflow.  Any inaccuracy in the\n\t\t * result should be insignificant; but even if we computed a\n\t\t * completely insane result, the checks below will prevent anything\n\t\t * really bad from happening.\n\t\t */\n\t\tdouble\t\tgrow_ratio;\n\n\t\tgrow_ratio = (double) state->allowedMem / (double) memNowUsed;\n\t\tif (memtupsize * grow_ratio < INT_MAX)\n\t\t\tnewmemtupsize = (int) (memtupsize * grow_ratio);\n\t\telse\n\t\t\tnewmemtupsize = INT_MAX;\n\n\t\t/* We won't make any further enlargement attempts */\n\t\tstate->growmemtuples = false;\n\t}\n\n\t/* Must enlarge array by at least one element, else report failure */\n\tif (newmemtupsize <= memtupsize)\n\t\tgoto noalloc;\n\n\t/*\n\t * On a 32-bit machine, allowedMem could exceed MaxAllocHugeSize.  Clamp\n\t * to ensure our request won't be rejected.  Note that we can easily\n\t * exhaust address space before facing this outcome.  (This is presently\n\t * impossible due to guc.c's MAX_KILOBYTES limitation on work_mem, but\n\t * don't rely on that at this distance.)\n\t */\n\tif ((Size) newmemtupsize >= MaxAllocHugeSize / sizeof(SortTuple))\n\t{\n\t\tnewmemtupsize = (int) (MaxAllocHugeSize / sizeof(SortTuple));\n\t\tstate->growmemtuples = false;\t/* can't grow any more */\n\t}\n\n\t/*\n\t * We need to be sure that we do not cause LACKMEM to become true, else\n\t * the space management algorithm will go nuts.  The code above should\n\t * never generate a dangerous request, but to be safe, check explicitly\n\t * that the array growth fits within availMem.  (We could still cause\n\t * LACKMEM if the memory chunk overhead associated with the memtuples\n\t * array were to increase.  That shouldn't happen because we chose the\n\t * initial array size large enough to ensure that palloc will be treating\n\t * both old and new arrays as separate chunks.  But we'll check LACKMEM\n\t * explicitly below just in case.)\n\t */\n\tif (state->availMem < (int64) ((newmemtupsize - memtupsize) * sizeof(SortTuple)))\n\t\tgoto noalloc;\n\n\t/* OK, do it */\n\tFREEMEM(state, GetMemoryChunkSpace(state->memtuples));\n\tstate->memtupsize = newmemtupsize;\n\tstate->memtuples = (SortTuple *)\n\t\trepalloc_huge(state->memtuples,\n\t\t\t\t\t  state->memtupsize * sizeof(SortTuple));\n\tUSEMEM(state, GetMemoryChunkSpace(state->memtuples));\n\tif (LACKMEM(state))\n\t\telog(ERROR, \"unexpected out-of-memory situation in tuplesort\");\n\treturn true;\n\nnoalloc:\n\t/* If for any reason we didn't realloc, shut off future attempts */\n\tstate->growmemtuples = false;\n\treturn false;\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic bool\ngrow_memtuples(Tuplesortstate *state)\n{\n\tint\t\t\tnewmemtupsize;\n\tint\t\t\tmemtupsize = state->memtupsize;\n\tint64\t\tmemNowUsed = state->allowedMem - state->availMem;\n\n\t/* Forget it if we've already maxed out memtuples, per comment above */\n\tif (!state->growmemtuples)\n\t\treturn false;\n\n\t/* Select new value of memtupsize */\n\tif (memNowUsed <= state->availMem)\n\t{\n\t\t/*\n\t\t * We've used no more than half of allowedMem; double our usage,\n\t\t * clamping at INT_MAX tuples.\n\t\t */\n\t\tif (memtupsize < INT_MAX / 2)\n\t\t\tnewmemtupsize = memtupsize * 2;\n\t\telse\n\t\t{\n\t\t\tnewmemtupsize = INT_MAX;\n\t\t\tstate->growmemtuples = false;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * This will be the last increment of memtupsize.  Abandon doubling\n\t\t * strategy and instead increase as much as we safely can.\n\t\t *\n\t\t * To stay within allowedMem, we can't increase memtupsize by more\n\t\t * than availMem / sizeof(SortTuple) elements.  In practice, we want\n\t\t * to increase it by considerably less, because we need to leave some\n\t\t * space for the tuples to which the new array slots will refer.  We\n\t\t * assume the new tuples will be about the same size as the tuples\n\t\t * we've already seen, and thus we can extrapolate from the space\n\t\t * consumption so far to estimate an appropriate new size for the\n\t\t * memtuples array.  The optimal value might be higher or lower than\n\t\t * this estimate, but it's hard to know that in advance.  We again\n\t\t * clamp at INT_MAX tuples.\n\t\t *\n\t\t * This calculation is safe against enlarging the array so much that\n\t\t * LACKMEM becomes true, because the memory currently used includes\n\t\t * the present array; thus, there would be enough allowedMem for the\n\t\t * new array elements even if no other memory were currently used.\n\t\t *\n\t\t * We do the arithmetic in float8, because otherwise the product of\n\t\t * memtupsize and allowedMem could overflow.  Any inaccuracy in the\n\t\t * result should be insignificant; but even if we computed a\n\t\t * completely insane result, the checks below will prevent anything\n\t\t * really bad from happening.\n\t\t */\n\t\tdouble\t\tgrow_ratio;\n\n\t\tgrow_ratio = (double) state->allowedMem / (double) memNowUsed;\n\t\tif (memtupsize * grow_ratio < INT_MAX)\n\t\t\tnewmemtupsize = (int) (memtupsize * grow_ratio);\n\t\telse\n\t\t\tnewmemtupsize = INT_MAX;\n\n\t\t/* We won't make any further enlargement attempts */\n\t\tstate->growmemtuples = false;\n\t}\n\n\t/* Must enlarge array by at least one element, else report failure */\n\tif (newmemtupsize <= memtupsize)\n\t\tgoto noalloc;\n\n\t/*\n\t * On a 32-bit machine, allowedMem could exceed MaxAllocHugeSize.  Clamp\n\t * to ensure our request won't be rejected.  Note that we can easily\n\t * exhaust address space before facing this outcome.  (This is presently\n\t * impossible due to guc.c's MAX_KILOBYTES limitation on work_mem, but\n\t * don't rely on that at this distance.)\n\t */\n\tif ((Size) newmemtupsize >= MaxAllocHugeSize / sizeof(SortTuple))\n\t{\n\t\tnewmemtupsize = (int) (MaxAllocHugeSize / sizeof(SortTuple));\n\t\tstate->growmemtuples = false;\t/* can't grow any more */\n\t}\n\n\t/*\n\t * We need to be sure that we do not cause LACKMEM to become true, else\n\t * the space management algorithm will go nuts.  The code above should\n\t * never generate a dangerous request, but to be safe, check explicitly\n\t * that the array growth fits within availMem.  (We could still cause\n\t * LACKMEM if the memory chunk overhead associated with the memtuples\n\t * array were to increase.  That shouldn't happen because we chose the\n\t * initial array size large enough to ensure that palloc will be treating\n\t * both old and new arrays as separate chunks.  But we'll check LACKMEM\n\t * explicitly below just in case.)\n\t */\n\tif (state->availMem < (int64) ((newmemtupsize - memtupsize) * sizeof(SortTuple)))\n\t\tgoto noalloc;\n\n\t/* OK, do it */\n\tFREEMEM(state, GetMemoryChunkSpace(state->memtuples));\n\tstate->memtupsize = newmemtupsize;\n\tstate->memtuples = (SortTuple *)\n\t\trepalloc_huge(state->memtuples,\n\t\t\t\t\t  state->memtupsize * sizeof(SortTuple));\n\tUSEMEM(state, GetMemoryChunkSpace(state->memtuples));\n\tif (LACKMEM(state))\n\t\telog(ERROR, \"unexpected out-of-memory situation in tuplesort\");\n\treturn true;\n\nnoalloc:\n\t/* If for any reason we didn't realloc, shut off future attempts */\n\tstate->growmemtuples = false;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!LEADER(state)"
          ],
          "line": 1639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LEADER",
          "args": [
            "state"
          ],
          "line": 1639
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic void\nputtuple_common(Tuplesortstate *state, SortTuple *tuple)\n{\n\tAssert(!LEADER(state));\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INITIAL:\n\n\t\t\t/*\n\t\t\t * Save the tuple into the unsorted array.  First, grow the array\n\t\t\t * as needed.  Note that we try to grow the array when there is\n\t\t\t * still one free slot remaining --- if we fail, there'll still be\n\t\t\t * room to store the incoming tuple, and then we'll switch to\n\t\t\t * tape-based operation.\n\t\t\t */\n\t\t\tif (state->memtupcount >= state->memtupsize - 1)\n\t\t\t{\n\t\t\t\t(void) grow_memtuples(state);\n\t\t\t\tAssert(state->memtupcount < state->memtupsize);\n\t\t\t}\n\t\t\tstate->memtuples[state->memtupcount++] = *tuple;\n\n\t\t\t/*\n\t\t\t * Check if it's time to switch over to a bounded heapsort. We do\n\t\t\t * so if the input tuple count exceeds twice the desired tuple\n\t\t\t * count (this is a heuristic for where heapsort becomes cheaper\n\t\t\t * than a quicksort), or if we've just filled workMem and have\n\t\t\t * enough tuples to meet the bound.\n\t\t\t *\n\t\t\t * Note that once we enter TSS_BOUNDED state we will always try to\n\t\t\t * complete the sort that way.  In the worst case, if later input\n\t\t\t * tuples are larger than earlier ones, this might cause us to\n\t\t\t * exceed workMem significantly.\n\t\t\t */\n\t\t\tif (state->bounded &&\n\t\t\t\t(state->memtupcount > state->bound * 2 ||\n\t\t\t\t (state->memtupcount > state->bound && LACKMEM(state))))\n\t\t\t{\n#ifdef TRACE_SORT\n\t\t\t\tif (trace_sort)\n\t\t\t\t\telog(LOG, \"switching to bounded heapsort at %d tuples: %s\",\n\t\t\t\t\t\t state->memtupcount,\n\t\t\t\t\t\t pg_rusage_show(&state->ru_start));\n#endif\n\t\t\t\tmake_bounded_heap(state);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Done if we still fit in available memory and have array slots.\n\t\t\t */\n\t\t\tif (state->memtupcount < state->memtupsize && !LACKMEM(state))\n\t\t\t\treturn;\n\n\t\t\t/*\n\t\t\t * Nope; time to switch to tape-based operation.\n\t\t\t */\n\t\t\tinittapes(state, true);\n\n\t\t\t/*\n\t\t\t * Dump all tuples.\n\t\t\t */\n\t\t\tdumptuples(state, false);\n\t\t\tbreak;\n\n\t\tcase TSS_BOUNDED:\n\n\t\t\t/*\n\t\t\t * We don't want to grow the array here, so check whether the new\n\t\t\t * tuple can be discarded before putting it in.  This should be a\n\t\t\t * good speed optimization, too, since when there are many more\n\t\t\t * input tuples than the bound, most input tuples can be discarded\n\t\t\t * with just this one comparison.  Note that because we currently\n\t\t\t * have the sort direction reversed, we must check for <= not >=.\n\t\t\t */\n\t\t\tif (COMPARETUP(state, tuple, &state->memtuples[0]) <= 0)\n\t\t\t{\n\t\t\t\t/* new tuple <= top of the heap, so we can discard it */\n\t\t\t\tfree_sort_tuple(state, tuple);\n\t\t\t\tCHECK_FOR_INTERRUPTS();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* discard top of heap, replacing it with the new tuple */\n\t\t\t\tfree_sort_tuple(state, &state->memtuples[0]);\n\t\t\t\ttuplesort_heap_replace_top(state, tuple);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TSS_BUILDRUNS:\n\n\t\t\t/*\n\t\t\t * Save the tuple into the unsorted array (there must be space)\n\t\t\t */\n\t\t\tstate->memtuples[state->memtupcount++] = *tuple;\n\n\t\t\t/*\n\t\t\t * If we are over the memory limit, dump all tuples.\n\t\t\t */\n\t\t\tdumptuples(state, false);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplesort state\");\n\t\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "tuplesort_putdatum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "1554-1631",
    "snippet": "void\ntuplesort_putdatum(Tuplesortstate *state, Datum val, bool isNull)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->tuplecontext);\n\tSortTuple\tstup;\n\n\t/*\n\t * Pass-by-value types or null values are just stored directly in\n\t * stup.datum1 (and stup.tuple is not used and set to NULL).\n\t *\n\t * Non-null pass-by-reference values need to be copied into memory we\n\t * control, and possibly abbreviated. The copied value is pointed to by\n\t * stup.tuple and is treated as the canonical copy (e.g. to return via\n\t * tuplesort_getdatum or when writing to tape); stup.datum1 gets the\n\t * abbreviated value if abbreviation is happening, otherwise it's\n\t * identical to stup.tuple.\n\t */\n\n\tif (isNull || !state->tuples)\n\t{\n\t\t/*\n\t\t * Set datum1 to zeroed representation for NULLs (to be consistent,\n\t\t * and to support cheap inequality tests for NULL abbreviated keys).\n\t\t */\n\t\tstup.datum1 = !isNull ? val : (Datum) 0;\n\t\tstup.isnull1 = isNull;\n\t\tstup.tuple = NULL;\t\t/* no separate storage */\n\t\tMemoryContextSwitchTo(state->sortcontext);\n\t}\n\telse\n\t{\n\t\tDatum\t\toriginal = datumCopy(val, false, state->datumTypeLen);\n\n\t\tstup.isnull1 = false;\n\t\tstup.tuple = DatumGetPointer(original);\n\t\tUSEMEM(state, GetMemoryChunkSpace(stup.tuple));\n\t\tMemoryContextSwitchTo(state->sortcontext);\n\n\t\tif (!state->sortKeys->abbrev_converter)\n\t\t{\n\t\t\tstup.datum1 = original;\n\t\t}\n\t\telse if (!consider_abort_common(state))\n\t\t{\n\t\t\t/* Store abbreviated key representation */\n\t\t\tstup.datum1 = state->sortKeys->abbrev_converter(original,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstate->sortKeys);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Abort abbreviation */\n\t\t\tint\t\t\ti;\n\n\t\t\tstup.datum1 = original;\n\n\t\t\t/*\n\t\t\t * Set state to be consistent with never trying abbreviation.\n\t\t\t *\n\t\t\t * Alter datum1 representation in already-copied tuples, so as to\n\t\t\t * ensure a consistent representation (current tuple was just\n\t\t\t * handled).  It does not matter if some dumped tuples are already\n\t\t\t * sorted on tape, since serialized tuples lack abbreviated keys\n\t\t\t * (TSS_BUILDRUNS state prevents control reaching here in any\n\t\t\t * case).\n\t\t\t */\n\t\t\tfor (i = 0; i < state->memtupcount; i++)\n\t\t\t{\n\t\t\t\tSortTuple  *mtup = &state->memtuples[i];\n\n\t\t\t\tmtup->datum1 = PointerGetDatum(mtup->tuple);\n\t\t\t}\n\t\t}\n\t}\n\n\tputtuple_common(state, &stup);\n\n\tMemoryContextSwitchTo(oldcontext);\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);",
      "static void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 1630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "puttuple_common",
          "args": [
            "state",
            "&stup"
          ],
          "line": 1628
        },
        "resolved": true,
        "details": {
          "function_name": "puttuple_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "1636-1743",
          "snippet": "static void\nputtuple_common(Tuplesortstate *state, SortTuple *tuple)\n{\n\tAssert(!LEADER(state));\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INITIAL:\n\n\t\t\t/*\n\t\t\t * Save the tuple into the unsorted array.  First, grow the array\n\t\t\t * as needed.  Note that we try to grow the array when there is\n\t\t\t * still one free slot remaining --- if we fail, there'll still be\n\t\t\t * room to store the incoming tuple, and then we'll switch to\n\t\t\t * tape-based operation.\n\t\t\t */\n\t\t\tif (state->memtupcount >= state->memtupsize - 1)\n\t\t\t{\n\t\t\t\t(void) grow_memtuples(state);\n\t\t\t\tAssert(state->memtupcount < state->memtupsize);\n\t\t\t}\n\t\t\tstate->memtuples[state->memtupcount++] = *tuple;\n\n\t\t\t/*\n\t\t\t * Check if it's time to switch over to a bounded heapsort. We do\n\t\t\t * so if the input tuple count exceeds twice the desired tuple\n\t\t\t * count (this is a heuristic for where heapsort becomes cheaper\n\t\t\t * than a quicksort), or if we've just filled workMem and have\n\t\t\t * enough tuples to meet the bound.\n\t\t\t *\n\t\t\t * Note that once we enter TSS_BOUNDED state we will always try to\n\t\t\t * complete the sort that way.  In the worst case, if later input\n\t\t\t * tuples are larger than earlier ones, this might cause us to\n\t\t\t * exceed workMem significantly.\n\t\t\t */\n\t\t\tif (state->bounded &&\n\t\t\t\t(state->memtupcount > state->bound * 2 ||\n\t\t\t\t (state->memtupcount > state->bound && LACKMEM(state))))\n\t\t\t{\n#ifdef TRACE_SORT\n\t\t\t\tif (trace_sort)\n\t\t\t\t\telog(LOG, \"switching to bounded heapsort at %d tuples: %s\",\n\t\t\t\t\t\t state->memtupcount,\n\t\t\t\t\t\t pg_rusage_show(&state->ru_start));\n#endif\n\t\t\t\tmake_bounded_heap(state);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Done if we still fit in available memory and have array slots.\n\t\t\t */\n\t\t\tif (state->memtupcount < state->memtupsize && !LACKMEM(state))\n\t\t\t\treturn;\n\n\t\t\t/*\n\t\t\t * Nope; time to switch to tape-based operation.\n\t\t\t */\n\t\t\tinittapes(state, true);\n\n\t\t\t/*\n\t\t\t * Dump all tuples.\n\t\t\t */\n\t\t\tdumptuples(state, false);\n\t\t\tbreak;\n\n\t\tcase TSS_BOUNDED:\n\n\t\t\t/*\n\t\t\t * We don't want to grow the array here, so check whether the new\n\t\t\t * tuple can be discarded before putting it in.  This should be a\n\t\t\t * good speed optimization, too, since when there are many more\n\t\t\t * input tuples than the bound, most input tuples can be discarded\n\t\t\t * with just this one comparison.  Note that because we currently\n\t\t\t * have the sort direction reversed, we must check for <= not >=.\n\t\t\t */\n\t\t\tif (COMPARETUP(state, tuple, &state->memtuples[0]) <= 0)\n\t\t\t{\n\t\t\t\t/* new tuple <= top of the heap, so we can discard it */\n\t\t\t\tfree_sort_tuple(state, tuple);\n\t\t\t\tCHECK_FOR_INTERRUPTS();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* discard top of heap, replacing it with the new tuple */\n\t\t\t\tfree_sort_tuple(state, &state->memtuples[0]);\n\t\t\t\ttuplesort_heap_replace_top(state, tuple);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TSS_BUILDRUNS:\n\n\t\t\t/*\n\t\t\t * Save the tuple into the unsorted array (there must be space)\n\t\t\t */\n\t\t\tstate->memtuples[state->memtupcount++] = *tuple;\n\n\t\t\t/*\n\t\t\t * If we are over the memory limit, dump all tuples.\n\t\t\t */\n\t\t\tdumptuples(state, false);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplesort state\");\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic void\nputtuple_common(Tuplesortstate *state, SortTuple *tuple)\n{\n\tAssert(!LEADER(state));\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INITIAL:\n\n\t\t\t/*\n\t\t\t * Save the tuple into the unsorted array.  First, grow the array\n\t\t\t * as needed.  Note that we try to grow the array when there is\n\t\t\t * still one free slot remaining --- if we fail, there'll still be\n\t\t\t * room to store the incoming tuple, and then we'll switch to\n\t\t\t * tape-based operation.\n\t\t\t */\n\t\t\tif (state->memtupcount >= state->memtupsize - 1)\n\t\t\t{\n\t\t\t\t(void) grow_memtuples(state);\n\t\t\t\tAssert(state->memtupcount < state->memtupsize);\n\t\t\t}\n\t\t\tstate->memtuples[state->memtupcount++] = *tuple;\n\n\t\t\t/*\n\t\t\t * Check if it's time to switch over to a bounded heapsort. We do\n\t\t\t * so if the input tuple count exceeds twice the desired tuple\n\t\t\t * count (this is a heuristic for where heapsort becomes cheaper\n\t\t\t * than a quicksort), or if we've just filled workMem and have\n\t\t\t * enough tuples to meet the bound.\n\t\t\t *\n\t\t\t * Note that once we enter TSS_BOUNDED state we will always try to\n\t\t\t * complete the sort that way.  In the worst case, if later input\n\t\t\t * tuples are larger than earlier ones, this might cause us to\n\t\t\t * exceed workMem significantly.\n\t\t\t */\n\t\t\tif (state->bounded &&\n\t\t\t\t(state->memtupcount > state->bound * 2 ||\n\t\t\t\t (state->memtupcount > state->bound && LACKMEM(state))))\n\t\t\t{\n#ifdef TRACE_SORT\n\t\t\t\tif (trace_sort)\n\t\t\t\t\telog(LOG, \"switching to bounded heapsort at %d tuples: %s\",\n\t\t\t\t\t\t state->memtupcount,\n\t\t\t\t\t\t pg_rusage_show(&state->ru_start));\n#endif\n\t\t\t\tmake_bounded_heap(state);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Done if we still fit in available memory and have array slots.\n\t\t\t */\n\t\t\tif (state->memtupcount < state->memtupsize && !LACKMEM(state))\n\t\t\t\treturn;\n\n\t\t\t/*\n\t\t\t * Nope; time to switch to tape-based operation.\n\t\t\t */\n\t\t\tinittapes(state, true);\n\n\t\t\t/*\n\t\t\t * Dump all tuples.\n\t\t\t */\n\t\t\tdumptuples(state, false);\n\t\t\tbreak;\n\n\t\tcase TSS_BOUNDED:\n\n\t\t\t/*\n\t\t\t * We don't want to grow the array here, so check whether the new\n\t\t\t * tuple can be discarded before putting it in.  This should be a\n\t\t\t * good speed optimization, too, since when there are many more\n\t\t\t * input tuples than the bound, most input tuples can be discarded\n\t\t\t * with just this one comparison.  Note that because we currently\n\t\t\t * have the sort direction reversed, we must check for <= not >=.\n\t\t\t */\n\t\t\tif (COMPARETUP(state, tuple, &state->memtuples[0]) <= 0)\n\t\t\t{\n\t\t\t\t/* new tuple <= top of the heap, so we can discard it */\n\t\t\t\tfree_sort_tuple(state, tuple);\n\t\t\t\tCHECK_FOR_INTERRUPTS();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* discard top of heap, replacing it with the new tuple */\n\t\t\t\tfree_sort_tuple(state, &state->memtuples[0]);\n\t\t\t\ttuplesort_heap_replace_top(state, tuple);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TSS_BUILDRUNS:\n\n\t\t\t/*\n\t\t\t * Save the tuple into the unsorted array (there must be space)\n\t\t\t */\n\t\t\tstate->memtuples[state->memtupcount++] = *tuple;\n\n\t\t\t/*\n\t\t\t * If we are over the memory limit, dump all tuples.\n\t\t\t */\n\t\t\tdumptuples(state, false);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplesort state\");\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "mtup->tuple"
          ],
          "line": 1623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "state->sortKeys->abbrev_converter",
          "args": [
            "original",
            "state->sortKeys"
          ],
          "line": 1599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "consider_abort_common",
          "args": [
            "state"
          ],
          "line": 1596
        },
        "resolved": true,
        "details": {
          "function_name": "consider_abort_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "1745-1784",
          "snippet": "static bool\nconsider_abort_common(Tuplesortstate *state)\n{\n\tAssert(state->sortKeys[0].abbrev_converter != NULL);\n\tAssert(state->sortKeys[0].abbrev_abort != NULL);\n\tAssert(state->sortKeys[0].abbrev_full_comparator != NULL);\n\n\t/*\n\t * Check effectiveness of abbreviation optimization.  Consider aborting\n\t * when still within memory limit.\n\t */\n\tif (state->status == TSS_INITIAL &&\n\t\tstate->memtupcount >= state->abbrevNext)\n\t{\n\t\tstate->abbrevNext *= 2;\n\n\t\t/*\n\t\t * Check opclass-supplied abbreviation abort routine.  It may indicate\n\t\t * that abbreviation should not proceed.\n\t\t */\n\t\tif (!state->sortKeys->abbrev_abort(state->memtupcount,\n\t\t\t\t\t\t\t\t\t\t   state->sortKeys))\n\t\t\treturn false;\n\n\t\t/*\n\t\t * Finally, restore authoritative comparator, and indicate that\n\t\t * abbreviation is not in play by setting abbrev_converter to NULL\n\t\t */\n\t\tstate->sortKeys[0].comparator = state->sortKeys[0].abbrev_full_comparator;\n\t\tstate->sortKeys[0].abbrev_converter = NULL;\n\t\t/* Not strictly necessary, but be tidy */\n\t\tstate->sortKeys[0].abbrev_abort = NULL;\n\t\tstate->sortKeys[0].abbrev_full_comparator = NULL;\n\n\t\t/* Give up - expect original pass-by-value representation */\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic bool\nconsider_abort_common(Tuplesortstate *state)\n{\n\tAssert(state->sortKeys[0].abbrev_converter != NULL);\n\tAssert(state->sortKeys[0].abbrev_abort != NULL);\n\tAssert(state->sortKeys[0].abbrev_full_comparator != NULL);\n\n\t/*\n\t * Check effectiveness of abbreviation optimization.  Consider aborting\n\t * when still within memory limit.\n\t */\n\tif (state->status == TSS_INITIAL &&\n\t\tstate->memtupcount >= state->abbrevNext)\n\t{\n\t\tstate->abbrevNext *= 2;\n\n\t\t/*\n\t\t * Check opclass-supplied abbreviation abort routine.  It may indicate\n\t\t * that abbreviation should not proceed.\n\t\t */\n\t\tif (!state->sortKeys->abbrev_abort(state->memtupcount,\n\t\t\t\t\t\t\t\t\t\t   state->sortKeys))\n\t\t\treturn false;\n\n\t\t/*\n\t\t * Finally, restore authoritative comparator, and indicate that\n\t\t * abbreviation is not in play by setting abbrev_converter to NULL\n\t\t */\n\t\tstate->sortKeys[0].comparator = state->sortKeys[0].abbrev_full_comparator;\n\t\tstate->sortKeys[0].abbrev_converter = NULL;\n\t\t/* Not strictly necessary, but be tidy */\n\t\tstate->sortKeys[0].abbrev_abort = NULL;\n\t\tstate->sortKeys[0].abbrev_full_comparator = NULL;\n\n\t\t/* Give up - expect original pass-by-value representation */\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "state->sortcontext"
          ],
          "line": 1590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USEMEM",
          "args": [
            "state",
            "GetMemoryChunkSpace(stup.tuple)"
          ],
          "line": 1589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetMemoryChunkSpace",
          "args": [
            "stup.tuple"
          ],
          "line": 1589
        },
        "resolved": true,
        "details": {
          "function_name": "GetMemoryChunkSpace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "426-432",
          "snippet": "Size\nGetMemoryChunkSpace(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\treturn context->methods->get_chunk_space(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nSize\nGetMemoryChunkSpace(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\treturn context->methods->get_chunk_space(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "original"
          ],
          "line": 1588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "datumCopy",
          "args": [
            "val",
            "false",
            "state->datumTypeLen"
          ],
          "line": 1585
        },
        "resolved": true,
        "details": {
          "function_name": "datumCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datum.c",
          "lines": "127-176",
          "snippet": "Datum\ndatumCopy(Datum value, bool typByVal, int typLen)\n{\n\tDatum\t\tres;\n\n\tif (typByVal)\n\t\tres = value;\n\telse if (typLen == -1)\n\t{\n\t\t/* It is a varlena datatype */\n\t\tstruct varlena *vl = (struct varlena *) DatumGetPointer(value);\n\n\t\tif (VARATT_IS_EXTERNAL_EXPANDED(vl))\n\t\t{\n\t\t\t/* Flatten into the caller's memory context */\n\t\t\tExpandedObjectHeader *eoh = DatumGetEOHP(value);\n\t\t\tSize\t\tresultsize;\n\t\t\tchar\t   *resultptr;\n\n\t\t\tresultsize = EOH_get_flat_size(eoh);\n\t\t\tresultptr = (char *) palloc(resultsize);\n\t\t\tEOH_flatten_into(eoh, (void *) resultptr, resultsize);\n\t\t\tres = PointerGetDatum(resultptr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Otherwise, just copy the varlena datum verbatim */\n\t\t\tSize\t\trealSize;\n\t\t\tchar\t   *resultptr;\n\n\t\t\trealSize = (Size) VARSIZE_ANY(vl);\n\t\t\tresultptr = (char *) palloc(realSize);\n\t\t\tmemcpy(resultptr, vl, realSize);\n\t\t\tres = PointerGetDatum(resultptr);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Pass by reference, but not varlena, so not toasted */\n\t\tSize\t\trealSize;\n\t\tchar\t   *resultptr;\n\n\t\trealSize = datumGetSize(value, typByVal, typLen);\n\n\t\tresultptr = (char *) palloc(realSize);\n\t\tmemcpy(resultptr, DatumGetPointer(value), realSize);\n\t\tres = PointerGetDatum(resultptr);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"utils/expandeddatum.h\"",
            "#include \"utils/datum.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/expandeddatum.h\"\n#include \"utils/datum.h\"\n#include \"postgres.h\"\n\nDatum\ndatumCopy(Datum value, bool typByVal, int typLen)\n{\n\tDatum\t\tres;\n\n\tif (typByVal)\n\t\tres = value;\n\telse if (typLen == -1)\n\t{\n\t\t/* It is a varlena datatype */\n\t\tstruct varlena *vl = (struct varlena *) DatumGetPointer(value);\n\n\t\tif (VARATT_IS_EXTERNAL_EXPANDED(vl))\n\t\t{\n\t\t\t/* Flatten into the caller's memory context */\n\t\t\tExpandedObjectHeader *eoh = DatumGetEOHP(value);\n\t\t\tSize\t\tresultsize;\n\t\t\tchar\t   *resultptr;\n\n\t\t\tresultsize = EOH_get_flat_size(eoh);\n\t\t\tresultptr = (char *) palloc(resultsize);\n\t\t\tEOH_flatten_into(eoh, (void *) resultptr, resultsize);\n\t\t\tres = PointerGetDatum(resultptr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Otherwise, just copy the varlena datum verbatim */\n\t\t\tSize\t\trealSize;\n\t\t\tchar\t   *resultptr;\n\n\t\t\trealSize = (Size) VARSIZE_ANY(vl);\n\t\t\tresultptr = (char *) palloc(realSize);\n\t\t\tmemcpy(resultptr, vl, realSize);\n\t\t\tres = PointerGetDatum(resultptr);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Pass by reference, but not varlena, so not toasted */\n\t\tSize\t\trealSize;\n\t\tchar\t   *resultptr;\n\n\t\trealSize = datumGetSize(value, typByVal, typLen);\n\n\t\tresultptr = (char *) palloc(realSize);\n\t\tmemcpy(resultptr, DatumGetPointer(value), realSize);\n\t\tres = PointerGetDatum(resultptr);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "state->sortcontext"
          ],
          "line": 1581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "state->tuplecontext"
          ],
          "line": 1557
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\nstatic void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);\n\nvoid\ntuplesort_putdatum(Tuplesortstate *state, Datum val, bool isNull)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->tuplecontext);\n\tSortTuple\tstup;\n\n\t/*\n\t * Pass-by-value types or null values are just stored directly in\n\t * stup.datum1 (and stup.tuple is not used and set to NULL).\n\t *\n\t * Non-null pass-by-reference values need to be copied into memory we\n\t * control, and possibly abbreviated. The copied value is pointed to by\n\t * stup.tuple and is treated as the canonical copy (e.g. to return via\n\t * tuplesort_getdatum or when writing to tape); stup.datum1 gets the\n\t * abbreviated value if abbreviation is happening, otherwise it's\n\t * identical to stup.tuple.\n\t */\n\n\tif (isNull || !state->tuples)\n\t{\n\t\t/*\n\t\t * Set datum1 to zeroed representation for NULLs (to be consistent,\n\t\t * and to support cheap inequality tests for NULL abbreviated keys).\n\t\t */\n\t\tstup.datum1 = !isNull ? val : (Datum) 0;\n\t\tstup.isnull1 = isNull;\n\t\tstup.tuple = NULL;\t\t/* no separate storage */\n\t\tMemoryContextSwitchTo(state->sortcontext);\n\t}\n\telse\n\t{\n\t\tDatum\t\toriginal = datumCopy(val, false, state->datumTypeLen);\n\n\t\tstup.isnull1 = false;\n\t\tstup.tuple = DatumGetPointer(original);\n\t\tUSEMEM(state, GetMemoryChunkSpace(stup.tuple));\n\t\tMemoryContextSwitchTo(state->sortcontext);\n\n\t\tif (!state->sortKeys->abbrev_converter)\n\t\t{\n\t\t\tstup.datum1 = original;\n\t\t}\n\t\telse if (!consider_abort_common(state))\n\t\t{\n\t\t\t/* Store abbreviated key representation */\n\t\t\tstup.datum1 = state->sortKeys->abbrev_converter(original,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstate->sortKeys);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Abort abbreviation */\n\t\t\tint\t\t\ti;\n\n\t\t\tstup.datum1 = original;\n\n\t\t\t/*\n\t\t\t * Set state to be consistent with never trying abbreviation.\n\t\t\t *\n\t\t\t * Alter datum1 representation in already-copied tuples, so as to\n\t\t\t * ensure a consistent representation (current tuple was just\n\t\t\t * handled).  It does not matter if some dumped tuples are already\n\t\t\t * sorted on tape, since serialized tuples lack abbreviated keys\n\t\t\t * (TSS_BUILDRUNS state prevents control reaching here in any\n\t\t\t * case).\n\t\t\t */\n\t\t\tfor (i = 0; i < state->memtupcount; i++)\n\t\t\t{\n\t\t\t\tSortTuple  *mtup = &state->memtuples[i];\n\n\t\t\t\tmtup->datum1 = PointerGetDatum(mtup->tuple);\n\t\t\t}\n\t\t}\n\t}\n\n\tputtuple_common(state, &stup);\n\n\tMemoryContextSwitchTo(oldcontext);\n}"
  },
  {
    "function_name": "tuplesort_putindextuplevalues",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "1476-1547",
    "snippet": "void\ntuplesort_putindextuplevalues(Tuplesortstate *state, Relation rel,\n\t\t\t\t\t\t\t  ItemPointer self, Datum *values,\n\t\t\t\t\t\t\t  bool *isnull)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->tuplecontext);\n\tSortTuple\tstup;\n\tDatum\t\toriginal;\n\tIndexTuple\ttuple;\n\n\tstup.tuple = index_form_tuple(RelationGetDescr(rel), values, isnull);\n\ttuple = ((IndexTuple) stup.tuple);\n\ttuple->t_tid = *self;\n\tUSEMEM(state, GetMemoryChunkSpace(stup.tuple));\n\t/* set up first-column key value */\n\toriginal = index_getattr(tuple,\n\t\t\t\t\t\t\t 1,\n\t\t\t\t\t\t\t RelationGetDescr(state->indexRel),\n\t\t\t\t\t\t\t &stup.isnull1);\n\n\tMemoryContextSwitchTo(state->sortcontext);\n\n\tif (!state->sortKeys || !state->sortKeys->abbrev_converter || stup.isnull1)\n\t{\n\t\t/*\n\t\t * Store ordinary Datum representation, or NULL value.  If there is a\n\t\t * converter it won't expect NULL values, and cost model is not\n\t\t * required to account for NULL, so in that case we avoid calling\n\t\t * converter and just set datum1 to zeroed representation (to be\n\t\t * consistent, and to support cheap inequality tests for NULL\n\t\t * abbreviated keys).\n\t\t */\n\t\tstup.datum1 = original;\n\t}\n\telse if (!consider_abort_common(state))\n\t{\n\t\t/* Store abbreviated key representation */\n\t\tstup.datum1 = state->sortKeys->abbrev_converter(original,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tstate->sortKeys);\n\t}\n\telse\n\t{\n\t\t/* Abort abbreviation */\n\t\tint\t\t\ti;\n\n\t\tstup.datum1 = original;\n\n\t\t/*\n\t\t * Set state to be consistent with never trying abbreviation.\n\t\t *\n\t\t * Alter datum1 representation in already-copied tuples, so as to\n\t\t * ensure a consistent representation (current tuple was just\n\t\t * handled).  It does not matter if some dumped tuples are already\n\t\t * sorted on tape, since serialized tuples lack abbreviated keys\n\t\t * (TSS_BUILDRUNS state prevents control reaching here in any case).\n\t\t */\n\t\tfor (i = 0; i < state->memtupcount; i++)\n\t\t{\n\t\t\tSortTuple  *mtup = &state->memtuples[i];\n\n\t\t\ttuple = mtup->tuple;\n\t\t\tmtup->datum1 = index_getattr(tuple,\n\t\t\t\t\t\t\t\t\t\t 1,\n\t\t\t\t\t\t\t\t\t\t RelationGetDescr(state->indexRel),\n\t\t\t\t\t\t\t\t\t\t &mtup->isnull1);\n\t\t}\n\t}\n\n\tputtuple_common(state, &stup);\n\n\tMemoryContextSwitchTo(oldcontext);\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);",
      "static void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "puttuple_common",
          "args": [
            "state",
            "&stup"
          ],
          "line": 1544
        },
        "resolved": true,
        "details": {
          "function_name": "puttuple_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "1636-1743",
          "snippet": "static void\nputtuple_common(Tuplesortstate *state, SortTuple *tuple)\n{\n\tAssert(!LEADER(state));\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INITIAL:\n\n\t\t\t/*\n\t\t\t * Save the tuple into the unsorted array.  First, grow the array\n\t\t\t * as needed.  Note that we try to grow the array when there is\n\t\t\t * still one free slot remaining --- if we fail, there'll still be\n\t\t\t * room to store the incoming tuple, and then we'll switch to\n\t\t\t * tape-based operation.\n\t\t\t */\n\t\t\tif (state->memtupcount >= state->memtupsize - 1)\n\t\t\t{\n\t\t\t\t(void) grow_memtuples(state);\n\t\t\t\tAssert(state->memtupcount < state->memtupsize);\n\t\t\t}\n\t\t\tstate->memtuples[state->memtupcount++] = *tuple;\n\n\t\t\t/*\n\t\t\t * Check if it's time to switch over to a bounded heapsort. We do\n\t\t\t * so if the input tuple count exceeds twice the desired tuple\n\t\t\t * count (this is a heuristic for where heapsort becomes cheaper\n\t\t\t * than a quicksort), or if we've just filled workMem and have\n\t\t\t * enough tuples to meet the bound.\n\t\t\t *\n\t\t\t * Note that once we enter TSS_BOUNDED state we will always try to\n\t\t\t * complete the sort that way.  In the worst case, if later input\n\t\t\t * tuples are larger than earlier ones, this might cause us to\n\t\t\t * exceed workMem significantly.\n\t\t\t */\n\t\t\tif (state->bounded &&\n\t\t\t\t(state->memtupcount > state->bound * 2 ||\n\t\t\t\t (state->memtupcount > state->bound && LACKMEM(state))))\n\t\t\t{\n#ifdef TRACE_SORT\n\t\t\t\tif (trace_sort)\n\t\t\t\t\telog(LOG, \"switching to bounded heapsort at %d tuples: %s\",\n\t\t\t\t\t\t state->memtupcount,\n\t\t\t\t\t\t pg_rusage_show(&state->ru_start));\n#endif\n\t\t\t\tmake_bounded_heap(state);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Done if we still fit in available memory and have array slots.\n\t\t\t */\n\t\t\tif (state->memtupcount < state->memtupsize && !LACKMEM(state))\n\t\t\t\treturn;\n\n\t\t\t/*\n\t\t\t * Nope; time to switch to tape-based operation.\n\t\t\t */\n\t\t\tinittapes(state, true);\n\n\t\t\t/*\n\t\t\t * Dump all tuples.\n\t\t\t */\n\t\t\tdumptuples(state, false);\n\t\t\tbreak;\n\n\t\tcase TSS_BOUNDED:\n\n\t\t\t/*\n\t\t\t * We don't want to grow the array here, so check whether the new\n\t\t\t * tuple can be discarded before putting it in.  This should be a\n\t\t\t * good speed optimization, too, since when there are many more\n\t\t\t * input tuples than the bound, most input tuples can be discarded\n\t\t\t * with just this one comparison.  Note that because we currently\n\t\t\t * have the sort direction reversed, we must check for <= not >=.\n\t\t\t */\n\t\t\tif (COMPARETUP(state, tuple, &state->memtuples[0]) <= 0)\n\t\t\t{\n\t\t\t\t/* new tuple <= top of the heap, so we can discard it */\n\t\t\t\tfree_sort_tuple(state, tuple);\n\t\t\t\tCHECK_FOR_INTERRUPTS();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* discard top of heap, replacing it with the new tuple */\n\t\t\t\tfree_sort_tuple(state, &state->memtuples[0]);\n\t\t\t\ttuplesort_heap_replace_top(state, tuple);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TSS_BUILDRUNS:\n\n\t\t\t/*\n\t\t\t * Save the tuple into the unsorted array (there must be space)\n\t\t\t */\n\t\t\tstate->memtuples[state->memtupcount++] = *tuple;\n\n\t\t\t/*\n\t\t\t * If we are over the memory limit, dump all tuples.\n\t\t\t */\n\t\t\tdumptuples(state, false);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplesort state\");\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic void\nputtuple_common(Tuplesortstate *state, SortTuple *tuple)\n{\n\tAssert(!LEADER(state));\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INITIAL:\n\n\t\t\t/*\n\t\t\t * Save the tuple into the unsorted array.  First, grow the array\n\t\t\t * as needed.  Note that we try to grow the array when there is\n\t\t\t * still one free slot remaining --- if we fail, there'll still be\n\t\t\t * room to store the incoming tuple, and then we'll switch to\n\t\t\t * tape-based operation.\n\t\t\t */\n\t\t\tif (state->memtupcount >= state->memtupsize - 1)\n\t\t\t{\n\t\t\t\t(void) grow_memtuples(state);\n\t\t\t\tAssert(state->memtupcount < state->memtupsize);\n\t\t\t}\n\t\t\tstate->memtuples[state->memtupcount++] = *tuple;\n\n\t\t\t/*\n\t\t\t * Check if it's time to switch over to a bounded heapsort. We do\n\t\t\t * so if the input tuple count exceeds twice the desired tuple\n\t\t\t * count (this is a heuristic for where heapsort becomes cheaper\n\t\t\t * than a quicksort), or if we've just filled workMem and have\n\t\t\t * enough tuples to meet the bound.\n\t\t\t *\n\t\t\t * Note that once we enter TSS_BOUNDED state we will always try to\n\t\t\t * complete the sort that way.  In the worst case, if later input\n\t\t\t * tuples are larger than earlier ones, this might cause us to\n\t\t\t * exceed workMem significantly.\n\t\t\t */\n\t\t\tif (state->bounded &&\n\t\t\t\t(state->memtupcount > state->bound * 2 ||\n\t\t\t\t (state->memtupcount > state->bound && LACKMEM(state))))\n\t\t\t{\n#ifdef TRACE_SORT\n\t\t\t\tif (trace_sort)\n\t\t\t\t\telog(LOG, \"switching to bounded heapsort at %d tuples: %s\",\n\t\t\t\t\t\t state->memtupcount,\n\t\t\t\t\t\t pg_rusage_show(&state->ru_start));\n#endif\n\t\t\t\tmake_bounded_heap(state);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Done if we still fit in available memory and have array slots.\n\t\t\t */\n\t\t\tif (state->memtupcount < state->memtupsize && !LACKMEM(state))\n\t\t\t\treturn;\n\n\t\t\t/*\n\t\t\t * Nope; time to switch to tape-based operation.\n\t\t\t */\n\t\t\tinittapes(state, true);\n\n\t\t\t/*\n\t\t\t * Dump all tuples.\n\t\t\t */\n\t\t\tdumptuples(state, false);\n\t\t\tbreak;\n\n\t\tcase TSS_BOUNDED:\n\n\t\t\t/*\n\t\t\t * We don't want to grow the array here, so check whether the new\n\t\t\t * tuple can be discarded before putting it in.  This should be a\n\t\t\t * good speed optimization, too, since when there are many more\n\t\t\t * input tuples than the bound, most input tuples can be discarded\n\t\t\t * with just this one comparison.  Note that because we currently\n\t\t\t * have the sort direction reversed, we must check for <= not >=.\n\t\t\t */\n\t\t\tif (COMPARETUP(state, tuple, &state->memtuples[0]) <= 0)\n\t\t\t{\n\t\t\t\t/* new tuple <= top of the heap, so we can discard it */\n\t\t\t\tfree_sort_tuple(state, tuple);\n\t\t\t\tCHECK_FOR_INTERRUPTS();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* discard top of heap, replacing it with the new tuple */\n\t\t\t\tfree_sort_tuple(state, &state->memtuples[0]);\n\t\t\t\ttuplesort_heap_replace_top(state, tuple);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TSS_BUILDRUNS:\n\n\t\t\t/*\n\t\t\t * Save the tuple into the unsorted array (there must be space)\n\t\t\t */\n\t\t\tstate->memtuples[state->memtupcount++] = *tuple;\n\n\t\t\t/*\n\t\t\t * If we are over the memory limit, dump all tuples.\n\t\t\t */\n\t\t\tdumptuples(state, false);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplesort state\");\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_getattr",
          "args": [
            "tuple",
            "1",
            "RelationGetDescr(state->indexRel)",
            "&mtup->isnull1"
          ],
          "line": 1537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetDescr",
          "args": [
            "state->indexRel"
          ],
          "line": 1539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "state->sortKeys->abbrev_converter",
          "args": [
            "original",
            "state->sortKeys"
          ],
          "line": 1513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "consider_abort_common",
          "args": [
            "state"
          ],
          "line": 1510
        },
        "resolved": true,
        "details": {
          "function_name": "consider_abort_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "1745-1784",
          "snippet": "static bool\nconsider_abort_common(Tuplesortstate *state)\n{\n\tAssert(state->sortKeys[0].abbrev_converter != NULL);\n\tAssert(state->sortKeys[0].abbrev_abort != NULL);\n\tAssert(state->sortKeys[0].abbrev_full_comparator != NULL);\n\n\t/*\n\t * Check effectiveness of abbreviation optimization.  Consider aborting\n\t * when still within memory limit.\n\t */\n\tif (state->status == TSS_INITIAL &&\n\t\tstate->memtupcount >= state->abbrevNext)\n\t{\n\t\tstate->abbrevNext *= 2;\n\n\t\t/*\n\t\t * Check opclass-supplied abbreviation abort routine.  It may indicate\n\t\t * that abbreviation should not proceed.\n\t\t */\n\t\tif (!state->sortKeys->abbrev_abort(state->memtupcount,\n\t\t\t\t\t\t\t\t\t\t   state->sortKeys))\n\t\t\treturn false;\n\n\t\t/*\n\t\t * Finally, restore authoritative comparator, and indicate that\n\t\t * abbreviation is not in play by setting abbrev_converter to NULL\n\t\t */\n\t\tstate->sortKeys[0].comparator = state->sortKeys[0].abbrev_full_comparator;\n\t\tstate->sortKeys[0].abbrev_converter = NULL;\n\t\t/* Not strictly necessary, but be tidy */\n\t\tstate->sortKeys[0].abbrev_abort = NULL;\n\t\tstate->sortKeys[0].abbrev_full_comparator = NULL;\n\n\t\t/* Give up - expect original pass-by-value representation */\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic bool\nconsider_abort_common(Tuplesortstate *state)\n{\n\tAssert(state->sortKeys[0].abbrev_converter != NULL);\n\tAssert(state->sortKeys[0].abbrev_abort != NULL);\n\tAssert(state->sortKeys[0].abbrev_full_comparator != NULL);\n\n\t/*\n\t * Check effectiveness of abbreviation optimization.  Consider aborting\n\t * when still within memory limit.\n\t */\n\tif (state->status == TSS_INITIAL &&\n\t\tstate->memtupcount >= state->abbrevNext)\n\t{\n\t\tstate->abbrevNext *= 2;\n\n\t\t/*\n\t\t * Check opclass-supplied abbreviation abort routine.  It may indicate\n\t\t * that abbreviation should not proceed.\n\t\t */\n\t\tif (!state->sortKeys->abbrev_abort(state->memtupcount,\n\t\t\t\t\t\t\t\t\t\t   state->sortKeys))\n\t\t\treturn false;\n\n\t\t/*\n\t\t * Finally, restore authoritative comparator, and indicate that\n\t\t * abbreviation is not in play by setting abbrev_converter to NULL\n\t\t */\n\t\tstate->sortKeys[0].comparator = state->sortKeys[0].abbrev_full_comparator;\n\t\tstate->sortKeys[0].abbrev_converter = NULL;\n\t\t/* Not strictly necessary, but be tidy */\n\t\tstate->sortKeys[0].abbrev_abort = NULL;\n\t\tstate->sortKeys[0].abbrev_full_comparator = NULL;\n\n\t\t/* Give up - expect original pass-by-value representation */\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "state->sortcontext"
          ],
          "line": 1496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "index_getattr",
          "args": [
            "tuple",
            "1",
            "RelationGetDescr(state->indexRel)",
            "&stup.isnull1"
          ],
          "line": 1491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetDescr",
          "args": [
            "state->indexRel"
          ],
          "line": 1493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USEMEM",
          "args": [
            "state",
            "GetMemoryChunkSpace(stup.tuple)"
          ],
          "line": 1489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetMemoryChunkSpace",
          "args": [
            "stup.tuple"
          ],
          "line": 1489
        },
        "resolved": true,
        "details": {
          "function_name": "GetMemoryChunkSpace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "426-432",
          "snippet": "Size\nGetMemoryChunkSpace(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\treturn context->methods->get_chunk_space(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nSize\nGetMemoryChunkSpace(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\treturn context->methods->get_chunk_space(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_form_tuple",
          "args": [
            "RelationGetDescr(rel)",
            "values",
            "isnull"
          ],
          "line": 1486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetDescr",
          "args": [
            "rel"
          ],
          "line": 1486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "state->tuplecontext"
          ],
          "line": 1481
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\nstatic void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);\n\nvoid\ntuplesort_putindextuplevalues(Tuplesortstate *state, Relation rel,\n\t\t\t\t\t\t\t  ItemPointer self, Datum *values,\n\t\t\t\t\t\t\t  bool *isnull)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->tuplecontext);\n\tSortTuple\tstup;\n\tDatum\t\toriginal;\n\tIndexTuple\ttuple;\n\n\tstup.tuple = index_form_tuple(RelationGetDescr(rel), values, isnull);\n\ttuple = ((IndexTuple) stup.tuple);\n\ttuple->t_tid = *self;\n\tUSEMEM(state, GetMemoryChunkSpace(stup.tuple));\n\t/* set up first-column key value */\n\toriginal = index_getattr(tuple,\n\t\t\t\t\t\t\t 1,\n\t\t\t\t\t\t\t RelationGetDescr(state->indexRel),\n\t\t\t\t\t\t\t &stup.isnull1);\n\n\tMemoryContextSwitchTo(state->sortcontext);\n\n\tif (!state->sortKeys || !state->sortKeys->abbrev_converter || stup.isnull1)\n\t{\n\t\t/*\n\t\t * Store ordinary Datum representation, or NULL value.  If there is a\n\t\t * converter it won't expect NULL values, and cost model is not\n\t\t * required to account for NULL, so in that case we avoid calling\n\t\t * converter and just set datum1 to zeroed representation (to be\n\t\t * consistent, and to support cheap inequality tests for NULL\n\t\t * abbreviated keys).\n\t\t */\n\t\tstup.datum1 = original;\n\t}\n\telse if (!consider_abort_common(state))\n\t{\n\t\t/* Store abbreviated key representation */\n\t\tstup.datum1 = state->sortKeys->abbrev_converter(original,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tstate->sortKeys);\n\t}\n\telse\n\t{\n\t\t/* Abort abbreviation */\n\t\tint\t\t\ti;\n\n\t\tstup.datum1 = original;\n\n\t\t/*\n\t\t * Set state to be consistent with never trying abbreviation.\n\t\t *\n\t\t * Alter datum1 representation in already-copied tuples, so as to\n\t\t * ensure a consistent representation (current tuple was just\n\t\t * handled).  It does not matter if some dumped tuples are already\n\t\t * sorted on tape, since serialized tuples lack abbreviated keys\n\t\t * (TSS_BUILDRUNS state prevents control reaching here in any case).\n\t\t */\n\t\tfor (i = 0; i < state->memtupcount; i++)\n\t\t{\n\t\t\tSortTuple  *mtup = &state->memtuples[i];\n\n\t\t\ttuple = mtup->tuple;\n\t\t\tmtup->datum1 = index_getattr(tuple,\n\t\t\t\t\t\t\t\t\t\t 1,\n\t\t\t\t\t\t\t\t\t\t RelationGetDescr(state->indexRel),\n\t\t\t\t\t\t\t\t\t\t &mtup->isnull1);\n\t\t}\n\t}\n\n\tputtuple_common(state, &stup);\n\n\tMemoryContextSwitchTo(oldcontext);\n}"
  },
  {
    "function_name": "tuplesort_putheaptuple",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "1455-1470",
    "snippet": "void\ntuplesort_putheaptuple(Tuplesortstate *state, HeapTuple tup)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\tSortTuple\tstup;\n\n\t/*\n\t * Copy the given tuple into memory we control, and decrease availMem.\n\t * Then call the common code.\n\t */\n\tCOPYTUP(state, &stup, (void *) tup);\n\n\tputtuple_common(state, &stup);\n\n\tMemoryContextSwitchTo(oldcontext);\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static void copytup_heap(Tuplesortstate *state, SortTuple *stup, void *tup);",
      "static void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static void copytup_cluster(Tuplesortstate *state, SortTuple *stup, void *tup);",
      "static void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static void copytup_index(Tuplesortstate *state, SortTuple *stup, void *tup);",
      "static void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static void copytup_datum(Tuplesortstate *state, SortTuple *stup, void *tup);",
      "static void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);",
      "static void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "puttuple_common",
          "args": [
            "state",
            "&stup"
          ],
          "line": 1467
        },
        "resolved": true,
        "details": {
          "function_name": "puttuple_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "1636-1743",
          "snippet": "static void\nputtuple_common(Tuplesortstate *state, SortTuple *tuple)\n{\n\tAssert(!LEADER(state));\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INITIAL:\n\n\t\t\t/*\n\t\t\t * Save the tuple into the unsorted array.  First, grow the array\n\t\t\t * as needed.  Note that we try to grow the array when there is\n\t\t\t * still one free slot remaining --- if we fail, there'll still be\n\t\t\t * room to store the incoming tuple, and then we'll switch to\n\t\t\t * tape-based operation.\n\t\t\t */\n\t\t\tif (state->memtupcount >= state->memtupsize - 1)\n\t\t\t{\n\t\t\t\t(void) grow_memtuples(state);\n\t\t\t\tAssert(state->memtupcount < state->memtupsize);\n\t\t\t}\n\t\t\tstate->memtuples[state->memtupcount++] = *tuple;\n\n\t\t\t/*\n\t\t\t * Check if it's time to switch over to a bounded heapsort. We do\n\t\t\t * so if the input tuple count exceeds twice the desired tuple\n\t\t\t * count (this is a heuristic for where heapsort becomes cheaper\n\t\t\t * than a quicksort), or if we've just filled workMem and have\n\t\t\t * enough tuples to meet the bound.\n\t\t\t *\n\t\t\t * Note that once we enter TSS_BOUNDED state we will always try to\n\t\t\t * complete the sort that way.  In the worst case, if later input\n\t\t\t * tuples are larger than earlier ones, this might cause us to\n\t\t\t * exceed workMem significantly.\n\t\t\t */\n\t\t\tif (state->bounded &&\n\t\t\t\t(state->memtupcount > state->bound * 2 ||\n\t\t\t\t (state->memtupcount > state->bound && LACKMEM(state))))\n\t\t\t{\n#ifdef TRACE_SORT\n\t\t\t\tif (trace_sort)\n\t\t\t\t\telog(LOG, \"switching to bounded heapsort at %d tuples: %s\",\n\t\t\t\t\t\t state->memtupcount,\n\t\t\t\t\t\t pg_rusage_show(&state->ru_start));\n#endif\n\t\t\t\tmake_bounded_heap(state);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Done if we still fit in available memory and have array slots.\n\t\t\t */\n\t\t\tif (state->memtupcount < state->memtupsize && !LACKMEM(state))\n\t\t\t\treturn;\n\n\t\t\t/*\n\t\t\t * Nope; time to switch to tape-based operation.\n\t\t\t */\n\t\t\tinittapes(state, true);\n\n\t\t\t/*\n\t\t\t * Dump all tuples.\n\t\t\t */\n\t\t\tdumptuples(state, false);\n\t\t\tbreak;\n\n\t\tcase TSS_BOUNDED:\n\n\t\t\t/*\n\t\t\t * We don't want to grow the array here, so check whether the new\n\t\t\t * tuple can be discarded before putting it in.  This should be a\n\t\t\t * good speed optimization, too, since when there are many more\n\t\t\t * input tuples than the bound, most input tuples can be discarded\n\t\t\t * with just this one comparison.  Note that because we currently\n\t\t\t * have the sort direction reversed, we must check for <= not >=.\n\t\t\t */\n\t\t\tif (COMPARETUP(state, tuple, &state->memtuples[0]) <= 0)\n\t\t\t{\n\t\t\t\t/* new tuple <= top of the heap, so we can discard it */\n\t\t\t\tfree_sort_tuple(state, tuple);\n\t\t\t\tCHECK_FOR_INTERRUPTS();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* discard top of heap, replacing it with the new tuple */\n\t\t\t\tfree_sort_tuple(state, &state->memtuples[0]);\n\t\t\t\ttuplesort_heap_replace_top(state, tuple);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TSS_BUILDRUNS:\n\n\t\t\t/*\n\t\t\t * Save the tuple into the unsorted array (there must be space)\n\t\t\t */\n\t\t\tstate->memtuples[state->memtupcount++] = *tuple;\n\n\t\t\t/*\n\t\t\t * If we are over the memory limit, dump all tuples.\n\t\t\t */\n\t\t\tdumptuples(state, false);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplesort state\");\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic void\nputtuple_common(Tuplesortstate *state, SortTuple *tuple)\n{\n\tAssert(!LEADER(state));\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INITIAL:\n\n\t\t\t/*\n\t\t\t * Save the tuple into the unsorted array.  First, grow the array\n\t\t\t * as needed.  Note that we try to grow the array when there is\n\t\t\t * still one free slot remaining --- if we fail, there'll still be\n\t\t\t * room to store the incoming tuple, and then we'll switch to\n\t\t\t * tape-based operation.\n\t\t\t */\n\t\t\tif (state->memtupcount >= state->memtupsize - 1)\n\t\t\t{\n\t\t\t\t(void) grow_memtuples(state);\n\t\t\t\tAssert(state->memtupcount < state->memtupsize);\n\t\t\t}\n\t\t\tstate->memtuples[state->memtupcount++] = *tuple;\n\n\t\t\t/*\n\t\t\t * Check if it's time to switch over to a bounded heapsort. We do\n\t\t\t * so if the input tuple count exceeds twice the desired tuple\n\t\t\t * count (this is a heuristic for where heapsort becomes cheaper\n\t\t\t * than a quicksort), or if we've just filled workMem and have\n\t\t\t * enough tuples to meet the bound.\n\t\t\t *\n\t\t\t * Note that once we enter TSS_BOUNDED state we will always try to\n\t\t\t * complete the sort that way.  In the worst case, if later input\n\t\t\t * tuples are larger than earlier ones, this might cause us to\n\t\t\t * exceed workMem significantly.\n\t\t\t */\n\t\t\tif (state->bounded &&\n\t\t\t\t(state->memtupcount > state->bound * 2 ||\n\t\t\t\t (state->memtupcount > state->bound && LACKMEM(state))))\n\t\t\t{\n#ifdef TRACE_SORT\n\t\t\t\tif (trace_sort)\n\t\t\t\t\telog(LOG, \"switching to bounded heapsort at %d tuples: %s\",\n\t\t\t\t\t\t state->memtupcount,\n\t\t\t\t\t\t pg_rusage_show(&state->ru_start));\n#endif\n\t\t\t\tmake_bounded_heap(state);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Done if we still fit in available memory and have array slots.\n\t\t\t */\n\t\t\tif (state->memtupcount < state->memtupsize && !LACKMEM(state))\n\t\t\t\treturn;\n\n\t\t\t/*\n\t\t\t * Nope; time to switch to tape-based operation.\n\t\t\t */\n\t\t\tinittapes(state, true);\n\n\t\t\t/*\n\t\t\t * Dump all tuples.\n\t\t\t */\n\t\t\tdumptuples(state, false);\n\t\t\tbreak;\n\n\t\tcase TSS_BOUNDED:\n\n\t\t\t/*\n\t\t\t * We don't want to grow the array here, so check whether the new\n\t\t\t * tuple can be discarded before putting it in.  This should be a\n\t\t\t * good speed optimization, too, since when there are many more\n\t\t\t * input tuples than the bound, most input tuples can be discarded\n\t\t\t * with just this one comparison.  Note that because we currently\n\t\t\t * have the sort direction reversed, we must check for <= not >=.\n\t\t\t */\n\t\t\tif (COMPARETUP(state, tuple, &state->memtuples[0]) <= 0)\n\t\t\t{\n\t\t\t\t/* new tuple <= top of the heap, so we can discard it */\n\t\t\t\tfree_sort_tuple(state, tuple);\n\t\t\t\tCHECK_FOR_INTERRUPTS();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* discard top of heap, replacing it with the new tuple */\n\t\t\t\tfree_sort_tuple(state, &state->memtuples[0]);\n\t\t\t\ttuplesort_heap_replace_top(state, tuple);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TSS_BUILDRUNS:\n\n\t\t\t/*\n\t\t\t * Save the tuple into the unsorted array (there must be space)\n\t\t\t */\n\t\t\tstate->memtuples[state->memtupcount++] = *tuple;\n\n\t\t\t/*\n\t\t\t * If we are over the memory limit, dump all tuples.\n\t\t\t */\n\t\t\tdumptuples(state, false);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplesort state\");\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "COPYTUP",
          "args": [
            "state",
            "&stup",
            "(void *) tup"
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "state->sortcontext"
          ],
          "line": 1458
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic void copytup_heap(Tuplesortstate *state, SortTuple *stup, void *tup);\nstatic void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic void copytup_cluster(Tuplesortstate *state, SortTuple *stup, void *tup);\nstatic void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic void copytup_index(Tuplesortstate *state, SortTuple *stup, void *tup);\nstatic void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic void copytup_datum(Tuplesortstate *state, SortTuple *stup, void *tup);\nstatic void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\nstatic void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);\n\nvoid\ntuplesort_putheaptuple(Tuplesortstate *state, HeapTuple tup)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\tSortTuple\tstup;\n\n\t/*\n\t * Copy the given tuple into memory we control, and decrease availMem.\n\t * Then call the common code.\n\t */\n\tCOPYTUP(state, &stup, (void *) tup);\n\n\tputtuple_common(state, &stup);\n\n\tMemoryContextSwitchTo(oldcontext);\n}"
  },
  {
    "function_name": "tuplesort_puttupleslot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "1433-1448",
    "snippet": "void\ntuplesort_puttupleslot(Tuplesortstate *state, TupleTableSlot *slot)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\tSortTuple\tstup;\n\n\t/*\n\t * Copy the given tuple into memory we control, and decrease availMem.\n\t * Then call the common code.\n\t */\n\tCOPYTUP(state, &stup, (void *) slot);\n\n\tputtuple_common(state, &stup);\n\n\tMemoryContextSwitchTo(oldcontext);\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);",
      "static void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "puttuple_common",
          "args": [
            "state",
            "&stup"
          ],
          "line": 1445
        },
        "resolved": true,
        "details": {
          "function_name": "puttuple_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "1636-1743",
          "snippet": "static void\nputtuple_common(Tuplesortstate *state, SortTuple *tuple)\n{\n\tAssert(!LEADER(state));\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INITIAL:\n\n\t\t\t/*\n\t\t\t * Save the tuple into the unsorted array.  First, grow the array\n\t\t\t * as needed.  Note that we try to grow the array when there is\n\t\t\t * still one free slot remaining --- if we fail, there'll still be\n\t\t\t * room to store the incoming tuple, and then we'll switch to\n\t\t\t * tape-based operation.\n\t\t\t */\n\t\t\tif (state->memtupcount >= state->memtupsize - 1)\n\t\t\t{\n\t\t\t\t(void) grow_memtuples(state);\n\t\t\t\tAssert(state->memtupcount < state->memtupsize);\n\t\t\t}\n\t\t\tstate->memtuples[state->memtupcount++] = *tuple;\n\n\t\t\t/*\n\t\t\t * Check if it's time to switch over to a bounded heapsort. We do\n\t\t\t * so if the input tuple count exceeds twice the desired tuple\n\t\t\t * count (this is a heuristic for where heapsort becomes cheaper\n\t\t\t * than a quicksort), or if we've just filled workMem and have\n\t\t\t * enough tuples to meet the bound.\n\t\t\t *\n\t\t\t * Note that once we enter TSS_BOUNDED state we will always try to\n\t\t\t * complete the sort that way.  In the worst case, if later input\n\t\t\t * tuples are larger than earlier ones, this might cause us to\n\t\t\t * exceed workMem significantly.\n\t\t\t */\n\t\t\tif (state->bounded &&\n\t\t\t\t(state->memtupcount > state->bound * 2 ||\n\t\t\t\t (state->memtupcount > state->bound && LACKMEM(state))))\n\t\t\t{\n#ifdef TRACE_SORT\n\t\t\t\tif (trace_sort)\n\t\t\t\t\telog(LOG, \"switching to bounded heapsort at %d tuples: %s\",\n\t\t\t\t\t\t state->memtupcount,\n\t\t\t\t\t\t pg_rusage_show(&state->ru_start));\n#endif\n\t\t\t\tmake_bounded_heap(state);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Done if we still fit in available memory and have array slots.\n\t\t\t */\n\t\t\tif (state->memtupcount < state->memtupsize && !LACKMEM(state))\n\t\t\t\treturn;\n\n\t\t\t/*\n\t\t\t * Nope; time to switch to tape-based operation.\n\t\t\t */\n\t\t\tinittapes(state, true);\n\n\t\t\t/*\n\t\t\t * Dump all tuples.\n\t\t\t */\n\t\t\tdumptuples(state, false);\n\t\t\tbreak;\n\n\t\tcase TSS_BOUNDED:\n\n\t\t\t/*\n\t\t\t * We don't want to grow the array here, so check whether the new\n\t\t\t * tuple can be discarded before putting it in.  This should be a\n\t\t\t * good speed optimization, too, since when there are many more\n\t\t\t * input tuples than the bound, most input tuples can be discarded\n\t\t\t * with just this one comparison.  Note that because we currently\n\t\t\t * have the sort direction reversed, we must check for <= not >=.\n\t\t\t */\n\t\t\tif (COMPARETUP(state, tuple, &state->memtuples[0]) <= 0)\n\t\t\t{\n\t\t\t\t/* new tuple <= top of the heap, so we can discard it */\n\t\t\t\tfree_sort_tuple(state, tuple);\n\t\t\t\tCHECK_FOR_INTERRUPTS();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* discard top of heap, replacing it with the new tuple */\n\t\t\t\tfree_sort_tuple(state, &state->memtuples[0]);\n\t\t\t\ttuplesort_heap_replace_top(state, tuple);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TSS_BUILDRUNS:\n\n\t\t\t/*\n\t\t\t * Save the tuple into the unsorted array (there must be space)\n\t\t\t */\n\t\t\tstate->memtuples[state->memtupcount++] = *tuple;\n\n\t\t\t/*\n\t\t\t * If we are over the memory limit, dump all tuples.\n\t\t\t */\n\t\t\tdumptuples(state, false);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplesort state\");\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic void\nputtuple_common(Tuplesortstate *state, SortTuple *tuple)\n{\n\tAssert(!LEADER(state));\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INITIAL:\n\n\t\t\t/*\n\t\t\t * Save the tuple into the unsorted array.  First, grow the array\n\t\t\t * as needed.  Note that we try to grow the array when there is\n\t\t\t * still one free slot remaining --- if we fail, there'll still be\n\t\t\t * room to store the incoming tuple, and then we'll switch to\n\t\t\t * tape-based operation.\n\t\t\t */\n\t\t\tif (state->memtupcount >= state->memtupsize - 1)\n\t\t\t{\n\t\t\t\t(void) grow_memtuples(state);\n\t\t\t\tAssert(state->memtupcount < state->memtupsize);\n\t\t\t}\n\t\t\tstate->memtuples[state->memtupcount++] = *tuple;\n\n\t\t\t/*\n\t\t\t * Check if it's time to switch over to a bounded heapsort. We do\n\t\t\t * so if the input tuple count exceeds twice the desired tuple\n\t\t\t * count (this is a heuristic for where heapsort becomes cheaper\n\t\t\t * than a quicksort), or if we've just filled workMem and have\n\t\t\t * enough tuples to meet the bound.\n\t\t\t *\n\t\t\t * Note that once we enter TSS_BOUNDED state we will always try to\n\t\t\t * complete the sort that way.  In the worst case, if later input\n\t\t\t * tuples are larger than earlier ones, this might cause us to\n\t\t\t * exceed workMem significantly.\n\t\t\t */\n\t\t\tif (state->bounded &&\n\t\t\t\t(state->memtupcount > state->bound * 2 ||\n\t\t\t\t (state->memtupcount > state->bound && LACKMEM(state))))\n\t\t\t{\n#ifdef TRACE_SORT\n\t\t\t\tif (trace_sort)\n\t\t\t\t\telog(LOG, \"switching to bounded heapsort at %d tuples: %s\",\n\t\t\t\t\t\t state->memtupcount,\n\t\t\t\t\t\t pg_rusage_show(&state->ru_start));\n#endif\n\t\t\t\tmake_bounded_heap(state);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Done if we still fit in available memory and have array slots.\n\t\t\t */\n\t\t\tif (state->memtupcount < state->memtupsize && !LACKMEM(state))\n\t\t\t\treturn;\n\n\t\t\t/*\n\t\t\t * Nope; time to switch to tape-based operation.\n\t\t\t */\n\t\t\tinittapes(state, true);\n\n\t\t\t/*\n\t\t\t * Dump all tuples.\n\t\t\t */\n\t\t\tdumptuples(state, false);\n\t\t\tbreak;\n\n\t\tcase TSS_BOUNDED:\n\n\t\t\t/*\n\t\t\t * We don't want to grow the array here, so check whether the new\n\t\t\t * tuple can be discarded before putting it in.  This should be a\n\t\t\t * good speed optimization, too, since when there are many more\n\t\t\t * input tuples than the bound, most input tuples can be discarded\n\t\t\t * with just this one comparison.  Note that because we currently\n\t\t\t * have the sort direction reversed, we must check for <= not >=.\n\t\t\t */\n\t\t\tif (COMPARETUP(state, tuple, &state->memtuples[0]) <= 0)\n\t\t\t{\n\t\t\t\t/* new tuple <= top of the heap, so we can discard it */\n\t\t\t\tfree_sort_tuple(state, tuple);\n\t\t\t\tCHECK_FOR_INTERRUPTS();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* discard top of heap, replacing it with the new tuple */\n\t\t\t\tfree_sort_tuple(state, &state->memtuples[0]);\n\t\t\t\ttuplesort_heap_replace_top(state, tuple);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TSS_BUILDRUNS:\n\n\t\t\t/*\n\t\t\t * Save the tuple into the unsorted array (there must be space)\n\t\t\t */\n\t\t\tstate->memtuples[state->memtupcount++] = *tuple;\n\n\t\t\t/*\n\t\t\t * If we are over the memory limit, dump all tuples.\n\t\t\t */\n\t\t\tdumptuples(state, false);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplesort state\");\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "COPYTUP",
          "args": [
            "state",
            "&stup",
            "(void *) slot"
          ],
          "line": 1443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "state->sortcontext"
          ],
          "line": 1436
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic bool mergereadnext(Tuplesortstate *state, int srcTape, SortTuple *stup);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic void writetup_heap(Tuplesortstate *state, int tapenum,\n\t\t\t  SortTuple *stup);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic void writetup_cluster(Tuplesortstate *state, int tapenum,\n\t\t\t\t SortTuple *stup);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic void writetup_index(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic void writetup_datum(Tuplesortstate *state, int tapenum,\n\t\t\t   SortTuple *stup);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\nstatic void free_sort_tuple(Tuplesortstate *state, SortTuple *stup);\n\nvoid\ntuplesort_puttupleslot(Tuplesortstate *state, TupleTableSlot *slot)\n{\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\tSortTuple\tstup;\n\n\t/*\n\t * Copy the given tuple into memory we control, and decrease availMem.\n\t * Then call the common code.\n\t */\n\tCOPYTUP(state, &stup, (void *) slot);\n\n\tputtuple_common(state, &stup);\n\n\tMemoryContextSwitchTo(oldcontext);\n}"
  },
  {
    "function_name": "grow_memtuples",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "1314-1426",
    "snippet": "static bool\ngrow_memtuples(Tuplesortstate *state)\n{\n\tint\t\t\tnewmemtupsize;\n\tint\t\t\tmemtupsize = state->memtupsize;\n\tint64\t\tmemNowUsed = state->allowedMem - state->availMem;\n\n\t/* Forget it if we've already maxed out memtuples, per comment above */\n\tif (!state->growmemtuples)\n\t\treturn false;\n\n\t/* Select new value of memtupsize */\n\tif (memNowUsed <= state->availMem)\n\t{\n\t\t/*\n\t\t * We've used no more than half of allowedMem; double our usage,\n\t\t * clamping at INT_MAX tuples.\n\t\t */\n\t\tif (memtupsize < INT_MAX / 2)\n\t\t\tnewmemtupsize = memtupsize * 2;\n\t\telse\n\t\t{\n\t\t\tnewmemtupsize = INT_MAX;\n\t\t\tstate->growmemtuples = false;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * This will be the last increment of memtupsize.  Abandon doubling\n\t\t * strategy and instead increase as much as we safely can.\n\t\t *\n\t\t * To stay within allowedMem, we can't increase memtupsize by more\n\t\t * than availMem / sizeof(SortTuple) elements.  In practice, we want\n\t\t * to increase it by considerably less, because we need to leave some\n\t\t * space for the tuples to which the new array slots will refer.  We\n\t\t * assume the new tuples will be about the same size as the tuples\n\t\t * we've already seen, and thus we can extrapolate from the space\n\t\t * consumption so far to estimate an appropriate new size for the\n\t\t * memtuples array.  The optimal value might be higher or lower than\n\t\t * this estimate, but it's hard to know that in advance.  We again\n\t\t * clamp at INT_MAX tuples.\n\t\t *\n\t\t * This calculation is safe against enlarging the array so much that\n\t\t * LACKMEM becomes true, because the memory currently used includes\n\t\t * the present array; thus, there would be enough allowedMem for the\n\t\t * new array elements even if no other memory were currently used.\n\t\t *\n\t\t * We do the arithmetic in float8, because otherwise the product of\n\t\t * memtupsize and allowedMem could overflow.  Any inaccuracy in the\n\t\t * result should be insignificant; but even if we computed a\n\t\t * completely insane result, the checks below will prevent anything\n\t\t * really bad from happening.\n\t\t */\n\t\tdouble\t\tgrow_ratio;\n\n\t\tgrow_ratio = (double) state->allowedMem / (double) memNowUsed;\n\t\tif (memtupsize * grow_ratio < INT_MAX)\n\t\t\tnewmemtupsize = (int) (memtupsize * grow_ratio);\n\t\telse\n\t\t\tnewmemtupsize = INT_MAX;\n\n\t\t/* We won't make any further enlargement attempts */\n\t\tstate->growmemtuples = false;\n\t}\n\n\t/* Must enlarge array by at least one element, else report failure */\n\tif (newmemtupsize <= memtupsize)\n\t\tgoto noalloc;\n\n\t/*\n\t * On a 32-bit machine, allowedMem could exceed MaxAllocHugeSize.  Clamp\n\t * to ensure our request won't be rejected.  Note that we can easily\n\t * exhaust address space before facing this outcome.  (This is presently\n\t * impossible due to guc.c's MAX_KILOBYTES limitation on work_mem, but\n\t * don't rely on that at this distance.)\n\t */\n\tif ((Size) newmemtupsize >= MaxAllocHugeSize / sizeof(SortTuple))\n\t{\n\t\tnewmemtupsize = (int) (MaxAllocHugeSize / sizeof(SortTuple));\n\t\tstate->growmemtuples = false;\t/* can't grow any more */\n\t}\n\n\t/*\n\t * We need to be sure that we do not cause LACKMEM to become true, else\n\t * the space management algorithm will go nuts.  The code above should\n\t * never generate a dangerous request, but to be safe, check explicitly\n\t * that the array growth fits within availMem.  (We could still cause\n\t * LACKMEM if the memory chunk overhead associated with the memtuples\n\t * array were to increase.  That shouldn't happen because we chose the\n\t * initial array size large enough to ensure that palloc will be treating\n\t * both old and new arrays as separate chunks.  But we'll check LACKMEM\n\t * explicitly below just in case.)\n\t */\n\tif (state->availMem < (int64) ((newmemtupsize - memtupsize) * sizeof(SortTuple)))\n\t\tgoto noalloc;\n\n\t/* OK, do it */\n\tFREEMEM(state, GetMemoryChunkSpace(state->memtuples));\n\tstate->memtupsize = newmemtupsize;\n\tstate->memtuples = (SortTuple *)\n\t\trepalloc_huge(state->memtuples,\n\t\t\t\t\t  state->memtupsize * sizeof(SortTuple));\n\tUSEMEM(state, GetMemoryChunkSpace(state->memtuples));\n\tif (LACKMEM(state))\n\t\telog(ERROR, \"unexpected out-of-memory situation in tuplesort\");\n\treturn true;\n\nnoalloc:\n\t/* If for any reason we didn't realloc, shut off future attempts */\n\tstate->growmemtuples = false;\n\treturn false;\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unexpected out-of-memory situation in tuplesort\""
          ],
          "line": 1419
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LACKMEM",
          "args": [
            "state"
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USEMEM",
          "args": [
            "state",
            "GetMemoryChunkSpace(state->memtuples)"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetMemoryChunkSpace",
          "args": [
            "state->memtuples"
          ],
          "line": 1417
        },
        "resolved": true,
        "details": {
          "function_name": "GetMemoryChunkSpace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "426-432",
          "snippet": "Size\nGetMemoryChunkSpace(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\treturn context->methods->get_chunk_space(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nSize\nGetMemoryChunkSpace(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\treturn context->methods->get_chunk_space(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "repalloc_huge",
          "args": [
            "state->memtuples",
            "state->memtupsize * sizeof(SortTuple)"
          ],
          "line": 1415
        },
        "resolved": true,
        "details": {
          "function_name": "repalloc_huge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1113-1141",
          "snippet": "void *\nrepalloc_huge(void *pointer, Size size)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\tvoid\t   *ret;\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tAssertNotInCriticalSection(context);\n\n\t/* isReset must be false already */\n\tAssert(!context->isReset);\n\n\tret = context->methods->realloc(context, pointer, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_CHANGE(context, pointer, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nrepalloc_huge(void *pointer, Size size)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\tvoid\t   *ret;\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tAssertNotInCriticalSection(context);\n\n\t/* isReset must be false already */\n\tAssert(!context->isReset);\n\n\tret = context->methods->realloc(context, pointer, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_CHANGE(context, pointer, ret, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FREEMEM",
          "args": [
            "state",
            "GetMemoryChunkSpace(state->memtuples)"
          ],
          "line": 1412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(newmemtupsize - memtupsize) * sizeof(SortTuple)"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic bool\ngrow_memtuples(Tuplesortstate *state)\n{\n\tint\t\t\tnewmemtupsize;\n\tint\t\t\tmemtupsize = state->memtupsize;\n\tint64\t\tmemNowUsed = state->allowedMem - state->availMem;\n\n\t/* Forget it if we've already maxed out memtuples, per comment above */\n\tif (!state->growmemtuples)\n\t\treturn false;\n\n\t/* Select new value of memtupsize */\n\tif (memNowUsed <= state->availMem)\n\t{\n\t\t/*\n\t\t * We've used no more than half of allowedMem; double our usage,\n\t\t * clamping at INT_MAX tuples.\n\t\t */\n\t\tif (memtupsize < INT_MAX / 2)\n\t\t\tnewmemtupsize = memtupsize * 2;\n\t\telse\n\t\t{\n\t\t\tnewmemtupsize = INT_MAX;\n\t\t\tstate->growmemtuples = false;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * This will be the last increment of memtupsize.  Abandon doubling\n\t\t * strategy and instead increase as much as we safely can.\n\t\t *\n\t\t * To stay within allowedMem, we can't increase memtupsize by more\n\t\t * than availMem / sizeof(SortTuple) elements.  In practice, we want\n\t\t * to increase it by considerably less, because we need to leave some\n\t\t * space for the tuples to which the new array slots will refer.  We\n\t\t * assume the new tuples will be about the same size as the tuples\n\t\t * we've already seen, and thus we can extrapolate from the space\n\t\t * consumption so far to estimate an appropriate new size for the\n\t\t * memtuples array.  The optimal value might be higher or lower than\n\t\t * this estimate, but it's hard to know that in advance.  We again\n\t\t * clamp at INT_MAX tuples.\n\t\t *\n\t\t * This calculation is safe against enlarging the array so much that\n\t\t * LACKMEM becomes true, because the memory currently used includes\n\t\t * the present array; thus, there would be enough allowedMem for the\n\t\t * new array elements even if no other memory were currently used.\n\t\t *\n\t\t * We do the arithmetic in float8, because otherwise the product of\n\t\t * memtupsize and allowedMem could overflow.  Any inaccuracy in the\n\t\t * result should be insignificant; but even if we computed a\n\t\t * completely insane result, the checks below will prevent anything\n\t\t * really bad from happening.\n\t\t */\n\t\tdouble\t\tgrow_ratio;\n\n\t\tgrow_ratio = (double) state->allowedMem / (double) memNowUsed;\n\t\tif (memtupsize * grow_ratio < INT_MAX)\n\t\t\tnewmemtupsize = (int) (memtupsize * grow_ratio);\n\t\telse\n\t\t\tnewmemtupsize = INT_MAX;\n\n\t\t/* We won't make any further enlargement attempts */\n\t\tstate->growmemtuples = false;\n\t}\n\n\t/* Must enlarge array by at least one element, else report failure */\n\tif (newmemtupsize <= memtupsize)\n\t\tgoto noalloc;\n\n\t/*\n\t * On a 32-bit machine, allowedMem could exceed MaxAllocHugeSize.  Clamp\n\t * to ensure our request won't be rejected.  Note that we can easily\n\t * exhaust address space before facing this outcome.  (This is presently\n\t * impossible due to guc.c's MAX_KILOBYTES limitation on work_mem, but\n\t * don't rely on that at this distance.)\n\t */\n\tif ((Size) newmemtupsize >= MaxAllocHugeSize / sizeof(SortTuple))\n\t{\n\t\tnewmemtupsize = (int) (MaxAllocHugeSize / sizeof(SortTuple));\n\t\tstate->growmemtuples = false;\t/* can't grow any more */\n\t}\n\n\t/*\n\t * We need to be sure that we do not cause LACKMEM to become true, else\n\t * the space management algorithm will go nuts.  The code above should\n\t * never generate a dangerous request, but to be safe, check explicitly\n\t * that the array growth fits within availMem.  (We could still cause\n\t * LACKMEM if the memory chunk overhead associated with the memtuples\n\t * array were to increase.  That shouldn't happen because we chose the\n\t * initial array size large enough to ensure that palloc will be treating\n\t * both old and new arrays as separate chunks.  But we'll check LACKMEM\n\t * explicitly below just in case.)\n\t */\n\tif (state->availMem < (int64) ((newmemtupsize - memtupsize) * sizeof(SortTuple)))\n\t\tgoto noalloc;\n\n\t/* OK, do it */\n\tFREEMEM(state, GetMemoryChunkSpace(state->memtuples));\n\tstate->memtupsize = newmemtupsize;\n\tstate->memtuples = (SortTuple *)\n\t\trepalloc_huge(state->memtuples,\n\t\t\t\t\t  state->memtupsize * sizeof(SortTuple));\n\tUSEMEM(state, GetMemoryChunkSpace(state->memtuples));\n\tif (LACKMEM(state))\n\t\telog(ERROR, \"unexpected out-of-memory situation in tuplesort\");\n\treturn true;\n\nnoalloc:\n\t/* If for any reason we didn't realloc, shut off future attempts */\n\tstate->growmemtuples = false;\n\treturn false;\n}"
  },
  {
    "function_name": "tuplesort_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "1234-1297",
    "snippet": "void\ntuplesort_end(Tuplesortstate *state)\n{\n\t/* context swap probably not needed, but let's be safe */\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\n#ifdef TRACE_SORT\n\tlong\t\tspaceUsed;\n\n\tif (state->tapeset)\n\t\tspaceUsed = LogicalTapeSetBlocks(state->tapeset);\n\telse\n\t\tspaceUsed = (state->allowedMem - state->availMem + 1023) / 1024;\n#endif\n\n\t/*\n\t * Delete temporary \"tape\" files, if any.\n\t *\n\t * Note: want to include this in reported total cost of sort, hence need\n\t * for two #ifdef TRACE_SORT sections.\n\t */\n\tif (state->tapeset)\n\t\tLogicalTapeSetClose(state->tapeset);\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t{\n\t\tif (state->tapeset)\n\t\t\telog(LOG, \"%s of worker %d ended, %ld disk blocks used: %s\",\n\t\t\t\t SERIAL(state) ? \"external sort\" : \"parallel external sort\",\n\t\t\t\t state->worker, spaceUsed, pg_rusage_show(&state->ru_start));\n\t\telse\n\t\t\telog(LOG, \"%s of worker %d ended, %ld KB used: %s\",\n\t\t\t\t SERIAL(state) ? \"internal sort\" : \"unperformed parallel sort\",\n\t\t\t\t state->worker, spaceUsed, pg_rusage_show(&state->ru_start));\n\t}\n\n\tTRACE_POSTGRESQL_SORT_DONE(state->tapeset != NULL, spaceUsed);\n#else\n\n\t/*\n\t * If you disabled TRACE_SORT, you can still probe sort__done, but you\n\t * ain't getting space-used stats.\n\t */\n\tTRACE_POSTGRESQL_SORT_DONE(state->tapeset != NULL, 0L);\n#endif\n\n\t/* Free any execution state created for CLUSTER case */\n\tif (state->estate != NULL)\n\t{\n\t\tExprContext *econtext = GetPerTupleExprContext(state->estate);\n\n\t\tExecDropSingleTupleTableSlot(econtext->ecxt_scantuple);\n\t\tFreeExecutorState(state->estate);\n\t}\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\t/*\n\t * Free the per-sort memory context, thereby releasing all working memory,\n\t * including the Tuplesortstate struct itself.\n\t */\n\tMemoryContextDelete(state->sortcontext);\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextDelete",
          "args": [
            "state->sortcontext"
          ],
          "line": 1296
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextDeleteChildren",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "255-266",
          "snippet": "void\nMemoryContextDeleteChildren(MemoryContext context)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\n\t/*\n\t * MemoryContextDelete will delink the child from me, so just iterate as\n\t * long as there is a child.\n\t */\n\twhile (context->firstchild != NULL)\n\t\tMemoryContextDelete(context->firstchild);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\nMemoryContextDeleteChildren(MemoryContext context)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\n\t/*\n\t * MemoryContextDelete will delink the child from me, so just iterate as\n\t * long as there is a child.\n\t */\n\twhile (context->firstchild != NULL)\n\t\tMemoryContextDelete(context->firstchild);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FreeExecutorState",
          "args": [
            "state->estate"
          ],
          "line": 1287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ExecDropSingleTupleTableSlot",
          "args": [
            "econtext->ecxt_scantuple"
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetPerTupleExprContext",
          "args": [
            "state->estate"
          ],
          "line": 1284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRACE_POSTGRESQL_SORT_DONE",
          "args": [
            "state->tapeset != NULL",
            "0L"
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRACE_POSTGRESQL_SORT_DONE",
          "args": [
            "state->tapeset != NULL",
            "spaceUsed"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "LOG",
            "\"%s of worker %d ended, %ld KB used: %s\"",
            "SERIAL(state) ? \"internal sort\" : \"unperformed parallel sort\"",
            "state->worker",
            "spaceUsed",
            "pg_rusage_show(&state->ru_start)"
          ],
          "line": 1266
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_rusage_show",
          "args": [
            "&state->ru_start"
          ],
          "line": 1268
        },
        "resolved": true,
        "details": {
          "function_name": "pg_rusage_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/pg_rusage.c",
          "lines": "39-73",
          "snippet": "const char *\npg_rusage_show(const PGRUsage *ru0)\n{\n\tstatic char result[100];\n\tPGRUsage\tru1;\n\n\tpg_rusage_init(&ru1);\n\n\tif (ru1.tv.tv_usec < ru0->tv.tv_usec)\n\t{\n\t\tru1.tv.tv_sec--;\n\t\tru1.tv.tv_usec += 1000000;\n\t}\n\tif (ru1.ru.ru_stime.tv_usec < ru0->ru.ru_stime.tv_usec)\n\t{\n\t\tru1.ru.ru_stime.tv_sec--;\n\t\tru1.ru.ru_stime.tv_usec += 1000000;\n\t}\n\tif (ru1.ru.ru_utime.tv_usec < ru0->ru.ru_utime.tv_usec)\n\t{\n\t\tru1.ru.ru_utime.tv_sec--;\n\t\tru1.ru.ru_utime.tv_usec += 1000000;\n\t}\n\n\tsnprintf(result, sizeof(result),\n\t\t\t _(\"CPU: user: %d.%02d s, system: %d.%02d s, elapsed: %d.%02d s\"),\n\t\t\t (int) (ru1.ru.ru_utime.tv_sec - ru0->ru.ru_utime.tv_sec),\n\t\t\t (int) (ru1.ru.ru_utime.tv_usec - ru0->ru.ru_utime.tv_usec) / 10000,\n\t\t\t (int) (ru1.ru.ru_stime.tv_sec - ru0->ru.ru_stime.tv_sec),\n\t\t\t (int) (ru1.ru.ru_stime.tv_usec - ru0->ru.ru_stime.tv_usec) / 10000,\n\t\t\t (int) (ru1.tv.tv_sec - ru0->tv.tv_sec),\n\t\t\t (int) (ru1.tv.tv_usec - ru0->tv.tv_usec) / 10000);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/pg_rusage.h\"",
            "#include <unistd.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_rusage.h\"\n#include <unistd.h>\n#include \"postgres.h\"\n\nconst char *\npg_rusage_show(const PGRUsage *ru0)\n{\n\tstatic char result[100];\n\tPGRUsage\tru1;\n\n\tpg_rusage_init(&ru1);\n\n\tif (ru1.tv.tv_usec < ru0->tv.tv_usec)\n\t{\n\t\tru1.tv.tv_sec--;\n\t\tru1.tv.tv_usec += 1000000;\n\t}\n\tif (ru1.ru.ru_stime.tv_usec < ru0->ru.ru_stime.tv_usec)\n\t{\n\t\tru1.ru.ru_stime.tv_sec--;\n\t\tru1.ru.ru_stime.tv_usec += 1000000;\n\t}\n\tif (ru1.ru.ru_utime.tv_usec < ru0->ru.ru_utime.tv_usec)\n\t{\n\t\tru1.ru.ru_utime.tv_sec--;\n\t\tru1.ru.ru_utime.tv_usec += 1000000;\n\t}\n\n\tsnprintf(result, sizeof(result),\n\t\t\t _(\"CPU: user: %d.%02d s, system: %d.%02d s, elapsed: %d.%02d s\"),\n\t\t\t (int) (ru1.ru.ru_utime.tv_sec - ru0->ru.ru_utime.tv_sec),\n\t\t\t (int) (ru1.ru.ru_utime.tv_usec - ru0->ru.ru_utime.tv_usec) / 10000,\n\t\t\t (int) (ru1.ru.ru_stime.tv_sec - ru0->ru.ru_stime.tv_sec),\n\t\t\t (int) (ru1.ru.ru_stime.tv_usec - ru0->ru.ru_stime.tv_usec) / 10000,\n\t\t\t (int) (ru1.tv.tv_sec - ru0->tv.tv_sec),\n\t\t\t (int) (ru1.tv.tv_usec - ru0->tv.tv_usec) / 10000);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SERIAL",
          "args": [
            "state"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SERIAL",
          "args": [
            "state"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LogicalTapeSetClose",
          "args": [
            "state->tapeset"
          ],
          "line": 1256
        },
        "resolved": true,
        "details": {
          "function_name": "LogicalTapeSetClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/logtape.c",
          "lines": "583-598",
          "snippet": "void\nLogicalTapeSetClose(LogicalTapeSet *lts)\n{\n\tLogicalTape *lt;\n\tint\t\t\ti;\n\n\tBufFileClose(lts->pfile);\n\tfor (i = 0; i < lts->nTapes; i++)\n\t{\n\t\tlt = &lts->tapes[i];\n\t\tif (lt->buffer)\n\t\t\tpfree(lt->buffer);\n\t}\n\tpfree(lts->freeBlocks);\n\tpfree(lts);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
            "static void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);",
            "static long ltsGetFreeBlock(LogicalTapeSet *lts);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/logtape.h\"\n#include \"utils/builtins.h\"\n#include \"storage/buffile.h\"\n#include \"postgres.h\"\n\nstatic void ltsWriteBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic void ltsReadBlock(LogicalTapeSet *lts, long blocknum, void *buffer);\nstatic long ltsGetFreeBlock(LogicalTapeSet *lts);\n\nvoid\nLogicalTapeSetClose(LogicalTapeSet *lts)\n{\n\tLogicalTape *lt;\n\tint\t\t\ti;\n\n\tBufFileClose(lts->pfile);\n\tfor (i = 0; i < lts->nTapes; i++)\n\t{\n\t\tlt = &lts->tapes[i];\n\t\tif (lt->buffer)\n\t\t\tpfree(lt->buffer);\n\t}\n\tpfree(lts->freeBlocks);\n\tpfree(lts);\n}"
        }
      },
      {
        "call_info": {
          "callee": "LogicalTapeSetBlocks",
          "args": [
            "state->tapeset"
          ],
          "line": 1244
        },
        "resolved": true,
        "details": {
          "function_name": "LogicalTapeSetBlocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/logtape.c",
          "lines": "1081-1085",
          "snippet": "long\nLogicalTapeSetBlocks(LogicalTapeSet *lts)\n{\n\treturn lts->nBlocksAllocated - lts->nHoleBlocks;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long ltsGetFreeBlock(LogicalTapeSet *lts);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/logtape.h\"\n#include \"utils/builtins.h\"\n#include \"storage/buffile.h\"\n#include \"postgres.h\"\n\nstatic long ltsGetFreeBlock(LogicalTapeSet *lts);\n\nlong\nLogicalTapeSetBlocks(LogicalTapeSet *lts)\n{\n\treturn lts->nBlocksAllocated - lts->nHoleBlocks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "state->sortcontext"
          ],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nvoid\ntuplesort_end(Tuplesortstate *state)\n{\n\t/* context swap probably not needed, but let's be safe */\n\tMemoryContext oldcontext = MemoryContextSwitchTo(state->sortcontext);\n\n#ifdef TRACE_SORT\n\tlong\t\tspaceUsed;\n\n\tif (state->tapeset)\n\t\tspaceUsed = LogicalTapeSetBlocks(state->tapeset);\n\telse\n\t\tspaceUsed = (state->allowedMem - state->availMem + 1023) / 1024;\n#endif\n\n\t/*\n\t * Delete temporary \"tape\" files, if any.\n\t *\n\t * Note: want to include this in reported total cost of sort, hence need\n\t * for two #ifdef TRACE_SORT sections.\n\t */\n\tif (state->tapeset)\n\t\tLogicalTapeSetClose(state->tapeset);\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t{\n\t\tif (state->tapeset)\n\t\t\telog(LOG, \"%s of worker %d ended, %ld disk blocks used: %s\",\n\t\t\t\t SERIAL(state) ? \"external sort\" : \"parallel external sort\",\n\t\t\t\t state->worker, spaceUsed, pg_rusage_show(&state->ru_start));\n\t\telse\n\t\t\telog(LOG, \"%s of worker %d ended, %ld KB used: %s\",\n\t\t\t\t SERIAL(state) ? \"internal sort\" : \"unperformed parallel sort\",\n\t\t\t\t state->worker, spaceUsed, pg_rusage_show(&state->ru_start));\n\t}\n\n\tTRACE_POSTGRESQL_SORT_DONE(state->tapeset != NULL, spaceUsed);\n#else\n\n\t/*\n\t * If you disabled TRACE_SORT, you can still probe sort__done, but you\n\t * ain't getting space-used stats.\n\t */\n\tTRACE_POSTGRESQL_SORT_DONE(state->tapeset != NULL, 0L);\n#endif\n\n\t/* Free any execution state created for CLUSTER case */\n\tif (state->estate != NULL)\n\t{\n\t\tExprContext *econtext = GetPerTupleExprContext(state->estate);\n\n\t\tExecDropSingleTupleTableSlot(econtext->ecxt_scantuple);\n\t\tFreeExecutorState(state->estate);\n\t}\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\t/*\n\t * Free the per-sort memory context, thereby releasing all working memory,\n\t * including the Tuplesortstate struct itself.\n\t */\n\tMemoryContextDelete(state->sortcontext);\n}"
  },
  {
    "function_name": "tuplesort_set_bound",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "1185-1223",
    "snippet": "void\ntuplesort_set_bound(Tuplesortstate *state, int64 bound)\n{\n\t/* Assert we're called before loading any tuples */\n\tAssert(state->status == TSS_INITIAL);\n\tAssert(state->memtupcount == 0);\n\tAssert(!state->bounded);\n\tAssert(!WORKER(state));\n\n#ifdef DEBUG_BOUNDED_SORT\n\t/* Honor GUC setting that disables the feature (for easy testing) */\n\tif (!optimize_bounded_sort)\n\t\treturn;\n#endif\n\n\t/* Parallel leader ignores hint */\n\tif (LEADER(state))\n\t\treturn;\n\n\t/* We want to be able to compute bound * 2, so limit the setting */\n\tif (bound > (int64) (INT_MAX / 2))\n\t\treturn;\n\n\tstate->bounded = true;\n\tstate->bound = (int) bound;\n\n\t/*\n\t * Bounded sorts are not an effective target for abbreviated key\n\t * optimization.  Disable by setting state to be consistent with no\n\t * abbreviation support.\n\t */\n\tstate->sortKeys->abbrev_converter = NULL;\n\tif (state->sortKeys->abbrev_full_comparator)\n\t\tstate->sortKeys->comparator = state->sortKeys->abbrev_full_comparator;\n\n\t/* Not strictly necessary, but be tidy */\n\tstate->sortKeys->abbrev_abort = NULL;\n\tstate->sortKeys->abbrev_full_comparator = NULL;\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "INT_MAX / 2"
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LEADER",
          "args": [
            "state"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!WORKER(state)"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WORKER",
          "args": [
            "state"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!state->bounded"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "state->memtupcount == 0"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "state->status == TSS_INITIAL"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nvoid\ntuplesort_set_bound(Tuplesortstate *state, int64 bound)\n{\n\t/* Assert we're called before loading any tuples */\n\tAssert(state->status == TSS_INITIAL);\n\tAssert(state->memtupcount == 0);\n\tAssert(!state->bounded);\n\tAssert(!WORKER(state));\n\n#ifdef DEBUG_BOUNDED_SORT\n\t/* Honor GUC setting that disables the feature (for easy testing) */\n\tif (!optimize_bounded_sort)\n\t\treturn;\n#endif\n\n\t/* Parallel leader ignores hint */\n\tif (LEADER(state))\n\t\treturn;\n\n\t/* We want to be able to compute bound * 2, so limit the setting */\n\tif (bound > (int64) (INT_MAX / 2))\n\t\treturn;\n\n\tstate->bounded = true;\n\tstate->bound = (int) bound;\n\n\t/*\n\t * Bounded sorts are not an effective target for abbreviated key\n\t * optimization.  Disable by setting state to be consistent with no\n\t * abbreviation support.\n\t */\n\tstate->sortKeys->abbrev_converter = NULL;\n\tif (state->sortKeys->abbrev_full_comparator)\n\t\tstate->sortKeys->comparator = state->sortKeys->abbrev_full_comparator;\n\n\t/* Not strictly necessary, but be tidy */\n\tstate->sortKeys->abbrev_abort = NULL;\n\tstate->sortKeys->abbrev_full_comparator = NULL;\n}"
  },
  {
    "function_name": "tuplesort_begin_datum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "1098-1171",
    "snippet": "Tuplesortstate *\ntuplesort_begin_datum(Oid datumType, Oid sortOperator, Oid sortCollation,\n\t\t\t\t\t  bool nullsFirstFlag, int workMem,\n\t\t\t\t\t  SortCoordinate coordinate, bool randomAccess)\n{\n\tTuplesortstate *state = tuplesort_begin_common(workMem, coordinate,\n\t\t\t\t\t\t\t\t\t\t\t\t   randomAccess);\n\tMemoryContext oldcontext;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\n\toldcontext = MemoryContextSwitchTo(state->sortcontext);\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\telog(LOG,\n\t\t\t \"begin datum sort: workMem = %d, randomAccess = %c\",\n\t\t\t workMem, randomAccess ? 't' : 'f');\n#endif\n\n\tstate->nKeys = 1;\t\t\t/* always a one-column sort */\n\n\tTRACE_POSTGRESQL_SORT_START(DATUM_SORT,\n\t\t\t\t\t\t\t\tfalse,\t/* no unique check */\n\t\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\t\tworkMem,\n\t\t\t\t\t\t\t\trandomAccess,\n\t\t\t\t\t\t\t\tPARALLEL_SORT(state));\n\n\tstate->comparetup = comparetup_datum;\n\tstate->copytup = copytup_datum;\n\tstate->writetup = writetup_datum;\n\tstate->readtup = readtup_datum;\n\tstate->abbrevNext = 10;\n\n\tstate->datumType = datumType;\n\n\t/* lookup necessary attributes of the datum type */\n\tget_typlenbyval(datumType, &typlen, &typbyval);\n\tstate->datumTypeLen = typlen;\n\tstate->tuples = !typbyval;\n\n\t/* Prepare SortSupport data */\n\tstate->sortKeys = (SortSupport) palloc0(sizeof(SortSupportData));\n\n\tstate->sortKeys->ssup_cxt = CurrentMemoryContext;\n\tstate->sortKeys->ssup_collation = sortCollation;\n\tstate->sortKeys->ssup_nulls_first = nullsFirstFlag;\n\n\t/*\n\t * Abbreviation is possible here only for by-reference types.  In theory,\n\t * a pass-by-value datatype could have an abbreviated form that is cheaper\n\t * to compare.  In a tuple sort, we could support that, because we can\n\t * always extract the original datum from the tuple is needed.  Here, we\n\t * can't, because a datum sort only stores a single copy of the datum; the\n\t * \"tuple\" field of each sortTuple is NULL.\n\t */\n\tstate->sortKeys->abbreviate = !typbyval;\n\n\tPrepareSortSupportFromOrderingOp(sortOperator, state->sortKeys);\n\n\t/*\n\t * The \"onlyKey\" optimization cannot be used with abbreviated keys, since\n\t * tie-breaker comparisons may be required.  Typically, the optimization\n\t * is only of value to pass-by-value types anyway, whereas abbreviated\n\t * keys are typically only of value to pass-by-reference types.\n\t */\n\tif (!state->sortKeys->abbrev_converter)\n\t\tstate->onlyKey = state->sortKeys;\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn state;\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define DATUM_SORT\t\t2"
    ],
    "globals_used": [
      "static Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);",
      "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrepareSortSupportFromOrderingOp",
          "args": [
            "sortOperator",
            "state->sortKeys"
          ],
          "line": 1157
        },
        "resolved": true,
        "details": {
          "function_name": "PrepareSortSupportFromOrderingOp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/sortsupport.c",
          "lines": "132-149",
          "snippet": "void\nPrepareSortSupportFromOrderingOp(Oid orderingOp, SortSupport ssup)\n{\n\tOid\t\t\topfamily;\n\tOid\t\t\topcintype;\n\tint16\t\tstrategy;\n\n\tAssert(ssup->comparator == NULL);\n\n\t/* Find the operator in pg_amop */\n\tif (!get_ordering_op_properties(orderingOp, &opfamily, &opcintype,\n\t\t\t\t\t\t\t\t\t&strategy))\n\t\telog(ERROR, \"operator %u is not a valid ordering operator\",\n\t\t\t orderingOp);\n\tssup->ssup_reverse = (strategy == BTGreaterStrategyNumber);\n\n\tFinishSortSupportFunction(opfamily, opcintype, ssup);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_am.h\"\n#include \"access/nbtree.h\"\n#include \"postgres.h\"\n\nvoid\nPrepareSortSupportFromOrderingOp(Oid orderingOp, SortSupport ssup)\n{\n\tOid\t\t\topfamily;\n\tOid\t\t\topcintype;\n\tint16\t\tstrategy;\n\n\tAssert(ssup->comparator == NULL);\n\n\t/* Find the operator in pg_amop */\n\tif (!get_ordering_op_properties(orderingOp, &opfamily, &opcintype,\n\t\t\t\t\t\t\t\t\t&strategy))\n\t\telog(ERROR, \"operator %u is not a valid ordering operator\",\n\t\t\t orderingOp);\n\tssup->ssup_reverse = (strategy == BTGreaterStrategyNumber);\n\n\tFinishSortSupportFunction(opfamily, opcintype, ssup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "sizeof(SortSupportData)"
          ],
          "line": 1141
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_typlenbyval",
          "args": [
            "datumType",
            "&typlen",
            "&typbyval"
          ],
          "line": 1136
        },
        "resolved": true,
        "details": {
          "function_name": "get_typlenbyval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2028-2041",
          "snippet": "void\nget_typlenbyval(Oid typid, int16 *typlen, bool *typbyval)\n{\n\tHeapTuple\ttp;\n\tForm_pg_type typtup;\n\n\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t*typlen = typtup->typlen;\n\t*typbyval = typtup->typbyval;\n\tReleaseSysCache(tp);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nget_typlenbyval(Oid typid, int16 *typlen, bool *typbyval)\n{\n\tHeapTuple\ttp;\n\tForm_pg_type typtup;\n\n\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t*typlen = typtup->typlen;\n\t*typbyval = typtup->typbyval;\n\tReleaseSysCache(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TRACE_POSTGRESQL_SORT_START",
          "args": [
            "DATUM_SORT",
            "false",
            "/* no unique check */1",
            "workMem",
            "randomAccess",
            "PARALLEL_SORT(state)"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PARALLEL_SORT",
          "args": [
            "state"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "LOG",
            "\"begin datum sort: workMem = %d, randomAccess = %c\"",
            "workMem",
            "randomAccess ? 't' : 'f'"
          ],
          "line": 1113
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "state->sortcontext"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tuplesort_begin_common",
          "args": [
            "workMem",
            "coordinate",
            "randomAccess"
          ],
          "line": 1103
        },
        "resolved": true,
        "details": {
          "function_name": "tuplesort_begin_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "680-803",
          "snippet": "static Tuplesortstate *\ntuplesort_begin_common(int workMem, SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess)\n{\n\tTuplesortstate *state;\n\tMemoryContext sortcontext;\n\tMemoryContext tuplecontext;\n\tMemoryContext oldcontext;\n\n\t/* See leader_takeover_tapes() remarks on randomAccess support */\n\tif (coordinate && randomAccess)\n\t\telog(ERROR, \"random access disallowed under parallel sort\");\n\n\t/*\n\t * Create a working memory context for this sort operation. All data\n\t * needed by the sort will live inside this context.\n\t */\n\tsortcontext = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\"TupleSort main\",\n\t\t\t\t\t\t\t\t\t\tALLOCSET_DEFAULT_SIZES);\n\n\t/*\n\t * Caller tuple (e.g. IndexTuple) memory context.\n\t *\n\t * A dedicated child context used exclusively for caller passed tuples\n\t * eases memory management.  Resetting at key points reduces\n\t * fragmentation. Note that the memtuples array of SortTuples is allocated\n\t * in the parent context, not this context, because there is no need to\n\t * free memtuples early.\n\t */\n\ttuplecontext = AllocSetContextCreate(sortcontext,\n\t\t\t\t\t\t\t\t\t\t \"Caller tuples\",\n\t\t\t\t\t\t\t\t\t\t ALLOCSET_DEFAULT_SIZES);\n\n\t/*\n\t * Make the Tuplesortstate within the per-sort context.  This way, we\n\t * don't need a separate pfree() operation for it at shutdown.\n\t */\n\toldcontext = MemoryContextSwitchTo(sortcontext);\n\n\tstate = (Tuplesortstate *) palloc0(sizeof(Tuplesortstate));\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\tpg_rusage_init(&state->ru_start);\n#endif\n\n\tstate->status = TSS_INITIAL;\n\tstate->randomAccess = randomAccess;\n\tstate->bounded = false;\n\tstate->tuples = true;\n\tstate->boundUsed = false;\n\n\t/*\n\t * workMem is forced to be at least 64KB, the current minimum valid value\n\t * for the work_mem GUC.  This is a defense against parallel sort callers\n\t * that divide out memory among many workers in a way that leaves each\n\t * with very little memory.\n\t */\n\tstate->allowedMem = Max(workMem, 64) * (int64) 1024;\n\tstate->availMem = state->allowedMem;\n\tstate->sortcontext = sortcontext;\n\tstate->tuplecontext = tuplecontext;\n\tstate->tapeset = NULL;\n\n\tstate->memtupcount = 0;\n\n\t/*\n\t * Initial size of array must be more than ALLOCSET_SEPARATE_THRESHOLD;\n\t * see comments in grow_memtuples().\n\t */\n\tstate->memtupsize = Max(1024,\n\t\t\t\t\t\t\tALLOCSET_SEPARATE_THRESHOLD / sizeof(SortTuple) + 1);\n\n\tstate->growmemtuples = true;\n\tstate->slabAllocatorUsed = false;\n\tstate->memtuples = (SortTuple *) palloc(state->memtupsize * sizeof(SortTuple));\n\n\tUSEMEM(state, GetMemoryChunkSpace(state->memtuples));\n\n\t/* workMem must be large enough for the minimal memtuples array */\n\tif (LACKMEM(state))\n\t\telog(ERROR, \"insufficient memory allowed for sort\");\n\n\tstate->currentRun = 0;\n\n\t/*\n\t * maxTapes, tapeRange, and Algorithm D variables will be initialized by\n\t * inittapes(), if needed\n\t */\n\n\tstate->result_tape = -1;\t/* flag that result tape has not been formed */\n\n\t/*\n\t * Initialize parallel-related state based on coordination information\n\t * from caller\n\t */\n\tif (!coordinate)\n\t{\n\t\t/* Serial sort */\n\t\tstate->shared = NULL;\n\t\tstate->worker = -1;\n\t\tstate->nParticipants = -1;\n\t}\n\telse if (coordinate->isWorker)\n\t{\n\t\t/* Parallel worker produces exactly one final run from all input */\n\t\tstate->shared = coordinate->sharedsort;\n\t\tstate->worker = worker_get_identifier(state);\n\t\tstate->nParticipants = -1;\n\t}\n\telse\n\t{\n\t\t/* Parallel leader state only used for final merge */\n\t\tstate->shared = coordinate->sharedsort;\n\t\tstate->worker = -1;\n\t\tstate->nParticipants = coordinate->nParticipants;\n\t\tAssert(state->nParticipants >= 1);\n\t}\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn state;\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);",
            "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void inittapestate(Tuplesortstate *state, int maxTapes);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void inittapestate(Tuplesortstate *state, int maxTapes);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic Tuplesortstate *\ntuplesort_begin_common(int workMem, SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess)\n{\n\tTuplesortstate *state;\n\tMemoryContext sortcontext;\n\tMemoryContext tuplecontext;\n\tMemoryContext oldcontext;\n\n\t/* See leader_takeover_tapes() remarks on randomAccess support */\n\tif (coordinate && randomAccess)\n\t\telog(ERROR, \"random access disallowed under parallel sort\");\n\n\t/*\n\t * Create a working memory context for this sort operation. All data\n\t * needed by the sort will live inside this context.\n\t */\n\tsortcontext = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\"TupleSort main\",\n\t\t\t\t\t\t\t\t\t\tALLOCSET_DEFAULT_SIZES);\n\n\t/*\n\t * Caller tuple (e.g. IndexTuple) memory context.\n\t *\n\t * A dedicated child context used exclusively for caller passed tuples\n\t * eases memory management.  Resetting at key points reduces\n\t * fragmentation. Note that the memtuples array of SortTuples is allocated\n\t * in the parent context, not this context, because there is no need to\n\t * free memtuples early.\n\t */\n\ttuplecontext = AllocSetContextCreate(sortcontext,\n\t\t\t\t\t\t\t\t\t\t \"Caller tuples\",\n\t\t\t\t\t\t\t\t\t\t ALLOCSET_DEFAULT_SIZES);\n\n\t/*\n\t * Make the Tuplesortstate within the per-sort context.  This way, we\n\t * don't need a separate pfree() operation for it at shutdown.\n\t */\n\toldcontext = MemoryContextSwitchTo(sortcontext);\n\n\tstate = (Tuplesortstate *) palloc0(sizeof(Tuplesortstate));\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\tpg_rusage_init(&state->ru_start);\n#endif\n\n\tstate->status = TSS_INITIAL;\n\tstate->randomAccess = randomAccess;\n\tstate->bounded = false;\n\tstate->tuples = true;\n\tstate->boundUsed = false;\n\n\t/*\n\t * workMem is forced to be at least 64KB, the current minimum valid value\n\t * for the work_mem GUC.  This is a defense against parallel sort callers\n\t * that divide out memory among many workers in a way that leaves each\n\t * with very little memory.\n\t */\n\tstate->allowedMem = Max(workMem, 64) * (int64) 1024;\n\tstate->availMem = state->allowedMem;\n\tstate->sortcontext = sortcontext;\n\tstate->tuplecontext = tuplecontext;\n\tstate->tapeset = NULL;\n\n\tstate->memtupcount = 0;\n\n\t/*\n\t * Initial size of array must be more than ALLOCSET_SEPARATE_THRESHOLD;\n\t * see comments in grow_memtuples().\n\t */\n\tstate->memtupsize = Max(1024,\n\t\t\t\t\t\t\tALLOCSET_SEPARATE_THRESHOLD / sizeof(SortTuple) + 1);\n\n\tstate->growmemtuples = true;\n\tstate->slabAllocatorUsed = false;\n\tstate->memtuples = (SortTuple *) palloc(state->memtupsize * sizeof(SortTuple));\n\n\tUSEMEM(state, GetMemoryChunkSpace(state->memtuples));\n\n\t/* workMem must be large enough for the minimal memtuples array */\n\tif (LACKMEM(state))\n\t\telog(ERROR, \"insufficient memory allowed for sort\");\n\n\tstate->currentRun = 0;\n\n\t/*\n\t * maxTapes, tapeRange, and Algorithm D variables will be initialized by\n\t * inittapes(), if needed\n\t */\n\n\tstate->result_tape = -1;\t/* flag that result tape has not been formed */\n\n\t/*\n\t * Initialize parallel-related state based on coordination information\n\t * from caller\n\t */\n\tif (!coordinate)\n\t{\n\t\t/* Serial sort */\n\t\tstate->shared = NULL;\n\t\tstate->worker = -1;\n\t\tstate->nParticipants = -1;\n\t}\n\telse if (coordinate->isWorker)\n\t{\n\t\t/* Parallel worker produces exactly one final run from all input */\n\t\tstate->shared = coordinate->sharedsort;\n\t\tstate->worker = worker_get_identifier(state);\n\t\tstate->nParticipants = -1;\n\t}\n\telse\n\t{\n\t\t/* Parallel leader state only used for final merge */\n\t\tstate->shared = coordinate->sharedsort;\n\t\tstate->worker = -1;\n\t\tstate->nParticipants = coordinate->nParticipants;\n\t\tAssert(state->nParticipants >= 1);\n\t}\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn state;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define DATUM_SORT\t\t2\n\nstatic Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nTuplesortstate *\ntuplesort_begin_datum(Oid datumType, Oid sortOperator, Oid sortCollation,\n\t\t\t\t\t  bool nullsFirstFlag, int workMem,\n\t\t\t\t\t  SortCoordinate coordinate, bool randomAccess)\n{\n\tTuplesortstate *state = tuplesort_begin_common(workMem, coordinate,\n\t\t\t\t\t\t\t\t\t\t\t\t   randomAccess);\n\tMemoryContext oldcontext;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\n\toldcontext = MemoryContextSwitchTo(state->sortcontext);\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\telog(LOG,\n\t\t\t \"begin datum sort: workMem = %d, randomAccess = %c\",\n\t\t\t workMem, randomAccess ? 't' : 'f');\n#endif\n\n\tstate->nKeys = 1;\t\t\t/* always a one-column sort */\n\n\tTRACE_POSTGRESQL_SORT_START(DATUM_SORT,\n\t\t\t\t\t\t\t\tfalse,\t/* no unique check */\n\t\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\t\tworkMem,\n\t\t\t\t\t\t\t\trandomAccess,\n\t\t\t\t\t\t\t\tPARALLEL_SORT(state));\n\n\tstate->comparetup = comparetup_datum;\n\tstate->copytup = copytup_datum;\n\tstate->writetup = writetup_datum;\n\tstate->readtup = readtup_datum;\n\tstate->abbrevNext = 10;\n\n\tstate->datumType = datumType;\n\n\t/* lookup necessary attributes of the datum type */\n\tget_typlenbyval(datumType, &typlen, &typbyval);\n\tstate->datumTypeLen = typlen;\n\tstate->tuples = !typbyval;\n\n\t/* Prepare SortSupport data */\n\tstate->sortKeys = (SortSupport) palloc0(sizeof(SortSupportData));\n\n\tstate->sortKeys->ssup_cxt = CurrentMemoryContext;\n\tstate->sortKeys->ssup_collation = sortCollation;\n\tstate->sortKeys->ssup_nulls_first = nullsFirstFlag;\n\n\t/*\n\t * Abbreviation is possible here only for by-reference types.  In theory,\n\t * a pass-by-value datatype could have an abbreviated form that is cheaper\n\t * to compare.  In a tuple sort, we could support that, because we can\n\t * always extract the original datum from the tuple is needed.  Here, we\n\t * can't, because a datum sort only stores a single copy of the datum; the\n\t * \"tuple\" field of each sortTuple is NULL.\n\t */\n\tstate->sortKeys->abbreviate = !typbyval;\n\n\tPrepareSortSupportFromOrderingOp(sortOperator, state->sortKeys);\n\n\t/*\n\t * The \"onlyKey\" optimization cannot be used with abbreviated keys, since\n\t * tie-breaker comparisons may be required.  Typically, the optimization\n\t * is only of value to pass-by-value types anyway, whereas abbreviated\n\t * keys are typically only of value to pass-by-reference types.\n\t */\n\tif (!state->sortKeys->abbrev_converter)\n\t\tstate->onlyKey = state->sortKeys;\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn state;\n}"
  },
  {
    "function_name": "tuplesort_begin_index_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "1052-1096",
    "snippet": "Tuplesortstate *\ntuplesort_begin_index_hash(Relation heapRel,\n\t\t\t\t\t\t   Relation indexRel,\n\t\t\t\t\t\t   uint32 high_mask,\n\t\t\t\t\t\t   uint32 low_mask,\n\t\t\t\t\t\t   uint32 max_buckets,\n\t\t\t\t\t\t   int workMem,\n\t\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t\t   bool randomAccess)\n{\n\tTuplesortstate *state = tuplesort_begin_common(workMem, coordinate,\n\t\t\t\t\t\t\t\t\t\t\t\t   randomAccess);\n\tMemoryContext oldcontext;\n\n\toldcontext = MemoryContextSwitchTo(state->sortcontext);\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\telog(LOG,\n\t\t\t \"begin index sort: high_mask = 0x%x, low_mask = 0x%x, \"\n\t\t\t \"max_buckets = 0x%x, workMem = %d, randomAccess = %c\",\n\t\t\t high_mask,\n\t\t\t low_mask,\n\t\t\t max_buckets,\n\t\t\t workMem, randomAccess ? 't' : 'f');\n#endif\n\n\tstate->nKeys = 1;\t\t\t/* Only one sort column, the hash code */\n\n\tstate->comparetup = comparetup_index_hash;\n\tstate->copytup = copytup_index;\n\tstate->writetup = writetup_index;\n\tstate->readtup = readtup_index;\n\n\tstate->heapRel = heapRel;\n\tstate->indexRel = indexRel;\n\n\tstate->high_mask = high_mask;\n\tstate->low_mask = low_mask;\n\tstate->max_buckets = max_buckets;\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn state;\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);",
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "LOG",
            "\"begin index sort: high_mask = 0x%x, low_mask = 0x%x, \"\n\t\t\t \"max_buckets = 0x%x, workMem = %d, randomAccess = %c\"",
            "high_mask",
            "low_mask",
            "max_buckets",
            "workMem",
            "randomAccess ? 't' : 'f'"
          ],
          "line": 1070
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "state->sortcontext"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tuplesort_begin_common",
          "args": [
            "workMem",
            "coordinate",
            "randomAccess"
          ],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "tuplesort_begin_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "680-803",
          "snippet": "static Tuplesortstate *\ntuplesort_begin_common(int workMem, SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess)\n{\n\tTuplesortstate *state;\n\tMemoryContext sortcontext;\n\tMemoryContext tuplecontext;\n\tMemoryContext oldcontext;\n\n\t/* See leader_takeover_tapes() remarks on randomAccess support */\n\tif (coordinate && randomAccess)\n\t\telog(ERROR, \"random access disallowed under parallel sort\");\n\n\t/*\n\t * Create a working memory context for this sort operation. All data\n\t * needed by the sort will live inside this context.\n\t */\n\tsortcontext = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\"TupleSort main\",\n\t\t\t\t\t\t\t\t\t\tALLOCSET_DEFAULT_SIZES);\n\n\t/*\n\t * Caller tuple (e.g. IndexTuple) memory context.\n\t *\n\t * A dedicated child context used exclusively for caller passed tuples\n\t * eases memory management.  Resetting at key points reduces\n\t * fragmentation. Note that the memtuples array of SortTuples is allocated\n\t * in the parent context, not this context, because there is no need to\n\t * free memtuples early.\n\t */\n\ttuplecontext = AllocSetContextCreate(sortcontext,\n\t\t\t\t\t\t\t\t\t\t \"Caller tuples\",\n\t\t\t\t\t\t\t\t\t\t ALLOCSET_DEFAULT_SIZES);\n\n\t/*\n\t * Make the Tuplesortstate within the per-sort context.  This way, we\n\t * don't need a separate pfree() operation for it at shutdown.\n\t */\n\toldcontext = MemoryContextSwitchTo(sortcontext);\n\n\tstate = (Tuplesortstate *) palloc0(sizeof(Tuplesortstate));\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\tpg_rusage_init(&state->ru_start);\n#endif\n\n\tstate->status = TSS_INITIAL;\n\tstate->randomAccess = randomAccess;\n\tstate->bounded = false;\n\tstate->tuples = true;\n\tstate->boundUsed = false;\n\n\t/*\n\t * workMem is forced to be at least 64KB, the current minimum valid value\n\t * for the work_mem GUC.  This is a defense against parallel sort callers\n\t * that divide out memory among many workers in a way that leaves each\n\t * with very little memory.\n\t */\n\tstate->allowedMem = Max(workMem, 64) * (int64) 1024;\n\tstate->availMem = state->allowedMem;\n\tstate->sortcontext = sortcontext;\n\tstate->tuplecontext = tuplecontext;\n\tstate->tapeset = NULL;\n\n\tstate->memtupcount = 0;\n\n\t/*\n\t * Initial size of array must be more than ALLOCSET_SEPARATE_THRESHOLD;\n\t * see comments in grow_memtuples().\n\t */\n\tstate->memtupsize = Max(1024,\n\t\t\t\t\t\t\tALLOCSET_SEPARATE_THRESHOLD / sizeof(SortTuple) + 1);\n\n\tstate->growmemtuples = true;\n\tstate->slabAllocatorUsed = false;\n\tstate->memtuples = (SortTuple *) palloc(state->memtupsize * sizeof(SortTuple));\n\n\tUSEMEM(state, GetMemoryChunkSpace(state->memtuples));\n\n\t/* workMem must be large enough for the minimal memtuples array */\n\tif (LACKMEM(state))\n\t\telog(ERROR, \"insufficient memory allowed for sort\");\n\n\tstate->currentRun = 0;\n\n\t/*\n\t * maxTapes, tapeRange, and Algorithm D variables will be initialized by\n\t * inittapes(), if needed\n\t */\n\n\tstate->result_tape = -1;\t/* flag that result tape has not been formed */\n\n\t/*\n\t * Initialize parallel-related state based on coordination information\n\t * from caller\n\t */\n\tif (!coordinate)\n\t{\n\t\t/* Serial sort */\n\t\tstate->shared = NULL;\n\t\tstate->worker = -1;\n\t\tstate->nParticipants = -1;\n\t}\n\telse if (coordinate->isWorker)\n\t{\n\t\t/* Parallel worker produces exactly one final run from all input */\n\t\tstate->shared = coordinate->sharedsort;\n\t\tstate->worker = worker_get_identifier(state);\n\t\tstate->nParticipants = -1;\n\t}\n\telse\n\t{\n\t\t/* Parallel leader state only used for final merge */\n\t\tstate->shared = coordinate->sharedsort;\n\t\tstate->worker = -1;\n\t\tstate->nParticipants = coordinate->nParticipants;\n\t\tAssert(state->nParticipants >= 1);\n\t}\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn state;\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);",
            "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void inittapestate(Tuplesortstate *state, int maxTapes);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void inittapestate(Tuplesortstate *state, int maxTapes);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic Tuplesortstate *\ntuplesort_begin_common(int workMem, SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess)\n{\n\tTuplesortstate *state;\n\tMemoryContext sortcontext;\n\tMemoryContext tuplecontext;\n\tMemoryContext oldcontext;\n\n\t/* See leader_takeover_tapes() remarks on randomAccess support */\n\tif (coordinate && randomAccess)\n\t\telog(ERROR, \"random access disallowed under parallel sort\");\n\n\t/*\n\t * Create a working memory context for this sort operation. All data\n\t * needed by the sort will live inside this context.\n\t */\n\tsortcontext = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\"TupleSort main\",\n\t\t\t\t\t\t\t\t\t\tALLOCSET_DEFAULT_SIZES);\n\n\t/*\n\t * Caller tuple (e.g. IndexTuple) memory context.\n\t *\n\t * A dedicated child context used exclusively for caller passed tuples\n\t * eases memory management.  Resetting at key points reduces\n\t * fragmentation. Note that the memtuples array of SortTuples is allocated\n\t * in the parent context, not this context, because there is no need to\n\t * free memtuples early.\n\t */\n\ttuplecontext = AllocSetContextCreate(sortcontext,\n\t\t\t\t\t\t\t\t\t\t \"Caller tuples\",\n\t\t\t\t\t\t\t\t\t\t ALLOCSET_DEFAULT_SIZES);\n\n\t/*\n\t * Make the Tuplesortstate within the per-sort context.  This way, we\n\t * don't need a separate pfree() operation for it at shutdown.\n\t */\n\toldcontext = MemoryContextSwitchTo(sortcontext);\n\n\tstate = (Tuplesortstate *) palloc0(sizeof(Tuplesortstate));\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\tpg_rusage_init(&state->ru_start);\n#endif\n\n\tstate->status = TSS_INITIAL;\n\tstate->randomAccess = randomAccess;\n\tstate->bounded = false;\n\tstate->tuples = true;\n\tstate->boundUsed = false;\n\n\t/*\n\t * workMem is forced to be at least 64KB, the current minimum valid value\n\t * for the work_mem GUC.  This is a defense against parallel sort callers\n\t * that divide out memory among many workers in a way that leaves each\n\t * with very little memory.\n\t */\n\tstate->allowedMem = Max(workMem, 64) * (int64) 1024;\n\tstate->availMem = state->allowedMem;\n\tstate->sortcontext = sortcontext;\n\tstate->tuplecontext = tuplecontext;\n\tstate->tapeset = NULL;\n\n\tstate->memtupcount = 0;\n\n\t/*\n\t * Initial size of array must be more than ALLOCSET_SEPARATE_THRESHOLD;\n\t * see comments in grow_memtuples().\n\t */\n\tstate->memtupsize = Max(1024,\n\t\t\t\t\t\t\tALLOCSET_SEPARATE_THRESHOLD / sizeof(SortTuple) + 1);\n\n\tstate->growmemtuples = true;\n\tstate->slabAllocatorUsed = false;\n\tstate->memtuples = (SortTuple *) palloc(state->memtupsize * sizeof(SortTuple));\n\n\tUSEMEM(state, GetMemoryChunkSpace(state->memtuples));\n\n\t/* workMem must be large enough for the minimal memtuples array */\n\tif (LACKMEM(state))\n\t\telog(ERROR, \"insufficient memory allowed for sort\");\n\n\tstate->currentRun = 0;\n\n\t/*\n\t * maxTapes, tapeRange, and Algorithm D variables will be initialized by\n\t * inittapes(), if needed\n\t */\n\n\tstate->result_tape = -1;\t/* flag that result tape has not been formed */\n\n\t/*\n\t * Initialize parallel-related state based on coordination information\n\t * from caller\n\t */\n\tif (!coordinate)\n\t{\n\t\t/* Serial sort */\n\t\tstate->shared = NULL;\n\t\tstate->worker = -1;\n\t\tstate->nParticipants = -1;\n\t}\n\telse if (coordinate->isWorker)\n\t{\n\t\t/* Parallel worker produces exactly one final run from all input */\n\t\tstate->shared = coordinate->sharedsort;\n\t\tstate->worker = worker_get_identifier(state);\n\t\tstate->nParticipants = -1;\n\t}\n\telse\n\t{\n\t\t/* Parallel leader state only used for final merge */\n\t\tstate->shared = coordinate->sharedsort;\n\t\tstate->worker = -1;\n\t\tstate->nParticipants = coordinate->nParticipants;\n\t\tAssert(state->nParticipants >= 1);\n\t}\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn state;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nTuplesortstate *\ntuplesort_begin_index_hash(Relation heapRel,\n\t\t\t\t\t\t   Relation indexRel,\n\t\t\t\t\t\t   uint32 high_mask,\n\t\t\t\t\t\t   uint32 low_mask,\n\t\t\t\t\t\t   uint32 max_buckets,\n\t\t\t\t\t\t   int workMem,\n\t\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t\t   bool randomAccess)\n{\n\tTuplesortstate *state = tuplesort_begin_common(workMem, coordinate,\n\t\t\t\t\t\t\t\t\t\t\t\t   randomAccess);\n\tMemoryContext oldcontext;\n\n\toldcontext = MemoryContextSwitchTo(state->sortcontext);\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\telog(LOG,\n\t\t\t \"begin index sort: high_mask = 0x%x, low_mask = 0x%x, \"\n\t\t\t \"max_buckets = 0x%x, workMem = %d, randomAccess = %c\",\n\t\t\t high_mask,\n\t\t\t low_mask,\n\t\t\t max_buckets,\n\t\t\t workMem, randomAccess ? 't' : 'f');\n#endif\n\n\tstate->nKeys = 1;\t\t\t/* Only one sort column, the hash code */\n\n\tstate->comparetup = comparetup_index_hash;\n\tstate->copytup = copytup_index;\n\tstate->writetup = writetup_index;\n\tstate->readtup = readtup_index;\n\n\tstate->heapRel = heapRel;\n\tstate->indexRel = indexRel;\n\n\tstate->high_mask = high_mask;\n\tstate->low_mask = low_mask;\n\tstate->max_buckets = max_buckets;\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn state;\n}"
  },
  {
    "function_name": "tuplesort_begin_index_btree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "974-1050",
    "snippet": "Tuplesortstate *\ntuplesort_begin_index_btree(Relation heapRel,\n\t\t\t\t\t\t\tRelation indexRel,\n\t\t\t\t\t\t\tbool enforceUnique,\n\t\t\t\t\t\t\tint workMem,\n\t\t\t\t\t\t\tSortCoordinate coordinate,\n\t\t\t\t\t\t\tbool randomAccess)\n{\n\tTuplesortstate *state = tuplesort_begin_common(workMem, coordinate,\n\t\t\t\t\t\t\t\t\t\t\t\t   randomAccess);\n\tScanKey\t\tindexScanKey;\n\tMemoryContext oldcontext;\n\tint\t\t\ti;\n\n\toldcontext = MemoryContextSwitchTo(state->sortcontext);\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\telog(LOG,\n\t\t\t \"begin index sort: unique = %c, workMem = %d, randomAccess = %c\",\n\t\t\t enforceUnique ? 't' : 'f',\n\t\t\t workMem, randomAccess ? 't' : 'f');\n#endif\n\n\tstate->nKeys = IndexRelationGetNumberOfKeyAttributes(indexRel);\n\n\tTRACE_POSTGRESQL_SORT_START(INDEX_SORT,\n\t\t\t\t\t\t\t\tenforceUnique,\n\t\t\t\t\t\t\t\tstate->nKeys,\n\t\t\t\t\t\t\t\tworkMem,\n\t\t\t\t\t\t\t\trandomAccess,\n\t\t\t\t\t\t\t\tPARALLEL_SORT(state));\n\n\tstate->comparetup = comparetup_index_btree;\n\tstate->copytup = copytup_index;\n\tstate->writetup = writetup_index;\n\tstate->readtup = readtup_index;\n\tstate->abbrevNext = 10;\n\n\tstate->heapRel = heapRel;\n\tstate->indexRel = indexRel;\n\tstate->enforceUnique = enforceUnique;\n\n\tindexScanKey = _bt_mkscankey_nodata(indexRel);\n\n\t/* Prepare SortSupport data for each column */\n\tstate->sortKeys = (SortSupport) palloc0(state->nKeys *\n\t\t\t\t\t\t\t\t\t\t\tsizeof(SortSupportData));\n\n\tfor (i = 0; i < state->nKeys; i++)\n\t{\n\t\tSortSupport sortKey = state->sortKeys + i;\n\t\tScanKey\t\tscanKey = indexScanKey + i;\n\t\tint16\t\tstrategy;\n\n\t\tsortKey->ssup_cxt = CurrentMemoryContext;\n\t\tsortKey->ssup_collation = scanKey->sk_collation;\n\t\tsortKey->ssup_nulls_first =\n\t\t\t(scanKey->sk_flags & SK_BT_NULLS_FIRST) != 0;\n\t\tsortKey->ssup_attno = scanKey->sk_attno;\n\t\t/* Convey if abbreviation optimization is applicable in principle */\n\t\tsortKey->abbreviate = (i == 0);\n\n\t\tAssertState(sortKey->ssup_attno != 0);\n\n\t\tstrategy = (scanKey->sk_flags & SK_BT_DESC) != 0 ?\n\t\t\tBTGreaterStrategyNumber : BTLessStrategyNumber;\n\n\t\tPrepareSortSupportFromIndexRel(indexRel, strategy, sortKey);\n\t}\n\n\t_bt_freeskey(indexScanKey);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn state;\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define INDEX_SORT\t\t1"
    ],
    "globals_used": [
      "static Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);",
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_bt_freeskey",
          "args": [
            "indexScanKey"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrepareSortSupportFromIndexRel",
          "args": [
            "indexRel",
            "strategy",
            "sortKey"
          ],
          "line": 1042
        },
        "resolved": true,
        "details": {
          "function_name": "PrepareSortSupportFromIndexRel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/sortsupport.c",
          "lines": "159-176",
          "snippet": "void\nPrepareSortSupportFromIndexRel(Relation indexRel, int16 strategy,\n\t\t\t\t\t\t\t   SortSupport ssup)\n{\n\tOid\t\t\topfamily = indexRel->rd_opfamily[ssup->ssup_attno - 1];\n\tOid\t\t\topcintype = indexRel->rd_opcintype[ssup->ssup_attno - 1];\n\n\tAssert(ssup->comparator == NULL);\n\n\tif (indexRel->rd_rel->relam != BTREE_AM_OID)\n\t\telog(ERROR, \"unexpected non-btree AM: %u\", indexRel->rd_rel->relam);\n\tif (strategy != BTGreaterStrategyNumber &&\n\t\tstrategy != BTLessStrategyNumber)\n\t\telog(ERROR, \"unexpected sort support strategy: %d\", strategy);\n\tssup->ssup_reverse = (strategy == BTGreaterStrategyNumber);\n\n\tFinishSortSupportFunction(opfamily, opcintype, ssup);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_am.h\"\n#include \"access/nbtree.h\"\n#include \"postgres.h\"\n\nvoid\nPrepareSortSupportFromIndexRel(Relation indexRel, int16 strategy,\n\t\t\t\t\t\t\t   SortSupport ssup)\n{\n\tOid\t\t\topfamily = indexRel->rd_opfamily[ssup->ssup_attno - 1];\n\tOid\t\t\topcintype = indexRel->rd_opcintype[ssup->ssup_attno - 1];\n\n\tAssert(ssup->comparator == NULL);\n\n\tif (indexRel->rd_rel->relam != BTREE_AM_OID)\n\t\telog(ERROR, \"unexpected non-btree AM: %u\", indexRel->rd_rel->relam);\n\tif (strategy != BTGreaterStrategyNumber &&\n\t\tstrategy != BTLessStrategyNumber)\n\t\telog(ERROR, \"unexpected sort support strategy: %d\", strategy);\n\tssup->ssup_reverse = (strategy == BTGreaterStrategyNumber);\n\n\tFinishSortSupportFunction(opfamily, opcintype, ssup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AssertState",
          "args": [
            "sortKey->ssup_attno != 0"
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "state->nKeys *\n\t\t\t\t\t\t\t\t\t\t\tsizeof(SortSupportData)"
          ],
          "line": 1020
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_bt_mkscankey_nodata",
          "args": [
            "indexRel"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRACE_POSTGRESQL_SORT_START",
          "args": [
            "INDEX_SORT",
            "enforceUnique",
            "state->nKeys",
            "workMem",
            "randomAccess",
            "PARALLEL_SORT(state)"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PARALLEL_SORT",
          "args": [
            "state"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IndexRelationGetNumberOfKeyAttributes",
          "args": [
            "indexRel"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "LOG",
            "\"begin index sort: unique = %c, workMem = %d, randomAccess = %c\"",
            "enforceUnique ? 't' : 'f'",
            "workMem",
            "randomAccess ? 't' : 'f'"
          ],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "state->sortcontext"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tuplesort_begin_common",
          "args": [
            "workMem",
            "coordinate",
            "randomAccess"
          ],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "tuplesort_begin_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "680-803",
          "snippet": "static Tuplesortstate *\ntuplesort_begin_common(int workMem, SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess)\n{\n\tTuplesortstate *state;\n\tMemoryContext sortcontext;\n\tMemoryContext tuplecontext;\n\tMemoryContext oldcontext;\n\n\t/* See leader_takeover_tapes() remarks on randomAccess support */\n\tif (coordinate && randomAccess)\n\t\telog(ERROR, \"random access disallowed under parallel sort\");\n\n\t/*\n\t * Create a working memory context for this sort operation. All data\n\t * needed by the sort will live inside this context.\n\t */\n\tsortcontext = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\"TupleSort main\",\n\t\t\t\t\t\t\t\t\t\tALLOCSET_DEFAULT_SIZES);\n\n\t/*\n\t * Caller tuple (e.g. IndexTuple) memory context.\n\t *\n\t * A dedicated child context used exclusively for caller passed tuples\n\t * eases memory management.  Resetting at key points reduces\n\t * fragmentation. Note that the memtuples array of SortTuples is allocated\n\t * in the parent context, not this context, because there is no need to\n\t * free memtuples early.\n\t */\n\ttuplecontext = AllocSetContextCreate(sortcontext,\n\t\t\t\t\t\t\t\t\t\t \"Caller tuples\",\n\t\t\t\t\t\t\t\t\t\t ALLOCSET_DEFAULT_SIZES);\n\n\t/*\n\t * Make the Tuplesortstate within the per-sort context.  This way, we\n\t * don't need a separate pfree() operation for it at shutdown.\n\t */\n\toldcontext = MemoryContextSwitchTo(sortcontext);\n\n\tstate = (Tuplesortstate *) palloc0(sizeof(Tuplesortstate));\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\tpg_rusage_init(&state->ru_start);\n#endif\n\n\tstate->status = TSS_INITIAL;\n\tstate->randomAccess = randomAccess;\n\tstate->bounded = false;\n\tstate->tuples = true;\n\tstate->boundUsed = false;\n\n\t/*\n\t * workMem is forced to be at least 64KB, the current minimum valid value\n\t * for the work_mem GUC.  This is a defense against parallel sort callers\n\t * that divide out memory among many workers in a way that leaves each\n\t * with very little memory.\n\t */\n\tstate->allowedMem = Max(workMem, 64) * (int64) 1024;\n\tstate->availMem = state->allowedMem;\n\tstate->sortcontext = sortcontext;\n\tstate->tuplecontext = tuplecontext;\n\tstate->tapeset = NULL;\n\n\tstate->memtupcount = 0;\n\n\t/*\n\t * Initial size of array must be more than ALLOCSET_SEPARATE_THRESHOLD;\n\t * see comments in grow_memtuples().\n\t */\n\tstate->memtupsize = Max(1024,\n\t\t\t\t\t\t\tALLOCSET_SEPARATE_THRESHOLD / sizeof(SortTuple) + 1);\n\n\tstate->growmemtuples = true;\n\tstate->slabAllocatorUsed = false;\n\tstate->memtuples = (SortTuple *) palloc(state->memtupsize * sizeof(SortTuple));\n\n\tUSEMEM(state, GetMemoryChunkSpace(state->memtuples));\n\n\t/* workMem must be large enough for the minimal memtuples array */\n\tif (LACKMEM(state))\n\t\telog(ERROR, \"insufficient memory allowed for sort\");\n\n\tstate->currentRun = 0;\n\n\t/*\n\t * maxTapes, tapeRange, and Algorithm D variables will be initialized by\n\t * inittapes(), if needed\n\t */\n\n\tstate->result_tape = -1;\t/* flag that result tape has not been formed */\n\n\t/*\n\t * Initialize parallel-related state based on coordination information\n\t * from caller\n\t */\n\tif (!coordinate)\n\t{\n\t\t/* Serial sort */\n\t\tstate->shared = NULL;\n\t\tstate->worker = -1;\n\t\tstate->nParticipants = -1;\n\t}\n\telse if (coordinate->isWorker)\n\t{\n\t\t/* Parallel worker produces exactly one final run from all input */\n\t\tstate->shared = coordinate->sharedsort;\n\t\tstate->worker = worker_get_identifier(state);\n\t\tstate->nParticipants = -1;\n\t}\n\telse\n\t{\n\t\t/* Parallel leader state only used for final merge */\n\t\tstate->shared = coordinate->sharedsort;\n\t\tstate->worker = -1;\n\t\tstate->nParticipants = coordinate->nParticipants;\n\t\tAssert(state->nParticipants >= 1);\n\t}\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn state;\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);",
            "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void inittapestate(Tuplesortstate *state, int maxTapes);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void inittapestate(Tuplesortstate *state, int maxTapes);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic Tuplesortstate *\ntuplesort_begin_common(int workMem, SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess)\n{\n\tTuplesortstate *state;\n\tMemoryContext sortcontext;\n\tMemoryContext tuplecontext;\n\tMemoryContext oldcontext;\n\n\t/* See leader_takeover_tapes() remarks on randomAccess support */\n\tif (coordinate && randomAccess)\n\t\telog(ERROR, \"random access disallowed under parallel sort\");\n\n\t/*\n\t * Create a working memory context for this sort operation. All data\n\t * needed by the sort will live inside this context.\n\t */\n\tsortcontext = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\"TupleSort main\",\n\t\t\t\t\t\t\t\t\t\tALLOCSET_DEFAULT_SIZES);\n\n\t/*\n\t * Caller tuple (e.g. IndexTuple) memory context.\n\t *\n\t * A dedicated child context used exclusively for caller passed tuples\n\t * eases memory management.  Resetting at key points reduces\n\t * fragmentation. Note that the memtuples array of SortTuples is allocated\n\t * in the parent context, not this context, because there is no need to\n\t * free memtuples early.\n\t */\n\ttuplecontext = AllocSetContextCreate(sortcontext,\n\t\t\t\t\t\t\t\t\t\t \"Caller tuples\",\n\t\t\t\t\t\t\t\t\t\t ALLOCSET_DEFAULT_SIZES);\n\n\t/*\n\t * Make the Tuplesortstate within the per-sort context.  This way, we\n\t * don't need a separate pfree() operation for it at shutdown.\n\t */\n\toldcontext = MemoryContextSwitchTo(sortcontext);\n\n\tstate = (Tuplesortstate *) palloc0(sizeof(Tuplesortstate));\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\tpg_rusage_init(&state->ru_start);\n#endif\n\n\tstate->status = TSS_INITIAL;\n\tstate->randomAccess = randomAccess;\n\tstate->bounded = false;\n\tstate->tuples = true;\n\tstate->boundUsed = false;\n\n\t/*\n\t * workMem is forced to be at least 64KB, the current minimum valid value\n\t * for the work_mem GUC.  This is a defense against parallel sort callers\n\t * that divide out memory among many workers in a way that leaves each\n\t * with very little memory.\n\t */\n\tstate->allowedMem = Max(workMem, 64) * (int64) 1024;\n\tstate->availMem = state->allowedMem;\n\tstate->sortcontext = sortcontext;\n\tstate->tuplecontext = tuplecontext;\n\tstate->tapeset = NULL;\n\n\tstate->memtupcount = 0;\n\n\t/*\n\t * Initial size of array must be more than ALLOCSET_SEPARATE_THRESHOLD;\n\t * see comments in grow_memtuples().\n\t */\n\tstate->memtupsize = Max(1024,\n\t\t\t\t\t\t\tALLOCSET_SEPARATE_THRESHOLD / sizeof(SortTuple) + 1);\n\n\tstate->growmemtuples = true;\n\tstate->slabAllocatorUsed = false;\n\tstate->memtuples = (SortTuple *) palloc(state->memtupsize * sizeof(SortTuple));\n\n\tUSEMEM(state, GetMemoryChunkSpace(state->memtuples));\n\n\t/* workMem must be large enough for the minimal memtuples array */\n\tif (LACKMEM(state))\n\t\telog(ERROR, \"insufficient memory allowed for sort\");\n\n\tstate->currentRun = 0;\n\n\t/*\n\t * maxTapes, tapeRange, and Algorithm D variables will be initialized by\n\t * inittapes(), if needed\n\t */\n\n\tstate->result_tape = -1;\t/* flag that result tape has not been formed */\n\n\t/*\n\t * Initialize parallel-related state based on coordination information\n\t * from caller\n\t */\n\tif (!coordinate)\n\t{\n\t\t/* Serial sort */\n\t\tstate->shared = NULL;\n\t\tstate->worker = -1;\n\t\tstate->nParticipants = -1;\n\t}\n\telse if (coordinate->isWorker)\n\t{\n\t\t/* Parallel worker produces exactly one final run from all input */\n\t\tstate->shared = coordinate->sharedsort;\n\t\tstate->worker = worker_get_identifier(state);\n\t\tstate->nParticipants = -1;\n\t}\n\telse\n\t{\n\t\t/* Parallel leader state only used for final merge */\n\t\tstate->shared = coordinate->sharedsort;\n\t\tstate->worker = -1;\n\t\tstate->nParticipants = coordinate->nParticipants;\n\t\tAssert(state->nParticipants >= 1);\n\t}\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn state;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define INDEX_SORT\t\t1\n\nstatic Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nTuplesortstate *\ntuplesort_begin_index_btree(Relation heapRel,\n\t\t\t\t\t\t\tRelation indexRel,\n\t\t\t\t\t\t\tbool enforceUnique,\n\t\t\t\t\t\t\tint workMem,\n\t\t\t\t\t\t\tSortCoordinate coordinate,\n\t\t\t\t\t\t\tbool randomAccess)\n{\n\tTuplesortstate *state = tuplesort_begin_common(workMem, coordinate,\n\t\t\t\t\t\t\t\t\t\t\t\t   randomAccess);\n\tScanKey\t\tindexScanKey;\n\tMemoryContext oldcontext;\n\tint\t\t\ti;\n\n\toldcontext = MemoryContextSwitchTo(state->sortcontext);\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\telog(LOG,\n\t\t\t \"begin index sort: unique = %c, workMem = %d, randomAccess = %c\",\n\t\t\t enforceUnique ? 't' : 'f',\n\t\t\t workMem, randomAccess ? 't' : 'f');\n#endif\n\n\tstate->nKeys = IndexRelationGetNumberOfKeyAttributes(indexRel);\n\n\tTRACE_POSTGRESQL_SORT_START(INDEX_SORT,\n\t\t\t\t\t\t\t\tenforceUnique,\n\t\t\t\t\t\t\t\tstate->nKeys,\n\t\t\t\t\t\t\t\tworkMem,\n\t\t\t\t\t\t\t\trandomAccess,\n\t\t\t\t\t\t\t\tPARALLEL_SORT(state));\n\n\tstate->comparetup = comparetup_index_btree;\n\tstate->copytup = copytup_index;\n\tstate->writetup = writetup_index;\n\tstate->readtup = readtup_index;\n\tstate->abbrevNext = 10;\n\n\tstate->heapRel = heapRel;\n\tstate->indexRel = indexRel;\n\tstate->enforceUnique = enforceUnique;\n\n\tindexScanKey = _bt_mkscankey_nodata(indexRel);\n\n\t/* Prepare SortSupport data for each column */\n\tstate->sortKeys = (SortSupport) palloc0(state->nKeys *\n\t\t\t\t\t\t\t\t\t\t\tsizeof(SortSupportData));\n\n\tfor (i = 0; i < state->nKeys; i++)\n\t{\n\t\tSortSupport sortKey = state->sortKeys + i;\n\t\tScanKey\t\tscanKey = indexScanKey + i;\n\t\tint16\t\tstrategy;\n\n\t\tsortKey->ssup_cxt = CurrentMemoryContext;\n\t\tsortKey->ssup_collation = scanKey->sk_collation;\n\t\tsortKey->ssup_nulls_first =\n\t\t\t(scanKey->sk_flags & SK_BT_NULLS_FIRST) != 0;\n\t\tsortKey->ssup_attno = scanKey->sk_attno;\n\t\t/* Convey if abbreviation optimization is applicable in principle */\n\t\tsortKey->abbreviate = (i == 0);\n\n\t\tAssertState(sortKey->ssup_attno != 0);\n\n\t\tstrategy = (scanKey->sk_flags & SK_BT_DESC) != 0 ?\n\t\t\tBTGreaterStrategyNumber : BTLessStrategyNumber;\n\n\t\tPrepareSortSupportFromIndexRel(indexRel, strategy, sortKey);\n\t}\n\n\t_bt_freeskey(indexScanKey);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn state;\n}"
  },
  {
    "function_name": "tuplesort_begin_cluster",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "879-972",
    "snippet": "Tuplesortstate *\ntuplesort_begin_cluster(TupleDesc tupDesc,\n\t\t\t\t\t\tRelation indexRel,\n\t\t\t\t\t\tint workMem,\n\t\t\t\t\t\tSortCoordinate coordinate, bool randomAccess)\n{\n\tTuplesortstate *state = tuplesort_begin_common(workMem, coordinate,\n\t\t\t\t\t\t\t\t\t\t\t\t   randomAccess);\n\tScanKey\t\tindexScanKey;\n\tMemoryContext oldcontext;\n\tint\t\t\ti;\n\n\tAssert(indexRel->rd_rel->relam == BTREE_AM_OID);\n\n\toldcontext = MemoryContextSwitchTo(state->sortcontext);\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\telog(LOG,\n\t\t\t \"begin tuple sort: nkeys = %d, workMem = %d, randomAccess = %c\",\n\t\t\t RelationGetNumberOfAttributes(indexRel),\n\t\t\t workMem, randomAccess ? 't' : 'f');\n#endif\n\n\tstate->nKeys = IndexRelationGetNumberOfKeyAttributes(indexRel);\n\n\tTRACE_POSTGRESQL_SORT_START(CLUSTER_SORT,\n\t\t\t\t\t\t\t\tfalse,\t/* no unique check */\n\t\t\t\t\t\t\t\tstate->nKeys,\n\t\t\t\t\t\t\t\tworkMem,\n\t\t\t\t\t\t\t\trandomAccess,\n\t\t\t\t\t\t\t\tPARALLEL_SORT(state));\n\n\tstate->comparetup = comparetup_cluster;\n\tstate->copytup = copytup_cluster;\n\tstate->writetup = writetup_cluster;\n\tstate->readtup = readtup_cluster;\n\tstate->abbrevNext = 10;\n\n\tstate->indexInfo = BuildIndexInfo(indexRel);\n\n\tstate->tupDesc = tupDesc;\t/* assume we need not copy tupDesc */\n\n\tindexScanKey = _bt_mkscankey_nodata(indexRel);\n\n\tif (state->indexInfo->ii_Expressions != NULL)\n\t{\n\t\tTupleTableSlot *slot;\n\t\tExprContext *econtext;\n\n\t\t/*\n\t\t * We will need to use FormIndexDatum to evaluate the index\n\t\t * expressions.  To do that, we need an EState, as well as a\n\t\t * TupleTableSlot to put the table tuples into.  The econtext's\n\t\t * scantuple has to point to that slot, too.\n\t\t */\n\t\tstate->estate = CreateExecutorState();\n\t\tslot = MakeSingleTupleTableSlot(tupDesc);\n\t\tecontext = GetPerTupleExprContext(state->estate);\n\t\tecontext->ecxt_scantuple = slot;\n\t}\n\n\t/* Prepare SortSupport data for each column */\n\tstate->sortKeys = (SortSupport) palloc0(state->nKeys *\n\t\t\t\t\t\t\t\t\t\t\tsizeof(SortSupportData));\n\n\tfor (i = 0; i < state->nKeys; i++)\n\t{\n\t\tSortSupport sortKey = state->sortKeys + i;\n\t\tScanKey\t\tscanKey = indexScanKey + i;\n\t\tint16\t\tstrategy;\n\n\t\tsortKey->ssup_cxt = CurrentMemoryContext;\n\t\tsortKey->ssup_collation = scanKey->sk_collation;\n\t\tsortKey->ssup_nulls_first =\n\t\t\t(scanKey->sk_flags & SK_BT_NULLS_FIRST) != 0;\n\t\tsortKey->ssup_attno = scanKey->sk_attno;\n\t\t/* Convey if abbreviation optimization is applicable in principle */\n\t\tsortKey->abbreviate = (i == 0);\n\n\t\tAssertState(sortKey->ssup_attno != 0);\n\n\t\tstrategy = (scanKey->sk_flags & SK_BT_DESC) != 0 ?\n\t\t\tBTGreaterStrategyNumber : BTLessStrategyNumber;\n\n\t\tPrepareSortSupportFromIndexRel(indexRel, strategy, sortKey);\n\t}\n\n\t_bt_freeskey(indexScanKey);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn state;\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define CLUSTER_SORT\t3"
    ],
    "globals_used": [
      "static Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);",
      "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_bt_freeskey",
          "args": [
            "indexScanKey"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrepareSortSupportFromIndexRel",
          "args": [
            "indexRel",
            "strategy",
            "sortKey"
          ],
          "line": 964
        },
        "resolved": true,
        "details": {
          "function_name": "PrepareSortSupportFromIndexRel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/sortsupport.c",
          "lines": "159-176",
          "snippet": "void\nPrepareSortSupportFromIndexRel(Relation indexRel, int16 strategy,\n\t\t\t\t\t\t\t   SortSupport ssup)\n{\n\tOid\t\t\topfamily = indexRel->rd_opfamily[ssup->ssup_attno - 1];\n\tOid\t\t\topcintype = indexRel->rd_opcintype[ssup->ssup_attno - 1];\n\n\tAssert(ssup->comparator == NULL);\n\n\tif (indexRel->rd_rel->relam != BTREE_AM_OID)\n\t\telog(ERROR, \"unexpected non-btree AM: %u\", indexRel->rd_rel->relam);\n\tif (strategy != BTGreaterStrategyNumber &&\n\t\tstrategy != BTLessStrategyNumber)\n\t\telog(ERROR, \"unexpected sort support strategy: %d\", strategy);\n\tssup->ssup_reverse = (strategy == BTGreaterStrategyNumber);\n\n\tFinishSortSupportFunction(opfamily, opcintype, ssup);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_am.h\"\n#include \"access/nbtree.h\"\n#include \"postgres.h\"\n\nvoid\nPrepareSortSupportFromIndexRel(Relation indexRel, int16 strategy,\n\t\t\t\t\t\t\t   SortSupport ssup)\n{\n\tOid\t\t\topfamily = indexRel->rd_opfamily[ssup->ssup_attno - 1];\n\tOid\t\t\topcintype = indexRel->rd_opcintype[ssup->ssup_attno - 1];\n\n\tAssert(ssup->comparator == NULL);\n\n\tif (indexRel->rd_rel->relam != BTREE_AM_OID)\n\t\telog(ERROR, \"unexpected non-btree AM: %u\", indexRel->rd_rel->relam);\n\tif (strategy != BTGreaterStrategyNumber &&\n\t\tstrategy != BTLessStrategyNumber)\n\t\telog(ERROR, \"unexpected sort support strategy: %d\", strategy);\n\tssup->ssup_reverse = (strategy == BTGreaterStrategyNumber);\n\n\tFinishSortSupportFunction(opfamily, opcintype, ssup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AssertState",
          "args": [
            "sortKey->ssup_attno != 0"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "state->nKeys *\n\t\t\t\t\t\t\t\t\t\t\tsizeof(SortSupportData)"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetPerTupleExprContext",
          "args": [
            "state->estate"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MakeSingleTupleTableSlot",
          "args": [
            "tupDesc"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CreateExecutorState",
          "args": [],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_bt_mkscankey_nodata",
          "args": [
            "indexRel"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BuildIndexInfo",
          "args": [
            "indexRel"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRACE_POSTGRESQL_SORT_START",
          "args": [
            "CLUSTER_SORT",
            "false",
            "/* no unique check */state->nKeys",
            "workMem",
            "randomAccess",
            "PARALLEL_SORT(state)"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PARALLEL_SORT",
          "args": [
            "state"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IndexRelationGetNumberOfKeyAttributes",
          "args": [
            "indexRel"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "LOG",
            "\"begin tuple sort: nkeys = %d, workMem = %d, randomAccess = %c\"",
            "RelationGetNumberOfAttributes(indexRel)",
            "workMem",
            "randomAccess ? 't' : 'f'"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationGetNumberOfAttributes",
          "args": [
            "indexRel"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "state->sortcontext"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "indexRel->rd_rel->relam == BTREE_AM_OID"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tuplesort_begin_common",
          "args": [
            "workMem",
            "coordinate",
            "randomAccess"
          ],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "tuplesort_begin_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "680-803",
          "snippet": "static Tuplesortstate *\ntuplesort_begin_common(int workMem, SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess)\n{\n\tTuplesortstate *state;\n\tMemoryContext sortcontext;\n\tMemoryContext tuplecontext;\n\tMemoryContext oldcontext;\n\n\t/* See leader_takeover_tapes() remarks on randomAccess support */\n\tif (coordinate && randomAccess)\n\t\telog(ERROR, \"random access disallowed under parallel sort\");\n\n\t/*\n\t * Create a working memory context for this sort operation. All data\n\t * needed by the sort will live inside this context.\n\t */\n\tsortcontext = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\"TupleSort main\",\n\t\t\t\t\t\t\t\t\t\tALLOCSET_DEFAULT_SIZES);\n\n\t/*\n\t * Caller tuple (e.g. IndexTuple) memory context.\n\t *\n\t * A dedicated child context used exclusively for caller passed tuples\n\t * eases memory management.  Resetting at key points reduces\n\t * fragmentation. Note that the memtuples array of SortTuples is allocated\n\t * in the parent context, not this context, because there is no need to\n\t * free memtuples early.\n\t */\n\ttuplecontext = AllocSetContextCreate(sortcontext,\n\t\t\t\t\t\t\t\t\t\t \"Caller tuples\",\n\t\t\t\t\t\t\t\t\t\t ALLOCSET_DEFAULT_SIZES);\n\n\t/*\n\t * Make the Tuplesortstate within the per-sort context.  This way, we\n\t * don't need a separate pfree() operation for it at shutdown.\n\t */\n\toldcontext = MemoryContextSwitchTo(sortcontext);\n\n\tstate = (Tuplesortstate *) palloc0(sizeof(Tuplesortstate));\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\tpg_rusage_init(&state->ru_start);\n#endif\n\n\tstate->status = TSS_INITIAL;\n\tstate->randomAccess = randomAccess;\n\tstate->bounded = false;\n\tstate->tuples = true;\n\tstate->boundUsed = false;\n\n\t/*\n\t * workMem is forced to be at least 64KB, the current minimum valid value\n\t * for the work_mem GUC.  This is a defense against parallel sort callers\n\t * that divide out memory among many workers in a way that leaves each\n\t * with very little memory.\n\t */\n\tstate->allowedMem = Max(workMem, 64) * (int64) 1024;\n\tstate->availMem = state->allowedMem;\n\tstate->sortcontext = sortcontext;\n\tstate->tuplecontext = tuplecontext;\n\tstate->tapeset = NULL;\n\n\tstate->memtupcount = 0;\n\n\t/*\n\t * Initial size of array must be more than ALLOCSET_SEPARATE_THRESHOLD;\n\t * see comments in grow_memtuples().\n\t */\n\tstate->memtupsize = Max(1024,\n\t\t\t\t\t\t\tALLOCSET_SEPARATE_THRESHOLD / sizeof(SortTuple) + 1);\n\n\tstate->growmemtuples = true;\n\tstate->slabAllocatorUsed = false;\n\tstate->memtuples = (SortTuple *) palloc(state->memtupsize * sizeof(SortTuple));\n\n\tUSEMEM(state, GetMemoryChunkSpace(state->memtuples));\n\n\t/* workMem must be large enough for the minimal memtuples array */\n\tif (LACKMEM(state))\n\t\telog(ERROR, \"insufficient memory allowed for sort\");\n\n\tstate->currentRun = 0;\n\n\t/*\n\t * maxTapes, tapeRange, and Algorithm D variables will be initialized by\n\t * inittapes(), if needed\n\t */\n\n\tstate->result_tape = -1;\t/* flag that result tape has not been formed */\n\n\t/*\n\t * Initialize parallel-related state based on coordination information\n\t * from caller\n\t */\n\tif (!coordinate)\n\t{\n\t\t/* Serial sort */\n\t\tstate->shared = NULL;\n\t\tstate->worker = -1;\n\t\tstate->nParticipants = -1;\n\t}\n\telse if (coordinate->isWorker)\n\t{\n\t\t/* Parallel worker produces exactly one final run from all input */\n\t\tstate->shared = coordinate->sharedsort;\n\t\tstate->worker = worker_get_identifier(state);\n\t\tstate->nParticipants = -1;\n\t}\n\telse\n\t{\n\t\t/* Parallel leader state only used for final merge */\n\t\tstate->shared = coordinate->sharedsort;\n\t\tstate->worker = -1;\n\t\tstate->nParticipants = coordinate->nParticipants;\n\t\tAssert(state->nParticipants >= 1);\n\t}\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn state;\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);",
            "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void inittapestate(Tuplesortstate *state, int maxTapes);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void inittapestate(Tuplesortstate *state, int maxTapes);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic Tuplesortstate *\ntuplesort_begin_common(int workMem, SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess)\n{\n\tTuplesortstate *state;\n\tMemoryContext sortcontext;\n\tMemoryContext tuplecontext;\n\tMemoryContext oldcontext;\n\n\t/* See leader_takeover_tapes() remarks on randomAccess support */\n\tif (coordinate && randomAccess)\n\t\telog(ERROR, \"random access disallowed under parallel sort\");\n\n\t/*\n\t * Create a working memory context for this sort operation. All data\n\t * needed by the sort will live inside this context.\n\t */\n\tsortcontext = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\"TupleSort main\",\n\t\t\t\t\t\t\t\t\t\tALLOCSET_DEFAULT_SIZES);\n\n\t/*\n\t * Caller tuple (e.g. IndexTuple) memory context.\n\t *\n\t * A dedicated child context used exclusively for caller passed tuples\n\t * eases memory management.  Resetting at key points reduces\n\t * fragmentation. Note that the memtuples array of SortTuples is allocated\n\t * in the parent context, not this context, because there is no need to\n\t * free memtuples early.\n\t */\n\ttuplecontext = AllocSetContextCreate(sortcontext,\n\t\t\t\t\t\t\t\t\t\t \"Caller tuples\",\n\t\t\t\t\t\t\t\t\t\t ALLOCSET_DEFAULT_SIZES);\n\n\t/*\n\t * Make the Tuplesortstate within the per-sort context.  This way, we\n\t * don't need a separate pfree() operation for it at shutdown.\n\t */\n\toldcontext = MemoryContextSwitchTo(sortcontext);\n\n\tstate = (Tuplesortstate *) palloc0(sizeof(Tuplesortstate));\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\tpg_rusage_init(&state->ru_start);\n#endif\n\n\tstate->status = TSS_INITIAL;\n\tstate->randomAccess = randomAccess;\n\tstate->bounded = false;\n\tstate->tuples = true;\n\tstate->boundUsed = false;\n\n\t/*\n\t * workMem is forced to be at least 64KB, the current minimum valid value\n\t * for the work_mem GUC.  This is a defense against parallel sort callers\n\t * that divide out memory among many workers in a way that leaves each\n\t * with very little memory.\n\t */\n\tstate->allowedMem = Max(workMem, 64) * (int64) 1024;\n\tstate->availMem = state->allowedMem;\n\tstate->sortcontext = sortcontext;\n\tstate->tuplecontext = tuplecontext;\n\tstate->tapeset = NULL;\n\n\tstate->memtupcount = 0;\n\n\t/*\n\t * Initial size of array must be more than ALLOCSET_SEPARATE_THRESHOLD;\n\t * see comments in grow_memtuples().\n\t */\n\tstate->memtupsize = Max(1024,\n\t\t\t\t\t\t\tALLOCSET_SEPARATE_THRESHOLD / sizeof(SortTuple) + 1);\n\n\tstate->growmemtuples = true;\n\tstate->slabAllocatorUsed = false;\n\tstate->memtuples = (SortTuple *) palloc(state->memtupsize * sizeof(SortTuple));\n\n\tUSEMEM(state, GetMemoryChunkSpace(state->memtuples));\n\n\t/* workMem must be large enough for the minimal memtuples array */\n\tif (LACKMEM(state))\n\t\telog(ERROR, \"insufficient memory allowed for sort\");\n\n\tstate->currentRun = 0;\n\n\t/*\n\t * maxTapes, tapeRange, and Algorithm D variables will be initialized by\n\t * inittapes(), if needed\n\t */\n\n\tstate->result_tape = -1;\t/* flag that result tape has not been formed */\n\n\t/*\n\t * Initialize parallel-related state based on coordination information\n\t * from caller\n\t */\n\tif (!coordinate)\n\t{\n\t\t/* Serial sort */\n\t\tstate->shared = NULL;\n\t\tstate->worker = -1;\n\t\tstate->nParticipants = -1;\n\t}\n\telse if (coordinate->isWorker)\n\t{\n\t\t/* Parallel worker produces exactly one final run from all input */\n\t\tstate->shared = coordinate->sharedsort;\n\t\tstate->worker = worker_get_identifier(state);\n\t\tstate->nParticipants = -1;\n\t}\n\telse\n\t{\n\t\t/* Parallel leader state only used for final merge */\n\t\tstate->shared = coordinate->sharedsort;\n\t\tstate->worker = -1;\n\t\tstate->nParticipants = coordinate->nParticipants;\n\t\tAssert(state->nParticipants >= 1);\n\t}\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn state;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define CLUSTER_SORT\t3\n\nstatic Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nTuplesortstate *\ntuplesort_begin_cluster(TupleDesc tupDesc,\n\t\t\t\t\t\tRelation indexRel,\n\t\t\t\t\t\tint workMem,\n\t\t\t\t\t\tSortCoordinate coordinate, bool randomAccess)\n{\n\tTuplesortstate *state = tuplesort_begin_common(workMem, coordinate,\n\t\t\t\t\t\t\t\t\t\t\t\t   randomAccess);\n\tScanKey\t\tindexScanKey;\n\tMemoryContext oldcontext;\n\tint\t\t\ti;\n\n\tAssert(indexRel->rd_rel->relam == BTREE_AM_OID);\n\n\toldcontext = MemoryContextSwitchTo(state->sortcontext);\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\telog(LOG,\n\t\t\t \"begin tuple sort: nkeys = %d, workMem = %d, randomAccess = %c\",\n\t\t\t RelationGetNumberOfAttributes(indexRel),\n\t\t\t workMem, randomAccess ? 't' : 'f');\n#endif\n\n\tstate->nKeys = IndexRelationGetNumberOfKeyAttributes(indexRel);\n\n\tTRACE_POSTGRESQL_SORT_START(CLUSTER_SORT,\n\t\t\t\t\t\t\t\tfalse,\t/* no unique check */\n\t\t\t\t\t\t\t\tstate->nKeys,\n\t\t\t\t\t\t\t\tworkMem,\n\t\t\t\t\t\t\t\trandomAccess,\n\t\t\t\t\t\t\t\tPARALLEL_SORT(state));\n\n\tstate->comparetup = comparetup_cluster;\n\tstate->copytup = copytup_cluster;\n\tstate->writetup = writetup_cluster;\n\tstate->readtup = readtup_cluster;\n\tstate->abbrevNext = 10;\n\n\tstate->indexInfo = BuildIndexInfo(indexRel);\n\n\tstate->tupDesc = tupDesc;\t/* assume we need not copy tupDesc */\n\n\tindexScanKey = _bt_mkscankey_nodata(indexRel);\n\n\tif (state->indexInfo->ii_Expressions != NULL)\n\t{\n\t\tTupleTableSlot *slot;\n\t\tExprContext *econtext;\n\n\t\t/*\n\t\t * We will need to use FormIndexDatum to evaluate the index\n\t\t * expressions.  To do that, we need an EState, as well as a\n\t\t * TupleTableSlot to put the table tuples into.  The econtext's\n\t\t * scantuple has to point to that slot, too.\n\t\t */\n\t\tstate->estate = CreateExecutorState();\n\t\tslot = MakeSingleTupleTableSlot(tupDesc);\n\t\tecontext = GetPerTupleExprContext(state->estate);\n\t\tecontext->ecxt_scantuple = slot;\n\t}\n\n\t/* Prepare SortSupport data for each column */\n\tstate->sortKeys = (SortSupport) palloc0(state->nKeys *\n\t\t\t\t\t\t\t\t\t\t\tsizeof(SortSupportData));\n\n\tfor (i = 0; i < state->nKeys; i++)\n\t{\n\t\tSortSupport sortKey = state->sortKeys + i;\n\t\tScanKey\t\tscanKey = indexScanKey + i;\n\t\tint16\t\tstrategy;\n\n\t\tsortKey->ssup_cxt = CurrentMemoryContext;\n\t\tsortKey->ssup_collation = scanKey->sk_collation;\n\t\tsortKey->ssup_nulls_first =\n\t\t\t(scanKey->sk_flags & SK_BT_NULLS_FIRST) != 0;\n\t\tsortKey->ssup_attno = scanKey->sk_attno;\n\t\t/* Convey if abbreviation optimization is applicable in principle */\n\t\tsortKey->abbreviate = (i == 0);\n\n\t\tAssertState(sortKey->ssup_attno != 0);\n\n\t\tstrategy = (scanKey->sk_flags & SK_BT_DESC) != 0 ?\n\t\t\tBTGreaterStrategyNumber : BTLessStrategyNumber;\n\n\t\tPrepareSortSupportFromIndexRel(indexRel, strategy, sortKey);\n\t}\n\n\t_bt_freeskey(indexScanKey);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn state;\n}"
  },
  {
    "function_name": "tuplesort_begin_heap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "805-877",
    "snippet": "Tuplesortstate *\ntuplesort_begin_heap(TupleDesc tupDesc,\n\t\t\t\t\t int nkeys, AttrNumber *attNums,\n\t\t\t\t\t Oid *sortOperators, Oid *sortCollations,\n\t\t\t\t\t bool *nullsFirstFlags,\n\t\t\t\t\t int workMem, SortCoordinate coordinate, bool randomAccess)\n{\n\tTuplesortstate *state = tuplesort_begin_common(workMem, coordinate,\n\t\t\t\t\t\t\t\t\t\t\t\t   randomAccess);\n\tMemoryContext oldcontext;\n\tint\t\t\ti;\n\n\toldcontext = MemoryContextSwitchTo(state->sortcontext);\n\n\tAssertArg(nkeys > 0);\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\telog(LOG,\n\t\t\t \"begin tuple sort: nkeys = %d, workMem = %d, randomAccess = %c\",\n\t\t\t nkeys, workMem, randomAccess ? 't' : 'f');\n#endif\n\n\tstate->nKeys = nkeys;\n\n\tTRACE_POSTGRESQL_SORT_START(HEAP_SORT,\n\t\t\t\t\t\t\t\tfalse,\t/* no unique check */\n\t\t\t\t\t\t\t\tnkeys,\n\t\t\t\t\t\t\t\tworkMem,\n\t\t\t\t\t\t\t\trandomAccess,\n\t\t\t\t\t\t\t\tPARALLEL_SORT(state));\n\n\tstate->comparetup = comparetup_heap;\n\tstate->copytup = copytup_heap;\n\tstate->writetup = writetup_heap;\n\tstate->readtup = readtup_heap;\n\n\tstate->tupDesc = tupDesc;\t/* assume we need not copy tupDesc */\n\tstate->abbrevNext = 10;\n\n\t/* Prepare SortSupport data for each column */\n\tstate->sortKeys = (SortSupport) palloc0(nkeys * sizeof(SortSupportData));\n\n\tfor (i = 0; i < nkeys; i++)\n\t{\n\t\tSortSupport sortKey = state->sortKeys + i;\n\n\t\tAssertArg(attNums[i] != 0);\n\t\tAssertArg(sortOperators[i] != 0);\n\n\t\tsortKey->ssup_cxt = CurrentMemoryContext;\n\t\tsortKey->ssup_collation = sortCollations[i];\n\t\tsortKey->ssup_nulls_first = nullsFirstFlags[i];\n\t\tsortKey->ssup_attno = attNums[i];\n\t\t/* Convey if abbreviation optimization is applicable in principle */\n\t\tsortKey->abbreviate = (i == 0);\n\n\t\tPrepareSortSupportFromOrderingOp(sortOperators[i], sortKey);\n\t}\n\n\t/*\n\t * The \"onlyKey\" optimization cannot be used with abbreviated keys, since\n\t * tie-breaker comparisons may be required.  Typically, the optimization\n\t * is only of value to pass-by-value types anyway, whereas abbreviated\n\t * keys are typically only of value to pass-by-reference types.\n\t */\n\tif (nkeys == 1 && !state->sortKeys->abbrev_converter)\n\t\tstate->onlyKey = state->sortKeys;\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn state;\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define HEAP_SORT\t\t0"
    ],
    "globals_used": [
      "static Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);",
      "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrepareSortSupportFromOrderingOp",
          "args": [
            "sortOperators[i]",
            "sortKey"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "PrepareSortSupportFromOrderingOp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/sortsupport.c",
          "lines": "132-149",
          "snippet": "void\nPrepareSortSupportFromOrderingOp(Oid orderingOp, SortSupport ssup)\n{\n\tOid\t\t\topfamily;\n\tOid\t\t\topcintype;\n\tint16\t\tstrategy;\n\n\tAssert(ssup->comparator == NULL);\n\n\t/* Find the operator in pg_amop */\n\tif (!get_ordering_op_properties(orderingOp, &opfamily, &opcintype,\n\t\t\t\t\t\t\t\t\t&strategy))\n\t\telog(ERROR, \"operator %u is not a valid ordering operator\",\n\t\t\t orderingOp);\n\tssup->ssup_reverse = (strategy == BTGreaterStrategyNumber);\n\n\tFinishSortSupportFunction(opfamily, opcintype, ssup);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"fmgr.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"fmgr.h\"\n#include \"catalog/pg_am.h\"\n#include \"access/nbtree.h\"\n#include \"postgres.h\"\n\nvoid\nPrepareSortSupportFromOrderingOp(Oid orderingOp, SortSupport ssup)\n{\n\tOid\t\t\topfamily;\n\tOid\t\t\topcintype;\n\tint16\t\tstrategy;\n\n\tAssert(ssup->comparator == NULL);\n\n\t/* Find the operator in pg_amop */\n\tif (!get_ordering_op_properties(orderingOp, &opfamily, &opcintype,\n\t\t\t\t\t\t\t\t\t&strategy))\n\t\telog(ERROR, \"operator %u is not a valid ordering operator\",\n\t\t\t orderingOp);\n\tssup->ssup_reverse = (strategy == BTGreaterStrategyNumber);\n\n\tFinishSortSupportFunction(opfamily, opcintype, ssup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AssertArg",
          "args": [
            "sortOperators[i] != 0"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AssertArg",
          "args": [
            "attNums[i] != 0"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "nkeys * sizeof(SortSupportData)"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TRACE_POSTGRESQL_SORT_START",
          "args": [
            "HEAP_SORT",
            "false",
            "/* no unique check */nkeys",
            "workMem",
            "randomAccess",
            "PARALLEL_SORT(state)"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PARALLEL_SORT",
          "args": [
            "state"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "LOG",
            "\"begin tuple sort: nkeys = %d, workMem = %d, randomAccess = %c\"",
            "nkeys",
            "workMem",
            "randomAccess ? 't' : 'f'"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AssertArg",
          "args": [
            "nkeys > 0"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "state->sortcontext"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tuplesort_begin_common",
          "args": [
            "workMem",
            "coordinate",
            "randomAccess"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "tuplesort_begin_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "680-803",
          "snippet": "static Tuplesortstate *\ntuplesort_begin_common(int workMem, SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess)\n{\n\tTuplesortstate *state;\n\tMemoryContext sortcontext;\n\tMemoryContext tuplecontext;\n\tMemoryContext oldcontext;\n\n\t/* See leader_takeover_tapes() remarks on randomAccess support */\n\tif (coordinate && randomAccess)\n\t\telog(ERROR, \"random access disallowed under parallel sort\");\n\n\t/*\n\t * Create a working memory context for this sort operation. All data\n\t * needed by the sort will live inside this context.\n\t */\n\tsortcontext = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\"TupleSort main\",\n\t\t\t\t\t\t\t\t\t\tALLOCSET_DEFAULT_SIZES);\n\n\t/*\n\t * Caller tuple (e.g. IndexTuple) memory context.\n\t *\n\t * A dedicated child context used exclusively for caller passed tuples\n\t * eases memory management.  Resetting at key points reduces\n\t * fragmentation. Note that the memtuples array of SortTuples is allocated\n\t * in the parent context, not this context, because there is no need to\n\t * free memtuples early.\n\t */\n\ttuplecontext = AllocSetContextCreate(sortcontext,\n\t\t\t\t\t\t\t\t\t\t \"Caller tuples\",\n\t\t\t\t\t\t\t\t\t\t ALLOCSET_DEFAULT_SIZES);\n\n\t/*\n\t * Make the Tuplesortstate within the per-sort context.  This way, we\n\t * don't need a separate pfree() operation for it at shutdown.\n\t */\n\toldcontext = MemoryContextSwitchTo(sortcontext);\n\n\tstate = (Tuplesortstate *) palloc0(sizeof(Tuplesortstate));\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\tpg_rusage_init(&state->ru_start);\n#endif\n\n\tstate->status = TSS_INITIAL;\n\tstate->randomAccess = randomAccess;\n\tstate->bounded = false;\n\tstate->tuples = true;\n\tstate->boundUsed = false;\n\n\t/*\n\t * workMem is forced to be at least 64KB, the current minimum valid value\n\t * for the work_mem GUC.  This is a defense against parallel sort callers\n\t * that divide out memory among many workers in a way that leaves each\n\t * with very little memory.\n\t */\n\tstate->allowedMem = Max(workMem, 64) * (int64) 1024;\n\tstate->availMem = state->allowedMem;\n\tstate->sortcontext = sortcontext;\n\tstate->tuplecontext = tuplecontext;\n\tstate->tapeset = NULL;\n\n\tstate->memtupcount = 0;\n\n\t/*\n\t * Initial size of array must be more than ALLOCSET_SEPARATE_THRESHOLD;\n\t * see comments in grow_memtuples().\n\t */\n\tstate->memtupsize = Max(1024,\n\t\t\t\t\t\t\tALLOCSET_SEPARATE_THRESHOLD / sizeof(SortTuple) + 1);\n\n\tstate->growmemtuples = true;\n\tstate->slabAllocatorUsed = false;\n\tstate->memtuples = (SortTuple *) palloc(state->memtupsize * sizeof(SortTuple));\n\n\tUSEMEM(state, GetMemoryChunkSpace(state->memtuples));\n\n\t/* workMem must be large enough for the minimal memtuples array */\n\tif (LACKMEM(state))\n\t\telog(ERROR, \"insufficient memory allowed for sort\");\n\n\tstate->currentRun = 0;\n\n\t/*\n\t * maxTapes, tapeRange, and Algorithm D variables will be initialized by\n\t * inittapes(), if needed\n\t */\n\n\tstate->result_tape = -1;\t/* flag that result tape has not been formed */\n\n\t/*\n\t * Initialize parallel-related state based on coordination information\n\t * from caller\n\t */\n\tif (!coordinate)\n\t{\n\t\t/* Serial sort */\n\t\tstate->shared = NULL;\n\t\tstate->worker = -1;\n\t\tstate->nParticipants = -1;\n\t}\n\telse if (coordinate->isWorker)\n\t{\n\t\t/* Parallel worker produces exactly one final run from all input */\n\t\tstate->shared = coordinate->sharedsort;\n\t\tstate->worker = worker_get_identifier(state);\n\t\tstate->nParticipants = -1;\n\t}\n\telse\n\t{\n\t\t/* Parallel leader state only used for final merge */\n\t\tstate->shared = coordinate->sharedsort;\n\t\tstate->worker = -1;\n\t\tstate->nParticipants = coordinate->nParticipants;\n\t\tAssert(state->nParticipants >= 1);\n\t}\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn state;\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);",
            "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void inittapestate(Tuplesortstate *state, int maxTapes);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void inittapestate(Tuplesortstate *state, int maxTapes);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic Tuplesortstate *\ntuplesort_begin_common(int workMem, SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess)\n{\n\tTuplesortstate *state;\n\tMemoryContext sortcontext;\n\tMemoryContext tuplecontext;\n\tMemoryContext oldcontext;\n\n\t/* See leader_takeover_tapes() remarks on randomAccess support */\n\tif (coordinate && randomAccess)\n\t\telog(ERROR, \"random access disallowed under parallel sort\");\n\n\t/*\n\t * Create a working memory context for this sort operation. All data\n\t * needed by the sort will live inside this context.\n\t */\n\tsortcontext = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\"TupleSort main\",\n\t\t\t\t\t\t\t\t\t\tALLOCSET_DEFAULT_SIZES);\n\n\t/*\n\t * Caller tuple (e.g. IndexTuple) memory context.\n\t *\n\t * A dedicated child context used exclusively for caller passed tuples\n\t * eases memory management.  Resetting at key points reduces\n\t * fragmentation. Note that the memtuples array of SortTuples is allocated\n\t * in the parent context, not this context, because there is no need to\n\t * free memtuples early.\n\t */\n\ttuplecontext = AllocSetContextCreate(sortcontext,\n\t\t\t\t\t\t\t\t\t\t \"Caller tuples\",\n\t\t\t\t\t\t\t\t\t\t ALLOCSET_DEFAULT_SIZES);\n\n\t/*\n\t * Make the Tuplesortstate within the per-sort context.  This way, we\n\t * don't need a separate pfree() operation for it at shutdown.\n\t */\n\toldcontext = MemoryContextSwitchTo(sortcontext);\n\n\tstate = (Tuplesortstate *) palloc0(sizeof(Tuplesortstate));\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\tpg_rusage_init(&state->ru_start);\n#endif\n\n\tstate->status = TSS_INITIAL;\n\tstate->randomAccess = randomAccess;\n\tstate->bounded = false;\n\tstate->tuples = true;\n\tstate->boundUsed = false;\n\n\t/*\n\t * workMem is forced to be at least 64KB, the current minimum valid value\n\t * for the work_mem GUC.  This is a defense against parallel sort callers\n\t * that divide out memory among many workers in a way that leaves each\n\t * with very little memory.\n\t */\n\tstate->allowedMem = Max(workMem, 64) * (int64) 1024;\n\tstate->availMem = state->allowedMem;\n\tstate->sortcontext = sortcontext;\n\tstate->tuplecontext = tuplecontext;\n\tstate->tapeset = NULL;\n\n\tstate->memtupcount = 0;\n\n\t/*\n\t * Initial size of array must be more than ALLOCSET_SEPARATE_THRESHOLD;\n\t * see comments in grow_memtuples().\n\t */\n\tstate->memtupsize = Max(1024,\n\t\t\t\t\t\t\tALLOCSET_SEPARATE_THRESHOLD / sizeof(SortTuple) + 1);\n\n\tstate->growmemtuples = true;\n\tstate->slabAllocatorUsed = false;\n\tstate->memtuples = (SortTuple *) palloc(state->memtupsize * sizeof(SortTuple));\n\n\tUSEMEM(state, GetMemoryChunkSpace(state->memtuples));\n\n\t/* workMem must be large enough for the minimal memtuples array */\n\tif (LACKMEM(state))\n\t\telog(ERROR, \"insufficient memory allowed for sort\");\n\n\tstate->currentRun = 0;\n\n\t/*\n\t * maxTapes, tapeRange, and Algorithm D variables will be initialized by\n\t * inittapes(), if needed\n\t */\n\n\tstate->result_tape = -1;\t/* flag that result tape has not been formed */\n\n\t/*\n\t * Initialize parallel-related state based on coordination information\n\t * from caller\n\t */\n\tif (!coordinate)\n\t{\n\t\t/* Serial sort */\n\t\tstate->shared = NULL;\n\t\tstate->worker = -1;\n\t\tstate->nParticipants = -1;\n\t}\n\telse if (coordinate->isWorker)\n\t{\n\t\t/* Parallel worker produces exactly one final run from all input */\n\t\tstate->shared = coordinate->sharedsort;\n\t\tstate->worker = worker_get_identifier(state);\n\t\tstate->nParticipants = -1;\n\t}\n\telse\n\t{\n\t\t/* Parallel leader state only used for final merge */\n\t\tstate->shared = coordinate->sharedsort;\n\t\tstate->worker = -1;\n\t\tstate->nParticipants = coordinate->nParticipants;\n\t\tAssert(state->nParticipants >= 1);\n\t}\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn state;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define HEAP_SORT\t\t0\n\nstatic Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nTuplesortstate *\ntuplesort_begin_heap(TupleDesc tupDesc,\n\t\t\t\t\t int nkeys, AttrNumber *attNums,\n\t\t\t\t\t Oid *sortOperators, Oid *sortCollations,\n\t\t\t\t\t bool *nullsFirstFlags,\n\t\t\t\t\t int workMem, SortCoordinate coordinate, bool randomAccess)\n{\n\tTuplesortstate *state = tuplesort_begin_common(workMem, coordinate,\n\t\t\t\t\t\t\t\t\t\t\t\t   randomAccess);\n\tMemoryContext oldcontext;\n\tint\t\t\ti;\n\n\toldcontext = MemoryContextSwitchTo(state->sortcontext);\n\n\tAssertArg(nkeys > 0);\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\telog(LOG,\n\t\t\t \"begin tuple sort: nkeys = %d, workMem = %d, randomAccess = %c\",\n\t\t\t nkeys, workMem, randomAccess ? 't' : 'f');\n#endif\n\n\tstate->nKeys = nkeys;\n\n\tTRACE_POSTGRESQL_SORT_START(HEAP_SORT,\n\t\t\t\t\t\t\t\tfalse,\t/* no unique check */\n\t\t\t\t\t\t\t\tnkeys,\n\t\t\t\t\t\t\t\tworkMem,\n\t\t\t\t\t\t\t\trandomAccess,\n\t\t\t\t\t\t\t\tPARALLEL_SORT(state));\n\n\tstate->comparetup = comparetup_heap;\n\tstate->copytup = copytup_heap;\n\tstate->writetup = writetup_heap;\n\tstate->readtup = readtup_heap;\n\n\tstate->tupDesc = tupDesc;\t/* assume we need not copy tupDesc */\n\tstate->abbrevNext = 10;\n\n\t/* Prepare SortSupport data for each column */\n\tstate->sortKeys = (SortSupport) palloc0(nkeys * sizeof(SortSupportData));\n\n\tfor (i = 0; i < nkeys; i++)\n\t{\n\t\tSortSupport sortKey = state->sortKeys + i;\n\n\t\tAssertArg(attNums[i] != 0);\n\t\tAssertArg(sortOperators[i] != 0);\n\n\t\tsortKey->ssup_cxt = CurrentMemoryContext;\n\t\tsortKey->ssup_collation = sortCollations[i];\n\t\tsortKey->ssup_nulls_first = nullsFirstFlags[i];\n\t\tsortKey->ssup_attno = attNums[i];\n\t\t/* Convey if abbreviation optimization is applicable in principle */\n\t\tsortKey->abbreviate = (i == 0);\n\n\t\tPrepareSortSupportFromOrderingOp(sortOperators[i], sortKey);\n\t}\n\n\t/*\n\t * The \"onlyKey\" optimization cannot be used with abbreviated keys, since\n\t * tie-breaker comparisons may be required.  Typically, the optimization\n\t * is only of value to pass-by-value types anyway, whereas abbreviated\n\t * keys are typically only of value to pass-by-reference types.\n\t */\n\tif (nkeys == 1 && !state->sortKeys->abbrev_converter)\n\t\tstate->onlyKey = state->sortKeys;\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn state;\n}"
  },
  {
    "function_name": "tuplesort_begin_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
    "lines": "680-803",
    "snippet": "static Tuplesortstate *\ntuplesort_begin_common(int workMem, SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess)\n{\n\tTuplesortstate *state;\n\tMemoryContext sortcontext;\n\tMemoryContext tuplecontext;\n\tMemoryContext oldcontext;\n\n\t/* See leader_takeover_tapes() remarks on randomAccess support */\n\tif (coordinate && randomAccess)\n\t\telog(ERROR, \"random access disallowed under parallel sort\");\n\n\t/*\n\t * Create a working memory context for this sort operation. All data\n\t * needed by the sort will live inside this context.\n\t */\n\tsortcontext = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\"TupleSort main\",\n\t\t\t\t\t\t\t\t\t\tALLOCSET_DEFAULT_SIZES);\n\n\t/*\n\t * Caller tuple (e.g. IndexTuple) memory context.\n\t *\n\t * A dedicated child context used exclusively for caller passed tuples\n\t * eases memory management.  Resetting at key points reduces\n\t * fragmentation. Note that the memtuples array of SortTuples is allocated\n\t * in the parent context, not this context, because there is no need to\n\t * free memtuples early.\n\t */\n\ttuplecontext = AllocSetContextCreate(sortcontext,\n\t\t\t\t\t\t\t\t\t\t \"Caller tuples\",\n\t\t\t\t\t\t\t\t\t\t ALLOCSET_DEFAULT_SIZES);\n\n\t/*\n\t * Make the Tuplesortstate within the per-sort context.  This way, we\n\t * don't need a separate pfree() operation for it at shutdown.\n\t */\n\toldcontext = MemoryContextSwitchTo(sortcontext);\n\n\tstate = (Tuplesortstate *) palloc0(sizeof(Tuplesortstate));\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\tpg_rusage_init(&state->ru_start);\n#endif\n\n\tstate->status = TSS_INITIAL;\n\tstate->randomAccess = randomAccess;\n\tstate->bounded = false;\n\tstate->tuples = true;\n\tstate->boundUsed = false;\n\n\t/*\n\t * workMem is forced to be at least 64KB, the current minimum valid value\n\t * for the work_mem GUC.  This is a defense against parallel sort callers\n\t * that divide out memory among many workers in a way that leaves each\n\t * with very little memory.\n\t */\n\tstate->allowedMem = Max(workMem, 64) * (int64) 1024;\n\tstate->availMem = state->allowedMem;\n\tstate->sortcontext = sortcontext;\n\tstate->tuplecontext = tuplecontext;\n\tstate->tapeset = NULL;\n\n\tstate->memtupcount = 0;\n\n\t/*\n\t * Initial size of array must be more than ALLOCSET_SEPARATE_THRESHOLD;\n\t * see comments in grow_memtuples().\n\t */\n\tstate->memtupsize = Max(1024,\n\t\t\t\t\t\t\tALLOCSET_SEPARATE_THRESHOLD / sizeof(SortTuple) + 1);\n\n\tstate->growmemtuples = true;\n\tstate->slabAllocatorUsed = false;\n\tstate->memtuples = (SortTuple *) palloc(state->memtupsize * sizeof(SortTuple));\n\n\tUSEMEM(state, GetMemoryChunkSpace(state->memtuples));\n\n\t/* workMem must be large enough for the minimal memtuples array */\n\tif (LACKMEM(state))\n\t\telog(ERROR, \"insufficient memory allowed for sort\");\n\n\tstate->currentRun = 0;\n\n\t/*\n\t * maxTapes, tapeRange, and Algorithm D variables will be initialized by\n\t * inittapes(), if needed\n\t */\n\n\tstate->result_tape = -1;\t/* flag that result tape has not been formed */\n\n\t/*\n\t * Initialize parallel-related state based on coordination information\n\t * from caller\n\t */\n\tif (!coordinate)\n\t{\n\t\t/* Serial sort */\n\t\tstate->shared = NULL;\n\t\tstate->worker = -1;\n\t\tstate->nParticipants = -1;\n\t}\n\telse if (coordinate->isWorker)\n\t{\n\t\t/* Parallel worker produces exactly one final run from all input */\n\t\tstate->shared = coordinate->sharedsort;\n\t\tstate->worker = worker_get_identifier(state);\n\t\tstate->nParticipants = -1;\n\t}\n\telse\n\t{\n\t\t/* Parallel leader state only used for final merge */\n\t\tstate->shared = coordinate->sharedsort;\n\t\tstate->worker = -1;\n\t\tstate->nParticipants = coordinate->nParticipants;\n\t\tAssert(state->nParticipants >= 1);\n\t}\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn state;\n}",
    "includes": [
      "#include \"qsort_tuple.c\"",
      "#include \"utils/tuplesort.h\"",
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_rusage.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/logtape.h\"",
      "#include \"utils/datum.h\"",
      "#include \"pg_trace.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"commands/tablespace.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);",
      "static void puttuple_common(Tuplesortstate *state, SortTuple *tuple);",
      "static bool consider_abort_common(Tuplesortstate *state);",
      "static void inittapestate(Tuplesortstate *state, int maxTapes);",
      "static void selectnewtape(Tuplesortstate *state);",
      "static void mergeruns(Tuplesortstate *state);",
      "static void mergeonerun(Tuplesortstate *state);",
      "static void beginmerge(Tuplesortstate *state);",
      "static void make_bounded_heap(Tuplesortstate *state);",
      "static void sort_bounded_heap(Tuplesortstate *state);",
      "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
      "static void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);",
      "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
      "static void reversedirection(Tuplesortstate *state);",
      "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
      "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
      "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
      "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
      "static int\tworker_get_identifier(Tuplesortstate *state);",
      "static void worker_freeze_result_tape(Tuplesortstate *state);",
      "static void worker_nomergeruns(Tuplesortstate *state);",
      "static void leader_takeover_tapes(Tuplesortstate *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "state->nParticipants >= 1"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "worker_get_identifier",
          "args": [
            "state"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "worker_get_identifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplesort.c",
          "lines": "4426-4439",
          "snippet": "static int\nworker_get_identifier(Tuplesortstate *state)\n{\n\tSharedsort *shared = state->shared;\n\tint\t\t\tworker;\n\n\tAssert(WORKER(state));\n\n\tSpinLockAcquire(&shared->mutex);\n\tworker = shared->currentWorker++;\n\tSpinLockRelease(&shared->mutex);\n\n\treturn worker;\n}",
          "includes": [
            "#include \"qsort_tuple.c\"",
            "#include \"utils/tuplesort.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_rusage.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/logtape.h\"",
            "#include \"utils/datum.h\"",
            "#include \"pg_trace.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool consider_abort_common(Tuplesortstate *state);",
            "static void selectnewtape(Tuplesortstate *state);",
            "static void mergeruns(Tuplesortstate *state);",
            "static void mergeonerun(Tuplesortstate *state);",
            "static void beginmerge(Tuplesortstate *state);",
            "static void make_bounded_heap(Tuplesortstate *state);",
            "static void sort_bounded_heap(Tuplesortstate *state);",
            "static void tuplesort_sort_memtuples(Tuplesortstate *state);",
            "static void tuplesort_heap_delete_top(Tuplesortstate *state);",
            "static void reversedirection(Tuplesortstate *state);",
            "static int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);",
            "static int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);",
            "static int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);",
            "static int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);",
            "static int\tworker_get_identifier(Tuplesortstate *state);",
            "static void worker_freeze_result_tape(Tuplesortstate *state);",
            "static void worker_nomergeruns(Tuplesortstate *state);",
            "static void leader_takeover_tapes(Tuplesortstate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic int\nworker_get_identifier(Tuplesortstate *state)\n{\n\tSharedsort *shared = state->shared;\n\tint\t\t\tworker;\n\n\tAssert(WORKER(state));\n\n\tSpinLockAcquire(&shared->mutex);\n\tworker = shared->currentWorker++;\n\tSpinLockRelease(&shared->mutex);\n\n\treturn worker;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"insufficient memory allowed for sort\""
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LACKMEM",
          "args": [
            "state"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USEMEM",
          "args": [
            "state",
            "GetMemoryChunkSpace(state->memtuples)"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetMemoryChunkSpace",
          "args": [
            "state->memtuples"
          ],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "GetMemoryChunkSpace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "426-432",
          "snippet": "Size\nGetMemoryChunkSpace(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\treturn context->methods->get_chunk_space(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nSize\nGetMemoryChunkSpace(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\treturn context->methods->get_chunk_space(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "state->memtupsize * sizeof(SortTuple)"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Max",
          "args": [
            "1024",
            "ALLOCSET_SEPARATE_THRESHOLD / sizeof(SortTuple) + 1"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Max",
          "args": [
            "workMem",
            "64"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_rusage_init",
          "args": [
            "&state->ru_start"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "pg_rusage_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/pg_rusage.c",
          "lines": "26-31",
          "snippet": "void\npg_rusage_init(PGRUsage *ru0)\n{\n\tgetrusage(RUSAGE_SELF, &ru0->ru);\n\tgettimeofday(&ru0->tv, NULL);\n}",
          "includes": [
            "#include \"utils/pg_rusage.h\"",
            "#include <unistd.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_rusage.h\"\n#include <unistd.h>\n#include \"postgres.h\"\n\nvoid\npg_rusage_init(PGRUsage *ru0)\n{\n\tgetrusage(RUSAGE_SELF, &ru0->ru);\n\tgettimeofday(&ru0->tv, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "sortcontext"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocSetContextCreate",
          "args": [
            "sortcontext",
            "\"Caller tuples\"",
            "ALLOCSET_DEFAULT_SIZES"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocSetContextCreate",
          "args": [
            "CurrentMemoryContext",
            "\"TupleSort main\"",
            "ALLOCSET_DEFAULT_SIZES"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qsort_tuple.c\"\n#include \"utils/tuplesort.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_rusage.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/logtape.h\"\n#include \"utils/datum.h\"\n#include \"pg_trace.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/hash.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Tuplesortstate *tuplesort_begin_common(int workMem,\n\t\t\t\t\t   SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess);\nstatic void puttuple_common(Tuplesortstate *state, SortTuple *tuple);\nstatic bool consider_abort_common(Tuplesortstate *state);\nstatic void inittapestate(Tuplesortstate *state, int maxTapes);\nstatic void selectnewtape(Tuplesortstate *state);\nstatic void mergeruns(Tuplesortstate *state);\nstatic void mergeonerun(Tuplesortstate *state);\nstatic void beginmerge(Tuplesortstate *state);\nstatic void make_bounded_heap(Tuplesortstate *state);\nstatic void sort_bounded_heap(Tuplesortstate *state);\nstatic void tuplesort_sort_memtuples(Tuplesortstate *state);\nstatic void tuplesort_heap_insert(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_replace_top(Tuplesortstate *state, SortTuple *tuple);\nstatic void tuplesort_heap_delete_top(Tuplesortstate *state);\nstatic void reversedirection(Tuplesortstate *state);\nstatic int comparetup_heap(const SortTuple *a, const SortTuple *b,\n\t\t\t\tTuplesortstate *state);\nstatic int comparetup_cluster(const SortTuple *a, const SortTuple *b,\n\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_btree(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t   Tuplesortstate *state);\nstatic int comparetup_index_hash(const SortTuple *a, const SortTuple *b,\n\t\t\t\t\t  Tuplesortstate *state);\nstatic int comparetup_datum(const SortTuple *a, const SortTuple *b,\n\t\t\t\t Tuplesortstate *state);\nstatic int\tworker_get_identifier(Tuplesortstate *state);\nstatic void worker_freeze_result_tape(Tuplesortstate *state);\nstatic void worker_nomergeruns(Tuplesortstate *state);\nstatic void leader_takeover_tapes(Tuplesortstate *state);\n\nstatic Tuplesortstate *\ntuplesort_begin_common(int workMem, SortCoordinate coordinate,\n\t\t\t\t\t   bool randomAccess)\n{\n\tTuplesortstate *state;\n\tMemoryContext sortcontext;\n\tMemoryContext tuplecontext;\n\tMemoryContext oldcontext;\n\n\t/* See leader_takeover_tapes() remarks on randomAccess support */\n\tif (coordinate && randomAccess)\n\t\telog(ERROR, \"random access disallowed under parallel sort\");\n\n\t/*\n\t * Create a working memory context for this sort operation. All data\n\t * needed by the sort will live inside this context.\n\t */\n\tsortcontext = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\"TupleSort main\",\n\t\t\t\t\t\t\t\t\t\tALLOCSET_DEFAULT_SIZES);\n\n\t/*\n\t * Caller tuple (e.g. IndexTuple) memory context.\n\t *\n\t * A dedicated child context used exclusively for caller passed tuples\n\t * eases memory management.  Resetting at key points reduces\n\t * fragmentation. Note that the memtuples array of SortTuples is allocated\n\t * in the parent context, not this context, because there is no need to\n\t * free memtuples early.\n\t */\n\ttuplecontext = AllocSetContextCreate(sortcontext,\n\t\t\t\t\t\t\t\t\t\t \"Caller tuples\",\n\t\t\t\t\t\t\t\t\t\t ALLOCSET_DEFAULT_SIZES);\n\n\t/*\n\t * Make the Tuplesortstate within the per-sort context.  This way, we\n\t * don't need a separate pfree() operation for it at shutdown.\n\t */\n\toldcontext = MemoryContextSwitchTo(sortcontext);\n\n\tstate = (Tuplesortstate *) palloc0(sizeof(Tuplesortstate));\n\n#ifdef TRACE_SORT\n\tif (trace_sort)\n\t\tpg_rusage_init(&state->ru_start);\n#endif\n\n\tstate->status = TSS_INITIAL;\n\tstate->randomAccess = randomAccess;\n\tstate->bounded = false;\n\tstate->tuples = true;\n\tstate->boundUsed = false;\n\n\t/*\n\t * workMem is forced to be at least 64KB, the current minimum valid value\n\t * for the work_mem GUC.  This is a defense against parallel sort callers\n\t * that divide out memory among many workers in a way that leaves each\n\t * with very little memory.\n\t */\n\tstate->allowedMem = Max(workMem, 64) * (int64) 1024;\n\tstate->availMem = state->allowedMem;\n\tstate->sortcontext = sortcontext;\n\tstate->tuplecontext = tuplecontext;\n\tstate->tapeset = NULL;\n\n\tstate->memtupcount = 0;\n\n\t/*\n\t * Initial size of array must be more than ALLOCSET_SEPARATE_THRESHOLD;\n\t * see comments in grow_memtuples().\n\t */\n\tstate->memtupsize = Max(1024,\n\t\t\t\t\t\t\tALLOCSET_SEPARATE_THRESHOLD / sizeof(SortTuple) + 1);\n\n\tstate->growmemtuples = true;\n\tstate->slabAllocatorUsed = false;\n\tstate->memtuples = (SortTuple *) palloc(state->memtupsize * sizeof(SortTuple));\n\n\tUSEMEM(state, GetMemoryChunkSpace(state->memtuples));\n\n\t/* workMem must be large enough for the minimal memtuples array */\n\tif (LACKMEM(state))\n\t\telog(ERROR, \"insufficient memory allowed for sort\");\n\n\tstate->currentRun = 0;\n\n\t/*\n\t * maxTapes, tapeRange, and Algorithm D variables will be initialized by\n\t * inittapes(), if needed\n\t */\n\n\tstate->result_tape = -1;\t/* flag that result tape has not been formed */\n\n\t/*\n\t * Initialize parallel-related state based on coordination information\n\t * from caller\n\t */\n\tif (!coordinate)\n\t{\n\t\t/* Serial sort */\n\t\tstate->shared = NULL;\n\t\tstate->worker = -1;\n\t\tstate->nParticipants = -1;\n\t}\n\telse if (coordinate->isWorker)\n\t{\n\t\t/* Parallel worker produces exactly one final run from all input */\n\t\tstate->shared = coordinate->sharedsort;\n\t\tstate->worker = worker_get_identifier(state);\n\t\tstate->nParticipants = -1;\n\t}\n\telse\n\t{\n\t\t/* Parallel leader state only used for final merge */\n\t\tstate->shared = coordinate->sharedsort;\n\t\tstate->worker = -1;\n\t\tstate->nParticipants = coordinate->nParticipants;\n\t\tAssert(state->nParticipants >= 1);\n\t}\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn state;\n}"
  }
]