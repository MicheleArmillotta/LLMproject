[
  {
    "function_name": "utf8_to_iso8859_1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/conversion_procs/utf8_and_iso8859_1/utf8_and_iso8859_1.c",
    "lines": "64-112",
    "snippet": "Datum\nutf8_to_iso8859_1(PG_FUNCTION_ARGS)\n{\n\tunsigned char *src = (unsigned char *) PG_GETARG_CSTRING(2);\n\tunsigned char *dest = (unsigned char *) PG_GETARG_CSTRING(3);\n\tint\t\t\tlen = PG_GETARG_INT32(4);\n\tunsigned short c,\n\t\t\t\tc1;\n\n\tCHECK_ENCODING_CONVERSION_ARGS(PG_UTF8, PG_LATIN1);\n\n\twhile (len > 0)\n\t{\n\t\tc = *src;\n\t\tif (c == 0)\n\t\t\treport_invalid_encoding(PG_UTF8, (const char *) src, len);\n\t\t/* fast path for ASCII-subset characters */\n\t\tif (!IS_HIGHBIT_SET(c))\n\t\t{\n\t\t\t*dest++ = c;\n\t\t\tsrc++;\n\t\t\tlen--;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint\t\t\tl = pg_utf_mblen(src);\n\n\t\t\tif (l > len || !pg_utf8_islegal(src, l))\n\t\t\t\treport_invalid_encoding(PG_UTF8, (const char *) src, len);\n\t\t\tif (l != 2)\n\t\t\t\treport_untranslatable_char(PG_UTF8, PG_LATIN1,\n\t\t\t\t\t\t\t\t\t\t   (const char *) src, len);\n\t\t\tc1 = src[1] & 0x3f;\n\t\t\tc = ((c & 0x1f) << 6) | c1;\n\t\t\tif (c >= 0x80 && c <= 0xff)\n\t\t\t{\n\t\t\t\t*dest++ = (unsigned char) c;\n\t\t\t\tsrc += 2;\n\t\t\t\tlen -= 2;\n\t\t\t}\n\t\t\telse\n\t\t\t\treport_untranslatable_char(PG_UTF8, PG_LATIN1,\n\t\t\t\t\t\t\t\t\t\t   (const char *) src, len);\n\t\t}\n\t}\n\t*dest = '\\0';\n\n\tPG_RETURN_VOID();\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"fmgr.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VOID",
          "args": [],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "report_untranslatable_char",
          "args": [
            "PG_UTF8",
            "PG_LATIN1",
            "(const char *) src",
            "len"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "report_untranslatable_char",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "2026-2052",
          "snippet": "void\nreport_untranslatable_char(int src_encoding, int dest_encoding,\n\t\t\t\t\t\t   const char *mbstr, int len)\n{\n\tint\t\t\tl = pg_encoding_mblen(src_encoding, mbstr);\n\tchar\t\tbuf[8 * 5 + 1];\n\tchar\t   *p = buf;\n\tint\t\t\tj,\n\t\t\t\tjlimit;\n\n\tjlimit = Min(l, len);\n\tjlimit = Min(jlimit, 8);\t/* prevent buffer overrun */\n\n\tfor (j = 0; j < jlimit; j++)\n\t{\n\t\tp += sprintf(p, \"0x%02x\", (unsigned char) mbstr[j]);\n\t\tif (j < jlimit - 1)\n\t\t\tp += sprintf(p, \" \");\n\t}\n\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_UNTRANSLATABLE_CHARACTER),\n\t\t\t errmsg(\"character with byte sequence %s in encoding \\\"%s\\\" has no equivalent in encoding \\\"%s\\\"\",\n\t\t\t\t\tbuf,\n\t\t\t\t\tpg_enc2name_tbl[src_encoding].name,\n\t\t\t\t\tpg_enc2name_tbl[dest_encoding].name)));\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nvoid\nreport_untranslatable_char(int src_encoding, int dest_encoding,\n\t\t\t\t\t\t   const char *mbstr, int len)\n{\n\tint\t\t\tl = pg_encoding_mblen(src_encoding, mbstr);\n\tchar\t\tbuf[8 * 5 + 1];\n\tchar\t   *p = buf;\n\tint\t\t\tj,\n\t\t\t\tjlimit;\n\n\tjlimit = Min(l, len);\n\tjlimit = Min(jlimit, 8);\t/* prevent buffer overrun */\n\n\tfor (j = 0; j < jlimit; j++)\n\t{\n\t\tp += sprintf(p, \"0x%02x\", (unsigned char) mbstr[j]);\n\t\tif (j < jlimit - 1)\n\t\t\tp += sprintf(p, \" \");\n\t}\n\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_UNTRANSLATABLE_CHARACTER),\n\t\t\t errmsg(\"character with byte sequence %s in encoding \\\"%s\\\" has no equivalent in encoding \\\"%s\\\"\",\n\t\t\t\t\tbuf,\n\t\t\t\t\tpg_enc2name_tbl[src_encoding].name,\n\t\t\t\t\tpg_enc2name_tbl[dest_encoding].name)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "report_invalid_encoding",
          "args": [
            "PG_UTF8",
            "(const char *) src",
            "len"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "report_invalid_encoding",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "1994-2018",
          "snippet": "void\nreport_invalid_encoding(int encoding, const char *mbstr, int len)\n{\n\tint\t\t\tl = pg_encoding_mblen(encoding, mbstr);\n\tchar\t\tbuf[8 * 5 + 1];\n\tchar\t   *p = buf;\n\tint\t\t\tj,\n\t\t\t\tjlimit;\n\n\tjlimit = Min(l, len);\n\tjlimit = Min(jlimit, 8);\t/* prevent buffer overrun */\n\n\tfor (j = 0; j < jlimit; j++)\n\t{\n\t\tp += sprintf(p, \"0x%02x\", (unsigned char) mbstr[j]);\n\t\tif (j < jlimit - 1)\n\t\t\tp += sprintf(p, \" \");\n\t}\n\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_CHARACTER_NOT_IN_REPERTOIRE),\n\t\t\t errmsg(\"invalid byte sequence for encoding \\\"%s\\\": %s\",\n\t\t\t\t\tpg_enc2name_tbl[encoding].name,\n\t\t\t\t\tbuf)));\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nvoid\nreport_invalid_encoding(int encoding, const char *mbstr, int len)\n{\n\tint\t\t\tl = pg_encoding_mblen(encoding, mbstr);\n\tchar\t\tbuf[8 * 5 + 1];\n\tchar\t   *p = buf;\n\tint\t\t\tj,\n\t\t\t\tjlimit;\n\n\tjlimit = Min(l, len);\n\tjlimit = Min(jlimit, 8);\t/* prevent buffer overrun */\n\n\tfor (j = 0; j < jlimit; j++)\n\t{\n\t\tp += sprintf(p, \"0x%02x\", (unsigned char) mbstr[j]);\n\t\tif (j < jlimit - 1)\n\t\t\tp += sprintf(p, \" \");\n\t}\n\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_CHARACTER_NOT_IN_REPERTOIRE),\n\t\t\t errmsg(\"invalid byte sequence for encoding \\\"%s\\\": %s\",\n\t\t\t\t\tpg_enc2name_tbl[encoding].name,\n\t\t\t\t\tbuf)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_utf8_islegal",
          "args": [
            "src",
            "l"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "pg_utf8_islegal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "1457-1512",
          "snippet": "bool\npg_utf8_islegal(const unsigned char *source, int length)\n{\n\tunsigned char a;\n\n\tswitch (length)\n\t{\n\t\tdefault:\n\t\t\t/* reject lengths 5 and 6 for now */\n\t\t\treturn false;\n\t\tcase 4:\n\t\t\ta = source[3];\n\t\t\tif (a < 0x80 || a > 0xBF)\n\t\t\t\treturn false;\n\t\t\t/* FALL THRU */\n\t\tcase 3:\n\t\t\ta = source[2];\n\t\t\tif (a < 0x80 || a > 0xBF)\n\t\t\t\treturn false;\n\t\t\t/* FALL THRU */\n\t\tcase 2:\n\t\t\ta = source[1];\n\t\t\tswitch (*source)\n\t\t\t{\n\t\t\t\tcase 0xE0:\n\t\t\t\t\tif (a < 0xA0 || a > 0xBF)\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xED:\n\t\t\t\t\tif (a < 0x80 || a > 0x9F)\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xF0:\n\t\t\t\t\tif (a < 0x90 || a > 0xBF)\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xF4:\n\t\t\t\t\tif (a < 0x80 || a > 0x8F)\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (a < 0x80 || a > 0xBF)\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* FALL THRU */\n\t\tcase 1:\n\t\t\ta = *source;\n\t\t\tif (a >= 0x80 && a < 0xC2)\n\t\t\t\treturn false;\n\t\t\tif (a > 0xF4)\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nbool\npg_utf8_islegal(const unsigned char *source, int length)\n{\n\tunsigned char a;\n\n\tswitch (length)\n\t{\n\t\tdefault:\n\t\t\t/* reject lengths 5 and 6 for now */\n\t\t\treturn false;\n\t\tcase 4:\n\t\t\ta = source[3];\n\t\t\tif (a < 0x80 || a > 0xBF)\n\t\t\t\treturn false;\n\t\t\t/* FALL THRU */\n\t\tcase 3:\n\t\t\ta = source[2];\n\t\t\tif (a < 0x80 || a > 0xBF)\n\t\t\t\treturn false;\n\t\t\t/* FALL THRU */\n\t\tcase 2:\n\t\t\ta = source[1];\n\t\t\tswitch (*source)\n\t\t\t{\n\t\t\t\tcase 0xE0:\n\t\t\t\t\tif (a < 0xA0 || a > 0xBF)\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xED:\n\t\t\t\t\tif (a < 0x80 || a > 0x9F)\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xF0:\n\t\t\t\t\tif (a < 0x90 || a > 0xBF)\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xF4:\n\t\t\t\t\tif (a < 0x80 || a > 0x8F)\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (a < 0x80 || a > 0xBF)\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* FALL THRU */\n\t\tcase 1:\n\t\t\ta = *source;\n\t\t\tif (a >= 0x80 && a < 0xC2)\n\t\t\t\treturn false;\n\t\t\tif (a > 0xF4)\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_utf_mblen",
          "args": [
            "src"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "pg_utf_mblen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "540-562",
          "snippet": "int\npg_utf_mblen(const unsigned char *s)\n{\n\tint\t\t\tlen;\n\n\tif ((*s & 0x80) == 0)\n\t\tlen = 1;\n\telse if ((*s & 0xe0) == 0xc0)\n\t\tlen = 2;\n\telse if ((*s & 0xf0) == 0xe0)\n\t\tlen = 3;\n\telse if ((*s & 0xf8) == 0xf0)\n\t\tlen = 4;\n#ifdef NOT_USED\n\telse if ((*s & 0xfc) == 0xf8)\n\t\tlen = 5;\n\telse if ((*s & 0xfe) == 0xfc)\n\t\tlen = 6;\n#endif\n\telse\n\t\tlen = 1;\n\treturn len;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nint\npg_utf_mblen(const unsigned char *s)\n{\n\tint\t\t\tlen;\n\n\tif ((*s & 0x80) == 0)\n\t\tlen = 1;\n\telse if ((*s & 0xe0) == 0xc0)\n\t\tlen = 2;\n\telse if ((*s & 0xf0) == 0xe0)\n\t\tlen = 3;\n\telse if ((*s & 0xf8) == 0xf0)\n\t\tlen = 4;\n#ifdef NOT_USED\n\telse if ((*s & 0xfc) == 0xf8)\n\t\tlen = 5;\n\telse if ((*s & 0xfe) == 0xfc)\n\t\tlen = 6;\n#endif\n\telse\n\t\tlen = 1;\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_HIGHBIT_SET",
          "args": [
            "c"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_ENCODING_CONVERSION_ARGS",
          "args": [
            "PG_UTF8",
            "PG_LATIN1"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "4"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CSTRING",
          "args": [
            "3"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CSTRING",
          "args": [
            "2"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"fmgr.h\"\n#include \"postgres.h\"\n\nDatum\nutf8_to_iso8859_1(PG_FUNCTION_ARGS)\n{\n\tunsigned char *src = (unsigned char *) PG_GETARG_CSTRING(2);\n\tunsigned char *dest = (unsigned char *) PG_GETARG_CSTRING(3);\n\tint\t\t\tlen = PG_GETARG_INT32(4);\n\tunsigned short c,\n\t\t\t\tc1;\n\n\tCHECK_ENCODING_CONVERSION_ARGS(PG_UTF8, PG_LATIN1);\n\n\twhile (len > 0)\n\t{\n\t\tc = *src;\n\t\tif (c == 0)\n\t\t\treport_invalid_encoding(PG_UTF8, (const char *) src, len);\n\t\t/* fast path for ASCII-subset characters */\n\t\tif (!IS_HIGHBIT_SET(c))\n\t\t{\n\t\t\t*dest++ = c;\n\t\t\tsrc++;\n\t\t\tlen--;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint\t\t\tl = pg_utf_mblen(src);\n\n\t\t\tif (l > len || !pg_utf8_islegal(src, l))\n\t\t\t\treport_invalid_encoding(PG_UTF8, (const char *) src, len);\n\t\t\tif (l != 2)\n\t\t\t\treport_untranslatable_char(PG_UTF8, PG_LATIN1,\n\t\t\t\t\t\t\t\t\t\t   (const char *) src, len);\n\t\t\tc1 = src[1] & 0x3f;\n\t\t\tc = ((c & 0x1f) << 6) | c1;\n\t\t\tif (c >= 0x80 && c <= 0xff)\n\t\t\t{\n\t\t\t\t*dest++ = (unsigned char) c;\n\t\t\t\tsrc += 2;\n\t\t\t\tlen -= 2;\n\t\t\t}\n\t\t\telse\n\t\t\t\treport_untranslatable_char(PG_UTF8, PG_LATIN1,\n\t\t\t\t\t\t\t\t\t\t   (const char *) src, len);\n\t\t}\n\t}\n\t*dest = '\\0';\n\n\tPG_RETURN_VOID();\n}"
  },
  {
    "function_name": "iso8859_1_to_utf8",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/conversion_procs/utf8_and_iso8859_1/utf8_and_iso8859_1.c",
    "lines": "34-62",
    "snippet": "Datum\niso8859_1_to_utf8(PG_FUNCTION_ARGS)\n{\n\tunsigned char *src = (unsigned char *) PG_GETARG_CSTRING(2);\n\tunsigned char *dest = (unsigned char *) PG_GETARG_CSTRING(3);\n\tint\t\t\tlen = PG_GETARG_INT32(4);\n\tunsigned short c;\n\n\tCHECK_ENCODING_CONVERSION_ARGS(PG_LATIN1, PG_UTF8);\n\n\twhile (len > 0)\n\t{\n\t\tc = *src;\n\t\tif (c == 0)\n\t\t\treport_invalid_encoding(PG_LATIN1, (const char *) src, len);\n\t\tif (!IS_HIGHBIT_SET(c))\n\t\t\t*dest++ = c;\n\t\telse\n\t\t{\n\t\t\t*dest++ = (c >> 6) | 0xc0;\n\t\t\t*dest++ = (c & 0x003f) | HIGHBIT;\n\t\t}\n\t\tsrc++;\n\t\tlen--;\n\t}\n\t*dest = '\\0';\n\n\tPG_RETURN_VOID();\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"fmgr.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VOID",
          "args": [],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_HIGHBIT_SET",
          "args": [
            "c"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "report_invalid_encoding",
          "args": [
            "PG_LATIN1",
            "(const char *) src",
            "len"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "report_invalid_encoding",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "1994-2018",
          "snippet": "void\nreport_invalid_encoding(int encoding, const char *mbstr, int len)\n{\n\tint\t\t\tl = pg_encoding_mblen(encoding, mbstr);\n\tchar\t\tbuf[8 * 5 + 1];\n\tchar\t   *p = buf;\n\tint\t\t\tj,\n\t\t\t\tjlimit;\n\n\tjlimit = Min(l, len);\n\tjlimit = Min(jlimit, 8);\t/* prevent buffer overrun */\n\n\tfor (j = 0; j < jlimit; j++)\n\t{\n\t\tp += sprintf(p, \"0x%02x\", (unsigned char) mbstr[j]);\n\t\tif (j < jlimit - 1)\n\t\t\tp += sprintf(p, \" \");\n\t}\n\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_CHARACTER_NOT_IN_REPERTOIRE),\n\t\t\t errmsg(\"invalid byte sequence for encoding \\\"%s\\\": %s\",\n\t\t\t\t\tpg_enc2name_tbl[encoding].name,\n\t\t\t\t\tbuf)));\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nvoid\nreport_invalid_encoding(int encoding, const char *mbstr, int len)\n{\n\tint\t\t\tl = pg_encoding_mblen(encoding, mbstr);\n\tchar\t\tbuf[8 * 5 + 1];\n\tchar\t   *p = buf;\n\tint\t\t\tj,\n\t\t\t\tjlimit;\n\n\tjlimit = Min(l, len);\n\tjlimit = Min(jlimit, 8);\t/* prevent buffer overrun */\n\n\tfor (j = 0; j < jlimit; j++)\n\t{\n\t\tp += sprintf(p, \"0x%02x\", (unsigned char) mbstr[j]);\n\t\tif (j < jlimit - 1)\n\t\t\tp += sprintf(p, \" \");\n\t}\n\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_CHARACTER_NOT_IN_REPERTOIRE),\n\t\t\t errmsg(\"invalid byte sequence for encoding \\\"%s\\\": %s\",\n\t\t\t\t\tpg_enc2name_tbl[encoding].name,\n\t\t\t\t\tbuf)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHECK_ENCODING_CONVERSION_ARGS",
          "args": [
            "PG_LATIN1",
            "PG_UTF8"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "4"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CSTRING",
          "args": [
            "3"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CSTRING",
          "args": [
            "2"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"fmgr.h\"\n#include \"postgres.h\"\n\nDatum\niso8859_1_to_utf8(PG_FUNCTION_ARGS)\n{\n\tunsigned char *src = (unsigned char *) PG_GETARG_CSTRING(2);\n\tunsigned char *dest = (unsigned char *) PG_GETARG_CSTRING(3);\n\tint\t\t\tlen = PG_GETARG_INT32(4);\n\tunsigned short c;\n\n\tCHECK_ENCODING_CONVERSION_ARGS(PG_LATIN1, PG_UTF8);\n\n\twhile (len > 0)\n\t{\n\t\tc = *src;\n\t\tif (c == 0)\n\t\t\treport_invalid_encoding(PG_LATIN1, (const char *) src, len);\n\t\tif (!IS_HIGHBIT_SET(c))\n\t\t\t*dest++ = c;\n\t\telse\n\t\t{\n\t\t\t*dest++ = (c >> 6) | 0xc0;\n\t\t\t*dest++ = (c & 0x003f) | HIGHBIT;\n\t\t}\n\t\tsrc++;\n\t\tlen--;\n\t}\n\t*dest = '\\0';\n\n\tPG_RETURN_VOID();\n}"
  }
]