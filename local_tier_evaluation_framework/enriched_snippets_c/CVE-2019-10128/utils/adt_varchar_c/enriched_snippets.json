[
  {
    "function_name": "btbpchar_pattern_sortsupport",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
    "lines": "1079-1093",
    "snippet": "Datum\nbtbpchar_pattern_sortsupport(PG_FUNCTION_ARGS)\n{\n\tSortSupport ssup = (SortSupport) PG_GETARG_POINTER(0);\n\tMemoryContext oldcontext;\n\n\toldcontext = MemoryContextSwitchTo(ssup->ssup_cxt);\n\n\t/* Use generic string SortSupport, forcing \"C\" collation */\n\tvarstr_sortsupport(ssup, C_COLLATION_OID, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\tPG_RETURN_VOID();\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VOID",
          "args": [],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "varstr_sortsupport",
          "args": [
            "ssup",
            "C_COLLATION_OID",
            "true"
          ],
          "line": 1088
        },
        "resolved": true,
        "details": {
          "function_name": "varstr_sortsupport",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "1834-1985",
          "snippet": "void\nvarstr_sortsupport(SortSupport ssup, Oid collid, bool bpchar)\n{\n\tbool\t\tabbreviate = ssup->abbreviate;\n\tbool\t\tcollate_c = false;\n\tVarStringSortSupport *sss;\n\tpg_locale_t locale = 0;\n\n\t/*\n\t * If possible, set ssup->comparator to a function which can be used to\n\t * directly compare two datums.  If we can do this, we'll avoid the\n\t * overhead of a trip through the fmgr layer for every comparison, which\n\t * can be substantial.\n\t *\n\t * Most typically, we'll set the comparator to varstrfastcmp_locale, which\n\t * uses strcoll() to perform comparisons and knows about the special\n\t * requirements of BpChar callers.  However, if LC_COLLATE = C, we can\n\t * make things quite a bit faster with varstrfastcmp_c or bpcharfastcmp_c,\n\t * both of which use memcmp() rather than strcoll().\n\t */\n\tif (lc_collate_is_c(collid))\n\t{\n\t\tif (!bpchar)\n\t\t\tssup->comparator = varstrfastcmp_c;\n\t\telse\n\t\t\tssup->comparator = bpcharfastcmp_c;\n\n\t\tcollate_c = true;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * We need a collation-sensitive comparison.  To make things faster,\n\t\t * we'll figure out the collation based on the locale id and cache the\n\t\t * result.\n\t\t */\n\t\tif (collid != DEFAULT_COLLATION_OID)\n\t\t{\n\t\t\tif (!OidIsValid(collid))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This typically means that the parser could not resolve a\n\t\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t\t errmsg(\"could not determine which collation to use for string comparison\"),\n\t\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t\t}\n\t\t\tlocale = pg_newlocale_from_collation(collid);\n\t\t}\n\n\t\t/*\n\t\t * There is a further exception on Windows.  When the database\n\t\t * encoding is UTF-8 and we are not using the C collation, complex\n\t\t * hacks are required.  We don't currently have a comparator that\n\t\t * handles that case, so we fall back on the slow method of having the\n\t\t * sort code invoke bttextcmp() (in the case of text) via the fmgr\n\t\t * trampoline.  ICU locales work just the same on Windows, however.\n\t\t */\n#ifdef WIN32\n\t\tif (GetDatabaseEncoding() == PG_UTF8 &&\n\t\t\t!(locale && locale->provider == COLLPROVIDER_ICU))\n\t\t\treturn;\n#endif\n\n\t\tssup->comparator = varstrfastcmp_locale;\n\t}\n\n\t/*\n\t * Unfortunately, it seems that abbreviation for non-C collations is\n\t * broken on many common platforms; testing of multiple versions of glibc\n\t * reveals that, for many locales, strcoll() and strxfrm() do not return\n\t * consistent results, which is fatal to this optimization.  While no\n\t * other libc other than Cygwin has so far been shown to have a problem,\n\t * we take the conservative course of action for right now and disable\n\t * this categorically.  (Users who are certain this isn't a problem on\n\t * their system can define TRUST_STRXFRM.)\n\t *\n\t * Even apart from the risk of broken locales, it's possible that there\n\t * are platforms where the use of abbreviated keys should be disabled at\n\t * compile time.  Having only 4 byte datums could make worst-case\n\t * performance drastically more likely, for example.  Moreover, macOS's\n\t * strxfrm() implementation is known to not effectively concentrate a\n\t * significant amount of entropy from the original string in earlier\n\t * transformed blobs.  It's possible that other supported platforms are\n\t * similarly encumbered.  So, if we ever get past disabling this\n\t * categorically, we may still want or need to disable it for particular\n\t * platforms.\n\t */\n#ifndef TRUST_STRXFRM\n\tif (!collate_c && !(locale && locale->provider == COLLPROVIDER_ICU))\n\t\tabbreviate = false;\n#endif\n\n\t/*\n\t * If we're using abbreviated keys, or if we're using a locale-aware\n\t * comparison, we need to initialize a StringSortSupport object.  Both\n\t * cases will make use of the temporary buffers we initialize here for\n\t * scratch space (and to detect requirement for BpChar semantics from\n\t * caller), and the abbreviation case requires additional state.\n\t */\n\tif (abbreviate || !collate_c)\n\t{\n\t\tsss = palloc(sizeof(VarStringSortSupport));\n\t\tsss->buf1 = palloc(TEXTBUFLEN);\n\t\tsss->buflen1 = TEXTBUFLEN;\n\t\tsss->buf2 = palloc(TEXTBUFLEN);\n\t\tsss->buflen2 = TEXTBUFLEN;\n\t\t/* Start with invalid values */\n\t\tsss->last_len1 = -1;\n\t\tsss->last_len2 = -1;\n\t\t/* Initialize */\n\t\tsss->last_returned = 0;\n\t\tsss->locale = locale;\n\n\t\t/*\n\t\t * To avoid somehow confusing a strxfrm() blob and an original string,\n\t\t * constantly keep track of the variety of data that buf1 and buf2\n\t\t * currently contain.\n\t\t *\n\t\t * Comparisons may be interleaved with conversion calls.  Frequently,\n\t\t * conversions and comparisons are batched into two distinct phases,\n\t\t * but the correctness of caching cannot hinge upon this.  For\n\t\t * comparison caching, buffer state is only trusted if cache_blob is\n\t\t * found set to false, whereas strxfrm() caching only trusts the state\n\t\t * when cache_blob is found set to true.\n\t\t *\n\t\t * Arbitrarily initialize cache_blob to true.\n\t\t */\n\t\tsss->cache_blob = true;\n\t\tsss->collate_c = collate_c;\n\t\tsss->bpchar = bpchar;\n\t\tssup->ssup_extra = sss;\n\n\t\t/*\n\t\t * If possible, plan to use the abbreviated keys optimization.  The\n\t\t * core code may switch back to authoritative comparator should\n\t\t * abbreviation be aborted.\n\t\t */\n\t\tif (abbreviate)\n\t\t{\n\t\t\tsss->prop_card = 0.20;\n\t\t\tinitHyperLogLog(&sss->abbr_card, 10);\n\t\t\tinitHyperLogLog(&sss->full_card, 10);\n\t\t\tssup->abbrev_full_comparator = ssup->comparator;\n\t\t\tssup->comparator = varstrcmp_abbrev;\n\t\t\tssup->abbrev_converter = varstr_abbrev_convert;\n\t\t\tssup->abbrev_abort = varstr_abbrev_abort;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TEXTBUFLEN\t\t1024"
          ],
          "globals_used": [
            "static int\tvarstrfastcmp_c(Datum x, Datum y, SortSupport ssup);",
            "static int\tbpcharfastcmp_c(Datum x, Datum y, SortSupport ssup);",
            "static int\tvarstrfastcmp_locale(Datum x, Datum y, SortSupport ssup);",
            "static int\tvarstrcmp_abbrev(Datum x, Datum y, SortSupport ssup);",
            "static Datum varstr_abbrev_convert(Datum original, SortSupport ssup);",
            "static bool varstr_abbrev_abort(int memtupcount, SortSupport ssup);",
            "static void text_position_setup(text *t1, text *t2, TextPositionState *state);",
            "static int\ttext_position_next(int start_pos, TextPositionState *state);",
            "static void text_position_cleanup(TextPositionState *state);",
            "static int\ttext_cmp(text *arg1, text *arg2, Oid collid);",
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define TEXTBUFLEN\t\t1024\n\nstatic int\tvarstrfastcmp_c(Datum x, Datum y, SortSupport ssup);\nstatic int\tbpcharfastcmp_c(Datum x, Datum y, SortSupport ssup);\nstatic int\tvarstrfastcmp_locale(Datum x, Datum y, SortSupport ssup);\nstatic int\tvarstrcmp_abbrev(Datum x, Datum y, SortSupport ssup);\nstatic Datum varstr_abbrev_convert(Datum original, SortSupport ssup);\nstatic bool varstr_abbrev_abort(int memtupcount, SortSupport ssup);\nstatic void text_position_setup(text *t1, text *t2, TextPositionState *state);\nstatic int\ttext_position_next(int start_pos, TextPositionState *state);\nstatic void text_position_cleanup(TextPositionState *state);\nstatic int\ttext_cmp(text *arg1, text *arg2, Oid collid);\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nvoid\nvarstr_sortsupport(SortSupport ssup, Oid collid, bool bpchar)\n{\n\tbool\t\tabbreviate = ssup->abbreviate;\n\tbool\t\tcollate_c = false;\n\tVarStringSortSupport *sss;\n\tpg_locale_t locale = 0;\n\n\t/*\n\t * If possible, set ssup->comparator to a function which can be used to\n\t * directly compare two datums.  If we can do this, we'll avoid the\n\t * overhead of a trip through the fmgr layer for every comparison, which\n\t * can be substantial.\n\t *\n\t * Most typically, we'll set the comparator to varstrfastcmp_locale, which\n\t * uses strcoll() to perform comparisons and knows about the special\n\t * requirements of BpChar callers.  However, if LC_COLLATE = C, we can\n\t * make things quite a bit faster with varstrfastcmp_c or bpcharfastcmp_c,\n\t * both of which use memcmp() rather than strcoll().\n\t */\n\tif (lc_collate_is_c(collid))\n\t{\n\t\tif (!bpchar)\n\t\t\tssup->comparator = varstrfastcmp_c;\n\t\telse\n\t\t\tssup->comparator = bpcharfastcmp_c;\n\n\t\tcollate_c = true;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * We need a collation-sensitive comparison.  To make things faster,\n\t\t * we'll figure out the collation based on the locale id and cache the\n\t\t * result.\n\t\t */\n\t\tif (collid != DEFAULT_COLLATION_OID)\n\t\t{\n\t\t\tif (!OidIsValid(collid))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This typically means that the parser could not resolve a\n\t\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t\t errmsg(\"could not determine which collation to use for string comparison\"),\n\t\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t\t}\n\t\t\tlocale = pg_newlocale_from_collation(collid);\n\t\t}\n\n\t\t/*\n\t\t * There is a further exception on Windows.  When the database\n\t\t * encoding is UTF-8 and we are not using the C collation, complex\n\t\t * hacks are required.  We don't currently have a comparator that\n\t\t * handles that case, so we fall back on the slow method of having the\n\t\t * sort code invoke bttextcmp() (in the case of text) via the fmgr\n\t\t * trampoline.  ICU locales work just the same on Windows, however.\n\t\t */\n#ifdef WIN32\n\t\tif (GetDatabaseEncoding() == PG_UTF8 &&\n\t\t\t!(locale && locale->provider == COLLPROVIDER_ICU))\n\t\t\treturn;\n#endif\n\n\t\tssup->comparator = varstrfastcmp_locale;\n\t}\n\n\t/*\n\t * Unfortunately, it seems that abbreviation for non-C collations is\n\t * broken on many common platforms; testing of multiple versions of glibc\n\t * reveals that, for many locales, strcoll() and strxfrm() do not return\n\t * consistent results, which is fatal to this optimization.  While no\n\t * other libc other than Cygwin has so far been shown to have a problem,\n\t * we take the conservative course of action for right now and disable\n\t * this categorically.  (Users who are certain this isn't a problem on\n\t * their system can define TRUST_STRXFRM.)\n\t *\n\t * Even apart from the risk of broken locales, it's possible that there\n\t * are platforms where the use of abbreviated keys should be disabled at\n\t * compile time.  Having only 4 byte datums could make worst-case\n\t * performance drastically more likely, for example.  Moreover, macOS's\n\t * strxfrm() implementation is known to not effectively concentrate a\n\t * significant amount of entropy from the original string in earlier\n\t * transformed blobs.  It's possible that other supported platforms are\n\t * similarly encumbered.  So, if we ever get past disabling this\n\t * categorically, we may still want or need to disable it for particular\n\t * platforms.\n\t */\n#ifndef TRUST_STRXFRM\n\tif (!collate_c && !(locale && locale->provider == COLLPROVIDER_ICU))\n\t\tabbreviate = false;\n#endif\n\n\t/*\n\t * If we're using abbreviated keys, or if we're using a locale-aware\n\t * comparison, we need to initialize a StringSortSupport object.  Both\n\t * cases will make use of the temporary buffers we initialize here for\n\t * scratch space (and to detect requirement for BpChar semantics from\n\t * caller), and the abbreviation case requires additional state.\n\t */\n\tif (abbreviate || !collate_c)\n\t{\n\t\tsss = palloc(sizeof(VarStringSortSupport));\n\t\tsss->buf1 = palloc(TEXTBUFLEN);\n\t\tsss->buflen1 = TEXTBUFLEN;\n\t\tsss->buf2 = palloc(TEXTBUFLEN);\n\t\tsss->buflen2 = TEXTBUFLEN;\n\t\t/* Start with invalid values */\n\t\tsss->last_len1 = -1;\n\t\tsss->last_len2 = -1;\n\t\t/* Initialize */\n\t\tsss->last_returned = 0;\n\t\tsss->locale = locale;\n\n\t\t/*\n\t\t * To avoid somehow confusing a strxfrm() blob and an original string,\n\t\t * constantly keep track of the variety of data that buf1 and buf2\n\t\t * currently contain.\n\t\t *\n\t\t * Comparisons may be interleaved with conversion calls.  Frequently,\n\t\t * conversions and comparisons are batched into two distinct phases,\n\t\t * but the correctness of caching cannot hinge upon this.  For\n\t\t * comparison caching, buffer state is only trusted if cache_blob is\n\t\t * found set to false, whereas strxfrm() caching only trusts the state\n\t\t * when cache_blob is found set to true.\n\t\t *\n\t\t * Arbitrarily initialize cache_blob to true.\n\t\t */\n\t\tsss->cache_blob = true;\n\t\tsss->collate_c = collate_c;\n\t\tsss->bpchar = bpchar;\n\t\tssup->ssup_extra = sss;\n\n\t\t/*\n\t\t * If possible, plan to use the abbreviated keys optimization.  The\n\t\t * core code may switch back to authoritative comparator should\n\t\t * abbreviation be aborted.\n\t\t */\n\t\tif (abbreviate)\n\t\t{\n\t\t\tsss->prop_card = 0.20;\n\t\t\tinitHyperLogLog(&sss->abbr_card, 10);\n\t\t\tinitHyperLogLog(&sss->full_card, 10);\n\t\t\tssup->abbrev_full_comparator = ssup->comparator;\n\t\t\tssup->comparator = varstrcmp_abbrev;\n\t\t\tssup->abbrev_converter = varstr_abbrev_convert;\n\t\t\tssup->abbrev_abort = varstr_abbrev_abort;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "ssup->ssup_cxt"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nbtbpchar_pattern_sortsupport(PG_FUNCTION_ARGS)\n{\n\tSortSupport ssup = (SortSupport) PG_GETARG_POINTER(0);\n\tMemoryContext oldcontext;\n\n\toldcontext = MemoryContextSwitchTo(ssup->ssup_cxt);\n\n\t/* Use generic string SortSupport, forcing \"C\" collation */\n\tvarstr_sortsupport(ssup, C_COLLATION_OID, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\tPG_RETURN_VOID();\n}"
  },
  {
    "function_name": "btbpchar_pattern_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
    "lines": "1063-1076",
    "snippet": "Datum\nbtbpchar_pattern_cmp(PG_FUNCTION_ARGS)\n{\n\tBpChar\t   *arg1 = PG_GETARG_BPCHAR_PP(0);\n\tBpChar\t   *arg2 = PG_GETARG_BPCHAR_PP(1);\n\tint\t\t\tresult;\n\n\tresult = internal_bpchar_pattern_compare(arg1, arg2);\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_INT32(result);\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "result"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg2",
            "1"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg1",
            "0"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "internal_bpchar_pattern_compare",
          "args": [
            "arg1",
            "arg2"
          ],
          "line": 1070
        },
        "resolved": true,
        "details": {
          "function_name": "internal_bpchar_pattern_compare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
          "lines": "977-996",
          "snippet": "static int\ninternal_bpchar_pattern_compare(BpChar *arg1, BpChar *arg2)\n{\n\tint\t\t\tresult;\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\n\tlen1 = bcTruelen(arg1);\n\tlen2 = bcTruelen(arg2);\n\n\tresult = memcmp(VARDATA_ANY(arg1), VARDATA_ANY(arg2), Min(len1, len2));\n\tif (result != 0)\n\t\treturn result;\n\telse if (len1 < len2)\n\t\treturn -1;\n\telse if (len1 > len2)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic int\ninternal_bpchar_pattern_compare(BpChar *arg1, BpChar *arg2)\n{\n\tint\t\t\tresult;\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\n\tlen1 = bcTruelen(arg1);\n\tlen2 = bcTruelen(arg2);\n\n\tresult = memcmp(VARDATA_ANY(arg1), VARDATA_ANY(arg2), Min(len1, len2));\n\tif (result != 0)\n\t\treturn result;\n\telse if (len1 < len2)\n\t\treturn -1;\n\telse if (len1 > len2)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BPCHAR_PP",
          "args": [
            "1"
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BPCHAR_PP",
          "args": [
            "0"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nbtbpchar_pattern_cmp(PG_FUNCTION_ARGS)\n{\n\tBpChar\t   *arg1 = PG_GETARG_BPCHAR_PP(0);\n\tBpChar\t   *arg2 = PG_GETARG_BPCHAR_PP(1);\n\tint\t\t\tresult;\n\n\tresult = internal_bpchar_pattern_compare(arg1, arg2);\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_INT32(result);\n}"
  },
  {
    "function_name": "bpchar_pattern_gt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
    "lines": "1047-1060",
    "snippet": "Datum\nbpchar_pattern_gt(PG_FUNCTION_ARGS)\n{\n\tBpChar\t   *arg1 = PG_GETARG_BPCHAR_PP(0);\n\tBpChar\t   *arg2 = PG_GETARG_BPCHAR_PP(1);\n\tint\t\t\tresult;\n\n\tresult = internal_bpchar_pattern_compare(arg1, arg2);\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_BOOL(result > 0);\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "result > 0"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg2",
            "1"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg1",
            "0"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "internal_bpchar_pattern_compare",
          "args": [
            "arg1",
            "arg2"
          ],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "internal_bpchar_pattern_compare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
          "lines": "977-996",
          "snippet": "static int\ninternal_bpchar_pattern_compare(BpChar *arg1, BpChar *arg2)\n{\n\tint\t\t\tresult;\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\n\tlen1 = bcTruelen(arg1);\n\tlen2 = bcTruelen(arg2);\n\n\tresult = memcmp(VARDATA_ANY(arg1), VARDATA_ANY(arg2), Min(len1, len2));\n\tif (result != 0)\n\t\treturn result;\n\telse if (len1 < len2)\n\t\treturn -1;\n\telse if (len1 > len2)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic int\ninternal_bpchar_pattern_compare(BpChar *arg1, BpChar *arg2)\n{\n\tint\t\t\tresult;\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\n\tlen1 = bcTruelen(arg1);\n\tlen2 = bcTruelen(arg2);\n\n\tresult = memcmp(VARDATA_ANY(arg1), VARDATA_ANY(arg2), Min(len1, len2));\n\tif (result != 0)\n\t\treturn result;\n\telse if (len1 < len2)\n\t\treturn -1;\n\telse if (len1 > len2)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BPCHAR_PP",
          "args": [
            "1"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BPCHAR_PP",
          "args": [
            "0"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nbpchar_pattern_gt(PG_FUNCTION_ARGS)\n{\n\tBpChar\t   *arg1 = PG_GETARG_BPCHAR_PP(0);\n\tBpChar\t   *arg2 = PG_GETARG_BPCHAR_PP(1);\n\tint\t\t\tresult;\n\n\tresult = internal_bpchar_pattern_compare(arg1, arg2);\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_BOOL(result > 0);\n}"
  },
  {
    "function_name": "bpchar_pattern_ge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
    "lines": "1031-1044",
    "snippet": "Datum\nbpchar_pattern_ge(PG_FUNCTION_ARGS)\n{\n\tBpChar\t   *arg1 = PG_GETARG_BPCHAR_PP(0);\n\tBpChar\t   *arg2 = PG_GETARG_BPCHAR_PP(1);\n\tint\t\t\tresult;\n\n\tresult = internal_bpchar_pattern_compare(arg1, arg2);\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_BOOL(result >= 0);\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "result >= 0"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg2",
            "1"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg1",
            "0"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "internal_bpchar_pattern_compare",
          "args": [
            "arg1",
            "arg2"
          ],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "internal_bpchar_pattern_compare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
          "lines": "977-996",
          "snippet": "static int\ninternal_bpchar_pattern_compare(BpChar *arg1, BpChar *arg2)\n{\n\tint\t\t\tresult;\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\n\tlen1 = bcTruelen(arg1);\n\tlen2 = bcTruelen(arg2);\n\n\tresult = memcmp(VARDATA_ANY(arg1), VARDATA_ANY(arg2), Min(len1, len2));\n\tif (result != 0)\n\t\treturn result;\n\telse if (len1 < len2)\n\t\treturn -1;\n\telse if (len1 > len2)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic int\ninternal_bpchar_pattern_compare(BpChar *arg1, BpChar *arg2)\n{\n\tint\t\t\tresult;\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\n\tlen1 = bcTruelen(arg1);\n\tlen2 = bcTruelen(arg2);\n\n\tresult = memcmp(VARDATA_ANY(arg1), VARDATA_ANY(arg2), Min(len1, len2));\n\tif (result != 0)\n\t\treturn result;\n\telse if (len1 < len2)\n\t\treturn -1;\n\telse if (len1 > len2)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BPCHAR_PP",
          "args": [
            "1"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BPCHAR_PP",
          "args": [
            "0"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nbpchar_pattern_ge(PG_FUNCTION_ARGS)\n{\n\tBpChar\t   *arg1 = PG_GETARG_BPCHAR_PP(0);\n\tBpChar\t   *arg2 = PG_GETARG_BPCHAR_PP(1);\n\tint\t\t\tresult;\n\n\tresult = internal_bpchar_pattern_compare(arg1, arg2);\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_BOOL(result >= 0);\n}"
  },
  {
    "function_name": "bpchar_pattern_le",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
    "lines": "1015-1028",
    "snippet": "Datum\nbpchar_pattern_le(PG_FUNCTION_ARGS)\n{\n\tBpChar\t   *arg1 = PG_GETARG_BPCHAR_PP(0);\n\tBpChar\t   *arg2 = PG_GETARG_BPCHAR_PP(1);\n\tint\t\t\tresult;\n\n\tresult = internal_bpchar_pattern_compare(arg1, arg2);\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_BOOL(result <= 0);\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "result <= 0"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg2",
            "1"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg1",
            "0"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "internal_bpchar_pattern_compare",
          "args": [
            "arg1",
            "arg2"
          ],
          "line": 1022
        },
        "resolved": true,
        "details": {
          "function_name": "internal_bpchar_pattern_compare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
          "lines": "977-996",
          "snippet": "static int\ninternal_bpchar_pattern_compare(BpChar *arg1, BpChar *arg2)\n{\n\tint\t\t\tresult;\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\n\tlen1 = bcTruelen(arg1);\n\tlen2 = bcTruelen(arg2);\n\n\tresult = memcmp(VARDATA_ANY(arg1), VARDATA_ANY(arg2), Min(len1, len2));\n\tif (result != 0)\n\t\treturn result;\n\telse if (len1 < len2)\n\t\treturn -1;\n\telse if (len1 > len2)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic int\ninternal_bpchar_pattern_compare(BpChar *arg1, BpChar *arg2)\n{\n\tint\t\t\tresult;\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\n\tlen1 = bcTruelen(arg1);\n\tlen2 = bcTruelen(arg2);\n\n\tresult = memcmp(VARDATA_ANY(arg1), VARDATA_ANY(arg2), Min(len1, len2));\n\tif (result != 0)\n\t\treturn result;\n\telse if (len1 < len2)\n\t\treturn -1;\n\telse if (len1 > len2)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BPCHAR_PP",
          "args": [
            "1"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BPCHAR_PP",
          "args": [
            "0"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nbpchar_pattern_le(PG_FUNCTION_ARGS)\n{\n\tBpChar\t   *arg1 = PG_GETARG_BPCHAR_PP(0);\n\tBpChar\t   *arg2 = PG_GETARG_BPCHAR_PP(1);\n\tint\t\t\tresult;\n\n\tresult = internal_bpchar_pattern_compare(arg1, arg2);\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_BOOL(result <= 0);\n}"
  },
  {
    "function_name": "bpchar_pattern_lt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
    "lines": "999-1012",
    "snippet": "Datum\nbpchar_pattern_lt(PG_FUNCTION_ARGS)\n{\n\tBpChar\t   *arg1 = PG_GETARG_BPCHAR_PP(0);\n\tBpChar\t   *arg2 = PG_GETARG_BPCHAR_PP(1);\n\tint\t\t\tresult;\n\n\tresult = internal_bpchar_pattern_compare(arg1, arg2);\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_BOOL(result < 0);\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "result < 0"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg2",
            "1"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg1",
            "0"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "internal_bpchar_pattern_compare",
          "args": [
            "arg1",
            "arg2"
          ],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "internal_bpchar_pattern_compare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
          "lines": "977-996",
          "snippet": "static int\ninternal_bpchar_pattern_compare(BpChar *arg1, BpChar *arg2)\n{\n\tint\t\t\tresult;\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\n\tlen1 = bcTruelen(arg1);\n\tlen2 = bcTruelen(arg2);\n\n\tresult = memcmp(VARDATA_ANY(arg1), VARDATA_ANY(arg2), Min(len1, len2));\n\tif (result != 0)\n\t\treturn result;\n\telse if (len1 < len2)\n\t\treturn -1;\n\telse if (len1 > len2)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic int\ninternal_bpchar_pattern_compare(BpChar *arg1, BpChar *arg2)\n{\n\tint\t\t\tresult;\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\n\tlen1 = bcTruelen(arg1);\n\tlen2 = bcTruelen(arg2);\n\n\tresult = memcmp(VARDATA_ANY(arg1), VARDATA_ANY(arg2), Min(len1, len2));\n\tif (result != 0)\n\t\treturn result;\n\telse if (len1 < len2)\n\t\treturn -1;\n\telse if (len1 > len2)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BPCHAR_PP",
          "args": [
            "1"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BPCHAR_PP",
          "args": [
            "0"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nbpchar_pattern_lt(PG_FUNCTION_ARGS)\n{\n\tBpChar\t   *arg1 = PG_GETARG_BPCHAR_PP(0);\n\tBpChar\t   *arg2 = PG_GETARG_BPCHAR_PP(1);\n\tint\t\t\tresult;\n\n\tresult = internal_bpchar_pattern_compare(arg1, arg2);\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_BOOL(result < 0);\n}"
  },
  {
    "function_name": "internal_bpchar_pattern_compare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
    "lines": "977-996",
    "snippet": "static int\ninternal_bpchar_pattern_compare(BpChar *arg1, BpChar *arg2)\n{\n\tint\t\t\tresult;\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\n\tlen1 = bcTruelen(arg1);\n\tlen2 = bcTruelen(arg2);\n\n\tresult = memcmp(VARDATA_ANY(arg1), VARDATA_ANY(arg2), Min(len1, len2));\n\tif (result != 0)\n\t\treturn result;\n\telse if (len1 < len2)\n\t\treturn -1;\n\telse if (len1 > len2)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "VARDATA_ANY(arg1)",
            "VARDATA_ANY(arg2)",
            "Min(len1, len2)"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "len1",
            "len2"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "arg2"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "arg1"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcTruelen",
          "args": [
            "arg2"
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "bcTruelen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
          "lines": "653-657",
          "snippet": "static inline int\nbcTruelen(BpChar *arg)\n{\n\treturn bpchartruelen(VARDATA_ANY(arg), VARSIZE_ANY_EXHDR(arg));\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic inline int\nbcTruelen(BpChar *arg)\n{\n\treturn bpchartruelen(VARDATA_ANY(arg), VARSIZE_ANY_EXHDR(arg));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic int\ninternal_bpchar_pattern_compare(BpChar *arg1, BpChar *arg2)\n{\n\tint\t\t\tresult;\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\n\tlen1 = bcTruelen(arg1);\n\tlen2 = bcTruelen(arg2);\n\n\tresult = memcmp(VARDATA_ANY(arg1), VARDATA_ANY(arg2), Min(len1, len2));\n\tif (result != 0)\n\t\treturn result;\n\telse if (len1 < len2)\n\t\treturn -1;\n\telse if (len1 > len2)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}"
  },
  {
    "function_name": "hashbpcharextended",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
    "lines": "950-967",
    "snippet": "Datum\nhashbpcharextended(PG_FUNCTION_ARGS)\n{\n\tBpChar\t   *key = PG_GETARG_BPCHAR_PP(0);\n\tchar\t   *keydata;\n\tint\t\t\tkeylen;\n\tDatum\t\tresult;\n\n\tkeydata = VARDATA_ANY(key);\n\tkeylen = bcTruelen(key);\n\n\tresult = hash_any_extended((unsigned char *) keydata, keylen,\n\t\t\t\t\t\t\t   PG_GETARG_INT64(1));\n\n\tPG_FREE_IF_COPY(key, 0);\n\n\treturn result;\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "key",
            "0"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_any_extended",
          "args": [
            "(unsigned char *) keydata",
            "keylen",
            "PG_GETARG_INT64(1)"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT64",
          "args": [
            "1"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcTruelen",
          "args": [
            "key"
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "bcTruelen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
          "lines": "653-657",
          "snippet": "static inline int\nbcTruelen(BpChar *arg)\n{\n\treturn bpchartruelen(VARDATA_ANY(arg), VARSIZE_ANY_EXHDR(arg));\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic inline int\nbcTruelen(BpChar *arg)\n{\n\treturn bpchartruelen(VARDATA_ANY(arg), VARSIZE_ANY_EXHDR(arg));\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "key"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BPCHAR_PP",
          "args": [
            "0"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nhashbpcharextended(PG_FUNCTION_ARGS)\n{\n\tBpChar\t   *key = PG_GETARG_BPCHAR_PP(0);\n\tchar\t   *keydata;\n\tint\t\t\tkeylen;\n\tDatum\t\tresult;\n\n\tkeydata = VARDATA_ANY(key);\n\tkeylen = bcTruelen(key);\n\n\tresult = hash_any_extended((unsigned char *) keydata, keylen,\n\t\t\t\t\t\t\t   PG_GETARG_INT64(1));\n\n\tPG_FREE_IF_COPY(key, 0);\n\n\treturn result;\n}"
  },
  {
    "function_name": "hashbpchar",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
    "lines": "931-948",
    "snippet": "Datum\nhashbpchar(PG_FUNCTION_ARGS)\n{\n\tBpChar\t   *key = PG_GETARG_BPCHAR_PP(0);\n\tchar\t   *keydata;\n\tint\t\t\tkeylen;\n\tDatum\t\tresult;\n\n\tkeydata = VARDATA_ANY(key);\n\tkeylen = bcTruelen(key);\n\n\tresult = hash_any((unsigned char *) keydata, keylen);\n\n\t/* Avoid leaking memory for toasted inputs */\n\tPG_FREE_IF_COPY(key, 0);\n\n\treturn result;\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "key",
            "0"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_any",
          "args": [
            "(unsigned char *) keydata",
            "keylen"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcTruelen",
          "args": [
            "key"
          ],
          "line": 940
        },
        "resolved": true,
        "details": {
          "function_name": "bcTruelen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
          "lines": "653-657",
          "snippet": "static inline int\nbcTruelen(BpChar *arg)\n{\n\treturn bpchartruelen(VARDATA_ANY(arg), VARSIZE_ANY_EXHDR(arg));\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic inline int\nbcTruelen(BpChar *arg)\n{\n\treturn bpchartruelen(VARDATA_ANY(arg), VARSIZE_ANY_EXHDR(arg));\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "key"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BPCHAR_PP",
          "args": [
            "0"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nhashbpchar(PG_FUNCTION_ARGS)\n{\n\tBpChar\t   *key = PG_GETARG_BPCHAR_PP(0);\n\tchar\t   *keydata;\n\tint\t\t\tkeylen;\n\tDatum\t\tresult;\n\n\tkeydata = VARDATA_ANY(key);\n\tkeylen = bcTruelen(key);\n\n\tresult = hash_any((unsigned char *) keydata, keylen);\n\n\t/* Avoid leaking memory for toasted inputs */\n\tPG_FREE_IF_COPY(key, 0);\n\n\treturn result;\n}"
  },
  {
    "function_name": "bpchar_smaller",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
    "lines": "904-920",
    "snippet": "Datum\nbpchar_smaller(PG_FUNCTION_ARGS)\n{\n\tBpChar\t   *arg1 = PG_GETARG_BPCHAR_PP(0);\n\tBpChar\t   *arg2 = PG_GETARG_BPCHAR_PP(1);\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\tint\t\t\tcmp;\n\n\tlen1 = bcTruelen(arg1);\n\tlen2 = bcTruelen(arg2);\n\n\tcmp = varstr_cmp(VARDATA_ANY(arg1), len1, VARDATA_ANY(arg2), len2,\n\t\t\t\t\t PG_GET_COLLATION());\n\n\tPG_RETURN_BPCHAR_P((cmp <= 0) ? arg1 : arg2);\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BPCHAR_P",
          "args": [
            "(cmp <= 0) ? arg1 : arg2"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "varstr_cmp",
          "args": [
            "VARDATA_ANY(arg1)",
            "len1",
            "VARDATA_ANY(arg2)",
            "len2",
            "PG_GET_COLLATION()"
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "varstr_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "1380-1609",
          "snippet": "int\nvarstr_cmp(const char *arg1, int len1, const char *arg2, int len2, Oid collid)\n{\n\tint\t\t\tresult;\n\n\t/*\n\t * Unfortunately, there is no strncoll(), so in the non-C locale case we\n\t * have to do some memory copying.  This turns out to be significantly\n\t * slower, so we optimize the case where LC_COLLATE is C.  We also try to\n\t * optimize relatively-short strings by avoiding palloc/pfree overhead.\n\t */\n\tif (lc_collate_is_c(collid))\n\t{\n\t\tresult = memcmp(arg1, arg2, Min(len1, len2));\n\t\tif ((result == 0) && (len1 != len2))\n\t\t\tresult = (len1 < len2) ? -1 : 1;\n\t}\n\telse\n\t{\n\t\tchar\t\ta1buf[TEXTBUFLEN];\n\t\tchar\t\ta2buf[TEXTBUFLEN];\n\t\tchar\t   *a1p,\n\t\t\t\t   *a2p;\n\t\tpg_locale_t mylocale = 0;\n\n\t\tif (collid != DEFAULT_COLLATION_OID)\n\t\t{\n\t\t\tif (!OidIsValid(collid))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This typically means that the parser could not resolve a\n\t\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t\t errmsg(\"could not determine which collation to use for string comparison\"),\n\t\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t\t}\n\t\t\tmylocale = pg_newlocale_from_collation(collid);\n\t\t}\n\n\t\t/*\n\t\t * memcmp() can't tell us which of two unequal strings sorts first,\n\t\t * but it's a cheap way to tell if they're equal.  Testing shows that\n\t\t * memcmp() followed by strcoll() is only trivially slower than\n\t\t * strcoll() by itself, so we don't lose much if this doesn't work out\n\t\t * very often, and if it does - for example, because there are many\n\t\t * equal strings in the input - then we win big by avoiding expensive\n\t\t * collation-aware comparisons.\n\t\t */\n\t\tif (len1 == len2 && memcmp(arg1, arg2, len1) == 0)\n\t\t\treturn 0;\n\n#ifdef WIN32\n\t\t/* Win32 does not have UTF-8, so we need to map to UTF-16 */\n\t\tif (GetDatabaseEncoding() == PG_UTF8\n\t\t\t&& (!mylocale || mylocale->provider == COLLPROVIDER_LIBC))\n\t\t{\n\t\t\tint\t\t\ta1len;\n\t\t\tint\t\t\ta2len;\n\t\t\tint\t\t\tr;\n\n\t\t\tif (len1 >= TEXTBUFLEN / 2)\n\t\t\t{\n\t\t\t\ta1len = len1 * 2 + 2;\n\t\t\t\ta1p = palloc(a1len);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta1len = TEXTBUFLEN;\n\t\t\t\ta1p = a1buf;\n\t\t\t}\n\t\t\tif (len2 >= TEXTBUFLEN / 2)\n\t\t\t{\n\t\t\t\ta2len = len2 * 2 + 2;\n\t\t\t\ta2p = palloc(a2len);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta2len = TEXTBUFLEN;\n\t\t\t\ta2p = a2buf;\n\t\t\t}\n\n\t\t\t/* stupid Microsloth API does not work for zero-length input */\n\t\t\tif (len1 == 0)\n\t\t\t\tr = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = MultiByteToWideChar(CP_UTF8, 0, arg1, len1,\n\t\t\t\t\t\t\t\t\t\t(LPWSTR) a1p, a1len / 2);\n\t\t\t\tif (!r)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errmsg(\"could not convert string to UTF-16: error code %lu\",\n\t\t\t\t\t\t\t\t\tGetLastError())));\n\t\t\t}\n\t\t\t((LPWSTR) a1p)[r] = 0;\n\n\t\t\tif (len2 == 0)\n\t\t\t\tr = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = MultiByteToWideChar(CP_UTF8, 0, arg2, len2,\n\t\t\t\t\t\t\t\t\t\t(LPWSTR) a2p, a2len / 2);\n\t\t\t\tif (!r)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errmsg(\"could not convert string to UTF-16: error code %lu\",\n\t\t\t\t\t\t\t\t\tGetLastError())));\n\t\t\t}\n\t\t\t((LPWSTR) a2p)[r] = 0;\n\n\t\t\terrno = 0;\n#ifdef HAVE_LOCALE_T\n\t\t\tif (mylocale)\n\t\t\t\tresult = wcscoll_l((LPWSTR) a1p, (LPWSTR) a2p, mylocale->info.lt);\n\t\t\telse\n#endif\n\t\t\t\tresult = wcscoll((LPWSTR) a1p, (LPWSTR) a2p);\n\t\t\tif (result == 2147483647)\t/* _NLSCMPERROR; missing from mingw\n\t\t\t\t\t\t\t\t\t\t * headers */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errmsg(\"could not compare Unicode strings: %m\")));\n\n\t\t\t/*\n\t\t\t * In some locales wcscoll() can claim that nonidentical strings\n\t\t\t * are equal.  Believing that would be bad news for a number of\n\t\t\t * reasons, so we follow Perl's lead and sort \"equal\" strings\n\t\t\t * according to strcmp (on the UTF-8 representation).\n\t\t\t */\n\t\t\tif (result == 0)\n\t\t\t{\n\t\t\t\tresult = memcmp(arg1, arg2, Min(len1, len2));\n\t\t\t\tif ((result == 0) && (len1 != len2))\n\t\t\t\t\tresult = (len1 < len2) ? -1 : 1;\n\t\t\t}\n\n\t\t\tif (a1p != a1buf)\n\t\t\t\tpfree(a1p);\n\t\t\tif (a2p != a2buf)\n\t\t\t\tpfree(a2p);\n\n\t\t\treturn result;\n\t\t}\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\n\t\tif (len1 >= TEXTBUFLEN)\n\t\t\ta1p = (char *) palloc(len1 + 1);\n\t\telse\n\t\t\ta1p = a1buf;\n\t\tif (len2 >= TEXTBUFLEN)\n\t\t\ta2p = (char *) palloc(len2 + 1);\n\t\telse\n\t\t\ta2p = a2buf;\n\n\t\tmemcpy(a1p, arg1, len1);\n\t\ta1p[len1] = '\\0';\n\t\tmemcpy(a2p, arg2, len2);\n\t\ta2p[len2] = '\\0';\n\n\t\tif (mylocale)\n\t\t{\n\t\t\tif (mylocale->provider == COLLPROVIDER_ICU)\n\t\t\t{\n#ifdef USE_ICU\n#ifdef HAVE_UCOL_STRCOLLUTF8\n\t\t\t\tif (GetDatabaseEncoding() == PG_UTF8)\n\t\t\t\t{\n\t\t\t\t\tUErrorCode\tstatus;\n\n\t\t\t\t\tstatus = U_ZERO_ERROR;\n\t\t\t\t\tresult = ucol_strcollUTF8(mylocale->info.icu.ucol,\n\t\t\t\t\t\t\t\t\t\t\t  arg1, len1,\n\t\t\t\t\t\t\t\t\t\t\t  arg2, len2,\n\t\t\t\t\t\t\t\t\t\t\t  &status);\n\t\t\t\t\tif (U_FAILURE(status))\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errmsg(\"collation failed: %s\", u_errorName(status))));\n\t\t\t\t}\n\t\t\t\telse\n#endif\n\t\t\t\t{\n\t\t\t\t\tint32_t\t\tulen1,\n\t\t\t\t\t\t\t\tulen2;\n\t\t\t\t\tUChar\t   *uchar1,\n\t\t\t\t\t\t\t   *uchar2;\n\n\t\t\t\t\tulen1 = icu_to_uchar(&uchar1, arg1, len1);\n\t\t\t\t\tulen2 = icu_to_uchar(&uchar2, arg2, len2);\n\n\t\t\t\t\tresult = ucol_strcoll(mylocale->info.icu.ucol,\n\t\t\t\t\t\t\t\t\t\t  uchar1, ulen1,\n\t\t\t\t\t\t\t\t\t\t  uchar2, ulen2);\n\n\t\t\t\t\tpfree(uchar1);\n\t\t\t\t\tpfree(uchar2);\n\t\t\t\t}\n#else\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t\t/* shouldn't happen */\n\t\t\t\telog(ERROR, \"unsupported collprovider: %c\", mylocale->provider);\n#endif\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t}\n\t\t\telse\n\t\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\t\tresult = strcoll_l(a1p, a2p, mylocale->info.lt);\n#else\n\t\t\t\t/* shouldn't happen */\n\t\t\t\telog(ERROR, \"unsupported collprovider: %c\", mylocale->provider);\n#endif\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tresult = strcoll(a1p, a2p);\n\n\t\t/*\n\t\t * In some locales strcoll() can claim that nonidentical strings are\n\t\t * equal.  Believing that would be bad news for a number of reasons,\n\t\t * so we follow Perl's lead and sort \"equal\" strings according to\n\t\t * strcmp().\n\t\t */\n\t\tif (result == 0)\n\t\t\tresult = strcmp(a1p, a2p);\n\n\t\tif (a1p != a1buf)\n\t\t\tpfree(a1p);\n\t\tif (a2p != a2buf)\n\t\t\tpfree(a2p);\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TEXTBUFLEN\t\t1024"
          ],
          "globals_used": [
            "static int\ttext_cmp(text *arg1, text *arg2, Oid collid);",
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define TEXTBUFLEN\t\t1024\n\nstatic int\ttext_cmp(text *arg1, text *arg2, Oid collid);\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nint\nvarstr_cmp(const char *arg1, int len1, const char *arg2, int len2, Oid collid)\n{\n\tint\t\t\tresult;\n\n\t/*\n\t * Unfortunately, there is no strncoll(), so in the non-C locale case we\n\t * have to do some memory copying.  This turns out to be significantly\n\t * slower, so we optimize the case where LC_COLLATE is C.  We also try to\n\t * optimize relatively-short strings by avoiding palloc/pfree overhead.\n\t */\n\tif (lc_collate_is_c(collid))\n\t{\n\t\tresult = memcmp(arg1, arg2, Min(len1, len2));\n\t\tif ((result == 0) && (len1 != len2))\n\t\t\tresult = (len1 < len2) ? -1 : 1;\n\t}\n\telse\n\t{\n\t\tchar\t\ta1buf[TEXTBUFLEN];\n\t\tchar\t\ta2buf[TEXTBUFLEN];\n\t\tchar\t   *a1p,\n\t\t\t\t   *a2p;\n\t\tpg_locale_t mylocale = 0;\n\n\t\tif (collid != DEFAULT_COLLATION_OID)\n\t\t{\n\t\t\tif (!OidIsValid(collid))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This typically means that the parser could not resolve a\n\t\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t\t errmsg(\"could not determine which collation to use for string comparison\"),\n\t\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t\t}\n\t\t\tmylocale = pg_newlocale_from_collation(collid);\n\t\t}\n\n\t\t/*\n\t\t * memcmp() can't tell us which of two unequal strings sorts first,\n\t\t * but it's a cheap way to tell if they're equal.  Testing shows that\n\t\t * memcmp() followed by strcoll() is only trivially slower than\n\t\t * strcoll() by itself, so we don't lose much if this doesn't work out\n\t\t * very often, and if it does - for example, because there are many\n\t\t * equal strings in the input - then we win big by avoiding expensive\n\t\t * collation-aware comparisons.\n\t\t */\n\t\tif (len1 == len2 && memcmp(arg1, arg2, len1) == 0)\n\t\t\treturn 0;\n\n#ifdef WIN32\n\t\t/* Win32 does not have UTF-8, so we need to map to UTF-16 */\n\t\tif (GetDatabaseEncoding() == PG_UTF8\n\t\t\t&& (!mylocale || mylocale->provider == COLLPROVIDER_LIBC))\n\t\t{\n\t\t\tint\t\t\ta1len;\n\t\t\tint\t\t\ta2len;\n\t\t\tint\t\t\tr;\n\n\t\t\tif (len1 >= TEXTBUFLEN / 2)\n\t\t\t{\n\t\t\t\ta1len = len1 * 2 + 2;\n\t\t\t\ta1p = palloc(a1len);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta1len = TEXTBUFLEN;\n\t\t\t\ta1p = a1buf;\n\t\t\t}\n\t\t\tif (len2 >= TEXTBUFLEN / 2)\n\t\t\t{\n\t\t\t\ta2len = len2 * 2 + 2;\n\t\t\t\ta2p = palloc(a2len);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta2len = TEXTBUFLEN;\n\t\t\t\ta2p = a2buf;\n\t\t\t}\n\n\t\t\t/* stupid Microsloth API does not work for zero-length input */\n\t\t\tif (len1 == 0)\n\t\t\t\tr = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = MultiByteToWideChar(CP_UTF8, 0, arg1, len1,\n\t\t\t\t\t\t\t\t\t\t(LPWSTR) a1p, a1len / 2);\n\t\t\t\tif (!r)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errmsg(\"could not convert string to UTF-16: error code %lu\",\n\t\t\t\t\t\t\t\t\tGetLastError())));\n\t\t\t}\n\t\t\t((LPWSTR) a1p)[r] = 0;\n\n\t\t\tif (len2 == 0)\n\t\t\t\tr = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = MultiByteToWideChar(CP_UTF8, 0, arg2, len2,\n\t\t\t\t\t\t\t\t\t\t(LPWSTR) a2p, a2len / 2);\n\t\t\t\tif (!r)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errmsg(\"could not convert string to UTF-16: error code %lu\",\n\t\t\t\t\t\t\t\t\tGetLastError())));\n\t\t\t}\n\t\t\t((LPWSTR) a2p)[r] = 0;\n\n\t\t\terrno = 0;\n#ifdef HAVE_LOCALE_T\n\t\t\tif (mylocale)\n\t\t\t\tresult = wcscoll_l((LPWSTR) a1p, (LPWSTR) a2p, mylocale->info.lt);\n\t\t\telse\n#endif\n\t\t\t\tresult = wcscoll((LPWSTR) a1p, (LPWSTR) a2p);\n\t\t\tif (result == 2147483647)\t/* _NLSCMPERROR; missing from mingw\n\t\t\t\t\t\t\t\t\t\t * headers */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errmsg(\"could not compare Unicode strings: %m\")));\n\n\t\t\t/*\n\t\t\t * In some locales wcscoll() can claim that nonidentical strings\n\t\t\t * are equal.  Believing that would be bad news for a number of\n\t\t\t * reasons, so we follow Perl's lead and sort \"equal\" strings\n\t\t\t * according to strcmp (on the UTF-8 representation).\n\t\t\t */\n\t\t\tif (result == 0)\n\t\t\t{\n\t\t\t\tresult = memcmp(arg1, arg2, Min(len1, len2));\n\t\t\t\tif ((result == 0) && (len1 != len2))\n\t\t\t\t\tresult = (len1 < len2) ? -1 : 1;\n\t\t\t}\n\n\t\t\tif (a1p != a1buf)\n\t\t\t\tpfree(a1p);\n\t\t\tif (a2p != a2buf)\n\t\t\t\tpfree(a2p);\n\n\t\t\treturn result;\n\t\t}\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\n\t\tif (len1 >= TEXTBUFLEN)\n\t\t\ta1p = (char *) palloc(len1 + 1);\n\t\telse\n\t\t\ta1p = a1buf;\n\t\tif (len2 >= TEXTBUFLEN)\n\t\t\ta2p = (char *) palloc(len2 + 1);\n\t\telse\n\t\t\ta2p = a2buf;\n\n\t\tmemcpy(a1p, arg1, len1);\n\t\ta1p[len1] = '\\0';\n\t\tmemcpy(a2p, arg2, len2);\n\t\ta2p[len2] = '\\0';\n\n\t\tif (mylocale)\n\t\t{\n\t\t\tif (mylocale->provider == COLLPROVIDER_ICU)\n\t\t\t{\n#ifdef USE_ICU\n#ifdef HAVE_UCOL_STRCOLLUTF8\n\t\t\t\tif (GetDatabaseEncoding() == PG_UTF8)\n\t\t\t\t{\n\t\t\t\t\tUErrorCode\tstatus;\n\n\t\t\t\t\tstatus = U_ZERO_ERROR;\n\t\t\t\t\tresult = ucol_strcollUTF8(mylocale->info.icu.ucol,\n\t\t\t\t\t\t\t\t\t\t\t  arg1, len1,\n\t\t\t\t\t\t\t\t\t\t\t  arg2, len2,\n\t\t\t\t\t\t\t\t\t\t\t  &status);\n\t\t\t\t\tif (U_FAILURE(status))\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errmsg(\"collation failed: %s\", u_errorName(status))));\n\t\t\t\t}\n\t\t\t\telse\n#endif\n\t\t\t\t{\n\t\t\t\t\tint32_t\t\tulen1,\n\t\t\t\t\t\t\t\tulen2;\n\t\t\t\t\tUChar\t   *uchar1,\n\t\t\t\t\t\t\t   *uchar2;\n\n\t\t\t\t\tulen1 = icu_to_uchar(&uchar1, arg1, len1);\n\t\t\t\t\tulen2 = icu_to_uchar(&uchar2, arg2, len2);\n\n\t\t\t\t\tresult = ucol_strcoll(mylocale->info.icu.ucol,\n\t\t\t\t\t\t\t\t\t\t  uchar1, ulen1,\n\t\t\t\t\t\t\t\t\t\t  uchar2, ulen2);\n\n\t\t\t\t\tpfree(uchar1);\n\t\t\t\t\tpfree(uchar2);\n\t\t\t\t}\n#else\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t\t/* shouldn't happen */\n\t\t\t\telog(ERROR, \"unsupported collprovider: %c\", mylocale->provider);\n#endif\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t}\n\t\t\telse\n\t\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\t\tresult = strcoll_l(a1p, a2p, mylocale->info.lt);\n#else\n\t\t\t\t/* shouldn't happen */\n\t\t\t\telog(ERROR, \"unsupported collprovider: %c\", mylocale->provider);\n#endif\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tresult = strcoll(a1p, a2p);\n\n\t\t/*\n\t\t * In some locales strcoll() can claim that nonidentical strings are\n\t\t * equal.  Believing that would be bad news for a number of reasons,\n\t\t * so we follow Perl's lead and sort \"equal\" strings according to\n\t\t * strcmp().\n\t\t */\n\t\tif (result == 0)\n\t\t\tresult = strcmp(a1p, a2p);\n\n\t\tif (a1p != a1buf)\n\t\t\tpfree(a1p);\n\t\tif (a2p != a2buf)\n\t\t\tpfree(a2p);\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GET_COLLATION",
          "args": [],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "arg2"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "arg1"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcTruelen",
          "args": [
            "arg2"
          ],
          "line": 914
        },
        "resolved": true,
        "details": {
          "function_name": "bcTruelen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
          "lines": "653-657",
          "snippet": "static inline int\nbcTruelen(BpChar *arg)\n{\n\treturn bpchartruelen(VARDATA_ANY(arg), VARSIZE_ANY_EXHDR(arg));\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic inline int\nbcTruelen(BpChar *arg)\n{\n\treturn bpchartruelen(VARDATA_ANY(arg), VARSIZE_ANY_EXHDR(arg));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BPCHAR_PP",
          "args": [
            "1"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BPCHAR_PP",
          "args": [
            "0"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nbpchar_smaller(PG_FUNCTION_ARGS)\n{\n\tBpChar\t   *arg1 = PG_GETARG_BPCHAR_PP(0);\n\tBpChar\t   *arg2 = PG_GETARG_BPCHAR_PP(1);\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\tint\t\t\tcmp;\n\n\tlen1 = bcTruelen(arg1);\n\tlen2 = bcTruelen(arg2);\n\n\tcmp = varstr_cmp(VARDATA_ANY(arg1), len1, VARDATA_ANY(arg2), len2,\n\t\t\t\t\t PG_GET_COLLATION());\n\n\tPG_RETURN_BPCHAR_P((cmp <= 0) ? arg1 : arg2);\n}"
  },
  {
    "function_name": "bpchar_larger",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
    "lines": "886-902",
    "snippet": "Datum\nbpchar_larger(PG_FUNCTION_ARGS)\n{\n\tBpChar\t   *arg1 = PG_GETARG_BPCHAR_PP(0);\n\tBpChar\t   *arg2 = PG_GETARG_BPCHAR_PP(1);\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\tint\t\t\tcmp;\n\n\tlen1 = bcTruelen(arg1);\n\tlen2 = bcTruelen(arg2);\n\n\tcmp = varstr_cmp(VARDATA_ANY(arg1), len1, VARDATA_ANY(arg2), len2,\n\t\t\t\t\t PG_GET_COLLATION());\n\n\tPG_RETURN_BPCHAR_P((cmp >= 0) ? arg1 : arg2);\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BPCHAR_P",
          "args": [
            "(cmp >= 0) ? arg1 : arg2"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "varstr_cmp",
          "args": [
            "VARDATA_ANY(arg1)",
            "len1",
            "VARDATA_ANY(arg2)",
            "len2",
            "PG_GET_COLLATION()"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "varstr_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "1380-1609",
          "snippet": "int\nvarstr_cmp(const char *arg1, int len1, const char *arg2, int len2, Oid collid)\n{\n\tint\t\t\tresult;\n\n\t/*\n\t * Unfortunately, there is no strncoll(), so in the non-C locale case we\n\t * have to do some memory copying.  This turns out to be significantly\n\t * slower, so we optimize the case where LC_COLLATE is C.  We also try to\n\t * optimize relatively-short strings by avoiding palloc/pfree overhead.\n\t */\n\tif (lc_collate_is_c(collid))\n\t{\n\t\tresult = memcmp(arg1, arg2, Min(len1, len2));\n\t\tif ((result == 0) && (len1 != len2))\n\t\t\tresult = (len1 < len2) ? -1 : 1;\n\t}\n\telse\n\t{\n\t\tchar\t\ta1buf[TEXTBUFLEN];\n\t\tchar\t\ta2buf[TEXTBUFLEN];\n\t\tchar\t   *a1p,\n\t\t\t\t   *a2p;\n\t\tpg_locale_t mylocale = 0;\n\n\t\tif (collid != DEFAULT_COLLATION_OID)\n\t\t{\n\t\t\tif (!OidIsValid(collid))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This typically means that the parser could not resolve a\n\t\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t\t errmsg(\"could not determine which collation to use for string comparison\"),\n\t\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t\t}\n\t\t\tmylocale = pg_newlocale_from_collation(collid);\n\t\t}\n\n\t\t/*\n\t\t * memcmp() can't tell us which of two unequal strings sorts first,\n\t\t * but it's a cheap way to tell if they're equal.  Testing shows that\n\t\t * memcmp() followed by strcoll() is only trivially slower than\n\t\t * strcoll() by itself, so we don't lose much if this doesn't work out\n\t\t * very often, and if it does - for example, because there are many\n\t\t * equal strings in the input - then we win big by avoiding expensive\n\t\t * collation-aware comparisons.\n\t\t */\n\t\tif (len1 == len2 && memcmp(arg1, arg2, len1) == 0)\n\t\t\treturn 0;\n\n#ifdef WIN32\n\t\t/* Win32 does not have UTF-8, so we need to map to UTF-16 */\n\t\tif (GetDatabaseEncoding() == PG_UTF8\n\t\t\t&& (!mylocale || mylocale->provider == COLLPROVIDER_LIBC))\n\t\t{\n\t\t\tint\t\t\ta1len;\n\t\t\tint\t\t\ta2len;\n\t\t\tint\t\t\tr;\n\n\t\t\tif (len1 >= TEXTBUFLEN / 2)\n\t\t\t{\n\t\t\t\ta1len = len1 * 2 + 2;\n\t\t\t\ta1p = palloc(a1len);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta1len = TEXTBUFLEN;\n\t\t\t\ta1p = a1buf;\n\t\t\t}\n\t\t\tif (len2 >= TEXTBUFLEN / 2)\n\t\t\t{\n\t\t\t\ta2len = len2 * 2 + 2;\n\t\t\t\ta2p = palloc(a2len);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta2len = TEXTBUFLEN;\n\t\t\t\ta2p = a2buf;\n\t\t\t}\n\n\t\t\t/* stupid Microsloth API does not work for zero-length input */\n\t\t\tif (len1 == 0)\n\t\t\t\tr = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = MultiByteToWideChar(CP_UTF8, 0, arg1, len1,\n\t\t\t\t\t\t\t\t\t\t(LPWSTR) a1p, a1len / 2);\n\t\t\t\tif (!r)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errmsg(\"could not convert string to UTF-16: error code %lu\",\n\t\t\t\t\t\t\t\t\tGetLastError())));\n\t\t\t}\n\t\t\t((LPWSTR) a1p)[r] = 0;\n\n\t\t\tif (len2 == 0)\n\t\t\t\tr = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = MultiByteToWideChar(CP_UTF8, 0, arg2, len2,\n\t\t\t\t\t\t\t\t\t\t(LPWSTR) a2p, a2len / 2);\n\t\t\t\tif (!r)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errmsg(\"could not convert string to UTF-16: error code %lu\",\n\t\t\t\t\t\t\t\t\tGetLastError())));\n\t\t\t}\n\t\t\t((LPWSTR) a2p)[r] = 0;\n\n\t\t\terrno = 0;\n#ifdef HAVE_LOCALE_T\n\t\t\tif (mylocale)\n\t\t\t\tresult = wcscoll_l((LPWSTR) a1p, (LPWSTR) a2p, mylocale->info.lt);\n\t\t\telse\n#endif\n\t\t\t\tresult = wcscoll((LPWSTR) a1p, (LPWSTR) a2p);\n\t\t\tif (result == 2147483647)\t/* _NLSCMPERROR; missing from mingw\n\t\t\t\t\t\t\t\t\t\t * headers */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errmsg(\"could not compare Unicode strings: %m\")));\n\n\t\t\t/*\n\t\t\t * In some locales wcscoll() can claim that nonidentical strings\n\t\t\t * are equal.  Believing that would be bad news for a number of\n\t\t\t * reasons, so we follow Perl's lead and sort \"equal\" strings\n\t\t\t * according to strcmp (on the UTF-8 representation).\n\t\t\t */\n\t\t\tif (result == 0)\n\t\t\t{\n\t\t\t\tresult = memcmp(arg1, arg2, Min(len1, len2));\n\t\t\t\tif ((result == 0) && (len1 != len2))\n\t\t\t\t\tresult = (len1 < len2) ? -1 : 1;\n\t\t\t}\n\n\t\t\tif (a1p != a1buf)\n\t\t\t\tpfree(a1p);\n\t\t\tif (a2p != a2buf)\n\t\t\t\tpfree(a2p);\n\n\t\t\treturn result;\n\t\t}\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\n\t\tif (len1 >= TEXTBUFLEN)\n\t\t\ta1p = (char *) palloc(len1 + 1);\n\t\telse\n\t\t\ta1p = a1buf;\n\t\tif (len2 >= TEXTBUFLEN)\n\t\t\ta2p = (char *) palloc(len2 + 1);\n\t\telse\n\t\t\ta2p = a2buf;\n\n\t\tmemcpy(a1p, arg1, len1);\n\t\ta1p[len1] = '\\0';\n\t\tmemcpy(a2p, arg2, len2);\n\t\ta2p[len2] = '\\0';\n\n\t\tif (mylocale)\n\t\t{\n\t\t\tif (mylocale->provider == COLLPROVIDER_ICU)\n\t\t\t{\n#ifdef USE_ICU\n#ifdef HAVE_UCOL_STRCOLLUTF8\n\t\t\t\tif (GetDatabaseEncoding() == PG_UTF8)\n\t\t\t\t{\n\t\t\t\t\tUErrorCode\tstatus;\n\n\t\t\t\t\tstatus = U_ZERO_ERROR;\n\t\t\t\t\tresult = ucol_strcollUTF8(mylocale->info.icu.ucol,\n\t\t\t\t\t\t\t\t\t\t\t  arg1, len1,\n\t\t\t\t\t\t\t\t\t\t\t  arg2, len2,\n\t\t\t\t\t\t\t\t\t\t\t  &status);\n\t\t\t\t\tif (U_FAILURE(status))\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errmsg(\"collation failed: %s\", u_errorName(status))));\n\t\t\t\t}\n\t\t\t\telse\n#endif\n\t\t\t\t{\n\t\t\t\t\tint32_t\t\tulen1,\n\t\t\t\t\t\t\t\tulen2;\n\t\t\t\t\tUChar\t   *uchar1,\n\t\t\t\t\t\t\t   *uchar2;\n\n\t\t\t\t\tulen1 = icu_to_uchar(&uchar1, arg1, len1);\n\t\t\t\t\tulen2 = icu_to_uchar(&uchar2, arg2, len2);\n\n\t\t\t\t\tresult = ucol_strcoll(mylocale->info.icu.ucol,\n\t\t\t\t\t\t\t\t\t\t  uchar1, ulen1,\n\t\t\t\t\t\t\t\t\t\t  uchar2, ulen2);\n\n\t\t\t\t\tpfree(uchar1);\n\t\t\t\t\tpfree(uchar2);\n\t\t\t\t}\n#else\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t\t/* shouldn't happen */\n\t\t\t\telog(ERROR, \"unsupported collprovider: %c\", mylocale->provider);\n#endif\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t}\n\t\t\telse\n\t\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\t\tresult = strcoll_l(a1p, a2p, mylocale->info.lt);\n#else\n\t\t\t\t/* shouldn't happen */\n\t\t\t\telog(ERROR, \"unsupported collprovider: %c\", mylocale->provider);\n#endif\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tresult = strcoll(a1p, a2p);\n\n\t\t/*\n\t\t * In some locales strcoll() can claim that nonidentical strings are\n\t\t * equal.  Believing that would be bad news for a number of reasons,\n\t\t * so we follow Perl's lead and sort \"equal\" strings according to\n\t\t * strcmp().\n\t\t */\n\t\tif (result == 0)\n\t\t\tresult = strcmp(a1p, a2p);\n\n\t\tif (a1p != a1buf)\n\t\t\tpfree(a1p);\n\t\tif (a2p != a2buf)\n\t\t\tpfree(a2p);\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TEXTBUFLEN\t\t1024"
          ],
          "globals_used": [
            "static int\ttext_cmp(text *arg1, text *arg2, Oid collid);",
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define TEXTBUFLEN\t\t1024\n\nstatic int\ttext_cmp(text *arg1, text *arg2, Oid collid);\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nint\nvarstr_cmp(const char *arg1, int len1, const char *arg2, int len2, Oid collid)\n{\n\tint\t\t\tresult;\n\n\t/*\n\t * Unfortunately, there is no strncoll(), so in the non-C locale case we\n\t * have to do some memory copying.  This turns out to be significantly\n\t * slower, so we optimize the case where LC_COLLATE is C.  We also try to\n\t * optimize relatively-short strings by avoiding palloc/pfree overhead.\n\t */\n\tif (lc_collate_is_c(collid))\n\t{\n\t\tresult = memcmp(arg1, arg2, Min(len1, len2));\n\t\tif ((result == 0) && (len1 != len2))\n\t\t\tresult = (len1 < len2) ? -1 : 1;\n\t}\n\telse\n\t{\n\t\tchar\t\ta1buf[TEXTBUFLEN];\n\t\tchar\t\ta2buf[TEXTBUFLEN];\n\t\tchar\t   *a1p,\n\t\t\t\t   *a2p;\n\t\tpg_locale_t mylocale = 0;\n\n\t\tif (collid != DEFAULT_COLLATION_OID)\n\t\t{\n\t\t\tif (!OidIsValid(collid))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This typically means that the parser could not resolve a\n\t\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t\t errmsg(\"could not determine which collation to use for string comparison\"),\n\t\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t\t}\n\t\t\tmylocale = pg_newlocale_from_collation(collid);\n\t\t}\n\n\t\t/*\n\t\t * memcmp() can't tell us which of two unequal strings sorts first,\n\t\t * but it's a cheap way to tell if they're equal.  Testing shows that\n\t\t * memcmp() followed by strcoll() is only trivially slower than\n\t\t * strcoll() by itself, so we don't lose much if this doesn't work out\n\t\t * very often, and if it does - for example, because there are many\n\t\t * equal strings in the input - then we win big by avoiding expensive\n\t\t * collation-aware comparisons.\n\t\t */\n\t\tif (len1 == len2 && memcmp(arg1, arg2, len1) == 0)\n\t\t\treturn 0;\n\n#ifdef WIN32\n\t\t/* Win32 does not have UTF-8, so we need to map to UTF-16 */\n\t\tif (GetDatabaseEncoding() == PG_UTF8\n\t\t\t&& (!mylocale || mylocale->provider == COLLPROVIDER_LIBC))\n\t\t{\n\t\t\tint\t\t\ta1len;\n\t\t\tint\t\t\ta2len;\n\t\t\tint\t\t\tr;\n\n\t\t\tif (len1 >= TEXTBUFLEN / 2)\n\t\t\t{\n\t\t\t\ta1len = len1 * 2 + 2;\n\t\t\t\ta1p = palloc(a1len);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta1len = TEXTBUFLEN;\n\t\t\t\ta1p = a1buf;\n\t\t\t}\n\t\t\tif (len2 >= TEXTBUFLEN / 2)\n\t\t\t{\n\t\t\t\ta2len = len2 * 2 + 2;\n\t\t\t\ta2p = palloc(a2len);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta2len = TEXTBUFLEN;\n\t\t\t\ta2p = a2buf;\n\t\t\t}\n\n\t\t\t/* stupid Microsloth API does not work for zero-length input */\n\t\t\tif (len1 == 0)\n\t\t\t\tr = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = MultiByteToWideChar(CP_UTF8, 0, arg1, len1,\n\t\t\t\t\t\t\t\t\t\t(LPWSTR) a1p, a1len / 2);\n\t\t\t\tif (!r)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errmsg(\"could not convert string to UTF-16: error code %lu\",\n\t\t\t\t\t\t\t\t\tGetLastError())));\n\t\t\t}\n\t\t\t((LPWSTR) a1p)[r] = 0;\n\n\t\t\tif (len2 == 0)\n\t\t\t\tr = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = MultiByteToWideChar(CP_UTF8, 0, arg2, len2,\n\t\t\t\t\t\t\t\t\t\t(LPWSTR) a2p, a2len / 2);\n\t\t\t\tif (!r)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errmsg(\"could not convert string to UTF-16: error code %lu\",\n\t\t\t\t\t\t\t\t\tGetLastError())));\n\t\t\t}\n\t\t\t((LPWSTR) a2p)[r] = 0;\n\n\t\t\terrno = 0;\n#ifdef HAVE_LOCALE_T\n\t\t\tif (mylocale)\n\t\t\t\tresult = wcscoll_l((LPWSTR) a1p, (LPWSTR) a2p, mylocale->info.lt);\n\t\t\telse\n#endif\n\t\t\t\tresult = wcscoll((LPWSTR) a1p, (LPWSTR) a2p);\n\t\t\tif (result == 2147483647)\t/* _NLSCMPERROR; missing from mingw\n\t\t\t\t\t\t\t\t\t\t * headers */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errmsg(\"could not compare Unicode strings: %m\")));\n\n\t\t\t/*\n\t\t\t * In some locales wcscoll() can claim that nonidentical strings\n\t\t\t * are equal.  Believing that would be bad news for a number of\n\t\t\t * reasons, so we follow Perl's lead and sort \"equal\" strings\n\t\t\t * according to strcmp (on the UTF-8 representation).\n\t\t\t */\n\t\t\tif (result == 0)\n\t\t\t{\n\t\t\t\tresult = memcmp(arg1, arg2, Min(len1, len2));\n\t\t\t\tif ((result == 0) && (len1 != len2))\n\t\t\t\t\tresult = (len1 < len2) ? -1 : 1;\n\t\t\t}\n\n\t\t\tif (a1p != a1buf)\n\t\t\t\tpfree(a1p);\n\t\t\tif (a2p != a2buf)\n\t\t\t\tpfree(a2p);\n\n\t\t\treturn result;\n\t\t}\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\n\t\tif (len1 >= TEXTBUFLEN)\n\t\t\ta1p = (char *) palloc(len1 + 1);\n\t\telse\n\t\t\ta1p = a1buf;\n\t\tif (len2 >= TEXTBUFLEN)\n\t\t\ta2p = (char *) palloc(len2 + 1);\n\t\telse\n\t\t\ta2p = a2buf;\n\n\t\tmemcpy(a1p, arg1, len1);\n\t\ta1p[len1] = '\\0';\n\t\tmemcpy(a2p, arg2, len2);\n\t\ta2p[len2] = '\\0';\n\n\t\tif (mylocale)\n\t\t{\n\t\t\tif (mylocale->provider == COLLPROVIDER_ICU)\n\t\t\t{\n#ifdef USE_ICU\n#ifdef HAVE_UCOL_STRCOLLUTF8\n\t\t\t\tif (GetDatabaseEncoding() == PG_UTF8)\n\t\t\t\t{\n\t\t\t\t\tUErrorCode\tstatus;\n\n\t\t\t\t\tstatus = U_ZERO_ERROR;\n\t\t\t\t\tresult = ucol_strcollUTF8(mylocale->info.icu.ucol,\n\t\t\t\t\t\t\t\t\t\t\t  arg1, len1,\n\t\t\t\t\t\t\t\t\t\t\t  arg2, len2,\n\t\t\t\t\t\t\t\t\t\t\t  &status);\n\t\t\t\t\tif (U_FAILURE(status))\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errmsg(\"collation failed: %s\", u_errorName(status))));\n\t\t\t\t}\n\t\t\t\telse\n#endif\n\t\t\t\t{\n\t\t\t\t\tint32_t\t\tulen1,\n\t\t\t\t\t\t\t\tulen2;\n\t\t\t\t\tUChar\t   *uchar1,\n\t\t\t\t\t\t\t   *uchar2;\n\n\t\t\t\t\tulen1 = icu_to_uchar(&uchar1, arg1, len1);\n\t\t\t\t\tulen2 = icu_to_uchar(&uchar2, arg2, len2);\n\n\t\t\t\t\tresult = ucol_strcoll(mylocale->info.icu.ucol,\n\t\t\t\t\t\t\t\t\t\t  uchar1, ulen1,\n\t\t\t\t\t\t\t\t\t\t  uchar2, ulen2);\n\n\t\t\t\t\tpfree(uchar1);\n\t\t\t\t\tpfree(uchar2);\n\t\t\t\t}\n#else\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t\t/* shouldn't happen */\n\t\t\t\telog(ERROR, \"unsupported collprovider: %c\", mylocale->provider);\n#endif\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t}\n\t\t\telse\n\t\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\t\tresult = strcoll_l(a1p, a2p, mylocale->info.lt);\n#else\n\t\t\t\t/* shouldn't happen */\n\t\t\t\telog(ERROR, \"unsupported collprovider: %c\", mylocale->provider);\n#endif\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tresult = strcoll(a1p, a2p);\n\n\t\t/*\n\t\t * In some locales strcoll() can claim that nonidentical strings are\n\t\t * equal.  Believing that would be bad news for a number of reasons,\n\t\t * so we follow Perl's lead and sort \"equal\" strings according to\n\t\t * strcmp().\n\t\t */\n\t\tif (result == 0)\n\t\t\tresult = strcmp(a1p, a2p);\n\n\t\tif (a1p != a1buf)\n\t\t\tpfree(a1p);\n\t\tif (a2p != a2buf)\n\t\t\tpfree(a2p);\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GET_COLLATION",
          "args": [],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "arg2"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "arg1"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcTruelen",
          "args": [
            "arg2"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "bcTruelen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
          "lines": "653-657",
          "snippet": "static inline int\nbcTruelen(BpChar *arg)\n{\n\treturn bpchartruelen(VARDATA_ANY(arg), VARSIZE_ANY_EXHDR(arg));\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic inline int\nbcTruelen(BpChar *arg)\n{\n\treturn bpchartruelen(VARDATA_ANY(arg), VARSIZE_ANY_EXHDR(arg));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BPCHAR_PP",
          "args": [
            "1"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BPCHAR_PP",
          "args": [
            "0"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nbpchar_larger(PG_FUNCTION_ARGS)\n{\n\tBpChar\t   *arg1 = PG_GETARG_BPCHAR_PP(0);\n\tBpChar\t   *arg2 = PG_GETARG_BPCHAR_PP(1);\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\tint\t\t\tcmp;\n\n\tlen1 = bcTruelen(arg1);\n\tlen2 = bcTruelen(arg2);\n\n\tcmp = varstr_cmp(VARDATA_ANY(arg1), len1, VARDATA_ANY(arg2), len2,\n\t\t\t\t\t PG_GET_COLLATION());\n\n\tPG_RETURN_BPCHAR_P((cmp >= 0) ? arg1 : arg2);\n}"
  },
  {
    "function_name": "bpchar_sortsupport",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
    "lines": "869-884",
    "snippet": "Datum\nbpchar_sortsupport(PG_FUNCTION_ARGS)\n{\n\tSortSupport ssup = (SortSupport) PG_GETARG_POINTER(0);\n\tOid\t\t\tcollid = ssup->ssup_collation;\n\tMemoryContext oldcontext;\n\n\toldcontext = MemoryContextSwitchTo(ssup->ssup_cxt);\n\n\t/* Use generic string SortSupport */\n\tvarstr_sortsupport(ssup, collid, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\tPG_RETURN_VOID();\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VOID",
          "args": [],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "varstr_sortsupport",
          "args": [
            "ssup",
            "collid",
            "true"
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "varstr_sortsupport",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "1834-1985",
          "snippet": "void\nvarstr_sortsupport(SortSupport ssup, Oid collid, bool bpchar)\n{\n\tbool\t\tabbreviate = ssup->abbreviate;\n\tbool\t\tcollate_c = false;\n\tVarStringSortSupport *sss;\n\tpg_locale_t locale = 0;\n\n\t/*\n\t * If possible, set ssup->comparator to a function which can be used to\n\t * directly compare two datums.  If we can do this, we'll avoid the\n\t * overhead of a trip through the fmgr layer for every comparison, which\n\t * can be substantial.\n\t *\n\t * Most typically, we'll set the comparator to varstrfastcmp_locale, which\n\t * uses strcoll() to perform comparisons and knows about the special\n\t * requirements of BpChar callers.  However, if LC_COLLATE = C, we can\n\t * make things quite a bit faster with varstrfastcmp_c or bpcharfastcmp_c,\n\t * both of which use memcmp() rather than strcoll().\n\t */\n\tif (lc_collate_is_c(collid))\n\t{\n\t\tif (!bpchar)\n\t\t\tssup->comparator = varstrfastcmp_c;\n\t\telse\n\t\t\tssup->comparator = bpcharfastcmp_c;\n\n\t\tcollate_c = true;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * We need a collation-sensitive comparison.  To make things faster,\n\t\t * we'll figure out the collation based on the locale id and cache the\n\t\t * result.\n\t\t */\n\t\tif (collid != DEFAULT_COLLATION_OID)\n\t\t{\n\t\t\tif (!OidIsValid(collid))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This typically means that the parser could not resolve a\n\t\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t\t errmsg(\"could not determine which collation to use for string comparison\"),\n\t\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t\t}\n\t\t\tlocale = pg_newlocale_from_collation(collid);\n\t\t}\n\n\t\t/*\n\t\t * There is a further exception on Windows.  When the database\n\t\t * encoding is UTF-8 and we are not using the C collation, complex\n\t\t * hacks are required.  We don't currently have a comparator that\n\t\t * handles that case, so we fall back on the slow method of having the\n\t\t * sort code invoke bttextcmp() (in the case of text) via the fmgr\n\t\t * trampoline.  ICU locales work just the same on Windows, however.\n\t\t */\n#ifdef WIN32\n\t\tif (GetDatabaseEncoding() == PG_UTF8 &&\n\t\t\t!(locale && locale->provider == COLLPROVIDER_ICU))\n\t\t\treturn;\n#endif\n\n\t\tssup->comparator = varstrfastcmp_locale;\n\t}\n\n\t/*\n\t * Unfortunately, it seems that abbreviation for non-C collations is\n\t * broken on many common platforms; testing of multiple versions of glibc\n\t * reveals that, for many locales, strcoll() and strxfrm() do not return\n\t * consistent results, which is fatal to this optimization.  While no\n\t * other libc other than Cygwin has so far been shown to have a problem,\n\t * we take the conservative course of action for right now and disable\n\t * this categorically.  (Users who are certain this isn't a problem on\n\t * their system can define TRUST_STRXFRM.)\n\t *\n\t * Even apart from the risk of broken locales, it's possible that there\n\t * are platforms where the use of abbreviated keys should be disabled at\n\t * compile time.  Having only 4 byte datums could make worst-case\n\t * performance drastically more likely, for example.  Moreover, macOS's\n\t * strxfrm() implementation is known to not effectively concentrate a\n\t * significant amount of entropy from the original string in earlier\n\t * transformed blobs.  It's possible that other supported platforms are\n\t * similarly encumbered.  So, if we ever get past disabling this\n\t * categorically, we may still want or need to disable it for particular\n\t * platforms.\n\t */\n#ifndef TRUST_STRXFRM\n\tif (!collate_c && !(locale && locale->provider == COLLPROVIDER_ICU))\n\t\tabbreviate = false;\n#endif\n\n\t/*\n\t * If we're using abbreviated keys, or if we're using a locale-aware\n\t * comparison, we need to initialize a StringSortSupport object.  Both\n\t * cases will make use of the temporary buffers we initialize here for\n\t * scratch space (and to detect requirement for BpChar semantics from\n\t * caller), and the abbreviation case requires additional state.\n\t */\n\tif (abbreviate || !collate_c)\n\t{\n\t\tsss = palloc(sizeof(VarStringSortSupport));\n\t\tsss->buf1 = palloc(TEXTBUFLEN);\n\t\tsss->buflen1 = TEXTBUFLEN;\n\t\tsss->buf2 = palloc(TEXTBUFLEN);\n\t\tsss->buflen2 = TEXTBUFLEN;\n\t\t/* Start with invalid values */\n\t\tsss->last_len1 = -1;\n\t\tsss->last_len2 = -1;\n\t\t/* Initialize */\n\t\tsss->last_returned = 0;\n\t\tsss->locale = locale;\n\n\t\t/*\n\t\t * To avoid somehow confusing a strxfrm() blob and an original string,\n\t\t * constantly keep track of the variety of data that buf1 and buf2\n\t\t * currently contain.\n\t\t *\n\t\t * Comparisons may be interleaved with conversion calls.  Frequently,\n\t\t * conversions and comparisons are batched into two distinct phases,\n\t\t * but the correctness of caching cannot hinge upon this.  For\n\t\t * comparison caching, buffer state is only trusted if cache_blob is\n\t\t * found set to false, whereas strxfrm() caching only trusts the state\n\t\t * when cache_blob is found set to true.\n\t\t *\n\t\t * Arbitrarily initialize cache_blob to true.\n\t\t */\n\t\tsss->cache_blob = true;\n\t\tsss->collate_c = collate_c;\n\t\tsss->bpchar = bpchar;\n\t\tssup->ssup_extra = sss;\n\n\t\t/*\n\t\t * If possible, plan to use the abbreviated keys optimization.  The\n\t\t * core code may switch back to authoritative comparator should\n\t\t * abbreviation be aborted.\n\t\t */\n\t\tif (abbreviate)\n\t\t{\n\t\t\tsss->prop_card = 0.20;\n\t\t\tinitHyperLogLog(&sss->abbr_card, 10);\n\t\t\tinitHyperLogLog(&sss->full_card, 10);\n\t\t\tssup->abbrev_full_comparator = ssup->comparator;\n\t\t\tssup->comparator = varstrcmp_abbrev;\n\t\t\tssup->abbrev_converter = varstr_abbrev_convert;\n\t\t\tssup->abbrev_abort = varstr_abbrev_abort;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TEXTBUFLEN\t\t1024"
          ],
          "globals_used": [
            "static int\tvarstrfastcmp_c(Datum x, Datum y, SortSupport ssup);",
            "static int\tbpcharfastcmp_c(Datum x, Datum y, SortSupport ssup);",
            "static int\tvarstrfastcmp_locale(Datum x, Datum y, SortSupport ssup);",
            "static int\tvarstrcmp_abbrev(Datum x, Datum y, SortSupport ssup);",
            "static Datum varstr_abbrev_convert(Datum original, SortSupport ssup);",
            "static bool varstr_abbrev_abort(int memtupcount, SortSupport ssup);",
            "static void text_position_setup(text *t1, text *t2, TextPositionState *state);",
            "static int\ttext_position_next(int start_pos, TextPositionState *state);",
            "static void text_position_cleanup(TextPositionState *state);",
            "static int\ttext_cmp(text *arg1, text *arg2, Oid collid);",
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define TEXTBUFLEN\t\t1024\n\nstatic int\tvarstrfastcmp_c(Datum x, Datum y, SortSupport ssup);\nstatic int\tbpcharfastcmp_c(Datum x, Datum y, SortSupport ssup);\nstatic int\tvarstrfastcmp_locale(Datum x, Datum y, SortSupport ssup);\nstatic int\tvarstrcmp_abbrev(Datum x, Datum y, SortSupport ssup);\nstatic Datum varstr_abbrev_convert(Datum original, SortSupport ssup);\nstatic bool varstr_abbrev_abort(int memtupcount, SortSupport ssup);\nstatic void text_position_setup(text *t1, text *t2, TextPositionState *state);\nstatic int\ttext_position_next(int start_pos, TextPositionState *state);\nstatic void text_position_cleanup(TextPositionState *state);\nstatic int\ttext_cmp(text *arg1, text *arg2, Oid collid);\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nvoid\nvarstr_sortsupport(SortSupport ssup, Oid collid, bool bpchar)\n{\n\tbool\t\tabbreviate = ssup->abbreviate;\n\tbool\t\tcollate_c = false;\n\tVarStringSortSupport *sss;\n\tpg_locale_t locale = 0;\n\n\t/*\n\t * If possible, set ssup->comparator to a function which can be used to\n\t * directly compare two datums.  If we can do this, we'll avoid the\n\t * overhead of a trip through the fmgr layer for every comparison, which\n\t * can be substantial.\n\t *\n\t * Most typically, we'll set the comparator to varstrfastcmp_locale, which\n\t * uses strcoll() to perform comparisons and knows about the special\n\t * requirements of BpChar callers.  However, if LC_COLLATE = C, we can\n\t * make things quite a bit faster with varstrfastcmp_c or bpcharfastcmp_c,\n\t * both of which use memcmp() rather than strcoll().\n\t */\n\tif (lc_collate_is_c(collid))\n\t{\n\t\tif (!bpchar)\n\t\t\tssup->comparator = varstrfastcmp_c;\n\t\telse\n\t\t\tssup->comparator = bpcharfastcmp_c;\n\n\t\tcollate_c = true;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * We need a collation-sensitive comparison.  To make things faster,\n\t\t * we'll figure out the collation based on the locale id and cache the\n\t\t * result.\n\t\t */\n\t\tif (collid != DEFAULT_COLLATION_OID)\n\t\t{\n\t\t\tif (!OidIsValid(collid))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This typically means that the parser could not resolve a\n\t\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t\t errmsg(\"could not determine which collation to use for string comparison\"),\n\t\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t\t}\n\t\t\tlocale = pg_newlocale_from_collation(collid);\n\t\t}\n\n\t\t/*\n\t\t * There is a further exception on Windows.  When the database\n\t\t * encoding is UTF-8 and we are not using the C collation, complex\n\t\t * hacks are required.  We don't currently have a comparator that\n\t\t * handles that case, so we fall back on the slow method of having the\n\t\t * sort code invoke bttextcmp() (in the case of text) via the fmgr\n\t\t * trampoline.  ICU locales work just the same on Windows, however.\n\t\t */\n#ifdef WIN32\n\t\tif (GetDatabaseEncoding() == PG_UTF8 &&\n\t\t\t!(locale && locale->provider == COLLPROVIDER_ICU))\n\t\t\treturn;\n#endif\n\n\t\tssup->comparator = varstrfastcmp_locale;\n\t}\n\n\t/*\n\t * Unfortunately, it seems that abbreviation for non-C collations is\n\t * broken on many common platforms; testing of multiple versions of glibc\n\t * reveals that, for many locales, strcoll() and strxfrm() do not return\n\t * consistent results, which is fatal to this optimization.  While no\n\t * other libc other than Cygwin has so far been shown to have a problem,\n\t * we take the conservative course of action for right now and disable\n\t * this categorically.  (Users who are certain this isn't a problem on\n\t * their system can define TRUST_STRXFRM.)\n\t *\n\t * Even apart from the risk of broken locales, it's possible that there\n\t * are platforms where the use of abbreviated keys should be disabled at\n\t * compile time.  Having only 4 byte datums could make worst-case\n\t * performance drastically more likely, for example.  Moreover, macOS's\n\t * strxfrm() implementation is known to not effectively concentrate a\n\t * significant amount of entropy from the original string in earlier\n\t * transformed blobs.  It's possible that other supported platforms are\n\t * similarly encumbered.  So, if we ever get past disabling this\n\t * categorically, we may still want or need to disable it for particular\n\t * platforms.\n\t */\n#ifndef TRUST_STRXFRM\n\tif (!collate_c && !(locale && locale->provider == COLLPROVIDER_ICU))\n\t\tabbreviate = false;\n#endif\n\n\t/*\n\t * If we're using abbreviated keys, or if we're using a locale-aware\n\t * comparison, we need to initialize a StringSortSupport object.  Both\n\t * cases will make use of the temporary buffers we initialize here for\n\t * scratch space (and to detect requirement for BpChar semantics from\n\t * caller), and the abbreviation case requires additional state.\n\t */\n\tif (abbreviate || !collate_c)\n\t{\n\t\tsss = palloc(sizeof(VarStringSortSupport));\n\t\tsss->buf1 = palloc(TEXTBUFLEN);\n\t\tsss->buflen1 = TEXTBUFLEN;\n\t\tsss->buf2 = palloc(TEXTBUFLEN);\n\t\tsss->buflen2 = TEXTBUFLEN;\n\t\t/* Start with invalid values */\n\t\tsss->last_len1 = -1;\n\t\tsss->last_len2 = -1;\n\t\t/* Initialize */\n\t\tsss->last_returned = 0;\n\t\tsss->locale = locale;\n\n\t\t/*\n\t\t * To avoid somehow confusing a strxfrm() blob and an original string,\n\t\t * constantly keep track of the variety of data that buf1 and buf2\n\t\t * currently contain.\n\t\t *\n\t\t * Comparisons may be interleaved with conversion calls.  Frequently,\n\t\t * conversions and comparisons are batched into two distinct phases,\n\t\t * but the correctness of caching cannot hinge upon this.  For\n\t\t * comparison caching, buffer state is only trusted if cache_blob is\n\t\t * found set to false, whereas strxfrm() caching only trusts the state\n\t\t * when cache_blob is found set to true.\n\t\t *\n\t\t * Arbitrarily initialize cache_blob to true.\n\t\t */\n\t\tsss->cache_blob = true;\n\t\tsss->collate_c = collate_c;\n\t\tsss->bpchar = bpchar;\n\t\tssup->ssup_extra = sss;\n\n\t\t/*\n\t\t * If possible, plan to use the abbreviated keys optimization.  The\n\t\t * core code may switch back to authoritative comparator should\n\t\t * abbreviation be aborted.\n\t\t */\n\t\tif (abbreviate)\n\t\t{\n\t\t\tsss->prop_card = 0.20;\n\t\t\tinitHyperLogLog(&sss->abbr_card, 10);\n\t\t\tinitHyperLogLog(&sss->full_card, 10);\n\t\t\tssup->abbrev_full_comparator = ssup->comparator;\n\t\t\tssup->comparator = varstrcmp_abbrev;\n\t\t\tssup->abbrev_converter = varstr_abbrev_convert;\n\t\t\tssup->abbrev_abort = varstr_abbrev_abort;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "ssup->ssup_cxt"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nbpchar_sortsupport(PG_FUNCTION_ARGS)\n{\n\tSortSupport ssup = (SortSupport) PG_GETARG_POINTER(0);\n\tOid\t\t\tcollid = ssup->ssup_collation;\n\tMemoryContext oldcontext;\n\n\toldcontext = MemoryContextSwitchTo(ssup->ssup_cxt);\n\n\t/* Use generic string SortSupport */\n\tvarstr_sortsupport(ssup, collid, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\tPG_RETURN_VOID();\n}"
  },
  {
    "function_name": "bpcharcmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
    "lines": "848-867",
    "snippet": "Datum\nbpcharcmp(PG_FUNCTION_ARGS)\n{\n\tBpChar\t   *arg1 = PG_GETARG_BPCHAR_PP(0);\n\tBpChar\t   *arg2 = PG_GETARG_BPCHAR_PP(1);\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\tint\t\t\tcmp;\n\n\tlen1 = bcTruelen(arg1);\n\tlen2 = bcTruelen(arg2);\n\n\tcmp = varstr_cmp(VARDATA_ANY(arg1), len1, VARDATA_ANY(arg2), len2,\n\t\t\t\t\t PG_GET_COLLATION());\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_INT32(cmp);\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "cmp"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg2",
            "1"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg1",
            "0"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "varstr_cmp",
          "args": [
            "VARDATA_ANY(arg1)",
            "len1",
            "VARDATA_ANY(arg2)",
            "len2",
            "PG_GET_COLLATION()"
          ],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "varstr_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "1380-1609",
          "snippet": "int\nvarstr_cmp(const char *arg1, int len1, const char *arg2, int len2, Oid collid)\n{\n\tint\t\t\tresult;\n\n\t/*\n\t * Unfortunately, there is no strncoll(), so in the non-C locale case we\n\t * have to do some memory copying.  This turns out to be significantly\n\t * slower, so we optimize the case where LC_COLLATE is C.  We also try to\n\t * optimize relatively-short strings by avoiding palloc/pfree overhead.\n\t */\n\tif (lc_collate_is_c(collid))\n\t{\n\t\tresult = memcmp(arg1, arg2, Min(len1, len2));\n\t\tif ((result == 0) && (len1 != len2))\n\t\t\tresult = (len1 < len2) ? -1 : 1;\n\t}\n\telse\n\t{\n\t\tchar\t\ta1buf[TEXTBUFLEN];\n\t\tchar\t\ta2buf[TEXTBUFLEN];\n\t\tchar\t   *a1p,\n\t\t\t\t   *a2p;\n\t\tpg_locale_t mylocale = 0;\n\n\t\tif (collid != DEFAULT_COLLATION_OID)\n\t\t{\n\t\t\tif (!OidIsValid(collid))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This typically means that the parser could not resolve a\n\t\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t\t errmsg(\"could not determine which collation to use for string comparison\"),\n\t\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t\t}\n\t\t\tmylocale = pg_newlocale_from_collation(collid);\n\t\t}\n\n\t\t/*\n\t\t * memcmp() can't tell us which of two unequal strings sorts first,\n\t\t * but it's a cheap way to tell if they're equal.  Testing shows that\n\t\t * memcmp() followed by strcoll() is only trivially slower than\n\t\t * strcoll() by itself, so we don't lose much if this doesn't work out\n\t\t * very often, and if it does - for example, because there are many\n\t\t * equal strings in the input - then we win big by avoiding expensive\n\t\t * collation-aware comparisons.\n\t\t */\n\t\tif (len1 == len2 && memcmp(arg1, arg2, len1) == 0)\n\t\t\treturn 0;\n\n#ifdef WIN32\n\t\t/* Win32 does not have UTF-8, so we need to map to UTF-16 */\n\t\tif (GetDatabaseEncoding() == PG_UTF8\n\t\t\t&& (!mylocale || mylocale->provider == COLLPROVIDER_LIBC))\n\t\t{\n\t\t\tint\t\t\ta1len;\n\t\t\tint\t\t\ta2len;\n\t\t\tint\t\t\tr;\n\n\t\t\tif (len1 >= TEXTBUFLEN / 2)\n\t\t\t{\n\t\t\t\ta1len = len1 * 2 + 2;\n\t\t\t\ta1p = palloc(a1len);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta1len = TEXTBUFLEN;\n\t\t\t\ta1p = a1buf;\n\t\t\t}\n\t\t\tif (len2 >= TEXTBUFLEN / 2)\n\t\t\t{\n\t\t\t\ta2len = len2 * 2 + 2;\n\t\t\t\ta2p = palloc(a2len);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta2len = TEXTBUFLEN;\n\t\t\t\ta2p = a2buf;\n\t\t\t}\n\n\t\t\t/* stupid Microsloth API does not work for zero-length input */\n\t\t\tif (len1 == 0)\n\t\t\t\tr = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = MultiByteToWideChar(CP_UTF8, 0, arg1, len1,\n\t\t\t\t\t\t\t\t\t\t(LPWSTR) a1p, a1len / 2);\n\t\t\t\tif (!r)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errmsg(\"could not convert string to UTF-16: error code %lu\",\n\t\t\t\t\t\t\t\t\tGetLastError())));\n\t\t\t}\n\t\t\t((LPWSTR) a1p)[r] = 0;\n\n\t\t\tif (len2 == 0)\n\t\t\t\tr = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = MultiByteToWideChar(CP_UTF8, 0, arg2, len2,\n\t\t\t\t\t\t\t\t\t\t(LPWSTR) a2p, a2len / 2);\n\t\t\t\tif (!r)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errmsg(\"could not convert string to UTF-16: error code %lu\",\n\t\t\t\t\t\t\t\t\tGetLastError())));\n\t\t\t}\n\t\t\t((LPWSTR) a2p)[r] = 0;\n\n\t\t\terrno = 0;\n#ifdef HAVE_LOCALE_T\n\t\t\tif (mylocale)\n\t\t\t\tresult = wcscoll_l((LPWSTR) a1p, (LPWSTR) a2p, mylocale->info.lt);\n\t\t\telse\n#endif\n\t\t\t\tresult = wcscoll((LPWSTR) a1p, (LPWSTR) a2p);\n\t\t\tif (result == 2147483647)\t/* _NLSCMPERROR; missing from mingw\n\t\t\t\t\t\t\t\t\t\t * headers */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errmsg(\"could not compare Unicode strings: %m\")));\n\n\t\t\t/*\n\t\t\t * In some locales wcscoll() can claim that nonidentical strings\n\t\t\t * are equal.  Believing that would be bad news for a number of\n\t\t\t * reasons, so we follow Perl's lead and sort \"equal\" strings\n\t\t\t * according to strcmp (on the UTF-8 representation).\n\t\t\t */\n\t\t\tif (result == 0)\n\t\t\t{\n\t\t\t\tresult = memcmp(arg1, arg2, Min(len1, len2));\n\t\t\t\tif ((result == 0) && (len1 != len2))\n\t\t\t\t\tresult = (len1 < len2) ? -1 : 1;\n\t\t\t}\n\n\t\t\tif (a1p != a1buf)\n\t\t\t\tpfree(a1p);\n\t\t\tif (a2p != a2buf)\n\t\t\t\tpfree(a2p);\n\n\t\t\treturn result;\n\t\t}\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\n\t\tif (len1 >= TEXTBUFLEN)\n\t\t\ta1p = (char *) palloc(len1 + 1);\n\t\telse\n\t\t\ta1p = a1buf;\n\t\tif (len2 >= TEXTBUFLEN)\n\t\t\ta2p = (char *) palloc(len2 + 1);\n\t\telse\n\t\t\ta2p = a2buf;\n\n\t\tmemcpy(a1p, arg1, len1);\n\t\ta1p[len1] = '\\0';\n\t\tmemcpy(a2p, arg2, len2);\n\t\ta2p[len2] = '\\0';\n\n\t\tif (mylocale)\n\t\t{\n\t\t\tif (mylocale->provider == COLLPROVIDER_ICU)\n\t\t\t{\n#ifdef USE_ICU\n#ifdef HAVE_UCOL_STRCOLLUTF8\n\t\t\t\tif (GetDatabaseEncoding() == PG_UTF8)\n\t\t\t\t{\n\t\t\t\t\tUErrorCode\tstatus;\n\n\t\t\t\t\tstatus = U_ZERO_ERROR;\n\t\t\t\t\tresult = ucol_strcollUTF8(mylocale->info.icu.ucol,\n\t\t\t\t\t\t\t\t\t\t\t  arg1, len1,\n\t\t\t\t\t\t\t\t\t\t\t  arg2, len2,\n\t\t\t\t\t\t\t\t\t\t\t  &status);\n\t\t\t\t\tif (U_FAILURE(status))\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errmsg(\"collation failed: %s\", u_errorName(status))));\n\t\t\t\t}\n\t\t\t\telse\n#endif\n\t\t\t\t{\n\t\t\t\t\tint32_t\t\tulen1,\n\t\t\t\t\t\t\t\tulen2;\n\t\t\t\t\tUChar\t   *uchar1,\n\t\t\t\t\t\t\t   *uchar2;\n\n\t\t\t\t\tulen1 = icu_to_uchar(&uchar1, arg1, len1);\n\t\t\t\t\tulen2 = icu_to_uchar(&uchar2, arg2, len2);\n\n\t\t\t\t\tresult = ucol_strcoll(mylocale->info.icu.ucol,\n\t\t\t\t\t\t\t\t\t\t  uchar1, ulen1,\n\t\t\t\t\t\t\t\t\t\t  uchar2, ulen2);\n\n\t\t\t\t\tpfree(uchar1);\n\t\t\t\t\tpfree(uchar2);\n\t\t\t\t}\n#else\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t\t/* shouldn't happen */\n\t\t\t\telog(ERROR, \"unsupported collprovider: %c\", mylocale->provider);\n#endif\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t}\n\t\t\telse\n\t\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\t\tresult = strcoll_l(a1p, a2p, mylocale->info.lt);\n#else\n\t\t\t\t/* shouldn't happen */\n\t\t\t\telog(ERROR, \"unsupported collprovider: %c\", mylocale->provider);\n#endif\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tresult = strcoll(a1p, a2p);\n\n\t\t/*\n\t\t * In some locales strcoll() can claim that nonidentical strings are\n\t\t * equal.  Believing that would be bad news for a number of reasons,\n\t\t * so we follow Perl's lead and sort \"equal\" strings according to\n\t\t * strcmp().\n\t\t */\n\t\tif (result == 0)\n\t\t\tresult = strcmp(a1p, a2p);\n\n\t\tif (a1p != a1buf)\n\t\t\tpfree(a1p);\n\t\tif (a2p != a2buf)\n\t\t\tpfree(a2p);\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TEXTBUFLEN\t\t1024"
          ],
          "globals_used": [
            "static int\ttext_cmp(text *arg1, text *arg2, Oid collid);",
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define TEXTBUFLEN\t\t1024\n\nstatic int\ttext_cmp(text *arg1, text *arg2, Oid collid);\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nint\nvarstr_cmp(const char *arg1, int len1, const char *arg2, int len2, Oid collid)\n{\n\tint\t\t\tresult;\n\n\t/*\n\t * Unfortunately, there is no strncoll(), so in the non-C locale case we\n\t * have to do some memory copying.  This turns out to be significantly\n\t * slower, so we optimize the case where LC_COLLATE is C.  We also try to\n\t * optimize relatively-short strings by avoiding palloc/pfree overhead.\n\t */\n\tif (lc_collate_is_c(collid))\n\t{\n\t\tresult = memcmp(arg1, arg2, Min(len1, len2));\n\t\tif ((result == 0) && (len1 != len2))\n\t\t\tresult = (len1 < len2) ? -1 : 1;\n\t}\n\telse\n\t{\n\t\tchar\t\ta1buf[TEXTBUFLEN];\n\t\tchar\t\ta2buf[TEXTBUFLEN];\n\t\tchar\t   *a1p,\n\t\t\t\t   *a2p;\n\t\tpg_locale_t mylocale = 0;\n\n\t\tif (collid != DEFAULT_COLLATION_OID)\n\t\t{\n\t\t\tif (!OidIsValid(collid))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This typically means that the parser could not resolve a\n\t\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t\t errmsg(\"could not determine which collation to use for string comparison\"),\n\t\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t\t}\n\t\t\tmylocale = pg_newlocale_from_collation(collid);\n\t\t}\n\n\t\t/*\n\t\t * memcmp() can't tell us which of two unequal strings sorts first,\n\t\t * but it's a cheap way to tell if they're equal.  Testing shows that\n\t\t * memcmp() followed by strcoll() is only trivially slower than\n\t\t * strcoll() by itself, so we don't lose much if this doesn't work out\n\t\t * very often, and if it does - for example, because there are many\n\t\t * equal strings in the input - then we win big by avoiding expensive\n\t\t * collation-aware comparisons.\n\t\t */\n\t\tif (len1 == len2 && memcmp(arg1, arg2, len1) == 0)\n\t\t\treturn 0;\n\n#ifdef WIN32\n\t\t/* Win32 does not have UTF-8, so we need to map to UTF-16 */\n\t\tif (GetDatabaseEncoding() == PG_UTF8\n\t\t\t&& (!mylocale || mylocale->provider == COLLPROVIDER_LIBC))\n\t\t{\n\t\t\tint\t\t\ta1len;\n\t\t\tint\t\t\ta2len;\n\t\t\tint\t\t\tr;\n\n\t\t\tif (len1 >= TEXTBUFLEN / 2)\n\t\t\t{\n\t\t\t\ta1len = len1 * 2 + 2;\n\t\t\t\ta1p = palloc(a1len);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta1len = TEXTBUFLEN;\n\t\t\t\ta1p = a1buf;\n\t\t\t}\n\t\t\tif (len2 >= TEXTBUFLEN / 2)\n\t\t\t{\n\t\t\t\ta2len = len2 * 2 + 2;\n\t\t\t\ta2p = palloc(a2len);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta2len = TEXTBUFLEN;\n\t\t\t\ta2p = a2buf;\n\t\t\t}\n\n\t\t\t/* stupid Microsloth API does not work for zero-length input */\n\t\t\tif (len1 == 0)\n\t\t\t\tr = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = MultiByteToWideChar(CP_UTF8, 0, arg1, len1,\n\t\t\t\t\t\t\t\t\t\t(LPWSTR) a1p, a1len / 2);\n\t\t\t\tif (!r)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errmsg(\"could not convert string to UTF-16: error code %lu\",\n\t\t\t\t\t\t\t\t\tGetLastError())));\n\t\t\t}\n\t\t\t((LPWSTR) a1p)[r] = 0;\n\n\t\t\tif (len2 == 0)\n\t\t\t\tr = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = MultiByteToWideChar(CP_UTF8, 0, arg2, len2,\n\t\t\t\t\t\t\t\t\t\t(LPWSTR) a2p, a2len / 2);\n\t\t\t\tif (!r)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errmsg(\"could not convert string to UTF-16: error code %lu\",\n\t\t\t\t\t\t\t\t\tGetLastError())));\n\t\t\t}\n\t\t\t((LPWSTR) a2p)[r] = 0;\n\n\t\t\terrno = 0;\n#ifdef HAVE_LOCALE_T\n\t\t\tif (mylocale)\n\t\t\t\tresult = wcscoll_l((LPWSTR) a1p, (LPWSTR) a2p, mylocale->info.lt);\n\t\t\telse\n#endif\n\t\t\t\tresult = wcscoll((LPWSTR) a1p, (LPWSTR) a2p);\n\t\t\tif (result == 2147483647)\t/* _NLSCMPERROR; missing from mingw\n\t\t\t\t\t\t\t\t\t\t * headers */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errmsg(\"could not compare Unicode strings: %m\")));\n\n\t\t\t/*\n\t\t\t * In some locales wcscoll() can claim that nonidentical strings\n\t\t\t * are equal.  Believing that would be bad news for a number of\n\t\t\t * reasons, so we follow Perl's lead and sort \"equal\" strings\n\t\t\t * according to strcmp (on the UTF-8 representation).\n\t\t\t */\n\t\t\tif (result == 0)\n\t\t\t{\n\t\t\t\tresult = memcmp(arg1, arg2, Min(len1, len2));\n\t\t\t\tif ((result == 0) && (len1 != len2))\n\t\t\t\t\tresult = (len1 < len2) ? -1 : 1;\n\t\t\t}\n\n\t\t\tif (a1p != a1buf)\n\t\t\t\tpfree(a1p);\n\t\t\tif (a2p != a2buf)\n\t\t\t\tpfree(a2p);\n\n\t\t\treturn result;\n\t\t}\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\n\t\tif (len1 >= TEXTBUFLEN)\n\t\t\ta1p = (char *) palloc(len1 + 1);\n\t\telse\n\t\t\ta1p = a1buf;\n\t\tif (len2 >= TEXTBUFLEN)\n\t\t\ta2p = (char *) palloc(len2 + 1);\n\t\telse\n\t\t\ta2p = a2buf;\n\n\t\tmemcpy(a1p, arg1, len1);\n\t\ta1p[len1] = '\\0';\n\t\tmemcpy(a2p, arg2, len2);\n\t\ta2p[len2] = '\\0';\n\n\t\tif (mylocale)\n\t\t{\n\t\t\tif (mylocale->provider == COLLPROVIDER_ICU)\n\t\t\t{\n#ifdef USE_ICU\n#ifdef HAVE_UCOL_STRCOLLUTF8\n\t\t\t\tif (GetDatabaseEncoding() == PG_UTF8)\n\t\t\t\t{\n\t\t\t\t\tUErrorCode\tstatus;\n\n\t\t\t\t\tstatus = U_ZERO_ERROR;\n\t\t\t\t\tresult = ucol_strcollUTF8(mylocale->info.icu.ucol,\n\t\t\t\t\t\t\t\t\t\t\t  arg1, len1,\n\t\t\t\t\t\t\t\t\t\t\t  arg2, len2,\n\t\t\t\t\t\t\t\t\t\t\t  &status);\n\t\t\t\t\tif (U_FAILURE(status))\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errmsg(\"collation failed: %s\", u_errorName(status))));\n\t\t\t\t}\n\t\t\t\telse\n#endif\n\t\t\t\t{\n\t\t\t\t\tint32_t\t\tulen1,\n\t\t\t\t\t\t\t\tulen2;\n\t\t\t\t\tUChar\t   *uchar1,\n\t\t\t\t\t\t\t   *uchar2;\n\n\t\t\t\t\tulen1 = icu_to_uchar(&uchar1, arg1, len1);\n\t\t\t\t\tulen2 = icu_to_uchar(&uchar2, arg2, len2);\n\n\t\t\t\t\tresult = ucol_strcoll(mylocale->info.icu.ucol,\n\t\t\t\t\t\t\t\t\t\t  uchar1, ulen1,\n\t\t\t\t\t\t\t\t\t\t  uchar2, ulen2);\n\n\t\t\t\t\tpfree(uchar1);\n\t\t\t\t\tpfree(uchar2);\n\t\t\t\t}\n#else\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t\t/* shouldn't happen */\n\t\t\t\telog(ERROR, \"unsupported collprovider: %c\", mylocale->provider);\n#endif\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t}\n\t\t\telse\n\t\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\t\tresult = strcoll_l(a1p, a2p, mylocale->info.lt);\n#else\n\t\t\t\t/* shouldn't happen */\n\t\t\t\telog(ERROR, \"unsupported collprovider: %c\", mylocale->provider);\n#endif\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tresult = strcoll(a1p, a2p);\n\n\t\t/*\n\t\t * In some locales strcoll() can claim that nonidentical strings are\n\t\t * equal.  Believing that would be bad news for a number of reasons,\n\t\t * so we follow Perl's lead and sort \"equal\" strings according to\n\t\t * strcmp().\n\t\t */\n\t\tif (result == 0)\n\t\t\tresult = strcmp(a1p, a2p);\n\n\t\tif (a1p != a1buf)\n\t\t\tpfree(a1p);\n\t\tif (a2p != a2buf)\n\t\t\tpfree(a2p);\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GET_COLLATION",
          "args": [],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "arg2"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "arg1"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcTruelen",
          "args": [
            "arg2"
          ],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "bcTruelen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
          "lines": "653-657",
          "snippet": "static inline int\nbcTruelen(BpChar *arg)\n{\n\treturn bpchartruelen(VARDATA_ANY(arg), VARSIZE_ANY_EXHDR(arg));\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic inline int\nbcTruelen(BpChar *arg)\n{\n\treturn bpchartruelen(VARDATA_ANY(arg), VARSIZE_ANY_EXHDR(arg));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BPCHAR_PP",
          "args": [
            "1"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BPCHAR_PP",
          "args": [
            "0"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nbpcharcmp(PG_FUNCTION_ARGS)\n{\n\tBpChar\t   *arg1 = PG_GETARG_BPCHAR_PP(0);\n\tBpChar\t   *arg2 = PG_GETARG_BPCHAR_PP(1);\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\tint\t\t\tcmp;\n\n\tlen1 = bcTruelen(arg1);\n\tlen2 = bcTruelen(arg2);\n\n\tcmp = varstr_cmp(VARDATA_ANY(arg1), len1, VARDATA_ANY(arg2), len2,\n\t\t\t\t\t PG_GET_COLLATION());\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_INT32(cmp);\n}"
  },
  {
    "function_name": "bpcharge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
    "lines": "827-846",
    "snippet": "Datum\nbpcharge(PG_FUNCTION_ARGS)\n{\n\tBpChar\t   *arg1 = PG_GETARG_BPCHAR_PP(0);\n\tBpChar\t   *arg2 = PG_GETARG_BPCHAR_PP(1);\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\tint\t\t\tcmp;\n\n\tlen1 = bcTruelen(arg1);\n\tlen2 = bcTruelen(arg2);\n\n\tcmp = varstr_cmp(VARDATA_ANY(arg1), len1, VARDATA_ANY(arg2), len2,\n\t\t\t\t\t PG_GET_COLLATION());\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_BOOL(cmp >= 0);\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "cmp >= 0"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg2",
            "1"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg1",
            "0"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "varstr_cmp",
          "args": [
            "VARDATA_ANY(arg1)",
            "len1",
            "VARDATA_ANY(arg2)",
            "len2",
            "PG_GET_COLLATION()"
          ],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "varstr_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "1380-1609",
          "snippet": "int\nvarstr_cmp(const char *arg1, int len1, const char *arg2, int len2, Oid collid)\n{\n\tint\t\t\tresult;\n\n\t/*\n\t * Unfortunately, there is no strncoll(), so in the non-C locale case we\n\t * have to do some memory copying.  This turns out to be significantly\n\t * slower, so we optimize the case where LC_COLLATE is C.  We also try to\n\t * optimize relatively-short strings by avoiding palloc/pfree overhead.\n\t */\n\tif (lc_collate_is_c(collid))\n\t{\n\t\tresult = memcmp(arg1, arg2, Min(len1, len2));\n\t\tif ((result == 0) && (len1 != len2))\n\t\t\tresult = (len1 < len2) ? -1 : 1;\n\t}\n\telse\n\t{\n\t\tchar\t\ta1buf[TEXTBUFLEN];\n\t\tchar\t\ta2buf[TEXTBUFLEN];\n\t\tchar\t   *a1p,\n\t\t\t\t   *a2p;\n\t\tpg_locale_t mylocale = 0;\n\n\t\tif (collid != DEFAULT_COLLATION_OID)\n\t\t{\n\t\t\tif (!OidIsValid(collid))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This typically means that the parser could not resolve a\n\t\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t\t errmsg(\"could not determine which collation to use for string comparison\"),\n\t\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t\t}\n\t\t\tmylocale = pg_newlocale_from_collation(collid);\n\t\t}\n\n\t\t/*\n\t\t * memcmp() can't tell us which of two unequal strings sorts first,\n\t\t * but it's a cheap way to tell if they're equal.  Testing shows that\n\t\t * memcmp() followed by strcoll() is only trivially slower than\n\t\t * strcoll() by itself, so we don't lose much if this doesn't work out\n\t\t * very often, and if it does - for example, because there are many\n\t\t * equal strings in the input - then we win big by avoiding expensive\n\t\t * collation-aware comparisons.\n\t\t */\n\t\tif (len1 == len2 && memcmp(arg1, arg2, len1) == 0)\n\t\t\treturn 0;\n\n#ifdef WIN32\n\t\t/* Win32 does not have UTF-8, so we need to map to UTF-16 */\n\t\tif (GetDatabaseEncoding() == PG_UTF8\n\t\t\t&& (!mylocale || mylocale->provider == COLLPROVIDER_LIBC))\n\t\t{\n\t\t\tint\t\t\ta1len;\n\t\t\tint\t\t\ta2len;\n\t\t\tint\t\t\tr;\n\n\t\t\tif (len1 >= TEXTBUFLEN / 2)\n\t\t\t{\n\t\t\t\ta1len = len1 * 2 + 2;\n\t\t\t\ta1p = palloc(a1len);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta1len = TEXTBUFLEN;\n\t\t\t\ta1p = a1buf;\n\t\t\t}\n\t\t\tif (len2 >= TEXTBUFLEN / 2)\n\t\t\t{\n\t\t\t\ta2len = len2 * 2 + 2;\n\t\t\t\ta2p = palloc(a2len);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta2len = TEXTBUFLEN;\n\t\t\t\ta2p = a2buf;\n\t\t\t}\n\n\t\t\t/* stupid Microsloth API does not work for zero-length input */\n\t\t\tif (len1 == 0)\n\t\t\t\tr = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = MultiByteToWideChar(CP_UTF8, 0, arg1, len1,\n\t\t\t\t\t\t\t\t\t\t(LPWSTR) a1p, a1len / 2);\n\t\t\t\tif (!r)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errmsg(\"could not convert string to UTF-16: error code %lu\",\n\t\t\t\t\t\t\t\t\tGetLastError())));\n\t\t\t}\n\t\t\t((LPWSTR) a1p)[r] = 0;\n\n\t\t\tif (len2 == 0)\n\t\t\t\tr = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = MultiByteToWideChar(CP_UTF8, 0, arg2, len2,\n\t\t\t\t\t\t\t\t\t\t(LPWSTR) a2p, a2len / 2);\n\t\t\t\tif (!r)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errmsg(\"could not convert string to UTF-16: error code %lu\",\n\t\t\t\t\t\t\t\t\tGetLastError())));\n\t\t\t}\n\t\t\t((LPWSTR) a2p)[r] = 0;\n\n\t\t\terrno = 0;\n#ifdef HAVE_LOCALE_T\n\t\t\tif (mylocale)\n\t\t\t\tresult = wcscoll_l((LPWSTR) a1p, (LPWSTR) a2p, mylocale->info.lt);\n\t\t\telse\n#endif\n\t\t\t\tresult = wcscoll((LPWSTR) a1p, (LPWSTR) a2p);\n\t\t\tif (result == 2147483647)\t/* _NLSCMPERROR; missing from mingw\n\t\t\t\t\t\t\t\t\t\t * headers */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errmsg(\"could not compare Unicode strings: %m\")));\n\n\t\t\t/*\n\t\t\t * In some locales wcscoll() can claim that nonidentical strings\n\t\t\t * are equal.  Believing that would be bad news for a number of\n\t\t\t * reasons, so we follow Perl's lead and sort \"equal\" strings\n\t\t\t * according to strcmp (on the UTF-8 representation).\n\t\t\t */\n\t\t\tif (result == 0)\n\t\t\t{\n\t\t\t\tresult = memcmp(arg1, arg2, Min(len1, len2));\n\t\t\t\tif ((result == 0) && (len1 != len2))\n\t\t\t\t\tresult = (len1 < len2) ? -1 : 1;\n\t\t\t}\n\n\t\t\tif (a1p != a1buf)\n\t\t\t\tpfree(a1p);\n\t\t\tif (a2p != a2buf)\n\t\t\t\tpfree(a2p);\n\n\t\t\treturn result;\n\t\t}\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\n\t\tif (len1 >= TEXTBUFLEN)\n\t\t\ta1p = (char *) palloc(len1 + 1);\n\t\telse\n\t\t\ta1p = a1buf;\n\t\tif (len2 >= TEXTBUFLEN)\n\t\t\ta2p = (char *) palloc(len2 + 1);\n\t\telse\n\t\t\ta2p = a2buf;\n\n\t\tmemcpy(a1p, arg1, len1);\n\t\ta1p[len1] = '\\0';\n\t\tmemcpy(a2p, arg2, len2);\n\t\ta2p[len2] = '\\0';\n\n\t\tif (mylocale)\n\t\t{\n\t\t\tif (mylocale->provider == COLLPROVIDER_ICU)\n\t\t\t{\n#ifdef USE_ICU\n#ifdef HAVE_UCOL_STRCOLLUTF8\n\t\t\t\tif (GetDatabaseEncoding() == PG_UTF8)\n\t\t\t\t{\n\t\t\t\t\tUErrorCode\tstatus;\n\n\t\t\t\t\tstatus = U_ZERO_ERROR;\n\t\t\t\t\tresult = ucol_strcollUTF8(mylocale->info.icu.ucol,\n\t\t\t\t\t\t\t\t\t\t\t  arg1, len1,\n\t\t\t\t\t\t\t\t\t\t\t  arg2, len2,\n\t\t\t\t\t\t\t\t\t\t\t  &status);\n\t\t\t\t\tif (U_FAILURE(status))\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errmsg(\"collation failed: %s\", u_errorName(status))));\n\t\t\t\t}\n\t\t\t\telse\n#endif\n\t\t\t\t{\n\t\t\t\t\tint32_t\t\tulen1,\n\t\t\t\t\t\t\t\tulen2;\n\t\t\t\t\tUChar\t   *uchar1,\n\t\t\t\t\t\t\t   *uchar2;\n\n\t\t\t\t\tulen1 = icu_to_uchar(&uchar1, arg1, len1);\n\t\t\t\t\tulen2 = icu_to_uchar(&uchar2, arg2, len2);\n\n\t\t\t\t\tresult = ucol_strcoll(mylocale->info.icu.ucol,\n\t\t\t\t\t\t\t\t\t\t  uchar1, ulen1,\n\t\t\t\t\t\t\t\t\t\t  uchar2, ulen2);\n\n\t\t\t\t\tpfree(uchar1);\n\t\t\t\t\tpfree(uchar2);\n\t\t\t\t}\n#else\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t\t/* shouldn't happen */\n\t\t\t\telog(ERROR, \"unsupported collprovider: %c\", mylocale->provider);\n#endif\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t}\n\t\t\telse\n\t\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\t\tresult = strcoll_l(a1p, a2p, mylocale->info.lt);\n#else\n\t\t\t\t/* shouldn't happen */\n\t\t\t\telog(ERROR, \"unsupported collprovider: %c\", mylocale->provider);\n#endif\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tresult = strcoll(a1p, a2p);\n\n\t\t/*\n\t\t * In some locales strcoll() can claim that nonidentical strings are\n\t\t * equal.  Believing that would be bad news for a number of reasons,\n\t\t * so we follow Perl's lead and sort \"equal\" strings according to\n\t\t * strcmp().\n\t\t */\n\t\tif (result == 0)\n\t\t\tresult = strcmp(a1p, a2p);\n\n\t\tif (a1p != a1buf)\n\t\t\tpfree(a1p);\n\t\tif (a2p != a2buf)\n\t\t\tpfree(a2p);\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TEXTBUFLEN\t\t1024"
          ],
          "globals_used": [
            "static int\ttext_cmp(text *arg1, text *arg2, Oid collid);",
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define TEXTBUFLEN\t\t1024\n\nstatic int\ttext_cmp(text *arg1, text *arg2, Oid collid);\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nint\nvarstr_cmp(const char *arg1, int len1, const char *arg2, int len2, Oid collid)\n{\n\tint\t\t\tresult;\n\n\t/*\n\t * Unfortunately, there is no strncoll(), so in the non-C locale case we\n\t * have to do some memory copying.  This turns out to be significantly\n\t * slower, so we optimize the case where LC_COLLATE is C.  We also try to\n\t * optimize relatively-short strings by avoiding palloc/pfree overhead.\n\t */\n\tif (lc_collate_is_c(collid))\n\t{\n\t\tresult = memcmp(arg1, arg2, Min(len1, len2));\n\t\tif ((result == 0) && (len1 != len2))\n\t\t\tresult = (len1 < len2) ? -1 : 1;\n\t}\n\telse\n\t{\n\t\tchar\t\ta1buf[TEXTBUFLEN];\n\t\tchar\t\ta2buf[TEXTBUFLEN];\n\t\tchar\t   *a1p,\n\t\t\t\t   *a2p;\n\t\tpg_locale_t mylocale = 0;\n\n\t\tif (collid != DEFAULT_COLLATION_OID)\n\t\t{\n\t\t\tif (!OidIsValid(collid))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This typically means that the parser could not resolve a\n\t\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t\t errmsg(\"could not determine which collation to use for string comparison\"),\n\t\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t\t}\n\t\t\tmylocale = pg_newlocale_from_collation(collid);\n\t\t}\n\n\t\t/*\n\t\t * memcmp() can't tell us which of two unequal strings sorts first,\n\t\t * but it's a cheap way to tell if they're equal.  Testing shows that\n\t\t * memcmp() followed by strcoll() is only trivially slower than\n\t\t * strcoll() by itself, so we don't lose much if this doesn't work out\n\t\t * very often, and if it does - for example, because there are many\n\t\t * equal strings in the input - then we win big by avoiding expensive\n\t\t * collation-aware comparisons.\n\t\t */\n\t\tif (len1 == len2 && memcmp(arg1, arg2, len1) == 0)\n\t\t\treturn 0;\n\n#ifdef WIN32\n\t\t/* Win32 does not have UTF-8, so we need to map to UTF-16 */\n\t\tif (GetDatabaseEncoding() == PG_UTF8\n\t\t\t&& (!mylocale || mylocale->provider == COLLPROVIDER_LIBC))\n\t\t{\n\t\t\tint\t\t\ta1len;\n\t\t\tint\t\t\ta2len;\n\t\t\tint\t\t\tr;\n\n\t\t\tif (len1 >= TEXTBUFLEN / 2)\n\t\t\t{\n\t\t\t\ta1len = len1 * 2 + 2;\n\t\t\t\ta1p = palloc(a1len);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta1len = TEXTBUFLEN;\n\t\t\t\ta1p = a1buf;\n\t\t\t}\n\t\t\tif (len2 >= TEXTBUFLEN / 2)\n\t\t\t{\n\t\t\t\ta2len = len2 * 2 + 2;\n\t\t\t\ta2p = palloc(a2len);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta2len = TEXTBUFLEN;\n\t\t\t\ta2p = a2buf;\n\t\t\t}\n\n\t\t\t/* stupid Microsloth API does not work for zero-length input */\n\t\t\tif (len1 == 0)\n\t\t\t\tr = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = MultiByteToWideChar(CP_UTF8, 0, arg1, len1,\n\t\t\t\t\t\t\t\t\t\t(LPWSTR) a1p, a1len / 2);\n\t\t\t\tif (!r)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errmsg(\"could not convert string to UTF-16: error code %lu\",\n\t\t\t\t\t\t\t\t\tGetLastError())));\n\t\t\t}\n\t\t\t((LPWSTR) a1p)[r] = 0;\n\n\t\t\tif (len2 == 0)\n\t\t\t\tr = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = MultiByteToWideChar(CP_UTF8, 0, arg2, len2,\n\t\t\t\t\t\t\t\t\t\t(LPWSTR) a2p, a2len / 2);\n\t\t\t\tif (!r)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errmsg(\"could not convert string to UTF-16: error code %lu\",\n\t\t\t\t\t\t\t\t\tGetLastError())));\n\t\t\t}\n\t\t\t((LPWSTR) a2p)[r] = 0;\n\n\t\t\terrno = 0;\n#ifdef HAVE_LOCALE_T\n\t\t\tif (mylocale)\n\t\t\t\tresult = wcscoll_l((LPWSTR) a1p, (LPWSTR) a2p, mylocale->info.lt);\n\t\t\telse\n#endif\n\t\t\t\tresult = wcscoll((LPWSTR) a1p, (LPWSTR) a2p);\n\t\t\tif (result == 2147483647)\t/* _NLSCMPERROR; missing from mingw\n\t\t\t\t\t\t\t\t\t\t * headers */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errmsg(\"could not compare Unicode strings: %m\")));\n\n\t\t\t/*\n\t\t\t * In some locales wcscoll() can claim that nonidentical strings\n\t\t\t * are equal.  Believing that would be bad news for a number of\n\t\t\t * reasons, so we follow Perl's lead and sort \"equal\" strings\n\t\t\t * according to strcmp (on the UTF-8 representation).\n\t\t\t */\n\t\t\tif (result == 0)\n\t\t\t{\n\t\t\t\tresult = memcmp(arg1, arg2, Min(len1, len2));\n\t\t\t\tif ((result == 0) && (len1 != len2))\n\t\t\t\t\tresult = (len1 < len2) ? -1 : 1;\n\t\t\t}\n\n\t\t\tif (a1p != a1buf)\n\t\t\t\tpfree(a1p);\n\t\t\tif (a2p != a2buf)\n\t\t\t\tpfree(a2p);\n\n\t\t\treturn result;\n\t\t}\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\n\t\tif (len1 >= TEXTBUFLEN)\n\t\t\ta1p = (char *) palloc(len1 + 1);\n\t\telse\n\t\t\ta1p = a1buf;\n\t\tif (len2 >= TEXTBUFLEN)\n\t\t\ta2p = (char *) palloc(len2 + 1);\n\t\telse\n\t\t\ta2p = a2buf;\n\n\t\tmemcpy(a1p, arg1, len1);\n\t\ta1p[len1] = '\\0';\n\t\tmemcpy(a2p, arg2, len2);\n\t\ta2p[len2] = '\\0';\n\n\t\tif (mylocale)\n\t\t{\n\t\t\tif (mylocale->provider == COLLPROVIDER_ICU)\n\t\t\t{\n#ifdef USE_ICU\n#ifdef HAVE_UCOL_STRCOLLUTF8\n\t\t\t\tif (GetDatabaseEncoding() == PG_UTF8)\n\t\t\t\t{\n\t\t\t\t\tUErrorCode\tstatus;\n\n\t\t\t\t\tstatus = U_ZERO_ERROR;\n\t\t\t\t\tresult = ucol_strcollUTF8(mylocale->info.icu.ucol,\n\t\t\t\t\t\t\t\t\t\t\t  arg1, len1,\n\t\t\t\t\t\t\t\t\t\t\t  arg2, len2,\n\t\t\t\t\t\t\t\t\t\t\t  &status);\n\t\t\t\t\tif (U_FAILURE(status))\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errmsg(\"collation failed: %s\", u_errorName(status))));\n\t\t\t\t}\n\t\t\t\telse\n#endif\n\t\t\t\t{\n\t\t\t\t\tint32_t\t\tulen1,\n\t\t\t\t\t\t\t\tulen2;\n\t\t\t\t\tUChar\t   *uchar1,\n\t\t\t\t\t\t\t   *uchar2;\n\n\t\t\t\t\tulen1 = icu_to_uchar(&uchar1, arg1, len1);\n\t\t\t\t\tulen2 = icu_to_uchar(&uchar2, arg2, len2);\n\n\t\t\t\t\tresult = ucol_strcoll(mylocale->info.icu.ucol,\n\t\t\t\t\t\t\t\t\t\t  uchar1, ulen1,\n\t\t\t\t\t\t\t\t\t\t  uchar2, ulen2);\n\n\t\t\t\t\tpfree(uchar1);\n\t\t\t\t\tpfree(uchar2);\n\t\t\t\t}\n#else\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t\t/* shouldn't happen */\n\t\t\t\telog(ERROR, \"unsupported collprovider: %c\", mylocale->provider);\n#endif\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t}\n\t\t\telse\n\t\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\t\tresult = strcoll_l(a1p, a2p, mylocale->info.lt);\n#else\n\t\t\t\t/* shouldn't happen */\n\t\t\t\telog(ERROR, \"unsupported collprovider: %c\", mylocale->provider);\n#endif\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tresult = strcoll(a1p, a2p);\n\n\t\t/*\n\t\t * In some locales strcoll() can claim that nonidentical strings are\n\t\t * equal.  Believing that would be bad news for a number of reasons,\n\t\t * so we follow Perl's lead and sort \"equal\" strings according to\n\t\t * strcmp().\n\t\t */\n\t\tif (result == 0)\n\t\t\tresult = strcmp(a1p, a2p);\n\n\t\tif (a1p != a1buf)\n\t\t\tpfree(a1p);\n\t\tif (a2p != a2buf)\n\t\t\tpfree(a2p);\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GET_COLLATION",
          "args": [],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "arg2"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "arg1"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcTruelen",
          "args": [
            "arg2"
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "bcTruelen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
          "lines": "653-657",
          "snippet": "static inline int\nbcTruelen(BpChar *arg)\n{\n\treturn bpchartruelen(VARDATA_ANY(arg), VARSIZE_ANY_EXHDR(arg));\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic inline int\nbcTruelen(BpChar *arg)\n{\n\treturn bpchartruelen(VARDATA_ANY(arg), VARSIZE_ANY_EXHDR(arg));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BPCHAR_PP",
          "args": [
            "1"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BPCHAR_PP",
          "args": [
            "0"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nbpcharge(PG_FUNCTION_ARGS)\n{\n\tBpChar\t   *arg1 = PG_GETARG_BPCHAR_PP(0);\n\tBpChar\t   *arg2 = PG_GETARG_BPCHAR_PP(1);\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\tint\t\t\tcmp;\n\n\tlen1 = bcTruelen(arg1);\n\tlen2 = bcTruelen(arg2);\n\n\tcmp = varstr_cmp(VARDATA_ANY(arg1), len1, VARDATA_ANY(arg2), len2,\n\t\t\t\t\t PG_GET_COLLATION());\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_BOOL(cmp >= 0);\n}"
  },
  {
    "function_name": "bpchargt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
    "lines": "806-825",
    "snippet": "Datum\nbpchargt(PG_FUNCTION_ARGS)\n{\n\tBpChar\t   *arg1 = PG_GETARG_BPCHAR_PP(0);\n\tBpChar\t   *arg2 = PG_GETARG_BPCHAR_PP(1);\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\tint\t\t\tcmp;\n\n\tlen1 = bcTruelen(arg1);\n\tlen2 = bcTruelen(arg2);\n\n\tcmp = varstr_cmp(VARDATA_ANY(arg1), len1, VARDATA_ANY(arg2), len2,\n\t\t\t\t\t PG_GET_COLLATION());\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_BOOL(cmp > 0);\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "cmp > 0"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg2",
            "1"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg1",
            "0"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "varstr_cmp",
          "args": [
            "VARDATA_ANY(arg1)",
            "len1",
            "VARDATA_ANY(arg2)",
            "len2",
            "PG_GET_COLLATION()"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "varstr_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "1380-1609",
          "snippet": "int\nvarstr_cmp(const char *arg1, int len1, const char *arg2, int len2, Oid collid)\n{\n\tint\t\t\tresult;\n\n\t/*\n\t * Unfortunately, there is no strncoll(), so in the non-C locale case we\n\t * have to do some memory copying.  This turns out to be significantly\n\t * slower, so we optimize the case where LC_COLLATE is C.  We also try to\n\t * optimize relatively-short strings by avoiding palloc/pfree overhead.\n\t */\n\tif (lc_collate_is_c(collid))\n\t{\n\t\tresult = memcmp(arg1, arg2, Min(len1, len2));\n\t\tif ((result == 0) && (len1 != len2))\n\t\t\tresult = (len1 < len2) ? -1 : 1;\n\t}\n\telse\n\t{\n\t\tchar\t\ta1buf[TEXTBUFLEN];\n\t\tchar\t\ta2buf[TEXTBUFLEN];\n\t\tchar\t   *a1p,\n\t\t\t\t   *a2p;\n\t\tpg_locale_t mylocale = 0;\n\n\t\tif (collid != DEFAULT_COLLATION_OID)\n\t\t{\n\t\t\tif (!OidIsValid(collid))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This typically means that the parser could not resolve a\n\t\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t\t errmsg(\"could not determine which collation to use for string comparison\"),\n\t\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t\t}\n\t\t\tmylocale = pg_newlocale_from_collation(collid);\n\t\t}\n\n\t\t/*\n\t\t * memcmp() can't tell us which of two unequal strings sorts first,\n\t\t * but it's a cheap way to tell if they're equal.  Testing shows that\n\t\t * memcmp() followed by strcoll() is only trivially slower than\n\t\t * strcoll() by itself, so we don't lose much if this doesn't work out\n\t\t * very often, and if it does - for example, because there are many\n\t\t * equal strings in the input - then we win big by avoiding expensive\n\t\t * collation-aware comparisons.\n\t\t */\n\t\tif (len1 == len2 && memcmp(arg1, arg2, len1) == 0)\n\t\t\treturn 0;\n\n#ifdef WIN32\n\t\t/* Win32 does not have UTF-8, so we need to map to UTF-16 */\n\t\tif (GetDatabaseEncoding() == PG_UTF8\n\t\t\t&& (!mylocale || mylocale->provider == COLLPROVIDER_LIBC))\n\t\t{\n\t\t\tint\t\t\ta1len;\n\t\t\tint\t\t\ta2len;\n\t\t\tint\t\t\tr;\n\n\t\t\tif (len1 >= TEXTBUFLEN / 2)\n\t\t\t{\n\t\t\t\ta1len = len1 * 2 + 2;\n\t\t\t\ta1p = palloc(a1len);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta1len = TEXTBUFLEN;\n\t\t\t\ta1p = a1buf;\n\t\t\t}\n\t\t\tif (len2 >= TEXTBUFLEN / 2)\n\t\t\t{\n\t\t\t\ta2len = len2 * 2 + 2;\n\t\t\t\ta2p = palloc(a2len);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta2len = TEXTBUFLEN;\n\t\t\t\ta2p = a2buf;\n\t\t\t}\n\n\t\t\t/* stupid Microsloth API does not work for zero-length input */\n\t\t\tif (len1 == 0)\n\t\t\t\tr = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = MultiByteToWideChar(CP_UTF8, 0, arg1, len1,\n\t\t\t\t\t\t\t\t\t\t(LPWSTR) a1p, a1len / 2);\n\t\t\t\tif (!r)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errmsg(\"could not convert string to UTF-16: error code %lu\",\n\t\t\t\t\t\t\t\t\tGetLastError())));\n\t\t\t}\n\t\t\t((LPWSTR) a1p)[r] = 0;\n\n\t\t\tif (len2 == 0)\n\t\t\t\tr = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = MultiByteToWideChar(CP_UTF8, 0, arg2, len2,\n\t\t\t\t\t\t\t\t\t\t(LPWSTR) a2p, a2len / 2);\n\t\t\t\tif (!r)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errmsg(\"could not convert string to UTF-16: error code %lu\",\n\t\t\t\t\t\t\t\t\tGetLastError())));\n\t\t\t}\n\t\t\t((LPWSTR) a2p)[r] = 0;\n\n\t\t\terrno = 0;\n#ifdef HAVE_LOCALE_T\n\t\t\tif (mylocale)\n\t\t\t\tresult = wcscoll_l((LPWSTR) a1p, (LPWSTR) a2p, mylocale->info.lt);\n\t\t\telse\n#endif\n\t\t\t\tresult = wcscoll((LPWSTR) a1p, (LPWSTR) a2p);\n\t\t\tif (result == 2147483647)\t/* _NLSCMPERROR; missing from mingw\n\t\t\t\t\t\t\t\t\t\t * headers */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errmsg(\"could not compare Unicode strings: %m\")));\n\n\t\t\t/*\n\t\t\t * In some locales wcscoll() can claim that nonidentical strings\n\t\t\t * are equal.  Believing that would be bad news for a number of\n\t\t\t * reasons, so we follow Perl's lead and sort \"equal\" strings\n\t\t\t * according to strcmp (on the UTF-8 representation).\n\t\t\t */\n\t\t\tif (result == 0)\n\t\t\t{\n\t\t\t\tresult = memcmp(arg1, arg2, Min(len1, len2));\n\t\t\t\tif ((result == 0) && (len1 != len2))\n\t\t\t\t\tresult = (len1 < len2) ? -1 : 1;\n\t\t\t}\n\n\t\t\tif (a1p != a1buf)\n\t\t\t\tpfree(a1p);\n\t\t\tif (a2p != a2buf)\n\t\t\t\tpfree(a2p);\n\n\t\t\treturn result;\n\t\t}\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\n\t\tif (len1 >= TEXTBUFLEN)\n\t\t\ta1p = (char *) palloc(len1 + 1);\n\t\telse\n\t\t\ta1p = a1buf;\n\t\tif (len2 >= TEXTBUFLEN)\n\t\t\ta2p = (char *) palloc(len2 + 1);\n\t\telse\n\t\t\ta2p = a2buf;\n\n\t\tmemcpy(a1p, arg1, len1);\n\t\ta1p[len1] = '\\0';\n\t\tmemcpy(a2p, arg2, len2);\n\t\ta2p[len2] = '\\0';\n\n\t\tif (mylocale)\n\t\t{\n\t\t\tif (mylocale->provider == COLLPROVIDER_ICU)\n\t\t\t{\n#ifdef USE_ICU\n#ifdef HAVE_UCOL_STRCOLLUTF8\n\t\t\t\tif (GetDatabaseEncoding() == PG_UTF8)\n\t\t\t\t{\n\t\t\t\t\tUErrorCode\tstatus;\n\n\t\t\t\t\tstatus = U_ZERO_ERROR;\n\t\t\t\t\tresult = ucol_strcollUTF8(mylocale->info.icu.ucol,\n\t\t\t\t\t\t\t\t\t\t\t  arg1, len1,\n\t\t\t\t\t\t\t\t\t\t\t  arg2, len2,\n\t\t\t\t\t\t\t\t\t\t\t  &status);\n\t\t\t\t\tif (U_FAILURE(status))\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errmsg(\"collation failed: %s\", u_errorName(status))));\n\t\t\t\t}\n\t\t\t\telse\n#endif\n\t\t\t\t{\n\t\t\t\t\tint32_t\t\tulen1,\n\t\t\t\t\t\t\t\tulen2;\n\t\t\t\t\tUChar\t   *uchar1,\n\t\t\t\t\t\t\t   *uchar2;\n\n\t\t\t\t\tulen1 = icu_to_uchar(&uchar1, arg1, len1);\n\t\t\t\t\tulen2 = icu_to_uchar(&uchar2, arg2, len2);\n\n\t\t\t\t\tresult = ucol_strcoll(mylocale->info.icu.ucol,\n\t\t\t\t\t\t\t\t\t\t  uchar1, ulen1,\n\t\t\t\t\t\t\t\t\t\t  uchar2, ulen2);\n\n\t\t\t\t\tpfree(uchar1);\n\t\t\t\t\tpfree(uchar2);\n\t\t\t\t}\n#else\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t\t/* shouldn't happen */\n\t\t\t\telog(ERROR, \"unsupported collprovider: %c\", mylocale->provider);\n#endif\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t}\n\t\t\telse\n\t\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\t\tresult = strcoll_l(a1p, a2p, mylocale->info.lt);\n#else\n\t\t\t\t/* shouldn't happen */\n\t\t\t\telog(ERROR, \"unsupported collprovider: %c\", mylocale->provider);\n#endif\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tresult = strcoll(a1p, a2p);\n\n\t\t/*\n\t\t * In some locales strcoll() can claim that nonidentical strings are\n\t\t * equal.  Believing that would be bad news for a number of reasons,\n\t\t * so we follow Perl's lead and sort \"equal\" strings according to\n\t\t * strcmp().\n\t\t */\n\t\tif (result == 0)\n\t\t\tresult = strcmp(a1p, a2p);\n\n\t\tif (a1p != a1buf)\n\t\t\tpfree(a1p);\n\t\tif (a2p != a2buf)\n\t\t\tpfree(a2p);\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TEXTBUFLEN\t\t1024"
          ],
          "globals_used": [
            "static int\ttext_cmp(text *arg1, text *arg2, Oid collid);",
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define TEXTBUFLEN\t\t1024\n\nstatic int\ttext_cmp(text *arg1, text *arg2, Oid collid);\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nint\nvarstr_cmp(const char *arg1, int len1, const char *arg2, int len2, Oid collid)\n{\n\tint\t\t\tresult;\n\n\t/*\n\t * Unfortunately, there is no strncoll(), so in the non-C locale case we\n\t * have to do some memory copying.  This turns out to be significantly\n\t * slower, so we optimize the case where LC_COLLATE is C.  We also try to\n\t * optimize relatively-short strings by avoiding palloc/pfree overhead.\n\t */\n\tif (lc_collate_is_c(collid))\n\t{\n\t\tresult = memcmp(arg1, arg2, Min(len1, len2));\n\t\tif ((result == 0) && (len1 != len2))\n\t\t\tresult = (len1 < len2) ? -1 : 1;\n\t}\n\telse\n\t{\n\t\tchar\t\ta1buf[TEXTBUFLEN];\n\t\tchar\t\ta2buf[TEXTBUFLEN];\n\t\tchar\t   *a1p,\n\t\t\t\t   *a2p;\n\t\tpg_locale_t mylocale = 0;\n\n\t\tif (collid != DEFAULT_COLLATION_OID)\n\t\t{\n\t\t\tif (!OidIsValid(collid))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This typically means that the parser could not resolve a\n\t\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t\t errmsg(\"could not determine which collation to use for string comparison\"),\n\t\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t\t}\n\t\t\tmylocale = pg_newlocale_from_collation(collid);\n\t\t}\n\n\t\t/*\n\t\t * memcmp() can't tell us which of two unequal strings sorts first,\n\t\t * but it's a cheap way to tell if they're equal.  Testing shows that\n\t\t * memcmp() followed by strcoll() is only trivially slower than\n\t\t * strcoll() by itself, so we don't lose much if this doesn't work out\n\t\t * very often, and if it does - for example, because there are many\n\t\t * equal strings in the input - then we win big by avoiding expensive\n\t\t * collation-aware comparisons.\n\t\t */\n\t\tif (len1 == len2 && memcmp(arg1, arg2, len1) == 0)\n\t\t\treturn 0;\n\n#ifdef WIN32\n\t\t/* Win32 does not have UTF-8, so we need to map to UTF-16 */\n\t\tif (GetDatabaseEncoding() == PG_UTF8\n\t\t\t&& (!mylocale || mylocale->provider == COLLPROVIDER_LIBC))\n\t\t{\n\t\t\tint\t\t\ta1len;\n\t\t\tint\t\t\ta2len;\n\t\t\tint\t\t\tr;\n\n\t\t\tif (len1 >= TEXTBUFLEN / 2)\n\t\t\t{\n\t\t\t\ta1len = len1 * 2 + 2;\n\t\t\t\ta1p = palloc(a1len);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta1len = TEXTBUFLEN;\n\t\t\t\ta1p = a1buf;\n\t\t\t}\n\t\t\tif (len2 >= TEXTBUFLEN / 2)\n\t\t\t{\n\t\t\t\ta2len = len2 * 2 + 2;\n\t\t\t\ta2p = palloc(a2len);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta2len = TEXTBUFLEN;\n\t\t\t\ta2p = a2buf;\n\t\t\t}\n\n\t\t\t/* stupid Microsloth API does not work for zero-length input */\n\t\t\tif (len1 == 0)\n\t\t\t\tr = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = MultiByteToWideChar(CP_UTF8, 0, arg1, len1,\n\t\t\t\t\t\t\t\t\t\t(LPWSTR) a1p, a1len / 2);\n\t\t\t\tif (!r)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errmsg(\"could not convert string to UTF-16: error code %lu\",\n\t\t\t\t\t\t\t\t\tGetLastError())));\n\t\t\t}\n\t\t\t((LPWSTR) a1p)[r] = 0;\n\n\t\t\tif (len2 == 0)\n\t\t\t\tr = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = MultiByteToWideChar(CP_UTF8, 0, arg2, len2,\n\t\t\t\t\t\t\t\t\t\t(LPWSTR) a2p, a2len / 2);\n\t\t\t\tif (!r)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errmsg(\"could not convert string to UTF-16: error code %lu\",\n\t\t\t\t\t\t\t\t\tGetLastError())));\n\t\t\t}\n\t\t\t((LPWSTR) a2p)[r] = 0;\n\n\t\t\terrno = 0;\n#ifdef HAVE_LOCALE_T\n\t\t\tif (mylocale)\n\t\t\t\tresult = wcscoll_l((LPWSTR) a1p, (LPWSTR) a2p, mylocale->info.lt);\n\t\t\telse\n#endif\n\t\t\t\tresult = wcscoll((LPWSTR) a1p, (LPWSTR) a2p);\n\t\t\tif (result == 2147483647)\t/* _NLSCMPERROR; missing from mingw\n\t\t\t\t\t\t\t\t\t\t * headers */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errmsg(\"could not compare Unicode strings: %m\")));\n\n\t\t\t/*\n\t\t\t * In some locales wcscoll() can claim that nonidentical strings\n\t\t\t * are equal.  Believing that would be bad news for a number of\n\t\t\t * reasons, so we follow Perl's lead and sort \"equal\" strings\n\t\t\t * according to strcmp (on the UTF-8 representation).\n\t\t\t */\n\t\t\tif (result == 0)\n\t\t\t{\n\t\t\t\tresult = memcmp(arg1, arg2, Min(len1, len2));\n\t\t\t\tif ((result == 0) && (len1 != len2))\n\t\t\t\t\tresult = (len1 < len2) ? -1 : 1;\n\t\t\t}\n\n\t\t\tif (a1p != a1buf)\n\t\t\t\tpfree(a1p);\n\t\t\tif (a2p != a2buf)\n\t\t\t\tpfree(a2p);\n\n\t\t\treturn result;\n\t\t}\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\n\t\tif (len1 >= TEXTBUFLEN)\n\t\t\ta1p = (char *) palloc(len1 + 1);\n\t\telse\n\t\t\ta1p = a1buf;\n\t\tif (len2 >= TEXTBUFLEN)\n\t\t\ta2p = (char *) palloc(len2 + 1);\n\t\telse\n\t\t\ta2p = a2buf;\n\n\t\tmemcpy(a1p, arg1, len1);\n\t\ta1p[len1] = '\\0';\n\t\tmemcpy(a2p, arg2, len2);\n\t\ta2p[len2] = '\\0';\n\n\t\tif (mylocale)\n\t\t{\n\t\t\tif (mylocale->provider == COLLPROVIDER_ICU)\n\t\t\t{\n#ifdef USE_ICU\n#ifdef HAVE_UCOL_STRCOLLUTF8\n\t\t\t\tif (GetDatabaseEncoding() == PG_UTF8)\n\t\t\t\t{\n\t\t\t\t\tUErrorCode\tstatus;\n\n\t\t\t\t\tstatus = U_ZERO_ERROR;\n\t\t\t\t\tresult = ucol_strcollUTF8(mylocale->info.icu.ucol,\n\t\t\t\t\t\t\t\t\t\t\t  arg1, len1,\n\t\t\t\t\t\t\t\t\t\t\t  arg2, len2,\n\t\t\t\t\t\t\t\t\t\t\t  &status);\n\t\t\t\t\tif (U_FAILURE(status))\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errmsg(\"collation failed: %s\", u_errorName(status))));\n\t\t\t\t}\n\t\t\t\telse\n#endif\n\t\t\t\t{\n\t\t\t\t\tint32_t\t\tulen1,\n\t\t\t\t\t\t\t\tulen2;\n\t\t\t\t\tUChar\t   *uchar1,\n\t\t\t\t\t\t\t   *uchar2;\n\n\t\t\t\t\tulen1 = icu_to_uchar(&uchar1, arg1, len1);\n\t\t\t\t\tulen2 = icu_to_uchar(&uchar2, arg2, len2);\n\n\t\t\t\t\tresult = ucol_strcoll(mylocale->info.icu.ucol,\n\t\t\t\t\t\t\t\t\t\t  uchar1, ulen1,\n\t\t\t\t\t\t\t\t\t\t  uchar2, ulen2);\n\n\t\t\t\t\tpfree(uchar1);\n\t\t\t\t\tpfree(uchar2);\n\t\t\t\t}\n#else\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t\t/* shouldn't happen */\n\t\t\t\telog(ERROR, \"unsupported collprovider: %c\", mylocale->provider);\n#endif\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t}\n\t\t\telse\n\t\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\t\tresult = strcoll_l(a1p, a2p, mylocale->info.lt);\n#else\n\t\t\t\t/* shouldn't happen */\n\t\t\t\telog(ERROR, \"unsupported collprovider: %c\", mylocale->provider);\n#endif\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tresult = strcoll(a1p, a2p);\n\n\t\t/*\n\t\t * In some locales strcoll() can claim that nonidentical strings are\n\t\t * equal.  Believing that would be bad news for a number of reasons,\n\t\t * so we follow Perl's lead and sort \"equal\" strings according to\n\t\t * strcmp().\n\t\t */\n\t\tif (result == 0)\n\t\t\tresult = strcmp(a1p, a2p);\n\n\t\tif (a1p != a1buf)\n\t\t\tpfree(a1p);\n\t\tif (a2p != a2buf)\n\t\t\tpfree(a2p);\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GET_COLLATION",
          "args": [],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "arg2"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "arg1"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcTruelen",
          "args": [
            "arg2"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "bcTruelen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
          "lines": "653-657",
          "snippet": "static inline int\nbcTruelen(BpChar *arg)\n{\n\treturn bpchartruelen(VARDATA_ANY(arg), VARSIZE_ANY_EXHDR(arg));\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic inline int\nbcTruelen(BpChar *arg)\n{\n\treturn bpchartruelen(VARDATA_ANY(arg), VARSIZE_ANY_EXHDR(arg));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BPCHAR_PP",
          "args": [
            "1"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BPCHAR_PP",
          "args": [
            "0"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nbpchargt(PG_FUNCTION_ARGS)\n{\n\tBpChar\t   *arg1 = PG_GETARG_BPCHAR_PP(0);\n\tBpChar\t   *arg2 = PG_GETARG_BPCHAR_PP(1);\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\tint\t\t\tcmp;\n\n\tlen1 = bcTruelen(arg1);\n\tlen2 = bcTruelen(arg2);\n\n\tcmp = varstr_cmp(VARDATA_ANY(arg1), len1, VARDATA_ANY(arg2), len2,\n\t\t\t\t\t PG_GET_COLLATION());\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_BOOL(cmp > 0);\n}"
  },
  {
    "function_name": "bpcharle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
    "lines": "785-804",
    "snippet": "Datum\nbpcharle(PG_FUNCTION_ARGS)\n{\n\tBpChar\t   *arg1 = PG_GETARG_BPCHAR_PP(0);\n\tBpChar\t   *arg2 = PG_GETARG_BPCHAR_PP(1);\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\tint\t\t\tcmp;\n\n\tlen1 = bcTruelen(arg1);\n\tlen2 = bcTruelen(arg2);\n\n\tcmp = varstr_cmp(VARDATA_ANY(arg1), len1, VARDATA_ANY(arg2), len2,\n\t\t\t\t\t PG_GET_COLLATION());\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_BOOL(cmp <= 0);\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "cmp <= 0"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg2",
            "1"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg1",
            "0"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "varstr_cmp",
          "args": [
            "VARDATA_ANY(arg1)",
            "len1",
            "VARDATA_ANY(arg2)",
            "len2",
            "PG_GET_COLLATION()"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "varstr_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "1380-1609",
          "snippet": "int\nvarstr_cmp(const char *arg1, int len1, const char *arg2, int len2, Oid collid)\n{\n\tint\t\t\tresult;\n\n\t/*\n\t * Unfortunately, there is no strncoll(), so in the non-C locale case we\n\t * have to do some memory copying.  This turns out to be significantly\n\t * slower, so we optimize the case where LC_COLLATE is C.  We also try to\n\t * optimize relatively-short strings by avoiding palloc/pfree overhead.\n\t */\n\tif (lc_collate_is_c(collid))\n\t{\n\t\tresult = memcmp(arg1, arg2, Min(len1, len2));\n\t\tif ((result == 0) && (len1 != len2))\n\t\t\tresult = (len1 < len2) ? -1 : 1;\n\t}\n\telse\n\t{\n\t\tchar\t\ta1buf[TEXTBUFLEN];\n\t\tchar\t\ta2buf[TEXTBUFLEN];\n\t\tchar\t   *a1p,\n\t\t\t\t   *a2p;\n\t\tpg_locale_t mylocale = 0;\n\n\t\tif (collid != DEFAULT_COLLATION_OID)\n\t\t{\n\t\t\tif (!OidIsValid(collid))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This typically means that the parser could not resolve a\n\t\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t\t errmsg(\"could not determine which collation to use for string comparison\"),\n\t\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t\t}\n\t\t\tmylocale = pg_newlocale_from_collation(collid);\n\t\t}\n\n\t\t/*\n\t\t * memcmp() can't tell us which of two unequal strings sorts first,\n\t\t * but it's a cheap way to tell if they're equal.  Testing shows that\n\t\t * memcmp() followed by strcoll() is only trivially slower than\n\t\t * strcoll() by itself, so we don't lose much if this doesn't work out\n\t\t * very often, and if it does - for example, because there are many\n\t\t * equal strings in the input - then we win big by avoiding expensive\n\t\t * collation-aware comparisons.\n\t\t */\n\t\tif (len1 == len2 && memcmp(arg1, arg2, len1) == 0)\n\t\t\treturn 0;\n\n#ifdef WIN32\n\t\t/* Win32 does not have UTF-8, so we need to map to UTF-16 */\n\t\tif (GetDatabaseEncoding() == PG_UTF8\n\t\t\t&& (!mylocale || mylocale->provider == COLLPROVIDER_LIBC))\n\t\t{\n\t\t\tint\t\t\ta1len;\n\t\t\tint\t\t\ta2len;\n\t\t\tint\t\t\tr;\n\n\t\t\tif (len1 >= TEXTBUFLEN / 2)\n\t\t\t{\n\t\t\t\ta1len = len1 * 2 + 2;\n\t\t\t\ta1p = palloc(a1len);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta1len = TEXTBUFLEN;\n\t\t\t\ta1p = a1buf;\n\t\t\t}\n\t\t\tif (len2 >= TEXTBUFLEN / 2)\n\t\t\t{\n\t\t\t\ta2len = len2 * 2 + 2;\n\t\t\t\ta2p = palloc(a2len);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta2len = TEXTBUFLEN;\n\t\t\t\ta2p = a2buf;\n\t\t\t}\n\n\t\t\t/* stupid Microsloth API does not work for zero-length input */\n\t\t\tif (len1 == 0)\n\t\t\t\tr = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = MultiByteToWideChar(CP_UTF8, 0, arg1, len1,\n\t\t\t\t\t\t\t\t\t\t(LPWSTR) a1p, a1len / 2);\n\t\t\t\tif (!r)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errmsg(\"could not convert string to UTF-16: error code %lu\",\n\t\t\t\t\t\t\t\t\tGetLastError())));\n\t\t\t}\n\t\t\t((LPWSTR) a1p)[r] = 0;\n\n\t\t\tif (len2 == 0)\n\t\t\t\tr = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = MultiByteToWideChar(CP_UTF8, 0, arg2, len2,\n\t\t\t\t\t\t\t\t\t\t(LPWSTR) a2p, a2len / 2);\n\t\t\t\tif (!r)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errmsg(\"could not convert string to UTF-16: error code %lu\",\n\t\t\t\t\t\t\t\t\tGetLastError())));\n\t\t\t}\n\t\t\t((LPWSTR) a2p)[r] = 0;\n\n\t\t\terrno = 0;\n#ifdef HAVE_LOCALE_T\n\t\t\tif (mylocale)\n\t\t\t\tresult = wcscoll_l((LPWSTR) a1p, (LPWSTR) a2p, mylocale->info.lt);\n\t\t\telse\n#endif\n\t\t\t\tresult = wcscoll((LPWSTR) a1p, (LPWSTR) a2p);\n\t\t\tif (result == 2147483647)\t/* _NLSCMPERROR; missing from mingw\n\t\t\t\t\t\t\t\t\t\t * headers */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errmsg(\"could not compare Unicode strings: %m\")));\n\n\t\t\t/*\n\t\t\t * In some locales wcscoll() can claim that nonidentical strings\n\t\t\t * are equal.  Believing that would be bad news for a number of\n\t\t\t * reasons, so we follow Perl's lead and sort \"equal\" strings\n\t\t\t * according to strcmp (on the UTF-8 representation).\n\t\t\t */\n\t\t\tif (result == 0)\n\t\t\t{\n\t\t\t\tresult = memcmp(arg1, arg2, Min(len1, len2));\n\t\t\t\tif ((result == 0) && (len1 != len2))\n\t\t\t\t\tresult = (len1 < len2) ? -1 : 1;\n\t\t\t}\n\n\t\t\tif (a1p != a1buf)\n\t\t\t\tpfree(a1p);\n\t\t\tif (a2p != a2buf)\n\t\t\t\tpfree(a2p);\n\n\t\t\treturn result;\n\t\t}\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\n\t\tif (len1 >= TEXTBUFLEN)\n\t\t\ta1p = (char *) palloc(len1 + 1);\n\t\telse\n\t\t\ta1p = a1buf;\n\t\tif (len2 >= TEXTBUFLEN)\n\t\t\ta2p = (char *) palloc(len2 + 1);\n\t\telse\n\t\t\ta2p = a2buf;\n\n\t\tmemcpy(a1p, arg1, len1);\n\t\ta1p[len1] = '\\0';\n\t\tmemcpy(a2p, arg2, len2);\n\t\ta2p[len2] = '\\0';\n\n\t\tif (mylocale)\n\t\t{\n\t\t\tif (mylocale->provider == COLLPROVIDER_ICU)\n\t\t\t{\n#ifdef USE_ICU\n#ifdef HAVE_UCOL_STRCOLLUTF8\n\t\t\t\tif (GetDatabaseEncoding() == PG_UTF8)\n\t\t\t\t{\n\t\t\t\t\tUErrorCode\tstatus;\n\n\t\t\t\t\tstatus = U_ZERO_ERROR;\n\t\t\t\t\tresult = ucol_strcollUTF8(mylocale->info.icu.ucol,\n\t\t\t\t\t\t\t\t\t\t\t  arg1, len1,\n\t\t\t\t\t\t\t\t\t\t\t  arg2, len2,\n\t\t\t\t\t\t\t\t\t\t\t  &status);\n\t\t\t\t\tif (U_FAILURE(status))\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errmsg(\"collation failed: %s\", u_errorName(status))));\n\t\t\t\t}\n\t\t\t\telse\n#endif\n\t\t\t\t{\n\t\t\t\t\tint32_t\t\tulen1,\n\t\t\t\t\t\t\t\tulen2;\n\t\t\t\t\tUChar\t   *uchar1,\n\t\t\t\t\t\t\t   *uchar2;\n\n\t\t\t\t\tulen1 = icu_to_uchar(&uchar1, arg1, len1);\n\t\t\t\t\tulen2 = icu_to_uchar(&uchar2, arg2, len2);\n\n\t\t\t\t\tresult = ucol_strcoll(mylocale->info.icu.ucol,\n\t\t\t\t\t\t\t\t\t\t  uchar1, ulen1,\n\t\t\t\t\t\t\t\t\t\t  uchar2, ulen2);\n\n\t\t\t\t\tpfree(uchar1);\n\t\t\t\t\tpfree(uchar2);\n\t\t\t\t}\n#else\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t\t/* shouldn't happen */\n\t\t\t\telog(ERROR, \"unsupported collprovider: %c\", mylocale->provider);\n#endif\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t}\n\t\t\telse\n\t\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\t\tresult = strcoll_l(a1p, a2p, mylocale->info.lt);\n#else\n\t\t\t\t/* shouldn't happen */\n\t\t\t\telog(ERROR, \"unsupported collprovider: %c\", mylocale->provider);\n#endif\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tresult = strcoll(a1p, a2p);\n\n\t\t/*\n\t\t * In some locales strcoll() can claim that nonidentical strings are\n\t\t * equal.  Believing that would be bad news for a number of reasons,\n\t\t * so we follow Perl's lead and sort \"equal\" strings according to\n\t\t * strcmp().\n\t\t */\n\t\tif (result == 0)\n\t\t\tresult = strcmp(a1p, a2p);\n\n\t\tif (a1p != a1buf)\n\t\t\tpfree(a1p);\n\t\tif (a2p != a2buf)\n\t\t\tpfree(a2p);\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TEXTBUFLEN\t\t1024"
          ],
          "globals_used": [
            "static int\ttext_cmp(text *arg1, text *arg2, Oid collid);",
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define TEXTBUFLEN\t\t1024\n\nstatic int\ttext_cmp(text *arg1, text *arg2, Oid collid);\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nint\nvarstr_cmp(const char *arg1, int len1, const char *arg2, int len2, Oid collid)\n{\n\tint\t\t\tresult;\n\n\t/*\n\t * Unfortunately, there is no strncoll(), so in the non-C locale case we\n\t * have to do some memory copying.  This turns out to be significantly\n\t * slower, so we optimize the case where LC_COLLATE is C.  We also try to\n\t * optimize relatively-short strings by avoiding palloc/pfree overhead.\n\t */\n\tif (lc_collate_is_c(collid))\n\t{\n\t\tresult = memcmp(arg1, arg2, Min(len1, len2));\n\t\tif ((result == 0) && (len1 != len2))\n\t\t\tresult = (len1 < len2) ? -1 : 1;\n\t}\n\telse\n\t{\n\t\tchar\t\ta1buf[TEXTBUFLEN];\n\t\tchar\t\ta2buf[TEXTBUFLEN];\n\t\tchar\t   *a1p,\n\t\t\t\t   *a2p;\n\t\tpg_locale_t mylocale = 0;\n\n\t\tif (collid != DEFAULT_COLLATION_OID)\n\t\t{\n\t\t\tif (!OidIsValid(collid))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This typically means that the parser could not resolve a\n\t\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t\t errmsg(\"could not determine which collation to use for string comparison\"),\n\t\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t\t}\n\t\t\tmylocale = pg_newlocale_from_collation(collid);\n\t\t}\n\n\t\t/*\n\t\t * memcmp() can't tell us which of two unequal strings sorts first,\n\t\t * but it's a cheap way to tell if they're equal.  Testing shows that\n\t\t * memcmp() followed by strcoll() is only trivially slower than\n\t\t * strcoll() by itself, so we don't lose much if this doesn't work out\n\t\t * very often, and if it does - for example, because there are many\n\t\t * equal strings in the input - then we win big by avoiding expensive\n\t\t * collation-aware comparisons.\n\t\t */\n\t\tif (len1 == len2 && memcmp(arg1, arg2, len1) == 0)\n\t\t\treturn 0;\n\n#ifdef WIN32\n\t\t/* Win32 does not have UTF-8, so we need to map to UTF-16 */\n\t\tif (GetDatabaseEncoding() == PG_UTF8\n\t\t\t&& (!mylocale || mylocale->provider == COLLPROVIDER_LIBC))\n\t\t{\n\t\t\tint\t\t\ta1len;\n\t\t\tint\t\t\ta2len;\n\t\t\tint\t\t\tr;\n\n\t\t\tif (len1 >= TEXTBUFLEN / 2)\n\t\t\t{\n\t\t\t\ta1len = len1 * 2 + 2;\n\t\t\t\ta1p = palloc(a1len);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta1len = TEXTBUFLEN;\n\t\t\t\ta1p = a1buf;\n\t\t\t}\n\t\t\tif (len2 >= TEXTBUFLEN / 2)\n\t\t\t{\n\t\t\t\ta2len = len2 * 2 + 2;\n\t\t\t\ta2p = palloc(a2len);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta2len = TEXTBUFLEN;\n\t\t\t\ta2p = a2buf;\n\t\t\t}\n\n\t\t\t/* stupid Microsloth API does not work for zero-length input */\n\t\t\tif (len1 == 0)\n\t\t\t\tr = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = MultiByteToWideChar(CP_UTF8, 0, arg1, len1,\n\t\t\t\t\t\t\t\t\t\t(LPWSTR) a1p, a1len / 2);\n\t\t\t\tif (!r)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errmsg(\"could not convert string to UTF-16: error code %lu\",\n\t\t\t\t\t\t\t\t\tGetLastError())));\n\t\t\t}\n\t\t\t((LPWSTR) a1p)[r] = 0;\n\n\t\t\tif (len2 == 0)\n\t\t\t\tr = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = MultiByteToWideChar(CP_UTF8, 0, arg2, len2,\n\t\t\t\t\t\t\t\t\t\t(LPWSTR) a2p, a2len / 2);\n\t\t\t\tif (!r)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errmsg(\"could not convert string to UTF-16: error code %lu\",\n\t\t\t\t\t\t\t\t\tGetLastError())));\n\t\t\t}\n\t\t\t((LPWSTR) a2p)[r] = 0;\n\n\t\t\terrno = 0;\n#ifdef HAVE_LOCALE_T\n\t\t\tif (mylocale)\n\t\t\t\tresult = wcscoll_l((LPWSTR) a1p, (LPWSTR) a2p, mylocale->info.lt);\n\t\t\telse\n#endif\n\t\t\t\tresult = wcscoll((LPWSTR) a1p, (LPWSTR) a2p);\n\t\t\tif (result == 2147483647)\t/* _NLSCMPERROR; missing from mingw\n\t\t\t\t\t\t\t\t\t\t * headers */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errmsg(\"could not compare Unicode strings: %m\")));\n\n\t\t\t/*\n\t\t\t * In some locales wcscoll() can claim that nonidentical strings\n\t\t\t * are equal.  Believing that would be bad news for a number of\n\t\t\t * reasons, so we follow Perl's lead and sort \"equal\" strings\n\t\t\t * according to strcmp (on the UTF-8 representation).\n\t\t\t */\n\t\t\tif (result == 0)\n\t\t\t{\n\t\t\t\tresult = memcmp(arg1, arg2, Min(len1, len2));\n\t\t\t\tif ((result == 0) && (len1 != len2))\n\t\t\t\t\tresult = (len1 < len2) ? -1 : 1;\n\t\t\t}\n\n\t\t\tif (a1p != a1buf)\n\t\t\t\tpfree(a1p);\n\t\t\tif (a2p != a2buf)\n\t\t\t\tpfree(a2p);\n\n\t\t\treturn result;\n\t\t}\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\n\t\tif (len1 >= TEXTBUFLEN)\n\t\t\ta1p = (char *) palloc(len1 + 1);\n\t\telse\n\t\t\ta1p = a1buf;\n\t\tif (len2 >= TEXTBUFLEN)\n\t\t\ta2p = (char *) palloc(len2 + 1);\n\t\telse\n\t\t\ta2p = a2buf;\n\n\t\tmemcpy(a1p, arg1, len1);\n\t\ta1p[len1] = '\\0';\n\t\tmemcpy(a2p, arg2, len2);\n\t\ta2p[len2] = '\\0';\n\n\t\tif (mylocale)\n\t\t{\n\t\t\tif (mylocale->provider == COLLPROVIDER_ICU)\n\t\t\t{\n#ifdef USE_ICU\n#ifdef HAVE_UCOL_STRCOLLUTF8\n\t\t\t\tif (GetDatabaseEncoding() == PG_UTF8)\n\t\t\t\t{\n\t\t\t\t\tUErrorCode\tstatus;\n\n\t\t\t\t\tstatus = U_ZERO_ERROR;\n\t\t\t\t\tresult = ucol_strcollUTF8(mylocale->info.icu.ucol,\n\t\t\t\t\t\t\t\t\t\t\t  arg1, len1,\n\t\t\t\t\t\t\t\t\t\t\t  arg2, len2,\n\t\t\t\t\t\t\t\t\t\t\t  &status);\n\t\t\t\t\tif (U_FAILURE(status))\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errmsg(\"collation failed: %s\", u_errorName(status))));\n\t\t\t\t}\n\t\t\t\telse\n#endif\n\t\t\t\t{\n\t\t\t\t\tint32_t\t\tulen1,\n\t\t\t\t\t\t\t\tulen2;\n\t\t\t\t\tUChar\t   *uchar1,\n\t\t\t\t\t\t\t   *uchar2;\n\n\t\t\t\t\tulen1 = icu_to_uchar(&uchar1, arg1, len1);\n\t\t\t\t\tulen2 = icu_to_uchar(&uchar2, arg2, len2);\n\n\t\t\t\t\tresult = ucol_strcoll(mylocale->info.icu.ucol,\n\t\t\t\t\t\t\t\t\t\t  uchar1, ulen1,\n\t\t\t\t\t\t\t\t\t\t  uchar2, ulen2);\n\n\t\t\t\t\tpfree(uchar1);\n\t\t\t\t\tpfree(uchar2);\n\t\t\t\t}\n#else\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t\t/* shouldn't happen */\n\t\t\t\telog(ERROR, \"unsupported collprovider: %c\", mylocale->provider);\n#endif\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t}\n\t\t\telse\n\t\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\t\tresult = strcoll_l(a1p, a2p, mylocale->info.lt);\n#else\n\t\t\t\t/* shouldn't happen */\n\t\t\t\telog(ERROR, \"unsupported collprovider: %c\", mylocale->provider);\n#endif\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tresult = strcoll(a1p, a2p);\n\n\t\t/*\n\t\t * In some locales strcoll() can claim that nonidentical strings are\n\t\t * equal.  Believing that would be bad news for a number of reasons,\n\t\t * so we follow Perl's lead and sort \"equal\" strings according to\n\t\t * strcmp().\n\t\t */\n\t\tif (result == 0)\n\t\t\tresult = strcmp(a1p, a2p);\n\n\t\tif (a1p != a1buf)\n\t\t\tpfree(a1p);\n\t\tif (a2p != a2buf)\n\t\t\tpfree(a2p);\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GET_COLLATION",
          "args": [],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "arg2"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "arg1"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcTruelen",
          "args": [
            "arg2"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "bcTruelen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
          "lines": "653-657",
          "snippet": "static inline int\nbcTruelen(BpChar *arg)\n{\n\treturn bpchartruelen(VARDATA_ANY(arg), VARSIZE_ANY_EXHDR(arg));\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic inline int\nbcTruelen(BpChar *arg)\n{\n\treturn bpchartruelen(VARDATA_ANY(arg), VARSIZE_ANY_EXHDR(arg));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BPCHAR_PP",
          "args": [
            "1"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BPCHAR_PP",
          "args": [
            "0"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nbpcharle(PG_FUNCTION_ARGS)\n{\n\tBpChar\t   *arg1 = PG_GETARG_BPCHAR_PP(0);\n\tBpChar\t   *arg2 = PG_GETARG_BPCHAR_PP(1);\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\tint\t\t\tcmp;\n\n\tlen1 = bcTruelen(arg1);\n\tlen2 = bcTruelen(arg2);\n\n\tcmp = varstr_cmp(VARDATA_ANY(arg1), len1, VARDATA_ANY(arg2), len2,\n\t\t\t\t\t PG_GET_COLLATION());\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_BOOL(cmp <= 0);\n}"
  },
  {
    "function_name": "bpcharlt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
    "lines": "764-783",
    "snippet": "Datum\nbpcharlt(PG_FUNCTION_ARGS)\n{\n\tBpChar\t   *arg1 = PG_GETARG_BPCHAR_PP(0);\n\tBpChar\t   *arg2 = PG_GETARG_BPCHAR_PP(1);\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\tint\t\t\tcmp;\n\n\tlen1 = bcTruelen(arg1);\n\tlen2 = bcTruelen(arg2);\n\n\tcmp = varstr_cmp(VARDATA_ANY(arg1), len1, VARDATA_ANY(arg2), len2,\n\t\t\t\t\t PG_GET_COLLATION());\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_BOOL(cmp < 0);\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "cmp < 0"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg2",
            "1"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg1",
            "0"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "varstr_cmp",
          "args": [
            "VARDATA_ANY(arg1)",
            "len1",
            "VARDATA_ANY(arg2)",
            "len2",
            "PG_GET_COLLATION()"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "varstr_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "1380-1609",
          "snippet": "int\nvarstr_cmp(const char *arg1, int len1, const char *arg2, int len2, Oid collid)\n{\n\tint\t\t\tresult;\n\n\t/*\n\t * Unfortunately, there is no strncoll(), so in the non-C locale case we\n\t * have to do some memory copying.  This turns out to be significantly\n\t * slower, so we optimize the case where LC_COLLATE is C.  We also try to\n\t * optimize relatively-short strings by avoiding palloc/pfree overhead.\n\t */\n\tif (lc_collate_is_c(collid))\n\t{\n\t\tresult = memcmp(arg1, arg2, Min(len1, len2));\n\t\tif ((result == 0) && (len1 != len2))\n\t\t\tresult = (len1 < len2) ? -1 : 1;\n\t}\n\telse\n\t{\n\t\tchar\t\ta1buf[TEXTBUFLEN];\n\t\tchar\t\ta2buf[TEXTBUFLEN];\n\t\tchar\t   *a1p,\n\t\t\t\t   *a2p;\n\t\tpg_locale_t mylocale = 0;\n\n\t\tif (collid != DEFAULT_COLLATION_OID)\n\t\t{\n\t\t\tif (!OidIsValid(collid))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This typically means that the parser could not resolve a\n\t\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t\t errmsg(\"could not determine which collation to use for string comparison\"),\n\t\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t\t}\n\t\t\tmylocale = pg_newlocale_from_collation(collid);\n\t\t}\n\n\t\t/*\n\t\t * memcmp() can't tell us which of two unequal strings sorts first,\n\t\t * but it's a cheap way to tell if they're equal.  Testing shows that\n\t\t * memcmp() followed by strcoll() is only trivially slower than\n\t\t * strcoll() by itself, so we don't lose much if this doesn't work out\n\t\t * very often, and if it does - for example, because there are many\n\t\t * equal strings in the input - then we win big by avoiding expensive\n\t\t * collation-aware comparisons.\n\t\t */\n\t\tif (len1 == len2 && memcmp(arg1, arg2, len1) == 0)\n\t\t\treturn 0;\n\n#ifdef WIN32\n\t\t/* Win32 does not have UTF-8, so we need to map to UTF-16 */\n\t\tif (GetDatabaseEncoding() == PG_UTF8\n\t\t\t&& (!mylocale || mylocale->provider == COLLPROVIDER_LIBC))\n\t\t{\n\t\t\tint\t\t\ta1len;\n\t\t\tint\t\t\ta2len;\n\t\t\tint\t\t\tr;\n\n\t\t\tif (len1 >= TEXTBUFLEN / 2)\n\t\t\t{\n\t\t\t\ta1len = len1 * 2 + 2;\n\t\t\t\ta1p = palloc(a1len);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta1len = TEXTBUFLEN;\n\t\t\t\ta1p = a1buf;\n\t\t\t}\n\t\t\tif (len2 >= TEXTBUFLEN / 2)\n\t\t\t{\n\t\t\t\ta2len = len2 * 2 + 2;\n\t\t\t\ta2p = palloc(a2len);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta2len = TEXTBUFLEN;\n\t\t\t\ta2p = a2buf;\n\t\t\t}\n\n\t\t\t/* stupid Microsloth API does not work for zero-length input */\n\t\t\tif (len1 == 0)\n\t\t\t\tr = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = MultiByteToWideChar(CP_UTF8, 0, arg1, len1,\n\t\t\t\t\t\t\t\t\t\t(LPWSTR) a1p, a1len / 2);\n\t\t\t\tif (!r)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errmsg(\"could not convert string to UTF-16: error code %lu\",\n\t\t\t\t\t\t\t\t\tGetLastError())));\n\t\t\t}\n\t\t\t((LPWSTR) a1p)[r] = 0;\n\n\t\t\tif (len2 == 0)\n\t\t\t\tr = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = MultiByteToWideChar(CP_UTF8, 0, arg2, len2,\n\t\t\t\t\t\t\t\t\t\t(LPWSTR) a2p, a2len / 2);\n\t\t\t\tif (!r)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errmsg(\"could not convert string to UTF-16: error code %lu\",\n\t\t\t\t\t\t\t\t\tGetLastError())));\n\t\t\t}\n\t\t\t((LPWSTR) a2p)[r] = 0;\n\n\t\t\terrno = 0;\n#ifdef HAVE_LOCALE_T\n\t\t\tif (mylocale)\n\t\t\t\tresult = wcscoll_l((LPWSTR) a1p, (LPWSTR) a2p, mylocale->info.lt);\n\t\t\telse\n#endif\n\t\t\t\tresult = wcscoll((LPWSTR) a1p, (LPWSTR) a2p);\n\t\t\tif (result == 2147483647)\t/* _NLSCMPERROR; missing from mingw\n\t\t\t\t\t\t\t\t\t\t * headers */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errmsg(\"could not compare Unicode strings: %m\")));\n\n\t\t\t/*\n\t\t\t * In some locales wcscoll() can claim that nonidentical strings\n\t\t\t * are equal.  Believing that would be bad news for a number of\n\t\t\t * reasons, so we follow Perl's lead and sort \"equal\" strings\n\t\t\t * according to strcmp (on the UTF-8 representation).\n\t\t\t */\n\t\t\tif (result == 0)\n\t\t\t{\n\t\t\t\tresult = memcmp(arg1, arg2, Min(len1, len2));\n\t\t\t\tif ((result == 0) && (len1 != len2))\n\t\t\t\t\tresult = (len1 < len2) ? -1 : 1;\n\t\t\t}\n\n\t\t\tif (a1p != a1buf)\n\t\t\t\tpfree(a1p);\n\t\t\tif (a2p != a2buf)\n\t\t\t\tpfree(a2p);\n\n\t\t\treturn result;\n\t\t}\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\n\t\tif (len1 >= TEXTBUFLEN)\n\t\t\ta1p = (char *) palloc(len1 + 1);\n\t\telse\n\t\t\ta1p = a1buf;\n\t\tif (len2 >= TEXTBUFLEN)\n\t\t\ta2p = (char *) palloc(len2 + 1);\n\t\telse\n\t\t\ta2p = a2buf;\n\n\t\tmemcpy(a1p, arg1, len1);\n\t\ta1p[len1] = '\\0';\n\t\tmemcpy(a2p, arg2, len2);\n\t\ta2p[len2] = '\\0';\n\n\t\tif (mylocale)\n\t\t{\n\t\t\tif (mylocale->provider == COLLPROVIDER_ICU)\n\t\t\t{\n#ifdef USE_ICU\n#ifdef HAVE_UCOL_STRCOLLUTF8\n\t\t\t\tif (GetDatabaseEncoding() == PG_UTF8)\n\t\t\t\t{\n\t\t\t\t\tUErrorCode\tstatus;\n\n\t\t\t\t\tstatus = U_ZERO_ERROR;\n\t\t\t\t\tresult = ucol_strcollUTF8(mylocale->info.icu.ucol,\n\t\t\t\t\t\t\t\t\t\t\t  arg1, len1,\n\t\t\t\t\t\t\t\t\t\t\t  arg2, len2,\n\t\t\t\t\t\t\t\t\t\t\t  &status);\n\t\t\t\t\tif (U_FAILURE(status))\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errmsg(\"collation failed: %s\", u_errorName(status))));\n\t\t\t\t}\n\t\t\t\telse\n#endif\n\t\t\t\t{\n\t\t\t\t\tint32_t\t\tulen1,\n\t\t\t\t\t\t\t\tulen2;\n\t\t\t\t\tUChar\t   *uchar1,\n\t\t\t\t\t\t\t   *uchar2;\n\n\t\t\t\t\tulen1 = icu_to_uchar(&uchar1, arg1, len1);\n\t\t\t\t\tulen2 = icu_to_uchar(&uchar2, arg2, len2);\n\n\t\t\t\t\tresult = ucol_strcoll(mylocale->info.icu.ucol,\n\t\t\t\t\t\t\t\t\t\t  uchar1, ulen1,\n\t\t\t\t\t\t\t\t\t\t  uchar2, ulen2);\n\n\t\t\t\t\tpfree(uchar1);\n\t\t\t\t\tpfree(uchar2);\n\t\t\t\t}\n#else\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t\t/* shouldn't happen */\n\t\t\t\telog(ERROR, \"unsupported collprovider: %c\", mylocale->provider);\n#endif\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t}\n\t\t\telse\n\t\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\t\tresult = strcoll_l(a1p, a2p, mylocale->info.lt);\n#else\n\t\t\t\t/* shouldn't happen */\n\t\t\t\telog(ERROR, \"unsupported collprovider: %c\", mylocale->provider);\n#endif\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tresult = strcoll(a1p, a2p);\n\n\t\t/*\n\t\t * In some locales strcoll() can claim that nonidentical strings are\n\t\t * equal.  Believing that would be bad news for a number of reasons,\n\t\t * so we follow Perl's lead and sort \"equal\" strings according to\n\t\t * strcmp().\n\t\t */\n\t\tif (result == 0)\n\t\t\tresult = strcmp(a1p, a2p);\n\n\t\tif (a1p != a1buf)\n\t\t\tpfree(a1p);\n\t\tif (a2p != a2buf)\n\t\t\tpfree(a2p);\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TEXTBUFLEN\t\t1024"
          ],
          "globals_used": [
            "static int\ttext_cmp(text *arg1, text *arg2, Oid collid);",
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define TEXTBUFLEN\t\t1024\n\nstatic int\ttext_cmp(text *arg1, text *arg2, Oid collid);\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nint\nvarstr_cmp(const char *arg1, int len1, const char *arg2, int len2, Oid collid)\n{\n\tint\t\t\tresult;\n\n\t/*\n\t * Unfortunately, there is no strncoll(), so in the non-C locale case we\n\t * have to do some memory copying.  This turns out to be significantly\n\t * slower, so we optimize the case where LC_COLLATE is C.  We also try to\n\t * optimize relatively-short strings by avoiding palloc/pfree overhead.\n\t */\n\tif (lc_collate_is_c(collid))\n\t{\n\t\tresult = memcmp(arg1, arg2, Min(len1, len2));\n\t\tif ((result == 0) && (len1 != len2))\n\t\t\tresult = (len1 < len2) ? -1 : 1;\n\t}\n\telse\n\t{\n\t\tchar\t\ta1buf[TEXTBUFLEN];\n\t\tchar\t\ta2buf[TEXTBUFLEN];\n\t\tchar\t   *a1p,\n\t\t\t\t   *a2p;\n\t\tpg_locale_t mylocale = 0;\n\n\t\tif (collid != DEFAULT_COLLATION_OID)\n\t\t{\n\t\t\tif (!OidIsValid(collid))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This typically means that the parser could not resolve a\n\t\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t\t errmsg(\"could not determine which collation to use for string comparison\"),\n\t\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t\t}\n\t\t\tmylocale = pg_newlocale_from_collation(collid);\n\t\t}\n\n\t\t/*\n\t\t * memcmp() can't tell us which of two unequal strings sorts first,\n\t\t * but it's a cheap way to tell if they're equal.  Testing shows that\n\t\t * memcmp() followed by strcoll() is only trivially slower than\n\t\t * strcoll() by itself, so we don't lose much if this doesn't work out\n\t\t * very often, and if it does - for example, because there are many\n\t\t * equal strings in the input - then we win big by avoiding expensive\n\t\t * collation-aware comparisons.\n\t\t */\n\t\tif (len1 == len2 && memcmp(arg1, arg2, len1) == 0)\n\t\t\treturn 0;\n\n#ifdef WIN32\n\t\t/* Win32 does not have UTF-8, so we need to map to UTF-16 */\n\t\tif (GetDatabaseEncoding() == PG_UTF8\n\t\t\t&& (!mylocale || mylocale->provider == COLLPROVIDER_LIBC))\n\t\t{\n\t\t\tint\t\t\ta1len;\n\t\t\tint\t\t\ta2len;\n\t\t\tint\t\t\tr;\n\n\t\t\tif (len1 >= TEXTBUFLEN / 2)\n\t\t\t{\n\t\t\t\ta1len = len1 * 2 + 2;\n\t\t\t\ta1p = palloc(a1len);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta1len = TEXTBUFLEN;\n\t\t\t\ta1p = a1buf;\n\t\t\t}\n\t\t\tif (len2 >= TEXTBUFLEN / 2)\n\t\t\t{\n\t\t\t\ta2len = len2 * 2 + 2;\n\t\t\t\ta2p = palloc(a2len);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta2len = TEXTBUFLEN;\n\t\t\t\ta2p = a2buf;\n\t\t\t}\n\n\t\t\t/* stupid Microsloth API does not work for zero-length input */\n\t\t\tif (len1 == 0)\n\t\t\t\tr = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = MultiByteToWideChar(CP_UTF8, 0, arg1, len1,\n\t\t\t\t\t\t\t\t\t\t(LPWSTR) a1p, a1len / 2);\n\t\t\t\tif (!r)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errmsg(\"could not convert string to UTF-16: error code %lu\",\n\t\t\t\t\t\t\t\t\tGetLastError())));\n\t\t\t}\n\t\t\t((LPWSTR) a1p)[r] = 0;\n\n\t\t\tif (len2 == 0)\n\t\t\t\tr = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = MultiByteToWideChar(CP_UTF8, 0, arg2, len2,\n\t\t\t\t\t\t\t\t\t\t(LPWSTR) a2p, a2len / 2);\n\t\t\t\tif (!r)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errmsg(\"could not convert string to UTF-16: error code %lu\",\n\t\t\t\t\t\t\t\t\tGetLastError())));\n\t\t\t}\n\t\t\t((LPWSTR) a2p)[r] = 0;\n\n\t\t\terrno = 0;\n#ifdef HAVE_LOCALE_T\n\t\t\tif (mylocale)\n\t\t\t\tresult = wcscoll_l((LPWSTR) a1p, (LPWSTR) a2p, mylocale->info.lt);\n\t\t\telse\n#endif\n\t\t\t\tresult = wcscoll((LPWSTR) a1p, (LPWSTR) a2p);\n\t\t\tif (result == 2147483647)\t/* _NLSCMPERROR; missing from mingw\n\t\t\t\t\t\t\t\t\t\t * headers */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errmsg(\"could not compare Unicode strings: %m\")));\n\n\t\t\t/*\n\t\t\t * In some locales wcscoll() can claim that nonidentical strings\n\t\t\t * are equal.  Believing that would be bad news for a number of\n\t\t\t * reasons, so we follow Perl's lead and sort \"equal\" strings\n\t\t\t * according to strcmp (on the UTF-8 representation).\n\t\t\t */\n\t\t\tif (result == 0)\n\t\t\t{\n\t\t\t\tresult = memcmp(arg1, arg2, Min(len1, len2));\n\t\t\t\tif ((result == 0) && (len1 != len2))\n\t\t\t\t\tresult = (len1 < len2) ? -1 : 1;\n\t\t\t}\n\n\t\t\tif (a1p != a1buf)\n\t\t\t\tpfree(a1p);\n\t\t\tif (a2p != a2buf)\n\t\t\t\tpfree(a2p);\n\n\t\t\treturn result;\n\t\t}\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\n\t\tif (len1 >= TEXTBUFLEN)\n\t\t\ta1p = (char *) palloc(len1 + 1);\n\t\telse\n\t\t\ta1p = a1buf;\n\t\tif (len2 >= TEXTBUFLEN)\n\t\t\ta2p = (char *) palloc(len2 + 1);\n\t\telse\n\t\t\ta2p = a2buf;\n\n\t\tmemcpy(a1p, arg1, len1);\n\t\ta1p[len1] = '\\0';\n\t\tmemcpy(a2p, arg2, len2);\n\t\ta2p[len2] = '\\0';\n\n\t\tif (mylocale)\n\t\t{\n\t\t\tif (mylocale->provider == COLLPROVIDER_ICU)\n\t\t\t{\n#ifdef USE_ICU\n#ifdef HAVE_UCOL_STRCOLLUTF8\n\t\t\t\tif (GetDatabaseEncoding() == PG_UTF8)\n\t\t\t\t{\n\t\t\t\t\tUErrorCode\tstatus;\n\n\t\t\t\t\tstatus = U_ZERO_ERROR;\n\t\t\t\t\tresult = ucol_strcollUTF8(mylocale->info.icu.ucol,\n\t\t\t\t\t\t\t\t\t\t\t  arg1, len1,\n\t\t\t\t\t\t\t\t\t\t\t  arg2, len2,\n\t\t\t\t\t\t\t\t\t\t\t  &status);\n\t\t\t\t\tif (U_FAILURE(status))\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errmsg(\"collation failed: %s\", u_errorName(status))));\n\t\t\t\t}\n\t\t\t\telse\n#endif\n\t\t\t\t{\n\t\t\t\t\tint32_t\t\tulen1,\n\t\t\t\t\t\t\t\tulen2;\n\t\t\t\t\tUChar\t   *uchar1,\n\t\t\t\t\t\t\t   *uchar2;\n\n\t\t\t\t\tulen1 = icu_to_uchar(&uchar1, arg1, len1);\n\t\t\t\t\tulen2 = icu_to_uchar(&uchar2, arg2, len2);\n\n\t\t\t\t\tresult = ucol_strcoll(mylocale->info.icu.ucol,\n\t\t\t\t\t\t\t\t\t\t  uchar1, ulen1,\n\t\t\t\t\t\t\t\t\t\t  uchar2, ulen2);\n\n\t\t\t\t\tpfree(uchar1);\n\t\t\t\t\tpfree(uchar2);\n\t\t\t\t}\n#else\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t\t/* shouldn't happen */\n\t\t\t\telog(ERROR, \"unsupported collprovider: %c\", mylocale->provider);\n#endif\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t}\n\t\t\telse\n\t\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\t\tresult = strcoll_l(a1p, a2p, mylocale->info.lt);\n#else\n\t\t\t\t/* shouldn't happen */\n\t\t\t\telog(ERROR, \"unsupported collprovider: %c\", mylocale->provider);\n#endif\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tresult = strcoll(a1p, a2p);\n\n\t\t/*\n\t\t * In some locales strcoll() can claim that nonidentical strings are\n\t\t * equal.  Believing that would be bad news for a number of reasons,\n\t\t * so we follow Perl's lead and sort \"equal\" strings according to\n\t\t * strcmp().\n\t\t */\n\t\tif (result == 0)\n\t\t\tresult = strcmp(a1p, a2p);\n\n\t\tif (a1p != a1buf)\n\t\t\tpfree(a1p);\n\t\tif (a2p != a2buf)\n\t\t\tpfree(a2p);\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GET_COLLATION",
          "args": [],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "arg2"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "arg1"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcTruelen",
          "args": [
            "arg2"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "bcTruelen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
          "lines": "653-657",
          "snippet": "static inline int\nbcTruelen(BpChar *arg)\n{\n\treturn bpchartruelen(VARDATA_ANY(arg), VARSIZE_ANY_EXHDR(arg));\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic inline int\nbcTruelen(BpChar *arg)\n{\n\treturn bpchartruelen(VARDATA_ANY(arg), VARSIZE_ANY_EXHDR(arg));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BPCHAR_PP",
          "args": [
            "1"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BPCHAR_PP",
          "args": [
            "0"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nbpcharlt(PG_FUNCTION_ARGS)\n{\n\tBpChar\t   *arg1 = PG_GETARG_BPCHAR_PP(0);\n\tBpChar\t   *arg2 = PG_GETARG_BPCHAR_PP(1);\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\tint\t\t\tcmp;\n\n\tlen1 = bcTruelen(arg1);\n\tlen2 = bcTruelen(arg2);\n\n\tcmp = varstr_cmp(VARDATA_ANY(arg1), len1, VARDATA_ANY(arg2), len2,\n\t\t\t\t\t PG_GET_COLLATION());\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_BOOL(cmp < 0);\n}"
  },
  {
    "function_name": "bpcharne",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
    "lines": "737-762",
    "snippet": "Datum\nbpcharne(PG_FUNCTION_ARGS)\n{\n\tBpChar\t   *arg1 = PG_GETARG_BPCHAR_PP(0);\n\tBpChar\t   *arg2 = PG_GETARG_BPCHAR_PP(1);\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\tbool\t\tresult;\n\n\tlen1 = bcTruelen(arg1);\n\tlen2 = bcTruelen(arg2);\n\n\t/*\n\t * Since we only care about equality or not-equality, we can avoid all the\n\t * expense of strcoll() here, and just do bitwise comparison.\n\t */\n\tif (len1 != len2)\n\t\tresult = true;\n\telse\n\t\tresult = (memcmp(VARDATA_ANY(arg1), VARDATA_ANY(arg2), len1) != 0);\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_BOOL(result);\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "result"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg2",
            "1"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg1",
            "0"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "VARDATA_ANY(arg1)",
            "VARDATA_ANY(arg2)",
            "len1"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "arg2"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "arg1"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcTruelen",
          "args": [
            "arg2"
          ],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "bcTruelen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
          "lines": "653-657",
          "snippet": "static inline int\nbcTruelen(BpChar *arg)\n{\n\treturn bpchartruelen(VARDATA_ANY(arg), VARSIZE_ANY_EXHDR(arg));\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic inline int\nbcTruelen(BpChar *arg)\n{\n\treturn bpchartruelen(VARDATA_ANY(arg), VARSIZE_ANY_EXHDR(arg));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BPCHAR_PP",
          "args": [
            "1"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BPCHAR_PP",
          "args": [
            "0"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nbpcharne(PG_FUNCTION_ARGS)\n{\n\tBpChar\t   *arg1 = PG_GETARG_BPCHAR_PP(0);\n\tBpChar\t   *arg2 = PG_GETARG_BPCHAR_PP(1);\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\tbool\t\tresult;\n\n\tlen1 = bcTruelen(arg1);\n\tlen2 = bcTruelen(arg2);\n\n\t/*\n\t * Since we only care about equality or not-equality, we can avoid all the\n\t * expense of strcoll() here, and just do bitwise comparison.\n\t */\n\tif (len1 != len2)\n\t\tresult = true;\n\telse\n\t\tresult = (memcmp(VARDATA_ANY(arg1), VARDATA_ANY(arg2), len1) != 0);\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_BOOL(result);\n}"
  },
  {
    "function_name": "bpchareq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
    "lines": "710-735",
    "snippet": "Datum\nbpchareq(PG_FUNCTION_ARGS)\n{\n\tBpChar\t   *arg1 = PG_GETARG_BPCHAR_PP(0);\n\tBpChar\t   *arg2 = PG_GETARG_BPCHAR_PP(1);\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\tbool\t\tresult;\n\n\tlen1 = bcTruelen(arg1);\n\tlen2 = bcTruelen(arg2);\n\n\t/*\n\t * Since we only care about equality or not-equality, we can avoid all the\n\t * expense of strcoll() here, and just do bitwise comparison.\n\t */\n\tif (len1 != len2)\n\t\tresult = false;\n\telse\n\t\tresult = (memcmp(VARDATA_ANY(arg1), VARDATA_ANY(arg2), len1) == 0);\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_BOOL(result);\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "result"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg2",
            "1"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg1",
            "0"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "VARDATA_ANY(arg1)",
            "VARDATA_ANY(arg2)",
            "len1"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "arg2"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "arg1"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcTruelen",
          "args": [
            "arg2"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "bcTruelen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
          "lines": "653-657",
          "snippet": "static inline int\nbcTruelen(BpChar *arg)\n{\n\treturn bpchartruelen(VARDATA_ANY(arg), VARSIZE_ANY_EXHDR(arg));\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic inline int\nbcTruelen(BpChar *arg)\n{\n\treturn bpchartruelen(VARDATA_ANY(arg), VARSIZE_ANY_EXHDR(arg));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BPCHAR_PP",
          "args": [
            "1"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BPCHAR_PP",
          "args": [
            "0"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nbpchareq(PG_FUNCTION_ARGS)\n{\n\tBpChar\t   *arg1 = PG_GETARG_BPCHAR_PP(0);\n\tBpChar\t   *arg2 = PG_GETARG_BPCHAR_PP(1);\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\tbool\t\tresult;\n\n\tlen1 = bcTruelen(arg1);\n\tlen2 = bcTruelen(arg2);\n\n\t/*\n\t * Since we only care about equality or not-equality, we can avoid all the\n\t * expense of strcoll() here, and just do bitwise comparison.\n\t */\n\tif (len1 != len2)\n\t\tresult = false;\n\telse\n\t\tresult = (memcmp(VARDATA_ANY(arg1), VARDATA_ANY(arg2), len1) == 0);\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_BOOL(result);\n}"
  },
  {
    "function_name": "bpcharoctetlen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
    "lines": "692-699",
    "snippet": "Datum\nbpcharoctetlen(PG_FUNCTION_ARGS)\n{\n\tDatum\t\targ = PG_GETARG_DATUM(0);\n\n\t/* We need not detoast the input at all */\n\tPG_RETURN_INT32(toast_raw_datum_size(arg) - VARHDRSZ);\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "toast_raw_datum_size(arg) - VARHDRSZ"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toast_raw_datum_size",
          "args": [
            "arg"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "0"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nbpcharoctetlen(PG_FUNCTION_ARGS)\n{\n\tDatum\t\targ = PG_GETARG_DATUM(0);\n\n\t/* We need not detoast the input at all */\n\tPG_RETURN_INT32(toast_raw_datum_size(arg) - VARHDRSZ);\n}"
  },
  {
    "function_name": "bpcharlen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
    "lines": "676-690",
    "snippet": "Datum\nbpcharlen(PG_FUNCTION_ARGS)\n{\n\tBpChar\t   *arg = PG_GETARG_BPCHAR_PP(0);\n\tint\t\t\tlen;\n\n\t/* get number of bytes, ignoring trailing spaces */\n\tlen = bcTruelen(arg);\n\n\t/* in multibyte encoding, convert to number of characters */\n\tif (pg_database_encoding_max_length() != 1)\n\t\tlen = pg_mbstrlen_with_len(VARDATA_ANY(arg), len);\n\n\tPG_RETURN_INT32(len);\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "len"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_mbstrlen_with_len",
          "args": [
            "VARDATA_ANY(arg)",
            "len"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mbstrlen_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "793-811",
          "snippet": "int\npg_mbstrlen_with_len(const char *mbstr, int limit)\n{\n\tint\t\t\tlen = 0;\n\n\t/* optimization for single byte encoding */\n\tif (pg_database_encoding_max_length() == 1)\n\t\treturn limit;\n\n\twhile (limit > 0 && *mbstr)\n\t{\n\t\tint\t\t\tl = pg_mblen(mbstr);\n\n\t\tlimit -= l;\n\t\tmbstr += l;\n\t\tlen++;\n\t}\n\treturn len;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tcliplen(const char *str, int len, int limit);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic int\tcliplen(const char *str, int len, int limit);\n\nint\npg_mbstrlen_with_len(const char *mbstr, int limit)\n{\n\tint\t\t\tlen = 0;\n\n\t/* optimization for single byte encoding */\n\tif (pg_database_encoding_max_length() == 1)\n\t\treturn limit;\n\n\twhile (limit > 0 && *mbstr)\n\t{\n\t\tint\t\t\tl = pg_mblen(mbstr);\n\n\t\tlimit -= l;\n\t\tmbstr += l;\n\t\tlen++;\n\t}\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "arg"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_database_encoding_max_length",
          "args": [],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "pg_database_encoding_max_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "1832-1836",
          "snippet": "int\npg_database_encoding_max_length(void)\n{\n\treturn pg_wchar_table[GetDatabaseEncoding()].maxmblen;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nconst pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};\n\nint\npg_database_encoding_max_length(void)\n{\n\treturn pg_wchar_table[GetDatabaseEncoding()].maxmblen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bcTruelen",
          "args": [
            "arg"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "bcTruelen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
          "lines": "653-657",
          "snippet": "static inline int\nbcTruelen(BpChar *arg)\n{\n\treturn bpchartruelen(VARDATA_ANY(arg), VARSIZE_ANY_EXHDR(arg));\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic inline int\nbcTruelen(BpChar *arg)\n{\n\treturn bpchartruelen(VARDATA_ANY(arg), VARSIZE_ANY_EXHDR(arg));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BPCHAR_PP",
          "args": [
            "0"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nbpcharlen(PG_FUNCTION_ARGS)\n{\n\tBpChar\t   *arg = PG_GETARG_BPCHAR_PP(0);\n\tint\t\t\tlen;\n\n\t/* get number of bytes, ignoring trailing spaces */\n\tlen = bcTruelen(arg);\n\n\t/* in multibyte encoding, convert to number of characters */\n\tif (pg_database_encoding_max_length() != 1)\n\t\tlen = pg_mbstrlen_with_len(VARDATA_ANY(arg), len);\n\n\tPG_RETURN_INT32(len);\n}"
  },
  {
    "function_name": "bpchartruelen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
    "lines": "659-674",
    "snippet": "int\nbpchartruelen(char *s, int len)\n{\n\tint\t\t\ti;\n\n\t/*\n\t * Note that we rely on the assumption that ' ' is a singleton unit on\n\t * every supported multibyte server encoding.\n\t */\n\tfor (i = len - 1; i >= 0; i--)\n\t{\n\t\tif (s[i] != ' ')\n\t\t\tbreak;\n\t}\n\treturn i + 1;\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nint\nbpchartruelen(char *s, int len)\n{\n\tint\t\t\ti;\n\n\t/*\n\t * Note that we rely on the assumption that ' ' is a singleton unit on\n\t * every supported multibyte server encoding.\n\t */\n\tfor (i = len - 1; i >= 0; i--)\n\t{\n\t\tif (s[i] != ' ')\n\t\t\tbreak;\n\t}\n\treturn i + 1;\n}"
  },
  {
    "function_name": "bcTruelen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
    "lines": "653-657",
    "snippet": "static inline int\nbcTruelen(BpChar *arg)\n{\n\treturn bpchartruelen(VARDATA_ANY(arg), VARSIZE_ANY_EXHDR(arg));\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpchartruelen",
          "args": [
            "VARDATA_ANY(arg)",
            "VARSIZE_ANY_EXHDR(arg)"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "bpchartruelen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
          "lines": "659-674",
          "snippet": "int\nbpchartruelen(char *s, int len)\n{\n\tint\t\t\ti;\n\n\t/*\n\t * Note that we rely on the assumption that ' ' is a singleton unit on\n\t * every supported multibyte server encoding.\n\t */\n\tfor (i = len - 1; i >= 0; i--)\n\t{\n\t\tif (s[i] != ' ')\n\t\t\tbreak;\n\t}\n\treturn i + 1;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nint\nbpchartruelen(char *s, int len)\n{\n\tint\t\t\ti;\n\n\t/*\n\t * Note that we rely on the assumption that ' ' is a singleton unit on\n\t * every supported multibyte server encoding.\n\t */\n\tfor (i = len - 1; i >= 0; i--)\n\t{\n\t\tif (s[i] != ' ')\n\t\t\tbreak;\n\t}\n\treturn i + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "arg"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "arg"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic inline int\nbcTruelen(BpChar *arg)\n{\n\treturn bpchartruelen(VARDATA_ANY(arg), VARSIZE_ANY_EXHDR(arg));\n}"
  },
  {
    "function_name": "varchartypmodout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
    "lines": "639-645",
    "snippet": "Datum\nvarchartypmodout(PG_FUNCTION_ARGS)\n{\n\tint32\t\ttypmod = PG_GETARG_INT32(0);\n\n\tPG_RETURN_CSTRING(anychar_typmodout(typmod));\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "anychar_typmodout(typmod)"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anychar_typmodout",
          "args": [
            "typmod"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "anychar_typmodout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
          "lines": "69-80",
          "snippet": "static char *\nanychar_typmodout(int32 typmod)\n{\n\tchar\t   *res = (char *) palloc(64);\n\n\tif (typmod > VARHDRSZ)\n\t\tsnprintf(res, 64, \"(%d)\", (int) (typmod - VARHDRSZ));\n\telse\n\t\t*res = '\\0';\n\n\treturn res;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic char *\nanychar_typmodout(int32 typmod)\n{\n\tchar\t   *res = (char *) palloc(64);\n\n\tif (typmod > VARHDRSZ)\n\t\tsnprintf(res, 64, \"(%d)\", (int) (typmod - VARHDRSZ));\n\telse\n\t\t*res = '\\0';\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "0"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nvarchartypmodout(PG_FUNCTION_ARGS)\n{\n\tint32\t\ttypmod = PG_GETARG_INT32(0);\n\n\tPG_RETURN_CSTRING(anychar_typmodout(typmod));\n}"
  },
  {
    "function_name": "varchartypmodin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
    "lines": "631-637",
    "snippet": "Datum\nvarchartypmodin(PG_FUNCTION_ARGS)\n{\n\tArrayType  *ta = PG_GETARG_ARRAYTYPE_P(0);\n\n\tPG_RETURN_INT32(anychar_typmodin(ta, \"varchar\"));\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "anychar_typmodin(ta, \"varchar\")"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anychar_typmodin",
          "args": [
            "ta",
            "\"varchar\""
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "anychar_typmodin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
          "lines": "30-66",
          "snippet": "static int32\nanychar_typmodin(ArrayType *ta, const char *typename)\n{\n\tint32\t\ttypmod;\n\tint32\t   *tl;\n\tint\t\t\tn;\n\n\ttl = ArrayGetIntegerTypmods(ta, &n);\n\n\t/*\n\t * we're not too tense about good error message here because grammar\n\t * shouldn't allow wrong number of modifiers for CHAR\n\t */\n\tif (n != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid type modifier\")));\n\n\tif (*tl < 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"length for type %s must be at least 1\", typename)));\n\tif (*tl > MaxAttrSize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"length for type %s cannot exceed %d\",\n\t\t\t\t\t\ttypename, MaxAttrSize)));\n\n\t/*\n\t * For largely historical reasons, the typmod is VARHDRSZ plus the number\n\t * of characters; there is enough client-side code that knows about that\n\t * that we'd better not change it.\n\t */\n\ttypmod = VARHDRSZ + *tl;\n\n\treturn typmod;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic int32\nanychar_typmodin(ArrayType *ta, const char *typename)\n{\n\tint32\t\ttypmod;\n\tint32\t   *tl;\n\tint\t\t\tn;\n\n\ttl = ArrayGetIntegerTypmods(ta, &n);\n\n\t/*\n\t * we're not too tense about good error message here because grammar\n\t * shouldn't allow wrong number of modifiers for CHAR\n\t */\n\tif (n != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid type modifier\")));\n\n\tif (*tl < 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"length for type %s must be at least 1\", typename)));\n\tif (*tl > MaxAttrSize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"length for type %s cannot exceed %d\",\n\t\t\t\t\t\ttypename, MaxAttrSize)));\n\n\t/*\n\t * For largely historical reasons, the typmod is VARHDRSZ plus the number\n\t * of characters; there is enough client-side code that knows about that\n\t * that we'd better not change it.\n\t */\n\ttypmod = VARHDRSZ + *tl;\n\n\treturn typmod;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "0"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nvarchartypmodin(PG_FUNCTION_ARGS)\n{\n\tArrayType  *ta = PG_GETARG_ARRAYTYPE_P(0);\n\n\tPG_RETURN_INT32(anychar_typmodin(ta, \"varchar\"));\n}"
  },
  {
    "function_name": "varchar",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
    "lines": "592-629",
    "snippet": "Datum\nvarchar(PG_FUNCTION_ARGS)\n{\n\tVarChar    *source = PG_GETARG_VARCHAR_PP(0);\n\tint32\t\ttypmod = PG_GETARG_INT32(1);\n\tbool\t\tisExplicit = PG_GETARG_BOOL(2);\n\tint32\t\tlen,\n\t\t\t\tmaxlen;\n\tsize_t\t\tmaxmblen;\n\tint\t\t\ti;\n\tchar\t   *s_data;\n\n\tlen = VARSIZE_ANY_EXHDR(source);\n\ts_data = VARDATA_ANY(source);\n\tmaxlen = typmod - VARHDRSZ;\n\n\t/* No work if typmod is invalid or supplied data fits it already */\n\tif (maxlen < 0 || len <= maxlen)\n\t\tPG_RETURN_VARCHAR_P(source);\n\n\t/* only reach here if string is too long... */\n\n\t/* truncate multibyte string preserving multibyte boundary */\n\tmaxmblen = pg_mbcharcliplen(s_data, len, maxlen);\n\n\tif (!isExplicit)\n\t{\n\t\tfor (i = maxmblen; i < len; i++)\n\t\t\tif (s_data[i] != ' ')\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_STRING_DATA_RIGHT_TRUNCATION),\n\t\t\t\t\t\t errmsg(\"value too long for type character varying(%d)\",\n\t\t\t\t\t\t\t\tmaxlen)));\n\t}\n\n\tPG_RETURN_VARCHAR_P((VarChar *) cstring_to_text_with_len(s_data,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t maxmblen));\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VARCHAR_P",
          "args": [
            "(VarChar *) cstring_to_text_with_len(s_data,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t maxmblen)"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cstring_to_text_with_len",
          "args": [
            "s_data",
            "maxmblen"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "160-169",
          "snippet": "text *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_STRING_DATA_RIGHT_TRUNCATION),\n\t\t\t\t\t\t errmsg(\"value too long for type character varying(%d)\",\n\t\t\t\t\t\t\t\tmaxlen))"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"value too long for type character varying(%d)\"",
            "maxlen"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_STRING_DATA_RIGHT_TRUNCATION"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_mbcharcliplen",
          "args": [
            "s_data",
            "len",
            "maxlen"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mbcharcliplen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "861-883",
          "snippet": "int\npg_mbcharcliplen(const char *mbstr, int len, int limit)\n{\n\tint\t\t\tclen = 0;\n\tint\t\t\tnch = 0;\n\tint\t\t\tl;\n\n\t/* optimization for single byte encoding */\n\tif (pg_database_encoding_max_length() == 1)\n\t\treturn cliplen(mbstr, len, limit);\n\n\twhile (len > 0 && *mbstr)\n\t{\n\t\tl = pg_mblen(mbstr);\n\t\tnch++;\n\t\tif (nch > limit)\n\t\t\tbreak;\n\t\tclen += l;\n\t\tlen -= l;\n\t\tmbstr += l;\n\t}\n\treturn clen;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tcliplen(const char *str, int len, int limit);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic int\tcliplen(const char *str, int len, int limit);\n\nint\npg_mbcharcliplen(const char *mbstr, int len, int limit)\n{\n\tint\t\t\tclen = 0;\n\tint\t\t\tnch = 0;\n\tint\t\t\tl;\n\n\t/* optimization for single byte encoding */\n\tif (pg_database_encoding_max_length() == 1)\n\t\treturn cliplen(mbstr, len, limit);\n\n\twhile (len > 0 && *mbstr)\n\t{\n\t\tl = pg_mblen(mbstr);\n\t\tnch++;\n\t\tif (nch > limit)\n\t\t\tbreak;\n\t\tclen += l;\n\t\tlen -= l;\n\t\tmbstr += l;\n\t}\n\treturn clen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_VARCHAR_P",
          "args": [
            "source"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "source"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "source"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOOL",
          "args": [
            "2"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "1"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_VARCHAR_PP",
          "args": [
            "0"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nvarchar(PG_FUNCTION_ARGS)\n{\n\tVarChar    *source = PG_GETARG_VARCHAR_PP(0);\n\tint32\t\ttypmod = PG_GETARG_INT32(1);\n\tbool\t\tisExplicit = PG_GETARG_BOOL(2);\n\tint32\t\tlen,\n\t\t\t\tmaxlen;\n\tsize_t\t\tmaxmblen;\n\tint\t\t\ti;\n\tchar\t   *s_data;\n\n\tlen = VARSIZE_ANY_EXHDR(source);\n\ts_data = VARDATA_ANY(source);\n\tmaxlen = typmod - VARHDRSZ;\n\n\t/* No work if typmod is invalid or supplied data fits it already */\n\tif (maxlen < 0 || len <= maxlen)\n\t\tPG_RETURN_VARCHAR_P(source);\n\n\t/* only reach here if string is too long... */\n\n\t/* truncate multibyte string preserving multibyte boundary */\n\tmaxmblen = pg_mbcharcliplen(s_data, len, maxlen);\n\n\tif (!isExplicit)\n\t{\n\t\tfor (i = maxmblen; i < len; i++)\n\t\t\tif (s_data[i] != ' ')\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_STRING_DATA_RIGHT_TRUNCATION),\n\t\t\t\t\t\t errmsg(\"value too long for type character varying(%d)\",\n\t\t\t\t\t\t\t\tmaxlen)));\n\t}\n\n\tPG_RETURN_VARCHAR_P((VarChar *) cstring_to_text_with_len(s_data,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t maxmblen));\n}"
  },
  {
    "function_name": "varchar_transform",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
    "lines": "554-578",
    "snippet": "Datum\nvarchar_transform(PG_FUNCTION_ARGS)\n{\n\tFuncExpr   *expr = castNode(FuncExpr, PG_GETARG_POINTER(0));\n\tNode\t   *ret = NULL;\n\tNode\t   *typmod;\n\n\tAssert(list_length(expr->args) >= 2);\n\n\ttypmod = (Node *) lsecond(expr->args);\n\n\tif (IsA(typmod, Const) &&!((Const *) typmod)->constisnull)\n\t{\n\t\tNode\t   *source = (Node *) linitial(expr->args);\n\t\tint32\t\told_typmod = exprTypmod(source);\n\t\tint32\t\tnew_typmod = DatumGetInt32(((Const *) typmod)->constvalue);\n\t\tint32\t\told_max = old_typmod - VARHDRSZ;\n\t\tint32\t\tnew_max = new_typmod - VARHDRSZ;\n\n\t\tif (new_typmod < 0 || (old_typmod >= 0 && old_max <= new_max))\n\t\t\tret = relabel_to_typmod(source, new_typmod);\n\t}\n\n\tPG_RETURN_POINTER(ret);\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "ret"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relabel_to_typmod",
          "args": [
            "source",
            "new_typmod"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetInt32",
          "args": [
            "((Const *) typmod)->constvalue"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exprTypmod",
          "args": [
            "source"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "linitial",
          "args": [
            "expr->args"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "typmod",
            "Const"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lsecond",
          "args": [
            "expr->args"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "list_length(expr->args) >= 2"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_length",
          "args": [
            "expr->args"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "castNode",
          "args": [
            "FuncExpr",
            "PG_GETARG_POINTER(0)"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nvarchar_transform(PG_FUNCTION_ARGS)\n{\n\tFuncExpr   *expr = castNode(FuncExpr, PG_GETARG_POINTER(0));\n\tNode\t   *ret = NULL;\n\tNode\t   *typmod;\n\n\tAssert(list_length(expr->args) >= 2);\n\n\ttypmod = (Node *) lsecond(expr->args);\n\n\tif (IsA(typmod, Const) &&!((Const *) typmod)->constisnull)\n\t{\n\t\tNode\t   *source = (Node *) linitial(expr->args);\n\t\tint32\t\told_typmod = exprTypmod(source);\n\t\tint32\t\tnew_typmod = DatumGetInt32(((Const *) typmod)->constvalue);\n\t\tint32\t\told_max = old_typmod - VARHDRSZ;\n\t\tint32\t\tnew_max = new_typmod - VARHDRSZ;\n\n\t\tif (new_typmod < 0 || (old_typmod >= 0 && old_max <= new_max))\n\t\t\tret = relabel_to_typmod(source, new_typmod);\n\t}\n\n\tPG_RETURN_POINTER(ret);\n}"
  },
  {
    "function_name": "varcharsend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
    "lines": "540-545",
    "snippet": "Datum\nvarcharsend(PG_FUNCTION_ARGS)\n{\n\t/* Exactly the same as textsend, so share code */\n\treturn textsend(fcinfo);\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "textsend",
          "args": [
            "fcinfo"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "textsend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "547-556",
          "snippet": "Datum\ntextsend(PG_FUNCTION_ARGS)\n{\n\ttext\t   *t = PG_GETARG_TEXT_PP(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendtext(&buf, VARDATA_ANY(t), VARSIZE_ANY_EXHDR(t));\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void appendStringInfoText(StringInfo str, const text *t);",
            "static Datum text_to_array_internal(PG_FUNCTION_ARGS);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\n\nDatum\ntextsend(PG_FUNCTION_ARGS)\n{\n\ttext\t   *t = PG_GETARG_TEXT_PP(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendtext(&buf, VARDATA_ANY(t), VARSIZE_ANY_EXHDR(t));\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nvarcharsend(PG_FUNCTION_ARGS)\n{\n\t/* Exactly the same as textsend, so share code */\n\treturn textsend(fcinfo);\n}"
  },
  {
    "function_name": "varcharrecv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
    "lines": "518-535",
    "snippet": "Datum\nvarcharrecv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\n#ifdef NOT_USED\n\tOid\t\t\ttypelem = PG_GETARG_OID(1);\n#endif\n\tint32\t\tatttypmod = PG_GETARG_INT32(2);\n\tVarChar    *result;\n\tchar\t   *str;\n\tint\t\t\tnbytes;\n\n\tstr = pq_getmsgtext(buf, buf->len - buf->cursor, &nbytes);\n\tresult = varchar_input(str, nbytes, atttypmod);\n\tpfree(str);\n\tPG_RETURN_VARCHAR_P(result);\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VARCHAR_P",
          "args": [
            "result"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "str"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "varchar_input",
          "args": [
            "str",
            "nbytes",
            "atttypmod"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "varchar_input",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
          "lines": "451-479",
          "snippet": "static VarChar *\nvarchar_input(const char *s, size_t len, int32 atttypmod)\n{\n\tVarChar    *result;\n\tsize_t\t\tmaxlen;\n\n\tmaxlen = atttypmod - VARHDRSZ;\n\n\tif (atttypmod >= (int32) VARHDRSZ && len > maxlen)\n\t{\n\t\t/* Verify that extra characters are spaces, and clip them off */\n\t\tsize_t\t\tmbmaxlen = pg_mbcharcliplen(s, len, maxlen);\n\t\tsize_t\t\tj;\n\n\t\tfor (j = mbmaxlen; j < len; j++)\n\t\t{\n\t\t\tif (s[j] != ' ')\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_STRING_DATA_RIGHT_TRUNCATION),\n\t\t\t\t\t\t errmsg(\"value too long for type character varying(%d)\",\n\t\t\t\t\t\t\t\t(int) maxlen)));\n\t\t}\n\n\t\tlen = mbmaxlen;\n\t}\n\n\tresult = (VarChar *) cstring_to_text_with_len(s, len);\n\treturn result;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic VarChar *\nvarchar_input(const char *s, size_t len, int32 atttypmod)\n{\n\tVarChar    *result;\n\tsize_t\t\tmaxlen;\n\n\tmaxlen = atttypmod - VARHDRSZ;\n\n\tif (atttypmod >= (int32) VARHDRSZ && len > maxlen)\n\t{\n\t\t/* Verify that extra characters are spaces, and clip them off */\n\t\tsize_t\t\tmbmaxlen = pg_mbcharcliplen(s, len, maxlen);\n\t\tsize_t\t\tj;\n\n\t\tfor (j = mbmaxlen; j < len; j++)\n\t\t{\n\t\t\tif (s[j] != ' ')\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_STRING_DATA_RIGHT_TRUNCATION),\n\t\t\t\t\t\t errmsg(\"value too long for type character varying(%d)\",\n\t\t\t\t\t\t\t\t(int) maxlen)));\n\t\t}\n\n\t\tlen = mbmaxlen;\n\t}\n\n\tresult = (VarChar *) cstring_to_text_with_len(s, len);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pq_getmsgtext",
          "args": [
            "buf",
            "buf->len - buf->cursor",
            "&nbytes"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "2"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "1"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nvarcharrecv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\n#ifdef NOT_USED\n\tOid\t\t\ttypelem = PG_GETARG_OID(1);\n#endif\n\tint32\t\tatttypmod = PG_GETARG_INT32(2);\n\tVarChar    *result;\n\tchar\t   *str;\n\tint\t\t\tnbytes;\n\n\tstr = pq_getmsgtext(buf, buf->len - buf->cursor, &nbytes);\n\tresult = varchar_input(str, nbytes, atttypmod);\n\tpfree(str);\n\tPG_RETURN_VARCHAR_P(result);\n}"
  },
  {
    "function_name": "varcharout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
    "lines": "507-513",
    "snippet": "Datum\nvarcharout(PG_FUNCTION_ARGS)\n{\n\tDatum\t\ttxt = PG_GETARG_DATUM(0);\n\n\tPG_RETURN_CSTRING(TextDatumGetCString(txt));\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "TextDatumGetCString(txt)"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TextDatumGetCString",
          "args": [
            "txt"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "0"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nvarcharout(PG_FUNCTION_ARGS)\n{\n\tDatum\t\ttxt = PG_GETARG_DATUM(0);\n\n\tPG_RETURN_CSTRING(TextDatumGetCString(txt));\n}"
  },
  {
    "function_name": "varcharin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
    "lines": "485-498",
    "snippet": "Datum\nvarcharin(PG_FUNCTION_ARGS)\n{\n\tchar\t   *s = PG_GETARG_CSTRING(0);\n\n#ifdef NOT_USED\n\tOid\t\t\ttypelem = PG_GETARG_OID(1);\n#endif\n\tint32\t\tatttypmod = PG_GETARG_INT32(2);\n\tVarChar    *result;\n\n\tresult = varchar_input(s, strlen(s), atttypmod);\n\tPG_RETURN_VARCHAR_P(result);\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VARCHAR_P",
          "args": [
            "result"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "varchar_input",
          "args": [
            "s",
            "strlen(s)",
            "atttypmod"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "varchar_input",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
          "lines": "451-479",
          "snippet": "static VarChar *\nvarchar_input(const char *s, size_t len, int32 atttypmod)\n{\n\tVarChar    *result;\n\tsize_t\t\tmaxlen;\n\n\tmaxlen = atttypmod - VARHDRSZ;\n\n\tif (atttypmod >= (int32) VARHDRSZ && len > maxlen)\n\t{\n\t\t/* Verify that extra characters are spaces, and clip them off */\n\t\tsize_t\t\tmbmaxlen = pg_mbcharcliplen(s, len, maxlen);\n\t\tsize_t\t\tj;\n\n\t\tfor (j = mbmaxlen; j < len; j++)\n\t\t{\n\t\t\tif (s[j] != ' ')\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_STRING_DATA_RIGHT_TRUNCATION),\n\t\t\t\t\t\t errmsg(\"value too long for type character varying(%d)\",\n\t\t\t\t\t\t\t\t(int) maxlen)));\n\t\t}\n\n\t\tlen = mbmaxlen;\n\t}\n\n\tresult = (VarChar *) cstring_to_text_with_len(s, len);\n\treturn result;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic VarChar *\nvarchar_input(const char *s, size_t len, int32 atttypmod)\n{\n\tVarChar    *result;\n\tsize_t\t\tmaxlen;\n\n\tmaxlen = atttypmod - VARHDRSZ;\n\n\tif (atttypmod >= (int32) VARHDRSZ && len > maxlen)\n\t{\n\t\t/* Verify that extra characters are spaces, and clip them off */\n\t\tsize_t\t\tmbmaxlen = pg_mbcharcliplen(s, len, maxlen);\n\t\tsize_t\t\tj;\n\n\t\tfor (j = mbmaxlen; j < len; j++)\n\t\t{\n\t\t\tif (s[j] != ' ')\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_STRING_DATA_RIGHT_TRUNCATION),\n\t\t\t\t\t\t errmsg(\"value too long for type character varying(%d)\",\n\t\t\t\t\t\t\t\t(int) maxlen)));\n\t\t}\n\n\t\tlen = mbmaxlen;\n\t}\n\n\tresult = (VarChar *) cstring_to_text_with_len(s, len);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "s"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "2"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "1"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CSTRING",
          "args": [
            "0"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nvarcharin(PG_FUNCTION_ARGS)\n{\n\tchar\t   *s = PG_GETARG_CSTRING(0);\n\n#ifdef NOT_USED\n\tOid\t\t\ttypelem = PG_GETARG_OID(1);\n#endif\n\tint32\t\tatttypmod = PG_GETARG_INT32(2);\n\tVarChar    *result;\n\n\tresult = varchar_input(s, strlen(s), atttypmod);\n\tPG_RETURN_VARCHAR_P(result);\n}"
  },
  {
    "function_name": "varchar_input",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
    "lines": "451-479",
    "snippet": "static VarChar *\nvarchar_input(const char *s, size_t len, int32 atttypmod)\n{\n\tVarChar    *result;\n\tsize_t\t\tmaxlen;\n\n\tmaxlen = atttypmod - VARHDRSZ;\n\n\tif (atttypmod >= (int32) VARHDRSZ && len > maxlen)\n\t{\n\t\t/* Verify that extra characters are spaces, and clip them off */\n\t\tsize_t\t\tmbmaxlen = pg_mbcharcliplen(s, len, maxlen);\n\t\tsize_t\t\tj;\n\n\t\tfor (j = mbmaxlen; j < len; j++)\n\t\t{\n\t\t\tif (s[j] != ' ')\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_STRING_DATA_RIGHT_TRUNCATION),\n\t\t\t\t\t\t errmsg(\"value too long for type character varying(%d)\",\n\t\t\t\t\t\t\t\t(int) maxlen)));\n\t\t}\n\n\t\tlen = mbmaxlen;\n\t}\n\n\tresult = (VarChar *) cstring_to_text_with_len(s, len);\n\treturn result;\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cstring_to_text_with_len",
          "args": [
            "s",
            "len"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "160-169",
          "snippet": "text *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_STRING_DATA_RIGHT_TRUNCATION),\n\t\t\t\t\t\t errmsg(\"value too long for type character varying(%d)\",\n\t\t\t\t\t\t\t\t(int) maxlen))"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"value too long for type character varying(%d)\"",
            "(int) maxlen"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_STRING_DATA_RIGHT_TRUNCATION"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_mbcharcliplen",
          "args": [
            "s",
            "len",
            "maxlen"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mbcharcliplen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "861-883",
          "snippet": "int\npg_mbcharcliplen(const char *mbstr, int len, int limit)\n{\n\tint\t\t\tclen = 0;\n\tint\t\t\tnch = 0;\n\tint\t\t\tl;\n\n\t/* optimization for single byte encoding */\n\tif (pg_database_encoding_max_length() == 1)\n\t\treturn cliplen(mbstr, len, limit);\n\n\twhile (len > 0 && *mbstr)\n\t{\n\t\tl = pg_mblen(mbstr);\n\t\tnch++;\n\t\tif (nch > limit)\n\t\t\tbreak;\n\t\tclen += l;\n\t\tlen -= l;\n\t\tmbstr += l;\n\t}\n\treturn clen;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tcliplen(const char *str, int len, int limit);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic int\tcliplen(const char *str, int len, int limit);\n\nint\npg_mbcharcliplen(const char *mbstr, int len, int limit)\n{\n\tint\t\t\tclen = 0;\n\tint\t\t\tnch = 0;\n\tint\t\t\tl;\n\n\t/* optimization for single byte encoding */\n\tif (pg_database_encoding_max_length() == 1)\n\t\treturn cliplen(mbstr, len, limit);\n\n\twhile (len > 0 && *mbstr)\n\t{\n\t\tl = pg_mblen(mbstr);\n\t\tnch++;\n\t\tif (nch > limit)\n\t\t\tbreak;\n\t\tclen += l;\n\t\tlen -= l;\n\t\tmbstr += l;\n\t}\n\treturn clen;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic VarChar *\nvarchar_input(const char *s, size_t len, int32 atttypmod)\n{\n\tVarChar    *result;\n\tsize_t\t\tmaxlen;\n\n\tmaxlen = atttypmod - VARHDRSZ;\n\n\tif (atttypmod >= (int32) VARHDRSZ && len > maxlen)\n\t{\n\t\t/* Verify that extra characters are spaces, and clip them off */\n\t\tsize_t\t\tmbmaxlen = pg_mbcharcliplen(s, len, maxlen);\n\t\tsize_t\t\tj;\n\n\t\tfor (j = mbmaxlen; j < len; j++)\n\t\t{\n\t\t\tif (s[j] != ' ')\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_STRING_DATA_RIGHT_TRUNCATION),\n\t\t\t\t\t\t errmsg(\"value too long for type character varying(%d)\",\n\t\t\t\t\t\t\t\t(int) maxlen)));\n\t\t}\n\n\t\tlen = mbmaxlen;\n\t}\n\n\tresult = (VarChar *) cstring_to_text_with_len(s, len);\n\treturn result;\n}"
  },
  {
    "function_name": "bpchartypmodout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
    "lines": "420-426",
    "snippet": "Datum\nbpchartypmodout(PG_FUNCTION_ARGS)\n{\n\tint32\t\ttypmod = PG_GETARG_INT32(0);\n\n\tPG_RETURN_CSTRING(anychar_typmodout(typmod));\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "anychar_typmodout(typmod)"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anychar_typmodout",
          "args": [
            "typmod"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "anychar_typmodout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
          "lines": "69-80",
          "snippet": "static char *\nanychar_typmodout(int32 typmod)\n{\n\tchar\t   *res = (char *) palloc(64);\n\n\tif (typmod > VARHDRSZ)\n\t\tsnprintf(res, 64, \"(%d)\", (int) (typmod - VARHDRSZ));\n\telse\n\t\t*res = '\\0';\n\n\treturn res;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic char *\nanychar_typmodout(int32 typmod)\n{\n\tchar\t   *res = (char *) palloc(64);\n\n\tif (typmod > VARHDRSZ)\n\t\tsnprintf(res, 64, \"(%d)\", (int) (typmod - VARHDRSZ));\n\telse\n\t\t*res = '\\0';\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "0"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nbpchartypmodout(PG_FUNCTION_ARGS)\n{\n\tint32\t\ttypmod = PG_GETARG_INT32(0);\n\n\tPG_RETURN_CSTRING(anychar_typmodout(typmod));\n}"
  },
  {
    "function_name": "bpchartypmodin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
    "lines": "412-418",
    "snippet": "Datum\nbpchartypmodin(PG_FUNCTION_ARGS)\n{\n\tArrayType  *ta = PG_GETARG_ARRAYTYPE_P(0);\n\n\tPG_RETURN_INT32(anychar_typmodin(ta, \"char\"));\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "anychar_typmodin(ta, \"char\")"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anychar_typmodin",
          "args": [
            "ta",
            "\"char\""
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "anychar_typmodin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
          "lines": "30-66",
          "snippet": "static int32\nanychar_typmodin(ArrayType *ta, const char *typename)\n{\n\tint32\t\ttypmod;\n\tint32\t   *tl;\n\tint\t\t\tn;\n\n\ttl = ArrayGetIntegerTypmods(ta, &n);\n\n\t/*\n\t * we're not too tense about good error message here because grammar\n\t * shouldn't allow wrong number of modifiers for CHAR\n\t */\n\tif (n != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid type modifier\")));\n\n\tif (*tl < 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"length for type %s must be at least 1\", typename)));\n\tif (*tl > MaxAttrSize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"length for type %s cannot exceed %d\",\n\t\t\t\t\t\ttypename, MaxAttrSize)));\n\n\t/*\n\t * For largely historical reasons, the typmod is VARHDRSZ plus the number\n\t * of characters; there is enough client-side code that knows about that\n\t * that we'd better not change it.\n\t */\n\ttypmod = VARHDRSZ + *tl;\n\n\treturn typmod;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic int32\nanychar_typmodin(ArrayType *ta, const char *typename)\n{\n\tint32\t\ttypmod;\n\tint32\t   *tl;\n\tint\t\t\tn;\n\n\ttl = ArrayGetIntegerTypmods(ta, &n);\n\n\t/*\n\t * we're not too tense about good error message here because grammar\n\t * shouldn't allow wrong number of modifiers for CHAR\n\t */\n\tif (n != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid type modifier\")));\n\n\tif (*tl < 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"length for type %s must be at least 1\", typename)));\n\tif (*tl > MaxAttrSize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"length for type %s cannot exceed %d\",\n\t\t\t\t\t\ttypename, MaxAttrSize)));\n\n\t/*\n\t * For largely historical reasons, the typmod is VARHDRSZ plus the number\n\t * of characters; there is enough client-side code that knows about that\n\t * that we'd better not change it.\n\t */\n\ttypmod = VARHDRSZ + *tl;\n\n\treturn typmod;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "0"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nbpchartypmodin(PG_FUNCTION_ARGS)\n{\n\tArrayType  *ta = PG_GETARG_ARRAYTYPE_P(0);\n\n\tPG_RETURN_INT32(anychar_typmodin(ta, \"char\"));\n}"
  },
  {
    "function_name": "name_bpchar",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
    "lines": "402-410",
    "snippet": "Datum\nname_bpchar(PG_FUNCTION_ARGS)\n{\n\tName\t\ts = PG_GETARG_NAME(0);\n\tBpChar\t   *result;\n\n\tresult = (BpChar *) cstring_to_text(NameStr(*s));\n\tPG_RETURN_BPCHAR_P(result);\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BPCHAR_P",
          "args": [
            "result"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cstring_to_text",
          "args": [
            "NameStr(*s)"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "148-152",
          "snippet": "text *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}"
        }
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "*s"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_NAME",
          "args": [
            "0"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nname_bpchar(PG_FUNCTION_ARGS)\n{\n\tName\t\ts = PG_GETARG_NAME(0);\n\tBpChar\t   *result;\n\n\tresult = (BpChar *) cstring_to_text(NameStr(*s));\n\tPG_RETURN_BPCHAR_P(result);\n}"
  },
  {
    "function_name": "bpchar_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
    "lines": "366-394",
    "snippet": "Datum\nbpchar_name(PG_FUNCTION_ARGS)\n{\n\tBpChar\t   *s = PG_GETARG_BPCHAR_PP(0);\n\tchar\t   *s_data;\n\tName\t\tresult;\n\tint\t\t\tlen;\n\n\tlen = VARSIZE_ANY_EXHDR(s);\n\ts_data = VARDATA_ANY(s);\n\n\t/* Truncate oversize input */\n\tif (len >= NAMEDATALEN)\n\t\tlen = pg_mbcliplen(s_data, len, NAMEDATALEN - 1);\n\n\t/* Remove trailing blanks */\n\twhile (len > 0)\n\t{\n\t\tif (s_data[len - 1] != ' ')\n\t\t\tbreak;\n\t\tlen--;\n\t}\n\n\t/* We use palloc0 here to ensure result is zero-padded */\n\tresult = (Name) palloc0(NAMEDATALEN);\n\tmemcpy(NameStr(*result), s_data, len);\n\n\tPG_RETURN_NAME(result);\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_NAME",
          "args": [
            "result"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "NameStr(*result)",
            "s_data",
            "len"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "*result"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "NAMEDATALEN"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_mbcliplen",
          "args": [
            "s_data",
            "len",
            "NAMEDATALEN - 1"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mbcliplen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "819-824",
          "snippet": "int\npg_mbcliplen(const char *mbstr, int len, int limit)\n{\n\treturn pg_encoding_mbcliplen(DatabaseEncoding->encoding, mbstr,\n\t\t\t\t\t\t\t\t len, limit);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];",
            "static int\tcliplen(const char *str, int len, int limit);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\nstatic int\tcliplen(const char *str, int len, int limit);\n\nint\npg_mbcliplen(const char *mbstr, int len, int limit)\n{\n\treturn pg_encoding_mbcliplen(DatabaseEncoding->encoding, mbstr,\n\t\t\t\t\t\t\t\t len, limit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "s"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "s"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BPCHAR_PP",
          "args": [
            "0"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nbpchar_name(PG_FUNCTION_ARGS)\n{\n\tBpChar\t   *s = PG_GETARG_BPCHAR_PP(0);\n\tchar\t   *s_data;\n\tName\t\tresult;\n\tint\t\t\tlen;\n\n\tlen = VARSIZE_ANY_EXHDR(s);\n\ts_data = VARDATA_ANY(s);\n\n\t/* Truncate oversize input */\n\tif (len >= NAMEDATALEN)\n\t\tlen = pg_mbcliplen(s_data, len, NAMEDATALEN - 1);\n\n\t/* Remove trailing blanks */\n\twhile (len > 0)\n\t{\n\t\tif (s_data[len - 1] != ' ')\n\t\t\tbreak;\n\t\tlen--;\n\t}\n\n\t/* We use palloc0 here to ensure result is zero-padded */\n\tresult = (Name) palloc0(NAMEDATALEN);\n\tmemcpy(NameStr(*result), s_data, len);\n\n\tPG_RETURN_NAME(result);\n}"
  },
  {
    "function_name": "char_bpchar",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
    "lines": "348-360",
    "snippet": "Datum\nchar_bpchar(PG_FUNCTION_ARGS)\n{\n\tchar\t\tc = PG_GETARG_CHAR(0);\n\tBpChar\t   *result;\n\n\tresult = (BpChar *) palloc(VARHDRSZ + 1);\n\n\tSET_VARSIZE(result, VARHDRSZ + 1);\n\t*(VARDATA(result)) = c;\n\n\tPG_RETURN_BPCHAR_P(result);\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BPCHAR_P",
          "args": [
            "result"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA",
          "args": [
            "result"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "result",
            "VARHDRSZ + 1"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "VARHDRSZ + 1"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CHAR",
          "args": [
            "0"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nchar_bpchar(PG_FUNCTION_ARGS)\n{\n\tchar\t\tc = PG_GETARG_CHAR(0);\n\tBpChar\t   *result;\n\n\tresult = (BpChar *) palloc(VARHDRSZ + 1);\n\n\tSET_VARSIZE(result, VARHDRSZ + 1);\n\t*(VARDATA(result)) = c;\n\n\tPG_RETURN_BPCHAR_P(result);\n}"
  },
  {
    "function_name": "bpchar",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
    "lines": "266-342",
    "snippet": "Datum\nbpchar(PG_FUNCTION_ARGS)\n{\n\tBpChar\t   *source = PG_GETARG_BPCHAR_PP(0);\n\tint32\t\tmaxlen = PG_GETARG_INT32(1);\n\tbool\t\tisExplicit = PG_GETARG_BOOL(2);\n\tBpChar\t   *result;\n\tint32\t\tlen;\n\tchar\t   *r;\n\tchar\t   *s;\n\tint\t\t\ti;\n\tint\t\t\tcharlen;\t\t/* number of characters in the input string +\n\t\t\t\t\t\t\t\t * VARHDRSZ */\n\n\t/* No work if typmod is invalid */\n\tif (maxlen < (int32) VARHDRSZ)\n\t\tPG_RETURN_BPCHAR_P(source);\n\n\tmaxlen -= VARHDRSZ;\n\n\tlen = VARSIZE_ANY_EXHDR(source);\n\ts = VARDATA_ANY(source);\n\n\tcharlen = pg_mbstrlen_with_len(s, len);\n\n\t/* No work if supplied data matches typmod already */\n\tif (charlen == maxlen)\n\t\tPG_RETURN_BPCHAR_P(source);\n\n\tif (charlen > maxlen)\n\t{\n\t\t/* Verify that extra characters are spaces, and clip them off */\n\t\tsize_t\t\tmaxmblen;\n\n\t\tmaxmblen = pg_mbcharcliplen(s, len, maxlen);\n\n\t\tif (!isExplicit)\n\t\t{\n\t\t\tfor (i = maxmblen; i < len; i++)\n\t\t\t\tif (s[i] != ' ')\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_STRING_DATA_RIGHT_TRUNCATION),\n\t\t\t\t\t\t\t errmsg(\"value too long for type character(%d)\",\n\t\t\t\t\t\t\t\t\tmaxlen)));\n\t\t}\n\n\t\tlen = maxmblen;\n\n\t\t/*\n\t\t * At this point, maxlen is the necessary byte length, not the number\n\t\t * of CHARACTERS!\n\t\t */\n\t\tmaxlen = len;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * At this point, maxlen is the necessary byte length, not the number\n\t\t * of CHARACTERS!\n\t\t */\n\t\tmaxlen = len + (maxlen - charlen);\n\t}\n\n\tAssert(maxlen >= len);\n\n\tresult = palloc(maxlen + VARHDRSZ);\n\tSET_VARSIZE(result, maxlen + VARHDRSZ);\n\tr = VARDATA(result);\n\n\tmemcpy(r, s, len);\n\n\t/* blank pad the string if necessary */\n\tif (maxlen > len)\n\t\tmemset(r + len, ' ', maxlen - len);\n\n\tPG_RETURN_BPCHAR_P(result);\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BPCHAR_P",
          "args": [
            "result"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "r + len",
            "' '",
            "maxlen - len"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "r",
            "s",
            "len"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA",
          "args": [
            "result"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "result",
            "maxlen + VARHDRSZ"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "maxlen + VARHDRSZ"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "maxlen >= len"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_STRING_DATA_RIGHT_TRUNCATION),\n\t\t\t\t\t\t\t errmsg(\"value too long for type character(%d)\",\n\t\t\t\t\t\t\t\t\tmaxlen))"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"value too long for type character(%d)\"",
            "maxlen"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_STRING_DATA_RIGHT_TRUNCATION"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_mbcharcliplen",
          "args": [
            "s",
            "len",
            "maxlen"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mbcharcliplen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "861-883",
          "snippet": "int\npg_mbcharcliplen(const char *mbstr, int len, int limit)\n{\n\tint\t\t\tclen = 0;\n\tint\t\t\tnch = 0;\n\tint\t\t\tl;\n\n\t/* optimization for single byte encoding */\n\tif (pg_database_encoding_max_length() == 1)\n\t\treturn cliplen(mbstr, len, limit);\n\n\twhile (len > 0 && *mbstr)\n\t{\n\t\tl = pg_mblen(mbstr);\n\t\tnch++;\n\t\tif (nch > limit)\n\t\t\tbreak;\n\t\tclen += l;\n\t\tlen -= l;\n\t\tmbstr += l;\n\t}\n\treturn clen;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tcliplen(const char *str, int len, int limit);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic int\tcliplen(const char *str, int len, int limit);\n\nint\npg_mbcharcliplen(const char *mbstr, int len, int limit)\n{\n\tint\t\t\tclen = 0;\n\tint\t\t\tnch = 0;\n\tint\t\t\tl;\n\n\t/* optimization for single byte encoding */\n\tif (pg_database_encoding_max_length() == 1)\n\t\treturn cliplen(mbstr, len, limit);\n\n\twhile (len > 0 && *mbstr)\n\t{\n\t\tl = pg_mblen(mbstr);\n\t\tnch++;\n\t\tif (nch > limit)\n\t\t\tbreak;\n\t\tclen += l;\n\t\tlen -= l;\n\t\tmbstr += l;\n\t}\n\treturn clen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BPCHAR_P",
          "args": [
            "source"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_mbstrlen_with_len",
          "args": [
            "s",
            "len"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mbstrlen_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "793-811",
          "snippet": "int\npg_mbstrlen_with_len(const char *mbstr, int limit)\n{\n\tint\t\t\tlen = 0;\n\n\t/* optimization for single byte encoding */\n\tif (pg_database_encoding_max_length() == 1)\n\t\treturn limit;\n\n\twhile (limit > 0 && *mbstr)\n\t{\n\t\tint\t\t\tl = pg_mblen(mbstr);\n\n\t\tlimit -= l;\n\t\tmbstr += l;\n\t\tlen++;\n\t}\n\treturn len;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tcliplen(const char *str, int len, int limit);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic int\tcliplen(const char *str, int len, int limit);\n\nint\npg_mbstrlen_with_len(const char *mbstr, int limit)\n{\n\tint\t\t\tlen = 0;\n\n\t/* optimization for single byte encoding */\n\tif (pg_database_encoding_max_length() == 1)\n\t\treturn limit;\n\n\twhile (limit > 0 && *mbstr)\n\t{\n\t\tint\t\t\tl = pg_mblen(mbstr);\n\n\t\tlimit -= l;\n\t\tmbstr += l;\n\t\tlen++;\n\t}\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "source"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "source"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BPCHAR_P",
          "args": [
            "source"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOOL",
          "args": [
            "2"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "1"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BPCHAR_PP",
          "args": [
            "0"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nbpchar(PG_FUNCTION_ARGS)\n{\n\tBpChar\t   *source = PG_GETARG_BPCHAR_PP(0);\n\tint32\t\tmaxlen = PG_GETARG_INT32(1);\n\tbool\t\tisExplicit = PG_GETARG_BOOL(2);\n\tBpChar\t   *result;\n\tint32\t\tlen;\n\tchar\t   *r;\n\tchar\t   *s;\n\tint\t\t\ti;\n\tint\t\t\tcharlen;\t\t/* number of characters in the input string +\n\t\t\t\t\t\t\t\t * VARHDRSZ */\n\n\t/* No work if typmod is invalid */\n\tif (maxlen < (int32) VARHDRSZ)\n\t\tPG_RETURN_BPCHAR_P(source);\n\n\tmaxlen -= VARHDRSZ;\n\n\tlen = VARSIZE_ANY_EXHDR(source);\n\ts = VARDATA_ANY(source);\n\n\tcharlen = pg_mbstrlen_with_len(s, len);\n\n\t/* No work if supplied data matches typmod already */\n\tif (charlen == maxlen)\n\t\tPG_RETURN_BPCHAR_P(source);\n\n\tif (charlen > maxlen)\n\t{\n\t\t/* Verify that extra characters are spaces, and clip them off */\n\t\tsize_t\t\tmaxmblen;\n\n\t\tmaxmblen = pg_mbcharcliplen(s, len, maxlen);\n\n\t\tif (!isExplicit)\n\t\t{\n\t\t\tfor (i = maxmblen; i < len; i++)\n\t\t\t\tif (s[i] != ' ')\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_STRING_DATA_RIGHT_TRUNCATION),\n\t\t\t\t\t\t\t errmsg(\"value too long for type character(%d)\",\n\t\t\t\t\t\t\t\t\tmaxlen)));\n\t\t}\n\n\t\tlen = maxmblen;\n\n\t\t/*\n\t\t * At this point, maxlen is the necessary byte length, not the number\n\t\t * of CHARACTERS!\n\t\t */\n\t\tmaxlen = len;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * At this point, maxlen is the necessary byte length, not the number\n\t\t * of CHARACTERS!\n\t\t */\n\t\tmaxlen = len + (maxlen - charlen);\n\t}\n\n\tAssert(maxlen >= len);\n\n\tresult = palloc(maxlen + VARHDRSZ);\n\tSET_VARSIZE(result, maxlen + VARHDRSZ);\n\tr = VARDATA(result);\n\n\tmemcpy(r, s, len);\n\n\t/* blank pad the string if necessary */\n\tif (maxlen > len)\n\t\tmemset(r + len, ' ', maxlen - len);\n\n\tPG_RETURN_BPCHAR_P(result);\n}"
  },
  {
    "function_name": "bpcharsend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
    "lines": "246-251",
    "snippet": "Datum\nbpcharsend(PG_FUNCTION_ARGS)\n{\n\t/* Exactly the same as textsend, so share code */\n\treturn textsend(fcinfo);\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "textsend",
          "args": [
            "fcinfo"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "textsend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "547-556",
          "snippet": "Datum\ntextsend(PG_FUNCTION_ARGS)\n{\n\ttext\t   *t = PG_GETARG_TEXT_PP(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendtext(&buf, VARDATA_ANY(t), VARSIZE_ANY_EXHDR(t));\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void appendStringInfoText(StringInfo str, const text *t);",
            "static Datum text_to_array_internal(PG_FUNCTION_ARGS);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\nstatic Datum text_to_array_internal(PG_FUNCTION_ARGS);\n\nDatum\ntextsend(PG_FUNCTION_ARGS)\n{\n\ttext\t   *t = PG_GETARG_TEXT_PP(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendtext(&buf, VARDATA_ANY(t), VARSIZE_ANY_EXHDR(t));\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nbpcharsend(PG_FUNCTION_ARGS)\n{\n\t/* Exactly the same as textsend, so share code */\n\treturn textsend(fcinfo);\n}"
  },
  {
    "function_name": "bpcharrecv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
    "lines": "224-241",
    "snippet": "Datum\nbpcharrecv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\n#ifdef NOT_USED\n\tOid\t\t\ttypelem = PG_GETARG_OID(1);\n#endif\n\tint32\t\tatttypmod = PG_GETARG_INT32(2);\n\tBpChar\t   *result;\n\tchar\t   *str;\n\tint\t\t\tnbytes;\n\n\tstr = pq_getmsgtext(buf, buf->len - buf->cursor, &nbytes);\n\tresult = bpchar_input(str, nbytes, atttypmod);\n\tpfree(str);\n\tPG_RETURN_BPCHAR_P(result);\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BPCHAR_P",
          "args": [
            "result"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "str"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpchar_input",
          "args": [
            "str",
            "nbytes",
            "atttypmod"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "bpchar_input",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
          "lines": "123-185",
          "snippet": "static BpChar *\nbpchar_input(const char *s, size_t len, int32 atttypmod)\n{\n\tBpChar\t   *result;\n\tchar\t   *r;\n\tsize_t\t\tmaxlen;\n\n\t/* If typmod is -1 (or invalid), use the actual string length */\n\tif (atttypmod < (int32) VARHDRSZ)\n\t\tmaxlen = len;\n\telse\n\t{\n\t\tsize_t\t\tcharlen;\t/* number of CHARACTERS in the input */\n\n\t\tmaxlen = atttypmod - VARHDRSZ;\n\t\tcharlen = pg_mbstrlen_with_len(s, len);\n\t\tif (charlen > maxlen)\n\t\t{\n\t\t\t/* Verify that extra characters are spaces, and clip them off */\n\t\t\tsize_t\t\tmbmaxlen = pg_mbcharcliplen(s, len, maxlen);\n\t\t\tsize_t\t\tj;\n\n\t\t\t/*\n\t\t\t * at this point, len is the actual BYTE length of the input\n\t\t\t * string, maxlen is the max number of CHARACTERS allowed for this\n\t\t\t * bpchar type, mbmaxlen is the length in BYTES of those chars.\n\t\t\t */\n\t\t\tfor (j = mbmaxlen; j < len; j++)\n\t\t\t{\n\t\t\t\tif (s[j] != ' ')\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_STRING_DATA_RIGHT_TRUNCATION),\n\t\t\t\t\t\t\t errmsg(\"value too long for type character(%d)\",\n\t\t\t\t\t\t\t\t\t(int) maxlen)));\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Now we set maxlen to the necessary byte length, not the number\n\t\t\t * of CHARACTERS!\n\t\t\t */\n\t\t\tmaxlen = len = mbmaxlen;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Now we set maxlen to the necessary byte length, not the number\n\t\t\t * of CHARACTERS!\n\t\t\t */\n\t\t\tmaxlen = len + (maxlen - charlen);\n\t\t}\n\t}\n\n\tresult = (BpChar *) palloc(maxlen + VARHDRSZ);\n\tSET_VARSIZE(result, maxlen + VARHDRSZ);\n\tr = VARDATA(result);\n\tmemcpy(r, s, len);\n\n\t/* blank pad the string if necessary */\n\tif (maxlen > len)\n\t\tmemset(r + len, ' ', maxlen - len);\n\n\treturn result;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic BpChar *\nbpchar_input(const char *s, size_t len, int32 atttypmod)\n{\n\tBpChar\t   *result;\n\tchar\t   *r;\n\tsize_t\t\tmaxlen;\n\n\t/* If typmod is -1 (or invalid), use the actual string length */\n\tif (atttypmod < (int32) VARHDRSZ)\n\t\tmaxlen = len;\n\telse\n\t{\n\t\tsize_t\t\tcharlen;\t/* number of CHARACTERS in the input */\n\n\t\tmaxlen = atttypmod - VARHDRSZ;\n\t\tcharlen = pg_mbstrlen_with_len(s, len);\n\t\tif (charlen > maxlen)\n\t\t{\n\t\t\t/* Verify that extra characters are spaces, and clip them off */\n\t\t\tsize_t\t\tmbmaxlen = pg_mbcharcliplen(s, len, maxlen);\n\t\t\tsize_t\t\tj;\n\n\t\t\t/*\n\t\t\t * at this point, len is the actual BYTE length of the input\n\t\t\t * string, maxlen is the max number of CHARACTERS allowed for this\n\t\t\t * bpchar type, mbmaxlen is the length in BYTES of those chars.\n\t\t\t */\n\t\t\tfor (j = mbmaxlen; j < len; j++)\n\t\t\t{\n\t\t\t\tif (s[j] != ' ')\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_STRING_DATA_RIGHT_TRUNCATION),\n\t\t\t\t\t\t\t errmsg(\"value too long for type character(%d)\",\n\t\t\t\t\t\t\t\t\t(int) maxlen)));\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Now we set maxlen to the necessary byte length, not the number\n\t\t\t * of CHARACTERS!\n\t\t\t */\n\t\t\tmaxlen = len = mbmaxlen;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Now we set maxlen to the necessary byte length, not the number\n\t\t\t * of CHARACTERS!\n\t\t\t */\n\t\t\tmaxlen = len + (maxlen - charlen);\n\t\t}\n\t}\n\n\tresult = (BpChar *) palloc(maxlen + VARHDRSZ);\n\tSET_VARSIZE(result, maxlen + VARHDRSZ);\n\tr = VARDATA(result);\n\tmemcpy(r, s, len);\n\n\t/* blank pad the string if necessary */\n\tif (maxlen > len)\n\t\tmemset(r + len, ' ', maxlen - len);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pq_getmsgtext",
          "args": [
            "buf",
            "buf->len - buf->cursor",
            "&nbytes"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "2"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "1"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nbpcharrecv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\n#ifdef NOT_USED\n\tOid\t\t\ttypelem = PG_GETARG_OID(1);\n#endif\n\tint32\t\tatttypmod = PG_GETARG_INT32(2);\n\tBpChar\t   *result;\n\tchar\t   *str;\n\tint\t\t\tnbytes;\n\n\tstr = pq_getmsgtext(buf, buf->len - buf->cursor, &nbytes);\n\tresult = bpchar_input(str, nbytes, atttypmod);\n\tpfree(str);\n\tPG_RETURN_BPCHAR_P(result);\n}"
  },
  {
    "function_name": "bpcharout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
    "lines": "213-219",
    "snippet": "Datum\nbpcharout(PG_FUNCTION_ARGS)\n{\n\tDatum\t\ttxt = PG_GETARG_DATUM(0);\n\n\tPG_RETURN_CSTRING(TextDatumGetCString(txt));\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "TextDatumGetCString(txt)"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TextDatumGetCString",
          "args": [
            "txt"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "0"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nbpcharout(PG_FUNCTION_ARGS)\n{\n\tDatum\t\ttxt = PG_GETARG_DATUM(0);\n\n\tPG_RETURN_CSTRING(TextDatumGetCString(txt));\n}"
  },
  {
    "function_name": "bpcharin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
    "lines": "191-204",
    "snippet": "Datum\nbpcharin(PG_FUNCTION_ARGS)\n{\n\tchar\t   *s = PG_GETARG_CSTRING(0);\n\n#ifdef NOT_USED\n\tOid\t\t\ttypelem = PG_GETARG_OID(1);\n#endif\n\tint32\t\tatttypmod = PG_GETARG_INT32(2);\n\tBpChar\t   *result;\n\n\tresult = bpchar_input(s, strlen(s), atttypmod);\n\tPG_RETURN_BPCHAR_P(result);\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BPCHAR_P",
          "args": [
            "result"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpchar_input",
          "args": [
            "s",
            "strlen(s)",
            "atttypmod"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "bpchar_input",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
          "lines": "123-185",
          "snippet": "static BpChar *\nbpchar_input(const char *s, size_t len, int32 atttypmod)\n{\n\tBpChar\t   *result;\n\tchar\t   *r;\n\tsize_t\t\tmaxlen;\n\n\t/* If typmod is -1 (or invalid), use the actual string length */\n\tif (atttypmod < (int32) VARHDRSZ)\n\t\tmaxlen = len;\n\telse\n\t{\n\t\tsize_t\t\tcharlen;\t/* number of CHARACTERS in the input */\n\n\t\tmaxlen = atttypmod - VARHDRSZ;\n\t\tcharlen = pg_mbstrlen_with_len(s, len);\n\t\tif (charlen > maxlen)\n\t\t{\n\t\t\t/* Verify that extra characters are spaces, and clip them off */\n\t\t\tsize_t\t\tmbmaxlen = pg_mbcharcliplen(s, len, maxlen);\n\t\t\tsize_t\t\tj;\n\n\t\t\t/*\n\t\t\t * at this point, len is the actual BYTE length of the input\n\t\t\t * string, maxlen is the max number of CHARACTERS allowed for this\n\t\t\t * bpchar type, mbmaxlen is the length in BYTES of those chars.\n\t\t\t */\n\t\t\tfor (j = mbmaxlen; j < len; j++)\n\t\t\t{\n\t\t\t\tif (s[j] != ' ')\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_STRING_DATA_RIGHT_TRUNCATION),\n\t\t\t\t\t\t\t errmsg(\"value too long for type character(%d)\",\n\t\t\t\t\t\t\t\t\t(int) maxlen)));\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Now we set maxlen to the necessary byte length, not the number\n\t\t\t * of CHARACTERS!\n\t\t\t */\n\t\t\tmaxlen = len = mbmaxlen;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Now we set maxlen to the necessary byte length, not the number\n\t\t\t * of CHARACTERS!\n\t\t\t */\n\t\t\tmaxlen = len + (maxlen - charlen);\n\t\t}\n\t}\n\n\tresult = (BpChar *) palloc(maxlen + VARHDRSZ);\n\tSET_VARSIZE(result, maxlen + VARHDRSZ);\n\tr = VARDATA(result);\n\tmemcpy(r, s, len);\n\n\t/* blank pad the string if necessary */\n\tif (maxlen > len)\n\t\tmemset(r + len, ' ', maxlen - len);\n\n\treturn result;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic BpChar *\nbpchar_input(const char *s, size_t len, int32 atttypmod)\n{\n\tBpChar\t   *result;\n\tchar\t   *r;\n\tsize_t\t\tmaxlen;\n\n\t/* If typmod is -1 (or invalid), use the actual string length */\n\tif (atttypmod < (int32) VARHDRSZ)\n\t\tmaxlen = len;\n\telse\n\t{\n\t\tsize_t\t\tcharlen;\t/* number of CHARACTERS in the input */\n\n\t\tmaxlen = atttypmod - VARHDRSZ;\n\t\tcharlen = pg_mbstrlen_with_len(s, len);\n\t\tif (charlen > maxlen)\n\t\t{\n\t\t\t/* Verify that extra characters are spaces, and clip them off */\n\t\t\tsize_t\t\tmbmaxlen = pg_mbcharcliplen(s, len, maxlen);\n\t\t\tsize_t\t\tj;\n\n\t\t\t/*\n\t\t\t * at this point, len is the actual BYTE length of the input\n\t\t\t * string, maxlen is the max number of CHARACTERS allowed for this\n\t\t\t * bpchar type, mbmaxlen is the length in BYTES of those chars.\n\t\t\t */\n\t\t\tfor (j = mbmaxlen; j < len; j++)\n\t\t\t{\n\t\t\t\tif (s[j] != ' ')\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_STRING_DATA_RIGHT_TRUNCATION),\n\t\t\t\t\t\t\t errmsg(\"value too long for type character(%d)\",\n\t\t\t\t\t\t\t\t\t(int) maxlen)));\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Now we set maxlen to the necessary byte length, not the number\n\t\t\t * of CHARACTERS!\n\t\t\t */\n\t\t\tmaxlen = len = mbmaxlen;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Now we set maxlen to the necessary byte length, not the number\n\t\t\t * of CHARACTERS!\n\t\t\t */\n\t\t\tmaxlen = len + (maxlen - charlen);\n\t\t}\n\t}\n\n\tresult = (BpChar *) palloc(maxlen + VARHDRSZ);\n\tSET_VARSIZE(result, maxlen + VARHDRSZ);\n\tr = VARDATA(result);\n\tmemcpy(r, s, len);\n\n\t/* blank pad the string if necessary */\n\tif (maxlen > len)\n\t\tmemset(r + len, ' ', maxlen - len);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "s"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "2"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "1"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CSTRING",
          "args": [
            "0"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nbpcharin(PG_FUNCTION_ARGS)\n{\n\tchar\t   *s = PG_GETARG_CSTRING(0);\n\n#ifdef NOT_USED\n\tOid\t\t\ttypelem = PG_GETARG_OID(1);\n#endif\n\tint32\t\tatttypmod = PG_GETARG_INT32(2);\n\tBpChar\t   *result;\n\n\tresult = bpchar_input(s, strlen(s), atttypmod);\n\tPG_RETURN_BPCHAR_P(result);\n}"
  },
  {
    "function_name": "bpchar_input",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
    "lines": "123-185",
    "snippet": "static BpChar *\nbpchar_input(const char *s, size_t len, int32 atttypmod)\n{\n\tBpChar\t   *result;\n\tchar\t   *r;\n\tsize_t\t\tmaxlen;\n\n\t/* If typmod is -1 (or invalid), use the actual string length */\n\tif (atttypmod < (int32) VARHDRSZ)\n\t\tmaxlen = len;\n\telse\n\t{\n\t\tsize_t\t\tcharlen;\t/* number of CHARACTERS in the input */\n\n\t\tmaxlen = atttypmod - VARHDRSZ;\n\t\tcharlen = pg_mbstrlen_with_len(s, len);\n\t\tif (charlen > maxlen)\n\t\t{\n\t\t\t/* Verify that extra characters are spaces, and clip them off */\n\t\t\tsize_t\t\tmbmaxlen = pg_mbcharcliplen(s, len, maxlen);\n\t\t\tsize_t\t\tj;\n\n\t\t\t/*\n\t\t\t * at this point, len is the actual BYTE length of the input\n\t\t\t * string, maxlen is the max number of CHARACTERS allowed for this\n\t\t\t * bpchar type, mbmaxlen is the length in BYTES of those chars.\n\t\t\t */\n\t\t\tfor (j = mbmaxlen; j < len; j++)\n\t\t\t{\n\t\t\t\tif (s[j] != ' ')\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_STRING_DATA_RIGHT_TRUNCATION),\n\t\t\t\t\t\t\t errmsg(\"value too long for type character(%d)\",\n\t\t\t\t\t\t\t\t\t(int) maxlen)));\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Now we set maxlen to the necessary byte length, not the number\n\t\t\t * of CHARACTERS!\n\t\t\t */\n\t\t\tmaxlen = len = mbmaxlen;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Now we set maxlen to the necessary byte length, not the number\n\t\t\t * of CHARACTERS!\n\t\t\t */\n\t\t\tmaxlen = len + (maxlen - charlen);\n\t\t}\n\t}\n\n\tresult = (BpChar *) palloc(maxlen + VARHDRSZ);\n\tSET_VARSIZE(result, maxlen + VARHDRSZ);\n\tr = VARDATA(result);\n\tmemcpy(r, s, len);\n\n\t/* blank pad the string if necessary */\n\tif (maxlen > len)\n\t\tmemset(r + len, ' ', maxlen - len);\n\n\treturn result;\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "r + len",
            "' '",
            "maxlen - len"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "r",
            "s",
            "len"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA",
          "args": [
            "result"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "result",
            "maxlen + VARHDRSZ"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "maxlen + VARHDRSZ"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_STRING_DATA_RIGHT_TRUNCATION),\n\t\t\t\t\t\t\t errmsg(\"value too long for type character(%d)\",\n\t\t\t\t\t\t\t\t\t(int) maxlen))"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"value too long for type character(%d)\"",
            "(int) maxlen"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_STRING_DATA_RIGHT_TRUNCATION"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_mbcharcliplen",
          "args": [
            "s",
            "len",
            "maxlen"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mbcharcliplen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "861-883",
          "snippet": "int\npg_mbcharcliplen(const char *mbstr, int len, int limit)\n{\n\tint\t\t\tclen = 0;\n\tint\t\t\tnch = 0;\n\tint\t\t\tl;\n\n\t/* optimization for single byte encoding */\n\tif (pg_database_encoding_max_length() == 1)\n\t\treturn cliplen(mbstr, len, limit);\n\n\twhile (len > 0 && *mbstr)\n\t{\n\t\tl = pg_mblen(mbstr);\n\t\tnch++;\n\t\tif (nch > limit)\n\t\t\tbreak;\n\t\tclen += l;\n\t\tlen -= l;\n\t\tmbstr += l;\n\t}\n\treturn clen;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tcliplen(const char *str, int len, int limit);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic int\tcliplen(const char *str, int len, int limit);\n\nint\npg_mbcharcliplen(const char *mbstr, int len, int limit)\n{\n\tint\t\t\tclen = 0;\n\tint\t\t\tnch = 0;\n\tint\t\t\tl;\n\n\t/* optimization for single byte encoding */\n\tif (pg_database_encoding_max_length() == 1)\n\t\treturn cliplen(mbstr, len, limit);\n\n\twhile (len > 0 && *mbstr)\n\t{\n\t\tl = pg_mblen(mbstr);\n\t\tnch++;\n\t\tif (nch > limit)\n\t\t\tbreak;\n\t\tclen += l;\n\t\tlen -= l;\n\t\tmbstr += l;\n\t}\n\treturn clen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_mbstrlen_with_len",
          "args": [
            "s",
            "len"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mbstrlen_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "793-811",
          "snippet": "int\npg_mbstrlen_with_len(const char *mbstr, int limit)\n{\n\tint\t\t\tlen = 0;\n\n\t/* optimization for single byte encoding */\n\tif (pg_database_encoding_max_length() == 1)\n\t\treturn limit;\n\n\twhile (limit > 0 && *mbstr)\n\t{\n\t\tint\t\t\tl = pg_mblen(mbstr);\n\n\t\tlimit -= l;\n\t\tmbstr += l;\n\t\tlen++;\n\t}\n\treturn len;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tcliplen(const char *str, int len, int limit);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic int\tcliplen(const char *str, int len, int limit);\n\nint\npg_mbstrlen_with_len(const char *mbstr, int limit)\n{\n\tint\t\t\tlen = 0;\n\n\t/* optimization for single byte encoding */\n\tif (pg_database_encoding_max_length() == 1)\n\t\treturn limit;\n\n\twhile (limit > 0 && *mbstr)\n\t{\n\t\tint\t\t\tl = pg_mblen(mbstr);\n\n\t\tlimit -= l;\n\t\tmbstr += l;\n\t\tlen++;\n\t}\n\treturn len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic BpChar *\nbpchar_input(const char *s, size_t len, int32 atttypmod)\n{\n\tBpChar\t   *result;\n\tchar\t   *r;\n\tsize_t\t\tmaxlen;\n\n\t/* If typmod is -1 (or invalid), use the actual string length */\n\tif (atttypmod < (int32) VARHDRSZ)\n\t\tmaxlen = len;\n\telse\n\t{\n\t\tsize_t\t\tcharlen;\t/* number of CHARACTERS in the input */\n\n\t\tmaxlen = atttypmod - VARHDRSZ;\n\t\tcharlen = pg_mbstrlen_with_len(s, len);\n\t\tif (charlen > maxlen)\n\t\t{\n\t\t\t/* Verify that extra characters are spaces, and clip them off */\n\t\t\tsize_t\t\tmbmaxlen = pg_mbcharcliplen(s, len, maxlen);\n\t\t\tsize_t\t\tj;\n\n\t\t\t/*\n\t\t\t * at this point, len is the actual BYTE length of the input\n\t\t\t * string, maxlen is the max number of CHARACTERS allowed for this\n\t\t\t * bpchar type, mbmaxlen is the length in BYTES of those chars.\n\t\t\t */\n\t\t\tfor (j = mbmaxlen; j < len; j++)\n\t\t\t{\n\t\t\t\tif (s[j] != ' ')\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_STRING_DATA_RIGHT_TRUNCATION),\n\t\t\t\t\t\t\t errmsg(\"value too long for type character(%d)\",\n\t\t\t\t\t\t\t\t\t(int) maxlen)));\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Now we set maxlen to the necessary byte length, not the number\n\t\t\t * of CHARACTERS!\n\t\t\t */\n\t\t\tmaxlen = len = mbmaxlen;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Now we set maxlen to the necessary byte length, not the number\n\t\t\t * of CHARACTERS!\n\t\t\t */\n\t\t\tmaxlen = len + (maxlen - charlen);\n\t\t}\n\t}\n\n\tresult = (BpChar *) palloc(maxlen + VARHDRSZ);\n\tSET_VARSIZE(result, maxlen + VARHDRSZ);\n\tr = VARDATA(result);\n\tmemcpy(r, s, len);\n\n\t/* blank pad the string if necessary */\n\tif (maxlen > len)\n\t\tmemset(r + len, ' ', maxlen - len);\n\n\treturn result;\n}"
  },
  {
    "function_name": "anychar_typmodout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
    "lines": "69-80",
    "snippet": "static char *\nanychar_typmodout(int32 typmod)\n{\n\tchar\t   *res = (char *) palloc(64);\n\n\tif (typmod > VARHDRSZ)\n\t\tsnprintf(res, 64, \"(%d)\", (int) (typmod - VARHDRSZ));\n\telse\n\t\t*res = '\\0';\n\n\treturn res;\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "res",
            "64",
            "\"(%d)\"",
            "(int) (typmod - VARHDRSZ)"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "64"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic char *\nanychar_typmodout(int32 typmod)\n{\n\tchar\t   *res = (char *) palloc(64);\n\n\tif (typmod > VARHDRSZ)\n\t\tsnprintf(res, 64, \"(%d)\", (int) (typmod - VARHDRSZ));\n\telse\n\t\t*res = '\\0';\n\n\treturn res;\n}"
  },
  {
    "function_name": "anychar_typmodin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varchar.c",
    "lines": "30-66",
    "snippet": "static int32\nanychar_typmodin(ArrayType *ta, const char *typename)\n{\n\tint32\t\ttypmod;\n\tint32\t   *tl;\n\tint\t\t\tn;\n\n\ttl = ArrayGetIntegerTypmods(ta, &n);\n\n\t/*\n\t * we're not too tense about good error message here because grammar\n\t * shouldn't allow wrong number of modifiers for CHAR\n\t */\n\tif (n != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid type modifier\")));\n\n\tif (*tl < 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"length for type %s must be at least 1\", typename)));\n\tif (*tl > MaxAttrSize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"length for type %s cannot exceed %d\",\n\t\t\t\t\t\ttypename, MaxAttrSize)));\n\n\t/*\n\t * For largely historical reasons, the typmod is VARHDRSZ plus the number\n\t * of characters; there is enough client-side code that knows about that\n\t * that we'd better not change it.\n\t */\n\ttypmod = VARHDRSZ + *tl;\n\n\treturn typmod;\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/varlena.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"length for type %s cannot exceed %d\",\n\t\t\t\t\t\ttypename, MaxAttrSize))"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"length for type %s cannot exceed %d\"",
            "typename",
            "MaxAttrSize"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"length for type %s must be at least 1\", typename))"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid type modifier\"))"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ArrayGetIntegerTypmods",
          "args": [
            "ta",
            "&n"
          ],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "ArrayGetIntegerTypmods",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
          "lines": "199-235",
          "snippet": "int32 *\nArrayGetIntegerTypmods(ArrayType *arr, int *n)\n{\n\tint32\t   *result;\n\tDatum\t   *elem_values;\n\tint\t\t\ti;\n\n\tif (ARR_ELEMTYPE(arr) != CSTRINGOID)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_ELEMENT_ERROR),\n\t\t\t\t errmsg(\"typmod array must be type cstring[]\")));\n\n\tif (ARR_NDIM(arr) != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"typmod array must be one-dimensional\")));\n\n\tif (array_contains_nulls(arr))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"typmod array must not contain nulls\")));\n\n\t/* hardwired knowledge about cstring's representation details here */\n\tdeconstruct_array(arr, CSTRINGOID,\n\t\t\t\t\t  -2, false, 'c',\n\t\t\t\t\t  &elem_values, NULL, n);\n\n\tresult = (int32 *) palloc(*n * sizeof(int32));\n\n\tfor (i = 0; i < *n; i++)\n\t\tresult[i] = pg_atoi(DatumGetCString(elem_values[i]),\n\t\t\t\t\t\t\tsizeof(int32), '\\0');\n\n\tpfree(elem_values);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nint32 *\nArrayGetIntegerTypmods(ArrayType *arr, int *n)\n{\n\tint32\t   *result;\n\tDatum\t   *elem_values;\n\tint\t\t\ti;\n\n\tif (ARR_ELEMTYPE(arr) != CSTRINGOID)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_ELEMENT_ERROR),\n\t\t\t\t errmsg(\"typmod array must be type cstring[]\")));\n\n\tif (ARR_NDIM(arr) != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"typmod array must be one-dimensional\")));\n\n\tif (array_contains_nulls(arr))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"typmod array must not contain nulls\")));\n\n\t/* hardwired knowledge about cstring's representation details here */\n\tdeconstruct_array(arr, CSTRINGOID,\n\t\t\t\t\t  -2, false, 'c',\n\t\t\t\t\t  &elem_values, NULL, n);\n\n\tresult = (int32 *) palloc(*n * sizeof(int32));\n\n\tfor (i = 0; i < *n; i++)\n\t\tresult[i] = pg_atoi(DatumGetCString(elem_values[i]),\n\t\t\t\t\t\t\tsizeof(int32), '\\0');\n\n\tpfree(elem_values);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/varlena.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic int32\nanychar_typmodin(ArrayType *ta, const char *typename)\n{\n\tint32\t\ttypmod;\n\tint32\t   *tl;\n\tint\t\t\tn;\n\n\ttl = ArrayGetIntegerTypmods(ta, &n);\n\n\t/*\n\t * we're not too tense about good error message here because grammar\n\t * shouldn't allow wrong number of modifiers for CHAR\n\t */\n\tif (n != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid type modifier\")));\n\n\tif (*tl < 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"length for type %s must be at least 1\", typename)));\n\tif (*tl > MaxAttrSize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"length for type %s cannot exceed %d\",\n\t\t\t\t\t\ttypename, MaxAttrSize)));\n\n\t/*\n\t * For largely historical reasons, the typmod is VARHDRSZ plus the number\n\t * of characters; there is enough client-side code that knows about that\n\t * that we'd better not change it.\n\t */\n\ttypmod = VARHDRSZ + *tl;\n\n\treturn typmod;\n}"
  }
]