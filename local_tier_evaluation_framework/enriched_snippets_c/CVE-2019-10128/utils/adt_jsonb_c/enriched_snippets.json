[
  {
    "function_name": "jsonb_float8",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
    "lines": "2037-2053",
    "snippet": "Datum\njsonb_float8(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *in = PG_GETARG_JSONB_P(0);\n\tJsonbValue\tv;\n\tDatum\t\tretValue;\n\n\tif (!JsonbExtractScalar(&in->root, &v) || v.type != jbvNumeric)\n\t\tcannotCastJsonbValue(v.type, \"double precision\");\n\n\tretValue = DirectFunctionCall1(numeric_float8,\n\t\t\t\t\t\t\t\t   NumericGetDatum(v.val.numeric));\n\n\tPG_FREE_IF_COPY(in, 0);\n\n\tPG_RETURN_DATUM(retValue);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"miscadmin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_DATUM",
          "args": [
            "retValue"
          ],
          "line": 2052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "in",
            "0"
          ],
          "line": 2050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "numeric_float8",
            "NumericGetDatum(v.val.numeric)"
          ],
          "line": 2047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NumericGetDatum",
          "args": [
            "v.val.numeric"
          ],
          "line": 2048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cannotCastJsonbValue",
          "args": [
            "v.type",
            "\"double precision\""
          ],
          "line": 2045
        },
        "resolved": true,
        "details": {
          "function_name": "cannotCastJsonbValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
          "lines": "1900-1928",
          "snippet": "static void\ncannotCastJsonbValue(enum jbvType type, const char *sqltype)\n{\n\tstatic const struct\n\t{\n\t\tenum jbvType type;\n\t\tconst char *msg;\n\t}\n\t\t\t\tmessages[] =\n\t{\n\t\t{jbvNull, gettext_noop(\"cannot cast jsonb null to type %s\")},\n\t\t{jbvString, gettext_noop(\"cannot cast jsonb string to type %s\")},\n\t\t{jbvNumeric, gettext_noop(\"cannot cast jsonb numeric to type %s\")},\n\t\t{jbvBool, gettext_noop(\"cannot cast jsonb boolean to type %s\")},\n\t\t{jbvArray, gettext_noop(\"cannot cast jsonb array to type %s\")},\n\t\t{jbvObject, gettext_noop(\"cannot cast jsonb object to type %s\")},\n\t\t{jbvBinary, gettext_noop(\"cannot cast jsonb array or object to type %s\")}\n\t};\n\tint\t\t\ti;\n\n\tfor (i = 0; i < lengthof(messages); i++)\n\t\tif (messages[i].type == type)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(messages[i].msg, sqltype)));\n\n\t/* should be unreachable */\n\telog(ERROR, \"unknown jsonb type: %d\", (int) type);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"miscadmin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic void\ncannotCastJsonbValue(enum jbvType type, const char *sqltype)\n{\n\tstatic const struct\n\t{\n\t\tenum jbvType type;\n\t\tconst char *msg;\n\t}\n\t\t\t\tmessages[] =\n\t{\n\t\t{jbvNull, gettext_noop(\"cannot cast jsonb null to type %s\")},\n\t\t{jbvString, gettext_noop(\"cannot cast jsonb string to type %s\")},\n\t\t{jbvNumeric, gettext_noop(\"cannot cast jsonb numeric to type %s\")},\n\t\t{jbvBool, gettext_noop(\"cannot cast jsonb boolean to type %s\")},\n\t\t{jbvArray, gettext_noop(\"cannot cast jsonb array to type %s\")},\n\t\t{jbvObject, gettext_noop(\"cannot cast jsonb object to type %s\")},\n\t\t{jbvBinary, gettext_noop(\"cannot cast jsonb array or object to type %s\")}\n\t};\n\tint\t\t\ti;\n\n\tfor (i = 0; i < lengthof(messages); i++)\n\t\tif (messages[i].type == type)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(messages[i].msg, sqltype)));\n\n\t/* should be unreachable */\n\telog(ERROR, \"unknown jsonb type: %d\", (int) type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonbExtractScalar",
          "args": [
            "&in->root",
            "&v"
          ],
          "line": 2044
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbExtractScalar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
          "lines": "1860-1895",
          "snippet": "static bool\nJsonbExtractScalar(JsonbContainer *jbc, JsonbValue *res)\n{\n\tJsonbIterator *it;\n\tJsonbIteratorToken tok PG_USED_FOR_ASSERTS_ONLY;\n\tJsonbValue\ttmp;\n\n\tif (!JsonContainerIsArray(jbc) || !JsonContainerIsScalar(jbc))\n\t{\n\t\t/* inform caller about actual type of container */\n\t\tres->type = (JsonContainerIsArray(jbc)) ? jbvArray : jbvObject;\n\t\treturn false;\n\t}\n\n\t/*\n\t * A root scalar is stored as an array of one element, so we get the array\n\t * and then its first (and only) member.\n\t */\n\tit = JsonbIteratorInit(jbc);\n\n\ttok = JsonbIteratorNext(&it, &tmp, true);\n\tAssert(tok == WJB_BEGIN_ARRAY);\n\tAssert(tmp.val.array.nElems == 1 && tmp.val.array.rawScalar);\n\n\ttok = JsonbIteratorNext(&it, res, true);\n\tAssert(tok == WJB_ELEM);\n\tAssert(IsAJsonbScalar(res));\n\n\ttok = JsonbIteratorNext(&it, &tmp, true);\n\tAssert(tok == WJB_END_ARRAY);\n\n\ttok = JsonbIteratorNext(&it, &tmp, true);\n\tAssert(tok == WJB_DONE);\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"miscadmin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic bool\nJsonbExtractScalar(JsonbContainer *jbc, JsonbValue *res)\n{\n\tJsonbIterator *it;\n\tJsonbIteratorToken tok PG_USED_FOR_ASSERTS_ONLY;\n\tJsonbValue\ttmp;\n\n\tif (!JsonContainerIsArray(jbc) || !JsonContainerIsScalar(jbc))\n\t{\n\t\t/* inform caller about actual type of container */\n\t\tres->type = (JsonContainerIsArray(jbc)) ? jbvArray : jbvObject;\n\t\treturn false;\n\t}\n\n\t/*\n\t * A root scalar is stored as an array of one element, so we get the array\n\t * and then its first (and only) member.\n\t */\n\tit = JsonbIteratorInit(jbc);\n\n\ttok = JsonbIteratorNext(&it, &tmp, true);\n\tAssert(tok == WJB_BEGIN_ARRAY);\n\tAssert(tmp.val.array.nElems == 1 && tmp.val.array.rawScalar);\n\n\ttok = JsonbIteratorNext(&it, res, true);\n\tAssert(tok == WJB_ELEM);\n\tAssert(IsAJsonbScalar(res));\n\n\ttok = JsonbIteratorNext(&it, &tmp, true);\n\tAssert(tok == WJB_END_ARRAY);\n\n\ttok = JsonbIteratorNext(&it, &tmp, true);\n\tAssert(tok == WJB_DONE);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_JSONB_P",
          "args": [
            "0"
          ],
          "line": 2040
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nDatum\njsonb_float8(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *in = PG_GETARG_JSONB_P(0);\n\tJsonbValue\tv;\n\tDatum\t\tretValue;\n\n\tif (!JsonbExtractScalar(&in->root, &v) || v.type != jbvNumeric)\n\t\tcannotCastJsonbValue(v.type, \"double precision\");\n\n\tretValue = DirectFunctionCall1(numeric_float8,\n\t\t\t\t\t\t\t\t   NumericGetDatum(v.val.numeric));\n\n\tPG_FREE_IF_COPY(in, 0);\n\n\tPG_RETURN_DATUM(retValue);\n}"
  },
  {
    "function_name": "jsonb_float4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
    "lines": "2019-2035",
    "snippet": "Datum\njsonb_float4(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *in = PG_GETARG_JSONB_P(0);\n\tJsonbValue\tv;\n\tDatum\t\tretValue;\n\n\tif (!JsonbExtractScalar(&in->root, &v) || v.type != jbvNumeric)\n\t\tcannotCastJsonbValue(v.type, \"real\");\n\n\tretValue = DirectFunctionCall1(numeric_float4,\n\t\t\t\t\t\t\t\t   NumericGetDatum(v.val.numeric));\n\n\tPG_FREE_IF_COPY(in, 0);\n\n\tPG_RETURN_DATUM(retValue);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"miscadmin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_DATUM",
          "args": [
            "retValue"
          ],
          "line": 2034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "in",
            "0"
          ],
          "line": 2032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "numeric_float4",
            "NumericGetDatum(v.val.numeric)"
          ],
          "line": 2029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NumericGetDatum",
          "args": [
            "v.val.numeric"
          ],
          "line": 2030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cannotCastJsonbValue",
          "args": [
            "v.type",
            "\"real\""
          ],
          "line": 2027
        },
        "resolved": true,
        "details": {
          "function_name": "cannotCastJsonbValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
          "lines": "1900-1928",
          "snippet": "static void\ncannotCastJsonbValue(enum jbvType type, const char *sqltype)\n{\n\tstatic const struct\n\t{\n\t\tenum jbvType type;\n\t\tconst char *msg;\n\t}\n\t\t\t\tmessages[] =\n\t{\n\t\t{jbvNull, gettext_noop(\"cannot cast jsonb null to type %s\")},\n\t\t{jbvString, gettext_noop(\"cannot cast jsonb string to type %s\")},\n\t\t{jbvNumeric, gettext_noop(\"cannot cast jsonb numeric to type %s\")},\n\t\t{jbvBool, gettext_noop(\"cannot cast jsonb boolean to type %s\")},\n\t\t{jbvArray, gettext_noop(\"cannot cast jsonb array to type %s\")},\n\t\t{jbvObject, gettext_noop(\"cannot cast jsonb object to type %s\")},\n\t\t{jbvBinary, gettext_noop(\"cannot cast jsonb array or object to type %s\")}\n\t};\n\tint\t\t\ti;\n\n\tfor (i = 0; i < lengthof(messages); i++)\n\t\tif (messages[i].type == type)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(messages[i].msg, sqltype)));\n\n\t/* should be unreachable */\n\telog(ERROR, \"unknown jsonb type: %d\", (int) type);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"miscadmin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic void\ncannotCastJsonbValue(enum jbvType type, const char *sqltype)\n{\n\tstatic const struct\n\t{\n\t\tenum jbvType type;\n\t\tconst char *msg;\n\t}\n\t\t\t\tmessages[] =\n\t{\n\t\t{jbvNull, gettext_noop(\"cannot cast jsonb null to type %s\")},\n\t\t{jbvString, gettext_noop(\"cannot cast jsonb string to type %s\")},\n\t\t{jbvNumeric, gettext_noop(\"cannot cast jsonb numeric to type %s\")},\n\t\t{jbvBool, gettext_noop(\"cannot cast jsonb boolean to type %s\")},\n\t\t{jbvArray, gettext_noop(\"cannot cast jsonb array to type %s\")},\n\t\t{jbvObject, gettext_noop(\"cannot cast jsonb object to type %s\")},\n\t\t{jbvBinary, gettext_noop(\"cannot cast jsonb array or object to type %s\")}\n\t};\n\tint\t\t\ti;\n\n\tfor (i = 0; i < lengthof(messages); i++)\n\t\tif (messages[i].type == type)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(messages[i].msg, sqltype)));\n\n\t/* should be unreachable */\n\telog(ERROR, \"unknown jsonb type: %d\", (int) type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonbExtractScalar",
          "args": [
            "&in->root",
            "&v"
          ],
          "line": 2026
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbExtractScalar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
          "lines": "1860-1895",
          "snippet": "static bool\nJsonbExtractScalar(JsonbContainer *jbc, JsonbValue *res)\n{\n\tJsonbIterator *it;\n\tJsonbIteratorToken tok PG_USED_FOR_ASSERTS_ONLY;\n\tJsonbValue\ttmp;\n\n\tif (!JsonContainerIsArray(jbc) || !JsonContainerIsScalar(jbc))\n\t{\n\t\t/* inform caller about actual type of container */\n\t\tres->type = (JsonContainerIsArray(jbc)) ? jbvArray : jbvObject;\n\t\treturn false;\n\t}\n\n\t/*\n\t * A root scalar is stored as an array of one element, so we get the array\n\t * and then its first (and only) member.\n\t */\n\tit = JsonbIteratorInit(jbc);\n\n\ttok = JsonbIteratorNext(&it, &tmp, true);\n\tAssert(tok == WJB_BEGIN_ARRAY);\n\tAssert(tmp.val.array.nElems == 1 && tmp.val.array.rawScalar);\n\n\ttok = JsonbIteratorNext(&it, res, true);\n\tAssert(tok == WJB_ELEM);\n\tAssert(IsAJsonbScalar(res));\n\n\ttok = JsonbIteratorNext(&it, &tmp, true);\n\tAssert(tok == WJB_END_ARRAY);\n\n\ttok = JsonbIteratorNext(&it, &tmp, true);\n\tAssert(tok == WJB_DONE);\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"miscadmin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic bool\nJsonbExtractScalar(JsonbContainer *jbc, JsonbValue *res)\n{\n\tJsonbIterator *it;\n\tJsonbIteratorToken tok PG_USED_FOR_ASSERTS_ONLY;\n\tJsonbValue\ttmp;\n\n\tif (!JsonContainerIsArray(jbc) || !JsonContainerIsScalar(jbc))\n\t{\n\t\t/* inform caller about actual type of container */\n\t\tres->type = (JsonContainerIsArray(jbc)) ? jbvArray : jbvObject;\n\t\treturn false;\n\t}\n\n\t/*\n\t * A root scalar is stored as an array of one element, so we get the array\n\t * and then its first (and only) member.\n\t */\n\tit = JsonbIteratorInit(jbc);\n\n\ttok = JsonbIteratorNext(&it, &tmp, true);\n\tAssert(tok == WJB_BEGIN_ARRAY);\n\tAssert(tmp.val.array.nElems == 1 && tmp.val.array.rawScalar);\n\n\ttok = JsonbIteratorNext(&it, res, true);\n\tAssert(tok == WJB_ELEM);\n\tAssert(IsAJsonbScalar(res));\n\n\ttok = JsonbIteratorNext(&it, &tmp, true);\n\tAssert(tok == WJB_END_ARRAY);\n\n\ttok = JsonbIteratorNext(&it, &tmp, true);\n\tAssert(tok == WJB_DONE);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_JSONB_P",
          "args": [
            "0"
          ],
          "line": 2022
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nDatum\njsonb_float4(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *in = PG_GETARG_JSONB_P(0);\n\tJsonbValue\tv;\n\tDatum\t\tretValue;\n\n\tif (!JsonbExtractScalar(&in->root, &v) || v.type != jbvNumeric)\n\t\tcannotCastJsonbValue(v.type, \"real\");\n\n\tretValue = DirectFunctionCall1(numeric_float4,\n\t\t\t\t\t\t\t\t   NumericGetDatum(v.val.numeric));\n\n\tPG_FREE_IF_COPY(in, 0);\n\n\tPG_RETURN_DATUM(retValue);\n}"
  },
  {
    "function_name": "jsonb_int8",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
    "lines": "2001-2017",
    "snippet": "Datum\njsonb_int8(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *in = PG_GETARG_JSONB_P(0);\n\tJsonbValue\tv;\n\tDatum\t\tretValue;\n\n\tif (!JsonbExtractScalar(&in->root, &v) || v.type != jbvNumeric)\n\t\tcannotCastJsonbValue(v.type, \"bigint\");\n\n\tretValue = DirectFunctionCall1(numeric_int8,\n\t\t\t\t\t\t\t\t   NumericGetDatum(v.val.numeric));\n\n\tPG_FREE_IF_COPY(in, 0);\n\n\tPG_RETURN_DATUM(retValue);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"miscadmin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_DATUM",
          "args": [
            "retValue"
          ],
          "line": 2016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "in",
            "0"
          ],
          "line": 2014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "numeric_int8",
            "NumericGetDatum(v.val.numeric)"
          ],
          "line": 2011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NumericGetDatum",
          "args": [
            "v.val.numeric"
          ],
          "line": 2012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cannotCastJsonbValue",
          "args": [
            "v.type",
            "\"bigint\""
          ],
          "line": 2009
        },
        "resolved": true,
        "details": {
          "function_name": "cannotCastJsonbValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
          "lines": "1900-1928",
          "snippet": "static void\ncannotCastJsonbValue(enum jbvType type, const char *sqltype)\n{\n\tstatic const struct\n\t{\n\t\tenum jbvType type;\n\t\tconst char *msg;\n\t}\n\t\t\t\tmessages[] =\n\t{\n\t\t{jbvNull, gettext_noop(\"cannot cast jsonb null to type %s\")},\n\t\t{jbvString, gettext_noop(\"cannot cast jsonb string to type %s\")},\n\t\t{jbvNumeric, gettext_noop(\"cannot cast jsonb numeric to type %s\")},\n\t\t{jbvBool, gettext_noop(\"cannot cast jsonb boolean to type %s\")},\n\t\t{jbvArray, gettext_noop(\"cannot cast jsonb array to type %s\")},\n\t\t{jbvObject, gettext_noop(\"cannot cast jsonb object to type %s\")},\n\t\t{jbvBinary, gettext_noop(\"cannot cast jsonb array or object to type %s\")}\n\t};\n\tint\t\t\ti;\n\n\tfor (i = 0; i < lengthof(messages); i++)\n\t\tif (messages[i].type == type)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(messages[i].msg, sqltype)));\n\n\t/* should be unreachable */\n\telog(ERROR, \"unknown jsonb type: %d\", (int) type);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"miscadmin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic void\ncannotCastJsonbValue(enum jbvType type, const char *sqltype)\n{\n\tstatic const struct\n\t{\n\t\tenum jbvType type;\n\t\tconst char *msg;\n\t}\n\t\t\t\tmessages[] =\n\t{\n\t\t{jbvNull, gettext_noop(\"cannot cast jsonb null to type %s\")},\n\t\t{jbvString, gettext_noop(\"cannot cast jsonb string to type %s\")},\n\t\t{jbvNumeric, gettext_noop(\"cannot cast jsonb numeric to type %s\")},\n\t\t{jbvBool, gettext_noop(\"cannot cast jsonb boolean to type %s\")},\n\t\t{jbvArray, gettext_noop(\"cannot cast jsonb array to type %s\")},\n\t\t{jbvObject, gettext_noop(\"cannot cast jsonb object to type %s\")},\n\t\t{jbvBinary, gettext_noop(\"cannot cast jsonb array or object to type %s\")}\n\t};\n\tint\t\t\ti;\n\n\tfor (i = 0; i < lengthof(messages); i++)\n\t\tif (messages[i].type == type)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(messages[i].msg, sqltype)));\n\n\t/* should be unreachable */\n\telog(ERROR, \"unknown jsonb type: %d\", (int) type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonbExtractScalar",
          "args": [
            "&in->root",
            "&v"
          ],
          "line": 2008
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbExtractScalar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
          "lines": "1860-1895",
          "snippet": "static bool\nJsonbExtractScalar(JsonbContainer *jbc, JsonbValue *res)\n{\n\tJsonbIterator *it;\n\tJsonbIteratorToken tok PG_USED_FOR_ASSERTS_ONLY;\n\tJsonbValue\ttmp;\n\n\tif (!JsonContainerIsArray(jbc) || !JsonContainerIsScalar(jbc))\n\t{\n\t\t/* inform caller about actual type of container */\n\t\tres->type = (JsonContainerIsArray(jbc)) ? jbvArray : jbvObject;\n\t\treturn false;\n\t}\n\n\t/*\n\t * A root scalar is stored as an array of one element, so we get the array\n\t * and then its first (and only) member.\n\t */\n\tit = JsonbIteratorInit(jbc);\n\n\ttok = JsonbIteratorNext(&it, &tmp, true);\n\tAssert(tok == WJB_BEGIN_ARRAY);\n\tAssert(tmp.val.array.nElems == 1 && tmp.val.array.rawScalar);\n\n\ttok = JsonbIteratorNext(&it, res, true);\n\tAssert(tok == WJB_ELEM);\n\tAssert(IsAJsonbScalar(res));\n\n\ttok = JsonbIteratorNext(&it, &tmp, true);\n\tAssert(tok == WJB_END_ARRAY);\n\n\ttok = JsonbIteratorNext(&it, &tmp, true);\n\tAssert(tok == WJB_DONE);\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"miscadmin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic bool\nJsonbExtractScalar(JsonbContainer *jbc, JsonbValue *res)\n{\n\tJsonbIterator *it;\n\tJsonbIteratorToken tok PG_USED_FOR_ASSERTS_ONLY;\n\tJsonbValue\ttmp;\n\n\tif (!JsonContainerIsArray(jbc) || !JsonContainerIsScalar(jbc))\n\t{\n\t\t/* inform caller about actual type of container */\n\t\tres->type = (JsonContainerIsArray(jbc)) ? jbvArray : jbvObject;\n\t\treturn false;\n\t}\n\n\t/*\n\t * A root scalar is stored as an array of one element, so we get the array\n\t * and then its first (and only) member.\n\t */\n\tit = JsonbIteratorInit(jbc);\n\n\ttok = JsonbIteratorNext(&it, &tmp, true);\n\tAssert(tok == WJB_BEGIN_ARRAY);\n\tAssert(tmp.val.array.nElems == 1 && tmp.val.array.rawScalar);\n\n\ttok = JsonbIteratorNext(&it, res, true);\n\tAssert(tok == WJB_ELEM);\n\tAssert(IsAJsonbScalar(res));\n\n\ttok = JsonbIteratorNext(&it, &tmp, true);\n\tAssert(tok == WJB_END_ARRAY);\n\n\ttok = JsonbIteratorNext(&it, &tmp, true);\n\tAssert(tok == WJB_DONE);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_JSONB_P",
          "args": [
            "0"
          ],
          "line": 2004
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nDatum\njsonb_int8(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *in = PG_GETARG_JSONB_P(0);\n\tJsonbValue\tv;\n\tDatum\t\tretValue;\n\n\tif (!JsonbExtractScalar(&in->root, &v) || v.type != jbvNumeric)\n\t\tcannotCastJsonbValue(v.type, \"bigint\");\n\n\tretValue = DirectFunctionCall1(numeric_int8,\n\t\t\t\t\t\t\t\t   NumericGetDatum(v.val.numeric));\n\n\tPG_FREE_IF_COPY(in, 0);\n\n\tPG_RETURN_DATUM(retValue);\n}"
  },
  {
    "function_name": "jsonb_int4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
    "lines": "1983-1999",
    "snippet": "Datum\njsonb_int4(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *in = PG_GETARG_JSONB_P(0);\n\tJsonbValue\tv;\n\tDatum\t\tretValue;\n\n\tif (!JsonbExtractScalar(&in->root, &v) || v.type != jbvNumeric)\n\t\tcannotCastJsonbValue(v.type, \"integer\");\n\n\tretValue = DirectFunctionCall1(numeric_int4,\n\t\t\t\t\t\t\t\t   NumericGetDatum(v.val.numeric));\n\n\tPG_FREE_IF_COPY(in, 0);\n\n\tPG_RETURN_DATUM(retValue);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"miscadmin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_DATUM",
          "args": [
            "retValue"
          ],
          "line": 1998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "in",
            "0"
          ],
          "line": 1996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "numeric_int4",
            "NumericGetDatum(v.val.numeric)"
          ],
          "line": 1993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NumericGetDatum",
          "args": [
            "v.val.numeric"
          ],
          "line": 1994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cannotCastJsonbValue",
          "args": [
            "v.type",
            "\"integer\""
          ],
          "line": 1991
        },
        "resolved": true,
        "details": {
          "function_name": "cannotCastJsonbValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
          "lines": "1900-1928",
          "snippet": "static void\ncannotCastJsonbValue(enum jbvType type, const char *sqltype)\n{\n\tstatic const struct\n\t{\n\t\tenum jbvType type;\n\t\tconst char *msg;\n\t}\n\t\t\t\tmessages[] =\n\t{\n\t\t{jbvNull, gettext_noop(\"cannot cast jsonb null to type %s\")},\n\t\t{jbvString, gettext_noop(\"cannot cast jsonb string to type %s\")},\n\t\t{jbvNumeric, gettext_noop(\"cannot cast jsonb numeric to type %s\")},\n\t\t{jbvBool, gettext_noop(\"cannot cast jsonb boolean to type %s\")},\n\t\t{jbvArray, gettext_noop(\"cannot cast jsonb array to type %s\")},\n\t\t{jbvObject, gettext_noop(\"cannot cast jsonb object to type %s\")},\n\t\t{jbvBinary, gettext_noop(\"cannot cast jsonb array or object to type %s\")}\n\t};\n\tint\t\t\ti;\n\n\tfor (i = 0; i < lengthof(messages); i++)\n\t\tif (messages[i].type == type)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(messages[i].msg, sqltype)));\n\n\t/* should be unreachable */\n\telog(ERROR, \"unknown jsonb type: %d\", (int) type);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"miscadmin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic void\ncannotCastJsonbValue(enum jbvType type, const char *sqltype)\n{\n\tstatic const struct\n\t{\n\t\tenum jbvType type;\n\t\tconst char *msg;\n\t}\n\t\t\t\tmessages[] =\n\t{\n\t\t{jbvNull, gettext_noop(\"cannot cast jsonb null to type %s\")},\n\t\t{jbvString, gettext_noop(\"cannot cast jsonb string to type %s\")},\n\t\t{jbvNumeric, gettext_noop(\"cannot cast jsonb numeric to type %s\")},\n\t\t{jbvBool, gettext_noop(\"cannot cast jsonb boolean to type %s\")},\n\t\t{jbvArray, gettext_noop(\"cannot cast jsonb array to type %s\")},\n\t\t{jbvObject, gettext_noop(\"cannot cast jsonb object to type %s\")},\n\t\t{jbvBinary, gettext_noop(\"cannot cast jsonb array or object to type %s\")}\n\t};\n\tint\t\t\ti;\n\n\tfor (i = 0; i < lengthof(messages); i++)\n\t\tif (messages[i].type == type)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(messages[i].msg, sqltype)));\n\n\t/* should be unreachable */\n\telog(ERROR, \"unknown jsonb type: %d\", (int) type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonbExtractScalar",
          "args": [
            "&in->root",
            "&v"
          ],
          "line": 1990
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbExtractScalar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
          "lines": "1860-1895",
          "snippet": "static bool\nJsonbExtractScalar(JsonbContainer *jbc, JsonbValue *res)\n{\n\tJsonbIterator *it;\n\tJsonbIteratorToken tok PG_USED_FOR_ASSERTS_ONLY;\n\tJsonbValue\ttmp;\n\n\tif (!JsonContainerIsArray(jbc) || !JsonContainerIsScalar(jbc))\n\t{\n\t\t/* inform caller about actual type of container */\n\t\tres->type = (JsonContainerIsArray(jbc)) ? jbvArray : jbvObject;\n\t\treturn false;\n\t}\n\n\t/*\n\t * A root scalar is stored as an array of one element, so we get the array\n\t * and then its first (and only) member.\n\t */\n\tit = JsonbIteratorInit(jbc);\n\n\ttok = JsonbIteratorNext(&it, &tmp, true);\n\tAssert(tok == WJB_BEGIN_ARRAY);\n\tAssert(tmp.val.array.nElems == 1 && tmp.val.array.rawScalar);\n\n\ttok = JsonbIteratorNext(&it, res, true);\n\tAssert(tok == WJB_ELEM);\n\tAssert(IsAJsonbScalar(res));\n\n\ttok = JsonbIteratorNext(&it, &tmp, true);\n\tAssert(tok == WJB_END_ARRAY);\n\n\ttok = JsonbIteratorNext(&it, &tmp, true);\n\tAssert(tok == WJB_DONE);\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"miscadmin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic bool\nJsonbExtractScalar(JsonbContainer *jbc, JsonbValue *res)\n{\n\tJsonbIterator *it;\n\tJsonbIteratorToken tok PG_USED_FOR_ASSERTS_ONLY;\n\tJsonbValue\ttmp;\n\n\tif (!JsonContainerIsArray(jbc) || !JsonContainerIsScalar(jbc))\n\t{\n\t\t/* inform caller about actual type of container */\n\t\tres->type = (JsonContainerIsArray(jbc)) ? jbvArray : jbvObject;\n\t\treturn false;\n\t}\n\n\t/*\n\t * A root scalar is stored as an array of one element, so we get the array\n\t * and then its first (and only) member.\n\t */\n\tit = JsonbIteratorInit(jbc);\n\n\ttok = JsonbIteratorNext(&it, &tmp, true);\n\tAssert(tok == WJB_BEGIN_ARRAY);\n\tAssert(tmp.val.array.nElems == 1 && tmp.val.array.rawScalar);\n\n\ttok = JsonbIteratorNext(&it, res, true);\n\tAssert(tok == WJB_ELEM);\n\tAssert(IsAJsonbScalar(res));\n\n\ttok = JsonbIteratorNext(&it, &tmp, true);\n\tAssert(tok == WJB_END_ARRAY);\n\n\ttok = JsonbIteratorNext(&it, &tmp, true);\n\tAssert(tok == WJB_DONE);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_JSONB_P",
          "args": [
            "0"
          ],
          "line": 1986
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nDatum\njsonb_int4(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *in = PG_GETARG_JSONB_P(0);\n\tJsonbValue\tv;\n\tDatum\t\tretValue;\n\n\tif (!JsonbExtractScalar(&in->root, &v) || v.type != jbvNumeric)\n\t\tcannotCastJsonbValue(v.type, \"integer\");\n\n\tretValue = DirectFunctionCall1(numeric_int4,\n\t\t\t\t\t\t\t\t   NumericGetDatum(v.val.numeric));\n\n\tPG_FREE_IF_COPY(in, 0);\n\n\tPG_RETURN_DATUM(retValue);\n}"
  },
  {
    "function_name": "jsonb_int2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
    "lines": "1965-1981",
    "snippet": "Datum\njsonb_int2(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *in = PG_GETARG_JSONB_P(0);\n\tJsonbValue\tv;\n\tDatum\t\tretValue;\n\n\tif (!JsonbExtractScalar(&in->root, &v) || v.type != jbvNumeric)\n\t\tcannotCastJsonbValue(v.type, \"smallint\");\n\n\tretValue = DirectFunctionCall1(numeric_int2,\n\t\t\t\t\t\t\t\t   NumericGetDatum(v.val.numeric));\n\n\tPG_FREE_IF_COPY(in, 0);\n\n\tPG_RETURN_DATUM(retValue);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"miscadmin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_DATUM",
          "args": [
            "retValue"
          ],
          "line": 1980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "in",
            "0"
          ],
          "line": 1978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "numeric_int2",
            "NumericGetDatum(v.val.numeric)"
          ],
          "line": 1975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NumericGetDatum",
          "args": [
            "v.val.numeric"
          ],
          "line": 1976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cannotCastJsonbValue",
          "args": [
            "v.type",
            "\"smallint\""
          ],
          "line": 1973
        },
        "resolved": true,
        "details": {
          "function_name": "cannotCastJsonbValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
          "lines": "1900-1928",
          "snippet": "static void\ncannotCastJsonbValue(enum jbvType type, const char *sqltype)\n{\n\tstatic const struct\n\t{\n\t\tenum jbvType type;\n\t\tconst char *msg;\n\t}\n\t\t\t\tmessages[] =\n\t{\n\t\t{jbvNull, gettext_noop(\"cannot cast jsonb null to type %s\")},\n\t\t{jbvString, gettext_noop(\"cannot cast jsonb string to type %s\")},\n\t\t{jbvNumeric, gettext_noop(\"cannot cast jsonb numeric to type %s\")},\n\t\t{jbvBool, gettext_noop(\"cannot cast jsonb boolean to type %s\")},\n\t\t{jbvArray, gettext_noop(\"cannot cast jsonb array to type %s\")},\n\t\t{jbvObject, gettext_noop(\"cannot cast jsonb object to type %s\")},\n\t\t{jbvBinary, gettext_noop(\"cannot cast jsonb array or object to type %s\")}\n\t};\n\tint\t\t\ti;\n\n\tfor (i = 0; i < lengthof(messages); i++)\n\t\tif (messages[i].type == type)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(messages[i].msg, sqltype)));\n\n\t/* should be unreachable */\n\telog(ERROR, \"unknown jsonb type: %d\", (int) type);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"miscadmin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic void\ncannotCastJsonbValue(enum jbvType type, const char *sqltype)\n{\n\tstatic const struct\n\t{\n\t\tenum jbvType type;\n\t\tconst char *msg;\n\t}\n\t\t\t\tmessages[] =\n\t{\n\t\t{jbvNull, gettext_noop(\"cannot cast jsonb null to type %s\")},\n\t\t{jbvString, gettext_noop(\"cannot cast jsonb string to type %s\")},\n\t\t{jbvNumeric, gettext_noop(\"cannot cast jsonb numeric to type %s\")},\n\t\t{jbvBool, gettext_noop(\"cannot cast jsonb boolean to type %s\")},\n\t\t{jbvArray, gettext_noop(\"cannot cast jsonb array to type %s\")},\n\t\t{jbvObject, gettext_noop(\"cannot cast jsonb object to type %s\")},\n\t\t{jbvBinary, gettext_noop(\"cannot cast jsonb array or object to type %s\")}\n\t};\n\tint\t\t\ti;\n\n\tfor (i = 0; i < lengthof(messages); i++)\n\t\tif (messages[i].type == type)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(messages[i].msg, sqltype)));\n\n\t/* should be unreachable */\n\telog(ERROR, \"unknown jsonb type: %d\", (int) type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonbExtractScalar",
          "args": [
            "&in->root",
            "&v"
          ],
          "line": 1972
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbExtractScalar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
          "lines": "1860-1895",
          "snippet": "static bool\nJsonbExtractScalar(JsonbContainer *jbc, JsonbValue *res)\n{\n\tJsonbIterator *it;\n\tJsonbIteratorToken tok PG_USED_FOR_ASSERTS_ONLY;\n\tJsonbValue\ttmp;\n\n\tif (!JsonContainerIsArray(jbc) || !JsonContainerIsScalar(jbc))\n\t{\n\t\t/* inform caller about actual type of container */\n\t\tres->type = (JsonContainerIsArray(jbc)) ? jbvArray : jbvObject;\n\t\treturn false;\n\t}\n\n\t/*\n\t * A root scalar is stored as an array of one element, so we get the array\n\t * and then its first (and only) member.\n\t */\n\tit = JsonbIteratorInit(jbc);\n\n\ttok = JsonbIteratorNext(&it, &tmp, true);\n\tAssert(tok == WJB_BEGIN_ARRAY);\n\tAssert(tmp.val.array.nElems == 1 && tmp.val.array.rawScalar);\n\n\ttok = JsonbIteratorNext(&it, res, true);\n\tAssert(tok == WJB_ELEM);\n\tAssert(IsAJsonbScalar(res));\n\n\ttok = JsonbIteratorNext(&it, &tmp, true);\n\tAssert(tok == WJB_END_ARRAY);\n\n\ttok = JsonbIteratorNext(&it, &tmp, true);\n\tAssert(tok == WJB_DONE);\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"miscadmin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic bool\nJsonbExtractScalar(JsonbContainer *jbc, JsonbValue *res)\n{\n\tJsonbIterator *it;\n\tJsonbIteratorToken tok PG_USED_FOR_ASSERTS_ONLY;\n\tJsonbValue\ttmp;\n\n\tif (!JsonContainerIsArray(jbc) || !JsonContainerIsScalar(jbc))\n\t{\n\t\t/* inform caller about actual type of container */\n\t\tres->type = (JsonContainerIsArray(jbc)) ? jbvArray : jbvObject;\n\t\treturn false;\n\t}\n\n\t/*\n\t * A root scalar is stored as an array of one element, so we get the array\n\t * and then its first (and only) member.\n\t */\n\tit = JsonbIteratorInit(jbc);\n\n\ttok = JsonbIteratorNext(&it, &tmp, true);\n\tAssert(tok == WJB_BEGIN_ARRAY);\n\tAssert(tmp.val.array.nElems == 1 && tmp.val.array.rawScalar);\n\n\ttok = JsonbIteratorNext(&it, res, true);\n\tAssert(tok == WJB_ELEM);\n\tAssert(IsAJsonbScalar(res));\n\n\ttok = JsonbIteratorNext(&it, &tmp, true);\n\tAssert(tok == WJB_END_ARRAY);\n\n\ttok = JsonbIteratorNext(&it, &tmp, true);\n\tAssert(tok == WJB_DONE);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_JSONB_P",
          "args": [
            "0"
          ],
          "line": 1968
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nDatum\njsonb_int2(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *in = PG_GETARG_JSONB_P(0);\n\tJsonbValue\tv;\n\tDatum\t\tretValue;\n\n\tif (!JsonbExtractScalar(&in->root, &v) || v.type != jbvNumeric)\n\t\tcannotCastJsonbValue(v.type, \"smallint\");\n\n\tretValue = DirectFunctionCall1(numeric_int2,\n\t\t\t\t\t\t\t\t   NumericGetDatum(v.val.numeric));\n\n\tPG_FREE_IF_COPY(in, 0);\n\n\tPG_RETURN_DATUM(retValue);\n}"
  },
  {
    "function_name": "jsonb_numeric",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
    "lines": "1944-1963",
    "snippet": "Datum\njsonb_numeric(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *in = PG_GETARG_JSONB_P(0);\n\tJsonbValue\tv;\n\tNumeric\t\tretValue;\n\n\tif (!JsonbExtractScalar(&in->root, &v) || v.type != jbvNumeric)\n\t\tcannotCastJsonbValue(v.type, \"numeric\");\n\n\t/*\n\t * v.val.numeric points into jsonb body, so we need to make a copy to\n\t * return\n\t */\n\tretValue = DatumGetNumericCopy(NumericGetDatum(v.val.numeric));\n\n\tPG_FREE_IF_COPY(in, 0);\n\n\tPG_RETURN_NUMERIC(retValue);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"miscadmin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_NUMERIC",
          "args": [
            "retValue"
          ],
          "line": 1962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "in",
            "0"
          ],
          "line": 1960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetNumericCopy",
          "args": [
            "NumericGetDatum(v.val.numeric)"
          ],
          "line": 1958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NumericGetDatum",
          "args": [
            "v.val.numeric"
          ],
          "line": 1958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cannotCastJsonbValue",
          "args": [
            "v.type",
            "\"numeric\""
          ],
          "line": 1952
        },
        "resolved": true,
        "details": {
          "function_name": "cannotCastJsonbValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
          "lines": "1900-1928",
          "snippet": "static void\ncannotCastJsonbValue(enum jbvType type, const char *sqltype)\n{\n\tstatic const struct\n\t{\n\t\tenum jbvType type;\n\t\tconst char *msg;\n\t}\n\t\t\t\tmessages[] =\n\t{\n\t\t{jbvNull, gettext_noop(\"cannot cast jsonb null to type %s\")},\n\t\t{jbvString, gettext_noop(\"cannot cast jsonb string to type %s\")},\n\t\t{jbvNumeric, gettext_noop(\"cannot cast jsonb numeric to type %s\")},\n\t\t{jbvBool, gettext_noop(\"cannot cast jsonb boolean to type %s\")},\n\t\t{jbvArray, gettext_noop(\"cannot cast jsonb array to type %s\")},\n\t\t{jbvObject, gettext_noop(\"cannot cast jsonb object to type %s\")},\n\t\t{jbvBinary, gettext_noop(\"cannot cast jsonb array or object to type %s\")}\n\t};\n\tint\t\t\ti;\n\n\tfor (i = 0; i < lengthof(messages); i++)\n\t\tif (messages[i].type == type)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(messages[i].msg, sqltype)));\n\n\t/* should be unreachable */\n\telog(ERROR, \"unknown jsonb type: %d\", (int) type);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"miscadmin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic void\ncannotCastJsonbValue(enum jbvType type, const char *sqltype)\n{\n\tstatic const struct\n\t{\n\t\tenum jbvType type;\n\t\tconst char *msg;\n\t}\n\t\t\t\tmessages[] =\n\t{\n\t\t{jbvNull, gettext_noop(\"cannot cast jsonb null to type %s\")},\n\t\t{jbvString, gettext_noop(\"cannot cast jsonb string to type %s\")},\n\t\t{jbvNumeric, gettext_noop(\"cannot cast jsonb numeric to type %s\")},\n\t\t{jbvBool, gettext_noop(\"cannot cast jsonb boolean to type %s\")},\n\t\t{jbvArray, gettext_noop(\"cannot cast jsonb array to type %s\")},\n\t\t{jbvObject, gettext_noop(\"cannot cast jsonb object to type %s\")},\n\t\t{jbvBinary, gettext_noop(\"cannot cast jsonb array or object to type %s\")}\n\t};\n\tint\t\t\ti;\n\n\tfor (i = 0; i < lengthof(messages); i++)\n\t\tif (messages[i].type == type)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(messages[i].msg, sqltype)));\n\n\t/* should be unreachable */\n\telog(ERROR, \"unknown jsonb type: %d\", (int) type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonbExtractScalar",
          "args": [
            "&in->root",
            "&v"
          ],
          "line": 1951
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbExtractScalar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
          "lines": "1860-1895",
          "snippet": "static bool\nJsonbExtractScalar(JsonbContainer *jbc, JsonbValue *res)\n{\n\tJsonbIterator *it;\n\tJsonbIteratorToken tok PG_USED_FOR_ASSERTS_ONLY;\n\tJsonbValue\ttmp;\n\n\tif (!JsonContainerIsArray(jbc) || !JsonContainerIsScalar(jbc))\n\t{\n\t\t/* inform caller about actual type of container */\n\t\tres->type = (JsonContainerIsArray(jbc)) ? jbvArray : jbvObject;\n\t\treturn false;\n\t}\n\n\t/*\n\t * A root scalar is stored as an array of one element, so we get the array\n\t * and then its first (and only) member.\n\t */\n\tit = JsonbIteratorInit(jbc);\n\n\ttok = JsonbIteratorNext(&it, &tmp, true);\n\tAssert(tok == WJB_BEGIN_ARRAY);\n\tAssert(tmp.val.array.nElems == 1 && tmp.val.array.rawScalar);\n\n\ttok = JsonbIteratorNext(&it, res, true);\n\tAssert(tok == WJB_ELEM);\n\tAssert(IsAJsonbScalar(res));\n\n\ttok = JsonbIteratorNext(&it, &tmp, true);\n\tAssert(tok == WJB_END_ARRAY);\n\n\ttok = JsonbIteratorNext(&it, &tmp, true);\n\tAssert(tok == WJB_DONE);\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"miscadmin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic bool\nJsonbExtractScalar(JsonbContainer *jbc, JsonbValue *res)\n{\n\tJsonbIterator *it;\n\tJsonbIteratorToken tok PG_USED_FOR_ASSERTS_ONLY;\n\tJsonbValue\ttmp;\n\n\tif (!JsonContainerIsArray(jbc) || !JsonContainerIsScalar(jbc))\n\t{\n\t\t/* inform caller about actual type of container */\n\t\tres->type = (JsonContainerIsArray(jbc)) ? jbvArray : jbvObject;\n\t\treturn false;\n\t}\n\n\t/*\n\t * A root scalar is stored as an array of one element, so we get the array\n\t * and then its first (and only) member.\n\t */\n\tit = JsonbIteratorInit(jbc);\n\n\ttok = JsonbIteratorNext(&it, &tmp, true);\n\tAssert(tok == WJB_BEGIN_ARRAY);\n\tAssert(tmp.val.array.nElems == 1 && tmp.val.array.rawScalar);\n\n\ttok = JsonbIteratorNext(&it, res, true);\n\tAssert(tok == WJB_ELEM);\n\tAssert(IsAJsonbScalar(res));\n\n\ttok = JsonbIteratorNext(&it, &tmp, true);\n\tAssert(tok == WJB_END_ARRAY);\n\n\ttok = JsonbIteratorNext(&it, &tmp, true);\n\tAssert(tok == WJB_DONE);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_JSONB_P",
          "args": [
            "0"
          ],
          "line": 1947
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nDatum\njsonb_numeric(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *in = PG_GETARG_JSONB_P(0);\n\tJsonbValue\tv;\n\tNumeric\t\tretValue;\n\n\tif (!JsonbExtractScalar(&in->root, &v) || v.type != jbvNumeric)\n\t\tcannotCastJsonbValue(v.type, \"numeric\");\n\n\t/*\n\t * v.val.numeric points into jsonb body, so we need to make a copy to\n\t * return\n\t */\n\tretValue = DatumGetNumericCopy(NumericGetDatum(v.val.numeric));\n\n\tPG_FREE_IF_COPY(in, 0);\n\n\tPG_RETURN_NUMERIC(retValue);\n}"
  },
  {
    "function_name": "jsonb_bool",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
    "lines": "1930-1942",
    "snippet": "Datum\njsonb_bool(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *in = PG_GETARG_JSONB_P(0);\n\tJsonbValue\tv;\n\n\tif (!JsonbExtractScalar(&in->root, &v) || v.type != jbvBool)\n\t\tcannotCastJsonbValue(v.type, \"boolean\");\n\n\tPG_FREE_IF_COPY(in, 0);\n\n\tPG_RETURN_BOOL(v.val.boolean);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"miscadmin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "v.val.boolean"
          ],
          "line": 1941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "in",
            "0"
          ],
          "line": 1939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cannotCastJsonbValue",
          "args": [
            "v.type",
            "\"boolean\""
          ],
          "line": 1937
        },
        "resolved": true,
        "details": {
          "function_name": "cannotCastJsonbValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
          "lines": "1900-1928",
          "snippet": "static void\ncannotCastJsonbValue(enum jbvType type, const char *sqltype)\n{\n\tstatic const struct\n\t{\n\t\tenum jbvType type;\n\t\tconst char *msg;\n\t}\n\t\t\t\tmessages[] =\n\t{\n\t\t{jbvNull, gettext_noop(\"cannot cast jsonb null to type %s\")},\n\t\t{jbvString, gettext_noop(\"cannot cast jsonb string to type %s\")},\n\t\t{jbvNumeric, gettext_noop(\"cannot cast jsonb numeric to type %s\")},\n\t\t{jbvBool, gettext_noop(\"cannot cast jsonb boolean to type %s\")},\n\t\t{jbvArray, gettext_noop(\"cannot cast jsonb array to type %s\")},\n\t\t{jbvObject, gettext_noop(\"cannot cast jsonb object to type %s\")},\n\t\t{jbvBinary, gettext_noop(\"cannot cast jsonb array or object to type %s\")}\n\t};\n\tint\t\t\ti;\n\n\tfor (i = 0; i < lengthof(messages); i++)\n\t\tif (messages[i].type == type)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(messages[i].msg, sqltype)));\n\n\t/* should be unreachable */\n\telog(ERROR, \"unknown jsonb type: %d\", (int) type);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"miscadmin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic void\ncannotCastJsonbValue(enum jbvType type, const char *sqltype)\n{\n\tstatic const struct\n\t{\n\t\tenum jbvType type;\n\t\tconst char *msg;\n\t}\n\t\t\t\tmessages[] =\n\t{\n\t\t{jbvNull, gettext_noop(\"cannot cast jsonb null to type %s\")},\n\t\t{jbvString, gettext_noop(\"cannot cast jsonb string to type %s\")},\n\t\t{jbvNumeric, gettext_noop(\"cannot cast jsonb numeric to type %s\")},\n\t\t{jbvBool, gettext_noop(\"cannot cast jsonb boolean to type %s\")},\n\t\t{jbvArray, gettext_noop(\"cannot cast jsonb array to type %s\")},\n\t\t{jbvObject, gettext_noop(\"cannot cast jsonb object to type %s\")},\n\t\t{jbvBinary, gettext_noop(\"cannot cast jsonb array or object to type %s\")}\n\t};\n\tint\t\t\ti;\n\n\tfor (i = 0; i < lengthof(messages); i++)\n\t\tif (messages[i].type == type)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(messages[i].msg, sqltype)));\n\n\t/* should be unreachable */\n\telog(ERROR, \"unknown jsonb type: %d\", (int) type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonbExtractScalar",
          "args": [
            "&in->root",
            "&v"
          ],
          "line": 1936
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbExtractScalar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
          "lines": "1860-1895",
          "snippet": "static bool\nJsonbExtractScalar(JsonbContainer *jbc, JsonbValue *res)\n{\n\tJsonbIterator *it;\n\tJsonbIteratorToken tok PG_USED_FOR_ASSERTS_ONLY;\n\tJsonbValue\ttmp;\n\n\tif (!JsonContainerIsArray(jbc) || !JsonContainerIsScalar(jbc))\n\t{\n\t\t/* inform caller about actual type of container */\n\t\tres->type = (JsonContainerIsArray(jbc)) ? jbvArray : jbvObject;\n\t\treturn false;\n\t}\n\n\t/*\n\t * A root scalar is stored as an array of one element, so we get the array\n\t * and then its first (and only) member.\n\t */\n\tit = JsonbIteratorInit(jbc);\n\n\ttok = JsonbIteratorNext(&it, &tmp, true);\n\tAssert(tok == WJB_BEGIN_ARRAY);\n\tAssert(tmp.val.array.nElems == 1 && tmp.val.array.rawScalar);\n\n\ttok = JsonbIteratorNext(&it, res, true);\n\tAssert(tok == WJB_ELEM);\n\tAssert(IsAJsonbScalar(res));\n\n\ttok = JsonbIteratorNext(&it, &tmp, true);\n\tAssert(tok == WJB_END_ARRAY);\n\n\ttok = JsonbIteratorNext(&it, &tmp, true);\n\tAssert(tok == WJB_DONE);\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"miscadmin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic bool\nJsonbExtractScalar(JsonbContainer *jbc, JsonbValue *res)\n{\n\tJsonbIterator *it;\n\tJsonbIteratorToken tok PG_USED_FOR_ASSERTS_ONLY;\n\tJsonbValue\ttmp;\n\n\tif (!JsonContainerIsArray(jbc) || !JsonContainerIsScalar(jbc))\n\t{\n\t\t/* inform caller about actual type of container */\n\t\tres->type = (JsonContainerIsArray(jbc)) ? jbvArray : jbvObject;\n\t\treturn false;\n\t}\n\n\t/*\n\t * A root scalar is stored as an array of one element, so we get the array\n\t * and then its first (and only) member.\n\t */\n\tit = JsonbIteratorInit(jbc);\n\n\ttok = JsonbIteratorNext(&it, &tmp, true);\n\tAssert(tok == WJB_BEGIN_ARRAY);\n\tAssert(tmp.val.array.nElems == 1 && tmp.val.array.rawScalar);\n\n\ttok = JsonbIteratorNext(&it, res, true);\n\tAssert(tok == WJB_ELEM);\n\tAssert(IsAJsonbScalar(res));\n\n\ttok = JsonbIteratorNext(&it, &tmp, true);\n\tAssert(tok == WJB_END_ARRAY);\n\n\ttok = JsonbIteratorNext(&it, &tmp, true);\n\tAssert(tok == WJB_DONE);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_JSONB_P",
          "args": [
            "0"
          ],
          "line": 1933
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nDatum\njsonb_bool(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *in = PG_GETARG_JSONB_P(0);\n\tJsonbValue\tv;\n\n\tif (!JsonbExtractScalar(&in->root, &v) || v.type != jbvBool)\n\t\tcannotCastJsonbValue(v.type, \"boolean\");\n\n\tPG_FREE_IF_COPY(in, 0);\n\n\tPG_RETURN_BOOL(v.val.boolean);\n}"
  },
  {
    "function_name": "cannotCastJsonbValue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
    "lines": "1900-1928",
    "snippet": "static void\ncannotCastJsonbValue(enum jbvType type, const char *sqltype)\n{\n\tstatic const struct\n\t{\n\t\tenum jbvType type;\n\t\tconst char *msg;\n\t}\n\t\t\t\tmessages[] =\n\t{\n\t\t{jbvNull, gettext_noop(\"cannot cast jsonb null to type %s\")},\n\t\t{jbvString, gettext_noop(\"cannot cast jsonb string to type %s\")},\n\t\t{jbvNumeric, gettext_noop(\"cannot cast jsonb numeric to type %s\")},\n\t\t{jbvBool, gettext_noop(\"cannot cast jsonb boolean to type %s\")},\n\t\t{jbvArray, gettext_noop(\"cannot cast jsonb array to type %s\")},\n\t\t{jbvObject, gettext_noop(\"cannot cast jsonb object to type %s\")},\n\t\t{jbvBinary, gettext_noop(\"cannot cast jsonb array or object to type %s\")}\n\t};\n\tint\t\t\ti;\n\n\tfor (i = 0; i < lengthof(messages); i++)\n\t\tif (messages[i].type == type)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(messages[i].msg, sqltype)));\n\n\t/* should be unreachable */\n\telog(ERROR, \"unknown jsonb type: %d\", (int) type);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"miscadmin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unknown jsonb type: %d\"",
            "(int) type"
          ],
          "line": 1927
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(messages[i].msg, sqltype))"
          ],
          "line": 1922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "messages[i].msg",
            "sqltype"
          ],
          "line": 1924
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 1923
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "lengthof",
          "args": [
            "messages"
          ],
          "line": 1920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gettext_noop",
          "args": [
            "\"cannot cast jsonb array or object to type %s\""
          ],
          "line": 1916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gettext_noop",
          "args": [
            "\"cannot cast jsonb object to type %s\""
          ],
          "line": 1915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gettext_noop",
          "args": [
            "\"cannot cast jsonb array to type %s\""
          ],
          "line": 1914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gettext_noop",
          "args": [
            "\"cannot cast jsonb boolean to type %s\""
          ],
          "line": 1913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gettext_noop",
          "args": [
            "\"cannot cast jsonb numeric to type %s\""
          ],
          "line": 1912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gettext_noop",
          "args": [
            "\"cannot cast jsonb string to type %s\""
          ],
          "line": 1911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gettext_noop",
          "args": [
            "\"cannot cast jsonb null to type %s\""
          ],
          "line": 1910
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic void\ncannotCastJsonbValue(enum jbvType type, const char *sqltype)\n{\n\tstatic const struct\n\t{\n\t\tenum jbvType type;\n\t\tconst char *msg;\n\t}\n\t\t\t\tmessages[] =\n\t{\n\t\t{jbvNull, gettext_noop(\"cannot cast jsonb null to type %s\")},\n\t\t{jbvString, gettext_noop(\"cannot cast jsonb string to type %s\")},\n\t\t{jbvNumeric, gettext_noop(\"cannot cast jsonb numeric to type %s\")},\n\t\t{jbvBool, gettext_noop(\"cannot cast jsonb boolean to type %s\")},\n\t\t{jbvArray, gettext_noop(\"cannot cast jsonb array to type %s\")},\n\t\t{jbvObject, gettext_noop(\"cannot cast jsonb object to type %s\")},\n\t\t{jbvBinary, gettext_noop(\"cannot cast jsonb array or object to type %s\")}\n\t};\n\tint\t\t\ti;\n\n\tfor (i = 0; i < lengthof(messages); i++)\n\t\tif (messages[i].type == type)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(messages[i].msg, sqltype)));\n\n\t/* should be unreachable */\n\telog(ERROR, \"unknown jsonb type: %d\", (int) type);\n}"
  },
  {
    "function_name": "JsonbExtractScalar",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
    "lines": "1860-1895",
    "snippet": "static bool\nJsonbExtractScalar(JsonbContainer *jbc, JsonbValue *res)\n{\n\tJsonbIterator *it;\n\tJsonbIteratorToken tok PG_USED_FOR_ASSERTS_ONLY;\n\tJsonbValue\ttmp;\n\n\tif (!JsonContainerIsArray(jbc) || !JsonContainerIsScalar(jbc))\n\t{\n\t\t/* inform caller about actual type of container */\n\t\tres->type = (JsonContainerIsArray(jbc)) ? jbvArray : jbvObject;\n\t\treturn false;\n\t}\n\n\t/*\n\t * A root scalar is stored as an array of one element, so we get the array\n\t * and then its first (and only) member.\n\t */\n\tit = JsonbIteratorInit(jbc);\n\n\ttok = JsonbIteratorNext(&it, &tmp, true);\n\tAssert(tok == WJB_BEGIN_ARRAY);\n\tAssert(tmp.val.array.nElems == 1 && tmp.val.array.rawScalar);\n\n\ttok = JsonbIteratorNext(&it, res, true);\n\tAssert(tok == WJB_ELEM);\n\tAssert(IsAJsonbScalar(res));\n\n\ttok = JsonbIteratorNext(&it, &tmp, true);\n\tAssert(tok == WJB_END_ARRAY);\n\n\ttok = JsonbIteratorNext(&it, &tmp, true);\n\tAssert(tok == WJB_DONE);\n\n\treturn true;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"miscadmin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "tok == WJB_DONE"
          ],
          "line": 1892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JsonbIteratorNext",
          "args": [
            "&it",
            "&tmp",
            "true"
          ],
          "line": 1891
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbIteratorNext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "753-894",
          "snippet": "JsonbIteratorToken\nJsonbIteratorNext(JsonbIterator **it, JsonbValue *val, bool skipNested)\n{\n\tif (*it == NULL)\n\t\treturn WJB_DONE;\n\n\t/*\n\t * When stepping into a nested container, we jump back here to start\n\t * processing the child. We will not recurse further in one call, because\n\t * processing the child will always begin in JBI_ARRAY_START or\n\t * JBI_OBJECT_START state.\n\t */\nrecurse:\n\tswitch ((*it)->state)\n\t{\n\t\tcase JBI_ARRAY_START:\n\t\t\t/* Set v to array on first array call */\n\t\t\tval->type = jbvArray;\n\t\t\tval->val.array.nElems = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.array.elems is not actually set, because we aren't doing\n\t\t\t * a full conversion\n\t\t\t */\n\t\t\tval->val.array.rawScalar = (*it)->isScalar;\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = 0;\t/* not actually used */\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_ARRAY_ELEM;\n\t\t\treturn WJB_BEGIN_ARRAY;\n\n\t\tcase JBI_ARRAY_ELEM:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All elements within array already processed.  Report this\n\t\t\t\t * to caller, and give it back original parent iterator (which\n\t\t\t\t * independently tracks iteration progress at its level of\n\t\t\t\t * nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_ARRAY;\n\t\t\t}\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t/* Recurse into container. */\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scalar item in array, or a container and caller didn't want\n\t\t\t\t * us to recurse into it.\n\t\t\t\t */\n\t\t\t\treturn WJB_ELEM;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_START:\n\t\t\t/* Set v to object on first object call */\n\t\t\tval->type = jbvObject;\n\t\t\tval->val.object.nPairs = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.object.pairs is not actually set, because we aren't\n\t\t\t * doing a full conversion\n\t\t\t */\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = getJsonbOffset((*it)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t   (*it)->nElems);\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\t\t\treturn WJB_BEGIN_OBJECT;\n\n\t\tcase JBI_OBJECT_KEY:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All pairs within object already processed.  Report this to\n\t\t\t\t * caller, and give it back original containing iterator\n\t\t\t\t * (which independently tracks iteration progress at its level\n\t\t\t\t * of nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_OBJECT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Return key of a key/value pair.  */\n\t\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t\t   val);\n\t\t\t\tif (val->type != jbvString)\n\t\t\t\t\telog(ERROR, \"unexpected jsonb type as object key\");\n\n\t\t\t\t/* Set state for next call */\n\t\t\t\t(*it)->state = JBI_OBJECT_VALUE;\n\t\t\t\treturn WJB_KEY;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_VALUE:\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex + (*it)->nElems,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curValueOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curValueOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex + (*it)->nElems]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\t/*\n\t\t\t * Value may be a container, in which case we recurse with new,\n\t\t\t * child iterator (unless the caller asked not to, by passing\n\t\t\t * skipNested).\n\t\t\t */\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn WJB_VALUE;\n\t}\n\n\telog(ERROR, \"invalid iterator state\");\n\treturn -1;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbIterator *freeAndGetParent(JsonbIterator *it);",
            "static void uniqueifyJsonbObject(JsonbValue *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbIterator *freeAndGetParent(JsonbIterator *it);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\n\nJsonbIteratorToken\nJsonbIteratorNext(JsonbIterator **it, JsonbValue *val, bool skipNested)\n{\n\tif (*it == NULL)\n\t\treturn WJB_DONE;\n\n\t/*\n\t * When stepping into a nested container, we jump back here to start\n\t * processing the child. We will not recurse further in one call, because\n\t * processing the child will always begin in JBI_ARRAY_START or\n\t * JBI_OBJECT_START state.\n\t */\nrecurse:\n\tswitch ((*it)->state)\n\t{\n\t\tcase JBI_ARRAY_START:\n\t\t\t/* Set v to array on first array call */\n\t\t\tval->type = jbvArray;\n\t\t\tval->val.array.nElems = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.array.elems is not actually set, because we aren't doing\n\t\t\t * a full conversion\n\t\t\t */\n\t\t\tval->val.array.rawScalar = (*it)->isScalar;\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = 0;\t/* not actually used */\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_ARRAY_ELEM;\n\t\t\treturn WJB_BEGIN_ARRAY;\n\n\t\tcase JBI_ARRAY_ELEM:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All elements within array already processed.  Report this\n\t\t\t\t * to caller, and give it back original parent iterator (which\n\t\t\t\t * independently tracks iteration progress at its level of\n\t\t\t\t * nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_ARRAY;\n\t\t\t}\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t/* Recurse into container. */\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scalar item in array, or a container and caller didn't want\n\t\t\t\t * us to recurse into it.\n\t\t\t\t */\n\t\t\t\treturn WJB_ELEM;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_START:\n\t\t\t/* Set v to object on first object call */\n\t\t\tval->type = jbvObject;\n\t\t\tval->val.object.nPairs = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.object.pairs is not actually set, because we aren't\n\t\t\t * doing a full conversion\n\t\t\t */\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = getJsonbOffset((*it)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t   (*it)->nElems);\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\t\t\treturn WJB_BEGIN_OBJECT;\n\n\t\tcase JBI_OBJECT_KEY:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All pairs within object already processed.  Report this to\n\t\t\t\t * caller, and give it back original containing iterator\n\t\t\t\t * (which independently tracks iteration progress at its level\n\t\t\t\t * of nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_OBJECT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Return key of a key/value pair.  */\n\t\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t\t   val);\n\t\t\t\tif (val->type != jbvString)\n\t\t\t\t\telog(ERROR, \"unexpected jsonb type as object key\");\n\n\t\t\t\t/* Set state for next call */\n\t\t\t\t(*it)->state = JBI_OBJECT_VALUE;\n\t\t\t\treturn WJB_KEY;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_VALUE:\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex + (*it)->nElems,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curValueOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curValueOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex + (*it)->nElems]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\t/*\n\t\t\t * Value may be a container, in which case we recurse with new,\n\t\t\t * child iterator (unless the caller asked not to, by passing\n\t\t\t * skipNested).\n\t\t\t */\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn WJB_VALUE;\n\t}\n\n\telog(ERROR, \"invalid iterator state\");\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "tok == WJB_END_ARRAY"
          ],
          "line": 1889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "IsAJsonbScalar(res)"
          ],
          "line": 1886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsAJsonbScalar",
          "args": [
            "res"
          ],
          "line": 1886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "tok == WJB_ELEM"
          ],
          "line": 1885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "tmp.val.array.nElems == 1 && tmp.val.array.rawScalar"
          ],
          "line": 1882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "tok == WJB_BEGIN_ARRAY"
          ],
          "line": 1881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JsonbIteratorInit",
          "args": [
            "jbc"
          ],
          "line": 1878
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbIteratorInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "717-721",
          "snippet": "JsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nJsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonContainerIsArray",
          "args": [
            "jbc"
          ],
          "line": 1870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JsonContainerIsScalar",
          "args": [
            "jbc"
          ],
          "line": 1867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JsonContainerIsArray",
          "args": [
            "jbc"
          ],
          "line": 1867
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic bool\nJsonbExtractScalar(JsonbContainer *jbc, JsonbValue *res)\n{\n\tJsonbIterator *it;\n\tJsonbIteratorToken tok PG_USED_FOR_ASSERTS_ONLY;\n\tJsonbValue\ttmp;\n\n\tif (!JsonContainerIsArray(jbc) || !JsonContainerIsScalar(jbc))\n\t{\n\t\t/* inform caller about actual type of container */\n\t\tres->type = (JsonContainerIsArray(jbc)) ? jbvArray : jbvObject;\n\t\treturn false;\n\t}\n\n\t/*\n\t * A root scalar is stored as an array of one element, so we get the array\n\t * and then its first (and only) member.\n\t */\n\tit = JsonbIteratorInit(jbc);\n\n\ttok = JsonbIteratorNext(&it, &tmp, true);\n\tAssert(tok == WJB_BEGIN_ARRAY);\n\tAssert(tmp.val.array.nElems == 1 && tmp.val.array.rawScalar);\n\n\ttok = JsonbIteratorNext(&it, res, true);\n\tAssert(tok == WJB_ELEM);\n\tAssert(IsAJsonbScalar(res));\n\n\ttok = JsonbIteratorNext(&it, &tmp, true);\n\tAssert(tok == WJB_END_ARRAY);\n\n\ttok = JsonbIteratorNext(&it, &tmp, true);\n\tAssert(tok == WJB_DONE);\n\n\treturn true;\n}"
  },
  {
    "function_name": "jsonb_object_agg_finalfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
    "lines": "1823-1854",
    "snippet": "Datum\njsonb_object_agg_finalfn(PG_FUNCTION_ARGS)\n{\n\tJsonbAggState *arg;\n\tJsonbInState result;\n\tJsonb\t   *out;\n\n\t/* cannot be called directly because of internal-type argument */\n\tAssert(AggCheckCallContext(fcinfo, NULL));\n\n\tif (PG_ARGISNULL(0))\n\t\tPG_RETURN_NULL();\t\t/* returns null iff no input values */\n\n\targ = (JsonbAggState *) PG_GETARG_POINTER(0);\n\n\t/*\n\t * We need to do a shallow clone of the argument's res field in case the\n\t * final function is called more than once, so we avoid changing the\n\t * aggregate state value.  A shallow clone is sufficient as we aren't\n\t * going to change any of the values, just add the final object end\n\t * marker.\n\t */\n\n\tresult.parseState = clone_parse_state(arg->res->parseState);\n\n\tresult.res = pushJsonbValue(&result.parseState,\n\t\t\t\t\t\t\t\tWJB_END_OBJECT, NULL);\n\n\tout = JsonbValueToJsonb(result.res);\n\n\tPG_RETURN_POINTER(out);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"miscadmin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void composite_to_jsonb(Datum composite, JsonbInState *result);",
      "static void array_to_jsonb_internal(Datum array, JsonbInState *result);",
      "static JsonbParseState *clone_parse_state(JsonbParseState *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "out"
          ],
          "line": 1853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JsonbValueToJsonb",
          "args": [
            "result.res"
          ],
          "line": 1851
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbValueToJsonb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "78-113",
          "snippet": "Jsonb *\nJsonbValueToJsonb(JsonbValue *val)\n{\n\tJsonb\t   *out;\n\n\tif (IsAJsonbScalar(val))\n\t{\n\t\t/* Scalar value */\n\t\tJsonbParseState *pstate = NULL;\n\t\tJsonbValue *res;\n\t\tJsonbValue\tscalarArray;\n\n\t\tscalarArray.type = jbvArray;\n\t\tscalarArray.val.array.rawScalar = true;\n\t\tscalarArray.val.array.nElems = 1;\n\n\t\tpushJsonbValue(&pstate, WJB_BEGIN_ARRAY, &scalarArray);\n\t\tpushJsonbValue(&pstate, WJB_ELEM, val);\n\t\tres = pushJsonbValue(&pstate, WJB_END_ARRAY, NULL);\n\n\t\tout = convertToJsonb(res);\n\t}\n\telse if (val->type == jbvObject || val->type == jbvArray)\n\t{\n\t\tout = convertToJsonb(val);\n\t}\n\telse\n\t{\n\t\tAssert(val->type == jbvBinary);\n\t\tout = palloc(VARHDRSZ + val->val.binary.len);\n\t\tSET_VARSIZE(out, VARHDRSZ + val->val.binary.len);\n\t\tmemcpy(VARDATA(out), val->val.binary.data, val->val.binary.len);\n\t}\n\n\treturn out;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static int\treserveFromBuffer(StringInfo buffer, int len);",
            "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
            "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
            "static JsonbParseState *pushState(JsonbParseState **pstate);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\n\nJsonb *\nJsonbValueToJsonb(JsonbValue *val)\n{\n\tJsonb\t   *out;\n\n\tif (IsAJsonbScalar(val))\n\t{\n\t\t/* Scalar value */\n\t\tJsonbParseState *pstate = NULL;\n\t\tJsonbValue *res;\n\t\tJsonbValue\tscalarArray;\n\n\t\tscalarArray.type = jbvArray;\n\t\tscalarArray.val.array.rawScalar = true;\n\t\tscalarArray.val.array.nElems = 1;\n\n\t\tpushJsonbValue(&pstate, WJB_BEGIN_ARRAY, &scalarArray);\n\t\tpushJsonbValue(&pstate, WJB_ELEM, val);\n\t\tres = pushJsonbValue(&pstate, WJB_END_ARRAY, NULL);\n\n\t\tout = convertToJsonb(res);\n\t}\n\telse if (val->type == jbvObject || val->type == jbvArray)\n\t{\n\t\tout = convertToJsonb(val);\n\t}\n\telse\n\t{\n\t\tAssert(val->type == jbvBinary);\n\t\tout = palloc(VARHDRSZ + val->val.binary.len);\n\t\tSET_VARSIZE(out, VARHDRSZ + val->val.binary.len);\n\t\tmemcpy(VARDATA(out), val->val.binary.data, val->val.binary.len);\n\t}\n\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pushJsonbValue",
          "args": [
            "&result.parseState",
            "WJB_END_OBJECT",
            "NULL"
          ],
          "line": 1848
        },
        "resolved": true,
        "details": {
          "function_name": "pushJsonbValueScalar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "545-629",
          "snippet": "static JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);",
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbParseState *pushState(JsonbParseState **pstate);",
            "static void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void uniqueifyJsonbObject(JsonbValue *object);",
            "static JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\nstatic void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\nstatic JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);\n\nstatic JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clone_parse_state",
          "args": [
            "arg->res->parseState"
          ],
          "line": 1846
        },
        "resolved": true,
        "details": {
          "function_name": "clone_parse_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
          "lines": "1442-1468",
          "snippet": "static JsonbParseState *\nclone_parse_state(JsonbParseState *state)\n{\n\tJsonbParseState *result,\n\t\t\t   *icursor,\n\t\t\t   *ocursor;\n\n\tif (state == NULL)\n\t\treturn NULL;\n\n\tresult = palloc(sizeof(JsonbParseState));\n\ticursor = state;\n\tocursor = result;\n\tfor (;;)\n\t{\n\t\tocursor->contVal = icursor->contVal;\n\t\tocursor->size = icursor->size;\n\t\ticursor = icursor->next;\n\t\tif (icursor == NULL)\n\t\t\tbreak;\n\t\tocursor->next = palloc(sizeof(JsonbParseState));\n\t\tocursor = ocursor->next;\n\t}\n\tocursor->next = NULL;\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"miscadmin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void composite_to_jsonb(Datum composite, JsonbInState *result);",
            "static void array_to_jsonb_internal(Datum array, JsonbInState *result);",
            "static JsonbParseState *clone_parse_state(JsonbParseState *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic void composite_to_jsonb(Datum composite, JsonbInState *result);\nstatic void array_to_jsonb_internal(Datum array, JsonbInState *result);\nstatic JsonbParseState *clone_parse_state(JsonbParseState *state);\n\nstatic JsonbParseState *\nclone_parse_state(JsonbParseState *state)\n{\n\tJsonbParseState *result,\n\t\t\t   *icursor,\n\t\t\t   *ocursor;\n\n\tif (state == NULL)\n\t\treturn NULL;\n\n\tresult = palloc(sizeof(JsonbParseState));\n\ticursor = state;\n\tocursor = result;\n\tfor (;;)\n\t{\n\t\tocursor->contVal = icursor->contVal;\n\t\tocursor->size = icursor->size;\n\t\ticursor = icursor->next;\n\t\tif (icursor == NULL)\n\t\t\tbreak;\n\t\tocursor->next = palloc(sizeof(JsonbParseState));\n\t\tocursor = ocursor->next;\n\t}\n\tocursor->next = NULL;\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 1836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 1834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "0"
          ],
          "line": 1833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "AggCheckCallContext(fcinfo, NULL)"
          ],
          "line": 1831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AggCheckCallContext",
          "args": [
            "fcinfo",
            "NULL"
          ],
          "line": 1831
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic void composite_to_jsonb(Datum composite, JsonbInState *result);\nstatic void array_to_jsonb_internal(Datum array, JsonbInState *result);\nstatic JsonbParseState *clone_parse_state(JsonbParseState *state);\n\nDatum\njsonb_object_agg_finalfn(PG_FUNCTION_ARGS)\n{\n\tJsonbAggState *arg;\n\tJsonbInState result;\n\tJsonb\t   *out;\n\n\t/* cannot be called directly because of internal-type argument */\n\tAssert(AggCheckCallContext(fcinfo, NULL));\n\n\tif (PG_ARGISNULL(0))\n\t\tPG_RETURN_NULL();\t\t/* returns null iff no input values */\n\n\targ = (JsonbAggState *) PG_GETARG_POINTER(0);\n\n\t/*\n\t * We need to do a shallow clone of the argument's res field in case the\n\t * final function is called more than once, so we avoid changing the\n\t * aggregate state value.  A shallow clone is sufficient as we aren't\n\t * going to change any of the values, just add the final object end\n\t * marker.\n\t */\n\n\tresult.parseState = clone_parse_state(arg->res->parseState);\n\n\tresult.res = pushJsonbValue(&result.parseState,\n\t\t\t\t\t\t\t\tWJB_END_OBJECT, NULL);\n\n\tout = JsonbValueToJsonb(result.res);\n\n\tPG_RETURN_POINTER(out);\n}"
  },
  {
    "function_name": "jsonb_object_agg_transfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
    "lines": "1627-1821",
    "snippet": "Datum\njsonb_object_agg_transfn(PG_FUNCTION_ARGS)\n{\n\tMemoryContext oldcontext,\n\t\t\t\taggcontext;\n\tJsonbInState elem;\n\tJsonbAggState *state;\n\tDatum\t\tval;\n\tJsonbInState *result;\n\tbool\t\tsingle_scalar;\n\tJsonbIterator *it;\n\tJsonb\t   *jbkey,\n\t\t\t   *jbval;\n\tJsonbValue\tv;\n\tJsonbIteratorToken type;\n\n\tif (!AggCheckCallContext(fcinfo, &aggcontext))\n\t{\n\t\t/* cannot be called directly because of internal-type argument */\n\t\telog(ERROR, \"jsonb_object_agg_transfn called in non-aggregate context\");\n\t}\n\n\t/* set up the accumulator on the first go round */\n\n\tif (PG_ARGISNULL(0))\n\t{\n\t\tOid\t\t\targ_type;\n\n\t\toldcontext = MemoryContextSwitchTo(aggcontext);\n\t\tstate = palloc(sizeof(JsonbAggState));\n\t\tresult = palloc0(sizeof(JsonbInState));\n\t\tstate->res = result;\n\t\tresult->res = pushJsonbValue(&result->parseState,\n\t\t\t\t\t\t\t\t\t WJB_BEGIN_OBJECT, NULL);\n\t\tMemoryContextSwitchTo(oldcontext);\n\n\t\targ_type = get_fn_expr_argtype(fcinfo->flinfo, 1);\n\n\t\tif (arg_type == InvalidOid)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"could not determine input data type\")));\n\n\t\tjsonb_categorize_type(arg_type, &state->key_category,\n\t\t\t\t\t\t\t  &state->key_output_func);\n\n\t\targ_type = get_fn_expr_argtype(fcinfo->flinfo, 2);\n\n\t\tif (arg_type == InvalidOid)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"could not determine input data type\")));\n\n\t\tjsonb_categorize_type(arg_type, &state->val_category,\n\t\t\t\t\t\t\t  &state->val_output_func);\n\t}\n\telse\n\t{\n\t\tstate = (JsonbAggState *) PG_GETARG_POINTER(0);\n\t\tresult = state->res;\n\t}\n\n\t/* turn the argument into jsonb in the normal function context */\n\n\tif (PG_ARGISNULL(1))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"field name must not be null\")));\n\n\tval = PG_GETARG_DATUM(1);\n\n\tmemset(&elem, 0, sizeof(JsonbInState));\n\n\tdatum_to_jsonb(val, false, &elem, state->key_category,\n\t\t\t\t   state->key_output_func, true);\n\n\tjbkey = JsonbValueToJsonb(elem.res);\n\n\tval = PG_ARGISNULL(2) ? (Datum) 0 : PG_GETARG_DATUM(2);\n\n\tmemset(&elem, 0, sizeof(JsonbInState));\n\n\tdatum_to_jsonb(val, PG_ARGISNULL(2), &elem, state->val_category,\n\t\t\t\t   state->val_output_func, false);\n\n\tjbval = JsonbValueToJsonb(elem.res);\n\n\tit = JsonbIteratorInit(&jbkey->root);\n\n\t/* switch to the aggregate context for accumulation operations */\n\n\toldcontext = MemoryContextSwitchTo(aggcontext);\n\n\t/*\n\t * keys should be scalar, and we should have already checked for that\n\t * above when calling datum_to_jsonb, so we only need to look for these\n\t * things.\n\t */\n\n\twhile ((type = JsonbIteratorNext(&it, &v, false)) != WJB_DONE)\n\t{\n\t\tswitch (type)\n\t\t{\n\t\t\tcase WJB_BEGIN_ARRAY:\n\t\t\t\tif (!v.val.array.rawScalar)\n\t\t\t\t\telog(ERROR, \"unexpected structure for key\");\n\t\t\t\tbreak;\n\t\t\tcase WJB_ELEM:\n\t\t\t\tif (v.type == jbvString)\n\t\t\t\t{\n\t\t\t\t\t/* copy string values in the aggregate context */\n\t\t\t\t\tchar\t   *buf = palloc(v.val.string.len + 1);\n\n\t\t\t\t\tsnprintf(buf, v.val.string.len + 1, \"%s\", v.val.string.val);\n\t\t\t\t\tv.val.string.val = buf;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t\t errmsg(\"object keys must be strings\")));\n\t\t\t\t}\n\t\t\t\tresult->res = pushJsonbValue(&result->parseState,\n\t\t\t\t\t\t\t\t\t\t\t WJB_KEY, &v);\n\t\t\t\tbreak;\n\t\t\tcase WJB_END_ARRAY:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unexpected structure for key\");\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tit = JsonbIteratorInit(&jbval->root);\n\n\tsingle_scalar = false;\n\n\t/*\n\t * values can be anything, including structured and null, so we treat them\n\t * as in json_agg_transfn, except that single scalars are always pushed as\n\t * WJB_VALUE items.\n\t */\n\n\twhile ((type = JsonbIteratorNext(&it, &v, false)) != WJB_DONE)\n\t{\n\t\tswitch (type)\n\t\t{\n\t\t\tcase WJB_BEGIN_ARRAY:\n\t\t\t\tif (v.val.array.rawScalar)\n\t\t\t\t\tsingle_scalar = true;\n\t\t\t\telse\n\t\t\t\t\tresult->res = pushJsonbValue(&result->parseState,\n\t\t\t\t\t\t\t\t\t\t\t\t type, NULL);\n\t\t\t\tbreak;\n\t\t\tcase WJB_END_ARRAY:\n\t\t\t\tif (!single_scalar)\n\t\t\t\t\tresult->res = pushJsonbValue(&result->parseState,\n\t\t\t\t\t\t\t\t\t\t\t\t type, NULL);\n\t\t\t\tbreak;\n\t\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tcase WJB_END_OBJECT:\n\t\t\t\tresult->res = pushJsonbValue(&result->parseState,\n\t\t\t\t\t\t\t\t\t\t\t type, NULL);\n\t\t\t\tbreak;\n\t\t\tcase WJB_ELEM:\n\t\t\tcase WJB_KEY:\n\t\t\tcase WJB_VALUE:\n\t\t\t\tif (v.type == jbvString)\n\t\t\t\t{\n\t\t\t\t\t/* copy string values in the aggregate context */\n\t\t\t\t\tchar\t   *buf = palloc(v.val.string.len + 1);\n\n\t\t\t\t\tsnprintf(buf, v.val.string.len + 1, \"%s\", v.val.string.val);\n\t\t\t\t\tv.val.string.val = buf;\n\t\t\t\t}\n\t\t\t\telse if (v.type == jbvNumeric)\n\t\t\t\t{\n\t\t\t\t\t/* same for numeric */\n\t\t\t\t\tv.val.numeric =\n\t\t\t\t\t\tDatumGetNumeric(DirectFunctionCall1(numeric_uplus,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tNumericGetDatum(v.val.numeric)));\n\t\t\t\t}\n\t\t\t\tresult->res = pushJsonbValue(&result->parseState,\n\t\t\t\t\t\t\t\t\t\t\t single_scalar ? WJB_VALUE : type,\n\t\t\t\t\t\t\t\t\t\t\t &v);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unknown jsonb iterator token type\");\n\t\t}\n\t}\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\tPG_RETURN_POINTER(state);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"miscadmin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static inline Datum jsonb_from_cstring(char *json, int len);",
      "static size_t checkStringLen(size_t len);",
      "static void composite_to_jsonb(Datum composite, JsonbInState *result);",
      "static void array_to_jsonb_internal(Datum array, JsonbInState *result);",
      "static JsonbParseState *clone_parse_state(JsonbParseState *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "state"
          ],
          "line": 1820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 1818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unknown jsonb iterator token type\""
          ],
          "line": 1814
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pushJsonbValue",
          "args": [
            "&result->parseState",
            "single_scalar ? WJB_VALUE : type",
            "&v"
          ],
          "line": 1809
        },
        "resolved": true,
        "details": {
          "function_name": "pushJsonbValueScalar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "545-629",
          "snippet": "static JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);",
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbParseState *pushState(JsonbParseState **pstate);",
            "static void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void uniqueifyJsonbObject(JsonbValue *object);",
            "static JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\nstatic void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\nstatic JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);\n\nstatic JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetNumeric",
          "args": [
            "DirectFunctionCall1(numeric_uplus,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tNumericGetDatum(v.val.numeric))"
          ],
          "line": 1806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "numeric_uplus",
            "NumericGetDatum(v.val.numeric)"
          ],
          "line": 1806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NumericGetDatum",
          "args": [
            "v.val.numeric"
          ],
          "line": 1807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "v.val.string.len + 1",
            "\"%s\"",
            "v.val.string.val"
          ],
          "line": 1799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "v.val.string.len + 1"
          ],
          "line": 1797
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonbIteratorNext",
          "args": [
            "&it",
            "&v",
            "false"
          ],
          "line": 1770
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbIteratorNext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "753-894",
          "snippet": "JsonbIteratorToken\nJsonbIteratorNext(JsonbIterator **it, JsonbValue *val, bool skipNested)\n{\n\tif (*it == NULL)\n\t\treturn WJB_DONE;\n\n\t/*\n\t * When stepping into a nested container, we jump back here to start\n\t * processing the child. We will not recurse further in one call, because\n\t * processing the child will always begin in JBI_ARRAY_START or\n\t * JBI_OBJECT_START state.\n\t */\nrecurse:\n\tswitch ((*it)->state)\n\t{\n\t\tcase JBI_ARRAY_START:\n\t\t\t/* Set v to array on first array call */\n\t\t\tval->type = jbvArray;\n\t\t\tval->val.array.nElems = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.array.elems is not actually set, because we aren't doing\n\t\t\t * a full conversion\n\t\t\t */\n\t\t\tval->val.array.rawScalar = (*it)->isScalar;\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = 0;\t/* not actually used */\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_ARRAY_ELEM;\n\t\t\treturn WJB_BEGIN_ARRAY;\n\n\t\tcase JBI_ARRAY_ELEM:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All elements within array already processed.  Report this\n\t\t\t\t * to caller, and give it back original parent iterator (which\n\t\t\t\t * independently tracks iteration progress at its level of\n\t\t\t\t * nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_ARRAY;\n\t\t\t}\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t/* Recurse into container. */\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scalar item in array, or a container and caller didn't want\n\t\t\t\t * us to recurse into it.\n\t\t\t\t */\n\t\t\t\treturn WJB_ELEM;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_START:\n\t\t\t/* Set v to object on first object call */\n\t\t\tval->type = jbvObject;\n\t\t\tval->val.object.nPairs = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.object.pairs is not actually set, because we aren't\n\t\t\t * doing a full conversion\n\t\t\t */\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = getJsonbOffset((*it)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t   (*it)->nElems);\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\t\t\treturn WJB_BEGIN_OBJECT;\n\n\t\tcase JBI_OBJECT_KEY:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All pairs within object already processed.  Report this to\n\t\t\t\t * caller, and give it back original containing iterator\n\t\t\t\t * (which independently tracks iteration progress at its level\n\t\t\t\t * of nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_OBJECT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Return key of a key/value pair.  */\n\t\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t\t   val);\n\t\t\t\tif (val->type != jbvString)\n\t\t\t\t\telog(ERROR, \"unexpected jsonb type as object key\");\n\n\t\t\t\t/* Set state for next call */\n\t\t\t\t(*it)->state = JBI_OBJECT_VALUE;\n\t\t\t\treturn WJB_KEY;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_VALUE:\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex + (*it)->nElems,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curValueOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curValueOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex + (*it)->nElems]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\t/*\n\t\t\t * Value may be a container, in which case we recurse with new,\n\t\t\t * child iterator (unless the caller asked not to, by passing\n\t\t\t * skipNested).\n\t\t\t */\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn WJB_VALUE;\n\t}\n\n\telog(ERROR, \"invalid iterator state\");\n\treturn -1;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbIterator *freeAndGetParent(JsonbIterator *it);",
            "static void uniqueifyJsonbObject(JsonbValue *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbIterator *freeAndGetParent(JsonbIterator *it);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\n\nJsonbIteratorToken\nJsonbIteratorNext(JsonbIterator **it, JsonbValue *val, bool skipNested)\n{\n\tif (*it == NULL)\n\t\treturn WJB_DONE;\n\n\t/*\n\t * When stepping into a nested container, we jump back here to start\n\t * processing the child. We will not recurse further in one call, because\n\t * processing the child will always begin in JBI_ARRAY_START or\n\t * JBI_OBJECT_START state.\n\t */\nrecurse:\n\tswitch ((*it)->state)\n\t{\n\t\tcase JBI_ARRAY_START:\n\t\t\t/* Set v to array on first array call */\n\t\t\tval->type = jbvArray;\n\t\t\tval->val.array.nElems = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.array.elems is not actually set, because we aren't doing\n\t\t\t * a full conversion\n\t\t\t */\n\t\t\tval->val.array.rawScalar = (*it)->isScalar;\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = 0;\t/* not actually used */\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_ARRAY_ELEM;\n\t\t\treturn WJB_BEGIN_ARRAY;\n\n\t\tcase JBI_ARRAY_ELEM:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All elements within array already processed.  Report this\n\t\t\t\t * to caller, and give it back original parent iterator (which\n\t\t\t\t * independently tracks iteration progress at its level of\n\t\t\t\t * nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_ARRAY;\n\t\t\t}\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t/* Recurse into container. */\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scalar item in array, or a container and caller didn't want\n\t\t\t\t * us to recurse into it.\n\t\t\t\t */\n\t\t\t\treturn WJB_ELEM;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_START:\n\t\t\t/* Set v to object on first object call */\n\t\t\tval->type = jbvObject;\n\t\t\tval->val.object.nPairs = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.object.pairs is not actually set, because we aren't\n\t\t\t * doing a full conversion\n\t\t\t */\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = getJsonbOffset((*it)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t   (*it)->nElems);\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\t\t\treturn WJB_BEGIN_OBJECT;\n\n\t\tcase JBI_OBJECT_KEY:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All pairs within object already processed.  Report this to\n\t\t\t\t * caller, and give it back original containing iterator\n\t\t\t\t * (which independently tracks iteration progress at its level\n\t\t\t\t * of nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_OBJECT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Return key of a key/value pair.  */\n\t\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t\t   val);\n\t\t\t\tif (val->type != jbvString)\n\t\t\t\t\telog(ERROR, \"unexpected jsonb type as object key\");\n\n\t\t\t\t/* Set state for next call */\n\t\t\t\t(*it)->state = JBI_OBJECT_VALUE;\n\t\t\t\treturn WJB_KEY;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_VALUE:\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex + (*it)->nElems,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curValueOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curValueOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex + (*it)->nElems]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\t/*\n\t\t\t * Value may be a container, in which case we recurse with new,\n\t\t\t * child iterator (unless the caller asked not to, by passing\n\t\t\t * skipNested).\n\t\t\t */\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn WJB_VALUE;\n\t}\n\n\telog(ERROR, \"invalid iterator state\");\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonbIteratorInit",
          "args": [
            "&jbval->root"
          ],
          "line": 1760
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbIteratorInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "717-721",
          "snippet": "JsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nJsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t\t errmsg(\"object keys must be strings\"))"
          ],
          "line": 1745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"object keys must be strings\""
          ],
          "line": 1747
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 1746
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "v.val.string.len + 1",
            "\"%s\"",
            "v.val.string.val"
          ],
          "line": 1740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "aggcontext"
          ],
          "line": 1718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JsonbValueToJsonb",
          "args": [
            "elem.res"
          ],
          "line": 1712
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbValueToJsonb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "78-113",
          "snippet": "Jsonb *\nJsonbValueToJsonb(JsonbValue *val)\n{\n\tJsonb\t   *out;\n\n\tif (IsAJsonbScalar(val))\n\t{\n\t\t/* Scalar value */\n\t\tJsonbParseState *pstate = NULL;\n\t\tJsonbValue *res;\n\t\tJsonbValue\tscalarArray;\n\n\t\tscalarArray.type = jbvArray;\n\t\tscalarArray.val.array.rawScalar = true;\n\t\tscalarArray.val.array.nElems = 1;\n\n\t\tpushJsonbValue(&pstate, WJB_BEGIN_ARRAY, &scalarArray);\n\t\tpushJsonbValue(&pstate, WJB_ELEM, val);\n\t\tres = pushJsonbValue(&pstate, WJB_END_ARRAY, NULL);\n\n\t\tout = convertToJsonb(res);\n\t}\n\telse if (val->type == jbvObject || val->type == jbvArray)\n\t{\n\t\tout = convertToJsonb(val);\n\t}\n\telse\n\t{\n\t\tAssert(val->type == jbvBinary);\n\t\tout = palloc(VARHDRSZ + val->val.binary.len);\n\t\tSET_VARSIZE(out, VARHDRSZ + val->val.binary.len);\n\t\tmemcpy(VARDATA(out), val->val.binary.data, val->val.binary.len);\n\t}\n\n\treturn out;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static int\treserveFromBuffer(StringInfo buffer, int len);",
            "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
            "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
            "static JsonbParseState *pushState(JsonbParseState **pstate);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\n\nJsonb *\nJsonbValueToJsonb(JsonbValue *val)\n{\n\tJsonb\t   *out;\n\n\tif (IsAJsonbScalar(val))\n\t{\n\t\t/* Scalar value */\n\t\tJsonbParseState *pstate = NULL;\n\t\tJsonbValue *res;\n\t\tJsonbValue\tscalarArray;\n\n\t\tscalarArray.type = jbvArray;\n\t\tscalarArray.val.array.rawScalar = true;\n\t\tscalarArray.val.array.nElems = 1;\n\n\t\tpushJsonbValue(&pstate, WJB_BEGIN_ARRAY, &scalarArray);\n\t\tpushJsonbValue(&pstate, WJB_ELEM, val);\n\t\tres = pushJsonbValue(&pstate, WJB_END_ARRAY, NULL);\n\n\t\tout = convertToJsonb(res);\n\t}\n\telse if (val->type == jbvObject || val->type == jbvArray)\n\t{\n\t\tout = convertToJsonb(val);\n\t}\n\telse\n\t{\n\t\tAssert(val->type == jbvBinary);\n\t\tout = palloc(VARHDRSZ + val->val.binary.len);\n\t\tSET_VARSIZE(out, VARHDRSZ + val->val.binary.len);\n\t\tmemcpy(VARDATA(out), val->val.binary.data, val->val.binary.len);\n\t}\n\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "datum_to_jsonb",
          "args": [
            "val",
            "PG_ARGISNULL(2)",
            "&elem",
            "state->val_category",
            "state->val_output_func",
            "false"
          ],
          "line": 1709
        },
        "resolved": true,
        "details": {
          "function_name": "datum_to_jsonb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
          "lines": "701-914",
          "snippet": "static void\ndatum_to_jsonb(Datum val, bool is_null, JsonbInState *result,\n\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid,\n\t\t\t   bool key_scalar)\n{\n\tchar\t   *outputstr;\n\tbool\t\tnumeric_error;\n\tJsonbValue\tjb;\n\tbool\t\tscalar_jsonb = false;\n\n\tcheck_stack_depth();\n\n\t/* Convert val to a JsonbValue in jb (in most cases) */\n\tif (is_null)\n\t{\n\t\tAssert(!key_scalar);\n\t\tjb.type = jbvNull;\n\t}\n\telse if (key_scalar &&\n\t\t\t (tcategory == JSONBTYPE_ARRAY ||\n\t\t\t  tcategory == JSONBTYPE_COMPOSITE ||\n\t\t\t  tcategory == JSONBTYPE_JSON ||\n\t\t\t  tcategory == JSONBTYPE_JSONB ||\n\t\t\t  tcategory == JSONBTYPE_JSONCAST))\n\t{\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"key value must be scalar, not array, composite, or json\")));\n\t}\n\telse\n\t{\n\t\tif (tcategory == JSONBTYPE_JSONCAST)\n\t\t\tval = OidFunctionCall1(outfuncoid, val);\n\n\t\tswitch (tcategory)\n\t\t{\n\t\t\tcase JSONBTYPE_ARRAY:\n\t\t\t\tarray_to_jsonb_internal(val, result);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_COMPOSITE:\n\t\t\t\tcomposite_to_jsonb(val, result);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_BOOL:\n\t\t\t\tif (key_scalar)\n\t\t\t\t{\n\t\t\t\t\toutputstr = DatumGetBool(val) ? \"true\" : \"false\";\n\t\t\t\t\tjb.type = jbvString;\n\t\t\t\t\tjb.val.string.len = strlen(outputstr);\n\t\t\t\t\tjb.val.string.val = outputstr;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tjb.type = jbvBool;\n\t\t\t\t\tjb.val.boolean = DatumGetBool(val);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_NUMERIC:\n\t\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\t\t\t\tif (key_scalar)\n\t\t\t\t{\n\t\t\t\t\t/* always quote keys */\n\t\t\t\t\tjb.type = jbvString;\n\t\t\t\t\tjb.val.string.len = strlen(outputstr);\n\t\t\t\t\tjb.val.string.val = outputstr;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * Make it numeric if it's a valid JSON number, otherwise\n\t\t\t\t\t * a string. Invalid numeric output will always have an\n\t\t\t\t\t * 'N' or 'n' in it (I think).\n\t\t\t\t\t */\n\t\t\t\t\tnumeric_error = (strchr(outputstr, 'N') != NULL ||\n\t\t\t\t\t\t\t\t\t strchr(outputstr, 'n') != NULL);\n\t\t\t\t\tif (!numeric_error)\n\t\t\t\t\t{\n\t\t\t\t\t\tDatum\t\tnumd;\n\n\t\t\t\t\t\tjb.type = jbvNumeric;\n\t\t\t\t\t\tnumd = DirectFunctionCall3(numeric_in,\n\t\t\t\t\t\t\t\t\t\t\t\t   CStringGetDatum(outputstr),\n\t\t\t\t\t\t\t\t\t\t\t\t   ObjectIdGetDatum(InvalidOid),\n\t\t\t\t\t\t\t\t\t\t\t\t   Int32GetDatum(-1));\n\t\t\t\t\t\tjb.val.numeric = DatumGetNumeric(numd);\n\t\t\t\t\t\tpfree(outputstr);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tjb.type = jbvString;\n\t\t\t\t\t\tjb.val.string.len = strlen(outputstr);\n\t\t\t\t\t\tjb.val.string.val = outputstr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_DATE:\n\t\t\t\tjb.type = jbvString;\n\t\t\t\tjb.val.string.val = JsonEncodeDateTime(NULL, val, DATEOID);\n\t\t\t\tjb.val.string.len = strlen(jb.val.string.val);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_TIMESTAMP:\n\t\t\t\tjb.type = jbvString;\n\t\t\t\tjb.val.string.val = JsonEncodeDateTime(NULL, val, TIMESTAMPOID);\n\t\t\t\tjb.val.string.len = strlen(jb.val.string.val);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_TIMESTAMPTZ:\n\t\t\t\tjb.type = jbvString;\n\t\t\t\tjb.val.string.val = JsonEncodeDateTime(NULL, val, TIMESTAMPTZOID);\n\t\t\t\tjb.val.string.len = strlen(jb.val.string.val);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_JSONCAST:\n\t\t\tcase JSONBTYPE_JSON:\n\t\t\t\t{\n\t\t\t\t\t/* parse the json right into the existing result object */\n\t\t\t\t\tJsonLexContext *lex;\n\t\t\t\t\tJsonSemAction sem;\n\t\t\t\t\ttext\t   *json = DatumGetTextPP(val);\n\n\t\t\t\t\tlex = makeJsonLexContext(json, true);\n\n\t\t\t\t\tmemset(&sem, 0, sizeof(sem));\n\n\t\t\t\t\tsem.semstate = (void *) result;\n\n\t\t\t\t\tsem.object_start = jsonb_in_object_start;\n\t\t\t\t\tsem.array_start = jsonb_in_array_start;\n\t\t\t\t\tsem.object_end = jsonb_in_object_end;\n\t\t\t\t\tsem.array_end = jsonb_in_array_end;\n\t\t\t\t\tsem.scalar = jsonb_in_scalar;\n\t\t\t\t\tsem.object_field_start = jsonb_in_object_field_start;\n\n\t\t\t\t\tpg_parse_json(lex, &sem);\n\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_JSONB:\n\t\t\t\t{\n\t\t\t\t\tJsonb\t   *jsonb = DatumGetJsonbP(val);\n\t\t\t\t\tJsonbIterator *it;\n\n\t\t\t\t\tit = JsonbIteratorInit(&jsonb->root);\n\n\t\t\t\t\tif (JB_ROOT_IS_SCALAR(jsonb))\n\t\t\t\t\t{\n\t\t\t\t\t\t(void) JsonbIteratorNext(&it, &jb, true);\n\t\t\t\t\t\tAssert(jb.type == jbvArray);\n\t\t\t\t\t\t(void) JsonbIteratorNext(&it, &jb, true);\n\t\t\t\t\t\tscalar_jsonb = true;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tJsonbIteratorToken type;\n\n\t\t\t\t\t\twhile ((type = JsonbIteratorNext(&it, &jb, false))\n\t\t\t\t\t\t\t   != WJB_DONE)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (type == WJB_END_ARRAY || type == WJB_END_OBJECT ||\n\t\t\t\t\t\t\t\ttype == WJB_BEGIN_ARRAY || type == WJB_BEGIN_OBJECT)\n\t\t\t\t\t\t\t\tresult->res = pushJsonbValue(&result->parseState,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t type, NULL);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tresult->res = pushJsonbValue(&result->parseState,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t type, &jb);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\t\t\t\tjb.type = jbvString;\n\t\t\t\tjb.val.string.len = checkStringLen(strlen(outputstr));\n\t\t\t\tjb.val.string.val = outputstr;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Now insert jb into result, unless we did it recursively */\n\tif (!is_null && !scalar_jsonb &&\n\t\ttcategory >= JSONBTYPE_JSON && tcategory <= JSONBTYPE_JSONCAST)\n\t{\n\t\t/* work has been done recursively */\n\t\treturn;\n\t}\n\telse if (result->parseState == NULL)\n\t{\n\t\t/* single root scalar */\n\t\tJsonbValue\tva;\n\n\t\tva.type = jbvArray;\n\t\tva.val.array.rawScalar = true;\n\t\tva.val.array.nElems = 1;\n\n\t\tresult->res = pushJsonbValue(&result->parseState, WJB_BEGIN_ARRAY, &va);\n\t\tresult->res = pushJsonbValue(&result->parseState, WJB_ELEM, &jb);\n\t\tresult->res = pushJsonbValue(&result->parseState, WJB_END_ARRAY, NULL);\n\t}\n\telse\n\t{\n\t\tJsonbValue *o = &result->parseState->contVal;\n\n\t\tswitch (o->type)\n\t\t{\n\t\t\tcase jbvArray:\n\t\t\t\tresult->res = pushJsonbValue(&result->parseState, WJB_ELEM, &jb);\n\t\t\t\tbreak;\n\t\t\tcase jbvObject:\n\t\t\t\tresult->res = pushJsonbValue(&result->parseState,\n\t\t\t\t\t\t\t\t\t\t\t key_scalar ? WJB_KEY : WJB_VALUE,\n\t\t\t\t\t\t\t\t\t\t\t &jb);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unexpected parent of nested structure\");\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"miscadmin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline Datum jsonb_from_cstring(char *json, int len);",
            "static size_t checkStringLen(size_t len);",
            "static void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);",
            "static void composite_to_jsonb(Datum composite, JsonbInState *result);",
            "static void array_dim_to_jsonb(JsonbInState *result, int dim, int ndims, int *dims,\n\t\t\t\t   Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid);",
            "static void array_to_jsonb_internal(Datum array, JsonbInState *result);",
            "static void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);",
            "static void datum_to_jsonb(Datum val, bool is_null, JsonbInState *result,\n\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid,\n\t\t\t   bool key_scalar);",
            "static void add_jsonb(Datum val, bool is_null, JsonbInState *result,\n\t\t  Oid val_type, bool key_scalar);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic inline Datum jsonb_from_cstring(char *json, int len);\nstatic size_t checkStringLen(size_t len);\nstatic void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);\nstatic void composite_to_jsonb(Datum composite, JsonbInState *result);\nstatic void array_dim_to_jsonb(JsonbInState *result, int dim, int ndims, int *dims,\n\t\t\t\t   Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid);\nstatic void array_to_jsonb_internal(Datum array, JsonbInState *result);\nstatic void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);\nstatic void datum_to_jsonb(Datum val, bool is_null, JsonbInState *result,\n\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid,\n\t\t\t   bool key_scalar);\nstatic void add_jsonb(Datum val, bool is_null, JsonbInState *result,\n\t\t  Oid val_type, bool key_scalar);\n\nstatic void\ndatum_to_jsonb(Datum val, bool is_null, JsonbInState *result,\n\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid,\n\t\t\t   bool key_scalar)\n{\n\tchar\t   *outputstr;\n\tbool\t\tnumeric_error;\n\tJsonbValue\tjb;\n\tbool\t\tscalar_jsonb = false;\n\n\tcheck_stack_depth();\n\n\t/* Convert val to a JsonbValue in jb (in most cases) */\n\tif (is_null)\n\t{\n\t\tAssert(!key_scalar);\n\t\tjb.type = jbvNull;\n\t}\n\telse if (key_scalar &&\n\t\t\t (tcategory == JSONBTYPE_ARRAY ||\n\t\t\t  tcategory == JSONBTYPE_COMPOSITE ||\n\t\t\t  tcategory == JSONBTYPE_JSON ||\n\t\t\t  tcategory == JSONBTYPE_JSONB ||\n\t\t\t  tcategory == JSONBTYPE_JSONCAST))\n\t{\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"key value must be scalar, not array, composite, or json\")));\n\t}\n\telse\n\t{\n\t\tif (tcategory == JSONBTYPE_JSONCAST)\n\t\t\tval = OidFunctionCall1(outfuncoid, val);\n\n\t\tswitch (tcategory)\n\t\t{\n\t\t\tcase JSONBTYPE_ARRAY:\n\t\t\t\tarray_to_jsonb_internal(val, result);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_COMPOSITE:\n\t\t\t\tcomposite_to_jsonb(val, result);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_BOOL:\n\t\t\t\tif (key_scalar)\n\t\t\t\t{\n\t\t\t\t\toutputstr = DatumGetBool(val) ? \"true\" : \"false\";\n\t\t\t\t\tjb.type = jbvString;\n\t\t\t\t\tjb.val.string.len = strlen(outputstr);\n\t\t\t\t\tjb.val.string.val = outputstr;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tjb.type = jbvBool;\n\t\t\t\t\tjb.val.boolean = DatumGetBool(val);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_NUMERIC:\n\t\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\t\t\t\tif (key_scalar)\n\t\t\t\t{\n\t\t\t\t\t/* always quote keys */\n\t\t\t\t\tjb.type = jbvString;\n\t\t\t\t\tjb.val.string.len = strlen(outputstr);\n\t\t\t\t\tjb.val.string.val = outputstr;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * Make it numeric if it's a valid JSON number, otherwise\n\t\t\t\t\t * a string. Invalid numeric output will always have an\n\t\t\t\t\t * 'N' or 'n' in it (I think).\n\t\t\t\t\t */\n\t\t\t\t\tnumeric_error = (strchr(outputstr, 'N') != NULL ||\n\t\t\t\t\t\t\t\t\t strchr(outputstr, 'n') != NULL);\n\t\t\t\t\tif (!numeric_error)\n\t\t\t\t\t{\n\t\t\t\t\t\tDatum\t\tnumd;\n\n\t\t\t\t\t\tjb.type = jbvNumeric;\n\t\t\t\t\t\tnumd = DirectFunctionCall3(numeric_in,\n\t\t\t\t\t\t\t\t\t\t\t\t   CStringGetDatum(outputstr),\n\t\t\t\t\t\t\t\t\t\t\t\t   ObjectIdGetDatum(InvalidOid),\n\t\t\t\t\t\t\t\t\t\t\t\t   Int32GetDatum(-1));\n\t\t\t\t\t\tjb.val.numeric = DatumGetNumeric(numd);\n\t\t\t\t\t\tpfree(outputstr);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tjb.type = jbvString;\n\t\t\t\t\t\tjb.val.string.len = strlen(outputstr);\n\t\t\t\t\t\tjb.val.string.val = outputstr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_DATE:\n\t\t\t\tjb.type = jbvString;\n\t\t\t\tjb.val.string.val = JsonEncodeDateTime(NULL, val, DATEOID);\n\t\t\t\tjb.val.string.len = strlen(jb.val.string.val);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_TIMESTAMP:\n\t\t\t\tjb.type = jbvString;\n\t\t\t\tjb.val.string.val = JsonEncodeDateTime(NULL, val, TIMESTAMPOID);\n\t\t\t\tjb.val.string.len = strlen(jb.val.string.val);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_TIMESTAMPTZ:\n\t\t\t\tjb.type = jbvString;\n\t\t\t\tjb.val.string.val = JsonEncodeDateTime(NULL, val, TIMESTAMPTZOID);\n\t\t\t\tjb.val.string.len = strlen(jb.val.string.val);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_JSONCAST:\n\t\t\tcase JSONBTYPE_JSON:\n\t\t\t\t{\n\t\t\t\t\t/* parse the json right into the existing result object */\n\t\t\t\t\tJsonLexContext *lex;\n\t\t\t\t\tJsonSemAction sem;\n\t\t\t\t\ttext\t   *json = DatumGetTextPP(val);\n\n\t\t\t\t\tlex = makeJsonLexContext(json, true);\n\n\t\t\t\t\tmemset(&sem, 0, sizeof(sem));\n\n\t\t\t\t\tsem.semstate = (void *) result;\n\n\t\t\t\t\tsem.object_start = jsonb_in_object_start;\n\t\t\t\t\tsem.array_start = jsonb_in_array_start;\n\t\t\t\t\tsem.object_end = jsonb_in_object_end;\n\t\t\t\t\tsem.array_end = jsonb_in_array_end;\n\t\t\t\t\tsem.scalar = jsonb_in_scalar;\n\t\t\t\t\tsem.object_field_start = jsonb_in_object_field_start;\n\n\t\t\t\t\tpg_parse_json(lex, &sem);\n\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_JSONB:\n\t\t\t\t{\n\t\t\t\t\tJsonb\t   *jsonb = DatumGetJsonbP(val);\n\t\t\t\t\tJsonbIterator *it;\n\n\t\t\t\t\tit = JsonbIteratorInit(&jsonb->root);\n\n\t\t\t\t\tif (JB_ROOT_IS_SCALAR(jsonb))\n\t\t\t\t\t{\n\t\t\t\t\t\t(void) JsonbIteratorNext(&it, &jb, true);\n\t\t\t\t\t\tAssert(jb.type == jbvArray);\n\t\t\t\t\t\t(void) JsonbIteratorNext(&it, &jb, true);\n\t\t\t\t\t\tscalar_jsonb = true;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tJsonbIteratorToken type;\n\n\t\t\t\t\t\twhile ((type = JsonbIteratorNext(&it, &jb, false))\n\t\t\t\t\t\t\t   != WJB_DONE)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (type == WJB_END_ARRAY || type == WJB_END_OBJECT ||\n\t\t\t\t\t\t\t\ttype == WJB_BEGIN_ARRAY || type == WJB_BEGIN_OBJECT)\n\t\t\t\t\t\t\t\tresult->res = pushJsonbValue(&result->parseState,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t type, NULL);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tresult->res = pushJsonbValue(&result->parseState,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t type, &jb);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\t\t\t\tjb.type = jbvString;\n\t\t\t\tjb.val.string.len = checkStringLen(strlen(outputstr));\n\t\t\t\tjb.val.string.val = outputstr;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Now insert jb into result, unless we did it recursively */\n\tif (!is_null && !scalar_jsonb &&\n\t\ttcategory >= JSONBTYPE_JSON && tcategory <= JSONBTYPE_JSONCAST)\n\t{\n\t\t/* work has been done recursively */\n\t\treturn;\n\t}\n\telse if (result->parseState == NULL)\n\t{\n\t\t/* single root scalar */\n\t\tJsonbValue\tva;\n\n\t\tva.type = jbvArray;\n\t\tva.val.array.rawScalar = true;\n\t\tva.val.array.nElems = 1;\n\n\t\tresult->res = pushJsonbValue(&result->parseState, WJB_BEGIN_ARRAY, &va);\n\t\tresult->res = pushJsonbValue(&result->parseState, WJB_ELEM, &jb);\n\t\tresult->res = pushJsonbValue(&result->parseState, WJB_END_ARRAY, NULL);\n\t}\n\telse\n\t{\n\t\tJsonbValue *o = &result->parseState->contVal;\n\n\t\tswitch (o->type)\n\t\t{\n\t\t\tcase jbvArray:\n\t\t\t\tresult->res = pushJsonbValue(&result->parseState, WJB_ELEM, &jb);\n\t\t\t\tbreak;\n\t\t\tcase jbvObject:\n\t\t\t\tresult->res = pushJsonbValue(&result->parseState,\n\t\t\t\t\t\t\t\t\t\t\t key_scalar ? WJB_KEY : WJB_VALUE,\n\t\t\t\t\t\t\t\t\t\t\t &jb);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unexpected parent of nested structure\");\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "2"
          ],
          "line": 1709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&elem",
            "0",
            "sizeof(JsonbInState)"
          ],
          "line": 1707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "2"
          ],
          "line": 1705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "2"
          ],
          "line": 1705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&elem",
            "0",
            "sizeof(JsonbInState)"
          ],
          "line": 1698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "1"
          ],
          "line": 1696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"field name must not be null\"))"
          ],
          "line": 1692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "1"
          ],
          "line": 1691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 1685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jsonb_categorize_type",
          "args": [
            "arg_type",
            "&state->val_category",
            "&state->val_output_func"
          ],
          "line": 1680
        },
        "resolved": true,
        "details": {
          "function_name": "jsonb_categorize_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
          "lines": "593-690",
          "snippet": "static void\njsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid)\n{\n\tbool\t\ttypisvarlena;\n\n\t/* Look through any domain */\n\ttypoid = getBaseType(typoid);\n\n\t*outfuncoid = InvalidOid;\n\n\t/*\n\t * We need to get the output function for everything except date and\n\t * timestamp types, booleans, array and composite types, json and jsonb,\n\t * and non-builtin types where there's a cast to json. In this last case\n\t * we return the oid of the cast function instead.\n\t */\n\n\tswitch (typoid)\n\t{\n\t\tcase BOOLOID:\n\t\t\t*tcategory = JSONBTYPE_BOOL;\n\t\t\tbreak;\n\n\t\tcase INT2OID:\n\t\tcase INT4OID:\n\t\tcase INT8OID:\n\t\tcase FLOAT4OID:\n\t\tcase FLOAT8OID:\n\t\tcase NUMERICOID:\n\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t*tcategory = JSONBTYPE_NUMERIC;\n\t\t\tbreak;\n\n\t\tcase DATEOID:\n\t\t\t*tcategory = JSONBTYPE_DATE;\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPOID:\n\t\t\t*tcategory = JSONBTYPE_TIMESTAMP;\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPTZOID:\n\t\t\t*tcategory = JSONBTYPE_TIMESTAMPTZ;\n\t\t\tbreak;\n\n\t\tcase JSONBOID:\n\t\t\t*tcategory = JSONBTYPE_JSONB;\n\t\t\tbreak;\n\n\t\tcase JSONOID:\n\t\t\t*tcategory = JSONBTYPE_JSON;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* Check for arrays and composites */\n\t\t\tif (OidIsValid(get_element_type(typoid)) || typoid == ANYARRAYOID\n\t\t\t\t|| typoid == RECORDARRAYOID)\n\t\t\t\t*tcategory = JSONBTYPE_ARRAY;\n\t\t\telse if (type_is_rowtype(typoid))\t/* includes RECORDOID */\n\t\t\t\t*tcategory = JSONBTYPE_COMPOSITE;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* It's probably the general case ... */\n\t\t\t\t*tcategory = JSONBTYPE_OTHER;\n\n\t\t\t\t/*\n\t\t\t\t * but first let's look for a cast to json (note: not to\n\t\t\t\t * jsonb) if it's not built-in.\n\t\t\t\t */\n\t\t\t\tif (typoid >= FirstNormalObjectId)\n\t\t\t\t{\n\t\t\t\t\tOid\t\t\tcastfunc;\n\t\t\t\t\tCoercionPathType ctype;\n\n\t\t\t\t\tctype = find_coercion_pathway(JSONOID, typoid,\n\t\t\t\t\t\t\t\t\t\t\t\t  COERCION_EXPLICIT, &castfunc);\n\t\t\t\t\tif (ctype == COERCION_PATH_FUNC && OidIsValid(castfunc))\n\t\t\t\t\t{\n\t\t\t\t\t\t*tcategory = JSONBTYPE_JSONCAST;\n\t\t\t\t\t\t*outfuncoid = castfunc;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* not a cast type, so just get the usual output func */\n\t\t\t\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* any other builtin type */\n\t\t\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"miscadmin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);",
            "static void array_dim_to_jsonb(JsonbInState *result, int dim, int ndims, int *dims,\n\t\t\t\t   Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid);",
            "static void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);\nstatic void array_dim_to_jsonb(JsonbInState *result, int dim, int ndims, int *dims,\n\t\t\t\t   Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid);\nstatic void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);\n\nstatic void\njsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid)\n{\n\tbool\t\ttypisvarlena;\n\n\t/* Look through any domain */\n\ttypoid = getBaseType(typoid);\n\n\t*outfuncoid = InvalidOid;\n\n\t/*\n\t * We need to get the output function for everything except date and\n\t * timestamp types, booleans, array and composite types, json and jsonb,\n\t * and non-builtin types where there's a cast to json. In this last case\n\t * we return the oid of the cast function instead.\n\t */\n\n\tswitch (typoid)\n\t{\n\t\tcase BOOLOID:\n\t\t\t*tcategory = JSONBTYPE_BOOL;\n\t\t\tbreak;\n\n\t\tcase INT2OID:\n\t\tcase INT4OID:\n\t\tcase INT8OID:\n\t\tcase FLOAT4OID:\n\t\tcase FLOAT8OID:\n\t\tcase NUMERICOID:\n\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t*tcategory = JSONBTYPE_NUMERIC;\n\t\t\tbreak;\n\n\t\tcase DATEOID:\n\t\t\t*tcategory = JSONBTYPE_DATE;\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPOID:\n\t\t\t*tcategory = JSONBTYPE_TIMESTAMP;\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPTZOID:\n\t\t\t*tcategory = JSONBTYPE_TIMESTAMPTZ;\n\t\t\tbreak;\n\n\t\tcase JSONBOID:\n\t\t\t*tcategory = JSONBTYPE_JSONB;\n\t\t\tbreak;\n\n\t\tcase JSONOID:\n\t\t\t*tcategory = JSONBTYPE_JSON;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* Check for arrays and composites */\n\t\t\tif (OidIsValid(get_element_type(typoid)) || typoid == ANYARRAYOID\n\t\t\t\t|| typoid == RECORDARRAYOID)\n\t\t\t\t*tcategory = JSONBTYPE_ARRAY;\n\t\t\telse if (type_is_rowtype(typoid))\t/* includes RECORDOID */\n\t\t\t\t*tcategory = JSONBTYPE_COMPOSITE;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* It's probably the general case ... */\n\t\t\t\t*tcategory = JSONBTYPE_OTHER;\n\n\t\t\t\t/*\n\t\t\t\t * but first let's look for a cast to json (note: not to\n\t\t\t\t * jsonb) if it's not built-in.\n\t\t\t\t */\n\t\t\t\tif (typoid >= FirstNormalObjectId)\n\t\t\t\t{\n\t\t\t\t\tOid\t\t\tcastfunc;\n\t\t\t\t\tCoercionPathType ctype;\n\n\t\t\t\t\tctype = find_coercion_pathway(JSONOID, typoid,\n\t\t\t\t\t\t\t\t\t\t\t\t  COERCION_EXPLICIT, &castfunc);\n\t\t\t\t\tif (ctype == COERCION_PATH_FUNC && OidIsValid(castfunc))\n\t\t\t\t\t{\n\t\t\t\t\t\t*tcategory = JSONBTYPE_JSONCAST;\n\t\t\t\t\t\t*outfuncoid = castfunc;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* not a cast type, so just get the usual output func */\n\t\t\t\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* any other builtin type */\n\t\t\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"could not determine input data type\"))"
          ],
          "line": 1676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fn_expr_argtype",
          "args": [
            "fcinfo->flinfo",
            "2"
          ],
          "line": 1673
        },
        "resolved": true,
        "details": {
          "function_name": "get_fn_expr_argtype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1994-2005",
          "snippet": "Oid\nget_fn_expr_argtype(FmgrInfo *flinfo, int argnum)\n{\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn InvalidOid;\n\n\treturn get_call_expr_argtype(flinfo->fn_expr, argnum);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nOid\nget_fn_expr_argtype(FmgrInfo *flinfo, int argnum)\n{\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn InvalidOid;\n\n\treturn get_call_expr_argtype(flinfo->fn_expr, argnum);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"could not determine input data type\"))"
          ],
          "line": 1666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 1661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "sizeof(JsonbInState)"
          ],
          "line": 1657
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "aggcontext"
          ],
          "line": 1655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "0"
          ],
          "line": 1651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AggCheckCallContext",
          "args": [
            "fcinfo",
            "&aggcontext"
          ],
          "line": 1643
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic inline Datum jsonb_from_cstring(char *json, int len);\nstatic size_t checkStringLen(size_t len);\nstatic void composite_to_jsonb(Datum composite, JsonbInState *result);\nstatic void array_to_jsonb_internal(Datum array, JsonbInState *result);\nstatic JsonbParseState *clone_parse_state(JsonbParseState *state);\n\nDatum\njsonb_object_agg_transfn(PG_FUNCTION_ARGS)\n{\n\tMemoryContext oldcontext,\n\t\t\t\taggcontext;\n\tJsonbInState elem;\n\tJsonbAggState *state;\n\tDatum\t\tval;\n\tJsonbInState *result;\n\tbool\t\tsingle_scalar;\n\tJsonbIterator *it;\n\tJsonb\t   *jbkey,\n\t\t\t   *jbval;\n\tJsonbValue\tv;\n\tJsonbIteratorToken type;\n\n\tif (!AggCheckCallContext(fcinfo, &aggcontext))\n\t{\n\t\t/* cannot be called directly because of internal-type argument */\n\t\telog(ERROR, \"jsonb_object_agg_transfn called in non-aggregate context\");\n\t}\n\n\t/* set up the accumulator on the first go round */\n\n\tif (PG_ARGISNULL(0))\n\t{\n\t\tOid\t\t\targ_type;\n\n\t\toldcontext = MemoryContextSwitchTo(aggcontext);\n\t\tstate = palloc(sizeof(JsonbAggState));\n\t\tresult = palloc0(sizeof(JsonbInState));\n\t\tstate->res = result;\n\t\tresult->res = pushJsonbValue(&result->parseState,\n\t\t\t\t\t\t\t\t\t WJB_BEGIN_OBJECT, NULL);\n\t\tMemoryContextSwitchTo(oldcontext);\n\n\t\targ_type = get_fn_expr_argtype(fcinfo->flinfo, 1);\n\n\t\tif (arg_type == InvalidOid)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"could not determine input data type\")));\n\n\t\tjsonb_categorize_type(arg_type, &state->key_category,\n\t\t\t\t\t\t\t  &state->key_output_func);\n\n\t\targ_type = get_fn_expr_argtype(fcinfo->flinfo, 2);\n\n\t\tif (arg_type == InvalidOid)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"could not determine input data type\")));\n\n\t\tjsonb_categorize_type(arg_type, &state->val_category,\n\t\t\t\t\t\t\t  &state->val_output_func);\n\t}\n\telse\n\t{\n\t\tstate = (JsonbAggState *) PG_GETARG_POINTER(0);\n\t\tresult = state->res;\n\t}\n\n\t/* turn the argument into jsonb in the normal function context */\n\n\tif (PG_ARGISNULL(1))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"field name must not be null\")));\n\n\tval = PG_GETARG_DATUM(1);\n\n\tmemset(&elem, 0, sizeof(JsonbInState));\n\n\tdatum_to_jsonb(val, false, &elem, state->key_category,\n\t\t\t\t   state->key_output_func, true);\n\n\tjbkey = JsonbValueToJsonb(elem.res);\n\n\tval = PG_ARGISNULL(2) ? (Datum) 0 : PG_GETARG_DATUM(2);\n\n\tmemset(&elem, 0, sizeof(JsonbInState));\n\n\tdatum_to_jsonb(val, PG_ARGISNULL(2), &elem, state->val_category,\n\t\t\t\t   state->val_output_func, false);\n\n\tjbval = JsonbValueToJsonb(elem.res);\n\n\tit = JsonbIteratorInit(&jbkey->root);\n\n\t/* switch to the aggregate context for accumulation operations */\n\n\toldcontext = MemoryContextSwitchTo(aggcontext);\n\n\t/*\n\t * keys should be scalar, and we should have already checked for that\n\t * above when calling datum_to_jsonb, so we only need to look for these\n\t * things.\n\t */\n\n\twhile ((type = JsonbIteratorNext(&it, &v, false)) != WJB_DONE)\n\t{\n\t\tswitch (type)\n\t\t{\n\t\t\tcase WJB_BEGIN_ARRAY:\n\t\t\t\tif (!v.val.array.rawScalar)\n\t\t\t\t\telog(ERROR, \"unexpected structure for key\");\n\t\t\t\tbreak;\n\t\t\tcase WJB_ELEM:\n\t\t\t\tif (v.type == jbvString)\n\t\t\t\t{\n\t\t\t\t\t/* copy string values in the aggregate context */\n\t\t\t\t\tchar\t   *buf = palloc(v.val.string.len + 1);\n\n\t\t\t\t\tsnprintf(buf, v.val.string.len + 1, \"%s\", v.val.string.val);\n\t\t\t\t\tv.val.string.val = buf;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t\t errmsg(\"object keys must be strings\")));\n\t\t\t\t}\n\t\t\t\tresult->res = pushJsonbValue(&result->parseState,\n\t\t\t\t\t\t\t\t\t\t\t WJB_KEY, &v);\n\t\t\t\tbreak;\n\t\t\tcase WJB_END_ARRAY:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unexpected structure for key\");\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tit = JsonbIteratorInit(&jbval->root);\n\n\tsingle_scalar = false;\n\n\t/*\n\t * values can be anything, including structured and null, so we treat them\n\t * as in json_agg_transfn, except that single scalars are always pushed as\n\t * WJB_VALUE items.\n\t */\n\n\twhile ((type = JsonbIteratorNext(&it, &v, false)) != WJB_DONE)\n\t{\n\t\tswitch (type)\n\t\t{\n\t\t\tcase WJB_BEGIN_ARRAY:\n\t\t\t\tif (v.val.array.rawScalar)\n\t\t\t\t\tsingle_scalar = true;\n\t\t\t\telse\n\t\t\t\t\tresult->res = pushJsonbValue(&result->parseState,\n\t\t\t\t\t\t\t\t\t\t\t\t type, NULL);\n\t\t\t\tbreak;\n\t\t\tcase WJB_END_ARRAY:\n\t\t\t\tif (!single_scalar)\n\t\t\t\t\tresult->res = pushJsonbValue(&result->parseState,\n\t\t\t\t\t\t\t\t\t\t\t\t type, NULL);\n\t\t\t\tbreak;\n\t\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tcase WJB_END_OBJECT:\n\t\t\t\tresult->res = pushJsonbValue(&result->parseState,\n\t\t\t\t\t\t\t\t\t\t\t type, NULL);\n\t\t\t\tbreak;\n\t\t\tcase WJB_ELEM:\n\t\t\tcase WJB_KEY:\n\t\t\tcase WJB_VALUE:\n\t\t\t\tif (v.type == jbvString)\n\t\t\t\t{\n\t\t\t\t\t/* copy string values in the aggregate context */\n\t\t\t\t\tchar\t   *buf = palloc(v.val.string.len + 1);\n\n\t\t\t\t\tsnprintf(buf, v.val.string.len + 1, \"%s\", v.val.string.val);\n\t\t\t\t\tv.val.string.val = buf;\n\t\t\t\t}\n\t\t\t\telse if (v.type == jbvNumeric)\n\t\t\t\t{\n\t\t\t\t\t/* same for numeric */\n\t\t\t\t\tv.val.numeric =\n\t\t\t\t\t\tDatumGetNumeric(DirectFunctionCall1(numeric_uplus,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tNumericGetDatum(v.val.numeric)));\n\t\t\t\t}\n\t\t\t\tresult->res = pushJsonbValue(&result->parseState,\n\t\t\t\t\t\t\t\t\t\t\t single_scalar ? WJB_VALUE : type,\n\t\t\t\t\t\t\t\t\t\t\t &v);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unknown jsonb iterator token type\");\n\t\t}\n\t}\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\tPG_RETURN_POINTER(state);\n}"
  },
  {
    "function_name": "jsonb_agg_finalfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
    "lines": "1592-1622",
    "snippet": "Datum\njsonb_agg_finalfn(PG_FUNCTION_ARGS)\n{\n\tJsonbAggState *arg;\n\tJsonbInState result;\n\tJsonb\t   *out;\n\n\t/* cannot be called directly because of internal-type argument */\n\tAssert(AggCheckCallContext(fcinfo, NULL));\n\n\tif (PG_ARGISNULL(0))\n\t\tPG_RETURN_NULL();\t\t/* returns null iff no input values */\n\n\targ = (JsonbAggState *) PG_GETARG_POINTER(0);\n\n\t/*\n\t * We need to do a shallow clone of the argument in case the final\n\t * function is called more than once, so we avoid changing the argument. A\n\t * shallow clone is sufficient as we aren't going to change any of the\n\t * values, just add the final array end marker.\n\t */\n\n\tresult.parseState = clone_parse_state(arg->res->parseState);\n\n\tresult.res = pushJsonbValue(&result.parseState,\n\t\t\t\t\t\t\t\tWJB_END_ARRAY, NULL);\n\n\tout = JsonbValueToJsonb(result.res);\n\n\tPG_RETURN_POINTER(out);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"miscadmin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void composite_to_jsonb(Datum composite, JsonbInState *result);",
      "static void array_to_jsonb_internal(Datum array, JsonbInState *result);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "out"
          ],
          "line": 1621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JsonbValueToJsonb",
          "args": [
            "result.res"
          ],
          "line": 1619
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbValueToJsonb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "78-113",
          "snippet": "Jsonb *\nJsonbValueToJsonb(JsonbValue *val)\n{\n\tJsonb\t   *out;\n\n\tif (IsAJsonbScalar(val))\n\t{\n\t\t/* Scalar value */\n\t\tJsonbParseState *pstate = NULL;\n\t\tJsonbValue *res;\n\t\tJsonbValue\tscalarArray;\n\n\t\tscalarArray.type = jbvArray;\n\t\tscalarArray.val.array.rawScalar = true;\n\t\tscalarArray.val.array.nElems = 1;\n\n\t\tpushJsonbValue(&pstate, WJB_BEGIN_ARRAY, &scalarArray);\n\t\tpushJsonbValue(&pstate, WJB_ELEM, val);\n\t\tres = pushJsonbValue(&pstate, WJB_END_ARRAY, NULL);\n\n\t\tout = convertToJsonb(res);\n\t}\n\telse if (val->type == jbvObject || val->type == jbvArray)\n\t{\n\t\tout = convertToJsonb(val);\n\t}\n\telse\n\t{\n\t\tAssert(val->type == jbvBinary);\n\t\tout = palloc(VARHDRSZ + val->val.binary.len);\n\t\tSET_VARSIZE(out, VARHDRSZ + val->val.binary.len);\n\t\tmemcpy(VARDATA(out), val->val.binary.data, val->val.binary.len);\n\t}\n\n\treturn out;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static int\treserveFromBuffer(StringInfo buffer, int len);",
            "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
            "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
            "static JsonbParseState *pushState(JsonbParseState **pstate);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\n\nJsonb *\nJsonbValueToJsonb(JsonbValue *val)\n{\n\tJsonb\t   *out;\n\n\tif (IsAJsonbScalar(val))\n\t{\n\t\t/* Scalar value */\n\t\tJsonbParseState *pstate = NULL;\n\t\tJsonbValue *res;\n\t\tJsonbValue\tscalarArray;\n\n\t\tscalarArray.type = jbvArray;\n\t\tscalarArray.val.array.rawScalar = true;\n\t\tscalarArray.val.array.nElems = 1;\n\n\t\tpushJsonbValue(&pstate, WJB_BEGIN_ARRAY, &scalarArray);\n\t\tpushJsonbValue(&pstate, WJB_ELEM, val);\n\t\tres = pushJsonbValue(&pstate, WJB_END_ARRAY, NULL);\n\n\t\tout = convertToJsonb(res);\n\t}\n\telse if (val->type == jbvObject || val->type == jbvArray)\n\t{\n\t\tout = convertToJsonb(val);\n\t}\n\telse\n\t{\n\t\tAssert(val->type == jbvBinary);\n\t\tout = palloc(VARHDRSZ + val->val.binary.len);\n\t\tSET_VARSIZE(out, VARHDRSZ + val->val.binary.len);\n\t\tmemcpy(VARDATA(out), val->val.binary.data, val->val.binary.len);\n\t}\n\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pushJsonbValue",
          "args": [
            "&result.parseState",
            "WJB_END_ARRAY",
            "NULL"
          ],
          "line": 1616
        },
        "resolved": true,
        "details": {
          "function_name": "pushJsonbValueScalar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "545-629",
          "snippet": "static JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);",
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbParseState *pushState(JsonbParseState **pstate);",
            "static void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void uniqueifyJsonbObject(JsonbValue *object);",
            "static JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\nstatic void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\nstatic JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);\n\nstatic JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clone_parse_state",
          "args": [
            "arg->res->parseState"
          ],
          "line": 1614
        },
        "resolved": true,
        "details": {
          "function_name": "clone_parse_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
          "lines": "1442-1468",
          "snippet": "static JsonbParseState *\nclone_parse_state(JsonbParseState *state)\n{\n\tJsonbParseState *result,\n\t\t\t   *icursor,\n\t\t\t   *ocursor;\n\n\tif (state == NULL)\n\t\treturn NULL;\n\n\tresult = palloc(sizeof(JsonbParseState));\n\ticursor = state;\n\tocursor = result;\n\tfor (;;)\n\t{\n\t\tocursor->contVal = icursor->contVal;\n\t\tocursor->size = icursor->size;\n\t\ticursor = icursor->next;\n\t\tif (icursor == NULL)\n\t\t\tbreak;\n\t\tocursor->next = palloc(sizeof(JsonbParseState));\n\t\tocursor = ocursor->next;\n\t}\n\tocursor->next = NULL;\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"miscadmin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void composite_to_jsonb(Datum composite, JsonbInState *result);",
            "static void array_to_jsonb_internal(Datum array, JsonbInState *result);",
            "static JsonbParseState *clone_parse_state(JsonbParseState *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic void composite_to_jsonb(Datum composite, JsonbInState *result);\nstatic void array_to_jsonb_internal(Datum array, JsonbInState *result);\nstatic JsonbParseState *clone_parse_state(JsonbParseState *state);\n\nstatic JsonbParseState *\nclone_parse_state(JsonbParseState *state)\n{\n\tJsonbParseState *result,\n\t\t\t   *icursor,\n\t\t\t   *ocursor;\n\n\tif (state == NULL)\n\t\treturn NULL;\n\n\tresult = palloc(sizeof(JsonbParseState));\n\ticursor = state;\n\tocursor = result;\n\tfor (;;)\n\t{\n\t\tocursor->contVal = icursor->contVal;\n\t\tocursor->size = icursor->size;\n\t\ticursor = icursor->next;\n\t\tif (icursor == NULL)\n\t\t\tbreak;\n\t\tocursor->next = palloc(sizeof(JsonbParseState));\n\t\tocursor = ocursor->next;\n\t}\n\tocursor->next = NULL;\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 1605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 1603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "0"
          ],
          "line": 1602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "AggCheckCallContext(fcinfo, NULL)"
          ],
          "line": 1600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AggCheckCallContext",
          "args": [
            "fcinfo",
            "NULL"
          ],
          "line": 1600
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic void composite_to_jsonb(Datum composite, JsonbInState *result);\nstatic void array_to_jsonb_internal(Datum array, JsonbInState *result);\n\nDatum\njsonb_agg_finalfn(PG_FUNCTION_ARGS)\n{\n\tJsonbAggState *arg;\n\tJsonbInState result;\n\tJsonb\t   *out;\n\n\t/* cannot be called directly because of internal-type argument */\n\tAssert(AggCheckCallContext(fcinfo, NULL));\n\n\tif (PG_ARGISNULL(0))\n\t\tPG_RETURN_NULL();\t\t/* returns null iff no input values */\n\n\targ = (JsonbAggState *) PG_GETARG_POINTER(0);\n\n\t/*\n\t * We need to do a shallow clone of the argument in case the final\n\t * function is called more than once, so we avoid changing the argument. A\n\t * shallow clone is sufficient as we aren't going to change any of the\n\t * values, just add the final array end marker.\n\t */\n\n\tresult.parseState = clone_parse_state(arg->res->parseState);\n\n\tresult.res = pushJsonbValue(&result.parseState,\n\t\t\t\t\t\t\t\tWJB_END_ARRAY, NULL);\n\n\tout = JsonbValueToJsonb(result.res);\n\n\tPG_RETURN_POINTER(out);\n}"
  },
  {
    "function_name": "jsonb_agg_transfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
    "lines": "1474-1590",
    "snippet": "Datum\njsonb_agg_transfn(PG_FUNCTION_ARGS)\n{\n\tMemoryContext oldcontext,\n\t\t\t\taggcontext;\n\tJsonbAggState *state;\n\tJsonbInState elem;\n\tDatum\t\tval;\n\tJsonbInState *result;\n\tbool\t\tsingle_scalar = false;\n\tJsonbIterator *it;\n\tJsonb\t   *jbelem;\n\tJsonbValue\tv;\n\tJsonbIteratorToken type;\n\n\tif (!AggCheckCallContext(fcinfo, &aggcontext))\n\t{\n\t\t/* cannot be called directly because of internal-type argument */\n\t\telog(ERROR, \"jsonb_agg_transfn called in non-aggregate context\");\n\t}\n\n\t/* set up the accumulator on the first go round */\n\n\tif (PG_ARGISNULL(0))\n\t{\n\t\tOid\t\t\targ_type = get_fn_expr_argtype(fcinfo->flinfo, 1);\n\n\t\tif (arg_type == InvalidOid)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"could not determine input data type\")));\n\n\t\toldcontext = MemoryContextSwitchTo(aggcontext);\n\t\tstate = palloc(sizeof(JsonbAggState));\n\t\tresult = palloc0(sizeof(JsonbInState));\n\t\tstate->res = result;\n\t\tresult->res = pushJsonbValue(&result->parseState,\n\t\t\t\t\t\t\t\t\t WJB_BEGIN_ARRAY, NULL);\n\t\tMemoryContextSwitchTo(oldcontext);\n\n\t\tjsonb_categorize_type(arg_type, &state->val_category,\n\t\t\t\t\t\t\t  &state->val_output_func);\n\t}\n\telse\n\t{\n\t\tstate = (JsonbAggState *) PG_GETARG_POINTER(0);\n\t\tresult = state->res;\n\t}\n\n\t/* turn the argument into jsonb in the normal function context */\n\n\tval = PG_ARGISNULL(1) ? (Datum) 0 : PG_GETARG_DATUM(1);\n\n\tmemset(&elem, 0, sizeof(JsonbInState));\n\n\tdatum_to_jsonb(val, PG_ARGISNULL(1), &elem, state->val_category,\n\t\t\t\t   state->val_output_func, false);\n\n\tjbelem = JsonbValueToJsonb(elem.res);\n\n\t/* switch to the aggregate context for accumulation operations */\n\n\toldcontext = MemoryContextSwitchTo(aggcontext);\n\n\tit = JsonbIteratorInit(&jbelem->root);\n\n\twhile ((type = JsonbIteratorNext(&it, &v, false)) != WJB_DONE)\n\t{\n\t\tswitch (type)\n\t\t{\n\t\t\tcase WJB_BEGIN_ARRAY:\n\t\t\t\tif (v.val.array.rawScalar)\n\t\t\t\t\tsingle_scalar = true;\n\t\t\t\telse\n\t\t\t\t\tresult->res = pushJsonbValue(&result->parseState,\n\t\t\t\t\t\t\t\t\t\t\t\t type, NULL);\n\t\t\t\tbreak;\n\t\t\tcase WJB_END_ARRAY:\n\t\t\t\tif (!single_scalar)\n\t\t\t\t\tresult->res = pushJsonbValue(&result->parseState,\n\t\t\t\t\t\t\t\t\t\t\t\t type, NULL);\n\t\t\t\tbreak;\n\t\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tcase WJB_END_OBJECT:\n\t\t\t\tresult->res = pushJsonbValue(&result->parseState,\n\t\t\t\t\t\t\t\t\t\t\t type, NULL);\n\t\t\t\tbreak;\n\t\t\tcase WJB_ELEM:\n\t\t\tcase WJB_KEY:\n\t\t\tcase WJB_VALUE:\n\t\t\t\tif (v.type == jbvString)\n\t\t\t\t{\n\t\t\t\t\t/* copy string values in the aggregate context */\n\t\t\t\t\tchar\t   *buf = palloc(v.val.string.len + 1);\n\n\t\t\t\t\tsnprintf(buf, v.val.string.len + 1, \"%s\", v.val.string.val);\n\t\t\t\t\tv.val.string.val = buf;\n\t\t\t\t}\n\t\t\t\telse if (v.type == jbvNumeric)\n\t\t\t\t{\n\t\t\t\t\t/* same for numeric */\n\t\t\t\t\tv.val.numeric =\n\t\t\t\t\t\tDatumGetNumeric(DirectFunctionCall1(numeric_uplus,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tNumericGetDatum(v.val.numeric)));\n\t\t\t\t}\n\t\t\t\tresult->res = pushJsonbValue(&result->parseState,\n\t\t\t\t\t\t\t\t\t\t\t type, &v);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unknown jsonb iterator token type\");\n\t\t}\n\t}\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\tPG_RETURN_POINTER(state);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"miscadmin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static inline Datum jsonb_from_cstring(char *json, int len);",
      "static size_t checkStringLen(size_t len);",
      "static void composite_to_jsonb(Datum composite, JsonbInState *result);",
      "static void array_to_jsonb_internal(Datum array, JsonbInState *result);",
      "static JsonbParseState *clone_parse_state(JsonbParseState *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "state"
          ],
          "line": 1589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 1587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unknown jsonb iterator token type\""
          ],
          "line": 1583
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pushJsonbValue",
          "args": [
            "&result->parseState",
            "type",
            "&v"
          ],
          "line": 1579
        },
        "resolved": true,
        "details": {
          "function_name": "pushJsonbValueScalar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "545-629",
          "snippet": "static JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);",
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbParseState *pushState(JsonbParseState **pstate);",
            "static void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void uniqueifyJsonbObject(JsonbValue *object);",
            "static JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\nstatic void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\nstatic JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);\n\nstatic JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetNumeric",
          "args": [
            "DirectFunctionCall1(numeric_uplus,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tNumericGetDatum(v.val.numeric))"
          ],
          "line": 1576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "numeric_uplus",
            "NumericGetDatum(v.val.numeric)"
          ],
          "line": 1576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NumericGetDatum",
          "args": [
            "v.val.numeric"
          ],
          "line": 1577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "v.val.string.len + 1",
            "\"%s\"",
            "v.val.string.val"
          ],
          "line": 1569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "v.val.string.len + 1"
          ],
          "line": 1567
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonbIteratorNext",
          "args": [
            "&it",
            "&v",
            "false"
          ],
          "line": 1540
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbIteratorNext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "753-894",
          "snippet": "JsonbIteratorToken\nJsonbIteratorNext(JsonbIterator **it, JsonbValue *val, bool skipNested)\n{\n\tif (*it == NULL)\n\t\treturn WJB_DONE;\n\n\t/*\n\t * When stepping into a nested container, we jump back here to start\n\t * processing the child. We will not recurse further in one call, because\n\t * processing the child will always begin in JBI_ARRAY_START or\n\t * JBI_OBJECT_START state.\n\t */\nrecurse:\n\tswitch ((*it)->state)\n\t{\n\t\tcase JBI_ARRAY_START:\n\t\t\t/* Set v to array on first array call */\n\t\t\tval->type = jbvArray;\n\t\t\tval->val.array.nElems = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.array.elems is not actually set, because we aren't doing\n\t\t\t * a full conversion\n\t\t\t */\n\t\t\tval->val.array.rawScalar = (*it)->isScalar;\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = 0;\t/* not actually used */\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_ARRAY_ELEM;\n\t\t\treturn WJB_BEGIN_ARRAY;\n\n\t\tcase JBI_ARRAY_ELEM:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All elements within array already processed.  Report this\n\t\t\t\t * to caller, and give it back original parent iterator (which\n\t\t\t\t * independently tracks iteration progress at its level of\n\t\t\t\t * nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_ARRAY;\n\t\t\t}\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t/* Recurse into container. */\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scalar item in array, or a container and caller didn't want\n\t\t\t\t * us to recurse into it.\n\t\t\t\t */\n\t\t\t\treturn WJB_ELEM;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_START:\n\t\t\t/* Set v to object on first object call */\n\t\t\tval->type = jbvObject;\n\t\t\tval->val.object.nPairs = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.object.pairs is not actually set, because we aren't\n\t\t\t * doing a full conversion\n\t\t\t */\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = getJsonbOffset((*it)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t   (*it)->nElems);\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\t\t\treturn WJB_BEGIN_OBJECT;\n\n\t\tcase JBI_OBJECT_KEY:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All pairs within object already processed.  Report this to\n\t\t\t\t * caller, and give it back original containing iterator\n\t\t\t\t * (which independently tracks iteration progress at its level\n\t\t\t\t * of nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_OBJECT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Return key of a key/value pair.  */\n\t\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t\t   val);\n\t\t\t\tif (val->type != jbvString)\n\t\t\t\t\telog(ERROR, \"unexpected jsonb type as object key\");\n\n\t\t\t\t/* Set state for next call */\n\t\t\t\t(*it)->state = JBI_OBJECT_VALUE;\n\t\t\t\treturn WJB_KEY;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_VALUE:\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex + (*it)->nElems,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curValueOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curValueOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex + (*it)->nElems]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\t/*\n\t\t\t * Value may be a container, in which case we recurse with new,\n\t\t\t * child iterator (unless the caller asked not to, by passing\n\t\t\t * skipNested).\n\t\t\t */\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn WJB_VALUE;\n\t}\n\n\telog(ERROR, \"invalid iterator state\");\n\treturn -1;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbIterator *freeAndGetParent(JsonbIterator *it);",
            "static void uniqueifyJsonbObject(JsonbValue *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbIterator *freeAndGetParent(JsonbIterator *it);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\n\nJsonbIteratorToken\nJsonbIteratorNext(JsonbIterator **it, JsonbValue *val, bool skipNested)\n{\n\tif (*it == NULL)\n\t\treturn WJB_DONE;\n\n\t/*\n\t * When stepping into a nested container, we jump back here to start\n\t * processing the child. We will not recurse further in one call, because\n\t * processing the child will always begin in JBI_ARRAY_START or\n\t * JBI_OBJECT_START state.\n\t */\nrecurse:\n\tswitch ((*it)->state)\n\t{\n\t\tcase JBI_ARRAY_START:\n\t\t\t/* Set v to array on first array call */\n\t\t\tval->type = jbvArray;\n\t\t\tval->val.array.nElems = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.array.elems is not actually set, because we aren't doing\n\t\t\t * a full conversion\n\t\t\t */\n\t\t\tval->val.array.rawScalar = (*it)->isScalar;\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = 0;\t/* not actually used */\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_ARRAY_ELEM;\n\t\t\treturn WJB_BEGIN_ARRAY;\n\n\t\tcase JBI_ARRAY_ELEM:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All elements within array already processed.  Report this\n\t\t\t\t * to caller, and give it back original parent iterator (which\n\t\t\t\t * independently tracks iteration progress at its level of\n\t\t\t\t * nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_ARRAY;\n\t\t\t}\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t/* Recurse into container. */\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scalar item in array, or a container and caller didn't want\n\t\t\t\t * us to recurse into it.\n\t\t\t\t */\n\t\t\t\treturn WJB_ELEM;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_START:\n\t\t\t/* Set v to object on first object call */\n\t\t\tval->type = jbvObject;\n\t\t\tval->val.object.nPairs = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.object.pairs is not actually set, because we aren't\n\t\t\t * doing a full conversion\n\t\t\t */\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = getJsonbOffset((*it)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t   (*it)->nElems);\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\t\t\treturn WJB_BEGIN_OBJECT;\n\n\t\tcase JBI_OBJECT_KEY:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All pairs within object already processed.  Report this to\n\t\t\t\t * caller, and give it back original containing iterator\n\t\t\t\t * (which independently tracks iteration progress at its level\n\t\t\t\t * of nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_OBJECT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Return key of a key/value pair.  */\n\t\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t\t   val);\n\t\t\t\tif (val->type != jbvString)\n\t\t\t\t\telog(ERROR, \"unexpected jsonb type as object key\");\n\n\t\t\t\t/* Set state for next call */\n\t\t\t\t(*it)->state = JBI_OBJECT_VALUE;\n\t\t\t\treturn WJB_KEY;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_VALUE:\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex + (*it)->nElems,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curValueOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curValueOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex + (*it)->nElems]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\t/*\n\t\t\t * Value may be a container, in which case we recurse with new,\n\t\t\t * child iterator (unless the caller asked not to, by passing\n\t\t\t * skipNested).\n\t\t\t */\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn WJB_VALUE;\n\t}\n\n\telog(ERROR, \"invalid iterator state\");\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonbIteratorInit",
          "args": [
            "&jbelem->root"
          ],
          "line": 1538
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbIteratorInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "717-721",
          "snippet": "JsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nJsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "aggcontext"
          ],
          "line": 1536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JsonbValueToJsonb",
          "args": [
            "elem.res"
          ],
          "line": 1532
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbValueToJsonb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "78-113",
          "snippet": "Jsonb *\nJsonbValueToJsonb(JsonbValue *val)\n{\n\tJsonb\t   *out;\n\n\tif (IsAJsonbScalar(val))\n\t{\n\t\t/* Scalar value */\n\t\tJsonbParseState *pstate = NULL;\n\t\tJsonbValue *res;\n\t\tJsonbValue\tscalarArray;\n\n\t\tscalarArray.type = jbvArray;\n\t\tscalarArray.val.array.rawScalar = true;\n\t\tscalarArray.val.array.nElems = 1;\n\n\t\tpushJsonbValue(&pstate, WJB_BEGIN_ARRAY, &scalarArray);\n\t\tpushJsonbValue(&pstate, WJB_ELEM, val);\n\t\tres = pushJsonbValue(&pstate, WJB_END_ARRAY, NULL);\n\n\t\tout = convertToJsonb(res);\n\t}\n\telse if (val->type == jbvObject || val->type == jbvArray)\n\t{\n\t\tout = convertToJsonb(val);\n\t}\n\telse\n\t{\n\t\tAssert(val->type == jbvBinary);\n\t\tout = palloc(VARHDRSZ + val->val.binary.len);\n\t\tSET_VARSIZE(out, VARHDRSZ + val->val.binary.len);\n\t\tmemcpy(VARDATA(out), val->val.binary.data, val->val.binary.len);\n\t}\n\n\treturn out;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static int\treserveFromBuffer(StringInfo buffer, int len);",
            "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
            "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
            "static JsonbParseState *pushState(JsonbParseState **pstate);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\n\nJsonb *\nJsonbValueToJsonb(JsonbValue *val)\n{\n\tJsonb\t   *out;\n\n\tif (IsAJsonbScalar(val))\n\t{\n\t\t/* Scalar value */\n\t\tJsonbParseState *pstate = NULL;\n\t\tJsonbValue *res;\n\t\tJsonbValue\tscalarArray;\n\n\t\tscalarArray.type = jbvArray;\n\t\tscalarArray.val.array.rawScalar = true;\n\t\tscalarArray.val.array.nElems = 1;\n\n\t\tpushJsonbValue(&pstate, WJB_BEGIN_ARRAY, &scalarArray);\n\t\tpushJsonbValue(&pstate, WJB_ELEM, val);\n\t\tres = pushJsonbValue(&pstate, WJB_END_ARRAY, NULL);\n\n\t\tout = convertToJsonb(res);\n\t}\n\telse if (val->type == jbvObject || val->type == jbvArray)\n\t{\n\t\tout = convertToJsonb(val);\n\t}\n\telse\n\t{\n\t\tAssert(val->type == jbvBinary);\n\t\tout = palloc(VARHDRSZ + val->val.binary.len);\n\t\tSET_VARSIZE(out, VARHDRSZ + val->val.binary.len);\n\t\tmemcpy(VARDATA(out), val->val.binary.data, val->val.binary.len);\n\t}\n\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "datum_to_jsonb",
          "args": [
            "val",
            "PG_ARGISNULL(1)",
            "&elem",
            "state->val_category",
            "state->val_output_func",
            "false"
          ],
          "line": 1529
        },
        "resolved": true,
        "details": {
          "function_name": "datum_to_jsonb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
          "lines": "701-914",
          "snippet": "static void\ndatum_to_jsonb(Datum val, bool is_null, JsonbInState *result,\n\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid,\n\t\t\t   bool key_scalar)\n{\n\tchar\t   *outputstr;\n\tbool\t\tnumeric_error;\n\tJsonbValue\tjb;\n\tbool\t\tscalar_jsonb = false;\n\n\tcheck_stack_depth();\n\n\t/* Convert val to a JsonbValue in jb (in most cases) */\n\tif (is_null)\n\t{\n\t\tAssert(!key_scalar);\n\t\tjb.type = jbvNull;\n\t}\n\telse if (key_scalar &&\n\t\t\t (tcategory == JSONBTYPE_ARRAY ||\n\t\t\t  tcategory == JSONBTYPE_COMPOSITE ||\n\t\t\t  tcategory == JSONBTYPE_JSON ||\n\t\t\t  tcategory == JSONBTYPE_JSONB ||\n\t\t\t  tcategory == JSONBTYPE_JSONCAST))\n\t{\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"key value must be scalar, not array, composite, or json\")));\n\t}\n\telse\n\t{\n\t\tif (tcategory == JSONBTYPE_JSONCAST)\n\t\t\tval = OidFunctionCall1(outfuncoid, val);\n\n\t\tswitch (tcategory)\n\t\t{\n\t\t\tcase JSONBTYPE_ARRAY:\n\t\t\t\tarray_to_jsonb_internal(val, result);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_COMPOSITE:\n\t\t\t\tcomposite_to_jsonb(val, result);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_BOOL:\n\t\t\t\tif (key_scalar)\n\t\t\t\t{\n\t\t\t\t\toutputstr = DatumGetBool(val) ? \"true\" : \"false\";\n\t\t\t\t\tjb.type = jbvString;\n\t\t\t\t\tjb.val.string.len = strlen(outputstr);\n\t\t\t\t\tjb.val.string.val = outputstr;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tjb.type = jbvBool;\n\t\t\t\t\tjb.val.boolean = DatumGetBool(val);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_NUMERIC:\n\t\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\t\t\t\tif (key_scalar)\n\t\t\t\t{\n\t\t\t\t\t/* always quote keys */\n\t\t\t\t\tjb.type = jbvString;\n\t\t\t\t\tjb.val.string.len = strlen(outputstr);\n\t\t\t\t\tjb.val.string.val = outputstr;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * Make it numeric if it's a valid JSON number, otherwise\n\t\t\t\t\t * a string. Invalid numeric output will always have an\n\t\t\t\t\t * 'N' or 'n' in it (I think).\n\t\t\t\t\t */\n\t\t\t\t\tnumeric_error = (strchr(outputstr, 'N') != NULL ||\n\t\t\t\t\t\t\t\t\t strchr(outputstr, 'n') != NULL);\n\t\t\t\t\tif (!numeric_error)\n\t\t\t\t\t{\n\t\t\t\t\t\tDatum\t\tnumd;\n\n\t\t\t\t\t\tjb.type = jbvNumeric;\n\t\t\t\t\t\tnumd = DirectFunctionCall3(numeric_in,\n\t\t\t\t\t\t\t\t\t\t\t\t   CStringGetDatum(outputstr),\n\t\t\t\t\t\t\t\t\t\t\t\t   ObjectIdGetDatum(InvalidOid),\n\t\t\t\t\t\t\t\t\t\t\t\t   Int32GetDatum(-1));\n\t\t\t\t\t\tjb.val.numeric = DatumGetNumeric(numd);\n\t\t\t\t\t\tpfree(outputstr);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tjb.type = jbvString;\n\t\t\t\t\t\tjb.val.string.len = strlen(outputstr);\n\t\t\t\t\t\tjb.val.string.val = outputstr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_DATE:\n\t\t\t\tjb.type = jbvString;\n\t\t\t\tjb.val.string.val = JsonEncodeDateTime(NULL, val, DATEOID);\n\t\t\t\tjb.val.string.len = strlen(jb.val.string.val);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_TIMESTAMP:\n\t\t\t\tjb.type = jbvString;\n\t\t\t\tjb.val.string.val = JsonEncodeDateTime(NULL, val, TIMESTAMPOID);\n\t\t\t\tjb.val.string.len = strlen(jb.val.string.val);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_TIMESTAMPTZ:\n\t\t\t\tjb.type = jbvString;\n\t\t\t\tjb.val.string.val = JsonEncodeDateTime(NULL, val, TIMESTAMPTZOID);\n\t\t\t\tjb.val.string.len = strlen(jb.val.string.val);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_JSONCAST:\n\t\t\tcase JSONBTYPE_JSON:\n\t\t\t\t{\n\t\t\t\t\t/* parse the json right into the existing result object */\n\t\t\t\t\tJsonLexContext *lex;\n\t\t\t\t\tJsonSemAction sem;\n\t\t\t\t\ttext\t   *json = DatumGetTextPP(val);\n\n\t\t\t\t\tlex = makeJsonLexContext(json, true);\n\n\t\t\t\t\tmemset(&sem, 0, sizeof(sem));\n\n\t\t\t\t\tsem.semstate = (void *) result;\n\n\t\t\t\t\tsem.object_start = jsonb_in_object_start;\n\t\t\t\t\tsem.array_start = jsonb_in_array_start;\n\t\t\t\t\tsem.object_end = jsonb_in_object_end;\n\t\t\t\t\tsem.array_end = jsonb_in_array_end;\n\t\t\t\t\tsem.scalar = jsonb_in_scalar;\n\t\t\t\t\tsem.object_field_start = jsonb_in_object_field_start;\n\n\t\t\t\t\tpg_parse_json(lex, &sem);\n\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_JSONB:\n\t\t\t\t{\n\t\t\t\t\tJsonb\t   *jsonb = DatumGetJsonbP(val);\n\t\t\t\t\tJsonbIterator *it;\n\n\t\t\t\t\tit = JsonbIteratorInit(&jsonb->root);\n\n\t\t\t\t\tif (JB_ROOT_IS_SCALAR(jsonb))\n\t\t\t\t\t{\n\t\t\t\t\t\t(void) JsonbIteratorNext(&it, &jb, true);\n\t\t\t\t\t\tAssert(jb.type == jbvArray);\n\t\t\t\t\t\t(void) JsonbIteratorNext(&it, &jb, true);\n\t\t\t\t\t\tscalar_jsonb = true;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tJsonbIteratorToken type;\n\n\t\t\t\t\t\twhile ((type = JsonbIteratorNext(&it, &jb, false))\n\t\t\t\t\t\t\t   != WJB_DONE)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (type == WJB_END_ARRAY || type == WJB_END_OBJECT ||\n\t\t\t\t\t\t\t\ttype == WJB_BEGIN_ARRAY || type == WJB_BEGIN_OBJECT)\n\t\t\t\t\t\t\t\tresult->res = pushJsonbValue(&result->parseState,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t type, NULL);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tresult->res = pushJsonbValue(&result->parseState,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t type, &jb);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\t\t\t\tjb.type = jbvString;\n\t\t\t\tjb.val.string.len = checkStringLen(strlen(outputstr));\n\t\t\t\tjb.val.string.val = outputstr;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Now insert jb into result, unless we did it recursively */\n\tif (!is_null && !scalar_jsonb &&\n\t\ttcategory >= JSONBTYPE_JSON && tcategory <= JSONBTYPE_JSONCAST)\n\t{\n\t\t/* work has been done recursively */\n\t\treturn;\n\t}\n\telse if (result->parseState == NULL)\n\t{\n\t\t/* single root scalar */\n\t\tJsonbValue\tva;\n\n\t\tva.type = jbvArray;\n\t\tva.val.array.rawScalar = true;\n\t\tva.val.array.nElems = 1;\n\n\t\tresult->res = pushJsonbValue(&result->parseState, WJB_BEGIN_ARRAY, &va);\n\t\tresult->res = pushJsonbValue(&result->parseState, WJB_ELEM, &jb);\n\t\tresult->res = pushJsonbValue(&result->parseState, WJB_END_ARRAY, NULL);\n\t}\n\telse\n\t{\n\t\tJsonbValue *o = &result->parseState->contVal;\n\n\t\tswitch (o->type)\n\t\t{\n\t\t\tcase jbvArray:\n\t\t\t\tresult->res = pushJsonbValue(&result->parseState, WJB_ELEM, &jb);\n\t\t\t\tbreak;\n\t\t\tcase jbvObject:\n\t\t\t\tresult->res = pushJsonbValue(&result->parseState,\n\t\t\t\t\t\t\t\t\t\t\t key_scalar ? WJB_KEY : WJB_VALUE,\n\t\t\t\t\t\t\t\t\t\t\t &jb);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unexpected parent of nested structure\");\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"miscadmin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline Datum jsonb_from_cstring(char *json, int len);",
            "static size_t checkStringLen(size_t len);",
            "static void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);",
            "static void composite_to_jsonb(Datum composite, JsonbInState *result);",
            "static void array_dim_to_jsonb(JsonbInState *result, int dim, int ndims, int *dims,\n\t\t\t\t   Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid);",
            "static void array_to_jsonb_internal(Datum array, JsonbInState *result);",
            "static void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);",
            "static void datum_to_jsonb(Datum val, bool is_null, JsonbInState *result,\n\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid,\n\t\t\t   bool key_scalar);",
            "static void add_jsonb(Datum val, bool is_null, JsonbInState *result,\n\t\t  Oid val_type, bool key_scalar);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic inline Datum jsonb_from_cstring(char *json, int len);\nstatic size_t checkStringLen(size_t len);\nstatic void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);\nstatic void composite_to_jsonb(Datum composite, JsonbInState *result);\nstatic void array_dim_to_jsonb(JsonbInState *result, int dim, int ndims, int *dims,\n\t\t\t\t   Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid);\nstatic void array_to_jsonb_internal(Datum array, JsonbInState *result);\nstatic void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);\nstatic void datum_to_jsonb(Datum val, bool is_null, JsonbInState *result,\n\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid,\n\t\t\t   bool key_scalar);\nstatic void add_jsonb(Datum val, bool is_null, JsonbInState *result,\n\t\t  Oid val_type, bool key_scalar);\n\nstatic void\ndatum_to_jsonb(Datum val, bool is_null, JsonbInState *result,\n\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid,\n\t\t\t   bool key_scalar)\n{\n\tchar\t   *outputstr;\n\tbool\t\tnumeric_error;\n\tJsonbValue\tjb;\n\tbool\t\tscalar_jsonb = false;\n\n\tcheck_stack_depth();\n\n\t/* Convert val to a JsonbValue in jb (in most cases) */\n\tif (is_null)\n\t{\n\t\tAssert(!key_scalar);\n\t\tjb.type = jbvNull;\n\t}\n\telse if (key_scalar &&\n\t\t\t (tcategory == JSONBTYPE_ARRAY ||\n\t\t\t  tcategory == JSONBTYPE_COMPOSITE ||\n\t\t\t  tcategory == JSONBTYPE_JSON ||\n\t\t\t  tcategory == JSONBTYPE_JSONB ||\n\t\t\t  tcategory == JSONBTYPE_JSONCAST))\n\t{\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"key value must be scalar, not array, composite, or json\")));\n\t}\n\telse\n\t{\n\t\tif (tcategory == JSONBTYPE_JSONCAST)\n\t\t\tval = OidFunctionCall1(outfuncoid, val);\n\n\t\tswitch (tcategory)\n\t\t{\n\t\t\tcase JSONBTYPE_ARRAY:\n\t\t\t\tarray_to_jsonb_internal(val, result);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_COMPOSITE:\n\t\t\t\tcomposite_to_jsonb(val, result);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_BOOL:\n\t\t\t\tif (key_scalar)\n\t\t\t\t{\n\t\t\t\t\toutputstr = DatumGetBool(val) ? \"true\" : \"false\";\n\t\t\t\t\tjb.type = jbvString;\n\t\t\t\t\tjb.val.string.len = strlen(outputstr);\n\t\t\t\t\tjb.val.string.val = outputstr;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tjb.type = jbvBool;\n\t\t\t\t\tjb.val.boolean = DatumGetBool(val);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_NUMERIC:\n\t\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\t\t\t\tif (key_scalar)\n\t\t\t\t{\n\t\t\t\t\t/* always quote keys */\n\t\t\t\t\tjb.type = jbvString;\n\t\t\t\t\tjb.val.string.len = strlen(outputstr);\n\t\t\t\t\tjb.val.string.val = outputstr;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * Make it numeric if it's a valid JSON number, otherwise\n\t\t\t\t\t * a string. Invalid numeric output will always have an\n\t\t\t\t\t * 'N' or 'n' in it (I think).\n\t\t\t\t\t */\n\t\t\t\t\tnumeric_error = (strchr(outputstr, 'N') != NULL ||\n\t\t\t\t\t\t\t\t\t strchr(outputstr, 'n') != NULL);\n\t\t\t\t\tif (!numeric_error)\n\t\t\t\t\t{\n\t\t\t\t\t\tDatum\t\tnumd;\n\n\t\t\t\t\t\tjb.type = jbvNumeric;\n\t\t\t\t\t\tnumd = DirectFunctionCall3(numeric_in,\n\t\t\t\t\t\t\t\t\t\t\t\t   CStringGetDatum(outputstr),\n\t\t\t\t\t\t\t\t\t\t\t\t   ObjectIdGetDatum(InvalidOid),\n\t\t\t\t\t\t\t\t\t\t\t\t   Int32GetDatum(-1));\n\t\t\t\t\t\tjb.val.numeric = DatumGetNumeric(numd);\n\t\t\t\t\t\tpfree(outputstr);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tjb.type = jbvString;\n\t\t\t\t\t\tjb.val.string.len = strlen(outputstr);\n\t\t\t\t\t\tjb.val.string.val = outputstr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_DATE:\n\t\t\t\tjb.type = jbvString;\n\t\t\t\tjb.val.string.val = JsonEncodeDateTime(NULL, val, DATEOID);\n\t\t\t\tjb.val.string.len = strlen(jb.val.string.val);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_TIMESTAMP:\n\t\t\t\tjb.type = jbvString;\n\t\t\t\tjb.val.string.val = JsonEncodeDateTime(NULL, val, TIMESTAMPOID);\n\t\t\t\tjb.val.string.len = strlen(jb.val.string.val);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_TIMESTAMPTZ:\n\t\t\t\tjb.type = jbvString;\n\t\t\t\tjb.val.string.val = JsonEncodeDateTime(NULL, val, TIMESTAMPTZOID);\n\t\t\t\tjb.val.string.len = strlen(jb.val.string.val);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_JSONCAST:\n\t\t\tcase JSONBTYPE_JSON:\n\t\t\t\t{\n\t\t\t\t\t/* parse the json right into the existing result object */\n\t\t\t\t\tJsonLexContext *lex;\n\t\t\t\t\tJsonSemAction sem;\n\t\t\t\t\ttext\t   *json = DatumGetTextPP(val);\n\n\t\t\t\t\tlex = makeJsonLexContext(json, true);\n\n\t\t\t\t\tmemset(&sem, 0, sizeof(sem));\n\n\t\t\t\t\tsem.semstate = (void *) result;\n\n\t\t\t\t\tsem.object_start = jsonb_in_object_start;\n\t\t\t\t\tsem.array_start = jsonb_in_array_start;\n\t\t\t\t\tsem.object_end = jsonb_in_object_end;\n\t\t\t\t\tsem.array_end = jsonb_in_array_end;\n\t\t\t\t\tsem.scalar = jsonb_in_scalar;\n\t\t\t\t\tsem.object_field_start = jsonb_in_object_field_start;\n\n\t\t\t\t\tpg_parse_json(lex, &sem);\n\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_JSONB:\n\t\t\t\t{\n\t\t\t\t\tJsonb\t   *jsonb = DatumGetJsonbP(val);\n\t\t\t\t\tJsonbIterator *it;\n\n\t\t\t\t\tit = JsonbIteratorInit(&jsonb->root);\n\n\t\t\t\t\tif (JB_ROOT_IS_SCALAR(jsonb))\n\t\t\t\t\t{\n\t\t\t\t\t\t(void) JsonbIteratorNext(&it, &jb, true);\n\t\t\t\t\t\tAssert(jb.type == jbvArray);\n\t\t\t\t\t\t(void) JsonbIteratorNext(&it, &jb, true);\n\t\t\t\t\t\tscalar_jsonb = true;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tJsonbIteratorToken type;\n\n\t\t\t\t\t\twhile ((type = JsonbIteratorNext(&it, &jb, false))\n\t\t\t\t\t\t\t   != WJB_DONE)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (type == WJB_END_ARRAY || type == WJB_END_OBJECT ||\n\t\t\t\t\t\t\t\ttype == WJB_BEGIN_ARRAY || type == WJB_BEGIN_OBJECT)\n\t\t\t\t\t\t\t\tresult->res = pushJsonbValue(&result->parseState,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t type, NULL);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tresult->res = pushJsonbValue(&result->parseState,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t type, &jb);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\t\t\t\tjb.type = jbvString;\n\t\t\t\tjb.val.string.len = checkStringLen(strlen(outputstr));\n\t\t\t\tjb.val.string.val = outputstr;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Now insert jb into result, unless we did it recursively */\n\tif (!is_null && !scalar_jsonb &&\n\t\ttcategory >= JSONBTYPE_JSON && tcategory <= JSONBTYPE_JSONCAST)\n\t{\n\t\t/* work has been done recursively */\n\t\treturn;\n\t}\n\telse if (result->parseState == NULL)\n\t{\n\t\t/* single root scalar */\n\t\tJsonbValue\tva;\n\n\t\tva.type = jbvArray;\n\t\tva.val.array.rawScalar = true;\n\t\tva.val.array.nElems = 1;\n\n\t\tresult->res = pushJsonbValue(&result->parseState, WJB_BEGIN_ARRAY, &va);\n\t\tresult->res = pushJsonbValue(&result->parseState, WJB_ELEM, &jb);\n\t\tresult->res = pushJsonbValue(&result->parseState, WJB_END_ARRAY, NULL);\n\t}\n\telse\n\t{\n\t\tJsonbValue *o = &result->parseState->contVal;\n\n\t\tswitch (o->type)\n\t\t{\n\t\t\tcase jbvArray:\n\t\t\t\tresult->res = pushJsonbValue(&result->parseState, WJB_ELEM, &jb);\n\t\t\t\tbreak;\n\t\t\tcase jbvObject:\n\t\t\t\tresult->res = pushJsonbValue(&result->parseState,\n\t\t\t\t\t\t\t\t\t\t\t key_scalar ? WJB_KEY : WJB_VALUE,\n\t\t\t\t\t\t\t\t\t\t\t &jb);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unexpected parent of nested structure\");\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "1"
          ],
          "line": 1529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&elem",
            "0",
            "sizeof(JsonbInState)"
          ],
          "line": 1527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "1"
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "1"
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 1519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jsonb_categorize_type",
          "args": [
            "arg_type",
            "&state->val_category",
            "&state->val_output_func"
          ],
          "line": 1514
        },
        "resolved": true,
        "details": {
          "function_name": "jsonb_categorize_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
          "lines": "593-690",
          "snippet": "static void\njsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid)\n{\n\tbool\t\ttypisvarlena;\n\n\t/* Look through any domain */\n\ttypoid = getBaseType(typoid);\n\n\t*outfuncoid = InvalidOid;\n\n\t/*\n\t * We need to get the output function for everything except date and\n\t * timestamp types, booleans, array and composite types, json and jsonb,\n\t * and non-builtin types where there's a cast to json. In this last case\n\t * we return the oid of the cast function instead.\n\t */\n\n\tswitch (typoid)\n\t{\n\t\tcase BOOLOID:\n\t\t\t*tcategory = JSONBTYPE_BOOL;\n\t\t\tbreak;\n\n\t\tcase INT2OID:\n\t\tcase INT4OID:\n\t\tcase INT8OID:\n\t\tcase FLOAT4OID:\n\t\tcase FLOAT8OID:\n\t\tcase NUMERICOID:\n\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t*tcategory = JSONBTYPE_NUMERIC;\n\t\t\tbreak;\n\n\t\tcase DATEOID:\n\t\t\t*tcategory = JSONBTYPE_DATE;\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPOID:\n\t\t\t*tcategory = JSONBTYPE_TIMESTAMP;\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPTZOID:\n\t\t\t*tcategory = JSONBTYPE_TIMESTAMPTZ;\n\t\t\tbreak;\n\n\t\tcase JSONBOID:\n\t\t\t*tcategory = JSONBTYPE_JSONB;\n\t\t\tbreak;\n\n\t\tcase JSONOID:\n\t\t\t*tcategory = JSONBTYPE_JSON;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* Check for arrays and composites */\n\t\t\tif (OidIsValid(get_element_type(typoid)) || typoid == ANYARRAYOID\n\t\t\t\t|| typoid == RECORDARRAYOID)\n\t\t\t\t*tcategory = JSONBTYPE_ARRAY;\n\t\t\telse if (type_is_rowtype(typoid))\t/* includes RECORDOID */\n\t\t\t\t*tcategory = JSONBTYPE_COMPOSITE;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* It's probably the general case ... */\n\t\t\t\t*tcategory = JSONBTYPE_OTHER;\n\n\t\t\t\t/*\n\t\t\t\t * but first let's look for a cast to json (note: not to\n\t\t\t\t * jsonb) if it's not built-in.\n\t\t\t\t */\n\t\t\t\tif (typoid >= FirstNormalObjectId)\n\t\t\t\t{\n\t\t\t\t\tOid\t\t\tcastfunc;\n\t\t\t\t\tCoercionPathType ctype;\n\n\t\t\t\t\tctype = find_coercion_pathway(JSONOID, typoid,\n\t\t\t\t\t\t\t\t\t\t\t\t  COERCION_EXPLICIT, &castfunc);\n\t\t\t\t\tif (ctype == COERCION_PATH_FUNC && OidIsValid(castfunc))\n\t\t\t\t\t{\n\t\t\t\t\t\t*tcategory = JSONBTYPE_JSONCAST;\n\t\t\t\t\t\t*outfuncoid = castfunc;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* not a cast type, so just get the usual output func */\n\t\t\t\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* any other builtin type */\n\t\t\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"miscadmin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);",
            "static void array_dim_to_jsonb(JsonbInState *result, int dim, int ndims, int *dims,\n\t\t\t\t   Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid);",
            "static void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);\nstatic void array_dim_to_jsonb(JsonbInState *result, int dim, int ndims, int *dims,\n\t\t\t\t   Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid);\nstatic void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);\n\nstatic void\njsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid)\n{\n\tbool\t\ttypisvarlena;\n\n\t/* Look through any domain */\n\ttypoid = getBaseType(typoid);\n\n\t*outfuncoid = InvalidOid;\n\n\t/*\n\t * We need to get the output function for everything except date and\n\t * timestamp types, booleans, array and composite types, json and jsonb,\n\t * and non-builtin types where there's a cast to json. In this last case\n\t * we return the oid of the cast function instead.\n\t */\n\n\tswitch (typoid)\n\t{\n\t\tcase BOOLOID:\n\t\t\t*tcategory = JSONBTYPE_BOOL;\n\t\t\tbreak;\n\n\t\tcase INT2OID:\n\t\tcase INT4OID:\n\t\tcase INT8OID:\n\t\tcase FLOAT4OID:\n\t\tcase FLOAT8OID:\n\t\tcase NUMERICOID:\n\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t*tcategory = JSONBTYPE_NUMERIC;\n\t\t\tbreak;\n\n\t\tcase DATEOID:\n\t\t\t*tcategory = JSONBTYPE_DATE;\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPOID:\n\t\t\t*tcategory = JSONBTYPE_TIMESTAMP;\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPTZOID:\n\t\t\t*tcategory = JSONBTYPE_TIMESTAMPTZ;\n\t\t\tbreak;\n\n\t\tcase JSONBOID:\n\t\t\t*tcategory = JSONBTYPE_JSONB;\n\t\t\tbreak;\n\n\t\tcase JSONOID:\n\t\t\t*tcategory = JSONBTYPE_JSON;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* Check for arrays and composites */\n\t\t\tif (OidIsValid(get_element_type(typoid)) || typoid == ANYARRAYOID\n\t\t\t\t|| typoid == RECORDARRAYOID)\n\t\t\t\t*tcategory = JSONBTYPE_ARRAY;\n\t\t\telse if (type_is_rowtype(typoid))\t/* includes RECORDOID */\n\t\t\t\t*tcategory = JSONBTYPE_COMPOSITE;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* It's probably the general case ... */\n\t\t\t\t*tcategory = JSONBTYPE_OTHER;\n\n\t\t\t\t/*\n\t\t\t\t * but first let's look for a cast to json (note: not to\n\t\t\t\t * jsonb) if it's not built-in.\n\t\t\t\t */\n\t\t\t\tif (typoid >= FirstNormalObjectId)\n\t\t\t\t{\n\t\t\t\t\tOid\t\t\tcastfunc;\n\t\t\t\t\tCoercionPathType ctype;\n\n\t\t\t\t\tctype = find_coercion_pathway(JSONOID, typoid,\n\t\t\t\t\t\t\t\t\t\t\t\t  COERCION_EXPLICIT, &castfunc);\n\t\t\t\t\tif (ctype == COERCION_PATH_FUNC && OidIsValid(castfunc))\n\t\t\t\t\t{\n\t\t\t\t\t\t*tcategory = JSONBTYPE_JSONCAST;\n\t\t\t\t\t\t*outfuncoid = castfunc;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* not a cast type, so just get the usual output func */\n\t\t\t\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* any other builtin type */\n\t\t\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 1512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "sizeof(JsonbInState)"
          ],
          "line": 1508
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "aggcontext"
          ],
          "line": 1506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"could not determine input data type\"))"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not determine input data type\""
          ],
          "line": 1504
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 1503
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fn_expr_argtype",
          "args": [
            "fcinfo->flinfo",
            "1"
          ],
          "line": 1499
        },
        "resolved": true,
        "details": {
          "function_name": "get_fn_expr_argtype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1994-2005",
          "snippet": "Oid\nget_fn_expr_argtype(FmgrInfo *flinfo, int argnum)\n{\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn InvalidOid;\n\n\treturn get_call_expr_argtype(flinfo->fn_expr, argnum);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nOid\nget_fn_expr_argtype(FmgrInfo *flinfo, int argnum)\n{\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn InvalidOid;\n\n\treturn get_call_expr_argtype(flinfo->fn_expr, argnum);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "0"
          ],
          "line": 1497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AggCheckCallContext",
          "args": [
            "fcinfo",
            "&aggcontext"
          ],
          "line": 1489
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic inline Datum jsonb_from_cstring(char *json, int len);\nstatic size_t checkStringLen(size_t len);\nstatic void composite_to_jsonb(Datum composite, JsonbInState *result);\nstatic void array_to_jsonb_internal(Datum array, JsonbInState *result);\nstatic JsonbParseState *clone_parse_state(JsonbParseState *state);\n\nDatum\njsonb_agg_transfn(PG_FUNCTION_ARGS)\n{\n\tMemoryContext oldcontext,\n\t\t\t\taggcontext;\n\tJsonbAggState *state;\n\tJsonbInState elem;\n\tDatum\t\tval;\n\tJsonbInState *result;\n\tbool\t\tsingle_scalar = false;\n\tJsonbIterator *it;\n\tJsonb\t   *jbelem;\n\tJsonbValue\tv;\n\tJsonbIteratorToken type;\n\n\tif (!AggCheckCallContext(fcinfo, &aggcontext))\n\t{\n\t\t/* cannot be called directly because of internal-type argument */\n\t\telog(ERROR, \"jsonb_agg_transfn called in non-aggregate context\");\n\t}\n\n\t/* set up the accumulator on the first go round */\n\n\tif (PG_ARGISNULL(0))\n\t{\n\t\tOid\t\t\targ_type = get_fn_expr_argtype(fcinfo->flinfo, 1);\n\n\t\tif (arg_type == InvalidOid)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"could not determine input data type\")));\n\n\t\toldcontext = MemoryContextSwitchTo(aggcontext);\n\t\tstate = palloc(sizeof(JsonbAggState));\n\t\tresult = palloc0(sizeof(JsonbInState));\n\t\tstate->res = result;\n\t\tresult->res = pushJsonbValue(&result->parseState,\n\t\t\t\t\t\t\t\t\t WJB_BEGIN_ARRAY, NULL);\n\t\tMemoryContextSwitchTo(oldcontext);\n\n\t\tjsonb_categorize_type(arg_type, &state->val_category,\n\t\t\t\t\t\t\t  &state->val_output_func);\n\t}\n\telse\n\t{\n\t\tstate = (JsonbAggState *) PG_GETARG_POINTER(0);\n\t\tresult = state->res;\n\t}\n\n\t/* turn the argument into jsonb in the normal function context */\n\n\tval = PG_ARGISNULL(1) ? (Datum) 0 : PG_GETARG_DATUM(1);\n\n\tmemset(&elem, 0, sizeof(JsonbInState));\n\n\tdatum_to_jsonb(val, PG_ARGISNULL(1), &elem, state->val_category,\n\t\t\t\t   state->val_output_func, false);\n\n\tjbelem = JsonbValueToJsonb(elem.res);\n\n\t/* switch to the aggregate context for accumulation operations */\n\n\toldcontext = MemoryContextSwitchTo(aggcontext);\n\n\tit = JsonbIteratorInit(&jbelem->root);\n\n\twhile ((type = JsonbIteratorNext(&it, &v, false)) != WJB_DONE)\n\t{\n\t\tswitch (type)\n\t\t{\n\t\t\tcase WJB_BEGIN_ARRAY:\n\t\t\t\tif (v.val.array.rawScalar)\n\t\t\t\t\tsingle_scalar = true;\n\t\t\t\telse\n\t\t\t\t\tresult->res = pushJsonbValue(&result->parseState,\n\t\t\t\t\t\t\t\t\t\t\t\t type, NULL);\n\t\t\t\tbreak;\n\t\t\tcase WJB_END_ARRAY:\n\t\t\t\tif (!single_scalar)\n\t\t\t\t\tresult->res = pushJsonbValue(&result->parseState,\n\t\t\t\t\t\t\t\t\t\t\t\t type, NULL);\n\t\t\t\tbreak;\n\t\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tcase WJB_END_OBJECT:\n\t\t\t\tresult->res = pushJsonbValue(&result->parseState,\n\t\t\t\t\t\t\t\t\t\t\t type, NULL);\n\t\t\t\tbreak;\n\t\t\tcase WJB_ELEM:\n\t\t\tcase WJB_KEY:\n\t\t\tcase WJB_VALUE:\n\t\t\t\tif (v.type == jbvString)\n\t\t\t\t{\n\t\t\t\t\t/* copy string values in the aggregate context */\n\t\t\t\t\tchar\t   *buf = palloc(v.val.string.len + 1);\n\n\t\t\t\t\tsnprintf(buf, v.val.string.len + 1, \"%s\", v.val.string.val);\n\t\t\t\t\tv.val.string.val = buf;\n\t\t\t\t}\n\t\t\t\telse if (v.type == jbvNumeric)\n\t\t\t\t{\n\t\t\t\t\t/* same for numeric */\n\t\t\t\t\tv.val.numeric =\n\t\t\t\t\t\tDatumGetNumeric(DirectFunctionCall1(numeric_uplus,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tNumericGetDatum(v.val.numeric)));\n\t\t\t\t}\n\t\t\t\tresult->res = pushJsonbValue(&result->parseState,\n\t\t\t\t\t\t\t\t\t\t\t type, &v);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unknown jsonb iterator token type\");\n\t\t}\n\t}\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\tPG_RETURN_POINTER(state);\n}"
  },
  {
    "function_name": "clone_parse_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
    "lines": "1442-1468",
    "snippet": "static JsonbParseState *\nclone_parse_state(JsonbParseState *state)\n{\n\tJsonbParseState *result,\n\t\t\t   *icursor,\n\t\t\t   *ocursor;\n\n\tif (state == NULL)\n\t\treturn NULL;\n\n\tresult = palloc(sizeof(JsonbParseState));\n\ticursor = state;\n\tocursor = result;\n\tfor (;;)\n\t{\n\t\tocursor->contVal = icursor->contVal;\n\t\tocursor->size = icursor->size;\n\t\ticursor = icursor->next;\n\t\tif (icursor == NULL)\n\t\t\tbreak;\n\t\tocursor->next = palloc(sizeof(JsonbParseState));\n\t\tocursor = ocursor->next;\n\t}\n\tocursor->next = NULL;\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"miscadmin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void composite_to_jsonb(Datum composite, JsonbInState *result);",
      "static void array_to_jsonb_internal(Datum array, JsonbInState *result);",
      "static JsonbParseState *clone_parse_state(JsonbParseState *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(JsonbParseState)"
          ],
          "line": 1462
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic void composite_to_jsonb(Datum composite, JsonbInState *result);\nstatic void array_to_jsonb_internal(Datum array, JsonbInState *result);\nstatic JsonbParseState *clone_parse_state(JsonbParseState *state);\n\nstatic JsonbParseState *\nclone_parse_state(JsonbParseState *state)\n{\n\tJsonbParseState *result,\n\t\t\t   *icursor,\n\t\t\t   *ocursor;\n\n\tif (state == NULL)\n\t\treturn NULL;\n\n\tresult = palloc(sizeof(JsonbParseState));\n\ticursor = state;\n\tocursor = result;\n\tfor (;;)\n\t{\n\t\tocursor->contVal = icursor->contVal;\n\t\tocursor->size = icursor->size;\n\t\ticursor = icursor->next;\n\t\tif (icursor == NULL)\n\t\t\tbreak;\n\t\tocursor->next = palloc(sizeof(JsonbParseState));\n\t\tocursor = ocursor->next;\n\t}\n\tocursor->next = NULL;\n\n\treturn result;\n}"
  },
  {
    "function_name": "jsonb_object_two_arg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
    "lines": "1345-1434",
    "snippet": "Datum\njsonb_object_two_arg(PG_FUNCTION_ARGS)\n{\n\tArrayType  *key_array = PG_GETARG_ARRAYTYPE_P(0);\n\tArrayType  *val_array = PG_GETARG_ARRAYTYPE_P(1);\n\tint\t\t\tnkdims = ARR_NDIM(key_array);\n\tint\t\t\tnvdims = ARR_NDIM(val_array);\n\tDatum\t   *key_datums,\n\t\t\t   *val_datums;\n\tbool\t   *key_nulls,\n\t\t\t   *val_nulls;\n\tint\t\t\tkey_count,\n\t\t\t\tval_count,\n\t\t\t\ti;\n\tJsonbInState result;\n\n\tmemset(&result, 0, sizeof(JsonbInState));\n\n\t(void) pushJsonbValue(&result.parseState, WJB_BEGIN_OBJECT, NULL);\n\n\tif (nkdims > 1 || nkdims != nvdims)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"wrong number of array subscripts\")));\n\n\tif (nkdims == 0)\n\t\tgoto close_object;\n\n\tdeconstruct_array(key_array,\n\t\t\t\t\t  TEXTOID, -1, false, 'i',\n\t\t\t\t\t  &key_datums, &key_nulls, &key_count);\n\n\tdeconstruct_array(val_array,\n\t\t\t\t\t  TEXTOID, -1, false, 'i',\n\t\t\t\t\t  &val_datums, &val_nulls, &val_count);\n\n\tif (key_count != val_count)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"mismatched array dimensions\")));\n\n\tfor (i = 0; i < key_count; ++i)\n\t{\n\t\tJsonbValue\tv;\n\t\tchar\t   *str;\n\t\tint\t\t\tlen;\n\n\t\tif (key_nulls[i])\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"null value not allowed for object key\")));\n\n\t\tstr = TextDatumGetCString(key_datums[i]);\n\t\tlen = strlen(str);\n\n\t\tv.type = jbvString;\n\n\t\tv.val.string.len = len;\n\t\tv.val.string.val = str;\n\n\t\t(void) pushJsonbValue(&result.parseState, WJB_KEY, &v);\n\n\t\tif (val_nulls[i])\n\t\t{\n\t\t\tv.type = jbvNull;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstr = TextDatumGetCString(val_datums[i]);\n\t\t\tlen = strlen(str);\n\n\t\t\tv.type = jbvString;\n\n\t\t\tv.val.string.len = len;\n\t\t\tv.val.string.val = str;\n\t\t}\n\n\t\t(void) pushJsonbValue(&result.parseState, WJB_VALUE, &v);\n\t}\n\n\tpfree(key_datums);\n\tpfree(key_nulls);\n\tpfree(val_datums);\n\tpfree(val_nulls);\n\nclose_object:\n\tresult.res = pushJsonbValue(&result.parseState, WJB_END_OBJECT, NULL);\n\n\tPG_RETURN_POINTER(JsonbValueToJsonb(result.res));\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"miscadmin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static inline Datum jsonb_from_cstring(char *json, int len);",
      "static size_t checkStringLen(size_t len);",
      "static void composite_to_jsonb(Datum composite, JsonbInState *result);",
      "static void array_to_jsonb_internal(Datum array, JsonbInState *result);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "JsonbValueToJsonb(result.res)"
          ],
          "line": 1433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JsonbValueToJsonb",
          "args": [
            "result.res"
          ],
          "line": 1433
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbValueToJsonb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "78-113",
          "snippet": "Jsonb *\nJsonbValueToJsonb(JsonbValue *val)\n{\n\tJsonb\t   *out;\n\n\tif (IsAJsonbScalar(val))\n\t{\n\t\t/* Scalar value */\n\t\tJsonbParseState *pstate = NULL;\n\t\tJsonbValue *res;\n\t\tJsonbValue\tscalarArray;\n\n\t\tscalarArray.type = jbvArray;\n\t\tscalarArray.val.array.rawScalar = true;\n\t\tscalarArray.val.array.nElems = 1;\n\n\t\tpushJsonbValue(&pstate, WJB_BEGIN_ARRAY, &scalarArray);\n\t\tpushJsonbValue(&pstate, WJB_ELEM, val);\n\t\tres = pushJsonbValue(&pstate, WJB_END_ARRAY, NULL);\n\n\t\tout = convertToJsonb(res);\n\t}\n\telse if (val->type == jbvObject || val->type == jbvArray)\n\t{\n\t\tout = convertToJsonb(val);\n\t}\n\telse\n\t{\n\t\tAssert(val->type == jbvBinary);\n\t\tout = palloc(VARHDRSZ + val->val.binary.len);\n\t\tSET_VARSIZE(out, VARHDRSZ + val->val.binary.len);\n\t\tmemcpy(VARDATA(out), val->val.binary.data, val->val.binary.len);\n\t}\n\n\treturn out;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static int\treserveFromBuffer(StringInfo buffer, int len);",
            "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
            "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
            "static JsonbParseState *pushState(JsonbParseState **pstate);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\n\nJsonb *\nJsonbValueToJsonb(JsonbValue *val)\n{\n\tJsonb\t   *out;\n\n\tif (IsAJsonbScalar(val))\n\t{\n\t\t/* Scalar value */\n\t\tJsonbParseState *pstate = NULL;\n\t\tJsonbValue *res;\n\t\tJsonbValue\tscalarArray;\n\n\t\tscalarArray.type = jbvArray;\n\t\tscalarArray.val.array.rawScalar = true;\n\t\tscalarArray.val.array.nElems = 1;\n\n\t\tpushJsonbValue(&pstate, WJB_BEGIN_ARRAY, &scalarArray);\n\t\tpushJsonbValue(&pstate, WJB_ELEM, val);\n\t\tres = pushJsonbValue(&pstate, WJB_END_ARRAY, NULL);\n\n\t\tout = convertToJsonb(res);\n\t}\n\telse if (val->type == jbvObject || val->type == jbvArray)\n\t{\n\t\tout = convertToJsonb(val);\n\t}\n\telse\n\t{\n\t\tAssert(val->type == jbvBinary);\n\t\tout = palloc(VARHDRSZ + val->val.binary.len);\n\t\tSET_VARSIZE(out, VARHDRSZ + val->val.binary.len);\n\t\tmemcpy(VARDATA(out), val->val.binary.data, val->val.binary.len);\n\t}\n\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pushJsonbValue",
          "args": [
            "&result.parseState",
            "WJB_END_OBJECT",
            "NULL"
          ],
          "line": 1431
        },
        "resolved": true,
        "details": {
          "function_name": "pushJsonbValueScalar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "545-629",
          "snippet": "static JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);",
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbParseState *pushState(JsonbParseState **pstate);",
            "static void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void uniqueifyJsonbObject(JsonbValue *object);",
            "static JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\nstatic void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\nstatic JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);\n\nstatic JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "val_nulls"
          ],
          "line": 1428
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str"
          ],
          "line": 1414
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TextDatumGetCString",
          "args": [
            "val_datums[i]"
          ],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TextDatumGetCString",
          "args": [
            "key_datums[i]"
          ],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"null value not allowed for object key\"))"
          ],
          "line": 1393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"null value not allowed for object key\""
          ],
          "line": 1395
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_NULL_VALUE_NOT_ALLOWED"
          ],
          "line": 1394
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"mismatched array dimensions\"))"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deconstruct_array",
          "args": [
            "val_array",
            "TEXTOID",
            "-1",
            "false",
            "'i'",
            "&val_datums",
            "&val_nulls",
            "&val_count"
          ],
          "line": 1377
        },
        "resolved": true,
        "details": {
          "function_name": "deconstruct_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3460-3519",
          "snippet": "void\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\n\nvoid\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"wrong number of array subscripts\"))"
          ],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&result",
            "0",
            "sizeof(JsonbInState)"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NDIM",
          "args": [
            "val_array"
          ],
          "line": 1351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NDIM",
          "args": [
            "key_array"
          ],
          "line": 1350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "1"
          ],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "0"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic inline Datum jsonb_from_cstring(char *json, int len);\nstatic size_t checkStringLen(size_t len);\nstatic void composite_to_jsonb(Datum composite, JsonbInState *result);\nstatic void array_to_jsonb_internal(Datum array, JsonbInState *result);\n\nDatum\njsonb_object_two_arg(PG_FUNCTION_ARGS)\n{\n\tArrayType  *key_array = PG_GETARG_ARRAYTYPE_P(0);\n\tArrayType  *val_array = PG_GETARG_ARRAYTYPE_P(1);\n\tint\t\t\tnkdims = ARR_NDIM(key_array);\n\tint\t\t\tnvdims = ARR_NDIM(val_array);\n\tDatum\t   *key_datums,\n\t\t\t   *val_datums;\n\tbool\t   *key_nulls,\n\t\t\t   *val_nulls;\n\tint\t\t\tkey_count,\n\t\t\t\tval_count,\n\t\t\t\ti;\n\tJsonbInState result;\n\n\tmemset(&result, 0, sizeof(JsonbInState));\n\n\t(void) pushJsonbValue(&result.parseState, WJB_BEGIN_OBJECT, NULL);\n\n\tif (nkdims > 1 || nkdims != nvdims)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"wrong number of array subscripts\")));\n\n\tif (nkdims == 0)\n\t\tgoto close_object;\n\n\tdeconstruct_array(key_array,\n\t\t\t\t\t  TEXTOID, -1, false, 'i',\n\t\t\t\t\t  &key_datums, &key_nulls, &key_count);\n\n\tdeconstruct_array(val_array,\n\t\t\t\t\t  TEXTOID, -1, false, 'i',\n\t\t\t\t\t  &val_datums, &val_nulls, &val_count);\n\n\tif (key_count != val_count)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"mismatched array dimensions\")));\n\n\tfor (i = 0; i < key_count; ++i)\n\t{\n\t\tJsonbValue\tv;\n\t\tchar\t   *str;\n\t\tint\t\t\tlen;\n\n\t\tif (key_nulls[i])\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"null value not allowed for object key\")));\n\n\t\tstr = TextDatumGetCString(key_datums[i]);\n\t\tlen = strlen(str);\n\n\t\tv.type = jbvString;\n\n\t\tv.val.string.len = len;\n\t\tv.val.string.val = str;\n\n\t\t(void) pushJsonbValue(&result.parseState, WJB_KEY, &v);\n\n\t\tif (val_nulls[i])\n\t\t{\n\t\t\tv.type = jbvNull;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstr = TextDatumGetCString(val_datums[i]);\n\t\t\tlen = strlen(str);\n\n\t\t\tv.type = jbvString;\n\n\t\t\tv.val.string.len = len;\n\t\t\tv.val.string.val = str;\n\t\t}\n\n\t\t(void) pushJsonbValue(&result.parseState, WJB_VALUE, &v);\n\t}\n\n\tpfree(key_datums);\n\tpfree(key_nulls);\n\tpfree(val_datums);\n\tpfree(val_nulls);\n\nclose_object:\n\tresult.res = pushJsonbValue(&result.parseState, WJB_END_OBJECT, NULL);\n\n\tPG_RETURN_POINTER(JsonbValueToJsonb(result.res));\n}"
  },
  {
    "function_name": "jsonb_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
    "lines": "1243-1337",
    "snippet": "Datum\njsonb_object(PG_FUNCTION_ARGS)\n{\n\tArrayType  *in_array = PG_GETARG_ARRAYTYPE_P(0);\n\tint\t\t\tndims = ARR_NDIM(in_array);\n\tDatum\t   *in_datums;\n\tbool\t   *in_nulls;\n\tint\t\t\tin_count,\n\t\t\t\tcount,\n\t\t\t\ti;\n\tJsonbInState result;\n\n\tmemset(&result, 0, sizeof(JsonbInState));\n\n\t(void) pushJsonbValue(&result.parseState, WJB_BEGIN_OBJECT, NULL);\n\n\tswitch (ndims)\n\t{\n\t\tcase 0:\n\t\t\tgoto close_object;\n\t\t\tbreak;\n\n\t\tcase 1:\n\t\t\tif ((ARR_DIMS(in_array)[0]) % 2)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t\t errmsg(\"array must have even number of elements\")));\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\t\tif ((ARR_DIMS(in_array)[1]) != 2)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t\t errmsg(\"array must have two columns\")));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t errmsg(\"wrong number of array subscripts\")));\n\t}\n\n\tdeconstruct_array(in_array,\n\t\t\t\t\t  TEXTOID, -1, false, 'i',\n\t\t\t\t\t  &in_datums, &in_nulls, &in_count);\n\n\tcount = in_count / 2;\n\n\tfor (i = 0; i < count; ++i)\n\t{\n\t\tJsonbValue\tv;\n\t\tchar\t   *str;\n\t\tint\t\t\tlen;\n\n\t\tif (in_nulls[i * 2])\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"null value not allowed for object key\")));\n\n\t\tstr = TextDatumGetCString(in_datums[i * 2]);\n\t\tlen = strlen(str);\n\n\t\tv.type = jbvString;\n\n\t\tv.val.string.len = len;\n\t\tv.val.string.val = str;\n\n\t\t(void) pushJsonbValue(&result.parseState, WJB_KEY, &v);\n\n\t\tif (in_nulls[i * 2 + 1])\n\t\t{\n\t\t\tv.type = jbvNull;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstr = TextDatumGetCString(in_datums[i * 2 + 1]);\n\t\t\tlen = strlen(str);\n\n\t\t\tv.type = jbvString;\n\n\t\t\tv.val.string.len = len;\n\t\t\tv.val.string.val = str;\n\t\t}\n\n\t\t(void) pushJsonbValue(&result.parseState, WJB_VALUE, &v);\n\t}\n\n\tpfree(in_datums);\n\tpfree(in_nulls);\n\nclose_object:\n\tresult.res = pushJsonbValue(&result.parseState, WJB_END_OBJECT, NULL);\n\n\tPG_RETURN_POINTER(JsonbValueToJsonb(result.res));\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"miscadmin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static inline Datum jsonb_from_cstring(char *json, int len);",
      "static size_t checkStringLen(size_t len);",
      "static void composite_to_jsonb(Datum composite, JsonbInState *result);",
      "static void array_to_jsonb_internal(Datum array, JsonbInState *result);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "JsonbValueToJsonb(result.res)"
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JsonbValueToJsonb",
          "args": [
            "result.res"
          ],
          "line": 1336
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbValueToJsonb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "78-113",
          "snippet": "Jsonb *\nJsonbValueToJsonb(JsonbValue *val)\n{\n\tJsonb\t   *out;\n\n\tif (IsAJsonbScalar(val))\n\t{\n\t\t/* Scalar value */\n\t\tJsonbParseState *pstate = NULL;\n\t\tJsonbValue *res;\n\t\tJsonbValue\tscalarArray;\n\n\t\tscalarArray.type = jbvArray;\n\t\tscalarArray.val.array.rawScalar = true;\n\t\tscalarArray.val.array.nElems = 1;\n\n\t\tpushJsonbValue(&pstate, WJB_BEGIN_ARRAY, &scalarArray);\n\t\tpushJsonbValue(&pstate, WJB_ELEM, val);\n\t\tres = pushJsonbValue(&pstate, WJB_END_ARRAY, NULL);\n\n\t\tout = convertToJsonb(res);\n\t}\n\telse if (val->type == jbvObject || val->type == jbvArray)\n\t{\n\t\tout = convertToJsonb(val);\n\t}\n\telse\n\t{\n\t\tAssert(val->type == jbvBinary);\n\t\tout = palloc(VARHDRSZ + val->val.binary.len);\n\t\tSET_VARSIZE(out, VARHDRSZ + val->val.binary.len);\n\t\tmemcpy(VARDATA(out), val->val.binary.data, val->val.binary.len);\n\t}\n\n\treturn out;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static int\treserveFromBuffer(StringInfo buffer, int len);",
            "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
            "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
            "static JsonbParseState *pushState(JsonbParseState **pstate);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\n\nJsonb *\nJsonbValueToJsonb(JsonbValue *val)\n{\n\tJsonb\t   *out;\n\n\tif (IsAJsonbScalar(val))\n\t{\n\t\t/* Scalar value */\n\t\tJsonbParseState *pstate = NULL;\n\t\tJsonbValue *res;\n\t\tJsonbValue\tscalarArray;\n\n\t\tscalarArray.type = jbvArray;\n\t\tscalarArray.val.array.rawScalar = true;\n\t\tscalarArray.val.array.nElems = 1;\n\n\t\tpushJsonbValue(&pstate, WJB_BEGIN_ARRAY, &scalarArray);\n\t\tpushJsonbValue(&pstate, WJB_ELEM, val);\n\t\tres = pushJsonbValue(&pstate, WJB_END_ARRAY, NULL);\n\n\t\tout = convertToJsonb(res);\n\t}\n\telse if (val->type == jbvObject || val->type == jbvArray)\n\t{\n\t\tout = convertToJsonb(val);\n\t}\n\telse\n\t{\n\t\tAssert(val->type == jbvBinary);\n\t\tout = palloc(VARHDRSZ + val->val.binary.len);\n\t\tSET_VARSIZE(out, VARHDRSZ + val->val.binary.len);\n\t\tmemcpy(VARDATA(out), val->val.binary.data, val->val.binary.len);\n\t}\n\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pushJsonbValue",
          "args": [
            "&result.parseState",
            "WJB_END_OBJECT",
            "NULL"
          ],
          "line": 1334
        },
        "resolved": true,
        "details": {
          "function_name": "pushJsonbValueScalar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "545-629",
          "snippet": "static JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);",
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbParseState *pushState(JsonbParseState **pstate);",
            "static void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void uniqueifyJsonbObject(JsonbValue *object);",
            "static JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\nstatic void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\nstatic JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);\n\nstatic JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "in_nulls"
          ],
          "line": 1331
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str"
          ],
          "line": 1319
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TextDatumGetCString",
          "args": [
            "in_datums[i * 2 + 1]"
          ],
          "line": 1318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TextDatumGetCString",
          "args": [
            "in_datums[i * 2]"
          ],
          "line": 1302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"null value not allowed for object key\"))"
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"null value not allowed for object key\""
          ],
          "line": 1300
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_NULL_VALUE_NOT_ALLOWED"
          ],
          "line": 1299
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "deconstruct_array",
          "args": [
            "in_array",
            "TEXTOID",
            "-1",
            "false",
            "'i'",
            "&in_datums",
            "&in_nulls",
            "&in_count"
          ],
          "line": 1285
        },
        "resolved": true,
        "details": {
          "function_name": "deconstruct_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3460-3519",
          "snippet": "void\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\n\nvoid\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t errmsg(\"wrong number of array subscripts\"))"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t\t errmsg(\"array must have two columns\"))"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "in_array"
          ],
          "line": 1273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t\t errmsg(\"array must have even number of elements\"))"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "in_array"
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&result",
            "0",
            "sizeof(JsonbInState)"
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NDIM",
          "args": [
            "in_array"
          ],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "0"
          ],
          "line": 1246
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic inline Datum jsonb_from_cstring(char *json, int len);\nstatic size_t checkStringLen(size_t len);\nstatic void composite_to_jsonb(Datum composite, JsonbInState *result);\nstatic void array_to_jsonb_internal(Datum array, JsonbInState *result);\n\nDatum\njsonb_object(PG_FUNCTION_ARGS)\n{\n\tArrayType  *in_array = PG_GETARG_ARRAYTYPE_P(0);\n\tint\t\t\tndims = ARR_NDIM(in_array);\n\tDatum\t   *in_datums;\n\tbool\t   *in_nulls;\n\tint\t\t\tin_count,\n\t\t\t\tcount,\n\t\t\t\ti;\n\tJsonbInState result;\n\n\tmemset(&result, 0, sizeof(JsonbInState));\n\n\t(void) pushJsonbValue(&result.parseState, WJB_BEGIN_OBJECT, NULL);\n\n\tswitch (ndims)\n\t{\n\t\tcase 0:\n\t\t\tgoto close_object;\n\t\t\tbreak;\n\n\t\tcase 1:\n\t\t\tif ((ARR_DIMS(in_array)[0]) % 2)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t\t errmsg(\"array must have even number of elements\")));\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\t\tif ((ARR_DIMS(in_array)[1]) != 2)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t\t errmsg(\"array must have two columns\")));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t errmsg(\"wrong number of array subscripts\")));\n\t}\n\n\tdeconstruct_array(in_array,\n\t\t\t\t\t  TEXTOID, -1, false, 'i',\n\t\t\t\t\t  &in_datums, &in_nulls, &in_count);\n\n\tcount = in_count / 2;\n\n\tfor (i = 0; i < count; ++i)\n\t{\n\t\tJsonbValue\tv;\n\t\tchar\t   *str;\n\t\tint\t\t\tlen;\n\n\t\tif (in_nulls[i * 2])\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"null value not allowed for object key\")));\n\n\t\tstr = TextDatumGetCString(in_datums[i * 2]);\n\t\tlen = strlen(str);\n\n\t\tv.type = jbvString;\n\n\t\tv.val.string.len = len;\n\t\tv.val.string.val = str;\n\n\t\t(void) pushJsonbValue(&result.parseState, WJB_KEY, &v);\n\n\t\tif (in_nulls[i * 2 + 1])\n\t\t{\n\t\t\tv.type = jbvNull;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstr = TextDatumGetCString(in_datums[i * 2 + 1]);\n\t\t\tlen = strlen(str);\n\n\t\t\tv.type = jbvString;\n\n\t\t\tv.val.string.len = len;\n\t\t\tv.val.string.val = str;\n\t\t}\n\n\t\t(void) pushJsonbValue(&result.parseState, WJB_VALUE, &v);\n\t}\n\n\tpfree(in_datums);\n\tpfree(in_nulls);\n\nclose_object:\n\tresult.res = pushJsonbValue(&result.parseState, WJB_END_OBJECT, NULL);\n\n\tPG_RETURN_POINTER(JsonbValueToJsonb(result.res));\n}"
  },
  {
    "function_name": "jsonb_build_array_noargs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
    "lines": "1222-1233",
    "snippet": "Datum\njsonb_build_array_noargs(PG_FUNCTION_ARGS)\n{\n\tJsonbInState result;\n\n\tmemset(&result, 0, sizeof(JsonbInState));\n\n\t(void) pushJsonbValue(&result.parseState, WJB_BEGIN_ARRAY, NULL);\n\tresult.res = pushJsonbValue(&result.parseState, WJB_END_ARRAY, NULL);\n\n\tPG_RETURN_POINTER(JsonbValueToJsonb(result.res));\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"miscadmin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void composite_to_jsonb(Datum composite, JsonbInState *result);",
      "static void array_to_jsonb_internal(Datum array, JsonbInState *result);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "JsonbValueToJsonb(result.res)"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JsonbValueToJsonb",
          "args": [
            "result.res"
          ],
          "line": 1232
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbValueToJsonb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "78-113",
          "snippet": "Jsonb *\nJsonbValueToJsonb(JsonbValue *val)\n{\n\tJsonb\t   *out;\n\n\tif (IsAJsonbScalar(val))\n\t{\n\t\t/* Scalar value */\n\t\tJsonbParseState *pstate = NULL;\n\t\tJsonbValue *res;\n\t\tJsonbValue\tscalarArray;\n\n\t\tscalarArray.type = jbvArray;\n\t\tscalarArray.val.array.rawScalar = true;\n\t\tscalarArray.val.array.nElems = 1;\n\n\t\tpushJsonbValue(&pstate, WJB_BEGIN_ARRAY, &scalarArray);\n\t\tpushJsonbValue(&pstate, WJB_ELEM, val);\n\t\tres = pushJsonbValue(&pstate, WJB_END_ARRAY, NULL);\n\n\t\tout = convertToJsonb(res);\n\t}\n\telse if (val->type == jbvObject || val->type == jbvArray)\n\t{\n\t\tout = convertToJsonb(val);\n\t}\n\telse\n\t{\n\t\tAssert(val->type == jbvBinary);\n\t\tout = palloc(VARHDRSZ + val->val.binary.len);\n\t\tSET_VARSIZE(out, VARHDRSZ + val->val.binary.len);\n\t\tmemcpy(VARDATA(out), val->val.binary.data, val->val.binary.len);\n\t}\n\n\treturn out;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static int\treserveFromBuffer(StringInfo buffer, int len);",
            "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
            "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
            "static JsonbParseState *pushState(JsonbParseState **pstate);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\n\nJsonb *\nJsonbValueToJsonb(JsonbValue *val)\n{\n\tJsonb\t   *out;\n\n\tif (IsAJsonbScalar(val))\n\t{\n\t\t/* Scalar value */\n\t\tJsonbParseState *pstate = NULL;\n\t\tJsonbValue *res;\n\t\tJsonbValue\tscalarArray;\n\n\t\tscalarArray.type = jbvArray;\n\t\tscalarArray.val.array.rawScalar = true;\n\t\tscalarArray.val.array.nElems = 1;\n\n\t\tpushJsonbValue(&pstate, WJB_BEGIN_ARRAY, &scalarArray);\n\t\tpushJsonbValue(&pstate, WJB_ELEM, val);\n\t\tres = pushJsonbValue(&pstate, WJB_END_ARRAY, NULL);\n\n\t\tout = convertToJsonb(res);\n\t}\n\telse if (val->type == jbvObject || val->type == jbvArray)\n\t{\n\t\tout = convertToJsonb(val);\n\t}\n\telse\n\t{\n\t\tAssert(val->type == jbvBinary);\n\t\tout = palloc(VARHDRSZ + val->val.binary.len);\n\t\tSET_VARSIZE(out, VARHDRSZ + val->val.binary.len);\n\t\tmemcpy(VARDATA(out), val->val.binary.data, val->val.binary.len);\n\t}\n\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pushJsonbValue",
          "args": [
            "&result.parseState",
            "WJB_END_ARRAY",
            "NULL"
          ],
          "line": 1230
        },
        "resolved": true,
        "details": {
          "function_name": "pushJsonbValueScalar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "545-629",
          "snippet": "static JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);",
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbParseState *pushState(JsonbParseState **pstate);",
            "static void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void uniqueifyJsonbObject(JsonbValue *object);",
            "static JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\nstatic void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\nstatic JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);\n\nstatic JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&result",
            "0",
            "sizeof(JsonbInState)"
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic void composite_to_jsonb(Datum composite, JsonbInState *result);\nstatic void array_to_jsonb_internal(Datum array, JsonbInState *result);\n\nDatum\njsonb_build_array_noargs(PG_FUNCTION_ARGS)\n{\n\tJsonbInState result;\n\n\tmemset(&result, 0, sizeof(JsonbInState));\n\n\t(void) pushJsonbValue(&result.parseState, WJB_BEGIN_ARRAY, NULL);\n\tresult.res = pushJsonbValue(&result.parseState, WJB_END_ARRAY, NULL);\n\n\tPG_RETURN_POINTER(JsonbValueToJsonb(result.res));\n}"
  },
  {
    "function_name": "jsonb_build_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
    "lines": "1191-1217",
    "snippet": "Datum\njsonb_build_array(PG_FUNCTION_ARGS)\n{\n\tint\t\t\tnargs;\n\tint\t\t\ti;\n\tJsonbInState result;\n\tDatum\t   *args;\n\tbool\t   *nulls;\n\tOid\t\t   *types;\n\n\t/* build argument values to build the array */\n\tnargs = extract_variadic_args(fcinfo, 0, true, &args, &types, &nulls);\n\n\tif (nargs < 0)\n\t\tPG_RETURN_NULL();\n\n\tmemset(&result, 0, sizeof(JsonbInState));\n\n\tresult.res = pushJsonbValue(&result.parseState, WJB_BEGIN_ARRAY, NULL);\n\n\tfor (i = 0; i < nargs; i++)\n\t\tadd_jsonb(args[i], nulls[i], &result, types[i], false);\n\n\tresult.res = pushJsonbValue(&result.parseState, WJB_END_ARRAY, NULL);\n\n\tPG_RETURN_POINTER(JsonbValueToJsonb(result.res));\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"miscadmin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void composite_to_jsonb(Datum composite, JsonbInState *result);",
      "static void array_to_jsonb_internal(Datum array, JsonbInState *result);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "JsonbValueToJsonb(result.res)"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JsonbValueToJsonb",
          "args": [
            "result.res"
          ],
          "line": 1216
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbValueToJsonb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "78-113",
          "snippet": "Jsonb *\nJsonbValueToJsonb(JsonbValue *val)\n{\n\tJsonb\t   *out;\n\n\tif (IsAJsonbScalar(val))\n\t{\n\t\t/* Scalar value */\n\t\tJsonbParseState *pstate = NULL;\n\t\tJsonbValue *res;\n\t\tJsonbValue\tscalarArray;\n\n\t\tscalarArray.type = jbvArray;\n\t\tscalarArray.val.array.rawScalar = true;\n\t\tscalarArray.val.array.nElems = 1;\n\n\t\tpushJsonbValue(&pstate, WJB_BEGIN_ARRAY, &scalarArray);\n\t\tpushJsonbValue(&pstate, WJB_ELEM, val);\n\t\tres = pushJsonbValue(&pstate, WJB_END_ARRAY, NULL);\n\n\t\tout = convertToJsonb(res);\n\t}\n\telse if (val->type == jbvObject || val->type == jbvArray)\n\t{\n\t\tout = convertToJsonb(val);\n\t}\n\telse\n\t{\n\t\tAssert(val->type == jbvBinary);\n\t\tout = palloc(VARHDRSZ + val->val.binary.len);\n\t\tSET_VARSIZE(out, VARHDRSZ + val->val.binary.len);\n\t\tmemcpy(VARDATA(out), val->val.binary.data, val->val.binary.len);\n\t}\n\n\treturn out;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static int\treserveFromBuffer(StringInfo buffer, int len);",
            "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
            "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
            "static JsonbParseState *pushState(JsonbParseState **pstate);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\n\nJsonb *\nJsonbValueToJsonb(JsonbValue *val)\n{\n\tJsonb\t   *out;\n\n\tif (IsAJsonbScalar(val))\n\t{\n\t\t/* Scalar value */\n\t\tJsonbParseState *pstate = NULL;\n\t\tJsonbValue *res;\n\t\tJsonbValue\tscalarArray;\n\n\t\tscalarArray.type = jbvArray;\n\t\tscalarArray.val.array.rawScalar = true;\n\t\tscalarArray.val.array.nElems = 1;\n\n\t\tpushJsonbValue(&pstate, WJB_BEGIN_ARRAY, &scalarArray);\n\t\tpushJsonbValue(&pstate, WJB_ELEM, val);\n\t\tres = pushJsonbValue(&pstate, WJB_END_ARRAY, NULL);\n\n\t\tout = convertToJsonb(res);\n\t}\n\telse if (val->type == jbvObject || val->type == jbvArray)\n\t{\n\t\tout = convertToJsonb(val);\n\t}\n\telse\n\t{\n\t\tAssert(val->type == jbvBinary);\n\t\tout = palloc(VARHDRSZ + val->val.binary.len);\n\t\tSET_VARSIZE(out, VARHDRSZ + val->val.binary.len);\n\t\tmemcpy(VARDATA(out), val->val.binary.data, val->val.binary.len);\n\t}\n\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pushJsonbValue",
          "args": [
            "&result.parseState",
            "WJB_END_ARRAY",
            "NULL"
          ],
          "line": 1214
        },
        "resolved": true,
        "details": {
          "function_name": "pushJsonbValueScalar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "545-629",
          "snippet": "static JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);",
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbParseState *pushState(JsonbParseState **pstate);",
            "static void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void uniqueifyJsonbObject(JsonbValue *object);",
            "static JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\nstatic void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\nstatic JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);\n\nstatic JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_jsonb",
          "args": [
            "args[i]",
            "nulls[i]",
            "&result",
            "types[i]",
            "false"
          ],
          "line": 1212
        },
        "resolved": true,
        "details": {
          "function_name": "add_jsonb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
          "lines": "1073-1095",
          "snippet": "static void\nadd_jsonb(Datum val, bool is_null, JsonbInState *result,\n\t\t  Oid val_type, bool key_scalar)\n{\n\tJsonbTypeCategory tcategory;\n\tOid\t\t\toutfuncoid;\n\n\tif (val_type == InvalidOid)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"could not determine input data type\")));\n\n\tif (is_null)\n\t{\n\t\ttcategory = JSONBTYPE_NULL;\n\t\toutfuncoid = InvalidOid;\n\t}\n\telse\n\t\tjsonb_categorize_type(val_type,\n\t\t\t\t\t\t\t  &tcategory, &outfuncoid);\n\n\tdatum_to_jsonb(val, is_null, result, tcategory, outfuncoid, key_scalar);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"miscadmin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);",
            "static void composite_to_jsonb(Datum composite, JsonbInState *result);",
            "static void array_dim_to_jsonb(JsonbInState *result, int dim, int ndims, int *dims,\n\t\t\t\t   Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid);",
            "static void array_to_jsonb_internal(Datum array, JsonbInState *result);",
            "static void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);",
            "static void datum_to_jsonb(Datum val, bool is_null, JsonbInState *result,\n\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid,\n\t\t\t   bool key_scalar);",
            "static void add_jsonb(Datum val, bool is_null, JsonbInState *result,\n\t\t  Oid val_type, bool key_scalar);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);\nstatic void composite_to_jsonb(Datum composite, JsonbInState *result);\nstatic void array_dim_to_jsonb(JsonbInState *result, int dim, int ndims, int *dims,\n\t\t\t\t   Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid);\nstatic void array_to_jsonb_internal(Datum array, JsonbInState *result);\nstatic void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);\nstatic void datum_to_jsonb(Datum val, bool is_null, JsonbInState *result,\n\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid,\n\t\t\t   bool key_scalar);\nstatic void add_jsonb(Datum val, bool is_null, JsonbInState *result,\n\t\t  Oid val_type, bool key_scalar);\n\nstatic void\nadd_jsonb(Datum val, bool is_null, JsonbInState *result,\n\t\t  Oid val_type, bool key_scalar)\n{\n\tJsonbTypeCategory tcategory;\n\tOid\t\t\toutfuncoid;\n\n\tif (val_type == InvalidOid)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"could not determine input data type\")));\n\n\tif (is_null)\n\t{\n\t\ttcategory = JSONBTYPE_NULL;\n\t\toutfuncoid = InvalidOid;\n\t}\n\telse\n\t\tjsonb_categorize_type(val_type,\n\t\t\t\t\t\t\t  &tcategory, &outfuncoid);\n\n\tdatum_to_jsonb(val, is_null, result, tcategory, outfuncoid, key_scalar);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&result",
            "0",
            "sizeof(JsonbInState)"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extract_variadic_args",
          "args": [
            "fcinfo",
            "0",
            "true",
            "&args",
            "&types",
            "&nulls"
          ],
          "line": 1202
        },
        "resolved": true,
        "details": {
          "function_name": "extract_variadic_args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/funcapi.c",
          "lines": "1478-1575",
          "snippet": "int\nextract_variadic_args(FunctionCallInfo fcinfo, int variadic_start,\n\t\t\t\t\t  bool convert_unknown, Datum **args, Oid **types,\n\t\t\t\t\t  bool **nulls)\n{\n\tbool\t\tvariadic = get_fn_expr_variadic(fcinfo->flinfo);\n\tDatum\t   *args_res;\n\tbool\t   *nulls_res;\n\tOid\t\t   *types_res;\n\tint\t\t\tnargs,\n\t\t\t\ti;\n\n\t*args = NULL;\n\t*types = NULL;\n\t*nulls = NULL;\n\n\tif (variadic)\n\t{\n\t\tArrayType  *array_in;\n\t\tOid\t\t\telement_type;\n\t\tbool\t\ttypbyval;\n\t\tchar\t\ttypalign;\n\t\tint16\t\ttyplen;\n\n\t\tAssert(PG_NARGS() == variadic_start + 1);\n\n\t\tif (PG_ARGISNULL(variadic_start))\n\t\t\treturn -1;\n\n\t\tarray_in = PG_GETARG_ARRAYTYPE_P(variadic_start);\n\t\telement_type = ARR_ELEMTYPE(array_in);\n\n\t\tget_typlenbyvalalign(element_type,\n\t\t\t\t\t\t\t &typlen, &typbyval, &typalign);\n\t\tdeconstruct_array(array_in, element_type, typlen, typbyval,\n\t\t\t\t\t\t  typalign, &args_res, &nulls_res,\n\t\t\t\t\t\t  &nargs);\n\n\t\t/* All the elements of the array have the same type */\n\t\ttypes_res = (Oid *) palloc0(nargs * sizeof(Oid));\n\t\tfor (i = 0; i < nargs; i++)\n\t\t\ttypes_res[i] = element_type;\n\t}\n\telse\n\t{\n\t\tnargs = PG_NARGS() - variadic_start;\n\t\tAssert(nargs > 0);\n\t\tnulls_res = (bool *) palloc0(nargs * sizeof(bool));\n\t\targs_res = (Datum *) palloc0(nargs * sizeof(Datum));\n\t\ttypes_res = (Oid *) palloc0(nargs * sizeof(Oid));\n\n\t\tfor (i = 0; i < nargs; i++)\n\t\t{\n\t\t\tnulls_res[i] = PG_ARGISNULL(i + variadic_start);\n\t\t\ttypes_res[i] = get_fn_expr_argtype(fcinfo->flinfo,\n\t\t\t\t\t\t\t\t\t\t\t   i + variadic_start);\n\n\t\t\t/*\n\t\t\t * Turn a constant (more or less literal) value that's of unknown\n\t\t\t * type into text if required. Unknowns come in as a cstring\n\t\t\t * pointer. Note: for functions declared as taking type \"any\", the\n\t\t\t * parser will not do any type conversion on unknown-type literals\n\t\t\t * (that is, undecorated strings or NULLs).\n\t\t\t */\n\t\t\tif (convert_unknown &&\n\t\t\t\ttypes_res[i] == UNKNOWNOID &&\n\t\t\t\tget_fn_expr_arg_stable(fcinfo->flinfo, i + variadic_start))\n\t\t\t{\n\t\t\t\ttypes_res[i] = TEXTOID;\n\n\t\t\t\tif (PG_ARGISNULL(i + variadic_start))\n\t\t\t\t\targs_res[i] = (Datum) 0;\n\t\t\t\telse\n\t\t\t\t\targs_res[i] =\n\t\t\t\t\t\tCStringGetTextDatum(PG_GETARG_POINTER(i + variadic_start));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* no conversion needed, just take the datum as given */\n\t\t\t\targs_res[i] = PG_GETARG_DATUM(i + variadic_start);\n\t\t\t}\n\n\t\t\tif (!OidIsValid(types_res[i]) ||\n\t\t\t\t(convert_unknown && types_res[i] == UNKNOWNOID))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"could not determine data type for argument %d\",\n\t\t\t\t\t\t\t\ti + 1)));\n\t\t}\n\t}\n\n\t/* Fill in results */\n\t*args = args_res;\n\t*nulls = nulls_res;\n\t*types = types_res;\n\n\treturn nargs;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nint\nextract_variadic_args(FunctionCallInfo fcinfo, int variadic_start,\n\t\t\t\t\t  bool convert_unknown, Datum **args, Oid **types,\n\t\t\t\t\t  bool **nulls)\n{\n\tbool\t\tvariadic = get_fn_expr_variadic(fcinfo->flinfo);\n\tDatum\t   *args_res;\n\tbool\t   *nulls_res;\n\tOid\t\t   *types_res;\n\tint\t\t\tnargs,\n\t\t\t\ti;\n\n\t*args = NULL;\n\t*types = NULL;\n\t*nulls = NULL;\n\n\tif (variadic)\n\t{\n\t\tArrayType  *array_in;\n\t\tOid\t\t\telement_type;\n\t\tbool\t\ttypbyval;\n\t\tchar\t\ttypalign;\n\t\tint16\t\ttyplen;\n\n\t\tAssert(PG_NARGS() == variadic_start + 1);\n\n\t\tif (PG_ARGISNULL(variadic_start))\n\t\t\treturn -1;\n\n\t\tarray_in = PG_GETARG_ARRAYTYPE_P(variadic_start);\n\t\telement_type = ARR_ELEMTYPE(array_in);\n\n\t\tget_typlenbyvalalign(element_type,\n\t\t\t\t\t\t\t &typlen, &typbyval, &typalign);\n\t\tdeconstruct_array(array_in, element_type, typlen, typbyval,\n\t\t\t\t\t\t  typalign, &args_res, &nulls_res,\n\t\t\t\t\t\t  &nargs);\n\n\t\t/* All the elements of the array have the same type */\n\t\ttypes_res = (Oid *) palloc0(nargs * sizeof(Oid));\n\t\tfor (i = 0; i < nargs; i++)\n\t\t\ttypes_res[i] = element_type;\n\t}\n\telse\n\t{\n\t\tnargs = PG_NARGS() - variadic_start;\n\t\tAssert(nargs > 0);\n\t\tnulls_res = (bool *) palloc0(nargs * sizeof(bool));\n\t\targs_res = (Datum *) palloc0(nargs * sizeof(Datum));\n\t\ttypes_res = (Oid *) palloc0(nargs * sizeof(Oid));\n\n\t\tfor (i = 0; i < nargs; i++)\n\t\t{\n\t\t\tnulls_res[i] = PG_ARGISNULL(i + variadic_start);\n\t\t\ttypes_res[i] = get_fn_expr_argtype(fcinfo->flinfo,\n\t\t\t\t\t\t\t\t\t\t\t   i + variadic_start);\n\n\t\t\t/*\n\t\t\t * Turn a constant (more or less literal) value that's of unknown\n\t\t\t * type into text if required. Unknowns come in as a cstring\n\t\t\t * pointer. Note: for functions declared as taking type \"any\", the\n\t\t\t * parser will not do any type conversion on unknown-type literals\n\t\t\t * (that is, undecorated strings or NULLs).\n\t\t\t */\n\t\t\tif (convert_unknown &&\n\t\t\t\ttypes_res[i] == UNKNOWNOID &&\n\t\t\t\tget_fn_expr_arg_stable(fcinfo->flinfo, i + variadic_start))\n\t\t\t{\n\t\t\t\ttypes_res[i] = TEXTOID;\n\n\t\t\t\tif (PG_ARGISNULL(i + variadic_start))\n\t\t\t\t\targs_res[i] = (Datum) 0;\n\t\t\t\telse\n\t\t\t\t\targs_res[i] =\n\t\t\t\t\t\tCStringGetTextDatum(PG_GETARG_POINTER(i + variadic_start));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* no conversion needed, just take the datum as given */\n\t\t\t\targs_res[i] = PG_GETARG_DATUM(i + variadic_start);\n\t\t\t}\n\n\t\t\tif (!OidIsValid(types_res[i]) ||\n\t\t\t\t(convert_unknown && types_res[i] == UNKNOWNOID))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"could not determine data type for argument %d\",\n\t\t\t\t\t\t\t\ti + 1)));\n\t\t}\n\t}\n\n\t/* Fill in results */\n\t*args = args_res;\n\t*nulls = nulls_res;\n\t*types = types_res;\n\n\treturn nargs;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic void composite_to_jsonb(Datum composite, JsonbInState *result);\nstatic void array_to_jsonb_internal(Datum array, JsonbInState *result);\n\nDatum\njsonb_build_array(PG_FUNCTION_ARGS)\n{\n\tint\t\t\tnargs;\n\tint\t\t\ti;\n\tJsonbInState result;\n\tDatum\t   *args;\n\tbool\t   *nulls;\n\tOid\t\t   *types;\n\n\t/* build argument values to build the array */\n\tnargs = extract_variadic_args(fcinfo, 0, true, &args, &types, &nulls);\n\n\tif (nargs < 0)\n\t\tPG_RETURN_NULL();\n\n\tmemset(&result, 0, sizeof(JsonbInState));\n\n\tresult.res = pushJsonbValue(&result.parseState, WJB_BEGIN_ARRAY, NULL);\n\n\tfor (i = 0; i < nargs; i++)\n\t\tadd_jsonb(args[i], nulls[i], &result, types[i], false);\n\n\tresult.res = pushJsonbValue(&result.parseState, WJB_END_ARRAY, NULL);\n\n\tPG_RETURN_POINTER(JsonbValueToJsonb(result.res));\n}"
  },
  {
    "function_name": "jsonb_build_object_noargs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
    "lines": "1175-1186",
    "snippet": "Datum\njsonb_build_object_noargs(PG_FUNCTION_ARGS)\n{\n\tJsonbInState result;\n\n\tmemset(&result, 0, sizeof(JsonbInState));\n\n\t(void) pushJsonbValue(&result.parseState, WJB_BEGIN_OBJECT, NULL);\n\tresult.res = pushJsonbValue(&result.parseState, WJB_END_OBJECT, NULL);\n\n\tPG_RETURN_POINTER(JsonbValueToJsonb(result.res));\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"miscadmin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void composite_to_jsonb(Datum composite, JsonbInState *result);",
      "static void array_to_jsonb_internal(Datum array, JsonbInState *result);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "JsonbValueToJsonb(result.res)"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JsonbValueToJsonb",
          "args": [
            "result.res"
          ],
          "line": 1185
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbValueToJsonb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "78-113",
          "snippet": "Jsonb *\nJsonbValueToJsonb(JsonbValue *val)\n{\n\tJsonb\t   *out;\n\n\tif (IsAJsonbScalar(val))\n\t{\n\t\t/* Scalar value */\n\t\tJsonbParseState *pstate = NULL;\n\t\tJsonbValue *res;\n\t\tJsonbValue\tscalarArray;\n\n\t\tscalarArray.type = jbvArray;\n\t\tscalarArray.val.array.rawScalar = true;\n\t\tscalarArray.val.array.nElems = 1;\n\n\t\tpushJsonbValue(&pstate, WJB_BEGIN_ARRAY, &scalarArray);\n\t\tpushJsonbValue(&pstate, WJB_ELEM, val);\n\t\tres = pushJsonbValue(&pstate, WJB_END_ARRAY, NULL);\n\n\t\tout = convertToJsonb(res);\n\t}\n\telse if (val->type == jbvObject || val->type == jbvArray)\n\t{\n\t\tout = convertToJsonb(val);\n\t}\n\telse\n\t{\n\t\tAssert(val->type == jbvBinary);\n\t\tout = palloc(VARHDRSZ + val->val.binary.len);\n\t\tSET_VARSIZE(out, VARHDRSZ + val->val.binary.len);\n\t\tmemcpy(VARDATA(out), val->val.binary.data, val->val.binary.len);\n\t}\n\n\treturn out;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static int\treserveFromBuffer(StringInfo buffer, int len);",
            "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
            "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
            "static JsonbParseState *pushState(JsonbParseState **pstate);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\n\nJsonb *\nJsonbValueToJsonb(JsonbValue *val)\n{\n\tJsonb\t   *out;\n\n\tif (IsAJsonbScalar(val))\n\t{\n\t\t/* Scalar value */\n\t\tJsonbParseState *pstate = NULL;\n\t\tJsonbValue *res;\n\t\tJsonbValue\tscalarArray;\n\n\t\tscalarArray.type = jbvArray;\n\t\tscalarArray.val.array.rawScalar = true;\n\t\tscalarArray.val.array.nElems = 1;\n\n\t\tpushJsonbValue(&pstate, WJB_BEGIN_ARRAY, &scalarArray);\n\t\tpushJsonbValue(&pstate, WJB_ELEM, val);\n\t\tres = pushJsonbValue(&pstate, WJB_END_ARRAY, NULL);\n\n\t\tout = convertToJsonb(res);\n\t}\n\telse if (val->type == jbvObject || val->type == jbvArray)\n\t{\n\t\tout = convertToJsonb(val);\n\t}\n\telse\n\t{\n\t\tAssert(val->type == jbvBinary);\n\t\tout = palloc(VARHDRSZ + val->val.binary.len);\n\t\tSET_VARSIZE(out, VARHDRSZ + val->val.binary.len);\n\t\tmemcpy(VARDATA(out), val->val.binary.data, val->val.binary.len);\n\t}\n\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pushJsonbValue",
          "args": [
            "&result.parseState",
            "WJB_END_OBJECT",
            "NULL"
          ],
          "line": 1183
        },
        "resolved": true,
        "details": {
          "function_name": "pushJsonbValueScalar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "545-629",
          "snippet": "static JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);",
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbParseState *pushState(JsonbParseState **pstate);",
            "static void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void uniqueifyJsonbObject(JsonbValue *object);",
            "static JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\nstatic void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\nstatic JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);\n\nstatic JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&result",
            "0",
            "sizeof(JsonbInState)"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic void composite_to_jsonb(Datum composite, JsonbInState *result);\nstatic void array_to_jsonb_internal(Datum array, JsonbInState *result);\n\nDatum\njsonb_build_object_noargs(PG_FUNCTION_ARGS)\n{\n\tJsonbInState result;\n\n\tmemset(&result, 0, sizeof(JsonbInState));\n\n\t(void) pushJsonbValue(&result.parseState, WJB_BEGIN_OBJECT, NULL);\n\tresult.res = pushJsonbValue(&result.parseState, WJB_END_OBJECT, NULL);\n\n\tPG_RETURN_POINTER(JsonbValueToJsonb(result.res));\n}"
  },
  {
    "function_name": "jsonb_build_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
    "lines": "1127-1170",
    "snippet": "Datum\njsonb_build_object(PG_FUNCTION_ARGS)\n{\n\tint\t\t\tnargs;\n\tint\t\t\ti;\n\tJsonbInState result;\n\tDatum\t   *args;\n\tbool\t   *nulls;\n\tOid\t\t   *types;\n\n\t/* build argument values to build the object */\n\tnargs = extract_variadic_args(fcinfo, 0, true, &args, &types, &nulls);\n\n\tif (nargs < 0)\n\t\tPG_RETURN_NULL();\n\n\tif (nargs % 2 != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"argument list must have even number of elements\"),\n\t\t\t\t errhint(\"The arguments of jsonb_build_object() must consist of alternating keys and values.\")));\n\n\tmemset(&result, 0, sizeof(JsonbInState));\n\n\tresult.res = pushJsonbValue(&result.parseState, WJB_BEGIN_OBJECT, NULL);\n\n\tfor (i = 0; i < nargs; i += 2)\n\t{\n\t\t/* process key */\n\t\tif (nulls[i])\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"argument %d: key must not be null\", i + 1)));\n\n\t\tadd_jsonb(args[i], false, &result, types[i], true);\n\n\t\t/* process value */\n\t\tadd_jsonb(args[i + 1], nulls[i + 1], &result, types[i + 1], false);\n\t}\n\n\tresult.res = pushJsonbValue(&result.parseState, WJB_END_OBJECT, NULL);\n\n\tPG_RETURN_POINTER(JsonbValueToJsonb(result.res));\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"miscadmin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void composite_to_jsonb(Datum composite, JsonbInState *result);",
      "static void array_to_jsonb_internal(Datum array, JsonbInState *result);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "JsonbValueToJsonb(result.res)"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JsonbValueToJsonb",
          "args": [
            "result.res"
          ],
          "line": 1169
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbValueToJsonb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "78-113",
          "snippet": "Jsonb *\nJsonbValueToJsonb(JsonbValue *val)\n{\n\tJsonb\t   *out;\n\n\tif (IsAJsonbScalar(val))\n\t{\n\t\t/* Scalar value */\n\t\tJsonbParseState *pstate = NULL;\n\t\tJsonbValue *res;\n\t\tJsonbValue\tscalarArray;\n\n\t\tscalarArray.type = jbvArray;\n\t\tscalarArray.val.array.rawScalar = true;\n\t\tscalarArray.val.array.nElems = 1;\n\n\t\tpushJsonbValue(&pstate, WJB_BEGIN_ARRAY, &scalarArray);\n\t\tpushJsonbValue(&pstate, WJB_ELEM, val);\n\t\tres = pushJsonbValue(&pstate, WJB_END_ARRAY, NULL);\n\n\t\tout = convertToJsonb(res);\n\t}\n\telse if (val->type == jbvObject || val->type == jbvArray)\n\t{\n\t\tout = convertToJsonb(val);\n\t}\n\telse\n\t{\n\t\tAssert(val->type == jbvBinary);\n\t\tout = palloc(VARHDRSZ + val->val.binary.len);\n\t\tSET_VARSIZE(out, VARHDRSZ + val->val.binary.len);\n\t\tmemcpy(VARDATA(out), val->val.binary.data, val->val.binary.len);\n\t}\n\n\treturn out;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static int\treserveFromBuffer(StringInfo buffer, int len);",
            "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
            "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
            "static JsonbParseState *pushState(JsonbParseState **pstate);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\n\nJsonb *\nJsonbValueToJsonb(JsonbValue *val)\n{\n\tJsonb\t   *out;\n\n\tif (IsAJsonbScalar(val))\n\t{\n\t\t/* Scalar value */\n\t\tJsonbParseState *pstate = NULL;\n\t\tJsonbValue *res;\n\t\tJsonbValue\tscalarArray;\n\n\t\tscalarArray.type = jbvArray;\n\t\tscalarArray.val.array.rawScalar = true;\n\t\tscalarArray.val.array.nElems = 1;\n\n\t\tpushJsonbValue(&pstate, WJB_BEGIN_ARRAY, &scalarArray);\n\t\tpushJsonbValue(&pstate, WJB_ELEM, val);\n\t\tres = pushJsonbValue(&pstate, WJB_END_ARRAY, NULL);\n\n\t\tout = convertToJsonb(res);\n\t}\n\telse if (val->type == jbvObject || val->type == jbvArray)\n\t{\n\t\tout = convertToJsonb(val);\n\t}\n\telse\n\t{\n\t\tAssert(val->type == jbvBinary);\n\t\tout = palloc(VARHDRSZ + val->val.binary.len);\n\t\tSET_VARSIZE(out, VARHDRSZ + val->val.binary.len);\n\t\tmemcpy(VARDATA(out), val->val.binary.data, val->val.binary.len);\n\t}\n\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pushJsonbValue",
          "args": [
            "&result.parseState",
            "WJB_END_OBJECT",
            "NULL"
          ],
          "line": 1167
        },
        "resolved": true,
        "details": {
          "function_name": "pushJsonbValueScalar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "545-629",
          "snippet": "static JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);",
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbParseState *pushState(JsonbParseState **pstate);",
            "static void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void uniqueifyJsonbObject(JsonbValue *object);",
            "static JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\nstatic void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\nstatic JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);\n\nstatic JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_jsonb",
          "args": [
            "args[i + 1]",
            "nulls[i + 1]",
            "&result",
            "types[i + 1]",
            "false"
          ],
          "line": 1164
        },
        "resolved": true,
        "details": {
          "function_name": "add_jsonb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
          "lines": "1073-1095",
          "snippet": "static void\nadd_jsonb(Datum val, bool is_null, JsonbInState *result,\n\t\t  Oid val_type, bool key_scalar)\n{\n\tJsonbTypeCategory tcategory;\n\tOid\t\t\toutfuncoid;\n\n\tif (val_type == InvalidOid)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"could not determine input data type\")));\n\n\tif (is_null)\n\t{\n\t\ttcategory = JSONBTYPE_NULL;\n\t\toutfuncoid = InvalidOid;\n\t}\n\telse\n\t\tjsonb_categorize_type(val_type,\n\t\t\t\t\t\t\t  &tcategory, &outfuncoid);\n\n\tdatum_to_jsonb(val, is_null, result, tcategory, outfuncoid, key_scalar);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"miscadmin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);",
            "static void composite_to_jsonb(Datum composite, JsonbInState *result);",
            "static void array_dim_to_jsonb(JsonbInState *result, int dim, int ndims, int *dims,\n\t\t\t\t   Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid);",
            "static void array_to_jsonb_internal(Datum array, JsonbInState *result);",
            "static void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);",
            "static void datum_to_jsonb(Datum val, bool is_null, JsonbInState *result,\n\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid,\n\t\t\t   bool key_scalar);",
            "static void add_jsonb(Datum val, bool is_null, JsonbInState *result,\n\t\t  Oid val_type, bool key_scalar);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);\nstatic void composite_to_jsonb(Datum composite, JsonbInState *result);\nstatic void array_dim_to_jsonb(JsonbInState *result, int dim, int ndims, int *dims,\n\t\t\t\t   Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid);\nstatic void array_to_jsonb_internal(Datum array, JsonbInState *result);\nstatic void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);\nstatic void datum_to_jsonb(Datum val, bool is_null, JsonbInState *result,\n\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid,\n\t\t\t   bool key_scalar);\nstatic void add_jsonb(Datum val, bool is_null, JsonbInState *result,\n\t\t  Oid val_type, bool key_scalar);\n\nstatic void\nadd_jsonb(Datum val, bool is_null, JsonbInState *result,\n\t\t  Oid val_type, bool key_scalar)\n{\n\tJsonbTypeCategory tcategory;\n\tOid\t\t\toutfuncoid;\n\n\tif (val_type == InvalidOid)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"could not determine input data type\")));\n\n\tif (is_null)\n\t{\n\t\ttcategory = JSONBTYPE_NULL;\n\t\toutfuncoid = InvalidOid;\n\t}\n\telse\n\t\tjsonb_categorize_type(val_type,\n\t\t\t\t\t\t\t  &tcategory, &outfuncoid);\n\n\tdatum_to_jsonb(val, is_null, result, tcategory, outfuncoid, key_scalar);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"argument %d: key must not be null\", i + 1))"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"argument %d: key must not be null\"",
            "i + 1"
          ],
          "line": 1159
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 1158
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&result",
            "0",
            "sizeof(JsonbInState)"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"argument list must have even number of elements\"),\n\t\t\t\t errhint(\"The arguments of jsonb_build_object() must consist of alternating keys and values.\"))"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errhint",
          "args": [
            "\"The arguments of jsonb_build_object() must consist of alternating keys and values.\""
          ],
          "line": 1147
        },
        "resolved": true,
        "details": {
          "function_name": "errhint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "984-999",
          "snippet": "int\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extract_variadic_args",
          "args": [
            "fcinfo",
            "0",
            "true",
            "&args",
            "&types",
            "&nulls"
          ],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "extract_variadic_args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/funcapi.c",
          "lines": "1478-1575",
          "snippet": "int\nextract_variadic_args(FunctionCallInfo fcinfo, int variadic_start,\n\t\t\t\t\t  bool convert_unknown, Datum **args, Oid **types,\n\t\t\t\t\t  bool **nulls)\n{\n\tbool\t\tvariadic = get_fn_expr_variadic(fcinfo->flinfo);\n\tDatum\t   *args_res;\n\tbool\t   *nulls_res;\n\tOid\t\t   *types_res;\n\tint\t\t\tnargs,\n\t\t\t\ti;\n\n\t*args = NULL;\n\t*types = NULL;\n\t*nulls = NULL;\n\n\tif (variadic)\n\t{\n\t\tArrayType  *array_in;\n\t\tOid\t\t\telement_type;\n\t\tbool\t\ttypbyval;\n\t\tchar\t\ttypalign;\n\t\tint16\t\ttyplen;\n\n\t\tAssert(PG_NARGS() == variadic_start + 1);\n\n\t\tif (PG_ARGISNULL(variadic_start))\n\t\t\treturn -1;\n\n\t\tarray_in = PG_GETARG_ARRAYTYPE_P(variadic_start);\n\t\telement_type = ARR_ELEMTYPE(array_in);\n\n\t\tget_typlenbyvalalign(element_type,\n\t\t\t\t\t\t\t &typlen, &typbyval, &typalign);\n\t\tdeconstruct_array(array_in, element_type, typlen, typbyval,\n\t\t\t\t\t\t  typalign, &args_res, &nulls_res,\n\t\t\t\t\t\t  &nargs);\n\n\t\t/* All the elements of the array have the same type */\n\t\ttypes_res = (Oid *) palloc0(nargs * sizeof(Oid));\n\t\tfor (i = 0; i < nargs; i++)\n\t\t\ttypes_res[i] = element_type;\n\t}\n\telse\n\t{\n\t\tnargs = PG_NARGS() - variadic_start;\n\t\tAssert(nargs > 0);\n\t\tnulls_res = (bool *) palloc0(nargs * sizeof(bool));\n\t\targs_res = (Datum *) palloc0(nargs * sizeof(Datum));\n\t\ttypes_res = (Oid *) palloc0(nargs * sizeof(Oid));\n\n\t\tfor (i = 0; i < nargs; i++)\n\t\t{\n\t\t\tnulls_res[i] = PG_ARGISNULL(i + variadic_start);\n\t\t\ttypes_res[i] = get_fn_expr_argtype(fcinfo->flinfo,\n\t\t\t\t\t\t\t\t\t\t\t   i + variadic_start);\n\n\t\t\t/*\n\t\t\t * Turn a constant (more or less literal) value that's of unknown\n\t\t\t * type into text if required. Unknowns come in as a cstring\n\t\t\t * pointer. Note: for functions declared as taking type \"any\", the\n\t\t\t * parser will not do any type conversion on unknown-type literals\n\t\t\t * (that is, undecorated strings or NULLs).\n\t\t\t */\n\t\t\tif (convert_unknown &&\n\t\t\t\ttypes_res[i] == UNKNOWNOID &&\n\t\t\t\tget_fn_expr_arg_stable(fcinfo->flinfo, i + variadic_start))\n\t\t\t{\n\t\t\t\ttypes_res[i] = TEXTOID;\n\n\t\t\t\tif (PG_ARGISNULL(i + variadic_start))\n\t\t\t\t\targs_res[i] = (Datum) 0;\n\t\t\t\telse\n\t\t\t\t\targs_res[i] =\n\t\t\t\t\t\tCStringGetTextDatum(PG_GETARG_POINTER(i + variadic_start));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* no conversion needed, just take the datum as given */\n\t\t\t\targs_res[i] = PG_GETARG_DATUM(i + variadic_start);\n\t\t\t}\n\n\t\t\tif (!OidIsValid(types_res[i]) ||\n\t\t\t\t(convert_unknown && types_res[i] == UNKNOWNOID))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"could not determine data type for argument %d\",\n\t\t\t\t\t\t\t\ti + 1)));\n\t\t}\n\t}\n\n\t/* Fill in results */\n\t*args = args_res;\n\t*nulls = nulls_res;\n\t*types = types_res;\n\n\treturn nargs;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nint\nextract_variadic_args(FunctionCallInfo fcinfo, int variadic_start,\n\t\t\t\t\t  bool convert_unknown, Datum **args, Oid **types,\n\t\t\t\t\t  bool **nulls)\n{\n\tbool\t\tvariadic = get_fn_expr_variadic(fcinfo->flinfo);\n\tDatum\t   *args_res;\n\tbool\t   *nulls_res;\n\tOid\t\t   *types_res;\n\tint\t\t\tnargs,\n\t\t\t\ti;\n\n\t*args = NULL;\n\t*types = NULL;\n\t*nulls = NULL;\n\n\tif (variadic)\n\t{\n\t\tArrayType  *array_in;\n\t\tOid\t\t\telement_type;\n\t\tbool\t\ttypbyval;\n\t\tchar\t\ttypalign;\n\t\tint16\t\ttyplen;\n\n\t\tAssert(PG_NARGS() == variadic_start + 1);\n\n\t\tif (PG_ARGISNULL(variadic_start))\n\t\t\treturn -1;\n\n\t\tarray_in = PG_GETARG_ARRAYTYPE_P(variadic_start);\n\t\telement_type = ARR_ELEMTYPE(array_in);\n\n\t\tget_typlenbyvalalign(element_type,\n\t\t\t\t\t\t\t &typlen, &typbyval, &typalign);\n\t\tdeconstruct_array(array_in, element_type, typlen, typbyval,\n\t\t\t\t\t\t  typalign, &args_res, &nulls_res,\n\t\t\t\t\t\t  &nargs);\n\n\t\t/* All the elements of the array have the same type */\n\t\ttypes_res = (Oid *) palloc0(nargs * sizeof(Oid));\n\t\tfor (i = 0; i < nargs; i++)\n\t\t\ttypes_res[i] = element_type;\n\t}\n\telse\n\t{\n\t\tnargs = PG_NARGS() - variadic_start;\n\t\tAssert(nargs > 0);\n\t\tnulls_res = (bool *) palloc0(nargs * sizeof(bool));\n\t\targs_res = (Datum *) palloc0(nargs * sizeof(Datum));\n\t\ttypes_res = (Oid *) palloc0(nargs * sizeof(Oid));\n\n\t\tfor (i = 0; i < nargs; i++)\n\t\t{\n\t\t\tnulls_res[i] = PG_ARGISNULL(i + variadic_start);\n\t\t\ttypes_res[i] = get_fn_expr_argtype(fcinfo->flinfo,\n\t\t\t\t\t\t\t\t\t\t\t   i + variadic_start);\n\n\t\t\t/*\n\t\t\t * Turn a constant (more or less literal) value that's of unknown\n\t\t\t * type into text if required. Unknowns come in as a cstring\n\t\t\t * pointer. Note: for functions declared as taking type \"any\", the\n\t\t\t * parser will not do any type conversion on unknown-type literals\n\t\t\t * (that is, undecorated strings or NULLs).\n\t\t\t */\n\t\t\tif (convert_unknown &&\n\t\t\t\ttypes_res[i] == UNKNOWNOID &&\n\t\t\t\tget_fn_expr_arg_stable(fcinfo->flinfo, i + variadic_start))\n\t\t\t{\n\t\t\t\ttypes_res[i] = TEXTOID;\n\n\t\t\t\tif (PG_ARGISNULL(i + variadic_start))\n\t\t\t\t\targs_res[i] = (Datum) 0;\n\t\t\t\telse\n\t\t\t\t\targs_res[i] =\n\t\t\t\t\t\tCStringGetTextDatum(PG_GETARG_POINTER(i + variadic_start));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* no conversion needed, just take the datum as given */\n\t\t\t\targs_res[i] = PG_GETARG_DATUM(i + variadic_start);\n\t\t\t}\n\n\t\t\tif (!OidIsValid(types_res[i]) ||\n\t\t\t\t(convert_unknown && types_res[i] == UNKNOWNOID))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"could not determine data type for argument %d\",\n\t\t\t\t\t\t\t\ti + 1)));\n\t\t}\n\t}\n\n\t/* Fill in results */\n\t*args = args_res;\n\t*nulls = nulls_res;\n\t*types = types_res;\n\n\treturn nargs;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic void composite_to_jsonb(Datum composite, JsonbInState *result);\nstatic void array_to_jsonb_internal(Datum array, JsonbInState *result);\n\nDatum\njsonb_build_object(PG_FUNCTION_ARGS)\n{\n\tint\t\t\tnargs;\n\tint\t\t\ti;\n\tJsonbInState result;\n\tDatum\t   *args;\n\tbool\t   *nulls;\n\tOid\t\t   *types;\n\n\t/* build argument values to build the object */\n\tnargs = extract_variadic_args(fcinfo, 0, true, &args, &types, &nulls);\n\n\tif (nargs < 0)\n\t\tPG_RETURN_NULL();\n\n\tif (nargs % 2 != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"argument list must have even number of elements\"),\n\t\t\t\t errhint(\"The arguments of jsonb_build_object() must consist of alternating keys and values.\")));\n\n\tmemset(&result, 0, sizeof(JsonbInState));\n\n\tresult.res = pushJsonbValue(&result.parseState, WJB_BEGIN_OBJECT, NULL);\n\n\tfor (i = 0; i < nargs; i += 2)\n\t{\n\t\t/* process key */\n\t\tif (nulls[i])\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"argument %d: key must not be null\", i + 1)));\n\n\t\tadd_jsonb(args[i], false, &result, types[i], true);\n\n\t\t/* process value */\n\t\tadd_jsonb(args[i + 1], nulls[i + 1], &result, types[i + 1], false);\n\t}\n\n\tresult.res = pushJsonbValue(&result.parseState, WJB_END_OBJECT, NULL);\n\n\tPG_RETURN_POINTER(JsonbValueToJsonb(result.res));\n}"
  },
  {
    "function_name": "to_jsonb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
    "lines": "1100-1122",
    "snippet": "Datum\nto_jsonb(PG_FUNCTION_ARGS)\n{\n\tDatum\t\tval = PG_GETARG_DATUM(0);\n\tOid\t\t\tval_type = get_fn_expr_argtype(fcinfo->flinfo, 0);\n\tJsonbInState result;\n\tJsonbTypeCategory tcategory;\n\tOid\t\t\toutfuncoid;\n\n\tif (val_type == InvalidOid)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"could not determine input data type\")));\n\n\tjsonb_categorize_type(val_type,\n\t\t\t\t\t\t  &tcategory, &outfuncoid);\n\n\tmemset(&result, 0, sizeof(JsonbInState));\n\n\tdatum_to_jsonb(val, false, &result, tcategory, outfuncoid, false);\n\n\tPG_RETURN_POINTER(JsonbValueToJsonb(result.res));\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"miscadmin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);",
      "static void composite_to_jsonb(Datum composite, JsonbInState *result);",
      "static void array_dim_to_jsonb(JsonbInState *result, int dim, int ndims, int *dims,\n\t\t\t\t   Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid);",
      "static void array_to_jsonb_internal(Datum array, JsonbInState *result);",
      "static void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "JsonbValueToJsonb(result.res)"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JsonbValueToJsonb",
          "args": [
            "result.res"
          ],
          "line": 1121
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbValueToJsonb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "78-113",
          "snippet": "Jsonb *\nJsonbValueToJsonb(JsonbValue *val)\n{\n\tJsonb\t   *out;\n\n\tif (IsAJsonbScalar(val))\n\t{\n\t\t/* Scalar value */\n\t\tJsonbParseState *pstate = NULL;\n\t\tJsonbValue *res;\n\t\tJsonbValue\tscalarArray;\n\n\t\tscalarArray.type = jbvArray;\n\t\tscalarArray.val.array.rawScalar = true;\n\t\tscalarArray.val.array.nElems = 1;\n\n\t\tpushJsonbValue(&pstate, WJB_BEGIN_ARRAY, &scalarArray);\n\t\tpushJsonbValue(&pstate, WJB_ELEM, val);\n\t\tres = pushJsonbValue(&pstate, WJB_END_ARRAY, NULL);\n\n\t\tout = convertToJsonb(res);\n\t}\n\telse if (val->type == jbvObject || val->type == jbvArray)\n\t{\n\t\tout = convertToJsonb(val);\n\t}\n\telse\n\t{\n\t\tAssert(val->type == jbvBinary);\n\t\tout = palloc(VARHDRSZ + val->val.binary.len);\n\t\tSET_VARSIZE(out, VARHDRSZ + val->val.binary.len);\n\t\tmemcpy(VARDATA(out), val->val.binary.data, val->val.binary.len);\n\t}\n\n\treturn out;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static int\treserveFromBuffer(StringInfo buffer, int len);",
            "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
            "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
            "static JsonbParseState *pushState(JsonbParseState **pstate);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\n\nJsonb *\nJsonbValueToJsonb(JsonbValue *val)\n{\n\tJsonb\t   *out;\n\n\tif (IsAJsonbScalar(val))\n\t{\n\t\t/* Scalar value */\n\t\tJsonbParseState *pstate = NULL;\n\t\tJsonbValue *res;\n\t\tJsonbValue\tscalarArray;\n\n\t\tscalarArray.type = jbvArray;\n\t\tscalarArray.val.array.rawScalar = true;\n\t\tscalarArray.val.array.nElems = 1;\n\n\t\tpushJsonbValue(&pstate, WJB_BEGIN_ARRAY, &scalarArray);\n\t\tpushJsonbValue(&pstate, WJB_ELEM, val);\n\t\tres = pushJsonbValue(&pstate, WJB_END_ARRAY, NULL);\n\n\t\tout = convertToJsonb(res);\n\t}\n\telse if (val->type == jbvObject || val->type == jbvArray)\n\t{\n\t\tout = convertToJsonb(val);\n\t}\n\telse\n\t{\n\t\tAssert(val->type == jbvBinary);\n\t\tout = palloc(VARHDRSZ + val->val.binary.len);\n\t\tSET_VARSIZE(out, VARHDRSZ + val->val.binary.len);\n\t\tmemcpy(VARDATA(out), val->val.binary.data, val->val.binary.len);\n\t}\n\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "datum_to_jsonb",
          "args": [
            "val",
            "false",
            "&result",
            "tcategory",
            "outfuncoid",
            "false"
          ],
          "line": 1119
        },
        "resolved": true,
        "details": {
          "function_name": "datum_to_jsonb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
          "lines": "701-914",
          "snippet": "static void\ndatum_to_jsonb(Datum val, bool is_null, JsonbInState *result,\n\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid,\n\t\t\t   bool key_scalar)\n{\n\tchar\t   *outputstr;\n\tbool\t\tnumeric_error;\n\tJsonbValue\tjb;\n\tbool\t\tscalar_jsonb = false;\n\n\tcheck_stack_depth();\n\n\t/* Convert val to a JsonbValue in jb (in most cases) */\n\tif (is_null)\n\t{\n\t\tAssert(!key_scalar);\n\t\tjb.type = jbvNull;\n\t}\n\telse if (key_scalar &&\n\t\t\t (tcategory == JSONBTYPE_ARRAY ||\n\t\t\t  tcategory == JSONBTYPE_COMPOSITE ||\n\t\t\t  tcategory == JSONBTYPE_JSON ||\n\t\t\t  tcategory == JSONBTYPE_JSONB ||\n\t\t\t  tcategory == JSONBTYPE_JSONCAST))\n\t{\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"key value must be scalar, not array, composite, or json\")));\n\t}\n\telse\n\t{\n\t\tif (tcategory == JSONBTYPE_JSONCAST)\n\t\t\tval = OidFunctionCall1(outfuncoid, val);\n\n\t\tswitch (tcategory)\n\t\t{\n\t\t\tcase JSONBTYPE_ARRAY:\n\t\t\t\tarray_to_jsonb_internal(val, result);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_COMPOSITE:\n\t\t\t\tcomposite_to_jsonb(val, result);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_BOOL:\n\t\t\t\tif (key_scalar)\n\t\t\t\t{\n\t\t\t\t\toutputstr = DatumGetBool(val) ? \"true\" : \"false\";\n\t\t\t\t\tjb.type = jbvString;\n\t\t\t\t\tjb.val.string.len = strlen(outputstr);\n\t\t\t\t\tjb.val.string.val = outputstr;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tjb.type = jbvBool;\n\t\t\t\t\tjb.val.boolean = DatumGetBool(val);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_NUMERIC:\n\t\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\t\t\t\tif (key_scalar)\n\t\t\t\t{\n\t\t\t\t\t/* always quote keys */\n\t\t\t\t\tjb.type = jbvString;\n\t\t\t\t\tjb.val.string.len = strlen(outputstr);\n\t\t\t\t\tjb.val.string.val = outputstr;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * Make it numeric if it's a valid JSON number, otherwise\n\t\t\t\t\t * a string. Invalid numeric output will always have an\n\t\t\t\t\t * 'N' or 'n' in it (I think).\n\t\t\t\t\t */\n\t\t\t\t\tnumeric_error = (strchr(outputstr, 'N') != NULL ||\n\t\t\t\t\t\t\t\t\t strchr(outputstr, 'n') != NULL);\n\t\t\t\t\tif (!numeric_error)\n\t\t\t\t\t{\n\t\t\t\t\t\tDatum\t\tnumd;\n\n\t\t\t\t\t\tjb.type = jbvNumeric;\n\t\t\t\t\t\tnumd = DirectFunctionCall3(numeric_in,\n\t\t\t\t\t\t\t\t\t\t\t\t   CStringGetDatum(outputstr),\n\t\t\t\t\t\t\t\t\t\t\t\t   ObjectIdGetDatum(InvalidOid),\n\t\t\t\t\t\t\t\t\t\t\t\t   Int32GetDatum(-1));\n\t\t\t\t\t\tjb.val.numeric = DatumGetNumeric(numd);\n\t\t\t\t\t\tpfree(outputstr);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tjb.type = jbvString;\n\t\t\t\t\t\tjb.val.string.len = strlen(outputstr);\n\t\t\t\t\t\tjb.val.string.val = outputstr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_DATE:\n\t\t\t\tjb.type = jbvString;\n\t\t\t\tjb.val.string.val = JsonEncodeDateTime(NULL, val, DATEOID);\n\t\t\t\tjb.val.string.len = strlen(jb.val.string.val);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_TIMESTAMP:\n\t\t\t\tjb.type = jbvString;\n\t\t\t\tjb.val.string.val = JsonEncodeDateTime(NULL, val, TIMESTAMPOID);\n\t\t\t\tjb.val.string.len = strlen(jb.val.string.val);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_TIMESTAMPTZ:\n\t\t\t\tjb.type = jbvString;\n\t\t\t\tjb.val.string.val = JsonEncodeDateTime(NULL, val, TIMESTAMPTZOID);\n\t\t\t\tjb.val.string.len = strlen(jb.val.string.val);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_JSONCAST:\n\t\t\tcase JSONBTYPE_JSON:\n\t\t\t\t{\n\t\t\t\t\t/* parse the json right into the existing result object */\n\t\t\t\t\tJsonLexContext *lex;\n\t\t\t\t\tJsonSemAction sem;\n\t\t\t\t\ttext\t   *json = DatumGetTextPP(val);\n\n\t\t\t\t\tlex = makeJsonLexContext(json, true);\n\n\t\t\t\t\tmemset(&sem, 0, sizeof(sem));\n\n\t\t\t\t\tsem.semstate = (void *) result;\n\n\t\t\t\t\tsem.object_start = jsonb_in_object_start;\n\t\t\t\t\tsem.array_start = jsonb_in_array_start;\n\t\t\t\t\tsem.object_end = jsonb_in_object_end;\n\t\t\t\t\tsem.array_end = jsonb_in_array_end;\n\t\t\t\t\tsem.scalar = jsonb_in_scalar;\n\t\t\t\t\tsem.object_field_start = jsonb_in_object_field_start;\n\n\t\t\t\t\tpg_parse_json(lex, &sem);\n\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_JSONB:\n\t\t\t\t{\n\t\t\t\t\tJsonb\t   *jsonb = DatumGetJsonbP(val);\n\t\t\t\t\tJsonbIterator *it;\n\n\t\t\t\t\tit = JsonbIteratorInit(&jsonb->root);\n\n\t\t\t\t\tif (JB_ROOT_IS_SCALAR(jsonb))\n\t\t\t\t\t{\n\t\t\t\t\t\t(void) JsonbIteratorNext(&it, &jb, true);\n\t\t\t\t\t\tAssert(jb.type == jbvArray);\n\t\t\t\t\t\t(void) JsonbIteratorNext(&it, &jb, true);\n\t\t\t\t\t\tscalar_jsonb = true;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tJsonbIteratorToken type;\n\n\t\t\t\t\t\twhile ((type = JsonbIteratorNext(&it, &jb, false))\n\t\t\t\t\t\t\t   != WJB_DONE)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (type == WJB_END_ARRAY || type == WJB_END_OBJECT ||\n\t\t\t\t\t\t\t\ttype == WJB_BEGIN_ARRAY || type == WJB_BEGIN_OBJECT)\n\t\t\t\t\t\t\t\tresult->res = pushJsonbValue(&result->parseState,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t type, NULL);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tresult->res = pushJsonbValue(&result->parseState,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t type, &jb);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\t\t\t\tjb.type = jbvString;\n\t\t\t\tjb.val.string.len = checkStringLen(strlen(outputstr));\n\t\t\t\tjb.val.string.val = outputstr;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Now insert jb into result, unless we did it recursively */\n\tif (!is_null && !scalar_jsonb &&\n\t\ttcategory >= JSONBTYPE_JSON && tcategory <= JSONBTYPE_JSONCAST)\n\t{\n\t\t/* work has been done recursively */\n\t\treturn;\n\t}\n\telse if (result->parseState == NULL)\n\t{\n\t\t/* single root scalar */\n\t\tJsonbValue\tva;\n\n\t\tva.type = jbvArray;\n\t\tva.val.array.rawScalar = true;\n\t\tva.val.array.nElems = 1;\n\n\t\tresult->res = pushJsonbValue(&result->parseState, WJB_BEGIN_ARRAY, &va);\n\t\tresult->res = pushJsonbValue(&result->parseState, WJB_ELEM, &jb);\n\t\tresult->res = pushJsonbValue(&result->parseState, WJB_END_ARRAY, NULL);\n\t}\n\telse\n\t{\n\t\tJsonbValue *o = &result->parseState->contVal;\n\n\t\tswitch (o->type)\n\t\t{\n\t\t\tcase jbvArray:\n\t\t\t\tresult->res = pushJsonbValue(&result->parseState, WJB_ELEM, &jb);\n\t\t\t\tbreak;\n\t\t\tcase jbvObject:\n\t\t\t\tresult->res = pushJsonbValue(&result->parseState,\n\t\t\t\t\t\t\t\t\t\t\t key_scalar ? WJB_KEY : WJB_VALUE,\n\t\t\t\t\t\t\t\t\t\t\t &jb);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unexpected parent of nested structure\");\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"miscadmin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline Datum jsonb_from_cstring(char *json, int len);",
            "static size_t checkStringLen(size_t len);",
            "static void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);",
            "static void composite_to_jsonb(Datum composite, JsonbInState *result);",
            "static void array_dim_to_jsonb(JsonbInState *result, int dim, int ndims, int *dims,\n\t\t\t\t   Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid);",
            "static void array_to_jsonb_internal(Datum array, JsonbInState *result);",
            "static void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);",
            "static void datum_to_jsonb(Datum val, bool is_null, JsonbInState *result,\n\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid,\n\t\t\t   bool key_scalar);",
            "static void add_jsonb(Datum val, bool is_null, JsonbInState *result,\n\t\t  Oid val_type, bool key_scalar);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic inline Datum jsonb_from_cstring(char *json, int len);\nstatic size_t checkStringLen(size_t len);\nstatic void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);\nstatic void composite_to_jsonb(Datum composite, JsonbInState *result);\nstatic void array_dim_to_jsonb(JsonbInState *result, int dim, int ndims, int *dims,\n\t\t\t\t   Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid);\nstatic void array_to_jsonb_internal(Datum array, JsonbInState *result);\nstatic void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);\nstatic void datum_to_jsonb(Datum val, bool is_null, JsonbInState *result,\n\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid,\n\t\t\t   bool key_scalar);\nstatic void add_jsonb(Datum val, bool is_null, JsonbInState *result,\n\t\t  Oid val_type, bool key_scalar);\n\nstatic void\ndatum_to_jsonb(Datum val, bool is_null, JsonbInState *result,\n\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid,\n\t\t\t   bool key_scalar)\n{\n\tchar\t   *outputstr;\n\tbool\t\tnumeric_error;\n\tJsonbValue\tjb;\n\tbool\t\tscalar_jsonb = false;\n\n\tcheck_stack_depth();\n\n\t/* Convert val to a JsonbValue in jb (in most cases) */\n\tif (is_null)\n\t{\n\t\tAssert(!key_scalar);\n\t\tjb.type = jbvNull;\n\t}\n\telse if (key_scalar &&\n\t\t\t (tcategory == JSONBTYPE_ARRAY ||\n\t\t\t  tcategory == JSONBTYPE_COMPOSITE ||\n\t\t\t  tcategory == JSONBTYPE_JSON ||\n\t\t\t  tcategory == JSONBTYPE_JSONB ||\n\t\t\t  tcategory == JSONBTYPE_JSONCAST))\n\t{\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"key value must be scalar, not array, composite, or json\")));\n\t}\n\telse\n\t{\n\t\tif (tcategory == JSONBTYPE_JSONCAST)\n\t\t\tval = OidFunctionCall1(outfuncoid, val);\n\n\t\tswitch (tcategory)\n\t\t{\n\t\t\tcase JSONBTYPE_ARRAY:\n\t\t\t\tarray_to_jsonb_internal(val, result);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_COMPOSITE:\n\t\t\t\tcomposite_to_jsonb(val, result);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_BOOL:\n\t\t\t\tif (key_scalar)\n\t\t\t\t{\n\t\t\t\t\toutputstr = DatumGetBool(val) ? \"true\" : \"false\";\n\t\t\t\t\tjb.type = jbvString;\n\t\t\t\t\tjb.val.string.len = strlen(outputstr);\n\t\t\t\t\tjb.val.string.val = outputstr;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tjb.type = jbvBool;\n\t\t\t\t\tjb.val.boolean = DatumGetBool(val);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_NUMERIC:\n\t\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\t\t\t\tif (key_scalar)\n\t\t\t\t{\n\t\t\t\t\t/* always quote keys */\n\t\t\t\t\tjb.type = jbvString;\n\t\t\t\t\tjb.val.string.len = strlen(outputstr);\n\t\t\t\t\tjb.val.string.val = outputstr;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * Make it numeric if it's a valid JSON number, otherwise\n\t\t\t\t\t * a string. Invalid numeric output will always have an\n\t\t\t\t\t * 'N' or 'n' in it (I think).\n\t\t\t\t\t */\n\t\t\t\t\tnumeric_error = (strchr(outputstr, 'N') != NULL ||\n\t\t\t\t\t\t\t\t\t strchr(outputstr, 'n') != NULL);\n\t\t\t\t\tif (!numeric_error)\n\t\t\t\t\t{\n\t\t\t\t\t\tDatum\t\tnumd;\n\n\t\t\t\t\t\tjb.type = jbvNumeric;\n\t\t\t\t\t\tnumd = DirectFunctionCall3(numeric_in,\n\t\t\t\t\t\t\t\t\t\t\t\t   CStringGetDatum(outputstr),\n\t\t\t\t\t\t\t\t\t\t\t\t   ObjectIdGetDatum(InvalidOid),\n\t\t\t\t\t\t\t\t\t\t\t\t   Int32GetDatum(-1));\n\t\t\t\t\t\tjb.val.numeric = DatumGetNumeric(numd);\n\t\t\t\t\t\tpfree(outputstr);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tjb.type = jbvString;\n\t\t\t\t\t\tjb.val.string.len = strlen(outputstr);\n\t\t\t\t\t\tjb.val.string.val = outputstr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_DATE:\n\t\t\t\tjb.type = jbvString;\n\t\t\t\tjb.val.string.val = JsonEncodeDateTime(NULL, val, DATEOID);\n\t\t\t\tjb.val.string.len = strlen(jb.val.string.val);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_TIMESTAMP:\n\t\t\t\tjb.type = jbvString;\n\t\t\t\tjb.val.string.val = JsonEncodeDateTime(NULL, val, TIMESTAMPOID);\n\t\t\t\tjb.val.string.len = strlen(jb.val.string.val);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_TIMESTAMPTZ:\n\t\t\t\tjb.type = jbvString;\n\t\t\t\tjb.val.string.val = JsonEncodeDateTime(NULL, val, TIMESTAMPTZOID);\n\t\t\t\tjb.val.string.len = strlen(jb.val.string.val);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_JSONCAST:\n\t\t\tcase JSONBTYPE_JSON:\n\t\t\t\t{\n\t\t\t\t\t/* parse the json right into the existing result object */\n\t\t\t\t\tJsonLexContext *lex;\n\t\t\t\t\tJsonSemAction sem;\n\t\t\t\t\ttext\t   *json = DatumGetTextPP(val);\n\n\t\t\t\t\tlex = makeJsonLexContext(json, true);\n\n\t\t\t\t\tmemset(&sem, 0, sizeof(sem));\n\n\t\t\t\t\tsem.semstate = (void *) result;\n\n\t\t\t\t\tsem.object_start = jsonb_in_object_start;\n\t\t\t\t\tsem.array_start = jsonb_in_array_start;\n\t\t\t\t\tsem.object_end = jsonb_in_object_end;\n\t\t\t\t\tsem.array_end = jsonb_in_array_end;\n\t\t\t\t\tsem.scalar = jsonb_in_scalar;\n\t\t\t\t\tsem.object_field_start = jsonb_in_object_field_start;\n\n\t\t\t\t\tpg_parse_json(lex, &sem);\n\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_JSONB:\n\t\t\t\t{\n\t\t\t\t\tJsonb\t   *jsonb = DatumGetJsonbP(val);\n\t\t\t\t\tJsonbIterator *it;\n\n\t\t\t\t\tit = JsonbIteratorInit(&jsonb->root);\n\n\t\t\t\t\tif (JB_ROOT_IS_SCALAR(jsonb))\n\t\t\t\t\t{\n\t\t\t\t\t\t(void) JsonbIteratorNext(&it, &jb, true);\n\t\t\t\t\t\tAssert(jb.type == jbvArray);\n\t\t\t\t\t\t(void) JsonbIteratorNext(&it, &jb, true);\n\t\t\t\t\t\tscalar_jsonb = true;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tJsonbIteratorToken type;\n\n\t\t\t\t\t\twhile ((type = JsonbIteratorNext(&it, &jb, false))\n\t\t\t\t\t\t\t   != WJB_DONE)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (type == WJB_END_ARRAY || type == WJB_END_OBJECT ||\n\t\t\t\t\t\t\t\ttype == WJB_BEGIN_ARRAY || type == WJB_BEGIN_OBJECT)\n\t\t\t\t\t\t\t\tresult->res = pushJsonbValue(&result->parseState,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t type, NULL);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tresult->res = pushJsonbValue(&result->parseState,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t type, &jb);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\t\t\t\tjb.type = jbvString;\n\t\t\t\tjb.val.string.len = checkStringLen(strlen(outputstr));\n\t\t\t\tjb.val.string.val = outputstr;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Now insert jb into result, unless we did it recursively */\n\tif (!is_null && !scalar_jsonb &&\n\t\ttcategory >= JSONBTYPE_JSON && tcategory <= JSONBTYPE_JSONCAST)\n\t{\n\t\t/* work has been done recursively */\n\t\treturn;\n\t}\n\telse if (result->parseState == NULL)\n\t{\n\t\t/* single root scalar */\n\t\tJsonbValue\tva;\n\n\t\tva.type = jbvArray;\n\t\tva.val.array.rawScalar = true;\n\t\tva.val.array.nElems = 1;\n\n\t\tresult->res = pushJsonbValue(&result->parseState, WJB_BEGIN_ARRAY, &va);\n\t\tresult->res = pushJsonbValue(&result->parseState, WJB_ELEM, &jb);\n\t\tresult->res = pushJsonbValue(&result->parseState, WJB_END_ARRAY, NULL);\n\t}\n\telse\n\t{\n\t\tJsonbValue *o = &result->parseState->contVal;\n\n\t\tswitch (o->type)\n\t\t{\n\t\t\tcase jbvArray:\n\t\t\t\tresult->res = pushJsonbValue(&result->parseState, WJB_ELEM, &jb);\n\t\t\t\tbreak;\n\t\t\tcase jbvObject:\n\t\t\t\tresult->res = pushJsonbValue(&result->parseState,\n\t\t\t\t\t\t\t\t\t\t\t key_scalar ? WJB_KEY : WJB_VALUE,\n\t\t\t\t\t\t\t\t\t\t\t &jb);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unexpected parent of nested structure\");\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&result",
            "0",
            "sizeof(JsonbInState)"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jsonb_categorize_type",
          "args": [
            "val_type",
            "&tcategory",
            "&outfuncoid"
          ],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "jsonb_categorize_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
          "lines": "593-690",
          "snippet": "static void\njsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid)\n{\n\tbool\t\ttypisvarlena;\n\n\t/* Look through any domain */\n\ttypoid = getBaseType(typoid);\n\n\t*outfuncoid = InvalidOid;\n\n\t/*\n\t * We need to get the output function for everything except date and\n\t * timestamp types, booleans, array and composite types, json and jsonb,\n\t * and non-builtin types where there's a cast to json. In this last case\n\t * we return the oid of the cast function instead.\n\t */\n\n\tswitch (typoid)\n\t{\n\t\tcase BOOLOID:\n\t\t\t*tcategory = JSONBTYPE_BOOL;\n\t\t\tbreak;\n\n\t\tcase INT2OID:\n\t\tcase INT4OID:\n\t\tcase INT8OID:\n\t\tcase FLOAT4OID:\n\t\tcase FLOAT8OID:\n\t\tcase NUMERICOID:\n\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t*tcategory = JSONBTYPE_NUMERIC;\n\t\t\tbreak;\n\n\t\tcase DATEOID:\n\t\t\t*tcategory = JSONBTYPE_DATE;\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPOID:\n\t\t\t*tcategory = JSONBTYPE_TIMESTAMP;\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPTZOID:\n\t\t\t*tcategory = JSONBTYPE_TIMESTAMPTZ;\n\t\t\tbreak;\n\n\t\tcase JSONBOID:\n\t\t\t*tcategory = JSONBTYPE_JSONB;\n\t\t\tbreak;\n\n\t\tcase JSONOID:\n\t\t\t*tcategory = JSONBTYPE_JSON;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* Check for arrays and composites */\n\t\t\tif (OidIsValid(get_element_type(typoid)) || typoid == ANYARRAYOID\n\t\t\t\t|| typoid == RECORDARRAYOID)\n\t\t\t\t*tcategory = JSONBTYPE_ARRAY;\n\t\t\telse if (type_is_rowtype(typoid))\t/* includes RECORDOID */\n\t\t\t\t*tcategory = JSONBTYPE_COMPOSITE;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* It's probably the general case ... */\n\t\t\t\t*tcategory = JSONBTYPE_OTHER;\n\n\t\t\t\t/*\n\t\t\t\t * but first let's look for a cast to json (note: not to\n\t\t\t\t * jsonb) if it's not built-in.\n\t\t\t\t */\n\t\t\t\tif (typoid >= FirstNormalObjectId)\n\t\t\t\t{\n\t\t\t\t\tOid\t\t\tcastfunc;\n\t\t\t\t\tCoercionPathType ctype;\n\n\t\t\t\t\tctype = find_coercion_pathway(JSONOID, typoid,\n\t\t\t\t\t\t\t\t\t\t\t\t  COERCION_EXPLICIT, &castfunc);\n\t\t\t\t\tif (ctype == COERCION_PATH_FUNC && OidIsValid(castfunc))\n\t\t\t\t\t{\n\t\t\t\t\t\t*tcategory = JSONBTYPE_JSONCAST;\n\t\t\t\t\t\t*outfuncoid = castfunc;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* not a cast type, so just get the usual output func */\n\t\t\t\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* any other builtin type */\n\t\t\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"miscadmin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);",
            "static void array_dim_to_jsonb(JsonbInState *result, int dim, int ndims, int *dims,\n\t\t\t\t   Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid);",
            "static void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);\nstatic void array_dim_to_jsonb(JsonbInState *result, int dim, int ndims, int *dims,\n\t\t\t\t   Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid);\nstatic void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);\n\nstatic void\njsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid)\n{\n\tbool\t\ttypisvarlena;\n\n\t/* Look through any domain */\n\ttypoid = getBaseType(typoid);\n\n\t*outfuncoid = InvalidOid;\n\n\t/*\n\t * We need to get the output function for everything except date and\n\t * timestamp types, booleans, array and composite types, json and jsonb,\n\t * and non-builtin types where there's a cast to json. In this last case\n\t * we return the oid of the cast function instead.\n\t */\n\n\tswitch (typoid)\n\t{\n\t\tcase BOOLOID:\n\t\t\t*tcategory = JSONBTYPE_BOOL;\n\t\t\tbreak;\n\n\t\tcase INT2OID:\n\t\tcase INT4OID:\n\t\tcase INT8OID:\n\t\tcase FLOAT4OID:\n\t\tcase FLOAT8OID:\n\t\tcase NUMERICOID:\n\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t*tcategory = JSONBTYPE_NUMERIC;\n\t\t\tbreak;\n\n\t\tcase DATEOID:\n\t\t\t*tcategory = JSONBTYPE_DATE;\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPOID:\n\t\t\t*tcategory = JSONBTYPE_TIMESTAMP;\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPTZOID:\n\t\t\t*tcategory = JSONBTYPE_TIMESTAMPTZ;\n\t\t\tbreak;\n\n\t\tcase JSONBOID:\n\t\t\t*tcategory = JSONBTYPE_JSONB;\n\t\t\tbreak;\n\n\t\tcase JSONOID:\n\t\t\t*tcategory = JSONBTYPE_JSON;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* Check for arrays and composites */\n\t\t\tif (OidIsValid(get_element_type(typoid)) || typoid == ANYARRAYOID\n\t\t\t\t|| typoid == RECORDARRAYOID)\n\t\t\t\t*tcategory = JSONBTYPE_ARRAY;\n\t\t\telse if (type_is_rowtype(typoid))\t/* includes RECORDOID */\n\t\t\t\t*tcategory = JSONBTYPE_COMPOSITE;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* It's probably the general case ... */\n\t\t\t\t*tcategory = JSONBTYPE_OTHER;\n\n\t\t\t\t/*\n\t\t\t\t * but first let's look for a cast to json (note: not to\n\t\t\t\t * jsonb) if it's not built-in.\n\t\t\t\t */\n\t\t\t\tif (typoid >= FirstNormalObjectId)\n\t\t\t\t{\n\t\t\t\t\tOid\t\t\tcastfunc;\n\t\t\t\t\tCoercionPathType ctype;\n\n\t\t\t\t\tctype = find_coercion_pathway(JSONOID, typoid,\n\t\t\t\t\t\t\t\t\t\t\t\t  COERCION_EXPLICIT, &castfunc);\n\t\t\t\t\tif (ctype == COERCION_PATH_FUNC && OidIsValid(castfunc))\n\t\t\t\t\t{\n\t\t\t\t\t\t*tcategory = JSONBTYPE_JSONCAST;\n\t\t\t\t\t\t*outfuncoid = castfunc;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* not a cast type, so just get the usual output func */\n\t\t\t\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* any other builtin type */\n\t\t\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"could not determine input data type\"))"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not determine input data type\""
          ],
          "line": 1112
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 1111
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fn_expr_argtype",
          "args": [
            "fcinfo->flinfo",
            "0"
          ],
          "line": 1104
        },
        "resolved": true,
        "details": {
          "function_name": "get_fn_expr_argtype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1994-2005",
          "snippet": "Oid\nget_fn_expr_argtype(FmgrInfo *flinfo, int argnum)\n{\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn InvalidOid;\n\n\treturn get_call_expr_argtype(flinfo->fn_expr, argnum);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nOid\nget_fn_expr_argtype(FmgrInfo *flinfo, int argnum)\n{\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn InvalidOid;\n\n\treturn get_call_expr_argtype(flinfo->fn_expr, argnum);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "0"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);\nstatic void composite_to_jsonb(Datum composite, JsonbInState *result);\nstatic void array_dim_to_jsonb(JsonbInState *result, int dim, int ndims, int *dims,\n\t\t\t\t   Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid);\nstatic void array_to_jsonb_internal(Datum array, JsonbInState *result);\nstatic void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);\n\nDatum\nto_jsonb(PG_FUNCTION_ARGS)\n{\n\tDatum\t\tval = PG_GETARG_DATUM(0);\n\tOid\t\t\tval_type = get_fn_expr_argtype(fcinfo->flinfo, 0);\n\tJsonbInState result;\n\tJsonbTypeCategory tcategory;\n\tOid\t\t\toutfuncoid;\n\n\tif (val_type == InvalidOid)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"could not determine input data type\")));\n\n\tjsonb_categorize_type(val_type,\n\t\t\t\t\t\t  &tcategory, &outfuncoid);\n\n\tmemset(&result, 0, sizeof(JsonbInState));\n\n\tdatum_to_jsonb(val, false, &result, tcategory, outfuncoid, false);\n\n\tPG_RETURN_POINTER(JsonbValueToJsonb(result.res));\n}"
  },
  {
    "function_name": "add_jsonb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
    "lines": "1073-1095",
    "snippet": "static void\nadd_jsonb(Datum val, bool is_null, JsonbInState *result,\n\t\t  Oid val_type, bool key_scalar)\n{\n\tJsonbTypeCategory tcategory;\n\tOid\t\t\toutfuncoid;\n\n\tif (val_type == InvalidOid)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"could not determine input data type\")));\n\n\tif (is_null)\n\t{\n\t\ttcategory = JSONBTYPE_NULL;\n\t\toutfuncoid = InvalidOid;\n\t}\n\telse\n\t\tjsonb_categorize_type(val_type,\n\t\t\t\t\t\t\t  &tcategory, &outfuncoid);\n\n\tdatum_to_jsonb(val, is_null, result, tcategory, outfuncoid, key_scalar);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"miscadmin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);",
      "static void composite_to_jsonb(Datum composite, JsonbInState *result);",
      "static void array_dim_to_jsonb(JsonbInState *result, int dim, int ndims, int *dims,\n\t\t\t\t   Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid);",
      "static void array_to_jsonb_internal(Datum array, JsonbInState *result);",
      "static void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);",
      "static void datum_to_jsonb(Datum val, bool is_null, JsonbInState *result,\n\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid,\n\t\t\t   bool key_scalar);",
      "static void add_jsonb(Datum val, bool is_null, JsonbInState *result,\n\t\t  Oid val_type, bool key_scalar);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "datum_to_jsonb",
          "args": [
            "val",
            "is_null",
            "result",
            "tcategory",
            "outfuncoid",
            "key_scalar"
          ],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "datum_to_jsonb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
          "lines": "701-914",
          "snippet": "static void\ndatum_to_jsonb(Datum val, bool is_null, JsonbInState *result,\n\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid,\n\t\t\t   bool key_scalar)\n{\n\tchar\t   *outputstr;\n\tbool\t\tnumeric_error;\n\tJsonbValue\tjb;\n\tbool\t\tscalar_jsonb = false;\n\n\tcheck_stack_depth();\n\n\t/* Convert val to a JsonbValue in jb (in most cases) */\n\tif (is_null)\n\t{\n\t\tAssert(!key_scalar);\n\t\tjb.type = jbvNull;\n\t}\n\telse if (key_scalar &&\n\t\t\t (tcategory == JSONBTYPE_ARRAY ||\n\t\t\t  tcategory == JSONBTYPE_COMPOSITE ||\n\t\t\t  tcategory == JSONBTYPE_JSON ||\n\t\t\t  tcategory == JSONBTYPE_JSONB ||\n\t\t\t  tcategory == JSONBTYPE_JSONCAST))\n\t{\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"key value must be scalar, not array, composite, or json\")));\n\t}\n\telse\n\t{\n\t\tif (tcategory == JSONBTYPE_JSONCAST)\n\t\t\tval = OidFunctionCall1(outfuncoid, val);\n\n\t\tswitch (tcategory)\n\t\t{\n\t\t\tcase JSONBTYPE_ARRAY:\n\t\t\t\tarray_to_jsonb_internal(val, result);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_COMPOSITE:\n\t\t\t\tcomposite_to_jsonb(val, result);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_BOOL:\n\t\t\t\tif (key_scalar)\n\t\t\t\t{\n\t\t\t\t\toutputstr = DatumGetBool(val) ? \"true\" : \"false\";\n\t\t\t\t\tjb.type = jbvString;\n\t\t\t\t\tjb.val.string.len = strlen(outputstr);\n\t\t\t\t\tjb.val.string.val = outputstr;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tjb.type = jbvBool;\n\t\t\t\t\tjb.val.boolean = DatumGetBool(val);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_NUMERIC:\n\t\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\t\t\t\tif (key_scalar)\n\t\t\t\t{\n\t\t\t\t\t/* always quote keys */\n\t\t\t\t\tjb.type = jbvString;\n\t\t\t\t\tjb.val.string.len = strlen(outputstr);\n\t\t\t\t\tjb.val.string.val = outputstr;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * Make it numeric if it's a valid JSON number, otherwise\n\t\t\t\t\t * a string. Invalid numeric output will always have an\n\t\t\t\t\t * 'N' or 'n' in it (I think).\n\t\t\t\t\t */\n\t\t\t\t\tnumeric_error = (strchr(outputstr, 'N') != NULL ||\n\t\t\t\t\t\t\t\t\t strchr(outputstr, 'n') != NULL);\n\t\t\t\t\tif (!numeric_error)\n\t\t\t\t\t{\n\t\t\t\t\t\tDatum\t\tnumd;\n\n\t\t\t\t\t\tjb.type = jbvNumeric;\n\t\t\t\t\t\tnumd = DirectFunctionCall3(numeric_in,\n\t\t\t\t\t\t\t\t\t\t\t\t   CStringGetDatum(outputstr),\n\t\t\t\t\t\t\t\t\t\t\t\t   ObjectIdGetDatum(InvalidOid),\n\t\t\t\t\t\t\t\t\t\t\t\t   Int32GetDatum(-1));\n\t\t\t\t\t\tjb.val.numeric = DatumGetNumeric(numd);\n\t\t\t\t\t\tpfree(outputstr);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tjb.type = jbvString;\n\t\t\t\t\t\tjb.val.string.len = strlen(outputstr);\n\t\t\t\t\t\tjb.val.string.val = outputstr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_DATE:\n\t\t\t\tjb.type = jbvString;\n\t\t\t\tjb.val.string.val = JsonEncodeDateTime(NULL, val, DATEOID);\n\t\t\t\tjb.val.string.len = strlen(jb.val.string.val);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_TIMESTAMP:\n\t\t\t\tjb.type = jbvString;\n\t\t\t\tjb.val.string.val = JsonEncodeDateTime(NULL, val, TIMESTAMPOID);\n\t\t\t\tjb.val.string.len = strlen(jb.val.string.val);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_TIMESTAMPTZ:\n\t\t\t\tjb.type = jbvString;\n\t\t\t\tjb.val.string.val = JsonEncodeDateTime(NULL, val, TIMESTAMPTZOID);\n\t\t\t\tjb.val.string.len = strlen(jb.val.string.val);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_JSONCAST:\n\t\t\tcase JSONBTYPE_JSON:\n\t\t\t\t{\n\t\t\t\t\t/* parse the json right into the existing result object */\n\t\t\t\t\tJsonLexContext *lex;\n\t\t\t\t\tJsonSemAction sem;\n\t\t\t\t\ttext\t   *json = DatumGetTextPP(val);\n\n\t\t\t\t\tlex = makeJsonLexContext(json, true);\n\n\t\t\t\t\tmemset(&sem, 0, sizeof(sem));\n\n\t\t\t\t\tsem.semstate = (void *) result;\n\n\t\t\t\t\tsem.object_start = jsonb_in_object_start;\n\t\t\t\t\tsem.array_start = jsonb_in_array_start;\n\t\t\t\t\tsem.object_end = jsonb_in_object_end;\n\t\t\t\t\tsem.array_end = jsonb_in_array_end;\n\t\t\t\t\tsem.scalar = jsonb_in_scalar;\n\t\t\t\t\tsem.object_field_start = jsonb_in_object_field_start;\n\n\t\t\t\t\tpg_parse_json(lex, &sem);\n\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_JSONB:\n\t\t\t\t{\n\t\t\t\t\tJsonb\t   *jsonb = DatumGetJsonbP(val);\n\t\t\t\t\tJsonbIterator *it;\n\n\t\t\t\t\tit = JsonbIteratorInit(&jsonb->root);\n\n\t\t\t\t\tif (JB_ROOT_IS_SCALAR(jsonb))\n\t\t\t\t\t{\n\t\t\t\t\t\t(void) JsonbIteratorNext(&it, &jb, true);\n\t\t\t\t\t\tAssert(jb.type == jbvArray);\n\t\t\t\t\t\t(void) JsonbIteratorNext(&it, &jb, true);\n\t\t\t\t\t\tscalar_jsonb = true;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tJsonbIteratorToken type;\n\n\t\t\t\t\t\twhile ((type = JsonbIteratorNext(&it, &jb, false))\n\t\t\t\t\t\t\t   != WJB_DONE)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (type == WJB_END_ARRAY || type == WJB_END_OBJECT ||\n\t\t\t\t\t\t\t\ttype == WJB_BEGIN_ARRAY || type == WJB_BEGIN_OBJECT)\n\t\t\t\t\t\t\t\tresult->res = pushJsonbValue(&result->parseState,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t type, NULL);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tresult->res = pushJsonbValue(&result->parseState,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t type, &jb);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\t\t\t\tjb.type = jbvString;\n\t\t\t\tjb.val.string.len = checkStringLen(strlen(outputstr));\n\t\t\t\tjb.val.string.val = outputstr;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Now insert jb into result, unless we did it recursively */\n\tif (!is_null && !scalar_jsonb &&\n\t\ttcategory >= JSONBTYPE_JSON && tcategory <= JSONBTYPE_JSONCAST)\n\t{\n\t\t/* work has been done recursively */\n\t\treturn;\n\t}\n\telse if (result->parseState == NULL)\n\t{\n\t\t/* single root scalar */\n\t\tJsonbValue\tva;\n\n\t\tva.type = jbvArray;\n\t\tva.val.array.rawScalar = true;\n\t\tva.val.array.nElems = 1;\n\n\t\tresult->res = pushJsonbValue(&result->parseState, WJB_BEGIN_ARRAY, &va);\n\t\tresult->res = pushJsonbValue(&result->parseState, WJB_ELEM, &jb);\n\t\tresult->res = pushJsonbValue(&result->parseState, WJB_END_ARRAY, NULL);\n\t}\n\telse\n\t{\n\t\tJsonbValue *o = &result->parseState->contVal;\n\n\t\tswitch (o->type)\n\t\t{\n\t\t\tcase jbvArray:\n\t\t\t\tresult->res = pushJsonbValue(&result->parseState, WJB_ELEM, &jb);\n\t\t\t\tbreak;\n\t\t\tcase jbvObject:\n\t\t\t\tresult->res = pushJsonbValue(&result->parseState,\n\t\t\t\t\t\t\t\t\t\t\t key_scalar ? WJB_KEY : WJB_VALUE,\n\t\t\t\t\t\t\t\t\t\t\t &jb);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unexpected parent of nested structure\");\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"miscadmin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline Datum jsonb_from_cstring(char *json, int len);",
            "static size_t checkStringLen(size_t len);",
            "static void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);",
            "static void composite_to_jsonb(Datum composite, JsonbInState *result);",
            "static void array_dim_to_jsonb(JsonbInState *result, int dim, int ndims, int *dims,\n\t\t\t\t   Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid);",
            "static void array_to_jsonb_internal(Datum array, JsonbInState *result);",
            "static void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);",
            "static void datum_to_jsonb(Datum val, bool is_null, JsonbInState *result,\n\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid,\n\t\t\t   bool key_scalar);",
            "static void add_jsonb(Datum val, bool is_null, JsonbInState *result,\n\t\t  Oid val_type, bool key_scalar);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic inline Datum jsonb_from_cstring(char *json, int len);\nstatic size_t checkStringLen(size_t len);\nstatic void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);\nstatic void composite_to_jsonb(Datum composite, JsonbInState *result);\nstatic void array_dim_to_jsonb(JsonbInState *result, int dim, int ndims, int *dims,\n\t\t\t\t   Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid);\nstatic void array_to_jsonb_internal(Datum array, JsonbInState *result);\nstatic void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);\nstatic void datum_to_jsonb(Datum val, bool is_null, JsonbInState *result,\n\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid,\n\t\t\t   bool key_scalar);\nstatic void add_jsonb(Datum val, bool is_null, JsonbInState *result,\n\t\t  Oid val_type, bool key_scalar);\n\nstatic void\ndatum_to_jsonb(Datum val, bool is_null, JsonbInState *result,\n\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid,\n\t\t\t   bool key_scalar)\n{\n\tchar\t   *outputstr;\n\tbool\t\tnumeric_error;\n\tJsonbValue\tjb;\n\tbool\t\tscalar_jsonb = false;\n\n\tcheck_stack_depth();\n\n\t/* Convert val to a JsonbValue in jb (in most cases) */\n\tif (is_null)\n\t{\n\t\tAssert(!key_scalar);\n\t\tjb.type = jbvNull;\n\t}\n\telse if (key_scalar &&\n\t\t\t (tcategory == JSONBTYPE_ARRAY ||\n\t\t\t  tcategory == JSONBTYPE_COMPOSITE ||\n\t\t\t  tcategory == JSONBTYPE_JSON ||\n\t\t\t  tcategory == JSONBTYPE_JSONB ||\n\t\t\t  tcategory == JSONBTYPE_JSONCAST))\n\t{\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"key value must be scalar, not array, composite, or json\")));\n\t}\n\telse\n\t{\n\t\tif (tcategory == JSONBTYPE_JSONCAST)\n\t\t\tval = OidFunctionCall1(outfuncoid, val);\n\n\t\tswitch (tcategory)\n\t\t{\n\t\t\tcase JSONBTYPE_ARRAY:\n\t\t\t\tarray_to_jsonb_internal(val, result);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_COMPOSITE:\n\t\t\t\tcomposite_to_jsonb(val, result);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_BOOL:\n\t\t\t\tif (key_scalar)\n\t\t\t\t{\n\t\t\t\t\toutputstr = DatumGetBool(val) ? \"true\" : \"false\";\n\t\t\t\t\tjb.type = jbvString;\n\t\t\t\t\tjb.val.string.len = strlen(outputstr);\n\t\t\t\t\tjb.val.string.val = outputstr;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tjb.type = jbvBool;\n\t\t\t\t\tjb.val.boolean = DatumGetBool(val);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_NUMERIC:\n\t\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\t\t\t\tif (key_scalar)\n\t\t\t\t{\n\t\t\t\t\t/* always quote keys */\n\t\t\t\t\tjb.type = jbvString;\n\t\t\t\t\tjb.val.string.len = strlen(outputstr);\n\t\t\t\t\tjb.val.string.val = outputstr;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * Make it numeric if it's a valid JSON number, otherwise\n\t\t\t\t\t * a string. Invalid numeric output will always have an\n\t\t\t\t\t * 'N' or 'n' in it (I think).\n\t\t\t\t\t */\n\t\t\t\t\tnumeric_error = (strchr(outputstr, 'N') != NULL ||\n\t\t\t\t\t\t\t\t\t strchr(outputstr, 'n') != NULL);\n\t\t\t\t\tif (!numeric_error)\n\t\t\t\t\t{\n\t\t\t\t\t\tDatum\t\tnumd;\n\n\t\t\t\t\t\tjb.type = jbvNumeric;\n\t\t\t\t\t\tnumd = DirectFunctionCall3(numeric_in,\n\t\t\t\t\t\t\t\t\t\t\t\t   CStringGetDatum(outputstr),\n\t\t\t\t\t\t\t\t\t\t\t\t   ObjectIdGetDatum(InvalidOid),\n\t\t\t\t\t\t\t\t\t\t\t\t   Int32GetDatum(-1));\n\t\t\t\t\t\tjb.val.numeric = DatumGetNumeric(numd);\n\t\t\t\t\t\tpfree(outputstr);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tjb.type = jbvString;\n\t\t\t\t\t\tjb.val.string.len = strlen(outputstr);\n\t\t\t\t\t\tjb.val.string.val = outputstr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_DATE:\n\t\t\t\tjb.type = jbvString;\n\t\t\t\tjb.val.string.val = JsonEncodeDateTime(NULL, val, DATEOID);\n\t\t\t\tjb.val.string.len = strlen(jb.val.string.val);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_TIMESTAMP:\n\t\t\t\tjb.type = jbvString;\n\t\t\t\tjb.val.string.val = JsonEncodeDateTime(NULL, val, TIMESTAMPOID);\n\t\t\t\tjb.val.string.len = strlen(jb.val.string.val);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_TIMESTAMPTZ:\n\t\t\t\tjb.type = jbvString;\n\t\t\t\tjb.val.string.val = JsonEncodeDateTime(NULL, val, TIMESTAMPTZOID);\n\t\t\t\tjb.val.string.len = strlen(jb.val.string.val);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_JSONCAST:\n\t\t\tcase JSONBTYPE_JSON:\n\t\t\t\t{\n\t\t\t\t\t/* parse the json right into the existing result object */\n\t\t\t\t\tJsonLexContext *lex;\n\t\t\t\t\tJsonSemAction sem;\n\t\t\t\t\ttext\t   *json = DatumGetTextPP(val);\n\n\t\t\t\t\tlex = makeJsonLexContext(json, true);\n\n\t\t\t\t\tmemset(&sem, 0, sizeof(sem));\n\n\t\t\t\t\tsem.semstate = (void *) result;\n\n\t\t\t\t\tsem.object_start = jsonb_in_object_start;\n\t\t\t\t\tsem.array_start = jsonb_in_array_start;\n\t\t\t\t\tsem.object_end = jsonb_in_object_end;\n\t\t\t\t\tsem.array_end = jsonb_in_array_end;\n\t\t\t\t\tsem.scalar = jsonb_in_scalar;\n\t\t\t\t\tsem.object_field_start = jsonb_in_object_field_start;\n\n\t\t\t\t\tpg_parse_json(lex, &sem);\n\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_JSONB:\n\t\t\t\t{\n\t\t\t\t\tJsonb\t   *jsonb = DatumGetJsonbP(val);\n\t\t\t\t\tJsonbIterator *it;\n\n\t\t\t\t\tit = JsonbIteratorInit(&jsonb->root);\n\n\t\t\t\t\tif (JB_ROOT_IS_SCALAR(jsonb))\n\t\t\t\t\t{\n\t\t\t\t\t\t(void) JsonbIteratorNext(&it, &jb, true);\n\t\t\t\t\t\tAssert(jb.type == jbvArray);\n\t\t\t\t\t\t(void) JsonbIteratorNext(&it, &jb, true);\n\t\t\t\t\t\tscalar_jsonb = true;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tJsonbIteratorToken type;\n\n\t\t\t\t\t\twhile ((type = JsonbIteratorNext(&it, &jb, false))\n\t\t\t\t\t\t\t   != WJB_DONE)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (type == WJB_END_ARRAY || type == WJB_END_OBJECT ||\n\t\t\t\t\t\t\t\ttype == WJB_BEGIN_ARRAY || type == WJB_BEGIN_OBJECT)\n\t\t\t\t\t\t\t\tresult->res = pushJsonbValue(&result->parseState,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t type, NULL);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tresult->res = pushJsonbValue(&result->parseState,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t type, &jb);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\t\t\t\tjb.type = jbvString;\n\t\t\t\tjb.val.string.len = checkStringLen(strlen(outputstr));\n\t\t\t\tjb.val.string.val = outputstr;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Now insert jb into result, unless we did it recursively */\n\tif (!is_null && !scalar_jsonb &&\n\t\ttcategory >= JSONBTYPE_JSON && tcategory <= JSONBTYPE_JSONCAST)\n\t{\n\t\t/* work has been done recursively */\n\t\treturn;\n\t}\n\telse if (result->parseState == NULL)\n\t{\n\t\t/* single root scalar */\n\t\tJsonbValue\tva;\n\n\t\tva.type = jbvArray;\n\t\tva.val.array.rawScalar = true;\n\t\tva.val.array.nElems = 1;\n\n\t\tresult->res = pushJsonbValue(&result->parseState, WJB_BEGIN_ARRAY, &va);\n\t\tresult->res = pushJsonbValue(&result->parseState, WJB_ELEM, &jb);\n\t\tresult->res = pushJsonbValue(&result->parseState, WJB_END_ARRAY, NULL);\n\t}\n\telse\n\t{\n\t\tJsonbValue *o = &result->parseState->contVal;\n\n\t\tswitch (o->type)\n\t\t{\n\t\t\tcase jbvArray:\n\t\t\t\tresult->res = pushJsonbValue(&result->parseState, WJB_ELEM, &jb);\n\t\t\t\tbreak;\n\t\t\tcase jbvObject:\n\t\t\t\tresult->res = pushJsonbValue(&result->parseState,\n\t\t\t\t\t\t\t\t\t\t\t key_scalar ? WJB_KEY : WJB_VALUE,\n\t\t\t\t\t\t\t\t\t\t\t &jb);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unexpected parent of nested structure\");\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "jsonb_categorize_type",
          "args": [
            "val_type",
            "&tcategory",
            "&outfuncoid"
          ],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "jsonb_categorize_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
          "lines": "593-690",
          "snippet": "static void\njsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid)\n{\n\tbool\t\ttypisvarlena;\n\n\t/* Look through any domain */\n\ttypoid = getBaseType(typoid);\n\n\t*outfuncoid = InvalidOid;\n\n\t/*\n\t * We need to get the output function for everything except date and\n\t * timestamp types, booleans, array and composite types, json and jsonb,\n\t * and non-builtin types where there's a cast to json. In this last case\n\t * we return the oid of the cast function instead.\n\t */\n\n\tswitch (typoid)\n\t{\n\t\tcase BOOLOID:\n\t\t\t*tcategory = JSONBTYPE_BOOL;\n\t\t\tbreak;\n\n\t\tcase INT2OID:\n\t\tcase INT4OID:\n\t\tcase INT8OID:\n\t\tcase FLOAT4OID:\n\t\tcase FLOAT8OID:\n\t\tcase NUMERICOID:\n\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t*tcategory = JSONBTYPE_NUMERIC;\n\t\t\tbreak;\n\n\t\tcase DATEOID:\n\t\t\t*tcategory = JSONBTYPE_DATE;\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPOID:\n\t\t\t*tcategory = JSONBTYPE_TIMESTAMP;\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPTZOID:\n\t\t\t*tcategory = JSONBTYPE_TIMESTAMPTZ;\n\t\t\tbreak;\n\n\t\tcase JSONBOID:\n\t\t\t*tcategory = JSONBTYPE_JSONB;\n\t\t\tbreak;\n\n\t\tcase JSONOID:\n\t\t\t*tcategory = JSONBTYPE_JSON;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* Check for arrays and composites */\n\t\t\tif (OidIsValid(get_element_type(typoid)) || typoid == ANYARRAYOID\n\t\t\t\t|| typoid == RECORDARRAYOID)\n\t\t\t\t*tcategory = JSONBTYPE_ARRAY;\n\t\t\telse if (type_is_rowtype(typoid))\t/* includes RECORDOID */\n\t\t\t\t*tcategory = JSONBTYPE_COMPOSITE;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* It's probably the general case ... */\n\t\t\t\t*tcategory = JSONBTYPE_OTHER;\n\n\t\t\t\t/*\n\t\t\t\t * but first let's look for a cast to json (note: not to\n\t\t\t\t * jsonb) if it's not built-in.\n\t\t\t\t */\n\t\t\t\tif (typoid >= FirstNormalObjectId)\n\t\t\t\t{\n\t\t\t\t\tOid\t\t\tcastfunc;\n\t\t\t\t\tCoercionPathType ctype;\n\n\t\t\t\t\tctype = find_coercion_pathway(JSONOID, typoid,\n\t\t\t\t\t\t\t\t\t\t\t\t  COERCION_EXPLICIT, &castfunc);\n\t\t\t\t\tif (ctype == COERCION_PATH_FUNC && OidIsValid(castfunc))\n\t\t\t\t\t{\n\t\t\t\t\t\t*tcategory = JSONBTYPE_JSONCAST;\n\t\t\t\t\t\t*outfuncoid = castfunc;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* not a cast type, so just get the usual output func */\n\t\t\t\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* any other builtin type */\n\t\t\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"miscadmin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);",
            "static void array_dim_to_jsonb(JsonbInState *result, int dim, int ndims, int *dims,\n\t\t\t\t   Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid);",
            "static void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);\nstatic void array_dim_to_jsonb(JsonbInState *result, int dim, int ndims, int *dims,\n\t\t\t\t   Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid);\nstatic void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);\n\nstatic void\njsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid)\n{\n\tbool\t\ttypisvarlena;\n\n\t/* Look through any domain */\n\ttypoid = getBaseType(typoid);\n\n\t*outfuncoid = InvalidOid;\n\n\t/*\n\t * We need to get the output function for everything except date and\n\t * timestamp types, booleans, array and composite types, json and jsonb,\n\t * and non-builtin types where there's a cast to json. In this last case\n\t * we return the oid of the cast function instead.\n\t */\n\n\tswitch (typoid)\n\t{\n\t\tcase BOOLOID:\n\t\t\t*tcategory = JSONBTYPE_BOOL;\n\t\t\tbreak;\n\n\t\tcase INT2OID:\n\t\tcase INT4OID:\n\t\tcase INT8OID:\n\t\tcase FLOAT4OID:\n\t\tcase FLOAT8OID:\n\t\tcase NUMERICOID:\n\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t*tcategory = JSONBTYPE_NUMERIC;\n\t\t\tbreak;\n\n\t\tcase DATEOID:\n\t\t\t*tcategory = JSONBTYPE_DATE;\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPOID:\n\t\t\t*tcategory = JSONBTYPE_TIMESTAMP;\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPTZOID:\n\t\t\t*tcategory = JSONBTYPE_TIMESTAMPTZ;\n\t\t\tbreak;\n\n\t\tcase JSONBOID:\n\t\t\t*tcategory = JSONBTYPE_JSONB;\n\t\t\tbreak;\n\n\t\tcase JSONOID:\n\t\t\t*tcategory = JSONBTYPE_JSON;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* Check for arrays and composites */\n\t\t\tif (OidIsValid(get_element_type(typoid)) || typoid == ANYARRAYOID\n\t\t\t\t|| typoid == RECORDARRAYOID)\n\t\t\t\t*tcategory = JSONBTYPE_ARRAY;\n\t\t\telse if (type_is_rowtype(typoid))\t/* includes RECORDOID */\n\t\t\t\t*tcategory = JSONBTYPE_COMPOSITE;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* It's probably the general case ... */\n\t\t\t\t*tcategory = JSONBTYPE_OTHER;\n\n\t\t\t\t/*\n\t\t\t\t * but first let's look for a cast to json (note: not to\n\t\t\t\t * jsonb) if it's not built-in.\n\t\t\t\t */\n\t\t\t\tif (typoid >= FirstNormalObjectId)\n\t\t\t\t{\n\t\t\t\t\tOid\t\t\tcastfunc;\n\t\t\t\t\tCoercionPathType ctype;\n\n\t\t\t\t\tctype = find_coercion_pathway(JSONOID, typoid,\n\t\t\t\t\t\t\t\t\t\t\t\t  COERCION_EXPLICIT, &castfunc);\n\t\t\t\t\tif (ctype == COERCION_PATH_FUNC && OidIsValid(castfunc))\n\t\t\t\t\t{\n\t\t\t\t\t\t*tcategory = JSONBTYPE_JSONCAST;\n\t\t\t\t\t\t*outfuncoid = castfunc;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* not a cast type, so just get the usual output func */\n\t\t\t\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* any other builtin type */\n\t\t\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"could not determine input data type\"))"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not determine input data type\""
          ],
          "line": 1083
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);\nstatic void composite_to_jsonb(Datum composite, JsonbInState *result);\nstatic void array_dim_to_jsonb(JsonbInState *result, int dim, int ndims, int *dims,\n\t\t\t\t   Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid);\nstatic void array_to_jsonb_internal(Datum array, JsonbInState *result);\nstatic void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);\nstatic void datum_to_jsonb(Datum val, bool is_null, JsonbInState *result,\n\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid,\n\t\t\t   bool key_scalar);\nstatic void add_jsonb(Datum val, bool is_null, JsonbInState *result,\n\t\t  Oid val_type, bool key_scalar);\n\nstatic void\nadd_jsonb(Datum val, bool is_null, JsonbInState *result,\n\t\t  Oid val_type, bool key_scalar)\n{\n\tJsonbTypeCategory tcategory;\n\tOid\t\t\toutfuncoid;\n\n\tif (val_type == InvalidOid)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"could not determine input data type\")));\n\n\tif (is_null)\n\t{\n\t\ttcategory = JSONBTYPE_NULL;\n\t\toutfuncoid = InvalidOid;\n\t}\n\telse\n\t\tjsonb_categorize_type(val_type,\n\t\t\t\t\t\t\t  &tcategory, &outfuncoid);\n\n\tdatum_to_jsonb(val, is_null, result, tcategory, outfuncoid, key_scalar);\n}"
  },
  {
    "function_name": "composite_to_jsonb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
    "lines": "1001-1063",
    "snippet": "static void\ncomposite_to_jsonb(Datum composite, JsonbInState *result)\n{\n\tHeapTupleHeader td;\n\tOid\t\t\ttupType;\n\tint32\t\ttupTypmod;\n\tTupleDesc\ttupdesc;\n\tHeapTupleData tmptup,\n\t\t\t   *tuple;\n\tint\t\t\ti;\n\n\ttd = DatumGetHeapTupleHeader(composite);\n\n\t/* Extract rowtype info and find a tupdesc */\n\ttupType = HeapTupleHeaderGetTypeId(td);\n\ttupTypmod = HeapTupleHeaderGetTypMod(td);\n\ttupdesc = lookup_rowtype_tupdesc(tupType, tupTypmod);\n\n\t/* Build a temporary HeapTuple control structure */\n\ttmptup.t_len = HeapTupleHeaderGetDatumLength(td);\n\ttmptup.t_data = td;\n\ttuple = &tmptup;\n\n\tresult->res = pushJsonbValue(&result->parseState, WJB_BEGIN_OBJECT, NULL);\n\n\tfor (i = 0; i < tupdesc->natts; i++)\n\t{\n\t\tDatum\t\tval;\n\t\tbool\t\tisnull;\n\t\tchar\t   *attname;\n\t\tJsonbTypeCategory tcategory;\n\t\tOid\t\t\toutfuncoid;\n\t\tJsonbValue\tv;\n\t\tForm_pg_attribute att = TupleDescAttr(tupdesc, i);\n\n\t\tif (att->attisdropped)\n\t\t\tcontinue;\n\n\t\tattname = NameStr(att->attname);\n\n\t\tv.type = jbvString;\n\t\t/* don't need checkStringLen here - can't exceed maximum name length */\n\t\tv.val.string.len = strlen(attname);\n\t\tv.val.string.val = attname;\n\n\t\tresult->res = pushJsonbValue(&result->parseState, WJB_KEY, &v);\n\n\t\tval = heap_getattr(tuple, i + 1, tupdesc, &isnull);\n\n\t\tif (isnull)\n\t\t{\n\t\t\ttcategory = JSONBTYPE_NULL;\n\t\t\toutfuncoid = InvalidOid;\n\t\t}\n\t\telse\n\t\t\tjsonb_categorize_type(att->atttypid, &tcategory, &outfuncoid);\n\n\t\tdatum_to_jsonb(val, isnull, result, tcategory, outfuncoid, false);\n\t}\n\n\tresult->res = pushJsonbValue(&result->parseState, WJB_END_OBJECT, NULL);\n\tReleaseTupleDesc(tupdesc);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"miscadmin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static inline Datum jsonb_from_cstring(char *json, int len);",
      "static size_t checkStringLen(size_t len);",
      "static void jsonb_in_object_field_start(void *pstate, char *fname, bool isnull);",
      "static void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);",
      "static void composite_to_jsonb(Datum composite, JsonbInState *result);",
      "static void array_dim_to_jsonb(JsonbInState *result, int dim, int ndims, int *dims,\n\t\t\t\t   Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid);",
      "static void array_to_jsonb_internal(Datum array, JsonbInState *result);",
      "static void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ReleaseTupleDesc",
          "args": [
            "tupdesc"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pushJsonbValue",
          "args": [
            "&result->parseState",
            "WJB_END_OBJECT",
            "NULL"
          ],
          "line": 1061
        },
        "resolved": true,
        "details": {
          "function_name": "pushJsonbValueScalar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "545-629",
          "snippet": "static JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);",
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbParseState *pushState(JsonbParseState **pstate);",
            "static void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void uniqueifyJsonbObject(JsonbValue *object);",
            "static JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\nstatic void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\nstatic JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);\n\nstatic JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "datum_to_jsonb",
          "args": [
            "val",
            "isnull",
            "result",
            "tcategory",
            "outfuncoid",
            "false"
          ],
          "line": 1058
        },
        "resolved": true,
        "details": {
          "function_name": "datum_to_jsonb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
          "lines": "701-914",
          "snippet": "static void\ndatum_to_jsonb(Datum val, bool is_null, JsonbInState *result,\n\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid,\n\t\t\t   bool key_scalar)\n{\n\tchar\t   *outputstr;\n\tbool\t\tnumeric_error;\n\tJsonbValue\tjb;\n\tbool\t\tscalar_jsonb = false;\n\n\tcheck_stack_depth();\n\n\t/* Convert val to a JsonbValue in jb (in most cases) */\n\tif (is_null)\n\t{\n\t\tAssert(!key_scalar);\n\t\tjb.type = jbvNull;\n\t}\n\telse if (key_scalar &&\n\t\t\t (tcategory == JSONBTYPE_ARRAY ||\n\t\t\t  tcategory == JSONBTYPE_COMPOSITE ||\n\t\t\t  tcategory == JSONBTYPE_JSON ||\n\t\t\t  tcategory == JSONBTYPE_JSONB ||\n\t\t\t  tcategory == JSONBTYPE_JSONCAST))\n\t{\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"key value must be scalar, not array, composite, or json\")));\n\t}\n\telse\n\t{\n\t\tif (tcategory == JSONBTYPE_JSONCAST)\n\t\t\tval = OidFunctionCall1(outfuncoid, val);\n\n\t\tswitch (tcategory)\n\t\t{\n\t\t\tcase JSONBTYPE_ARRAY:\n\t\t\t\tarray_to_jsonb_internal(val, result);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_COMPOSITE:\n\t\t\t\tcomposite_to_jsonb(val, result);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_BOOL:\n\t\t\t\tif (key_scalar)\n\t\t\t\t{\n\t\t\t\t\toutputstr = DatumGetBool(val) ? \"true\" : \"false\";\n\t\t\t\t\tjb.type = jbvString;\n\t\t\t\t\tjb.val.string.len = strlen(outputstr);\n\t\t\t\t\tjb.val.string.val = outputstr;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tjb.type = jbvBool;\n\t\t\t\t\tjb.val.boolean = DatumGetBool(val);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_NUMERIC:\n\t\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\t\t\t\tif (key_scalar)\n\t\t\t\t{\n\t\t\t\t\t/* always quote keys */\n\t\t\t\t\tjb.type = jbvString;\n\t\t\t\t\tjb.val.string.len = strlen(outputstr);\n\t\t\t\t\tjb.val.string.val = outputstr;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * Make it numeric if it's a valid JSON number, otherwise\n\t\t\t\t\t * a string. Invalid numeric output will always have an\n\t\t\t\t\t * 'N' or 'n' in it (I think).\n\t\t\t\t\t */\n\t\t\t\t\tnumeric_error = (strchr(outputstr, 'N') != NULL ||\n\t\t\t\t\t\t\t\t\t strchr(outputstr, 'n') != NULL);\n\t\t\t\t\tif (!numeric_error)\n\t\t\t\t\t{\n\t\t\t\t\t\tDatum\t\tnumd;\n\n\t\t\t\t\t\tjb.type = jbvNumeric;\n\t\t\t\t\t\tnumd = DirectFunctionCall3(numeric_in,\n\t\t\t\t\t\t\t\t\t\t\t\t   CStringGetDatum(outputstr),\n\t\t\t\t\t\t\t\t\t\t\t\t   ObjectIdGetDatum(InvalidOid),\n\t\t\t\t\t\t\t\t\t\t\t\t   Int32GetDatum(-1));\n\t\t\t\t\t\tjb.val.numeric = DatumGetNumeric(numd);\n\t\t\t\t\t\tpfree(outputstr);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tjb.type = jbvString;\n\t\t\t\t\t\tjb.val.string.len = strlen(outputstr);\n\t\t\t\t\t\tjb.val.string.val = outputstr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_DATE:\n\t\t\t\tjb.type = jbvString;\n\t\t\t\tjb.val.string.val = JsonEncodeDateTime(NULL, val, DATEOID);\n\t\t\t\tjb.val.string.len = strlen(jb.val.string.val);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_TIMESTAMP:\n\t\t\t\tjb.type = jbvString;\n\t\t\t\tjb.val.string.val = JsonEncodeDateTime(NULL, val, TIMESTAMPOID);\n\t\t\t\tjb.val.string.len = strlen(jb.val.string.val);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_TIMESTAMPTZ:\n\t\t\t\tjb.type = jbvString;\n\t\t\t\tjb.val.string.val = JsonEncodeDateTime(NULL, val, TIMESTAMPTZOID);\n\t\t\t\tjb.val.string.len = strlen(jb.val.string.val);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_JSONCAST:\n\t\t\tcase JSONBTYPE_JSON:\n\t\t\t\t{\n\t\t\t\t\t/* parse the json right into the existing result object */\n\t\t\t\t\tJsonLexContext *lex;\n\t\t\t\t\tJsonSemAction sem;\n\t\t\t\t\ttext\t   *json = DatumGetTextPP(val);\n\n\t\t\t\t\tlex = makeJsonLexContext(json, true);\n\n\t\t\t\t\tmemset(&sem, 0, sizeof(sem));\n\n\t\t\t\t\tsem.semstate = (void *) result;\n\n\t\t\t\t\tsem.object_start = jsonb_in_object_start;\n\t\t\t\t\tsem.array_start = jsonb_in_array_start;\n\t\t\t\t\tsem.object_end = jsonb_in_object_end;\n\t\t\t\t\tsem.array_end = jsonb_in_array_end;\n\t\t\t\t\tsem.scalar = jsonb_in_scalar;\n\t\t\t\t\tsem.object_field_start = jsonb_in_object_field_start;\n\n\t\t\t\t\tpg_parse_json(lex, &sem);\n\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_JSONB:\n\t\t\t\t{\n\t\t\t\t\tJsonb\t   *jsonb = DatumGetJsonbP(val);\n\t\t\t\t\tJsonbIterator *it;\n\n\t\t\t\t\tit = JsonbIteratorInit(&jsonb->root);\n\n\t\t\t\t\tif (JB_ROOT_IS_SCALAR(jsonb))\n\t\t\t\t\t{\n\t\t\t\t\t\t(void) JsonbIteratorNext(&it, &jb, true);\n\t\t\t\t\t\tAssert(jb.type == jbvArray);\n\t\t\t\t\t\t(void) JsonbIteratorNext(&it, &jb, true);\n\t\t\t\t\t\tscalar_jsonb = true;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tJsonbIteratorToken type;\n\n\t\t\t\t\t\twhile ((type = JsonbIteratorNext(&it, &jb, false))\n\t\t\t\t\t\t\t   != WJB_DONE)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (type == WJB_END_ARRAY || type == WJB_END_OBJECT ||\n\t\t\t\t\t\t\t\ttype == WJB_BEGIN_ARRAY || type == WJB_BEGIN_OBJECT)\n\t\t\t\t\t\t\t\tresult->res = pushJsonbValue(&result->parseState,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t type, NULL);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tresult->res = pushJsonbValue(&result->parseState,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t type, &jb);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\t\t\t\tjb.type = jbvString;\n\t\t\t\tjb.val.string.len = checkStringLen(strlen(outputstr));\n\t\t\t\tjb.val.string.val = outputstr;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Now insert jb into result, unless we did it recursively */\n\tif (!is_null && !scalar_jsonb &&\n\t\ttcategory >= JSONBTYPE_JSON && tcategory <= JSONBTYPE_JSONCAST)\n\t{\n\t\t/* work has been done recursively */\n\t\treturn;\n\t}\n\telse if (result->parseState == NULL)\n\t{\n\t\t/* single root scalar */\n\t\tJsonbValue\tva;\n\n\t\tva.type = jbvArray;\n\t\tva.val.array.rawScalar = true;\n\t\tva.val.array.nElems = 1;\n\n\t\tresult->res = pushJsonbValue(&result->parseState, WJB_BEGIN_ARRAY, &va);\n\t\tresult->res = pushJsonbValue(&result->parseState, WJB_ELEM, &jb);\n\t\tresult->res = pushJsonbValue(&result->parseState, WJB_END_ARRAY, NULL);\n\t}\n\telse\n\t{\n\t\tJsonbValue *o = &result->parseState->contVal;\n\n\t\tswitch (o->type)\n\t\t{\n\t\t\tcase jbvArray:\n\t\t\t\tresult->res = pushJsonbValue(&result->parseState, WJB_ELEM, &jb);\n\t\t\t\tbreak;\n\t\t\tcase jbvObject:\n\t\t\t\tresult->res = pushJsonbValue(&result->parseState,\n\t\t\t\t\t\t\t\t\t\t\t key_scalar ? WJB_KEY : WJB_VALUE,\n\t\t\t\t\t\t\t\t\t\t\t &jb);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unexpected parent of nested structure\");\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"miscadmin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline Datum jsonb_from_cstring(char *json, int len);",
            "static size_t checkStringLen(size_t len);",
            "static void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);",
            "static void composite_to_jsonb(Datum composite, JsonbInState *result);",
            "static void array_dim_to_jsonb(JsonbInState *result, int dim, int ndims, int *dims,\n\t\t\t\t   Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid);",
            "static void array_to_jsonb_internal(Datum array, JsonbInState *result);",
            "static void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);",
            "static void datum_to_jsonb(Datum val, bool is_null, JsonbInState *result,\n\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid,\n\t\t\t   bool key_scalar);",
            "static void add_jsonb(Datum val, bool is_null, JsonbInState *result,\n\t\t  Oid val_type, bool key_scalar);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic inline Datum jsonb_from_cstring(char *json, int len);\nstatic size_t checkStringLen(size_t len);\nstatic void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);\nstatic void composite_to_jsonb(Datum composite, JsonbInState *result);\nstatic void array_dim_to_jsonb(JsonbInState *result, int dim, int ndims, int *dims,\n\t\t\t\t   Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid);\nstatic void array_to_jsonb_internal(Datum array, JsonbInState *result);\nstatic void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);\nstatic void datum_to_jsonb(Datum val, bool is_null, JsonbInState *result,\n\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid,\n\t\t\t   bool key_scalar);\nstatic void add_jsonb(Datum val, bool is_null, JsonbInState *result,\n\t\t  Oid val_type, bool key_scalar);\n\nstatic void\ndatum_to_jsonb(Datum val, bool is_null, JsonbInState *result,\n\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid,\n\t\t\t   bool key_scalar)\n{\n\tchar\t   *outputstr;\n\tbool\t\tnumeric_error;\n\tJsonbValue\tjb;\n\tbool\t\tscalar_jsonb = false;\n\n\tcheck_stack_depth();\n\n\t/* Convert val to a JsonbValue in jb (in most cases) */\n\tif (is_null)\n\t{\n\t\tAssert(!key_scalar);\n\t\tjb.type = jbvNull;\n\t}\n\telse if (key_scalar &&\n\t\t\t (tcategory == JSONBTYPE_ARRAY ||\n\t\t\t  tcategory == JSONBTYPE_COMPOSITE ||\n\t\t\t  tcategory == JSONBTYPE_JSON ||\n\t\t\t  tcategory == JSONBTYPE_JSONB ||\n\t\t\t  tcategory == JSONBTYPE_JSONCAST))\n\t{\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"key value must be scalar, not array, composite, or json\")));\n\t}\n\telse\n\t{\n\t\tif (tcategory == JSONBTYPE_JSONCAST)\n\t\t\tval = OidFunctionCall1(outfuncoid, val);\n\n\t\tswitch (tcategory)\n\t\t{\n\t\t\tcase JSONBTYPE_ARRAY:\n\t\t\t\tarray_to_jsonb_internal(val, result);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_COMPOSITE:\n\t\t\t\tcomposite_to_jsonb(val, result);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_BOOL:\n\t\t\t\tif (key_scalar)\n\t\t\t\t{\n\t\t\t\t\toutputstr = DatumGetBool(val) ? \"true\" : \"false\";\n\t\t\t\t\tjb.type = jbvString;\n\t\t\t\t\tjb.val.string.len = strlen(outputstr);\n\t\t\t\t\tjb.val.string.val = outputstr;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tjb.type = jbvBool;\n\t\t\t\t\tjb.val.boolean = DatumGetBool(val);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_NUMERIC:\n\t\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\t\t\t\tif (key_scalar)\n\t\t\t\t{\n\t\t\t\t\t/* always quote keys */\n\t\t\t\t\tjb.type = jbvString;\n\t\t\t\t\tjb.val.string.len = strlen(outputstr);\n\t\t\t\t\tjb.val.string.val = outputstr;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * Make it numeric if it's a valid JSON number, otherwise\n\t\t\t\t\t * a string. Invalid numeric output will always have an\n\t\t\t\t\t * 'N' or 'n' in it (I think).\n\t\t\t\t\t */\n\t\t\t\t\tnumeric_error = (strchr(outputstr, 'N') != NULL ||\n\t\t\t\t\t\t\t\t\t strchr(outputstr, 'n') != NULL);\n\t\t\t\t\tif (!numeric_error)\n\t\t\t\t\t{\n\t\t\t\t\t\tDatum\t\tnumd;\n\n\t\t\t\t\t\tjb.type = jbvNumeric;\n\t\t\t\t\t\tnumd = DirectFunctionCall3(numeric_in,\n\t\t\t\t\t\t\t\t\t\t\t\t   CStringGetDatum(outputstr),\n\t\t\t\t\t\t\t\t\t\t\t\t   ObjectIdGetDatum(InvalidOid),\n\t\t\t\t\t\t\t\t\t\t\t\t   Int32GetDatum(-1));\n\t\t\t\t\t\tjb.val.numeric = DatumGetNumeric(numd);\n\t\t\t\t\t\tpfree(outputstr);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tjb.type = jbvString;\n\t\t\t\t\t\tjb.val.string.len = strlen(outputstr);\n\t\t\t\t\t\tjb.val.string.val = outputstr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_DATE:\n\t\t\t\tjb.type = jbvString;\n\t\t\t\tjb.val.string.val = JsonEncodeDateTime(NULL, val, DATEOID);\n\t\t\t\tjb.val.string.len = strlen(jb.val.string.val);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_TIMESTAMP:\n\t\t\t\tjb.type = jbvString;\n\t\t\t\tjb.val.string.val = JsonEncodeDateTime(NULL, val, TIMESTAMPOID);\n\t\t\t\tjb.val.string.len = strlen(jb.val.string.val);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_TIMESTAMPTZ:\n\t\t\t\tjb.type = jbvString;\n\t\t\t\tjb.val.string.val = JsonEncodeDateTime(NULL, val, TIMESTAMPTZOID);\n\t\t\t\tjb.val.string.len = strlen(jb.val.string.val);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_JSONCAST:\n\t\t\tcase JSONBTYPE_JSON:\n\t\t\t\t{\n\t\t\t\t\t/* parse the json right into the existing result object */\n\t\t\t\t\tJsonLexContext *lex;\n\t\t\t\t\tJsonSemAction sem;\n\t\t\t\t\ttext\t   *json = DatumGetTextPP(val);\n\n\t\t\t\t\tlex = makeJsonLexContext(json, true);\n\n\t\t\t\t\tmemset(&sem, 0, sizeof(sem));\n\n\t\t\t\t\tsem.semstate = (void *) result;\n\n\t\t\t\t\tsem.object_start = jsonb_in_object_start;\n\t\t\t\t\tsem.array_start = jsonb_in_array_start;\n\t\t\t\t\tsem.object_end = jsonb_in_object_end;\n\t\t\t\t\tsem.array_end = jsonb_in_array_end;\n\t\t\t\t\tsem.scalar = jsonb_in_scalar;\n\t\t\t\t\tsem.object_field_start = jsonb_in_object_field_start;\n\n\t\t\t\t\tpg_parse_json(lex, &sem);\n\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_JSONB:\n\t\t\t\t{\n\t\t\t\t\tJsonb\t   *jsonb = DatumGetJsonbP(val);\n\t\t\t\t\tJsonbIterator *it;\n\n\t\t\t\t\tit = JsonbIteratorInit(&jsonb->root);\n\n\t\t\t\t\tif (JB_ROOT_IS_SCALAR(jsonb))\n\t\t\t\t\t{\n\t\t\t\t\t\t(void) JsonbIteratorNext(&it, &jb, true);\n\t\t\t\t\t\tAssert(jb.type == jbvArray);\n\t\t\t\t\t\t(void) JsonbIteratorNext(&it, &jb, true);\n\t\t\t\t\t\tscalar_jsonb = true;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tJsonbIteratorToken type;\n\n\t\t\t\t\t\twhile ((type = JsonbIteratorNext(&it, &jb, false))\n\t\t\t\t\t\t\t   != WJB_DONE)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (type == WJB_END_ARRAY || type == WJB_END_OBJECT ||\n\t\t\t\t\t\t\t\ttype == WJB_BEGIN_ARRAY || type == WJB_BEGIN_OBJECT)\n\t\t\t\t\t\t\t\tresult->res = pushJsonbValue(&result->parseState,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t type, NULL);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tresult->res = pushJsonbValue(&result->parseState,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t type, &jb);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\t\t\t\tjb.type = jbvString;\n\t\t\t\tjb.val.string.len = checkStringLen(strlen(outputstr));\n\t\t\t\tjb.val.string.val = outputstr;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Now insert jb into result, unless we did it recursively */\n\tif (!is_null && !scalar_jsonb &&\n\t\ttcategory >= JSONBTYPE_JSON && tcategory <= JSONBTYPE_JSONCAST)\n\t{\n\t\t/* work has been done recursively */\n\t\treturn;\n\t}\n\telse if (result->parseState == NULL)\n\t{\n\t\t/* single root scalar */\n\t\tJsonbValue\tva;\n\n\t\tva.type = jbvArray;\n\t\tva.val.array.rawScalar = true;\n\t\tva.val.array.nElems = 1;\n\n\t\tresult->res = pushJsonbValue(&result->parseState, WJB_BEGIN_ARRAY, &va);\n\t\tresult->res = pushJsonbValue(&result->parseState, WJB_ELEM, &jb);\n\t\tresult->res = pushJsonbValue(&result->parseState, WJB_END_ARRAY, NULL);\n\t}\n\telse\n\t{\n\t\tJsonbValue *o = &result->parseState->contVal;\n\n\t\tswitch (o->type)\n\t\t{\n\t\t\tcase jbvArray:\n\t\t\t\tresult->res = pushJsonbValue(&result->parseState, WJB_ELEM, &jb);\n\t\t\t\tbreak;\n\t\t\tcase jbvObject:\n\t\t\t\tresult->res = pushJsonbValue(&result->parseState,\n\t\t\t\t\t\t\t\t\t\t\t key_scalar ? WJB_KEY : WJB_VALUE,\n\t\t\t\t\t\t\t\t\t\t\t &jb);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unexpected parent of nested structure\");\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "jsonb_categorize_type",
          "args": [
            "att->atttypid",
            "&tcategory",
            "&outfuncoid"
          ],
          "line": 1056
        },
        "resolved": true,
        "details": {
          "function_name": "jsonb_categorize_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
          "lines": "593-690",
          "snippet": "static void\njsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid)\n{\n\tbool\t\ttypisvarlena;\n\n\t/* Look through any domain */\n\ttypoid = getBaseType(typoid);\n\n\t*outfuncoid = InvalidOid;\n\n\t/*\n\t * We need to get the output function for everything except date and\n\t * timestamp types, booleans, array and composite types, json and jsonb,\n\t * and non-builtin types where there's a cast to json. In this last case\n\t * we return the oid of the cast function instead.\n\t */\n\n\tswitch (typoid)\n\t{\n\t\tcase BOOLOID:\n\t\t\t*tcategory = JSONBTYPE_BOOL;\n\t\t\tbreak;\n\n\t\tcase INT2OID:\n\t\tcase INT4OID:\n\t\tcase INT8OID:\n\t\tcase FLOAT4OID:\n\t\tcase FLOAT8OID:\n\t\tcase NUMERICOID:\n\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t*tcategory = JSONBTYPE_NUMERIC;\n\t\t\tbreak;\n\n\t\tcase DATEOID:\n\t\t\t*tcategory = JSONBTYPE_DATE;\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPOID:\n\t\t\t*tcategory = JSONBTYPE_TIMESTAMP;\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPTZOID:\n\t\t\t*tcategory = JSONBTYPE_TIMESTAMPTZ;\n\t\t\tbreak;\n\n\t\tcase JSONBOID:\n\t\t\t*tcategory = JSONBTYPE_JSONB;\n\t\t\tbreak;\n\n\t\tcase JSONOID:\n\t\t\t*tcategory = JSONBTYPE_JSON;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* Check for arrays and composites */\n\t\t\tif (OidIsValid(get_element_type(typoid)) || typoid == ANYARRAYOID\n\t\t\t\t|| typoid == RECORDARRAYOID)\n\t\t\t\t*tcategory = JSONBTYPE_ARRAY;\n\t\t\telse if (type_is_rowtype(typoid))\t/* includes RECORDOID */\n\t\t\t\t*tcategory = JSONBTYPE_COMPOSITE;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* It's probably the general case ... */\n\t\t\t\t*tcategory = JSONBTYPE_OTHER;\n\n\t\t\t\t/*\n\t\t\t\t * but first let's look for a cast to json (note: not to\n\t\t\t\t * jsonb) if it's not built-in.\n\t\t\t\t */\n\t\t\t\tif (typoid >= FirstNormalObjectId)\n\t\t\t\t{\n\t\t\t\t\tOid\t\t\tcastfunc;\n\t\t\t\t\tCoercionPathType ctype;\n\n\t\t\t\t\tctype = find_coercion_pathway(JSONOID, typoid,\n\t\t\t\t\t\t\t\t\t\t\t\t  COERCION_EXPLICIT, &castfunc);\n\t\t\t\t\tif (ctype == COERCION_PATH_FUNC && OidIsValid(castfunc))\n\t\t\t\t\t{\n\t\t\t\t\t\t*tcategory = JSONBTYPE_JSONCAST;\n\t\t\t\t\t\t*outfuncoid = castfunc;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* not a cast type, so just get the usual output func */\n\t\t\t\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* any other builtin type */\n\t\t\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"miscadmin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);",
            "static void array_dim_to_jsonb(JsonbInState *result, int dim, int ndims, int *dims,\n\t\t\t\t   Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid);",
            "static void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);\nstatic void array_dim_to_jsonb(JsonbInState *result, int dim, int ndims, int *dims,\n\t\t\t\t   Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid);\nstatic void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);\n\nstatic void\njsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid)\n{\n\tbool\t\ttypisvarlena;\n\n\t/* Look through any domain */\n\ttypoid = getBaseType(typoid);\n\n\t*outfuncoid = InvalidOid;\n\n\t/*\n\t * We need to get the output function for everything except date and\n\t * timestamp types, booleans, array and composite types, json and jsonb,\n\t * and non-builtin types where there's a cast to json. In this last case\n\t * we return the oid of the cast function instead.\n\t */\n\n\tswitch (typoid)\n\t{\n\t\tcase BOOLOID:\n\t\t\t*tcategory = JSONBTYPE_BOOL;\n\t\t\tbreak;\n\n\t\tcase INT2OID:\n\t\tcase INT4OID:\n\t\tcase INT8OID:\n\t\tcase FLOAT4OID:\n\t\tcase FLOAT8OID:\n\t\tcase NUMERICOID:\n\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t*tcategory = JSONBTYPE_NUMERIC;\n\t\t\tbreak;\n\n\t\tcase DATEOID:\n\t\t\t*tcategory = JSONBTYPE_DATE;\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPOID:\n\t\t\t*tcategory = JSONBTYPE_TIMESTAMP;\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPTZOID:\n\t\t\t*tcategory = JSONBTYPE_TIMESTAMPTZ;\n\t\t\tbreak;\n\n\t\tcase JSONBOID:\n\t\t\t*tcategory = JSONBTYPE_JSONB;\n\t\t\tbreak;\n\n\t\tcase JSONOID:\n\t\t\t*tcategory = JSONBTYPE_JSON;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* Check for arrays and composites */\n\t\t\tif (OidIsValid(get_element_type(typoid)) || typoid == ANYARRAYOID\n\t\t\t\t|| typoid == RECORDARRAYOID)\n\t\t\t\t*tcategory = JSONBTYPE_ARRAY;\n\t\t\telse if (type_is_rowtype(typoid))\t/* includes RECORDOID */\n\t\t\t\t*tcategory = JSONBTYPE_COMPOSITE;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* It's probably the general case ... */\n\t\t\t\t*tcategory = JSONBTYPE_OTHER;\n\n\t\t\t\t/*\n\t\t\t\t * but first let's look for a cast to json (note: not to\n\t\t\t\t * jsonb) if it's not built-in.\n\t\t\t\t */\n\t\t\t\tif (typoid >= FirstNormalObjectId)\n\t\t\t\t{\n\t\t\t\t\tOid\t\t\tcastfunc;\n\t\t\t\t\tCoercionPathType ctype;\n\n\t\t\t\t\tctype = find_coercion_pathway(JSONOID, typoid,\n\t\t\t\t\t\t\t\t\t\t\t\t  COERCION_EXPLICIT, &castfunc);\n\t\t\t\t\tif (ctype == COERCION_PATH_FUNC && OidIsValid(castfunc))\n\t\t\t\t\t{\n\t\t\t\t\t\t*tcategory = JSONBTYPE_JSONCAST;\n\t\t\t\t\t\t*outfuncoid = castfunc;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* not a cast type, so just get the usual output func */\n\t\t\t\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* any other builtin type */\n\t\t\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "heap_getattr",
          "args": [
            "tuple",
            "i + 1",
            "tupdesc",
            "&isnull"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "attname"
          ],
          "line": 1043
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "att->attname"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescAttr",
          "args": [
            "tupdesc",
            "i"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetDatumLength",
          "args": [
            "td"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_rowtype_tupdesc",
          "args": [
            "tupType",
            "tupTypmod"
          ],
          "line": 1017
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_rowtype_tupdesc_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "1674-1681",
          "snippet": "TupleDesc\nlookup_rowtype_tupdesc_copy(Oid type_id, int32 typmod)\n{\n\tTupleDesc\ttmp;\n\n\ttmp = lookup_rowtype_tupdesc_internal(type_id, typmod, false);\n\treturn CreateTupleDescCopyConstr(tmp);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);\n\nTupleDesc\nlookup_rowtype_tupdesc_copy(Oid type_id, int32 typmod)\n{\n\tTupleDesc\ttmp;\n\n\ttmp = lookup_rowtype_tupdesc_internal(type_id, typmod, false);\n\treturn CreateTupleDescCopyConstr(tmp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetTypMod",
          "args": [
            "td"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetTypeId",
          "args": [
            "td"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetHeapTupleHeader",
          "args": [
            "composite"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic inline Datum jsonb_from_cstring(char *json, int len);\nstatic size_t checkStringLen(size_t len);\nstatic void jsonb_in_object_field_start(void *pstate, char *fname, bool isnull);\nstatic void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);\nstatic void composite_to_jsonb(Datum composite, JsonbInState *result);\nstatic void array_dim_to_jsonb(JsonbInState *result, int dim, int ndims, int *dims,\n\t\t\t\t   Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid);\nstatic void array_to_jsonb_internal(Datum array, JsonbInState *result);\nstatic void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);\n\nstatic void\ncomposite_to_jsonb(Datum composite, JsonbInState *result)\n{\n\tHeapTupleHeader td;\n\tOid\t\t\ttupType;\n\tint32\t\ttupTypmod;\n\tTupleDesc\ttupdesc;\n\tHeapTupleData tmptup,\n\t\t\t   *tuple;\n\tint\t\t\ti;\n\n\ttd = DatumGetHeapTupleHeader(composite);\n\n\t/* Extract rowtype info and find a tupdesc */\n\ttupType = HeapTupleHeaderGetTypeId(td);\n\ttupTypmod = HeapTupleHeaderGetTypMod(td);\n\ttupdesc = lookup_rowtype_tupdesc(tupType, tupTypmod);\n\n\t/* Build a temporary HeapTuple control structure */\n\ttmptup.t_len = HeapTupleHeaderGetDatumLength(td);\n\ttmptup.t_data = td;\n\ttuple = &tmptup;\n\n\tresult->res = pushJsonbValue(&result->parseState, WJB_BEGIN_OBJECT, NULL);\n\n\tfor (i = 0; i < tupdesc->natts; i++)\n\t{\n\t\tDatum\t\tval;\n\t\tbool\t\tisnull;\n\t\tchar\t   *attname;\n\t\tJsonbTypeCategory tcategory;\n\t\tOid\t\t\toutfuncoid;\n\t\tJsonbValue\tv;\n\t\tForm_pg_attribute att = TupleDescAttr(tupdesc, i);\n\n\t\tif (att->attisdropped)\n\t\t\tcontinue;\n\n\t\tattname = NameStr(att->attname);\n\n\t\tv.type = jbvString;\n\t\t/* don't need checkStringLen here - can't exceed maximum name length */\n\t\tv.val.string.len = strlen(attname);\n\t\tv.val.string.val = attname;\n\n\t\tresult->res = pushJsonbValue(&result->parseState, WJB_KEY, &v);\n\n\t\tval = heap_getattr(tuple, i + 1, tupdesc, &isnull);\n\n\t\tif (isnull)\n\t\t{\n\t\t\ttcategory = JSONBTYPE_NULL;\n\t\t\toutfuncoid = InvalidOid;\n\t\t}\n\t\telse\n\t\t\tjsonb_categorize_type(att->atttypid, &tcategory, &outfuncoid);\n\n\t\tdatum_to_jsonb(val, isnull, result, tcategory, outfuncoid, false);\n\t}\n\n\tresult->res = pushJsonbValue(&result->parseState, WJB_END_OBJECT, NULL);\n\tReleaseTupleDesc(tupdesc);\n}"
  },
  {
    "function_name": "array_to_jsonb_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
    "lines": "953-996",
    "snippet": "static void\narray_to_jsonb_internal(Datum array, JsonbInState *result)\n{\n\tArrayType  *v = DatumGetArrayTypeP(array);\n\tOid\t\t\telement_type = ARR_ELEMTYPE(v);\n\tint\t\t   *dim;\n\tint\t\t\tndim;\n\tint\t\t\tnitems;\n\tint\t\t\tcount = 0;\n\tDatum\t   *elements;\n\tbool\t   *nulls;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tJsonbTypeCategory tcategory;\n\tOid\t\t\toutfuncoid;\n\n\tndim = ARR_NDIM(v);\n\tdim = ARR_DIMS(v);\n\tnitems = ArrayGetNItems(ndim, dim);\n\n\tif (nitems <= 0)\n\t{\n\t\tresult->res = pushJsonbValue(&result->parseState, WJB_BEGIN_ARRAY, NULL);\n\t\tresult->res = pushJsonbValue(&result->parseState, WJB_END_ARRAY, NULL);\n\t\treturn;\n\t}\n\n\tget_typlenbyvalalign(element_type,\n\t\t\t\t\t\t &typlen, &typbyval, &typalign);\n\n\tjsonb_categorize_type(element_type,\n\t\t\t\t\t\t  &tcategory, &outfuncoid);\n\n\tdeconstruct_array(v, element_type, typlen, typbyval,\n\t\t\t\t\t  typalign, &elements, &nulls,\n\t\t\t\t\t  &nitems);\n\n\tarray_dim_to_jsonb(result, 0, ndim, dim, elements, nulls, &count, tcategory,\n\t\t\t\t\t   outfuncoid);\n\n\tpfree(elements);\n\tpfree(nulls);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"miscadmin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);",
      "static void composite_to_jsonb(Datum composite, JsonbInState *result);",
      "static void array_dim_to_jsonb(JsonbInState *result, int dim, int ndims, int *dims,\n\t\t\t\t   Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid);",
      "static void array_to_jsonb_internal(Datum array, JsonbInState *result);",
      "static void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "nulls"
          ],
          "line": 995
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "array_dim_to_jsonb",
          "args": [
            "result",
            "0",
            "ndim",
            "dim",
            "elements",
            "nulls",
            "&count",
            "tcategory",
            "outfuncoid"
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "array_dim_to_jsonb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
          "lines": "921-948",
          "snippet": "static void\narray_dim_to_jsonb(JsonbInState *result, int dim, int ndims, int *dims, Datum *vals,\n\t\t\t\t   bool *nulls, int *valcount, JsonbTypeCategory tcategory,\n\t\t\t\t   Oid outfuncoid)\n{\n\tint\t\t\ti;\n\n\tAssert(dim < ndims);\n\n\tresult->res = pushJsonbValue(&result->parseState, WJB_BEGIN_ARRAY, NULL);\n\n\tfor (i = 1; i <= dims[dim]; i++)\n\t{\n\t\tif (dim + 1 == ndims)\n\t\t{\n\t\t\tdatum_to_jsonb(vals[*valcount], nulls[*valcount], result, tcategory,\n\t\t\t\t\t\t   outfuncoid, false);\n\t\t\t(*valcount)++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tarray_dim_to_jsonb(result, dim + 1, ndims, dims, vals, nulls,\n\t\t\t\t\t\t\t   valcount, tcategory, outfuncoid);\n\t\t}\n\t}\n\n\tresult->res = pushJsonbValue(&result->parseState, WJB_END_ARRAY, NULL);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"miscadmin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);",
            "static void composite_to_jsonb(Datum composite, JsonbInState *result);",
            "static void array_dim_to_jsonb(JsonbInState *result, int dim, int ndims, int *dims,\n\t\t\t\t   Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid);",
            "static void array_to_jsonb_internal(Datum array, JsonbInState *result);",
            "static void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);\nstatic void composite_to_jsonb(Datum composite, JsonbInState *result);\nstatic void array_dim_to_jsonb(JsonbInState *result, int dim, int ndims, int *dims,\n\t\t\t\t   Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid);\nstatic void array_to_jsonb_internal(Datum array, JsonbInState *result);\nstatic void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);\n\nstatic void\narray_dim_to_jsonb(JsonbInState *result, int dim, int ndims, int *dims, Datum *vals,\n\t\t\t\t   bool *nulls, int *valcount, JsonbTypeCategory tcategory,\n\t\t\t\t   Oid outfuncoid)\n{\n\tint\t\t\ti;\n\n\tAssert(dim < ndims);\n\n\tresult->res = pushJsonbValue(&result->parseState, WJB_BEGIN_ARRAY, NULL);\n\n\tfor (i = 1; i <= dims[dim]; i++)\n\t{\n\t\tif (dim + 1 == ndims)\n\t\t{\n\t\t\tdatum_to_jsonb(vals[*valcount], nulls[*valcount], result, tcategory,\n\t\t\t\t\t\t   outfuncoid, false);\n\t\t\t(*valcount)++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tarray_dim_to_jsonb(result, dim + 1, ndims, dims, vals, nulls,\n\t\t\t\t\t\t\t   valcount, tcategory, outfuncoid);\n\t\t}\n\t}\n\n\tresult->res = pushJsonbValue(&result->parseState, WJB_END_ARRAY, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "deconstruct_array",
          "args": [
            "v",
            "element_type",
            "typlen",
            "typbyval",
            "typalign",
            "&elements",
            "&nulls",
            "&nitems"
          ],
          "line": 987
        },
        "resolved": true,
        "details": {
          "function_name": "deconstruct_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3460-3519",
          "snippet": "void\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\n\nvoid\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "jsonb_categorize_type",
          "args": [
            "element_type",
            "&tcategory",
            "&outfuncoid"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "jsonb_categorize_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
          "lines": "593-690",
          "snippet": "static void\njsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid)\n{\n\tbool\t\ttypisvarlena;\n\n\t/* Look through any domain */\n\ttypoid = getBaseType(typoid);\n\n\t*outfuncoid = InvalidOid;\n\n\t/*\n\t * We need to get the output function for everything except date and\n\t * timestamp types, booleans, array and composite types, json and jsonb,\n\t * and non-builtin types where there's a cast to json. In this last case\n\t * we return the oid of the cast function instead.\n\t */\n\n\tswitch (typoid)\n\t{\n\t\tcase BOOLOID:\n\t\t\t*tcategory = JSONBTYPE_BOOL;\n\t\t\tbreak;\n\n\t\tcase INT2OID:\n\t\tcase INT4OID:\n\t\tcase INT8OID:\n\t\tcase FLOAT4OID:\n\t\tcase FLOAT8OID:\n\t\tcase NUMERICOID:\n\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t*tcategory = JSONBTYPE_NUMERIC;\n\t\t\tbreak;\n\n\t\tcase DATEOID:\n\t\t\t*tcategory = JSONBTYPE_DATE;\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPOID:\n\t\t\t*tcategory = JSONBTYPE_TIMESTAMP;\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPTZOID:\n\t\t\t*tcategory = JSONBTYPE_TIMESTAMPTZ;\n\t\t\tbreak;\n\n\t\tcase JSONBOID:\n\t\t\t*tcategory = JSONBTYPE_JSONB;\n\t\t\tbreak;\n\n\t\tcase JSONOID:\n\t\t\t*tcategory = JSONBTYPE_JSON;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* Check for arrays and composites */\n\t\t\tif (OidIsValid(get_element_type(typoid)) || typoid == ANYARRAYOID\n\t\t\t\t|| typoid == RECORDARRAYOID)\n\t\t\t\t*tcategory = JSONBTYPE_ARRAY;\n\t\t\telse if (type_is_rowtype(typoid))\t/* includes RECORDOID */\n\t\t\t\t*tcategory = JSONBTYPE_COMPOSITE;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* It's probably the general case ... */\n\t\t\t\t*tcategory = JSONBTYPE_OTHER;\n\n\t\t\t\t/*\n\t\t\t\t * but first let's look for a cast to json (note: not to\n\t\t\t\t * jsonb) if it's not built-in.\n\t\t\t\t */\n\t\t\t\tif (typoid >= FirstNormalObjectId)\n\t\t\t\t{\n\t\t\t\t\tOid\t\t\tcastfunc;\n\t\t\t\t\tCoercionPathType ctype;\n\n\t\t\t\t\tctype = find_coercion_pathway(JSONOID, typoid,\n\t\t\t\t\t\t\t\t\t\t\t\t  COERCION_EXPLICIT, &castfunc);\n\t\t\t\t\tif (ctype == COERCION_PATH_FUNC && OidIsValid(castfunc))\n\t\t\t\t\t{\n\t\t\t\t\t\t*tcategory = JSONBTYPE_JSONCAST;\n\t\t\t\t\t\t*outfuncoid = castfunc;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* not a cast type, so just get the usual output func */\n\t\t\t\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* any other builtin type */\n\t\t\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"miscadmin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);",
            "static void array_dim_to_jsonb(JsonbInState *result, int dim, int ndims, int *dims,\n\t\t\t\t   Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid);",
            "static void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);\nstatic void array_dim_to_jsonb(JsonbInState *result, int dim, int ndims, int *dims,\n\t\t\t\t   Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid);\nstatic void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);\n\nstatic void\njsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid)\n{\n\tbool\t\ttypisvarlena;\n\n\t/* Look through any domain */\n\ttypoid = getBaseType(typoid);\n\n\t*outfuncoid = InvalidOid;\n\n\t/*\n\t * We need to get the output function for everything except date and\n\t * timestamp types, booleans, array and composite types, json and jsonb,\n\t * and non-builtin types where there's a cast to json. In this last case\n\t * we return the oid of the cast function instead.\n\t */\n\n\tswitch (typoid)\n\t{\n\t\tcase BOOLOID:\n\t\t\t*tcategory = JSONBTYPE_BOOL;\n\t\t\tbreak;\n\n\t\tcase INT2OID:\n\t\tcase INT4OID:\n\t\tcase INT8OID:\n\t\tcase FLOAT4OID:\n\t\tcase FLOAT8OID:\n\t\tcase NUMERICOID:\n\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t*tcategory = JSONBTYPE_NUMERIC;\n\t\t\tbreak;\n\n\t\tcase DATEOID:\n\t\t\t*tcategory = JSONBTYPE_DATE;\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPOID:\n\t\t\t*tcategory = JSONBTYPE_TIMESTAMP;\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPTZOID:\n\t\t\t*tcategory = JSONBTYPE_TIMESTAMPTZ;\n\t\t\tbreak;\n\n\t\tcase JSONBOID:\n\t\t\t*tcategory = JSONBTYPE_JSONB;\n\t\t\tbreak;\n\n\t\tcase JSONOID:\n\t\t\t*tcategory = JSONBTYPE_JSON;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* Check for arrays and composites */\n\t\t\tif (OidIsValid(get_element_type(typoid)) || typoid == ANYARRAYOID\n\t\t\t\t|| typoid == RECORDARRAYOID)\n\t\t\t\t*tcategory = JSONBTYPE_ARRAY;\n\t\t\telse if (type_is_rowtype(typoid))\t/* includes RECORDOID */\n\t\t\t\t*tcategory = JSONBTYPE_COMPOSITE;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* It's probably the general case ... */\n\t\t\t\t*tcategory = JSONBTYPE_OTHER;\n\n\t\t\t\t/*\n\t\t\t\t * but first let's look for a cast to json (note: not to\n\t\t\t\t * jsonb) if it's not built-in.\n\t\t\t\t */\n\t\t\t\tif (typoid >= FirstNormalObjectId)\n\t\t\t\t{\n\t\t\t\t\tOid\t\t\tcastfunc;\n\t\t\t\t\tCoercionPathType ctype;\n\n\t\t\t\t\tctype = find_coercion_pathway(JSONOID, typoid,\n\t\t\t\t\t\t\t\t\t\t\t\t  COERCION_EXPLICIT, &castfunc);\n\t\t\t\t\tif (ctype == COERCION_PATH_FUNC && OidIsValid(castfunc))\n\t\t\t\t\t{\n\t\t\t\t\t\t*tcategory = JSONBTYPE_JSONCAST;\n\t\t\t\t\t\t*outfuncoid = castfunc;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* not a cast type, so just get the usual output func */\n\t\t\t\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* any other builtin type */\n\t\t\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_typlenbyvalalign",
          "args": [
            "element_type",
            "&typlen",
            "&typbyval",
            "&typalign"
          ],
          "line": 981
        },
        "resolved": true,
        "details": {
          "function_name": "get_typlenbyvalalign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2048-2063",
          "snippet": "void\nget_typlenbyvalalign(Oid typid, int16 *typlen, bool *typbyval,\n\t\t\t\t\t char *typalign)\n{\n\tHeapTuple\ttp;\n\tForm_pg_type typtup;\n\n\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t*typlen = typtup->typlen;\n\t*typbyval = typtup->typbyval;\n\t*typalign = typtup->typalign;\n\tReleaseSysCache(tp);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nget_typlenbyvalalign(Oid typid, int16 *typlen, bool *typbyval,\n\t\t\t\t\t char *typalign)\n{\n\tHeapTuple\ttp;\n\tForm_pg_type typtup;\n\n\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t*typlen = typtup->typlen;\n\t*typbyval = typtup->typbyval;\n\t*typalign = typtup->typalign;\n\tReleaseSysCache(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pushJsonbValue",
          "args": [
            "&result->parseState",
            "WJB_END_ARRAY",
            "NULL"
          ],
          "line": 977
        },
        "resolved": true,
        "details": {
          "function_name": "pushJsonbValueScalar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "545-629",
          "snippet": "static JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);",
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbParseState *pushState(JsonbParseState **pstate);",
            "static void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void uniqueifyJsonbObject(JsonbValue *object);",
            "static JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\nstatic void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\nstatic JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);\n\nstatic JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ArrayGetNItems",
          "args": [
            "ndim",
            "dim"
          ],
          "line": 972
        },
        "resolved": true,
        "details": {
          "function_name": "ArrayGetNItems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
          "lines": "74-112",
          "snippet": "int\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\nint\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "v"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NDIM",
          "args": [
            "v"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_ELEMTYPE",
          "args": [
            "v"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetArrayTypeP",
          "args": [
            "array"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);\nstatic void composite_to_jsonb(Datum composite, JsonbInState *result);\nstatic void array_dim_to_jsonb(JsonbInState *result, int dim, int ndims, int *dims,\n\t\t\t\t   Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid);\nstatic void array_to_jsonb_internal(Datum array, JsonbInState *result);\nstatic void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);\n\nstatic void\narray_to_jsonb_internal(Datum array, JsonbInState *result)\n{\n\tArrayType  *v = DatumGetArrayTypeP(array);\n\tOid\t\t\telement_type = ARR_ELEMTYPE(v);\n\tint\t\t   *dim;\n\tint\t\t\tndim;\n\tint\t\t\tnitems;\n\tint\t\t\tcount = 0;\n\tDatum\t   *elements;\n\tbool\t   *nulls;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tJsonbTypeCategory tcategory;\n\tOid\t\t\toutfuncoid;\n\n\tndim = ARR_NDIM(v);\n\tdim = ARR_DIMS(v);\n\tnitems = ArrayGetNItems(ndim, dim);\n\n\tif (nitems <= 0)\n\t{\n\t\tresult->res = pushJsonbValue(&result->parseState, WJB_BEGIN_ARRAY, NULL);\n\t\tresult->res = pushJsonbValue(&result->parseState, WJB_END_ARRAY, NULL);\n\t\treturn;\n\t}\n\n\tget_typlenbyvalalign(element_type,\n\t\t\t\t\t\t &typlen, &typbyval, &typalign);\n\n\tjsonb_categorize_type(element_type,\n\t\t\t\t\t\t  &tcategory, &outfuncoid);\n\n\tdeconstruct_array(v, element_type, typlen, typbyval,\n\t\t\t\t\t  typalign, &elements, &nulls,\n\t\t\t\t\t  &nitems);\n\n\tarray_dim_to_jsonb(result, 0, ndim, dim, elements, nulls, &count, tcategory,\n\t\t\t\t\t   outfuncoid);\n\n\tpfree(elements);\n\tpfree(nulls);\n}"
  },
  {
    "function_name": "array_dim_to_jsonb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
    "lines": "921-948",
    "snippet": "static void\narray_dim_to_jsonb(JsonbInState *result, int dim, int ndims, int *dims, Datum *vals,\n\t\t\t\t   bool *nulls, int *valcount, JsonbTypeCategory tcategory,\n\t\t\t\t   Oid outfuncoid)\n{\n\tint\t\t\ti;\n\n\tAssert(dim < ndims);\n\n\tresult->res = pushJsonbValue(&result->parseState, WJB_BEGIN_ARRAY, NULL);\n\n\tfor (i = 1; i <= dims[dim]; i++)\n\t{\n\t\tif (dim + 1 == ndims)\n\t\t{\n\t\t\tdatum_to_jsonb(vals[*valcount], nulls[*valcount], result, tcategory,\n\t\t\t\t\t\t   outfuncoid, false);\n\t\t\t(*valcount)++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tarray_dim_to_jsonb(result, dim + 1, ndims, dims, vals, nulls,\n\t\t\t\t\t\t\t   valcount, tcategory, outfuncoid);\n\t\t}\n\t}\n\n\tresult->res = pushJsonbValue(&result->parseState, WJB_END_ARRAY, NULL);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"miscadmin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);",
      "static void composite_to_jsonb(Datum composite, JsonbInState *result);",
      "static void array_dim_to_jsonb(JsonbInState *result, int dim, int ndims, int *dims,\n\t\t\t\t   Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid);",
      "static void array_to_jsonb_internal(Datum array, JsonbInState *result);",
      "static void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pushJsonbValue",
          "args": [
            "&result->parseState",
            "WJB_END_ARRAY",
            "NULL"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "pushJsonbValueScalar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "545-629",
          "snippet": "static JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);",
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbParseState *pushState(JsonbParseState **pstate);",
            "static void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void uniqueifyJsonbObject(JsonbValue *object);",
            "static JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\nstatic void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\nstatic JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);\n\nstatic JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "array_dim_to_jsonb",
          "args": [
            "result",
            "dim + 1",
            "ndims",
            "dims",
            "vals",
            "nulls",
            "valcount",
            "tcategory",
            "outfuncoid"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "array_dim_to_jsonb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
          "lines": "921-948",
          "snippet": "static void\narray_dim_to_jsonb(JsonbInState *result, int dim, int ndims, int *dims, Datum *vals,\n\t\t\t\t   bool *nulls, int *valcount, JsonbTypeCategory tcategory,\n\t\t\t\t   Oid outfuncoid)\n{\n\tint\t\t\ti;\n\n\tAssert(dim < ndims);\n\n\tresult->res = pushJsonbValue(&result->parseState, WJB_BEGIN_ARRAY, NULL);\n\n\tfor (i = 1; i <= dims[dim]; i++)\n\t{\n\t\tif (dim + 1 == ndims)\n\t\t{\n\t\t\tdatum_to_jsonb(vals[*valcount], nulls[*valcount], result, tcategory,\n\t\t\t\t\t\t   outfuncoid, false);\n\t\t\t(*valcount)++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tarray_dim_to_jsonb(result, dim + 1, ndims, dims, vals, nulls,\n\t\t\t\t\t\t\t   valcount, tcategory, outfuncoid);\n\t\t}\n\t}\n\n\tresult->res = pushJsonbValue(&result->parseState, WJB_END_ARRAY, NULL);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "datum_to_jsonb",
          "args": [
            "vals[*valcount]",
            "nulls[*valcount]",
            "result",
            "tcategory",
            "outfuncoid",
            "false"
          ],
          "line": 936
        },
        "resolved": true,
        "details": {
          "function_name": "datum_to_jsonb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
          "lines": "701-914",
          "snippet": "static void\ndatum_to_jsonb(Datum val, bool is_null, JsonbInState *result,\n\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid,\n\t\t\t   bool key_scalar)\n{\n\tchar\t   *outputstr;\n\tbool\t\tnumeric_error;\n\tJsonbValue\tjb;\n\tbool\t\tscalar_jsonb = false;\n\n\tcheck_stack_depth();\n\n\t/* Convert val to a JsonbValue in jb (in most cases) */\n\tif (is_null)\n\t{\n\t\tAssert(!key_scalar);\n\t\tjb.type = jbvNull;\n\t}\n\telse if (key_scalar &&\n\t\t\t (tcategory == JSONBTYPE_ARRAY ||\n\t\t\t  tcategory == JSONBTYPE_COMPOSITE ||\n\t\t\t  tcategory == JSONBTYPE_JSON ||\n\t\t\t  tcategory == JSONBTYPE_JSONB ||\n\t\t\t  tcategory == JSONBTYPE_JSONCAST))\n\t{\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"key value must be scalar, not array, composite, or json\")));\n\t}\n\telse\n\t{\n\t\tif (tcategory == JSONBTYPE_JSONCAST)\n\t\t\tval = OidFunctionCall1(outfuncoid, val);\n\n\t\tswitch (tcategory)\n\t\t{\n\t\t\tcase JSONBTYPE_ARRAY:\n\t\t\t\tarray_to_jsonb_internal(val, result);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_COMPOSITE:\n\t\t\t\tcomposite_to_jsonb(val, result);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_BOOL:\n\t\t\t\tif (key_scalar)\n\t\t\t\t{\n\t\t\t\t\toutputstr = DatumGetBool(val) ? \"true\" : \"false\";\n\t\t\t\t\tjb.type = jbvString;\n\t\t\t\t\tjb.val.string.len = strlen(outputstr);\n\t\t\t\t\tjb.val.string.val = outputstr;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tjb.type = jbvBool;\n\t\t\t\t\tjb.val.boolean = DatumGetBool(val);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_NUMERIC:\n\t\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\t\t\t\tif (key_scalar)\n\t\t\t\t{\n\t\t\t\t\t/* always quote keys */\n\t\t\t\t\tjb.type = jbvString;\n\t\t\t\t\tjb.val.string.len = strlen(outputstr);\n\t\t\t\t\tjb.val.string.val = outputstr;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * Make it numeric if it's a valid JSON number, otherwise\n\t\t\t\t\t * a string. Invalid numeric output will always have an\n\t\t\t\t\t * 'N' or 'n' in it (I think).\n\t\t\t\t\t */\n\t\t\t\t\tnumeric_error = (strchr(outputstr, 'N') != NULL ||\n\t\t\t\t\t\t\t\t\t strchr(outputstr, 'n') != NULL);\n\t\t\t\t\tif (!numeric_error)\n\t\t\t\t\t{\n\t\t\t\t\t\tDatum\t\tnumd;\n\n\t\t\t\t\t\tjb.type = jbvNumeric;\n\t\t\t\t\t\tnumd = DirectFunctionCall3(numeric_in,\n\t\t\t\t\t\t\t\t\t\t\t\t   CStringGetDatum(outputstr),\n\t\t\t\t\t\t\t\t\t\t\t\t   ObjectIdGetDatum(InvalidOid),\n\t\t\t\t\t\t\t\t\t\t\t\t   Int32GetDatum(-1));\n\t\t\t\t\t\tjb.val.numeric = DatumGetNumeric(numd);\n\t\t\t\t\t\tpfree(outputstr);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tjb.type = jbvString;\n\t\t\t\t\t\tjb.val.string.len = strlen(outputstr);\n\t\t\t\t\t\tjb.val.string.val = outputstr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_DATE:\n\t\t\t\tjb.type = jbvString;\n\t\t\t\tjb.val.string.val = JsonEncodeDateTime(NULL, val, DATEOID);\n\t\t\t\tjb.val.string.len = strlen(jb.val.string.val);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_TIMESTAMP:\n\t\t\t\tjb.type = jbvString;\n\t\t\t\tjb.val.string.val = JsonEncodeDateTime(NULL, val, TIMESTAMPOID);\n\t\t\t\tjb.val.string.len = strlen(jb.val.string.val);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_TIMESTAMPTZ:\n\t\t\t\tjb.type = jbvString;\n\t\t\t\tjb.val.string.val = JsonEncodeDateTime(NULL, val, TIMESTAMPTZOID);\n\t\t\t\tjb.val.string.len = strlen(jb.val.string.val);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_JSONCAST:\n\t\t\tcase JSONBTYPE_JSON:\n\t\t\t\t{\n\t\t\t\t\t/* parse the json right into the existing result object */\n\t\t\t\t\tJsonLexContext *lex;\n\t\t\t\t\tJsonSemAction sem;\n\t\t\t\t\ttext\t   *json = DatumGetTextPP(val);\n\n\t\t\t\t\tlex = makeJsonLexContext(json, true);\n\n\t\t\t\t\tmemset(&sem, 0, sizeof(sem));\n\n\t\t\t\t\tsem.semstate = (void *) result;\n\n\t\t\t\t\tsem.object_start = jsonb_in_object_start;\n\t\t\t\t\tsem.array_start = jsonb_in_array_start;\n\t\t\t\t\tsem.object_end = jsonb_in_object_end;\n\t\t\t\t\tsem.array_end = jsonb_in_array_end;\n\t\t\t\t\tsem.scalar = jsonb_in_scalar;\n\t\t\t\t\tsem.object_field_start = jsonb_in_object_field_start;\n\n\t\t\t\t\tpg_parse_json(lex, &sem);\n\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_JSONB:\n\t\t\t\t{\n\t\t\t\t\tJsonb\t   *jsonb = DatumGetJsonbP(val);\n\t\t\t\t\tJsonbIterator *it;\n\n\t\t\t\t\tit = JsonbIteratorInit(&jsonb->root);\n\n\t\t\t\t\tif (JB_ROOT_IS_SCALAR(jsonb))\n\t\t\t\t\t{\n\t\t\t\t\t\t(void) JsonbIteratorNext(&it, &jb, true);\n\t\t\t\t\t\tAssert(jb.type == jbvArray);\n\t\t\t\t\t\t(void) JsonbIteratorNext(&it, &jb, true);\n\t\t\t\t\t\tscalar_jsonb = true;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tJsonbIteratorToken type;\n\n\t\t\t\t\t\twhile ((type = JsonbIteratorNext(&it, &jb, false))\n\t\t\t\t\t\t\t   != WJB_DONE)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (type == WJB_END_ARRAY || type == WJB_END_OBJECT ||\n\t\t\t\t\t\t\t\ttype == WJB_BEGIN_ARRAY || type == WJB_BEGIN_OBJECT)\n\t\t\t\t\t\t\t\tresult->res = pushJsonbValue(&result->parseState,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t type, NULL);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tresult->res = pushJsonbValue(&result->parseState,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t type, &jb);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\t\t\t\tjb.type = jbvString;\n\t\t\t\tjb.val.string.len = checkStringLen(strlen(outputstr));\n\t\t\t\tjb.val.string.val = outputstr;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Now insert jb into result, unless we did it recursively */\n\tif (!is_null && !scalar_jsonb &&\n\t\ttcategory >= JSONBTYPE_JSON && tcategory <= JSONBTYPE_JSONCAST)\n\t{\n\t\t/* work has been done recursively */\n\t\treturn;\n\t}\n\telse if (result->parseState == NULL)\n\t{\n\t\t/* single root scalar */\n\t\tJsonbValue\tva;\n\n\t\tva.type = jbvArray;\n\t\tva.val.array.rawScalar = true;\n\t\tva.val.array.nElems = 1;\n\n\t\tresult->res = pushJsonbValue(&result->parseState, WJB_BEGIN_ARRAY, &va);\n\t\tresult->res = pushJsonbValue(&result->parseState, WJB_ELEM, &jb);\n\t\tresult->res = pushJsonbValue(&result->parseState, WJB_END_ARRAY, NULL);\n\t}\n\telse\n\t{\n\t\tJsonbValue *o = &result->parseState->contVal;\n\n\t\tswitch (o->type)\n\t\t{\n\t\t\tcase jbvArray:\n\t\t\t\tresult->res = pushJsonbValue(&result->parseState, WJB_ELEM, &jb);\n\t\t\t\tbreak;\n\t\t\tcase jbvObject:\n\t\t\t\tresult->res = pushJsonbValue(&result->parseState,\n\t\t\t\t\t\t\t\t\t\t\t key_scalar ? WJB_KEY : WJB_VALUE,\n\t\t\t\t\t\t\t\t\t\t\t &jb);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unexpected parent of nested structure\");\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"miscadmin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline Datum jsonb_from_cstring(char *json, int len);",
            "static size_t checkStringLen(size_t len);",
            "static void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);",
            "static void composite_to_jsonb(Datum composite, JsonbInState *result);",
            "static void array_dim_to_jsonb(JsonbInState *result, int dim, int ndims, int *dims,\n\t\t\t\t   Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid);",
            "static void array_to_jsonb_internal(Datum array, JsonbInState *result);",
            "static void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);",
            "static void datum_to_jsonb(Datum val, bool is_null, JsonbInState *result,\n\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid,\n\t\t\t   bool key_scalar);",
            "static void add_jsonb(Datum val, bool is_null, JsonbInState *result,\n\t\t  Oid val_type, bool key_scalar);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic inline Datum jsonb_from_cstring(char *json, int len);\nstatic size_t checkStringLen(size_t len);\nstatic void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);\nstatic void composite_to_jsonb(Datum composite, JsonbInState *result);\nstatic void array_dim_to_jsonb(JsonbInState *result, int dim, int ndims, int *dims,\n\t\t\t\t   Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid);\nstatic void array_to_jsonb_internal(Datum array, JsonbInState *result);\nstatic void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);\nstatic void datum_to_jsonb(Datum val, bool is_null, JsonbInState *result,\n\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid,\n\t\t\t   bool key_scalar);\nstatic void add_jsonb(Datum val, bool is_null, JsonbInState *result,\n\t\t  Oid val_type, bool key_scalar);\n\nstatic void\ndatum_to_jsonb(Datum val, bool is_null, JsonbInState *result,\n\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid,\n\t\t\t   bool key_scalar)\n{\n\tchar\t   *outputstr;\n\tbool\t\tnumeric_error;\n\tJsonbValue\tjb;\n\tbool\t\tscalar_jsonb = false;\n\n\tcheck_stack_depth();\n\n\t/* Convert val to a JsonbValue in jb (in most cases) */\n\tif (is_null)\n\t{\n\t\tAssert(!key_scalar);\n\t\tjb.type = jbvNull;\n\t}\n\telse if (key_scalar &&\n\t\t\t (tcategory == JSONBTYPE_ARRAY ||\n\t\t\t  tcategory == JSONBTYPE_COMPOSITE ||\n\t\t\t  tcategory == JSONBTYPE_JSON ||\n\t\t\t  tcategory == JSONBTYPE_JSONB ||\n\t\t\t  tcategory == JSONBTYPE_JSONCAST))\n\t{\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"key value must be scalar, not array, composite, or json\")));\n\t}\n\telse\n\t{\n\t\tif (tcategory == JSONBTYPE_JSONCAST)\n\t\t\tval = OidFunctionCall1(outfuncoid, val);\n\n\t\tswitch (tcategory)\n\t\t{\n\t\t\tcase JSONBTYPE_ARRAY:\n\t\t\t\tarray_to_jsonb_internal(val, result);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_COMPOSITE:\n\t\t\t\tcomposite_to_jsonb(val, result);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_BOOL:\n\t\t\t\tif (key_scalar)\n\t\t\t\t{\n\t\t\t\t\toutputstr = DatumGetBool(val) ? \"true\" : \"false\";\n\t\t\t\t\tjb.type = jbvString;\n\t\t\t\t\tjb.val.string.len = strlen(outputstr);\n\t\t\t\t\tjb.val.string.val = outputstr;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tjb.type = jbvBool;\n\t\t\t\t\tjb.val.boolean = DatumGetBool(val);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_NUMERIC:\n\t\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\t\t\t\tif (key_scalar)\n\t\t\t\t{\n\t\t\t\t\t/* always quote keys */\n\t\t\t\t\tjb.type = jbvString;\n\t\t\t\t\tjb.val.string.len = strlen(outputstr);\n\t\t\t\t\tjb.val.string.val = outputstr;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * Make it numeric if it's a valid JSON number, otherwise\n\t\t\t\t\t * a string. Invalid numeric output will always have an\n\t\t\t\t\t * 'N' or 'n' in it (I think).\n\t\t\t\t\t */\n\t\t\t\t\tnumeric_error = (strchr(outputstr, 'N') != NULL ||\n\t\t\t\t\t\t\t\t\t strchr(outputstr, 'n') != NULL);\n\t\t\t\t\tif (!numeric_error)\n\t\t\t\t\t{\n\t\t\t\t\t\tDatum\t\tnumd;\n\n\t\t\t\t\t\tjb.type = jbvNumeric;\n\t\t\t\t\t\tnumd = DirectFunctionCall3(numeric_in,\n\t\t\t\t\t\t\t\t\t\t\t\t   CStringGetDatum(outputstr),\n\t\t\t\t\t\t\t\t\t\t\t\t   ObjectIdGetDatum(InvalidOid),\n\t\t\t\t\t\t\t\t\t\t\t\t   Int32GetDatum(-1));\n\t\t\t\t\t\tjb.val.numeric = DatumGetNumeric(numd);\n\t\t\t\t\t\tpfree(outputstr);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tjb.type = jbvString;\n\t\t\t\t\t\tjb.val.string.len = strlen(outputstr);\n\t\t\t\t\t\tjb.val.string.val = outputstr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_DATE:\n\t\t\t\tjb.type = jbvString;\n\t\t\t\tjb.val.string.val = JsonEncodeDateTime(NULL, val, DATEOID);\n\t\t\t\tjb.val.string.len = strlen(jb.val.string.val);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_TIMESTAMP:\n\t\t\t\tjb.type = jbvString;\n\t\t\t\tjb.val.string.val = JsonEncodeDateTime(NULL, val, TIMESTAMPOID);\n\t\t\t\tjb.val.string.len = strlen(jb.val.string.val);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_TIMESTAMPTZ:\n\t\t\t\tjb.type = jbvString;\n\t\t\t\tjb.val.string.val = JsonEncodeDateTime(NULL, val, TIMESTAMPTZOID);\n\t\t\t\tjb.val.string.len = strlen(jb.val.string.val);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_JSONCAST:\n\t\t\tcase JSONBTYPE_JSON:\n\t\t\t\t{\n\t\t\t\t\t/* parse the json right into the existing result object */\n\t\t\t\t\tJsonLexContext *lex;\n\t\t\t\t\tJsonSemAction sem;\n\t\t\t\t\ttext\t   *json = DatumGetTextPP(val);\n\n\t\t\t\t\tlex = makeJsonLexContext(json, true);\n\n\t\t\t\t\tmemset(&sem, 0, sizeof(sem));\n\n\t\t\t\t\tsem.semstate = (void *) result;\n\n\t\t\t\t\tsem.object_start = jsonb_in_object_start;\n\t\t\t\t\tsem.array_start = jsonb_in_array_start;\n\t\t\t\t\tsem.object_end = jsonb_in_object_end;\n\t\t\t\t\tsem.array_end = jsonb_in_array_end;\n\t\t\t\t\tsem.scalar = jsonb_in_scalar;\n\t\t\t\t\tsem.object_field_start = jsonb_in_object_field_start;\n\n\t\t\t\t\tpg_parse_json(lex, &sem);\n\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_JSONB:\n\t\t\t\t{\n\t\t\t\t\tJsonb\t   *jsonb = DatumGetJsonbP(val);\n\t\t\t\t\tJsonbIterator *it;\n\n\t\t\t\t\tit = JsonbIteratorInit(&jsonb->root);\n\n\t\t\t\t\tif (JB_ROOT_IS_SCALAR(jsonb))\n\t\t\t\t\t{\n\t\t\t\t\t\t(void) JsonbIteratorNext(&it, &jb, true);\n\t\t\t\t\t\tAssert(jb.type == jbvArray);\n\t\t\t\t\t\t(void) JsonbIteratorNext(&it, &jb, true);\n\t\t\t\t\t\tscalar_jsonb = true;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tJsonbIteratorToken type;\n\n\t\t\t\t\t\twhile ((type = JsonbIteratorNext(&it, &jb, false))\n\t\t\t\t\t\t\t   != WJB_DONE)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (type == WJB_END_ARRAY || type == WJB_END_OBJECT ||\n\t\t\t\t\t\t\t\ttype == WJB_BEGIN_ARRAY || type == WJB_BEGIN_OBJECT)\n\t\t\t\t\t\t\t\tresult->res = pushJsonbValue(&result->parseState,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t type, NULL);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tresult->res = pushJsonbValue(&result->parseState,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t type, &jb);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\t\t\t\tjb.type = jbvString;\n\t\t\t\tjb.val.string.len = checkStringLen(strlen(outputstr));\n\t\t\t\tjb.val.string.val = outputstr;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Now insert jb into result, unless we did it recursively */\n\tif (!is_null && !scalar_jsonb &&\n\t\ttcategory >= JSONBTYPE_JSON && tcategory <= JSONBTYPE_JSONCAST)\n\t{\n\t\t/* work has been done recursively */\n\t\treturn;\n\t}\n\telse if (result->parseState == NULL)\n\t{\n\t\t/* single root scalar */\n\t\tJsonbValue\tva;\n\n\t\tva.type = jbvArray;\n\t\tva.val.array.rawScalar = true;\n\t\tva.val.array.nElems = 1;\n\n\t\tresult->res = pushJsonbValue(&result->parseState, WJB_BEGIN_ARRAY, &va);\n\t\tresult->res = pushJsonbValue(&result->parseState, WJB_ELEM, &jb);\n\t\tresult->res = pushJsonbValue(&result->parseState, WJB_END_ARRAY, NULL);\n\t}\n\telse\n\t{\n\t\tJsonbValue *o = &result->parseState->contVal;\n\n\t\tswitch (o->type)\n\t\t{\n\t\t\tcase jbvArray:\n\t\t\t\tresult->res = pushJsonbValue(&result->parseState, WJB_ELEM, &jb);\n\t\t\t\tbreak;\n\t\t\tcase jbvObject:\n\t\t\t\tresult->res = pushJsonbValue(&result->parseState,\n\t\t\t\t\t\t\t\t\t\t\t key_scalar ? WJB_KEY : WJB_VALUE,\n\t\t\t\t\t\t\t\t\t\t\t &jb);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unexpected parent of nested structure\");\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "dim < ndims"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);\nstatic void composite_to_jsonb(Datum composite, JsonbInState *result);\nstatic void array_dim_to_jsonb(JsonbInState *result, int dim, int ndims, int *dims,\n\t\t\t\t   Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid);\nstatic void array_to_jsonb_internal(Datum array, JsonbInState *result);\nstatic void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);\n\nstatic void\narray_dim_to_jsonb(JsonbInState *result, int dim, int ndims, int *dims, Datum *vals,\n\t\t\t\t   bool *nulls, int *valcount, JsonbTypeCategory tcategory,\n\t\t\t\t   Oid outfuncoid)\n{\n\tint\t\t\ti;\n\n\tAssert(dim < ndims);\n\n\tresult->res = pushJsonbValue(&result->parseState, WJB_BEGIN_ARRAY, NULL);\n\n\tfor (i = 1; i <= dims[dim]; i++)\n\t{\n\t\tif (dim + 1 == ndims)\n\t\t{\n\t\t\tdatum_to_jsonb(vals[*valcount], nulls[*valcount], result, tcategory,\n\t\t\t\t\t\t   outfuncoid, false);\n\t\t\t(*valcount)++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tarray_dim_to_jsonb(result, dim + 1, ndims, dims, vals, nulls,\n\t\t\t\t\t\t\t   valcount, tcategory, outfuncoid);\n\t\t}\n\t}\n\n\tresult->res = pushJsonbValue(&result->parseState, WJB_END_ARRAY, NULL);\n}"
  },
  {
    "function_name": "datum_to_jsonb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
    "lines": "701-914",
    "snippet": "static void\ndatum_to_jsonb(Datum val, bool is_null, JsonbInState *result,\n\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid,\n\t\t\t   bool key_scalar)\n{\n\tchar\t   *outputstr;\n\tbool\t\tnumeric_error;\n\tJsonbValue\tjb;\n\tbool\t\tscalar_jsonb = false;\n\n\tcheck_stack_depth();\n\n\t/* Convert val to a JsonbValue in jb (in most cases) */\n\tif (is_null)\n\t{\n\t\tAssert(!key_scalar);\n\t\tjb.type = jbvNull;\n\t}\n\telse if (key_scalar &&\n\t\t\t (tcategory == JSONBTYPE_ARRAY ||\n\t\t\t  tcategory == JSONBTYPE_COMPOSITE ||\n\t\t\t  tcategory == JSONBTYPE_JSON ||\n\t\t\t  tcategory == JSONBTYPE_JSONB ||\n\t\t\t  tcategory == JSONBTYPE_JSONCAST))\n\t{\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"key value must be scalar, not array, composite, or json\")));\n\t}\n\telse\n\t{\n\t\tif (tcategory == JSONBTYPE_JSONCAST)\n\t\t\tval = OidFunctionCall1(outfuncoid, val);\n\n\t\tswitch (tcategory)\n\t\t{\n\t\t\tcase JSONBTYPE_ARRAY:\n\t\t\t\tarray_to_jsonb_internal(val, result);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_COMPOSITE:\n\t\t\t\tcomposite_to_jsonb(val, result);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_BOOL:\n\t\t\t\tif (key_scalar)\n\t\t\t\t{\n\t\t\t\t\toutputstr = DatumGetBool(val) ? \"true\" : \"false\";\n\t\t\t\t\tjb.type = jbvString;\n\t\t\t\t\tjb.val.string.len = strlen(outputstr);\n\t\t\t\t\tjb.val.string.val = outputstr;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tjb.type = jbvBool;\n\t\t\t\t\tjb.val.boolean = DatumGetBool(val);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_NUMERIC:\n\t\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\t\t\t\tif (key_scalar)\n\t\t\t\t{\n\t\t\t\t\t/* always quote keys */\n\t\t\t\t\tjb.type = jbvString;\n\t\t\t\t\tjb.val.string.len = strlen(outputstr);\n\t\t\t\t\tjb.val.string.val = outputstr;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * Make it numeric if it's a valid JSON number, otherwise\n\t\t\t\t\t * a string. Invalid numeric output will always have an\n\t\t\t\t\t * 'N' or 'n' in it (I think).\n\t\t\t\t\t */\n\t\t\t\t\tnumeric_error = (strchr(outputstr, 'N') != NULL ||\n\t\t\t\t\t\t\t\t\t strchr(outputstr, 'n') != NULL);\n\t\t\t\t\tif (!numeric_error)\n\t\t\t\t\t{\n\t\t\t\t\t\tDatum\t\tnumd;\n\n\t\t\t\t\t\tjb.type = jbvNumeric;\n\t\t\t\t\t\tnumd = DirectFunctionCall3(numeric_in,\n\t\t\t\t\t\t\t\t\t\t\t\t   CStringGetDatum(outputstr),\n\t\t\t\t\t\t\t\t\t\t\t\t   ObjectIdGetDatum(InvalidOid),\n\t\t\t\t\t\t\t\t\t\t\t\t   Int32GetDatum(-1));\n\t\t\t\t\t\tjb.val.numeric = DatumGetNumeric(numd);\n\t\t\t\t\t\tpfree(outputstr);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tjb.type = jbvString;\n\t\t\t\t\t\tjb.val.string.len = strlen(outputstr);\n\t\t\t\t\t\tjb.val.string.val = outputstr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_DATE:\n\t\t\t\tjb.type = jbvString;\n\t\t\t\tjb.val.string.val = JsonEncodeDateTime(NULL, val, DATEOID);\n\t\t\t\tjb.val.string.len = strlen(jb.val.string.val);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_TIMESTAMP:\n\t\t\t\tjb.type = jbvString;\n\t\t\t\tjb.val.string.val = JsonEncodeDateTime(NULL, val, TIMESTAMPOID);\n\t\t\t\tjb.val.string.len = strlen(jb.val.string.val);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_TIMESTAMPTZ:\n\t\t\t\tjb.type = jbvString;\n\t\t\t\tjb.val.string.val = JsonEncodeDateTime(NULL, val, TIMESTAMPTZOID);\n\t\t\t\tjb.val.string.len = strlen(jb.val.string.val);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_JSONCAST:\n\t\t\tcase JSONBTYPE_JSON:\n\t\t\t\t{\n\t\t\t\t\t/* parse the json right into the existing result object */\n\t\t\t\t\tJsonLexContext *lex;\n\t\t\t\t\tJsonSemAction sem;\n\t\t\t\t\ttext\t   *json = DatumGetTextPP(val);\n\n\t\t\t\t\tlex = makeJsonLexContext(json, true);\n\n\t\t\t\t\tmemset(&sem, 0, sizeof(sem));\n\n\t\t\t\t\tsem.semstate = (void *) result;\n\n\t\t\t\t\tsem.object_start = jsonb_in_object_start;\n\t\t\t\t\tsem.array_start = jsonb_in_array_start;\n\t\t\t\t\tsem.object_end = jsonb_in_object_end;\n\t\t\t\t\tsem.array_end = jsonb_in_array_end;\n\t\t\t\t\tsem.scalar = jsonb_in_scalar;\n\t\t\t\t\tsem.object_field_start = jsonb_in_object_field_start;\n\n\t\t\t\t\tpg_parse_json(lex, &sem);\n\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_JSONB:\n\t\t\t\t{\n\t\t\t\t\tJsonb\t   *jsonb = DatumGetJsonbP(val);\n\t\t\t\t\tJsonbIterator *it;\n\n\t\t\t\t\tit = JsonbIteratorInit(&jsonb->root);\n\n\t\t\t\t\tif (JB_ROOT_IS_SCALAR(jsonb))\n\t\t\t\t\t{\n\t\t\t\t\t\t(void) JsonbIteratorNext(&it, &jb, true);\n\t\t\t\t\t\tAssert(jb.type == jbvArray);\n\t\t\t\t\t\t(void) JsonbIteratorNext(&it, &jb, true);\n\t\t\t\t\t\tscalar_jsonb = true;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tJsonbIteratorToken type;\n\n\t\t\t\t\t\twhile ((type = JsonbIteratorNext(&it, &jb, false))\n\t\t\t\t\t\t\t   != WJB_DONE)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (type == WJB_END_ARRAY || type == WJB_END_OBJECT ||\n\t\t\t\t\t\t\t\ttype == WJB_BEGIN_ARRAY || type == WJB_BEGIN_OBJECT)\n\t\t\t\t\t\t\t\tresult->res = pushJsonbValue(&result->parseState,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t type, NULL);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tresult->res = pushJsonbValue(&result->parseState,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t type, &jb);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\t\t\t\tjb.type = jbvString;\n\t\t\t\tjb.val.string.len = checkStringLen(strlen(outputstr));\n\t\t\t\tjb.val.string.val = outputstr;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Now insert jb into result, unless we did it recursively */\n\tif (!is_null && !scalar_jsonb &&\n\t\ttcategory >= JSONBTYPE_JSON && tcategory <= JSONBTYPE_JSONCAST)\n\t{\n\t\t/* work has been done recursively */\n\t\treturn;\n\t}\n\telse if (result->parseState == NULL)\n\t{\n\t\t/* single root scalar */\n\t\tJsonbValue\tva;\n\n\t\tva.type = jbvArray;\n\t\tva.val.array.rawScalar = true;\n\t\tva.val.array.nElems = 1;\n\n\t\tresult->res = pushJsonbValue(&result->parseState, WJB_BEGIN_ARRAY, &va);\n\t\tresult->res = pushJsonbValue(&result->parseState, WJB_ELEM, &jb);\n\t\tresult->res = pushJsonbValue(&result->parseState, WJB_END_ARRAY, NULL);\n\t}\n\telse\n\t{\n\t\tJsonbValue *o = &result->parseState->contVal;\n\n\t\tswitch (o->type)\n\t\t{\n\t\t\tcase jbvArray:\n\t\t\t\tresult->res = pushJsonbValue(&result->parseState, WJB_ELEM, &jb);\n\t\t\t\tbreak;\n\t\t\tcase jbvObject:\n\t\t\t\tresult->res = pushJsonbValue(&result->parseState,\n\t\t\t\t\t\t\t\t\t\t\t key_scalar ? WJB_KEY : WJB_VALUE,\n\t\t\t\t\t\t\t\t\t\t\t &jb);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unexpected parent of nested structure\");\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"miscadmin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static inline Datum jsonb_from_cstring(char *json, int len);",
      "static size_t checkStringLen(size_t len);",
      "static void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);",
      "static void composite_to_jsonb(Datum composite, JsonbInState *result);",
      "static void array_dim_to_jsonb(JsonbInState *result, int dim, int ndims, int *dims,\n\t\t\t\t   Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid);",
      "static void array_to_jsonb_internal(Datum array, JsonbInState *result);",
      "static void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);",
      "static void datum_to_jsonb(Datum val, bool is_null, JsonbInState *result,\n\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid,\n\t\t\t   bool key_scalar);",
      "static void add_jsonb(Datum val, bool is_null, JsonbInState *result,\n\t\t  Oid val_type, bool key_scalar);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unexpected parent of nested structure\""
          ],
          "line": 911
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pushJsonbValue",
          "args": [
            "&result->parseState",
            "key_scalar ? WJB_KEY : WJB_VALUE",
            "&jb"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "pushJsonbValueScalar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "545-629",
          "snippet": "static JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);",
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbParseState *pushState(JsonbParseState **pstate);",
            "static void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void uniqueifyJsonbObject(JsonbValue *object);",
            "static JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\nstatic void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\nstatic JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);\n\nstatic JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "checkStringLen",
          "args": [
            "strlen(outputstr)"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "checkStringLen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
          "lines": "252-263",
          "snippet": "static size_t\ncheckStringLen(size_t len)\n{\n\tif (len > JENTRY_OFFLENMASK)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"string too long to represent as jsonb string\"),\n\t\t\t\t errdetail(\"Due to an implementation restriction, jsonb strings cannot exceed %d bytes.\",\n\t\t\t\t\t\t   JENTRY_OFFLENMASK)));\n\n\treturn len;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"miscadmin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline Datum jsonb_from_cstring(char *json, int len);",
            "static size_t checkStringLen(size_t len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic inline Datum jsonb_from_cstring(char *json, int len);\nstatic size_t checkStringLen(size_t len);\n\nstatic size_t\ncheckStringLen(size_t len)\n{\n\tif (len > JENTRY_OFFLENMASK)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"string too long to represent as jsonb string\"),\n\t\t\t\t errdetail(\"Due to an implementation restriction, jsonb strings cannot exceed %d bytes.\",\n\t\t\t\t\t\t   JENTRY_OFFLENMASK)));\n\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "outputstr"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidOutputFunctionCall",
          "args": [
            "outfuncoid",
            "val"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "OidOutputFunctionCall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1832-1839",
          "snippet": "char *\nOidOutputFunctionCall(Oid functionId, Datum val)\n{\n\tFmgrInfo\tflinfo;\n\n\tfmgr_info(functionId, &flinfo);\n\treturn OutputFunctionCall(&flinfo, val);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nchar *\nOidOutputFunctionCall(Oid functionId, Datum val)\n{\n\tFmgrInfo\tflinfo;\n\n\tfmgr_info(functionId, &flinfo);\n\treturn OutputFunctionCall(&flinfo, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonbIteratorNext",
          "args": [
            "&it",
            "&jb",
            "false"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbIteratorNext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "753-894",
          "snippet": "JsonbIteratorToken\nJsonbIteratorNext(JsonbIterator **it, JsonbValue *val, bool skipNested)\n{\n\tif (*it == NULL)\n\t\treturn WJB_DONE;\n\n\t/*\n\t * When stepping into a nested container, we jump back here to start\n\t * processing the child. We will not recurse further in one call, because\n\t * processing the child will always begin in JBI_ARRAY_START or\n\t * JBI_OBJECT_START state.\n\t */\nrecurse:\n\tswitch ((*it)->state)\n\t{\n\t\tcase JBI_ARRAY_START:\n\t\t\t/* Set v to array on first array call */\n\t\t\tval->type = jbvArray;\n\t\t\tval->val.array.nElems = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.array.elems is not actually set, because we aren't doing\n\t\t\t * a full conversion\n\t\t\t */\n\t\t\tval->val.array.rawScalar = (*it)->isScalar;\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = 0;\t/* not actually used */\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_ARRAY_ELEM;\n\t\t\treturn WJB_BEGIN_ARRAY;\n\n\t\tcase JBI_ARRAY_ELEM:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All elements within array already processed.  Report this\n\t\t\t\t * to caller, and give it back original parent iterator (which\n\t\t\t\t * independently tracks iteration progress at its level of\n\t\t\t\t * nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_ARRAY;\n\t\t\t}\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t/* Recurse into container. */\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scalar item in array, or a container and caller didn't want\n\t\t\t\t * us to recurse into it.\n\t\t\t\t */\n\t\t\t\treturn WJB_ELEM;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_START:\n\t\t\t/* Set v to object on first object call */\n\t\t\tval->type = jbvObject;\n\t\t\tval->val.object.nPairs = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.object.pairs is not actually set, because we aren't\n\t\t\t * doing a full conversion\n\t\t\t */\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = getJsonbOffset((*it)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t   (*it)->nElems);\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\t\t\treturn WJB_BEGIN_OBJECT;\n\n\t\tcase JBI_OBJECT_KEY:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All pairs within object already processed.  Report this to\n\t\t\t\t * caller, and give it back original containing iterator\n\t\t\t\t * (which independently tracks iteration progress at its level\n\t\t\t\t * of nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_OBJECT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Return key of a key/value pair.  */\n\t\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t\t   val);\n\t\t\t\tif (val->type != jbvString)\n\t\t\t\t\telog(ERROR, \"unexpected jsonb type as object key\");\n\n\t\t\t\t/* Set state for next call */\n\t\t\t\t(*it)->state = JBI_OBJECT_VALUE;\n\t\t\t\treturn WJB_KEY;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_VALUE:\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex + (*it)->nElems,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curValueOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curValueOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex + (*it)->nElems]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\t/*\n\t\t\t * Value may be a container, in which case we recurse with new,\n\t\t\t * child iterator (unless the caller asked not to, by passing\n\t\t\t * skipNested).\n\t\t\t */\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn WJB_VALUE;\n\t}\n\n\telog(ERROR, \"invalid iterator state\");\n\treturn -1;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbIterator *freeAndGetParent(JsonbIterator *it);",
            "static void uniqueifyJsonbObject(JsonbValue *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbIterator *freeAndGetParent(JsonbIterator *it);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\n\nJsonbIteratorToken\nJsonbIteratorNext(JsonbIterator **it, JsonbValue *val, bool skipNested)\n{\n\tif (*it == NULL)\n\t\treturn WJB_DONE;\n\n\t/*\n\t * When stepping into a nested container, we jump back here to start\n\t * processing the child. We will not recurse further in one call, because\n\t * processing the child will always begin in JBI_ARRAY_START or\n\t * JBI_OBJECT_START state.\n\t */\nrecurse:\n\tswitch ((*it)->state)\n\t{\n\t\tcase JBI_ARRAY_START:\n\t\t\t/* Set v to array on first array call */\n\t\t\tval->type = jbvArray;\n\t\t\tval->val.array.nElems = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.array.elems is not actually set, because we aren't doing\n\t\t\t * a full conversion\n\t\t\t */\n\t\t\tval->val.array.rawScalar = (*it)->isScalar;\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = 0;\t/* not actually used */\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_ARRAY_ELEM;\n\t\t\treturn WJB_BEGIN_ARRAY;\n\n\t\tcase JBI_ARRAY_ELEM:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All elements within array already processed.  Report this\n\t\t\t\t * to caller, and give it back original parent iterator (which\n\t\t\t\t * independently tracks iteration progress at its level of\n\t\t\t\t * nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_ARRAY;\n\t\t\t}\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t/* Recurse into container. */\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scalar item in array, or a container and caller didn't want\n\t\t\t\t * us to recurse into it.\n\t\t\t\t */\n\t\t\t\treturn WJB_ELEM;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_START:\n\t\t\t/* Set v to object on first object call */\n\t\t\tval->type = jbvObject;\n\t\t\tval->val.object.nPairs = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.object.pairs is not actually set, because we aren't\n\t\t\t * doing a full conversion\n\t\t\t */\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = getJsonbOffset((*it)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t   (*it)->nElems);\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\t\t\treturn WJB_BEGIN_OBJECT;\n\n\t\tcase JBI_OBJECT_KEY:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All pairs within object already processed.  Report this to\n\t\t\t\t * caller, and give it back original containing iterator\n\t\t\t\t * (which independently tracks iteration progress at its level\n\t\t\t\t * of nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_OBJECT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Return key of a key/value pair.  */\n\t\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t\t   val);\n\t\t\t\tif (val->type != jbvString)\n\t\t\t\t\telog(ERROR, \"unexpected jsonb type as object key\");\n\n\t\t\t\t/* Set state for next call */\n\t\t\t\t(*it)->state = JBI_OBJECT_VALUE;\n\t\t\t\treturn WJB_KEY;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_VALUE:\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex + (*it)->nElems,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curValueOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curValueOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex + (*it)->nElems]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\t/*\n\t\t\t * Value may be a container, in which case we recurse with new,\n\t\t\t * child iterator (unless the caller asked not to, by passing\n\t\t\t * skipNested).\n\t\t\t */\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn WJB_VALUE;\n\t}\n\n\telog(ERROR, \"invalid iterator state\");\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "jb.type == jbvArray"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JB_ROOT_IS_SCALAR",
          "args": [
            "jsonb"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JsonbIteratorInit",
          "args": [
            "&jsonb->root"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbIteratorInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "717-721",
          "snippet": "JsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nJsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetJsonbP",
          "args": [
            "val"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_parse_json",
          "args": [
            "lex",
            "&sem"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "pg_parse_json",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "331-356",
          "snippet": "void\npg_parse_json(JsonLexContext *lex, JsonSemAction *sem)\n{\n\tJsonTokenType tok;\n\n\t/* get the initial token */\n\tjson_lex(lex);\n\n\ttok = lex_peek(lex);\n\n\t/* parse by recursive descent */\n\tswitch (tok)\n\t{\n\t\tcase JSON_TOKEN_OBJECT_START:\n\t\t\tparse_object(lex, sem);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_ARRAY_START:\n\t\t\tparse_array(lex, sem);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_scalar(lex, sem); /* json can be a bare scalar */\n\t}\n\n\tlex_expect(JSON_PARSE_END, lex, JSON_TOKEN_END);\n\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_object(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_array(JsonLexContext *lex, JsonSemAction *sem);",
            "static int\treport_json_context(JsonLexContext *lex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array(JsonLexContext *lex, JsonSemAction *sem);\nstatic int\treport_json_context(JsonLexContext *lex);\n\nvoid\npg_parse_json(JsonLexContext *lex, JsonSemAction *sem)\n{\n\tJsonTokenType tok;\n\n\t/* get the initial token */\n\tjson_lex(lex);\n\n\ttok = lex_peek(lex);\n\n\t/* parse by recursive descent */\n\tswitch (tok)\n\t{\n\t\tcase JSON_TOKEN_OBJECT_START:\n\t\t\tparse_object(lex, sem);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_ARRAY_START:\n\t\t\tparse_array(lex, sem);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_scalar(lex, sem); /* json can be a bare scalar */\n\t}\n\n\tlex_expect(JSON_PARSE_END, lex, JSON_TOKEN_END);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&sem",
            "0",
            "sizeof(sem)"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeJsonLexContext",
          "args": [
            "json",
            "true"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "makeJsonLexContext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "300-306",
          "snippet": "JsonLexContext *\nmakeJsonLexContext(text *json, bool need_escapes)\n{\n\treturn makeJsonLexContextCstringLen(VARDATA_ANY(json),\n\t\t\t\t\t\t\t\t\t\tVARSIZE_ANY_EXHDR(json),\n\t\t\t\t\t\t\t\t\t\tneed_escapes);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nJsonLexContext *\nmakeJsonLexContext(text *json, bool need_escapes)\n{\n\treturn makeJsonLexContextCstringLen(VARDATA_ANY(json),\n\t\t\t\t\t\t\t\t\t\tVARSIZE_ANY_EXHDR(json),\n\t\t\t\t\t\t\t\t\t\tneed_escapes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetTextPP",
          "args": [
            "val"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JsonEncodeDateTime",
          "args": [
            "NULL",
            "val",
            "TIMESTAMPTZOID"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "JsonEncodeDateTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "1555-1650",
          "snippet": "char *\nJsonEncodeDateTime(char *buf, Datum value, Oid typid)\n{\n\tif (!buf)\n\t\tbuf = palloc(MAXDATELEN + 1);\n\n\tswitch (typid)\n\t{\n\t\tcase DATEOID:\n\t\t\t{\n\t\t\t\tDateADT\t\tdate;\n\t\t\t\tstruct pg_tm tm;\n\n\t\t\t\tdate = DatumGetDateADT(value);\n\n\t\t\t\t/* Same as date_out(), but forcing DateStyle */\n\t\t\t\tif (DATE_NOT_FINITE(date))\n\t\t\t\t\tEncodeSpecialDate(date, buf);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tj2date(date + POSTGRES_EPOCH_JDATE,\n\t\t\t\t\t\t   &(tm.tm_year), &(tm.tm_mon), &(tm.tm_mday));\n\t\t\t\t\tEncodeDateOnly(&tm, USE_XSD_DATES, buf);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIMEOID:\n\t\t\t{\n\t\t\t\tTimeADT\t\ttime = DatumGetTimeADT(value);\n\t\t\t\tstruct pg_tm tt,\n\t\t\t\t\t\t   *tm = &tt;\n\t\t\t\tfsec_t\t\tfsec;\n\n\t\t\t\t/* Same as time_out(), but forcing DateStyle */\n\t\t\t\ttime2tm(time, tm, &fsec);\n\t\t\t\tEncodeTimeOnly(tm, fsec, false, 0, USE_XSD_DATES, buf);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIMETZOID:\n\t\t\t{\n\t\t\t\tTimeTzADT  *time = DatumGetTimeTzADTP(value);\n\t\t\t\tstruct pg_tm tt,\n\t\t\t\t\t\t   *tm = &tt;\n\t\t\t\tfsec_t\t\tfsec;\n\t\t\t\tint\t\t\ttz;\n\n\t\t\t\t/* Same as timetz_out(), but forcing DateStyle */\n\t\t\t\ttimetz2tm(time, tm, &fsec, &tz);\n\t\t\t\tEncodeTimeOnly(tm, fsec, true, tz, USE_XSD_DATES, buf);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIMESTAMPOID:\n\t\t\t{\n\t\t\t\tTimestamp\ttimestamp;\n\t\t\t\tstruct pg_tm tm;\n\t\t\t\tfsec_t\t\tfsec;\n\n\t\t\t\ttimestamp = DatumGetTimestamp(value);\n\t\t\t\t/* Same as timestamp_out(), but forcing DateStyle */\n\t\t\t\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\t\t\t\tEncodeSpecialTimestamp(timestamp, buf);\n\t\t\t\telse if (timestamp2tm(timestamp, NULL, &tm, &fsec, NULL, NULL) == 0)\n\t\t\t\t\tEncodeDateTime(&tm, fsec, false, 0, NULL, USE_XSD_DATES, buf);\n\t\t\t\telse\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIMESTAMPTZOID:\n\t\t\t{\n\t\t\t\tTimestampTz timestamp;\n\t\t\t\tstruct pg_tm tm;\n\t\t\t\tint\t\t\ttz;\n\t\t\t\tfsec_t\t\tfsec;\n\t\t\t\tconst char *tzn = NULL;\n\n\t\t\t\ttimestamp = DatumGetTimestampTz(value);\n\t\t\t\t/* Same as timestamptz_out(), but forcing DateStyle */\n\t\t\t\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\t\t\t\tEncodeSpecialTimestamp(timestamp, buf);\n\t\t\t\telse if (timestamp2tm(timestamp, &tz, &tm, &fsec, &tzn, NULL) == 0)\n\t\t\t\t\tEncodeDateTime(&tm, fsec, true, tz, tzn, USE_XSD_DATES, buf);\n\t\t\t\telse\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unknown jsonb value datetime type oid %d\", typid);\n\t\t\treturn NULL;\n\t}\n\n\treturn buf;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nchar *\nJsonEncodeDateTime(char *buf, Datum value, Oid typid)\n{\n\tif (!buf)\n\t\tbuf = palloc(MAXDATELEN + 1);\n\n\tswitch (typid)\n\t{\n\t\tcase DATEOID:\n\t\t\t{\n\t\t\t\tDateADT\t\tdate;\n\t\t\t\tstruct pg_tm tm;\n\n\t\t\t\tdate = DatumGetDateADT(value);\n\n\t\t\t\t/* Same as date_out(), but forcing DateStyle */\n\t\t\t\tif (DATE_NOT_FINITE(date))\n\t\t\t\t\tEncodeSpecialDate(date, buf);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tj2date(date + POSTGRES_EPOCH_JDATE,\n\t\t\t\t\t\t   &(tm.tm_year), &(tm.tm_mon), &(tm.tm_mday));\n\t\t\t\t\tEncodeDateOnly(&tm, USE_XSD_DATES, buf);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIMEOID:\n\t\t\t{\n\t\t\t\tTimeADT\t\ttime = DatumGetTimeADT(value);\n\t\t\t\tstruct pg_tm tt,\n\t\t\t\t\t\t   *tm = &tt;\n\t\t\t\tfsec_t\t\tfsec;\n\n\t\t\t\t/* Same as time_out(), but forcing DateStyle */\n\t\t\t\ttime2tm(time, tm, &fsec);\n\t\t\t\tEncodeTimeOnly(tm, fsec, false, 0, USE_XSD_DATES, buf);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIMETZOID:\n\t\t\t{\n\t\t\t\tTimeTzADT  *time = DatumGetTimeTzADTP(value);\n\t\t\t\tstruct pg_tm tt,\n\t\t\t\t\t\t   *tm = &tt;\n\t\t\t\tfsec_t\t\tfsec;\n\t\t\t\tint\t\t\ttz;\n\n\t\t\t\t/* Same as timetz_out(), but forcing DateStyle */\n\t\t\t\ttimetz2tm(time, tm, &fsec, &tz);\n\t\t\t\tEncodeTimeOnly(tm, fsec, true, tz, USE_XSD_DATES, buf);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIMESTAMPOID:\n\t\t\t{\n\t\t\t\tTimestamp\ttimestamp;\n\t\t\t\tstruct pg_tm tm;\n\t\t\t\tfsec_t\t\tfsec;\n\n\t\t\t\ttimestamp = DatumGetTimestamp(value);\n\t\t\t\t/* Same as timestamp_out(), but forcing DateStyle */\n\t\t\t\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\t\t\t\tEncodeSpecialTimestamp(timestamp, buf);\n\t\t\t\telse if (timestamp2tm(timestamp, NULL, &tm, &fsec, NULL, NULL) == 0)\n\t\t\t\t\tEncodeDateTime(&tm, fsec, false, 0, NULL, USE_XSD_DATES, buf);\n\t\t\t\telse\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIMESTAMPTZOID:\n\t\t\t{\n\t\t\t\tTimestampTz timestamp;\n\t\t\t\tstruct pg_tm tm;\n\t\t\t\tint\t\t\ttz;\n\t\t\t\tfsec_t\t\tfsec;\n\t\t\t\tconst char *tzn = NULL;\n\n\t\t\t\ttimestamp = DatumGetTimestampTz(value);\n\t\t\t\t/* Same as timestamptz_out(), but forcing DateStyle */\n\t\t\t\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\t\t\t\tEncodeSpecialTimestamp(timestamp, buf);\n\t\t\t\telse if (timestamp2tm(timestamp, &tz, &tm, &fsec, &tzn, NULL) == 0)\n\t\t\t\t\tEncodeDateTime(&tm, fsec, true, tz, tzn, USE_XSD_DATES, buf);\n\t\t\t\telse\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unknown jsonb value datetime type oid %d\", typid);\n\t\t\treturn NULL;\n\t}\n\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "outputstr"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetNumeric",
          "args": [
            "numd"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall3",
          "args": [
            "numeric_in",
            "CStringGetDatum(outputstr)",
            "ObjectIdGetDatum(InvalidOid)",
            "Int32GetDatum(-1)"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int32GetDatum",
          "args": [
            "-1"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "InvalidOid"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CStringGetDatum",
          "args": [
            "outputstr"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "outputstr",
            "'n'"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "outputstr",
            "'N'"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetBool",
          "args": [
            "val"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetBool",
          "args": [
            "val"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "composite_to_jsonb",
          "args": [
            "val",
            "result"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "composite_to_jsonb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
          "lines": "1001-1063",
          "snippet": "static void\ncomposite_to_jsonb(Datum composite, JsonbInState *result)\n{\n\tHeapTupleHeader td;\n\tOid\t\t\ttupType;\n\tint32\t\ttupTypmod;\n\tTupleDesc\ttupdesc;\n\tHeapTupleData tmptup,\n\t\t\t   *tuple;\n\tint\t\t\ti;\n\n\ttd = DatumGetHeapTupleHeader(composite);\n\n\t/* Extract rowtype info and find a tupdesc */\n\ttupType = HeapTupleHeaderGetTypeId(td);\n\ttupTypmod = HeapTupleHeaderGetTypMod(td);\n\ttupdesc = lookup_rowtype_tupdesc(tupType, tupTypmod);\n\n\t/* Build a temporary HeapTuple control structure */\n\ttmptup.t_len = HeapTupleHeaderGetDatumLength(td);\n\ttmptup.t_data = td;\n\ttuple = &tmptup;\n\n\tresult->res = pushJsonbValue(&result->parseState, WJB_BEGIN_OBJECT, NULL);\n\n\tfor (i = 0; i < tupdesc->natts; i++)\n\t{\n\t\tDatum\t\tval;\n\t\tbool\t\tisnull;\n\t\tchar\t   *attname;\n\t\tJsonbTypeCategory tcategory;\n\t\tOid\t\t\toutfuncoid;\n\t\tJsonbValue\tv;\n\t\tForm_pg_attribute att = TupleDescAttr(tupdesc, i);\n\n\t\tif (att->attisdropped)\n\t\t\tcontinue;\n\n\t\tattname = NameStr(att->attname);\n\n\t\tv.type = jbvString;\n\t\t/* don't need checkStringLen here - can't exceed maximum name length */\n\t\tv.val.string.len = strlen(attname);\n\t\tv.val.string.val = attname;\n\n\t\tresult->res = pushJsonbValue(&result->parseState, WJB_KEY, &v);\n\n\t\tval = heap_getattr(tuple, i + 1, tupdesc, &isnull);\n\n\t\tif (isnull)\n\t\t{\n\t\t\ttcategory = JSONBTYPE_NULL;\n\t\t\toutfuncoid = InvalidOid;\n\t\t}\n\t\telse\n\t\t\tjsonb_categorize_type(att->atttypid, &tcategory, &outfuncoid);\n\n\t\tdatum_to_jsonb(val, isnull, result, tcategory, outfuncoid, false);\n\t}\n\n\tresult->res = pushJsonbValue(&result->parseState, WJB_END_OBJECT, NULL);\n\tReleaseTupleDesc(tupdesc);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"miscadmin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline Datum jsonb_from_cstring(char *json, int len);",
            "static size_t checkStringLen(size_t len);",
            "static void jsonb_in_object_field_start(void *pstate, char *fname, bool isnull);",
            "static void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);",
            "static void composite_to_jsonb(Datum composite, JsonbInState *result);",
            "static void array_dim_to_jsonb(JsonbInState *result, int dim, int ndims, int *dims,\n\t\t\t\t   Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid);",
            "static void array_to_jsonb_internal(Datum array, JsonbInState *result);",
            "static void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic inline Datum jsonb_from_cstring(char *json, int len);\nstatic size_t checkStringLen(size_t len);\nstatic void jsonb_in_object_field_start(void *pstate, char *fname, bool isnull);\nstatic void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);\nstatic void composite_to_jsonb(Datum composite, JsonbInState *result);\nstatic void array_dim_to_jsonb(JsonbInState *result, int dim, int ndims, int *dims,\n\t\t\t\t   Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid);\nstatic void array_to_jsonb_internal(Datum array, JsonbInState *result);\nstatic void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);\n\nstatic void\ncomposite_to_jsonb(Datum composite, JsonbInState *result)\n{\n\tHeapTupleHeader td;\n\tOid\t\t\ttupType;\n\tint32\t\ttupTypmod;\n\tTupleDesc\ttupdesc;\n\tHeapTupleData tmptup,\n\t\t\t   *tuple;\n\tint\t\t\ti;\n\n\ttd = DatumGetHeapTupleHeader(composite);\n\n\t/* Extract rowtype info and find a tupdesc */\n\ttupType = HeapTupleHeaderGetTypeId(td);\n\ttupTypmod = HeapTupleHeaderGetTypMod(td);\n\ttupdesc = lookup_rowtype_tupdesc(tupType, tupTypmod);\n\n\t/* Build a temporary HeapTuple control structure */\n\ttmptup.t_len = HeapTupleHeaderGetDatumLength(td);\n\ttmptup.t_data = td;\n\ttuple = &tmptup;\n\n\tresult->res = pushJsonbValue(&result->parseState, WJB_BEGIN_OBJECT, NULL);\n\n\tfor (i = 0; i < tupdesc->natts; i++)\n\t{\n\t\tDatum\t\tval;\n\t\tbool\t\tisnull;\n\t\tchar\t   *attname;\n\t\tJsonbTypeCategory tcategory;\n\t\tOid\t\t\toutfuncoid;\n\t\tJsonbValue\tv;\n\t\tForm_pg_attribute att = TupleDescAttr(tupdesc, i);\n\n\t\tif (att->attisdropped)\n\t\t\tcontinue;\n\n\t\tattname = NameStr(att->attname);\n\n\t\tv.type = jbvString;\n\t\t/* don't need checkStringLen here - can't exceed maximum name length */\n\t\tv.val.string.len = strlen(attname);\n\t\tv.val.string.val = attname;\n\n\t\tresult->res = pushJsonbValue(&result->parseState, WJB_KEY, &v);\n\n\t\tval = heap_getattr(tuple, i + 1, tupdesc, &isnull);\n\n\t\tif (isnull)\n\t\t{\n\t\t\ttcategory = JSONBTYPE_NULL;\n\t\t\toutfuncoid = InvalidOid;\n\t\t}\n\t\telse\n\t\t\tjsonb_categorize_type(att->atttypid, &tcategory, &outfuncoid);\n\n\t\tdatum_to_jsonb(val, isnull, result, tcategory, outfuncoid, false);\n\t}\n\n\tresult->res = pushJsonbValue(&result->parseState, WJB_END_OBJECT, NULL);\n\tReleaseTupleDesc(tupdesc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "array_to_jsonb_internal",
          "args": [
            "val",
            "result"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "array_to_jsonb_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
          "lines": "953-996",
          "snippet": "static void\narray_to_jsonb_internal(Datum array, JsonbInState *result)\n{\n\tArrayType  *v = DatumGetArrayTypeP(array);\n\tOid\t\t\telement_type = ARR_ELEMTYPE(v);\n\tint\t\t   *dim;\n\tint\t\t\tndim;\n\tint\t\t\tnitems;\n\tint\t\t\tcount = 0;\n\tDatum\t   *elements;\n\tbool\t   *nulls;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tJsonbTypeCategory tcategory;\n\tOid\t\t\toutfuncoid;\n\n\tndim = ARR_NDIM(v);\n\tdim = ARR_DIMS(v);\n\tnitems = ArrayGetNItems(ndim, dim);\n\n\tif (nitems <= 0)\n\t{\n\t\tresult->res = pushJsonbValue(&result->parseState, WJB_BEGIN_ARRAY, NULL);\n\t\tresult->res = pushJsonbValue(&result->parseState, WJB_END_ARRAY, NULL);\n\t\treturn;\n\t}\n\n\tget_typlenbyvalalign(element_type,\n\t\t\t\t\t\t &typlen, &typbyval, &typalign);\n\n\tjsonb_categorize_type(element_type,\n\t\t\t\t\t\t  &tcategory, &outfuncoid);\n\n\tdeconstruct_array(v, element_type, typlen, typbyval,\n\t\t\t\t\t  typalign, &elements, &nulls,\n\t\t\t\t\t  &nitems);\n\n\tarray_dim_to_jsonb(result, 0, ndim, dim, elements, nulls, &count, tcategory,\n\t\t\t\t\t   outfuncoid);\n\n\tpfree(elements);\n\tpfree(nulls);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"miscadmin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);",
            "static void composite_to_jsonb(Datum composite, JsonbInState *result);",
            "static void array_dim_to_jsonb(JsonbInState *result, int dim, int ndims, int *dims,\n\t\t\t\t   Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid);",
            "static void array_to_jsonb_internal(Datum array, JsonbInState *result);",
            "static void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);\nstatic void composite_to_jsonb(Datum composite, JsonbInState *result);\nstatic void array_dim_to_jsonb(JsonbInState *result, int dim, int ndims, int *dims,\n\t\t\t\t   Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid);\nstatic void array_to_jsonb_internal(Datum array, JsonbInState *result);\nstatic void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);\n\nstatic void\narray_to_jsonb_internal(Datum array, JsonbInState *result)\n{\n\tArrayType  *v = DatumGetArrayTypeP(array);\n\tOid\t\t\telement_type = ARR_ELEMTYPE(v);\n\tint\t\t   *dim;\n\tint\t\t\tndim;\n\tint\t\t\tnitems;\n\tint\t\t\tcount = 0;\n\tDatum\t   *elements;\n\tbool\t   *nulls;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tJsonbTypeCategory tcategory;\n\tOid\t\t\toutfuncoid;\n\n\tndim = ARR_NDIM(v);\n\tdim = ARR_DIMS(v);\n\tnitems = ArrayGetNItems(ndim, dim);\n\n\tif (nitems <= 0)\n\t{\n\t\tresult->res = pushJsonbValue(&result->parseState, WJB_BEGIN_ARRAY, NULL);\n\t\tresult->res = pushJsonbValue(&result->parseState, WJB_END_ARRAY, NULL);\n\t\treturn;\n\t}\n\n\tget_typlenbyvalalign(element_type,\n\t\t\t\t\t\t &typlen, &typbyval, &typalign);\n\n\tjsonb_categorize_type(element_type,\n\t\t\t\t\t\t  &tcategory, &outfuncoid);\n\n\tdeconstruct_array(v, element_type, typlen, typbyval,\n\t\t\t\t\t  typalign, &elements, &nulls,\n\t\t\t\t\t  &nitems);\n\n\tarray_dim_to_jsonb(result, 0, ndim, dim, elements, nulls, &count, tcategory,\n\t\t\t\t\t   outfuncoid);\n\n\tpfree(elements);\n\tpfree(nulls);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidFunctionCall1",
          "args": [
            "outfuncoid",
            "val"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"key value must be scalar, not array, composite, or json\"))"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"key value must be scalar, not array, composite, or json\""
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!key_scalar"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_stack_depth",
          "args": [],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic inline Datum jsonb_from_cstring(char *json, int len);\nstatic size_t checkStringLen(size_t len);\nstatic void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);\nstatic void composite_to_jsonb(Datum composite, JsonbInState *result);\nstatic void array_dim_to_jsonb(JsonbInState *result, int dim, int ndims, int *dims,\n\t\t\t\t   Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid);\nstatic void array_to_jsonb_internal(Datum array, JsonbInState *result);\nstatic void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);\nstatic void datum_to_jsonb(Datum val, bool is_null, JsonbInState *result,\n\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid,\n\t\t\t   bool key_scalar);\nstatic void add_jsonb(Datum val, bool is_null, JsonbInState *result,\n\t\t  Oid val_type, bool key_scalar);\n\nstatic void\ndatum_to_jsonb(Datum val, bool is_null, JsonbInState *result,\n\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid,\n\t\t\t   bool key_scalar)\n{\n\tchar\t   *outputstr;\n\tbool\t\tnumeric_error;\n\tJsonbValue\tjb;\n\tbool\t\tscalar_jsonb = false;\n\n\tcheck_stack_depth();\n\n\t/* Convert val to a JsonbValue in jb (in most cases) */\n\tif (is_null)\n\t{\n\t\tAssert(!key_scalar);\n\t\tjb.type = jbvNull;\n\t}\n\telse if (key_scalar &&\n\t\t\t (tcategory == JSONBTYPE_ARRAY ||\n\t\t\t  tcategory == JSONBTYPE_COMPOSITE ||\n\t\t\t  tcategory == JSONBTYPE_JSON ||\n\t\t\t  tcategory == JSONBTYPE_JSONB ||\n\t\t\t  tcategory == JSONBTYPE_JSONCAST))\n\t{\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"key value must be scalar, not array, composite, or json\")));\n\t}\n\telse\n\t{\n\t\tif (tcategory == JSONBTYPE_JSONCAST)\n\t\t\tval = OidFunctionCall1(outfuncoid, val);\n\n\t\tswitch (tcategory)\n\t\t{\n\t\t\tcase JSONBTYPE_ARRAY:\n\t\t\t\tarray_to_jsonb_internal(val, result);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_COMPOSITE:\n\t\t\t\tcomposite_to_jsonb(val, result);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_BOOL:\n\t\t\t\tif (key_scalar)\n\t\t\t\t{\n\t\t\t\t\toutputstr = DatumGetBool(val) ? \"true\" : \"false\";\n\t\t\t\t\tjb.type = jbvString;\n\t\t\t\t\tjb.val.string.len = strlen(outputstr);\n\t\t\t\t\tjb.val.string.val = outputstr;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tjb.type = jbvBool;\n\t\t\t\t\tjb.val.boolean = DatumGetBool(val);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_NUMERIC:\n\t\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\t\t\t\tif (key_scalar)\n\t\t\t\t{\n\t\t\t\t\t/* always quote keys */\n\t\t\t\t\tjb.type = jbvString;\n\t\t\t\t\tjb.val.string.len = strlen(outputstr);\n\t\t\t\t\tjb.val.string.val = outputstr;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * Make it numeric if it's a valid JSON number, otherwise\n\t\t\t\t\t * a string. Invalid numeric output will always have an\n\t\t\t\t\t * 'N' or 'n' in it (I think).\n\t\t\t\t\t */\n\t\t\t\t\tnumeric_error = (strchr(outputstr, 'N') != NULL ||\n\t\t\t\t\t\t\t\t\t strchr(outputstr, 'n') != NULL);\n\t\t\t\t\tif (!numeric_error)\n\t\t\t\t\t{\n\t\t\t\t\t\tDatum\t\tnumd;\n\n\t\t\t\t\t\tjb.type = jbvNumeric;\n\t\t\t\t\t\tnumd = DirectFunctionCall3(numeric_in,\n\t\t\t\t\t\t\t\t\t\t\t\t   CStringGetDatum(outputstr),\n\t\t\t\t\t\t\t\t\t\t\t\t   ObjectIdGetDatum(InvalidOid),\n\t\t\t\t\t\t\t\t\t\t\t\t   Int32GetDatum(-1));\n\t\t\t\t\t\tjb.val.numeric = DatumGetNumeric(numd);\n\t\t\t\t\t\tpfree(outputstr);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tjb.type = jbvString;\n\t\t\t\t\t\tjb.val.string.len = strlen(outputstr);\n\t\t\t\t\t\tjb.val.string.val = outputstr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_DATE:\n\t\t\t\tjb.type = jbvString;\n\t\t\t\tjb.val.string.val = JsonEncodeDateTime(NULL, val, DATEOID);\n\t\t\t\tjb.val.string.len = strlen(jb.val.string.val);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_TIMESTAMP:\n\t\t\t\tjb.type = jbvString;\n\t\t\t\tjb.val.string.val = JsonEncodeDateTime(NULL, val, TIMESTAMPOID);\n\t\t\t\tjb.val.string.len = strlen(jb.val.string.val);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_TIMESTAMPTZ:\n\t\t\t\tjb.type = jbvString;\n\t\t\t\tjb.val.string.val = JsonEncodeDateTime(NULL, val, TIMESTAMPTZOID);\n\t\t\t\tjb.val.string.len = strlen(jb.val.string.val);\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_JSONCAST:\n\t\t\tcase JSONBTYPE_JSON:\n\t\t\t\t{\n\t\t\t\t\t/* parse the json right into the existing result object */\n\t\t\t\t\tJsonLexContext *lex;\n\t\t\t\t\tJsonSemAction sem;\n\t\t\t\t\ttext\t   *json = DatumGetTextPP(val);\n\n\t\t\t\t\tlex = makeJsonLexContext(json, true);\n\n\t\t\t\t\tmemset(&sem, 0, sizeof(sem));\n\n\t\t\t\t\tsem.semstate = (void *) result;\n\n\t\t\t\t\tsem.object_start = jsonb_in_object_start;\n\t\t\t\t\tsem.array_start = jsonb_in_array_start;\n\t\t\t\t\tsem.object_end = jsonb_in_object_end;\n\t\t\t\t\tsem.array_end = jsonb_in_array_end;\n\t\t\t\t\tsem.scalar = jsonb_in_scalar;\n\t\t\t\t\tsem.object_field_start = jsonb_in_object_field_start;\n\n\t\t\t\t\tpg_parse_json(lex, &sem);\n\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase JSONBTYPE_JSONB:\n\t\t\t\t{\n\t\t\t\t\tJsonb\t   *jsonb = DatumGetJsonbP(val);\n\t\t\t\t\tJsonbIterator *it;\n\n\t\t\t\t\tit = JsonbIteratorInit(&jsonb->root);\n\n\t\t\t\t\tif (JB_ROOT_IS_SCALAR(jsonb))\n\t\t\t\t\t{\n\t\t\t\t\t\t(void) JsonbIteratorNext(&it, &jb, true);\n\t\t\t\t\t\tAssert(jb.type == jbvArray);\n\t\t\t\t\t\t(void) JsonbIteratorNext(&it, &jb, true);\n\t\t\t\t\t\tscalar_jsonb = true;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tJsonbIteratorToken type;\n\n\t\t\t\t\t\twhile ((type = JsonbIteratorNext(&it, &jb, false))\n\t\t\t\t\t\t\t   != WJB_DONE)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (type == WJB_END_ARRAY || type == WJB_END_OBJECT ||\n\t\t\t\t\t\t\t\ttype == WJB_BEGIN_ARRAY || type == WJB_BEGIN_OBJECT)\n\t\t\t\t\t\t\t\tresult->res = pushJsonbValue(&result->parseState,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t type, NULL);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tresult->res = pushJsonbValue(&result->parseState,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t type, &jb);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\toutputstr = OidOutputFunctionCall(outfuncoid, val);\n\t\t\t\tjb.type = jbvString;\n\t\t\t\tjb.val.string.len = checkStringLen(strlen(outputstr));\n\t\t\t\tjb.val.string.val = outputstr;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Now insert jb into result, unless we did it recursively */\n\tif (!is_null && !scalar_jsonb &&\n\t\ttcategory >= JSONBTYPE_JSON && tcategory <= JSONBTYPE_JSONCAST)\n\t{\n\t\t/* work has been done recursively */\n\t\treturn;\n\t}\n\telse if (result->parseState == NULL)\n\t{\n\t\t/* single root scalar */\n\t\tJsonbValue\tva;\n\n\t\tva.type = jbvArray;\n\t\tva.val.array.rawScalar = true;\n\t\tva.val.array.nElems = 1;\n\n\t\tresult->res = pushJsonbValue(&result->parseState, WJB_BEGIN_ARRAY, &va);\n\t\tresult->res = pushJsonbValue(&result->parseState, WJB_ELEM, &jb);\n\t\tresult->res = pushJsonbValue(&result->parseState, WJB_END_ARRAY, NULL);\n\t}\n\telse\n\t{\n\t\tJsonbValue *o = &result->parseState->contVal;\n\n\t\tswitch (o->type)\n\t\t{\n\t\t\tcase jbvArray:\n\t\t\t\tresult->res = pushJsonbValue(&result->parseState, WJB_ELEM, &jb);\n\t\t\t\tbreak;\n\t\t\tcase jbvObject:\n\t\t\t\tresult->res = pushJsonbValue(&result->parseState,\n\t\t\t\t\t\t\t\t\t\t\t key_scalar ? WJB_KEY : WJB_VALUE,\n\t\t\t\t\t\t\t\t\t\t\t &jb);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unexpected parent of nested structure\");\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "jsonb_categorize_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
    "lines": "593-690",
    "snippet": "static void\njsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid)\n{\n\tbool\t\ttypisvarlena;\n\n\t/* Look through any domain */\n\ttypoid = getBaseType(typoid);\n\n\t*outfuncoid = InvalidOid;\n\n\t/*\n\t * We need to get the output function for everything except date and\n\t * timestamp types, booleans, array and composite types, json and jsonb,\n\t * and non-builtin types where there's a cast to json. In this last case\n\t * we return the oid of the cast function instead.\n\t */\n\n\tswitch (typoid)\n\t{\n\t\tcase BOOLOID:\n\t\t\t*tcategory = JSONBTYPE_BOOL;\n\t\t\tbreak;\n\n\t\tcase INT2OID:\n\t\tcase INT4OID:\n\t\tcase INT8OID:\n\t\tcase FLOAT4OID:\n\t\tcase FLOAT8OID:\n\t\tcase NUMERICOID:\n\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t*tcategory = JSONBTYPE_NUMERIC;\n\t\t\tbreak;\n\n\t\tcase DATEOID:\n\t\t\t*tcategory = JSONBTYPE_DATE;\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPOID:\n\t\t\t*tcategory = JSONBTYPE_TIMESTAMP;\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPTZOID:\n\t\t\t*tcategory = JSONBTYPE_TIMESTAMPTZ;\n\t\t\tbreak;\n\n\t\tcase JSONBOID:\n\t\t\t*tcategory = JSONBTYPE_JSONB;\n\t\t\tbreak;\n\n\t\tcase JSONOID:\n\t\t\t*tcategory = JSONBTYPE_JSON;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* Check for arrays and composites */\n\t\t\tif (OidIsValid(get_element_type(typoid)) || typoid == ANYARRAYOID\n\t\t\t\t|| typoid == RECORDARRAYOID)\n\t\t\t\t*tcategory = JSONBTYPE_ARRAY;\n\t\t\telse if (type_is_rowtype(typoid))\t/* includes RECORDOID */\n\t\t\t\t*tcategory = JSONBTYPE_COMPOSITE;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* It's probably the general case ... */\n\t\t\t\t*tcategory = JSONBTYPE_OTHER;\n\n\t\t\t\t/*\n\t\t\t\t * but first let's look for a cast to json (note: not to\n\t\t\t\t * jsonb) if it's not built-in.\n\t\t\t\t */\n\t\t\t\tif (typoid >= FirstNormalObjectId)\n\t\t\t\t{\n\t\t\t\t\tOid\t\t\tcastfunc;\n\t\t\t\t\tCoercionPathType ctype;\n\n\t\t\t\t\tctype = find_coercion_pathway(JSONOID, typoid,\n\t\t\t\t\t\t\t\t\t\t\t\t  COERCION_EXPLICIT, &castfunc);\n\t\t\t\t\tif (ctype == COERCION_PATH_FUNC && OidIsValid(castfunc))\n\t\t\t\t\t{\n\t\t\t\t\t\t*tcategory = JSONBTYPE_JSONCAST;\n\t\t\t\t\t\t*outfuncoid = castfunc;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* not a cast type, so just get the usual output func */\n\t\t\t\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* any other builtin type */\n\t\t\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"miscadmin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);",
      "static void array_dim_to_jsonb(JsonbInState *result, int dim, int ndims, int *dims,\n\t\t\t\t   Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid);",
      "static void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "getTypeOutputInfo",
          "args": [
            "typoid",
            "outfuncoid",
            "&typisvarlena"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "getTypeOutputInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2673-2699",
          "snippet": "void\ngetTypeOutputInfo(Oid type, Oid *typOutput, bool *typIsVarlena)\n{\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type pt;\n\n\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type));\n\tif (!HeapTupleIsValid(typeTuple))\n\t\telog(ERROR, \"cache lookup failed for type %u\", type);\n\tpt = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\tif (!pt->typisdefined)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t errmsg(\"type %s is only a shell\",\n\t\t\t\t\t\tformat_type_be(type))));\n\tif (!OidIsValid(pt->typoutput))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"no output function available for type %s\",\n\t\t\t\t\t\tformat_type_be(type))));\n\n\t*typOutput = pt->typoutput;\n\t*typIsVarlena = (!pt->typbyval) && (pt->typlen == -1);\n\n\tReleaseSysCache(typeTuple);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\ngetTypeOutputInfo(Oid type, Oid *typOutput, bool *typIsVarlena)\n{\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type pt;\n\n\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type));\n\tif (!HeapTupleIsValid(typeTuple))\n\t\telog(ERROR, \"cache lookup failed for type %u\", type);\n\tpt = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\tif (!pt->typisdefined)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t errmsg(\"type %s is only a shell\",\n\t\t\t\t\t\tformat_type_be(type))));\n\tif (!OidIsValid(pt->typoutput))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"no output function available for type %s\",\n\t\t\t\t\t\tformat_type_be(type))));\n\n\t*typOutput = pt->typoutput;\n\t*typIsVarlena = (!pt->typbyval) && (pt->typlen == -1);\n\n\tReleaseSysCache(typeTuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "castfunc"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_coercion_pathway",
          "args": [
            "JSONOID",
            "typoid",
            "COERCION_EXPLICIT",
            "&castfunc"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type_is_rowtype",
          "args": [
            "typoid"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "type_is_rowtype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2432-2449",
          "snippet": "bool\ntype_is_rowtype(Oid typid)\n{\n\tif (typid == RECORDOID)\n\t\treturn true;\t\t\t/* easy case */\n\tswitch (get_typtype(typid))\n\t{\n\t\tcase TYPTYPE_COMPOSITE:\n\t\t\treturn true;\n\t\tcase TYPTYPE_DOMAIN:\n\t\t\tif (get_typtype(getBaseType(typid)) == TYPTYPE_COMPOSITE)\n\t\t\t\treturn true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\ntype_is_rowtype(Oid typid)\n{\n\tif (typid == RECORDOID)\n\t\treturn true;\t\t\t/* easy case */\n\tswitch (get_typtype(typid))\n\t{\n\t\tcase TYPTYPE_COMPOSITE:\n\t\t\treturn true;\n\t\tcase TYPTYPE_DOMAIN:\n\t\t\tif (get_typtype(getBaseType(typid)) == TYPTYPE_COMPOSITE)\n\t\t\t\treturn true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "get_element_type(typoid)"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_element_type",
          "args": [
            "typoid"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "get_element_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2525-2545",
          "snippet": "Oid\nget_element_type(Oid typid)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_type typtup = (Form_pg_type) GETSTRUCT(tp);\n\t\tOid\t\t\tresult;\n\n\t\tif (typtup->typlen == -1)\n\t\t\tresult = typtup->typelem;\n\t\telse\n\t\t\tresult = InvalidOid;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn InvalidOid;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nOid\nget_element_type(Oid typid)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_type typtup = (Form_pg_type) GETSTRUCT(tp);\n\t\tOid\t\t\tresult;\n\n\t\tif (typtup->typlen == -1)\n\t\t\tresult = typtup->typelem;\n\t\telse\n\t\t\tresult = InvalidOid;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn InvalidOid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getBaseType",
          "args": [
            "typoid"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "getBaseType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2298-2304",
          "snippet": "Oid\ngetBaseType(Oid typid)\n{\n\tint32\t\ttypmod = -1;\n\n\treturn getBaseTypeAndTypmod(typid, &typmod);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nOid\ngetBaseType(Oid typid)\n{\n\tint32\t\ttypmod = -1;\n\n\treturn getBaseTypeAndTypmod(typid, &typmod);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);\nstatic void array_dim_to_jsonb(JsonbInState *result, int dim, int ndims, int *dims,\n\t\t\t\t   Datum *vals, bool *nulls, int *valcount,\n\t\t\t\t   JsonbTypeCategory tcategory, Oid outfuncoid);\nstatic void jsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid);\n\nstatic void\njsonb_categorize_type(Oid typoid,\n\t\t\t\t\t  JsonbTypeCategory *tcategory,\n\t\t\t\t\t  Oid *outfuncoid)\n{\n\tbool\t\ttypisvarlena;\n\n\t/* Look through any domain */\n\ttypoid = getBaseType(typoid);\n\n\t*outfuncoid = InvalidOid;\n\n\t/*\n\t * We need to get the output function for everything except date and\n\t * timestamp types, booleans, array and composite types, json and jsonb,\n\t * and non-builtin types where there's a cast to json. In this last case\n\t * we return the oid of the cast function instead.\n\t */\n\n\tswitch (typoid)\n\t{\n\t\tcase BOOLOID:\n\t\t\t*tcategory = JSONBTYPE_BOOL;\n\t\t\tbreak;\n\n\t\tcase INT2OID:\n\t\tcase INT4OID:\n\t\tcase INT8OID:\n\t\tcase FLOAT4OID:\n\t\tcase FLOAT8OID:\n\t\tcase NUMERICOID:\n\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t*tcategory = JSONBTYPE_NUMERIC;\n\t\t\tbreak;\n\n\t\tcase DATEOID:\n\t\t\t*tcategory = JSONBTYPE_DATE;\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPOID:\n\t\t\t*tcategory = JSONBTYPE_TIMESTAMP;\n\t\t\tbreak;\n\n\t\tcase TIMESTAMPTZOID:\n\t\t\t*tcategory = JSONBTYPE_TIMESTAMPTZ;\n\t\t\tbreak;\n\n\t\tcase JSONBOID:\n\t\t\t*tcategory = JSONBTYPE_JSONB;\n\t\t\tbreak;\n\n\t\tcase JSONOID:\n\t\t\t*tcategory = JSONBTYPE_JSON;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* Check for arrays and composites */\n\t\t\tif (OidIsValid(get_element_type(typoid)) || typoid == ANYARRAYOID\n\t\t\t\t|| typoid == RECORDARRAYOID)\n\t\t\t\t*tcategory = JSONBTYPE_ARRAY;\n\t\t\telse if (type_is_rowtype(typoid))\t/* includes RECORDOID */\n\t\t\t\t*tcategory = JSONBTYPE_COMPOSITE;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* It's probably the general case ... */\n\t\t\t\t*tcategory = JSONBTYPE_OTHER;\n\n\t\t\t\t/*\n\t\t\t\t * but first let's look for a cast to json (note: not to\n\t\t\t\t * jsonb) if it's not built-in.\n\t\t\t\t */\n\t\t\t\tif (typoid >= FirstNormalObjectId)\n\t\t\t\t{\n\t\t\t\t\tOid\t\t\tcastfunc;\n\t\t\t\t\tCoercionPathType ctype;\n\n\t\t\t\t\tctype = find_coercion_pathway(JSONOID, typoid,\n\t\t\t\t\t\t\t\t\t\t\t\t  COERCION_EXPLICIT, &castfunc);\n\t\t\t\t\tif (ctype == COERCION_PATH_FUNC && OidIsValid(castfunc))\n\t\t\t\t\t{\n\t\t\t\t\t\t*tcategory = JSONBTYPE_JSONCAST;\n\t\t\t\t\t\t*outfuncoid = castfunc;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* not a cast type, so just get the usual output func */\n\t\t\t\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* any other builtin type */\n\t\t\t\t\tgetTypeOutputInfo(typoid, outfuncoid, &typisvarlena);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n}"
  },
  {
    "function_name": "add_indent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
    "lines": "572-583",
    "snippet": "static void\nadd_indent(StringInfo out, bool indent, int level)\n{\n\tif (indent)\n\t{\n\t\tint\t\t\ti;\n\n\t\tappendStringInfoCharMacro(out, '\\n');\n\t\tfor (i = 0; i < level; i++)\n\t\t\tappendBinaryStringInfo(out, \"    \", 4);\n\t}\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"miscadmin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static char *JsonbToCStringWorker(StringInfo out, JsonbContainer *in, int estimated_len, bool indent);",
      "static void add_indent(StringInfo out, bool indent, int level);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "appendBinaryStringInfo",
          "args": [
            "out",
            "\"    \"",
            "4"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoCharMacro",
          "args": [
            "out",
            "'\\n'"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic char *JsonbToCStringWorker(StringInfo out, JsonbContainer *in, int estimated_len, bool indent);\nstatic void add_indent(StringInfo out, bool indent, int level);\n\nstatic void\nadd_indent(StringInfo out, bool indent, int level)\n{\n\tif (indent)\n\t{\n\t\tint\t\t\ti;\n\n\t\tappendStringInfoCharMacro(out, '\\n');\n\t\tfor (i = 0; i < level; i++)\n\t\t\tappendBinaryStringInfo(out, \"    \", 4);\n\t}\n}"
  },
  {
    "function_name": "JsonbToCStringWorker",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
    "lines": "448-570",
    "snippet": "static char *\nJsonbToCStringWorker(StringInfo out, JsonbContainer *in, int estimated_len, bool indent)\n{\n\tbool\t\tfirst = true;\n\tJsonbIterator *it;\n\tJsonbValue\tv;\n\tJsonbIteratorToken type = WJB_DONE;\n\tint\t\t\tlevel = 0;\n\tbool\t\tredo_switch = false;\n\n\t/* If we are indenting, don't add a space after a comma */\n\tint\t\t\tispaces = indent ? 1 : 2;\n\n\t/*\n\t * Don't indent the very first item. This gets set to the indent flag at\n\t * the bottom of the loop.\n\t */\n\tbool\t\tuse_indent = false;\n\tbool\t\traw_scalar = false;\n\tbool\t\tlast_was_key = false;\n\n\tif (out == NULL)\n\t\tout = makeStringInfo();\n\n\tenlargeStringInfo(out, (estimated_len >= 0) ? estimated_len : 64);\n\n\tit = JsonbIteratorInit(in);\n\n\twhile (redo_switch ||\n\t\t   ((type = JsonbIteratorNext(&it, &v, false)) != WJB_DONE))\n\t{\n\t\tredo_switch = false;\n\t\tswitch (type)\n\t\t{\n\t\t\tcase WJB_BEGIN_ARRAY:\n\t\t\t\tif (!first)\n\t\t\t\t\tappendBinaryStringInfo(out, \", \", ispaces);\n\n\t\t\t\tif (!v.val.array.rawScalar)\n\t\t\t\t{\n\t\t\t\t\tadd_indent(out, use_indent && !last_was_key, level);\n\t\t\t\t\tappendStringInfoCharMacro(out, '[');\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\traw_scalar = true;\n\n\t\t\t\tfirst = true;\n\t\t\t\tlevel++;\n\t\t\t\tbreak;\n\t\t\tcase WJB_BEGIN_OBJECT:\n\t\t\t\tif (!first)\n\t\t\t\t\tappendBinaryStringInfo(out, \", \", ispaces);\n\n\t\t\t\tadd_indent(out, use_indent && !last_was_key, level);\n\t\t\t\tappendStringInfoCharMacro(out, '{');\n\n\t\t\t\tfirst = true;\n\t\t\t\tlevel++;\n\t\t\t\tbreak;\n\t\t\tcase WJB_KEY:\n\t\t\t\tif (!first)\n\t\t\t\t\tappendBinaryStringInfo(out, \", \", ispaces);\n\t\t\t\tfirst = true;\n\n\t\t\t\tadd_indent(out, use_indent, level);\n\n\t\t\t\t/* json rules guarantee this is a string */\n\t\t\t\tjsonb_put_escaped_value(out, &v);\n\t\t\t\tappendBinaryStringInfo(out, \": \", 2);\n\n\t\t\t\ttype = JsonbIteratorNext(&it, &v, false);\n\t\t\t\tif (type == WJB_VALUE)\n\t\t\t\t{\n\t\t\t\t\tfirst = false;\n\t\t\t\t\tjsonb_put_escaped_value(out, &v);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tAssert(type == WJB_BEGIN_OBJECT || type == WJB_BEGIN_ARRAY);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * We need to rerun the current switch() since we need to\n\t\t\t\t\t * output the object which we just got from the iterator\n\t\t\t\t\t * before calling the iterator again.\n\t\t\t\t\t */\n\t\t\t\t\tredo_switch = true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase WJB_ELEM:\n\t\t\t\tif (!first)\n\t\t\t\t\tappendBinaryStringInfo(out, \", \", ispaces);\n\t\t\t\tfirst = false;\n\n\t\t\t\tif (!raw_scalar)\n\t\t\t\t\tadd_indent(out, use_indent, level);\n\t\t\t\tjsonb_put_escaped_value(out, &v);\n\t\t\t\tbreak;\n\t\t\tcase WJB_END_ARRAY:\n\t\t\t\tlevel--;\n\t\t\t\tif (!raw_scalar)\n\t\t\t\t{\n\t\t\t\t\tadd_indent(out, use_indent, level);\n\t\t\t\t\tappendStringInfoCharMacro(out, ']');\n\t\t\t\t}\n\t\t\t\tfirst = false;\n\t\t\t\tbreak;\n\t\t\tcase WJB_END_OBJECT:\n\t\t\t\tlevel--;\n\t\t\t\tadd_indent(out, use_indent, level);\n\t\t\t\tappendStringInfoCharMacro(out, '}');\n\t\t\t\tfirst = false;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unknown jsonb iterator token type\");\n\t\t}\n\t\tuse_indent = indent;\n\t\tlast_was_key = redo_switch;\n\t}\n\n\tAssert(level == 0);\n\n\treturn out->data;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"miscadmin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static char *JsonbToCStringWorker(StringInfo out, JsonbContainer *in, int estimated_len, bool indent);",
      "static void add_indent(StringInfo out, bool indent, int level);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "level == 0"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unknown jsonb iterator token type\""
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoCharMacro",
          "args": [
            "out",
            "'}'"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_indent",
          "args": [
            "out",
            "use_indent",
            "level"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "add_indent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
          "lines": "572-583",
          "snippet": "static void\nadd_indent(StringInfo out, bool indent, int level)\n{\n\tif (indent)\n\t{\n\t\tint\t\t\ti;\n\n\t\tappendStringInfoCharMacro(out, '\\n');\n\t\tfor (i = 0; i < level; i++)\n\t\t\tappendBinaryStringInfo(out, \"    \", 4);\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"miscadmin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *JsonbToCStringWorker(StringInfo out, JsonbContainer *in, int estimated_len, bool indent);",
            "static void add_indent(StringInfo out, bool indent, int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic char *JsonbToCStringWorker(StringInfo out, JsonbContainer *in, int estimated_len, bool indent);\nstatic void add_indent(StringInfo out, bool indent, int level);\n\nstatic void\nadd_indent(StringInfo out, bool indent, int level)\n{\n\tif (indent)\n\t{\n\t\tint\t\t\ti;\n\n\t\tappendStringInfoCharMacro(out, '\\n');\n\t\tfor (i = 0; i < level; i++)\n\t\t\tappendBinaryStringInfo(out, \"    \", 4);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoCharMacro",
          "args": [
            "out",
            "']'"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jsonb_put_escaped_value",
          "args": [
            "out",
            "&v"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "jsonb_put_escaped_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
          "lines": "311-336",
          "snippet": "static void\njsonb_put_escaped_value(StringInfo out, JsonbValue *scalarVal)\n{\n\tswitch (scalarVal->type)\n\t{\n\t\tcase jbvNull:\n\t\t\tappendBinaryStringInfo(out, \"null\", 4);\n\t\t\tbreak;\n\t\tcase jbvString:\n\t\t\tescape_json(out, pnstrdup(scalarVal->val.string.val, scalarVal->val.string.len));\n\t\t\tbreak;\n\t\tcase jbvNumeric:\n\t\t\tappendStringInfoString(out,\n\t\t\t\t\t\t\t\t   DatumGetCString(DirectFunctionCall1(numeric_out,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   PointerGetDatum(scalarVal->val.numeric))));\n\t\t\tbreak;\n\t\tcase jbvBool:\n\t\t\tif (scalarVal->val.boolean)\n\t\t\t\tappendBinaryStringInfo(out, \"true\", 4);\n\t\t\telse\n\t\t\t\tappendBinaryStringInfo(out, \"false\", 5);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unknown jsonb scalar type\");\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"miscadmin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline Datum jsonb_from_cstring(char *json, int len);",
            "static size_t checkStringLen(size_t len);",
            "static void jsonb_put_escaped_value(StringInfo out, JsonbValue *scalarVal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic inline Datum jsonb_from_cstring(char *json, int len);\nstatic size_t checkStringLen(size_t len);\nstatic void jsonb_put_escaped_value(StringInfo out, JsonbValue *scalarVal);\n\nstatic void\njsonb_put_escaped_value(StringInfo out, JsonbValue *scalarVal)\n{\n\tswitch (scalarVal->type)\n\t{\n\t\tcase jbvNull:\n\t\t\tappendBinaryStringInfo(out, \"null\", 4);\n\t\t\tbreak;\n\t\tcase jbvString:\n\t\t\tescape_json(out, pnstrdup(scalarVal->val.string.val, scalarVal->val.string.len));\n\t\t\tbreak;\n\t\tcase jbvNumeric:\n\t\t\tappendStringInfoString(out,\n\t\t\t\t\t\t\t\t   DatumGetCString(DirectFunctionCall1(numeric_out,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   PointerGetDatum(scalarVal->val.numeric))));\n\t\t\tbreak;\n\t\tcase jbvBool:\n\t\t\tif (scalarVal->val.boolean)\n\t\t\t\tappendBinaryStringInfo(out, \"true\", 4);\n\t\t\telse\n\t\t\t\tappendBinaryStringInfo(out, \"false\", 5);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unknown jsonb scalar type\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendBinaryStringInfo",
          "args": [
            "out",
            "\", \"",
            "ispaces"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "type == WJB_BEGIN_OBJECT || type == WJB_BEGIN_ARRAY"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JsonbIteratorNext",
          "args": [
            "&it",
            "&v",
            "false"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbIteratorNext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "753-894",
          "snippet": "JsonbIteratorToken\nJsonbIteratorNext(JsonbIterator **it, JsonbValue *val, bool skipNested)\n{\n\tif (*it == NULL)\n\t\treturn WJB_DONE;\n\n\t/*\n\t * When stepping into a nested container, we jump back here to start\n\t * processing the child. We will not recurse further in one call, because\n\t * processing the child will always begin in JBI_ARRAY_START or\n\t * JBI_OBJECT_START state.\n\t */\nrecurse:\n\tswitch ((*it)->state)\n\t{\n\t\tcase JBI_ARRAY_START:\n\t\t\t/* Set v to array on first array call */\n\t\t\tval->type = jbvArray;\n\t\t\tval->val.array.nElems = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.array.elems is not actually set, because we aren't doing\n\t\t\t * a full conversion\n\t\t\t */\n\t\t\tval->val.array.rawScalar = (*it)->isScalar;\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = 0;\t/* not actually used */\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_ARRAY_ELEM;\n\t\t\treturn WJB_BEGIN_ARRAY;\n\n\t\tcase JBI_ARRAY_ELEM:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All elements within array already processed.  Report this\n\t\t\t\t * to caller, and give it back original parent iterator (which\n\t\t\t\t * independently tracks iteration progress at its level of\n\t\t\t\t * nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_ARRAY;\n\t\t\t}\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t/* Recurse into container. */\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scalar item in array, or a container and caller didn't want\n\t\t\t\t * us to recurse into it.\n\t\t\t\t */\n\t\t\t\treturn WJB_ELEM;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_START:\n\t\t\t/* Set v to object on first object call */\n\t\t\tval->type = jbvObject;\n\t\t\tval->val.object.nPairs = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.object.pairs is not actually set, because we aren't\n\t\t\t * doing a full conversion\n\t\t\t */\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = getJsonbOffset((*it)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t   (*it)->nElems);\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\t\t\treturn WJB_BEGIN_OBJECT;\n\n\t\tcase JBI_OBJECT_KEY:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All pairs within object already processed.  Report this to\n\t\t\t\t * caller, and give it back original containing iterator\n\t\t\t\t * (which independently tracks iteration progress at its level\n\t\t\t\t * of nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_OBJECT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Return key of a key/value pair.  */\n\t\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t\t   val);\n\t\t\t\tif (val->type != jbvString)\n\t\t\t\t\telog(ERROR, \"unexpected jsonb type as object key\");\n\n\t\t\t\t/* Set state for next call */\n\t\t\t\t(*it)->state = JBI_OBJECT_VALUE;\n\t\t\t\treturn WJB_KEY;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_VALUE:\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex + (*it)->nElems,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curValueOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curValueOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex + (*it)->nElems]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\t/*\n\t\t\t * Value may be a container, in which case we recurse with new,\n\t\t\t * child iterator (unless the caller asked not to, by passing\n\t\t\t * skipNested).\n\t\t\t */\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn WJB_VALUE;\n\t}\n\n\telog(ERROR, \"invalid iterator state\");\n\treturn -1;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbIterator *freeAndGetParent(JsonbIterator *it);",
            "static void uniqueifyJsonbObject(JsonbValue *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbIterator *freeAndGetParent(JsonbIterator *it);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\n\nJsonbIteratorToken\nJsonbIteratorNext(JsonbIterator **it, JsonbValue *val, bool skipNested)\n{\n\tif (*it == NULL)\n\t\treturn WJB_DONE;\n\n\t/*\n\t * When stepping into a nested container, we jump back here to start\n\t * processing the child. We will not recurse further in one call, because\n\t * processing the child will always begin in JBI_ARRAY_START or\n\t * JBI_OBJECT_START state.\n\t */\nrecurse:\n\tswitch ((*it)->state)\n\t{\n\t\tcase JBI_ARRAY_START:\n\t\t\t/* Set v to array on first array call */\n\t\t\tval->type = jbvArray;\n\t\t\tval->val.array.nElems = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.array.elems is not actually set, because we aren't doing\n\t\t\t * a full conversion\n\t\t\t */\n\t\t\tval->val.array.rawScalar = (*it)->isScalar;\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = 0;\t/* not actually used */\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_ARRAY_ELEM;\n\t\t\treturn WJB_BEGIN_ARRAY;\n\n\t\tcase JBI_ARRAY_ELEM:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All elements within array already processed.  Report this\n\t\t\t\t * to caller, and give it back original parent iterator (which\n\t\t\t\t * independently tracks iteration progress at its level of\n\t\t\t\t * nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_ARRAY;\n\t\t\t}\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t/* Recurse into container. */\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scalar item in array, or a container and caller didn't want\n\t\t\t\t * us to recurse into it.\n\t\t\t\t */\n\t\t\t\treturn WJB_ELEM;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_START:\n\t\t\t/* Set v to object on first object call */\n\t\t\tval->type = jbvObject;\n\t\t\tval->val.object.nPairs = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.object.pairs is not actually set, because we aren't\n\t\t\t * doing a full conversion\n\t\t\t */\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = getJsonbOffset((*it)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t   (*it)->nElems);\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\t\t\treturn WJB_BEGIN_OBJECT;\n\n\t\tcase JBI_OBJECT_KEY:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All pairs within object already processed.  Report this to\n\t\t\t\t * caller, and give it back original containing iterator\n\t\t\t\t * (which independently tracks iteration progress at its level\n\t\t\t\t * of nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_OBJECT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Return key of a key/value pair.  */\n\t\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t\t   val);\n\t\t\t\tif (val->type != jbvString)\n\t\t\t\t\telog(ERROR, \"unexpected jsonb type as object key\");\n\n\t\t\t\t/* Set state for next call */\n\t\t\t\t(*it)->state = JBI_OBJECT_VALUE;\n\t\t\t\treturn WJB_KEY;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_VALUE:\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex + (*it)->nElems,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curValueOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curValueOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex + (*it)->nElems]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\t/*\n\t\t\t * Value may be a container, in which case we recurse with new,\n\t\t\t * child iterator (unless the caller asked not to, by passing\n\t\t\t * skipNested).\n\t\t\t */\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn WJB_VALUE;\n\t}\n\n\telog(ERROR, \"invalid iterator state\");\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendBinaryStringInfo",
          "args": [
            "out",
            "\": \"",
            "2"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendBinaryStringInfo",
          "args": [
            "out",
            "\", \"",
            "ispaces"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoCharMacro",
          "args": [
            "out",
            "'{'"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendBinaryStringInfo",
          "args": [
            "out",
            "\", \"",
            "ispaces"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoCharMacro",
          "args": [
            "out",
            "'['"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendBinaryStringInfo",
          "args": [
            "out",
            "\", \"",
            "ispaces"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JsonbIteratorInit",
          "args": [
            "in"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbIteratorInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "717-721",
          "snippet": "JsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nJsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "enlargeStringInfo",
          "args": [
            "out",
            "(estimated_len >= 0) ? estimated_len : 64"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeStringInfo",
          "args": [],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic char *JsonbToCStringWorker(StringInfo out, JsonbContainer *in, int estimated_len, bool indent);\nstatic void add_indent(StringInfo out, bool indent, int level);\n\nstatic char *\nJsonbToCStringWorker(StringInfo out, JsonbContainer *in, int estimated_len, bool indent)\n{\n\tbool\t\tfirst = true;\n\tJsonbIterator *it;\n\tJsonbValue\tv;\n\tJsonbIteratorToken type = WJB_DONE;\n\tint\t\t\tlevel = 0;\n\tbool\t\tredo_switch = false;\n\n\t/* If we are indenting, don't add a space after a comma */\n\tint\t\t\tispaces = indent ? 1 : 2;\n\n\t/*\n\t * Don't indent the very first item. This gets set to the indent flag at\n\t * the bottom of the loop.\n\t */\n\tbool\t\tuse_indent = false;\n\tbool\t\traw_scalar = false;\n\tbool\t\tlast_was_key = false;\n\n\tif (out == NULL)\n\t\tout = makeStringInfo();\n\n\tenlargeStringInfo(out, (estimated_len >= 0) ? estimated_len : 64);\n\n\tit = JsonbIteratorInit(in);\n\n\twhile (redo_switch ||\n\t\t   ((type = JsonbIteratorNext(&it, &v, false)) != WJB_DONE))\n\t{\n\t\tredo_switch = false;\n\t\tswitch (type)\n\t\t{\n\t\t\tcase WJB_BEGIN_ARRAY:\n\t\t\t\tif (!first)\n\t\t\t\t\tappendBinaryStringInfo(out, \", \", ispaces);\n\n\t\t\t\tif (!v.val.array.rawScalar)\n\t\t\t\t{\n\t\t\t\t\tadd_indent(out, use_indent && !last_was_key, level);\n\t\t\t\t\tappendStringInfoCharMacro(out, '[');\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\traw_scalar = true;\n\n\t\t\t\tfirst = true;\n\t\t\t\tlevel++;\n\t\t\t\tbreak;\n\t\t\tcase WJB_BEGIN_OBJECT:\n\t\t\t\tif (!first)\n\t\t\t\t\tappendBinaryStringInfo(out, \", \", ispaces);\n\n\t\t\t\tadd_indent(out, use_indent && !last_was_key, level);\n\t\t\t\tappendStringInfoCharMacro(out, '{');\n\n\t\t\t\tfirst = true;\n\t\t\t\tlevel++;\n\t\t\t\tbreak;\n\t\t\tcase WJB_KEY:\n\t\t\t\tif (!first)\n\t\t\t\t\tappendBinaryStringInfo(out, \", \", ispaces);\n\t\t\t\tfirst = true;\n\n\t\t\t\tadd_indent(out, use_indent, level);\n\n\t\t\t\t/* json rules guarantee this is a string */\n\t\t\t\tjsonb_put_escaped_value(out, &v);\n\t\t\t\tappendBinaryStringInfo(out, \": \", 2);\n\n\t\t\t\ttype = JsonbIteratorNext(&it, &v, false);\n\t\t\t\tif (type == WJB_VALUE)\n\t\t\t\t{\n\t\t\t\t\tfirst = false;\n\t\t\t\t\tjsonb_put_escaped_value(out, &v);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tAssert(type == WJB_BEGIN_OBJECT || type == WJB_BEGIN_ARRAY);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * We need to rerun the current switch() since we need to\n\t\t\t\t\t * output the object which we just got from the iterator\n\t\t\t\t\t * before calling the iterator again.\n\t\t\t\t\t */\n\t\t\t\t\tredo_switch = true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase WJB_ELEM:\n\t\t\t\tif (!first)\n\t\t\t\t\tappendBinaryStringInfo(out, \", \", ispaces);\n\t\t\t\tfirst = false;\n\n\t\t\t\tif (!raw_scalar)\n\t\t\t\t\tadd_indent(out, use_indent, level);\n\t\t\t\tjsonb_put_escaped_value(out, &v);\n\t\t\t\tbreak;\n\t\t\tcase WJB_END_ARRAY:\n\t\t\t\tlevel--;\n\t\t\t\tif (!raw_scalar)\n\t\t\t\t{\n\t\t\t\t\tadd_indent(out, use_indent, level);\n\t\t\t\t\tappendStringInfoCharMacro(out, ']');\n\t\t\t\t}\n\t\t\t\tfirst = false;\n\t\t\t\tbreak;\n\t\t\tcase WJB_END_OBJECT:\n\t\t\t\tlevel--;\n\t\t\t\tadd_indent(out, use_indent, level);\n\t\t\t\tappendStringInfoCharMacro(out, '}');\n\t\t\t\tfirst = false;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unknown jsonb iterator token type\");\n\t\t}\n\t\tuse_indent = indent;\n\t\tlast_was_key = redo_switch;\n\t}\n\n\tAssert(level == 0);\n\n\treturn out->data;\n}"
  },
  {
    "function_name": "JsonbToCStringIndent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
    "lines": "439-443",
    "snippet": "char *\nJsonbToCStringIndent(StringInfo out, JsonbContainer *in, int estimated_len)\n{\n\treturn JsonbToCStringWorker(out, in, estimated_len, true);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"miscadmin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "JsonbToCStringWorker",
          "args": [
            "out",
            "in",
            "estimated_len",
            "true"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbToCStringWorker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
          "lines": "448-570",
          "snippet": "static char *\nJsonbToCStringWorker(StringInfo out, JsonbContainer *in, int estimated_len, bool indent)\n{\n\tbool\t\tfirst = true;\n\tJsonbIterator *it;\n\tJsonbValue\tv;\n\tJsonbIteratorToken type = WJB_DONE;\n\tint\t\t\tlevel = 0;\n\tbool\t\tredo_switch = false;\n\n\t/* If we are indenting, don't add a space after a comma */\n\tint\t\t\tispaces = indent ? 1 : 2;\n\n\t/*\n\t * Don't indent the very first item. This gets set to the indent flag at\n\t * the bottom of the loop.\n\t */\n\tbool\t\tuse_indent = false;\n\tbool\t\traw_scalar = false;\n\tbool\t\tlast_was_key = false;\n\n\tif (out == NULL)\n\t\tout = makeStringInfo();\n\n\tenlargeStringInfo(out, (estimated_len >= 0) ? estimated_len : 64);\n\n\tit = JsonbIteratorInit(in);\n\n\twhile (redo_switch ||\n\t\t   ((type = JsonbIteratorNext(&it, &v, false)) != WJB_DONE))\n\t{\n\t\tredo_switch = false;\n\t\tswitch (type)\n\t\t{\n\t\t\tcase WJB_BEGIN_ARRAY:\n\t\t\t\tif (!first)\n\t\t\t\t\tappendBinaryStringInfo(out, \", \", ispaces);\n\n\t\t\t\tif (!v.val.array.rawScalar)\n\t\t\t\t{\n\t\t\t\t\tadd_indent(out, use_indent && !last_was_key, level);\n\t\t\t\t\tappendStringInfoCharMacro(out, '[');\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\traw_scalar = true;\n\n\t\t\t\tfirst = true;\n\t\t\t\tlevel++;\n\t\t\t\tbreak;\n\t\t\tcase WJB_BEGIN_OBJECT:\n\t\t\t\tif (!first)\n\t\t\t\t\tappendBinaryStringInfo(out, \", \", ispaces);\n\n\t\t\t\tadd_indent(out, use_indent && !last_was_key, level);\n\t\t\t\tappendStringInfoCharMacro(out, '{');\n\n\t\t\t\tfirst = true;\n\t\t\t\tlevel++;\n\t\t\t\tbreak;\n\t\t\tcase WJB_KEY:\n\t\t\t\tif (!first)\n\t\t\t\t\tappendBinaryStringInfo(out, \", \", ispaces);\n\t\t\t\tfirst = true;\n\n\t\t\t\tadd_indent(out, use_indent, level);\n\n\t\t\t\t/* json rules guarantee this is a string */\n\t\t\t\tjsonb_put_escaped_value(out, &v);\n\t\t\t\tappendBinaryStringInfo(out, \": \", 2);\n\n\t\t\t\ttype = JsonbIteratorNext(&it, &v, false);\n\t\t\t\tif (type == WJB_VALUE)\n\t\t\t\t{\n\t\t\t\t\tfirst = false;\n\t\t\t\t\tjsonb_put_escaped_value(out, &v);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tAssert(type == WJB_BEGIN_OBJECT || type == WJB_BEGIN_ARRAY);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * We need to rerun the current switch() since we need to\n\t\t\t\t\t * output the object which we just got from the iterator\n\t\t\t\t\t * before calling the iterator again.\n\t\t\t\t\t */\n\t\t\t\t\tredo_switch = true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase WJB_ELEM:\n\t\t\t\tif (!first)\n\t\t\t\t\tappendBinaryStringInfo(out, \", \", ispaces);\n\t\t\t\tfirst = false;\n\n\t\t\t\tif (!raw_scalar)\n\t\t\t\t\tadd_indent(out, use_indent, level);\n\t\t\t\tjsonb_put_escaped_value(out, &v);\n\t\t\t\tbreak;\n\t\t\tcase WJB_END_ARRAY:\n\t\t\t\tlevel--;\n\t\t\t\tif (!raw_scalar)\n\t\t\t\t{\n\t\t\t\t\tadd_indent(out, use_indent, level);\n\t\t\t\t\tappendStringInfoCharMacro(out, ']');\n\t\t\t\t}\n\t\t\t\tfirst = false;\n\t\t\t\tbreak;\n\t\t\tcase WJB_END_OBJECT:\n\t\t\t\tlevel--;\n\t\t\t\tadd_indent(out, use_indent, level);\n\t\t\t\tappendStringInfoCharMacro(out, '}');\n\t\t\t\tfirst = false;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unknown jsonb iterator token type\");\n\t\t}\n\t\tuse_indent = indent;\n\t\tlast_was_key = redo_switch;\n\t}\n\n\tAssert(level == 0);\n\n\treturn out->data;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"miscadmin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *JsonbToCStringWorker(StringInfo out, JsonbContainer *in, int estimated_len, bool indent);",
            "static void add_indent(StringInfo out, bool indent, int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic char *JsonbToCStringWorker(StringInfo out, JsonbContainer *in, int estimated_len, bool indent);\nstatic void add_indent(StringInfo out, bool indent, int level);\n\nstatic char *\nJsonbToCStringWorker(StringInfo out, JsonbContainer *in, int estimated_len, bool indent)\n{\n\tbool\t\tfirst = true;\n\tJsonbIterator *it;\n\tJsonbValue\tv;\n\tJsonbIteratorToken type = WJB_DONE;\n\tint\t\t\tlevel = 0;\n\tbool\t\tredo_switch = false;\n\n\t/* If we are indenting, don't add a space after a comma */\n\tint\t\t\tispaces = indent ? 1 : 2;\n\n\t/*\n\t * Don't indent the very first item. This gets set to the indent flag at\n\t * the bottom of the loop.\n\t */\n\tbool\t\tuse_indent = false;\n\tbool\t\traw_scalar = false;\n\tbool\t\tlast_was_key = false;\n\n\tif (out == NULL)\n\t\tout = makeStringInfo();\n\n\tenlargeStringInfo(out, (estimated_len >= 0) ? estimated_len : 64);\n\n\tit = JsonbIteratorInit(in);\n\n\twhile (redo_switch ||\n\t\t   ((type = JsonbIteratorNext(&it, &v, false)) != WJB_DONE))\n\t{\n\t\tredo_switch = false;\n\t\tswitch (type)\n\t\t{\n\t\t\tcase WJB_BEGIN_ARRAY:\n\t\t\t\tif (!first)\n\t\t\t\t\tappendBinaryStringInfo(out, \", \", ispaces);\n\n\t\t\t\tif (!v.val.array.rawScalar)\n\t\t\t\t{\n\t\t\t\t\tadd_indent(out, use_indent && !last_was_key, level);\n\t\t\t\t\tappendStringInfoCharMacro(out, '[');\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\traw_scalar = true;\n\n\t\t\t\tfirst = true;\n\t\t\t\tlevel++;\n\t\t\t\tbreak;\n\t\t\tcase WJB_BEGIN_OBJECT:\n\t\t\t\tif (!first)\n\t\t\t\t\tappendBinaryStringInfo(out, \", \", ispaces);\n\n\t\t\t\tadd_indent(out, use_indent && !last_was_key, level);\n\t\t\t\tappendStringInfoCharMacro(out, '{');\n\n\t\t\t\tfirst = true;\n\t\t\t\tlevel++;\n\t\t\t\tbreak;\n\t\t\tcase WJB_KEY:\n\t\t\t\tif (!first)\n\t\t\t\t\tappendBinaryStringInfo(out, \", \", ispaces);\n\t\t\t\tfirst = true;\n\n\t\t\t\tadd_indent(out, use_indent, level);\n\n\t\t\t\t/* json rules guarantee this is a string */\n\t\t\t\tjsonb_put_escaped_value(out, &v);\n\t\t\t\tappendBinaryStringInfo(out, \": \", 2);\n\n\t\t\t\ttype = JsonbIteratorNext(&it, &v, false);\n\t\t\t\tif (type == WJB_VALUE)\n\t\t\t\t{\n\t\t\t\t\tfirst = false;\n\t\t\t\t\tjsonb_put_escaped_value(out, &v);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tAssert(type == WJB_BEGIN_OBJECT || type == WJB_BEGIN_ARRAY);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * We need to rerun the current switch() since we need to\n\t\t\t\t\t * output the object which we just got from the iterator\n\t\t\t\t\t * before calling the iterator again.\n\t\t\t\t\t */\n\t\t\t\t\tredo_switch = true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase WJB_ELEM:\n\t\t\t\tif (!first)\n\t\t\t\t\tappendBinaryStringInfo(out, \", \", ispaces);\n\t\t\t\tfirst = false;\n\n\t\t\t\tif (!raw_scalar)\n\t\t\t\t\tadd_indent(out, use_indent, level);\n\t\t\t\tjsonb_put_escaped_value(out, &v);\n\t\t\t\tbreak;\n\t\t\tcase WJB_END_ARRAY:\n\t\t\t\tlevel--;\n\t\t\t\tif (!raw_scalar)\n\t\t\t\t{\n\t\t\t\t\tadd_indent(out, use_indent, level);\n\t\t\t\t\tappendStringInfoCharMacro(out, ']');\n\t\t\t\t}\n\t\t\t\tfirst = false;\n\t\t\t\tbreak;\n\t\t\tcase WJB_END_OBJECT:\n\t\t\t\tlevel--;\n\t\t\t\tadd_indent(out, use_indent, level);\n\t\t\t\tappendStringInfoCharMacro(out, '}');\n\t\t\t\tfirst = false;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unknown jsonb iterator token type\");\n\t\t}\n\t\tuse_indent = indent;\n\t\tlast_was_key = redo_switch;\n\t}\n\n\tAssert(level == 0);\n\n\treturn out->data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nchar *\nJsonbToCStringIndent(StringInfo out, JsonbContainer *in, int estimated_len)\n{\n\treturn JsonbToCStringWorker(out, in, estimated_len, true);\n}"
  },
  {
    "function_name": "JsonbToCString",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
    "lines": "430-434",
    "snippet": "char *\nJsonbToCString(StringInfo out, JsonbContainer *in, int estimated_len)\n{\n\treturn JsonbToCStringWorker(out, in, estimated_len, false);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"miscadmin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "JsonbToCStringWorker",
          "args": [
            "out",
            "in",
            "estimated_len",
            "false"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbToCStringWorker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
          "lines": "448-570",
          "snippet": "static char *\nJsonbToCStringWorker(StringInfo out, JsonbContainer *in, int estimated_len, bool indent)\n{\n\tbool\t\tfirst = true;\n\tJsonbIterator *it;\n\tJsonbValue\tv;\n\tJsonbIteratorToken type = WJB_DONE;\n\tint\t\t\tlevel = 0;\n\tbool\t\tredo_switch = false;\n\n\t/* If we are indenting, don't add a space after a comma */\n\tint\t\t\tispaces = indent ? 1 : 2;\n\n\t/*\n\t * Don't indent the very first item. This gets set to the indent flag at\n\t * the bottom of the loop.\n\t */\n\tbool\t\tuse_indent = false;\n\tbool\t\traw_scalar = false;\n\tbool\t\tlast_was_key = false;\n\n\tif (out == NULL)\n\t\tout = makeStringInfo();\n\n\tenlargeStringInfo(out, (estimated_len >= 0) ? estimated_len : 64);\n\n\tit = JsonbIteratorInit(in);\n\n\twhile (redo_switch ||\n\t\t   ((type = JsonbIteratorNext(&it, &v, false)) != WJB_DONE))\n\t{\n\t\tredo_switch = false;\n\t\tswitch (type)\n\t\t{\n\t\t\tcase WJB_BEGIN_ARRAY:\n\t\t\t\tif (!first)\n\t\t\t\t\tappendBinaryStringInfo(out, \", \", ispaces);\n\n\t\t\t\tif (!v.val.array.rawScalar)\n\t\t\t\t{\n\t\t\t\t\tadd_indent(out, use_indent && !last_was_key, level);\n\t\t\t\t\tappendStringInfoCharMacro(out, '[');\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\traw_scalar = true;\n\n\t\t\t\tfirst = true;\n\t\t\t\tlevel++;\n\t\t\t\tbreak;\n\t\t\tcase WJB_BEGIN_OBJECT:\n\t\t\t\tif (!first)\n\t\t\t\t\tappendBinaryStringInfo(out, \", \", ispaces);\n\n\t\t\t\tadd_indent(out, use_indent && !last_was_key, level);\n\t\t\t\tappendStringInfoCharMacro(out, '{');\n\n\t\t\t\tfirst = true;\n\t\t\t\tlevel++;\n\t\t\t\tbreak;\n\t\t\tcase WJB_KEY:\n\t\t\t\tif (!first)\n\t\t\t\t\tappendBinaryStringInfo(out, \", \", ispaces);\n\t\t\t\tfirst = true;\n\n\t\t\t\tadd_indent(out, use_indent, level);\n\n\t\t\t\t/* json rules guarantee this is a string */\n\t\t\t\tjsonb_put_escaped_value(out, &v);\n\t\t\t\tappendBinaryStringInfo(out, \": \", 2);\n\n\t\t\t\ttype = JsonbIteratorNext(&it, &v, false);\n\t\t\t\tif (type == WJB_VALUE)\n\t\t\t\t{\n\t\t\t\t\tfirst = false;\n\t\t\t\t\tjsonb_put_escaped_value(out, &v);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tAssert(type == WJB_BEGIN_OBJECT || type == WJB_BEGIN_ARRAY);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * We need to rerun the current switch() since we need to\n\t\t\t\t\t * output the object which we just got from the iterator\n\t\t\t\t\t * before calling the iterator again.\n\t\t\t\t\t */\n\t\t\t\t\tredo_switch = true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase WJB_ELEM:\n\t\t\t\tif (!first)\n\t\t\t\t\tappendBinaryStringInfo(out, \", \", ispaces);\n\t\t\t\tfirst = false;\n\n\t\t\t\tif (!raw_scalar)\n\t\t\t\t\tadd_indent(out, use_indent, level);\n\t\t\t\tjsonb_put_escaped_value(out, &v);\n\t\t\t\tbreak;\n\t\t\tcase WJB_END_ARRAY:\n\t\t\t\tlevel--;\n\t\t\t\tif (!raw_scalar)\n\t\t\t\t{\n\t\t\t\t\tadd_indent(out, use_indent, level);\n\t\t\t\t\tappendStringInfoCharMacro(out, ']');\n\t\t\t\t}\n\t\t\t\tfirst = false;\n\t\t\t\tbreak;\n\t\t\tcase WJB_END_OBJECT:\n\t\t\t\tlevel--;\n\t\t\t\tadd_indent(out, use_indent, level);\n\t\t\t\tappendStringInfoCharMacro(out, '}');\n\t\t\t\tfirst = false;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unknown jsonb iterator token type\");\n\t\t}\n\t\tuse_indent = indent;\n\t\tlast_was_key = redo_switch;\n\t}\n\n\tAssert(level == 0);\n\n\treturn out->data;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"miscadmin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *JsonbToCStringWorker(StringInfo out, JsonbContainer *in, int estimated_len, bool indent);",
            "static void add_indent(StringInfo out, bool indent, int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic char *JsonbToCStringWorker(StringInfo out, JsonbContainer *in, int estimated_len, bool indent);\nstatic void add_indent(StringInfo out, bool indent, int level);\n\nstatic char *\nJsonbToCStringWorker(StringInfo out, JsonbContainer *in, int estimated_len, bool indent)\n{\n\tbool\t\tfirst = true;\n\tJsonbIterator *it;\n\tJsonbValue\tv;\n\tJsonbIteratorToken type = WJB_DONE;\n\tint\t\t\tlevel = 0;\n\tbool\t\tredo_switch = false;\n\n\t/* If we are indenting, don't add a space after a comma */\n\tint\t\t\tispaces = indent ? 1 : 2;\n\n\t/*\n\t * Don't indent the very first item. This gets set to the indent flag at\n\t * the bottom of the loop.\n\t */\n\tbool\t\tuse_indent = false;\n\tbool\t\traw_scalar = false;\n\tbool\t\tlast_was_key = false;\n\n\tif (out == NULL)\n\t\tout = makeStringInfo();\n\n\tenlargeStringInfo(out, (estimated_len >= 0) ? estimated_len : 64);\n\n\tit = JsonbIteratorInit(in);\n\n\twhile (redo_switch ||\n\t\t   ((type = JsonbIteratorNext(&it, &v, false)) != WJB_DONE))\n\t{\n\t\tredo_switch = false;\n\t\tswitch (type)\n\t\t{\n\t\t\tcase WJB_BEGIN_ARRAY:\n\t\t\t\tif (!first)\n\t\t\t\t\tappendBinaryStringInfo(out, \", \", ispaces);\n\n\t\t\t\tif (!v.val.array.rawScalar)\n\t\t\t\t{\n\t\t\t\t\tadd_indent(out, use_indent && !last_was_key, level);\n\t\t\t\t\tappendStringInfoCharMacro(out, '[');\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\traw_scalar = true;\n\n\t\t\t\tfirst = true;\n\t\t\t\tlevel++;\n\t\t\t\tbreak;\n\t\t\tcase WJB_BEGIN_OBJECT:\n\t\t\t\tif (!first)\n\t\t\t\t\tappendBinaryStringInfo(out, \", \", ispaces);\n\n\t\t\t\tadd_indent(out, use_indent && !last_was_key, level);\n\t\t\t\tappendStringInfoCharMacro(out, '{');\n\n\t\t\t\tfirst = true;\n\t\t\t\tlevel++;\n\t\t\t\tbreak;\n\t\t\tcase WJB_KEY:\n\t\t\t\tif (!first)\n\t\t\t\t\tappendBinaryStringInfo(out, \", \", ispaces);\n\t\t\t\tfirst = true;\n\n\t\t\t\tadd_indent(out, use_indent, level);\n\n\t\t\t\t/* json rules guarantee this is a string */\n\t\t\t\tjsonb_put_escaped_value(out, &v);\n\t\t\t\tappendBinaryStringInfo(out, \": \", 2);\n\n\t\t\t\ttype = JsonbIteratorNext(&it, &v, false);\n\t\t\t\tif (type == WJB_VALUE)\n\t\t\t\t{\n\t\t\t\t\tfirst = false;\n\t\t\t\t\tjsonb_put_escaped_value(out, &v);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tAssert(type == WJB_BEGIN_OBJECT || type == WJB_BEGIN_ARRAY);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * We need to rerun the current switch() since we need to\n\t\t\t\t\t * output the object which we just got from the iterator\n\t\t\t\t\t * before calling the iterator again.\n\t\t\t\t\t */\n\t\t\t\t\tredo_switch = true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase WJB_ELEM:\n\t\t\t\tif (!first)\n\t\t\t\t\tappendBinaryStringInfo(out, \", \", ispaces);\n\t\t\t\tfirst = false;\n\n\t\t\t\tif (!raw_scalar)\n\t\t\t\t\tadd_indent(out, use_indent, level);\n\t\t\t\tjsonb_put_escaped_value(out, &v);\n\t\t\t\tbreak;\n\t\t\tcase WJB_END_ARRAY:\n\t\t\t\tlevel--;\n\t\t\t\tif (!raw_scalar)\n\t\t\t\t{\n\t\t\t\t\tadd_indent(out, use_indent, level);\n\t\t\t\t\tappendStringInfoCharMacro(out, ']');\n\t\t\t\t}\n\t\t\t\tfirst = false;\n\t\t\t\tbreak;\n\t\t\tcase WJB_END_OBJECT:\n\t\t\t\tlevel--;\n\t\t\t\tadd_indent(out, use_indent, level);\n\t\t\t\tappendStringInfoCharMacro(out, '}');\n\t\t\t\tfirst = false;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unknown jsonb iterator token type\");\n\t\t}\n\t\tuse_indent = indent;\n\t\tlast_was_key = redo_switch;\n\t}\n\n\tAssert(level == 0);\n\n\treturn out->data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nchar *\nJsonbToCString(StringInfo out, JsonbContainer *in, int estimated_len)\n{\n\treturn JsonbToCStringWorker(out, in, estimated_len, false);\n}"
  },
  {
    "function_name": "jsonb_in_scalar",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
    "lines": "341-417",
    "snippet": "static void\njsonb_in_scalar(void *pstate, char *token, JsonTokenType tokentype)\n{\n\tJsonbInState *_state = (JsonbInState *) pstate;\n\tJsonbValue\tv;\n\tDatum\t\tnumd;\n\n\tswitch (tokentype)\n\t{\n\n\t\tcase JSON_TOKEN_STRING:\n\t\t\tAssert(token != NULL);\n\t\t\tv.type = jbvString;\n\t\t\tv.val.string.len = checkStringLen(strlen(token));\n\t\t\tv.val.string.val = token;\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_NUMBER:\n\n\t\t\t/*\n\t\t\t * No need to check size of numeric values, because maximum\n\t\t\t * numeric size is well below the JsonbValue restriction\n\t\t\t */\n\t\t\tAssert(token != NULL);\n\t\t\tv.type = jbvNumeric;\n\t\t\tnumd = DirectFunctionCall3(numeric_in,\n\t\t\t\t\t\t\t\t\t   CStringGetDatum(token),\n\t\t\t\t\t\t\t\t\t   ObjectIdGetDatum(InvalidOid),\n\t\t\t\t\t\t\t\t\t   Int32GetDatum(-1));\n\t\t\tv.val.numeric = DatumGetNumeric(numd);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_TRUE:\n\t\t\tv.type = jbvBool;\n\t\t\tv.val.boolean = true;\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_FALSE:\n\t\t\tv.type = jbvBool;\n\t\t\tv.val.boolean = false;\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_NULL:\n\t\t\tv.type = jbvNull;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* should not be possible */\n\t\t\telog(ERROR, \"invalid json token type\");\n\t\t\tbreak;\n\t}\n\n\tif (_state->parseState == NULL)\n\t{\n\t\t/* single scalar */\n\t\tJsonbValue\tva;\n\n\t\tva.type = jbvArray;\n\t\tva.val.array.rawScalar = true;\n\t\tva.val.array.nElems = 1;\n\n\t\t_state->res = pushJsonbValue(&_state->parseState, WJB_BEGIN_ARRAY, &va);\n\t\t_state->res = pushJsonbValue(&_state->parseState, WJB_ELEM, &v);\n\t\t_state->res = pushJsonbValue(&_state->parseState, WJB_END_ARRAY, NULL);\n\t}\n\telse\n\t{\n\t\tJsonbValue *o = &_state->parseState->contVal;\n\n\t\tswitch (o->type)\n\t\t{\n\t\t\tcase jbvArray:\n\t\t\t\t_state->res = pushJsonbValue(&_state->parseState, WJB_ELEM, &v);\n\t\t\t\tbreak;\n\t\t\tcase jbvObject:\n\t\t\t\t_state->res = pushJsonbValue(&_state->parseState, WJB_VALUE, &v);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unexpected parent of nested structure\");\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"miscadmin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static inline Datum jsonb_from_cstring(char *json, int len);",
      "static size_t checkStringLen(size_t len);",
      "static void jsonb_in_object_start(void *pstate);",
      "static void jsonb_in_object_end(void *pstate);",
      "static void jsonb_in_array_start(void *pstate);",
      "static void jsonb_in_array_end(void *pstate);",
      "static void jsonb_in_scalar(void *pstate, char *token, JsonTokenType tokentype);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unexpected parent of nested structure\""
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pushJsonbValue",
          "args": [
            "&_state->parseState",
            "WJB_VALUE",
            "&v"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "pushJsonbValueScalar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "545-629",
          "snippet": "static JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);",
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbParseState *pushState(JsonbParseState **pstate);",
            "static void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void uniqueifyJsonbObject(JsonbValue *object);",
            "static JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\nstatic void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\nstatic JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);\n\nstatic JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetNumeric",
          "args": [
            "numd"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall3",
          "args": [
            "numeric_in",
            "CStringGetDatum(token)",
            "ObjectIdGetDatum(InvalidOid)",
            "Int32GetDatum(-1)"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int32GetDatum",
          "args": [
            "-1"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "InvalidOid"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CStringGetDatum",
          "args": [
            "token"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "token != NULL"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "checkStringLen",
          "args": [
            "strlen(token)"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "checkStringLen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
          "lines": "252-263",
          "snippet": "static size_t\ncheckStringLen(size_t len)\n{\n\tif (len > JENTRY_OFFLENMASK)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"string too long to represent as jsonb string\"),\n\t\t\t\t errdetail(\"Due to an implementation restriction, jsonb strings cannot exceed %d bytes.\",\n\t\t\t\t\t\t   JENTRY_OFFLENMASK)));\n\n\treturn len;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"miscadmin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline Datum jsonb_from_cstring(char *json, int len);",
            "static size_t checkStringLen(size_t len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic inline Datum jsonb_from_cstring(char *json, int len);\nstatic size_t checkStringLen(size_t len);\n\nstatic size_t\ncheckStringLen(size_t len)\n{\n\tif (len > JENTRY_OFFLENMASK)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"string too long to represent as jsonb string\"),\n\t\t\t\t errdetail(\"Due to an implementation restriction, jsonb strings cannot exceed %d bytes.\",\n\t\t\t\t\t\t   JENTRY_OFFLENMASK)));\n\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "token"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "token != NULL"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic inline Datum jsonb_from_cstring(char *json, int len);\nstatic size_t checkStringLen(size_t len);\nstatic void jsonb_in_object_start(void *pstate);\nstatic void jsonb_in_object_end(void *pstate);\nstatic void jsonb_in_array_start(void *pstate);\nstatic void jsonb_in_array_end(void *pstate);\nstatic void jsonb_in_scalar(void *pstate, char *token, JsonTokenType tokentype);\n\nstatic void\njsonb_in_scalar(void *pstate, char *token, JsonTokenType tokentype)\n{\n\tJsonbInState *_state = (JsonbInState *) pstate;\n\tJsonbValue\tv;\n\tDatum\t\tnumd;\n\n\tswitch (tokentype)\n\t{\n\n\t\tcase JSON_TOKEN_STRING:\n\t\t\tAssert(token != NULL);\n\t\t\tv.type = jbvString;\n\t\t\tv.val.string.len = checkStringLen(strlen(token));\n\t\t\tv.val.string.val = token;\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_NUMBER:\n\n\t\t\t/*\n\t\t\t * No need to check size of numeric values, because maximum\n\t\t\t * numeric size is well below the JsonbValue restriction\n\t\t\t */\n\t\t\tAssert(token != NULL);\n\t\t\tv.type = jbvNumeric;\n\t\t\tnumd = DirectFunctionCall3(numeric_in,\n\t\t\t\t\t\t\t\t\t   CStringGetDatum(token),\n\t\t\t\t\t\t\t\t\t   ObjectIdGetDatum(InvalidOid),\n\t\t\t\t\t\t\t\t\t   Int32GetDatum(-1));\n\t\t\tv.val.numeric = DatumGetNumeric(numd);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_TRUE:\n\t\t\tv.type = jbvBool;\n\t\t\tv.val.boolean = true;\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_FALSE:\n\t\t\tv.type = jbvBool;\n\t\t\tv.val.boolean = false;\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_NULL:\n\t\t\tv.type = jbvNull;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* should not be possible */\n\t\t\telog(ERROR, \"invalid json token type\");\n\t\t\tbreak;\n\t}\n\n\tif (_state->parseState == NULL)\n\t{\n\t\t/* single scalar */\n\t\tJsonbValue\tva;\n\n\t\tva.type = jbvArray;\n\t\tva.val.array.rawScalar = true;\n\t\tva.val.array.nElems = 1;\n\n\t\t_state->res = pushJsonbValue(&_state->parseState, WJB_BEGIN_ARRAY, &va);\n\t\t_state->res = pushJsonbValue(&_state->parseState, WJB_ELEM, &v);\n\t\t_state->res = pushJsonbValue(&_state->parseState, WJB_END_ARRAY, NULL);\n\t}\n\telse\n\t{\n\t\tJsonbValue *o = &_state->parseState->contVal;\n\n\t\tswitch (o->type)\n\t\t{\n\t\t\tcase jbvArray:\n\t\t\t\t_state->res = pushJsonbValue(&_state->parseState, WJB_ELEM, &v);\n\t\t\t\tbreak;\n\t\t\tcase jbvObject:\n\t\t\t\t_state->res = pushJsonbValue(&_state->parseState, WJB_VALUE, &v);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unexpected parent of nested structure\");\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "jsonb_put_escaped_value",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
    "lines": "311-336",
    "snippet": "static void\njsonb_put_escaped_value(StringInfo out, JsonbValue *scalarVal)\n{\n\tswitch (scalarVal->type)\n\t{\n\t\tcase jbvNull:\n\t\t\tappendBinaryStringInfo(out, \"null\", 4);\n\t\t\tbreak;\n\t\tcase jbvString:\n\t\t\tescape_json(out, pnstrdup(scalarVal->val.string.val, scalarVal->val.string.len));\n\t\t\tbreak;\n\t\tcase jbvNumeric:\n\t\t\tappendStringInfoString(out,\n\t\t\t\t\t\t\t\t   DatumGetCString(DirectFunctionCall1(numeric_out,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   PointerGetDatum(scalarVal->val.numeric))));\n\t\t\tbreak;\n\t\tcase jbvBool:\n\t\t\tif (scalarVal->val.boolean)\n\t\t\t\tappendBinaryStringInfo(out, \"true\", 4);\n\t\t\telse\n\t\t\t\tappendBinaryStringInfo(out, \"false\", 5);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unknown jsonb scalar type\");\n\t}\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"miscadmin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static inline Datum jsonb_from_cstring(char *json, int len);",
      "static size_t checkStringLen(size_t len);",
      "static void jsonb_put_escaped_value(StringInfo out, JsonbValue *scalarVal);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unknown jsonb scalar type\""
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendBinaryStringInfo",
          "args": [
            "out",
            "\"false\"",
            "5"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendBinaryStringInfo",
          "args": [
            "out",
            "\"true\"",
            "4"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "out",
            "DatumGetCString(DirectFunctionCall1(numeric_out,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   PointerGetDatum(scalarVal->val.numeric)))"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetCString",
          "args": [
            "DirectFunctionCall1(numeric_out,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   PointerGetDatum(scalarVal->val.numeric))"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "numeric_out",
            "PointerGetDatum(scalarVal->val.numeric)"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "scalarVal->val.numeric"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "escape_json",
          "args": [
            "out",
            "pnstrdup(scalarVal->val.string.val, scalarVal->val.string.len)"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "escape_json",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "2460-2500",
          "snippet": "void\nescape_json(StringInfo buf, const char *str)\n{\n\tconst char *p;\n\n\tappendStringInfoCharMacro(buf, '\"');\n\tfor (p = str; *p; p++)\n\t{\n\t\tswitch (*p)\n\t\t{\n\t\t\tcase '\\b':\n\t\t\t\tappendStringInfoString(buf, \"\\\\b\");\n\t\t\t\tbreak;\n\t\t\tcase '\\f':\n\t\t\t\tappendStringInfoString(buf, \"\\\\f\");\n\t\t\t\tbreak;\n\t\t\tcase '\\n':\n\t\t\t\tappendStringInfoString(buf, \"\\\\n\");\n\t\t\t\tbreak;\n\t\t\tcase '\\r':\n\t\t\t\tappendStringInfoString(buf, \"\\\\r\");\n\t\t\t\tbreak;\n\t\t\tcase '\\t':\n\t\t\t\tappendStringInfoString(buf, \"\\\\t\");\n\t\t\t\tbreak;\n\t\t\tcase '\"':\n\t\t\t\tappendStringInfoString(buf, \"\\\\\\\"\");\n\t\t\t\tbreak;\n\t\t\tcase '\\\\':\n\t\t\t\tappendStringInfoString(buf, \"\\\\\\\\\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif ((unsigned char) *p < ' ')\n\t\t\t\t\tappendStringInfo(buf, \"\\\\u%04x\", (int) *p);\n\t\t\t\telse\n\t\t\t\t\tappendStringInfoCharMacro(buf, *p);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tappendStringInfoCharMacro(buf, '\"');\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nescape_json(StringInfo buf, const char *str)\n{\n\tconst char *p;\n\n\tappendStringInfoCharMacro(buf, '\"');\n\tfor (p = str; *p; p++)\n\t{\n\t\tswitch (*p)\n\t\t{\n\t\t\tcase '\\b':\n\t\t\t\tappendStringInfoString(buf, \"\\\\b\");\n\t\t\t\tbreak;\n\t\t\tcase '\\f':\n\t\t\t\tappendStringInfoString(buf, \"\\\\f\");\n\t\t\t\tbreak;\n\t\t\tcase '\\n':\n\t\t\t\tappendStringInfoString(buf, \"\\\\n\");\n\t\t\t\tbreak;\n\t\t\tcase '\\r':\n\t\t\t\tappendStringInfoString(buf, \"\\\\r\");\n\t\t\t\tbreak;\n\t\t\tcase '\\t':\n\t\t\t\tappendStringInfoString(buf, \"\\\\t\");\n\t\t\t\tbreak;\n\t\t\tcase '\"':\n\t\t\t\tappendStringInfoString(buf, \"\\\\\\\"\");\n\t\t\t\tbreak;\n\t\t\tcase '\\\\':\n\t\t\t\tappendStringInfoString(buf, \"\\\\\\\\\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif ((unsigned char) *p < ' ')\n\t\t\t\t\tappendStringInfo(buf, \"\\\\u%04x\", (int) *p);\n\t\t\t\telse\n\t\t\t\t\tappendStringInfoCharMacro(buf, *p);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tappendStringInfoCharMacro(buf, '\"');\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnstrdup",
          "args": [
            "scalarVal->val.string.val",
            "scalarVal->val.string.len"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pnstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1155-1164",
          "snippet": "static xmlChar *\nxml_pnstrdup(const xmlChar *str, size_t len)\n{\n\txmlChar    *result;\n\n\tresult = (xmlChar *) palloc((len + 1) * sizeof(xmlChar));\n\tmemcpy(result, str, len * sizeof(xmlChar));\n\tresult[len] = 0;\n\treturn result;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic xmlChar *\nxml_pnstrdup(const xmlChar *str, size_t len)\n{\n\txmlChar    *result;\n\n\tresult = (xmlChar *) palloc((len + 1) * sizeof(xmlChar));\n\tmemcpy(result, str, len * sizeof(xmlChar));\n\tresult[len] = 0;\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendBinaryStringInfo",
          "args": [
            "out",
            "\"null\"",
            "4"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic inline Datum jsonb_from_cstring(char *json, int len);\nstatic size_t checkStringLen(size_t len);\nstatic void jsonb_put_escaped_value(StringInfo out, JsonbValue *scalarVal);\n\nstatic void\njsonb_put_escaped_value(StringInfo out, JsonbValue *scalarVal)\n{\n\tswitch (scalarVal->type)\n\t{\n\t\tcase jbvNull:\n\t\t\tappendBinaryStringInfo(out, \"null\", 4);\n\t\t\tbreak;\n\t\tcase jbvString:\n\t\t\tescape_json(out, pnstrdup(scalarVal->val.string.val, scalarVal->val.string.len));\n\t\t\tbreak;\n\t\tcase jbvNumeric:\n\t\t\tappendStringInfoString(out,\n\t\t\t\t\t\t\t\t   DatumGetCString(DirectFunctionCall1(numeric_out,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   PointerGetDatum(scalarVal->val.numeric))));\n\t\t\tbreak;\n\t\tcase jbvBool:\n\t\t\tif (scalarVal->val.boolean)\n\t\t\t\tappendBinaryStringInfo(out, \"true\", 4);\n\t\t\telse\n\t\t\t\tappendBinaryStringInfo(out, \"false\", 5);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unknown jsonb scalar type\");\n\t}\n}"
  },
  {
    "function_name": "jsonb_in_object_field_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
    "lines": "297-309",
    "snippet": "static void\njsonb_in_object_field_start(void *pstate, char *fname, bool isnull)\n{\n\tJsonbInState *_state = (JsonbInState *) pstate;\n\tJsonbValue\tv;\n\n\tAssert(fname != NULL);\n\tv.type = jbvString;\n\tv.val.string.len = checkStringLen(strlen(fname));\n\tv.val.string.val = fname;\n\n\t_state->res = pushJsonbValue(&_state->parseState, WJB_KEY, &v);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"miscadmin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static inline Datum jsonb_from_cstring(char *json, int len);",
      "static size_t checkStringLen(size_t len);",
      "static void jsonb_in_object_start(void *pstate);",
      "static void jsonb_in_object_end(void *pstate);",
      "static void jsonb_in_array_start(void *pstate);",
      "static void jsonb_in_array_end(void *pstate);",
      "static void jsonb_in_object_field_start(void *pstate, char *fname, bool isnull);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pushJsonbValue",
          "args": [
            "&_state->parseState",
            "WJB_KEY",
            "&v"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "pushJsonbValueScalar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "545-629",
          "snippet": "static JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);",
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbParseState *pushState(JsonbParseState **pstate);",
            "static void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void uniqueifyJsonbObject(JsonbValue *object);",
            "static JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\nstatic void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\nstatic JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);\n\nstatic JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "checkStringLen",
          "args": [
            "strlen(fname)"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "checkStringLen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
          "lines": "252-263",
          "snippet": "static size_t\ncheckStringLen(size_t len)\n{\n\tif (len > JENTRY_OFFLENMASK)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"string too long to represent as jsonb string\"),\n\t\t\t\t errdetail(\"Due to an implementation restriction, jsonb strings cannot exceed %d bytes.\",\n\t\t\t\t\t\t   JENTRY_OFFLENMASK)));\n\n\treturn len;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"miscadmin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline Datum jsonb_from_cstring(char *json, int len);",
            "static size_t checkStringLen(size_t len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic inline Datum jsonb_from_cstring(char *json, int len);\nstatic size_t checkStringLen(size_t len);\n\nstatic size_t\ncheckStringLen(size_t len)\n{\n\tif (len > JENTRY_OFFLENMASK)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"string too long to represent as jsonb string\"),\n\t\t\t\t errdetail(\"Due to an implementation restriction, jsonb strings cannot exceed %d bytes.\",\n\t\t\t\t\t\t   JENTRY_OFFLENMASK)));\n\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "fname"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "fname != NULL"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic inline Datum jsonb_from_cstring(char *json, int len);\nstatic size_t checkStringLen(size_t len);\nstatic void jsonb_in_object_start(void *pstate);\nstatic void jsonb_in_object_end(void *pstate);\nstatic void jsonb_in_array_start(void *pstate);\nstatic void jsonb_in_array_end(void *pstate);\nstatic void jsonb_in_object_field_start(void *pstate, char *fname, bool isnull);\n\nstatic void\njsonb_in_object_field_start(void *pstate, char *fname, bool isnull)\n{\n\tJsonbInState *_state = (JsonbInState *) pstate;\n\tJsonbValue\tv;\n\n\tAssert(fname != NULL);\n\tv.type = jbvString;\n\tv.val.string.len = checkStringLen(strlen(fname));\n\tv.val.string.val = fname;\n\n\t_state->res = pushJsonbValue(&_state->parseState, WJB_KEY, &v);\n}"
  },
  {
    "function_name": "jsonb_in_array_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
    "lines": "289-295",
    "snippet": "static void\njsonb_in_array_end(void *pstate)\n{\n\tJsonbInState *_state = (JsonbInState *) pstate;\n\n\t_state->res = pushJsonbValue(&_state->parseState, WJB_END_ARRAY, NULL);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"miscadmin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void jsonb_in_object_start(void *pstate);",
      "static void jsonb_in_object_end(void *pstate);",
      "static void jsonb_in_array_start(void *pstate);",
      "static void jsonb_in_array_end(void *pstate);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pushJsonbValue",
          "args": [
            "&_state->parseState",
            "WJB_END_ARRAY",
            "NULL"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "pushJsonbValueScalar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "545-629",
          "snippet": "static JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);",
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbParseState *pushState(JsonbParseState **pstate);",
            "static void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void uniqueifyJsonbObject(JsonbValue *object);",
            "static JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\nstatic void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\nstatic JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);\n\nstatic JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic void jsonb_in_object_start(void *pstate);\nstatic void jsonb_in_object_end(void *pstate);\nstatic void jsonb_in_array_start(void *pstate);\nstatic void jsonb_in_array_end(void *pstate);\n\nstatic void\njsonb_in_array_end(void *pstate)\n{\n\tJsonbInState *_state = (JsonbInState *) pstate;\n\n\t_state->res = pushJsonbValue(&_state->parseState, WJB_END_ARRAY, NULL);\n}"
  },
  {
    "function_name": "jsonb_in_array_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
    "lines": "281-287",
    "snippet": "static void\njsonb_in_array_start(void *pstate)\n{\n\tJsonbInState *_state = (JsonbInState *) pstate;\n\n\t_state->res = pushJsonbValue(&_state->parseState, WJB_BEGIN_ARRAY, NULL);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"miscadmin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void jsonb_in_object_start(void *pstate);",
      "static void jsonb_in_object_end(void *pstate);",
      "static void jsonb_in_array_start(void *pstate);",
      "static void jsonb_in_array_end(void *pstate);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pushJsonbValue",
          "args": [
            "&_state->parseState",
            "WJB_BEGIN_ARRAY",
            "NULL"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "pushJsonbValueScalar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "545-629",
          "snippet": "static JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);",
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbParseState *pushState(JsonbParseState **pstate);",
            "static void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void uniqueifyJsonbObject(JsonbValue *object);",
            "static JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\nstatic void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\nstatic JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);\n\nstatic JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic void jsonb_in_object_start(void *pstate);\nstatic void jsonb_in_object_end(void *pstate);\nstatic void jsonb_in_array_start(void *pstate);\nstatic void jsonb_in_array_end(void *pstate);\n\nstatic void\njsonb_in_array_start(void *pstate)\n{\n\tJsonbInState *_state = (JsonbInState *) pstate;\n\n\t_state->res = pushJsonbValue(&_state->parseState, WJB_BEGIN_ARRAY, NULL);\n}"
  },
  {
    "function_name": "jsonb_in_object_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
    "lines": "273-279",
    "snippet": "static void\njsonb_in_object_end(void *pstate)\n{\n\tJsonbInState *_state = (JsonbInState *) pstate;\n\n\t_state->res = pushJsonbValue(&_state->parseState, WJB_END_OBJECT, NULL);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"miscadmin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void jsonb_in_object_start(void *pstate);",
      "static void jsonb_in_object_end(void *pstate);",
      "static void jsonb_in_array_start(void *pstate);",
      "static void jsonb_in_array_end(void *pstate);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pushJsonbValue",
          "args": [
            "&_state->parseState",
            "WJB_END_OBJECT",
            "NULL"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "pushJsonbValueScalar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "545-629",
          "snippet": "static JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);",
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbParseState *pushState(JsonbParseState **pstate);",
            "static void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void uniqueifyJsonbObject(JsonbValue *object);",
            "static JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\nstatic void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\nstatic JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);\n\nstatic JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic void jsonb_in_object_start(void *pstate);\nstatic void jsonb_in_object_end(void *pstate);\nstatic void jsonb_in_array_start(void *pstate);\nstatic void jsonb_in_array_end(void *pstate);\n\nstatic void\njsonb_in_object_end(void *pstate)\n{\n\tJsonbInState *_state = (JsonbInState *) pstate;\n\n\t_state->res = pushJsonbValue(&_state->parseState, WJB_END_OBJECT, NULL);\n}"
  },
  {
    "function_name": "jsonb_in_object_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
    "lines": "265-271",
    "snippet": "static void\njsonb_in_object_start(void *pstate)\n{\n\tJsonbInState *_state = (JsonbInState *) pstate;\n\n\t_state->res = pushJsonbValue(&_state->parseState, WJB_BEGIN_OBJECT, NULL);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"miscadmin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void jsonb_in_object_start(void *pstate);",
      "static void jsonb_in_object_end(void *pstate);",
      "static void jsonb_in_array_start(void *pstate);",
      "static void jsonb_in_array_end(void *pstate);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pushJsonbValue",
          "args": [
            "&_state->parseState",
            "WJB_BEGIN_OBJECT",
            "NULL"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "pushJsonbValueScalar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "545-629",
          "snippet": "static JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);",
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbParseState *pushState(JsonbParseState **pstate);",
            "static void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void uniqueifyJsonbObject(JsonbValue *object);",
            "static JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\nstatic void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\nstatic JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);\n\nstatic JsonbValue *\npushJsonbValueScalar(JsonbParseState **pstate, JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal)\n{\n\tJsonbValue *result = NULL;\n\n\tswitch (seq)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tAssert(!scalarVal || scalarVal->val.array.rawScalar);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvArray;\n\t\t\t(*pstate)->contVal.val.array.nElems = 0;\n\t\t\t(*pstate)->contVal.val.array.rawScalar = (scalarVal &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t  scalarVal->val.array.rawScalar);\n\t\t\tif (scalarVal && scalarVal->val.array.nElems > 0)\n\t\t\t{\n\t\t\t\t/* Assume that this array is still really a scalar */\n\t\t\t\tAssert(scalarVal->type == jbvArray);\n\t\t\t\t(*pstate)->size = scalarVal->val.array.nElems;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*pstate)->size = 4;\n\t\t\t}\n\t\t\t(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\tAssert(!scalarVal);\n\t\t\t*pstate = pushState(pstate);\n\t\t\tresult = &(*pstate)->contVal;\n\t\t\t(*pstate)->contVal.type = jbvObject;\n\t\t\t(*pstate)->contVal.val.object.nPairs = 0;\n\t\t\t(*pstate)->size = 4;\n\t\t\t(*pstate)->contVal.val.object.pairs = palloc(sizeof(JsonbPair) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*pstate)->size);\n\t\t\tbreak;\n\t\tcase WJB_KEY:\n\t\t\tAssert(scalarVal->type == jbvString);\n\t\t\tappendKey(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_VALUE:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendValue(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\t\tAssert(IsAJsonbScalar(scalarVal));\n\t\t\tappendElement(*pstate, scalarVal);\n\t\t\tbreak;\n\t\tcase WJB_END_OBJECT:\n\t\t\tuniqueifyJsonbObject(&(*pstate)->contVal);\n\t\t\t/* fall through! */\n\t\tcase WJB_END_ARRAY:\n\t\t\t/* Steps here common to WJB_END_OBJECT case */\n\t\t\tAssert(!scalarVal);\n\t\t\tresult = &(*pstate)->contVal;\n\n\t\t\t/*\n\t\t\t * Pop stack and push current array/object as value in parent\n\t\t\t * array/object\n\t\t\t */\n\t\t\t*pstate = (*pstate)->next;\n\t\t\tif (*pstate)\n\t\t\t{\n\t\t\t\tswitch ((*pstate)->contVal.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvArray:\n\t\t\t\t\t\tappendElement(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tappendValue(*pstate, result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telog(ERROR, \"invalid jsonb container type\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb sequential processing token\");\n\t}\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic void jsonb_in_object_start(void *pstate);\nstatic void jsonb_in_object_end(void *pstate);\nstatic void jsonb_in_array_start(void *pstate);\nstatic void jsonb_in_array_end(void *pstate);\n\nstatic void\njsonb_in_object_start(void *pstate)\n{\n\tJsonbInState *_state = (JsonbInState *) pstate;\n\n\t_state->res = pushJsonbValue(&_state->parseState, WJB_BEGIN_OBJECT, NULL);\n}"
  },
  {
    "function_name": "checkStringLen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
    "lines": "252-263",
    "snippet": "static size_t\ncheckStringLen(size_t len)\n{\n\tif (len > JENTRY_OFFLENMASK)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"string too long to represent as jsonb string\"),\n\t\t\t\t errdetail(\"Due to an implementation restriction, jsonb strings cannot exceed %d bytes.\",\n\t\t\t\t\t\t   JENTRY_OFFLENMASK)));\n\n\treturn len;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"miscadmin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static inline Datum jsonb_from_cstring(char *json, int len);",
      "static size_t checkStringLen(size_t len);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"string too long to represent as jsonb string\"),\n\t\t\t\t errdetail(\"Due to an implementation restriction, jsonb strings cannot exceed %d bytes.\",\n\t\t\t\t\t\t   JENTRY_OFFLENMASK))"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errdetail",
          "args": [
            "\"Due to an implementation restriction, jsonb strings cannot exceed %d bytes.\"",
            "JENTRY_OFFLENMASK"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "errdetail_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "918-933",
          "snippet": "int\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"string too long to represent as jsonb string\""
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_PROGRAM_LIMIT_EXCEEDED"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic inline Datum jsonb_from_cstring(char *json, int len);\nstatic size_t checkStringLen(size_t len);\n\nstatic size_t\ncheckStringLen(size_t len)\n{\n\tif (len > JENTRY_OFFLENMASK)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"string too long to represent as jsonb string\"),\n\t\t\t\t errdetail(\"Due to an implementation restriction, jsonb strings cannot exceed %d bytes.\",\n\t\t\t\t\t\t   JENTRY_OFFLENMASK)));\n\n\treturn len;\n}"
  },
  {
    "function_name": "jsonb_from_cstring",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
    "lines": "226-250",
    "snippet": "static inline Datum\njsonb_from_cstring(char *json, int len)\n{\n\tJsonLexContext *lex;\n\tJsonbInState state;\n\tJsonSemAction sem;\n\n\tmemset(&state, 0, sizeof(state));\n\tmemset(&sem, 0, sizeof(sem));\n\tlex = makeJsonLexContextCstringLen(json, len, true);\n\n\tsem.semstate = (void *) &state;\n\n\tsem.object_start = jsonb_in_object_start;\n\tsem.array_start = jsonb_in_array_start;\n\tsem.object_end = jsonb_in_object_end;\n\tsem.array_end = jsonb_in_array_end;\n\tsem.scalar = jsonb_in_scalar;\n\tsem.object_field_start = jsonb_in_object_field_start;\n\n\tpg_parse_json(lex, &sem);\n\n\t/* after parsing, the item member has the composed jsonb structure */\n\tPG_RETURN_POINTER(JsonbValueToJsonb(state.res));\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"miscadmin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static inline Datum jsonb_from_cstring(char *json, int len);",
      "static size_t checkStringLen(size_t len);",
      "static JsonbParseState *clone_parse_state(JsonbParseState *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "JsonbValueToJsonb(state.res)"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JsonbValueToJsonb",
          "args": [
            "state.res"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbValueToJsonb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "78-113",
          "snippet": "Jsonb *\nJsonbValueToJsonb(JsonbValue *val)\n{\n\tJsonb\t   *out;\n\n\tif (IsAJsonbScalar(val))\n\t{\n\t\t/* Scalar value */\n\t\tJsonbParseState *pstate = NULL;\n\t\tJsonbValue *res;\n\t\tJsonbValue\tscalarArray;\n\n\t\tscalarArray.type = jbvArray;\n\t\tscalarArray.val.array.rawScalar = true;\n\t\tscalarArray.val.array.nElems = 1;\n\n\t\tpushJsonbValue(&pstate, WJB_BEGIN_ARRAY, &scalarArray);\n\t\tpushJsonbValue(&pstate, WJB_ELEM, val);\n\t\tres = pushJsonbValue(&pstate, WJB_END_ARRAY, NULL);\n\n\t\tout = convertToJsonb(res);\n\t}\n\telse if (val->type == jbvObject || val->type == jbvArray)\n\t{\n\t\tout = convertToJsonb(val);\n\t}\n\telse\n\t{\n\t\tAssert(val->type == jbvBinary);\n\t\tout = palloc(VARHDRSZ + val->val.binary.len);\n\t\tSET_VARSIZE(out, VARHDRSZ + val->val.binary.len);\n\t\tmemcpy(VARDATA(out), val->val.binary.data, val->val.binary.len);\n\t}\n\n\treturn out;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static int\treserveFromBuffer(StringInfo buffer, int len);",
            "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
            "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
            "static JsonbParseState *pushState(JsonbParseState **pstate);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic JsonbParseState *pushState(JsonbParseState **pstate);\n\nJsonb *\nJsonbValueToJsonb(JsonbValue *val)\n{\n\tJsonb\t   *out;\n\n\tif (IsAJsonbScalar(val))\n\t{\n\t\t/* Scalar value */\n\t\tJsonbParseState *pstate = NULL;\n\t\tJsonbValue *res;\n\t\tJsonbValue\tscalarArray;\n\n\t\tscalarArray.type = jbvArray;\n\t\tscalarArray.val.array.rawScalar = true;\n\t\tscalarArray.val.array.nElems = 1;\n\n\t\tpushJsonbValue(&pstate, WJB_BEGIN_ARRAY, &scalarArray);\n\t\tpushJsonbValue(&pstate, WJB_ELEM, val);\n\t\tres = pushJsonbValue(&pstate, WJB_END_ARRAY, NULL);\n\n\t\tout = convertToJsonb(res);\n\t}\n\telse if (val->type == jbvObject || val->type == jbvArray)\n\t{\n\t\tout = convertToJsonb(val);\n\t}\n\telse\n\t{\n\t\tAssert(val->type == jbvBinary);\n\t\tout = palloc(VARHDRSZ + val->val.binary.len);\n\t\tSET_VARSIZE(out, VARHDRSZ + val->val.binary.len);\n\t\tmemcpy(VARDATA(out), val->val.binary.data, val->val.binary.len);\n\t}\n\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_parse_json",
          "args": [
            "lex",
            "&sem"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "pg_parse_json",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "331-356",
          "snippet": "void\npg_parse_json(JsonLexContext *lex, JsonSemAction *sem)\n{\n\tJsonTokenType tok;\n\n\t/* get the initial token */\n\tjson_lex(lex);\n\n\ttok = lex_peek(lex);\n\n\t/* parse by recursive descent */\n\tswitch (tok)\n\t{\n\t\tcase JSON_TOKEN_OBJECT_START:\n\t\t\tparse_object(lex, sem);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_ARRAY_START:\n\t\t\tparse_array(lex, sem);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_scalar(lex, sem); /* json can be a bare scalar */\n\t}\n\n\tlex_expect(JSON_PARSE_END, lex, JSON_TOKEN_END);\n\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_object(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);",
            "static void parse_array(JsonLexContext *lex, JsonSemAction *sem);",
            "static int\treport_json_context(JsonLexContext *lex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic inline void parse_scalar(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object_field(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_object(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);\nstatic void parse_array(JsonLexContext *lex, JsonSemAction *sem);\nstatic int\treport_json_context(JsonLexContext *lex);\n\nvoid\npg_parse_json(JsonLexContext *lex, JsonSemAction *sem)\n{\n\tJsonTokenType tok;\n\n\t/* get the initial token */\n\tjson_lex(lex);\n\n\ttok = lex_peek(lex);\n\n\t/* parse by recursive descent */\n\tswitch (tok)\n\t{\n\t\tcase JSON_TOKEN_OBJECT_START:\n\t\t\tparse_object(lex, sem);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_ARRAY_START:\n\t\t\tparse_array(lex, sem);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_scalar(lex, sem); /* json can be a bare scalar */\n\t}\n\n\tlex_expect(JSON_PARSE_END, lex, JSON_TOKEN_END);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "makeJsonLexContextCstringLen",
          "args": [
            "json",
            "len",
            "true"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "makeJsonLexContextCstringLen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/json.c",
          "lines": "308-319",
          "snippet": "JsonLexContext *\nmakeJsonLexContextCstringLen(char *json, int len, bool need_escapes)\n{\n\tJsonLexContext *lex = palloc0(sizeof(JsonLexContext));\n\n\tlex->input = lex->token_terminator = lex->line_start = json;\n\tlex->line_number = 1;\n\tlex->input_length = len;\n\tif (need_escapes)\n\t\tlex->strval = makeStringInfo();\n\treturn lex;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void json_lex(JsonLexContext *lex);",
            "static inline void json_lex_string(JsonLexContext *lex);",
            "static int\treport_json_context(JsonLexContext *lex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/typcache.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void json_lex(JsonLexContext *lex);\nstatic inline void json_lex_string(JsonLexContext *lex);\nstatic int\treport_json_context(JsonLexContext *lex);\n\nJsonLexContext *\nmakeJsonLexContextCstringLen(char *json, int len, bool need_escapes)\n{\n\tJsonLexContext *lex = palloc0(sizeof(JsonLexContext));\n\n\tlex->input = lex->token_terminator = lex->line_start = json;\n\tlex->line_number = 1;\n\tlex->input_length = len;\n\tif (need_escapes)\n\t\tlex->strval = makeStringInfo();\n\treturn lex;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&sem",
            "0",
            "sizeof(sem)"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&state",
            "0",
            "sizeof(state)"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic inline Datum jsonb_from_cstring(char *json, int len);\nstatic size_t checkStringLen(size_t len);\nstatic JsonbParseState *clone_parse_state(JsonbParseState *state);\n\nstatic inline Datum\njsonb_from_cstring(char *json, int len)\n{\n\tJsonLexContext *lex;\n\tJsonbInState state;\n\tJsonSemAction sem;\n\n\tmemset(&state, 0, sizeof(state));\n\tmemset(&sem, 0, sizeof(sem));\n\tlex = makeJsonLexContextCstringLen(json, len, true);\n\n\tsem.semstate = (void *) &state;\n\n\tsem.object_start = jsonb_in_object_start;\n\tsem.array_start = jsonb_in_array_start;\n\tsem.object_end = jsonb_in_object_end;\n\tsem.array_end = jsonb_in_array_end;\n\tsem.scalar = jsonb_in_scalar;\n\tsem.object_field_start = jsonb_in_object_field_start;\n\n\tpg_parse_json(lex, &sem);\n\n\t/* after parsing, the item member has the composed jsonb structure */\n\tPG_RETURN_POINTER(JsonbValueToJsonb(state.res));\n}"
  },
  {
    "function_name": "jsonb_typeof",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
    "lines": "172-217",
    "snippet": "Datum\njsonb_typeof(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *in = PG_GETARG_JSONB_P(0);\n\tJsonbIterator *it;\n\tJsonbValue\tv;\n\tchar\t   *result;\n\n\tif (JB_ROOT_IS_OBJECT(in))\n\t\tresult = \"object\";\n\telse if (JB_ROOT_IS_ARRAY(in) && !JB_ROOT_IS_SCALAR(in))\n\t\tresult = \"array\";\n\telse\n\t{\n\t\tAssert(JB_ROOT_IS_SCALAR(in));\n\n\t\tit = JsonbIteratorInit(&in->root);\n\n\t\t/*\n\t\t * A root scalar is stored as an array of one element, so we get the\n\t\t * array and then its first (and only) member.\n\t\t */\n\t\t(void) JsonbIteratorNext(&it, &v, true);\n\t\tAssert(v.type == jbvArray);\n\t\t(void) JsonbIteratorNext(&it, &v, true);\n\t\tswitch (v.type)\n\t\t{\n\t\t\tcase jbvNull:\n\t\t\t\tresult = \"null\";\n\t\t\t\tbreak;\n\t\t\tcase jbvString:\n\t\t\t\tresult = \"string\";\n\t\t\t\tbreak;\n\t\t\tcase jbvNumeric:\n\t\t\t\tresult = \"number\";\n\t\t\t\tbreak;\n\t\t\tcase jbvBool:\n\t\t\t\tresult = \"boolean\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unknown jsonb scalar type\");\n\t\t}\n\t}\n\n\tPG_RETURN_TEXT_P(cstring_to_text(result));\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"miscadmin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void composite_to_jsonb(Datum composite, JsonbInState *result);",
      "static void array_to_jsonb_internal(Datum array, JsonbInState *result);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "cstring_to_text(result)"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cstring_to_text",
          "args": [
            "result"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "148-152",
          "snippet": "text *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unknown jsonb scalar type\""
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonbIteratorNext",
          "args": [
            "&it",
            "&v",
            "true"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbIteratorNext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "753-894",
          "snippet": "JsonbIteratorToken\nJsonbIteratorNext(JsonbIterator **it, JsonbValue *val, bool skipNested)\n{\n\tif (*it == NULL)\n\t\treturn WJB_DONE;\n\n\t/*\n\t * When stepping into a nested container, we jump back here to start\n\t * processing the child. We will not recurse further in one call, because\n\t * processing the child will always begin in JBI_ARRAY_START or\n\t * JBI_OBJECT_START state.\n\t */\nrecurse:\n\tswitch ((*it)->state)\n\t{\n\t\tcase JBI_ARRAY_START:\n\t\t\t/* Set v to array on first array call */\n\t\t\tval->type = jbvArray;\n\t\t\tval->val.array.nElems = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.array.elems is not actually set, because we aren't doing\n\t\t\t * a full conversion\n\t\t\t */\n\t\t\tval->val.array.rawScalar = (*it)->isScalar;\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = 0;\t/* not actually used */\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_ARRAY_ELEM;\n\t\t\treturn WJB_BEGIN_ARRAY;\n\n\t\tcase JBI_ARRAY_ELEM:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All elements within array already processed.  Report this\n\t\t\t\t * to caller, and give it back original parent iterator (which\n\t\t\t\t * independently tracks iteration progress at its level of\n\t\t\t\t * nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_ARRAY;\n\t\t\t}\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t/* Recurse into container. */\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scalar item in array, or a container and caller didn't want\n\t\t\t\t * us to recurse into it.\n\t\t\t\t */\n\t\t\t\treturn WJB_ELEM;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_START:\n\t\t\t/* Set v to object on first object call */\n\t\t\tval->type = jbvObject;\n\t\t\tval->val.object.nPairs = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.object.pairs is not actually set, because we aren't\n\t\t\t * doing a full conversion\n\t\t\t */\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = getJsonbOffset((*it)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t   (*it)->nElems);\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\t\t\treturn WJB_BEGIN_OBJECT;\n\n\t\tcase JBI_OBJECT_KEY:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All pairs within object already processed.  Report this to\n\t\t\t\t * caller, and give it back original containing iterator\n\t\t\t\t * (which independently tracks iteration progress at its level\n\t\t\t\t * of nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_OBJECT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Return key of a key/value pair.  */\n\t\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t\t   val);\n\t\t\t\tif (val->type != jbvString)\n\t\t\t\t\telog(ERROR, \"unexpected jsonb type as object key\");\n\n\t\t\t\t/* Set state for next call */\n\t\t\t\t(*it)->state = JBI_OBJECT_VALUE;\n\t\t\t\treturn WJB_KEY;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_VALUE:\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex + (*it)->nElems,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curValueOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curValueOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex + (*it)->nElems]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\t/*\n\t\t\t * Value may be a container, in which case we recurse with new,\n\t\t\t * child iterator (unless the caller asked not to, by passing\n\t\t\t * skipNested).\n\t\t\t */\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn WJB_VALUE;\n\t}\n\n\telog(ERROR, \"invalid iterator state\");\n\treturn -1;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbIterator *freeAndGetParent(JsonbIterator *it);",
            "static void uniqueifyJsonbObject(JsonbValue *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbIterator *freeAndGetParent(JsonbIterator *it);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\n\nJsonbIteratorToken\nJsonbIteratorNext(JsonbIterator **it, JsonbValue *val, bool skipNested)\n{\n\tif (*it == NULL)\n\t\treturn WJB_DONE;\n\n\t/*\n\t * When stepping into a nested container, we jump back here to start\n\t * processing the child. We will not recurse further in one call, because\n\t * processing the child will always begin in JBI_ARRAY_START or\n\t * JBI_OBJECT_START state.\n\t */\nrecurse:\n\tswitch ((*it)->state)\n\t{\n\t\tcase JBI_ARRAY_START:\n\t\t\t/* Set v to array on first array call */\n\t\t\tval->type = jbvArray;\n\t\t\tval->val.array.nElems = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.array.elems is not actually set, because we aren't doing\n\t\t\t * a full conversion\n\t\t\t */\n\t\t\tval->val.array.rawScalar = (*it)->isScalar;\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = 0;\t/* not actually used */\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_ARRAY_ELEM;\n\t\t\treturn WJB_BEGIN_ARRAY;\n\n\t\tcase JBI_ARRAY_ELEM:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All elements within array already processed.  Report this\n\t\t\t\t * to caller, and give it back original parent iterator (which\n\t\t\t\t * independently tracks iteration progress at its level of\n\t\t\t\t * nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_ARRAY;\n\t\t\t}\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t/* Recurse into container. */\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scalar item in array, or a container and caller didn't want\n\t\t\t\t * us to recurse into it.\n\t\t\t\t */\n\t\t\t\treturn WJB_ELEM;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_START:\n\t\t\t/* Set v to object on first object call */\n\t\t\tval->type = jbvObject;\n\t\t\tval->val.object.nPairs = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.object.pairs is not actually set, because we aren't\n\t\t\t * doing a full conversion\n\t\t\t */\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = getJsonbOffset((*it)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t   (*it)->nElems);\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\t\t\treturn WJB_BEGIN_OBJECT;\n\n\t\tcase JBI_OBJECT_KEY:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All pairs within object already processed.  Report this to\n\t\t\t\t * caller, and give it back original containing iterator\n\t\t\t\t * (which independently tracks iteration progress at its level\n\t\t\t\t * of nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_OBJECT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Return key of a key/value pair.  */\n\t\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t\t   val);\n\t\t\t\tif (val->type != jbvString)\n\t\t\t\t\telog(ERROR, \"unexpected jsonb type as object key\");\n\n\t\t\t\t/* Set state for next call */\n\t\t\t\t(*it)->state = JBI_OBJECT_VALUE;\n\t\t\t\treturn WJB_KEY;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_VALUE:\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex + (*it)->nElems,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curValueOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curValueOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex + (*it)->nElems]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\t/*\n\t\t\t * Value may be a container, in which case we recurse with new,\n\t\t\t * child iterator (unless the caller asked not to, by passing\n\t\t\t * skipNested).\n\t\t\t */\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn WJB_VALUE;\n\t}\n\n\telog(ERROR, \"invalid iterator state\");\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "v.type == jbvArray"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JsonbIteratorInit",
          "args": [
            "&in->root"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbIteratorInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "717-721",
          "snippet": "JsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nJsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "JB_ROOT_IS_SCALAR(in)"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JB_ROOT_IS_SCALAR",
          "args": [
            "in"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JB_ROOT_IS_SCALAR",
          "args": [
            "in"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JB_ROOT_IS_ARRAY",
          "args": [
            "in"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JB_ROOT_IS_OBJECT",
          "args": [
            "in"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_JSONB_P",
          "args": [
            "0"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic void composite_to_jsonb(Datum composite, JsonbInState *result);\nstatic void array_to_jsonb_internal(Datum array, JsonbInState *result);\n\nDatum\njsonb_typeof(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *in = PG_GETARG_JSONB_P(0);\n\tJsonbIterator *it;\n\tJsonbValue\tv;\n\tchar\t   *result;\n\n\tif (JB_ROOT_IS_OBJECT(in))\n\t\tresult = \"object\";\n\telse if (JB_ROOT_IS_ARRAY(in) && !JB_ROOT_IS_SCALAR(in))\n\t\tresult = \"array\";\n\telse\n\t{\n\t\tAssert(JB_ROOT_IS_SCALAR(in));\n\n\t\tit = JsonbIteratorInit(&in->root);\n\n\t\t/*\n\t\t * A root scalar is stored as an array of one element, so we get the\n\t\t * array and then its first (and only) member.\n\t\t */\n\t\t(void) JsonbIteratorNext(&it, &v, true);\n\t\tAssert(v.type == jbvArray);\n\t\t(void) JsonbIteratorNext(&it, &v, true);\n\t\tswitch (v.type)\n\t\t{\n\t\t\tcase jbvNull:\n\t\t\t\tresult = \"null\";\n\t\t\t\tbreak;\n\t\t\tcase jbvString:\n\t\t\t\tresult = \"string\";\n\t\t\t\tbreak;\n\t\t\tcase jbvNumeric:\n\t\t\t\tresult = \"number\";\n\t\t\t\tbreak;\n\t\t\tcase jbvBool:\n\t\t\t\tresult = \"boolean\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unknown jsonb scalar type\");\n\t\t}\n\t}\n\n\tPG_RETURN_TEXT_P(cstring_to_text(result));\n}"
  },
  {
    "function_name": "jsonb_send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
    "lines": "147-164",
    "snippet": "Datum\njsonb_send(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *jb = PG_GETARG_JSONB_P(0);\n\tStringInfoData buf;\n\tStringInfo\tjtext = makeStringInfo();\n\tint\t\t\tversion = 1;\n\n\t(void) JsonbToCString(jtext, &jb->root, VARSIZE(jb));\n\n\tpq_begintypsend(&buf);\n\tpq_sendint8(&buf, version);\n\tpq_sendtext(&buf, jtext->data, jtext->len);\n\tpfree(jtext->data);\n\tpfree(jtext);\n\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"miscadmin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static inline Datum jsonb_from_cstring(char *json, int len);",
      "static size_t checkStringLen(size_t len);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BYTEA_P",
          "args": [
            "pq_endtypsend(&buf)"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_endtypsend",
          "args": [
            "&buf"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "jtext"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pq_sendtext",
          "args": [
            "&buf",
            "jtext->data",
            "jtext->len"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendint8",
          "args": [
            "&buf",
            "version"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_begintypsend",
          "args": [
            "&buf"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JsonbToCString",
          "args": [
            "jtext",
            "&jb->root",
            "VARSIZE(jb)"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbToCStringIndent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
          "lines": "439-443",
          "snippet": "char *\nJsonbToCStringIndent(StringInfo out, JsonbContainer *in, int estimated_len)\n{\n\treturn JsonbToCStringWorker(out, in, estimated_len, true);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"miscadmin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nchar *\nJsonbToCStringIndent(StringInfo out, JsonbContainer *in, int estimated_len)\n{\n\treturn JsonbToCStringWorker(out, in, estimated_len, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "jb"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeStringInfo",
          "args": [],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_JSONB_P",
          "args": [
            "0"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic inline Datum jsonb_from_cstring(char *json, int len);\nstatic size_t checkStringLen(size_t len);\n\nDatum\njsonb_send(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *jb = PG_GETARG_JSONB_P(0);\n\tStringInfoData buf;\n\tStringInfo\tjtext = makeStringInfo();\n\tint\t\t\tversion = 1;\n\n\t(void) JsonbToCString(jtext, &jb->root, VARSIZE(jb));\n\n\tpq_begintypsend(&buf);\n\tpq_sendint8(&buf, version);\n\tpq_sendtext(&buf, jtext->data, jtext->len);\n\tpfree(jtext->data);\n\tpfree(jtext);\n\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}"
  },
  {
    "function_name": "jsonb_out",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
    "lines": "131-140",
    "snippet": "Datum\njsonb_out(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *jb = PG_GETARG_JSONB_P(0);\n\tchar\t   *out;\n\n\tout = JsonbToCString(NULL, &jb->root, VARSIZE(jb));\n\n\tPG_RETURN_CSTRING(out);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"miscadmin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "out"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JsonbToCString",
          "args": [
            "NULL",
            "&jb->root",
            "VARSIZE(jb)"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbToCStringIndent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
          "lines": "439-443",
          "snippet": "char *\nJsonbToCStringIndent(StringInfo out, JsonbContainer *in, int estimated_len)\n{\n\treturn JsonbToCStringWorker(out, in, estimated_len, true);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"miscadmin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nchar *\nJsonbToCStringIndent(StringInfo out, JsonbContainer *in, int estimated_len)\n{\n\treturn JsonbToCStringWorker(out, in, estimated_len, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "jb"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_JSONB_P",
          "args": [
            "0"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nDatum\njsonb_out(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *jb = PG_GETARG_JSONB_P(0);\n\tchar\t   *out;\n\n\tout = JsonbToCString(NULL, &jb->root, VARSIZE(jb));\n\n\tPG_RETURN_CSTRING(out);\n}"
  },
  {
    "function_name": "jsonb_recv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
    "lines": "112-126",
    "snippet": "Datum\njsonb_recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\tint\t\t\tversion = pq_getmsgint(buf, 1);\n\tchar\t   *str;\n\tint\t\t\tnbytes;\n\n\tif (version == 1)\n\t\tstr = pq_getmsgtext(buf, buf->len - buf->cursor, &nbytes);\n\telse\n\t\telog(ERROR, \"unsupported jsonb version number %d\", version);\n\n\treturn jsonb_from_cstring(str, nbytes);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"miscadmin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static inline Datum jsonb_from_cstring(char *json, int len);",
      "static size_t checkStringLen(size_t len);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "jsonb_from_cstring",
          "args": [
            "str",
            "nbytes"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "jsonb_from_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
          "lines": "226-250",
          "snippet": "static inline Datum\njsonb_from_cstring(char *json, int len)\n{\n\tJsonLexContext *lex;\n\tJsonbInState state;\n\tJsonSemAction sem;\n\n\tmemset(&state, 0, sizeof(state));\n\tmemset(&sem, 0, sizeof(sem));\n\tlex = makeJsonLexContextCstringLen(json, len, true);\n\n\tsem.semstate = (void *) &state;\n\n\tsem.object_start = jsonb_in_object_start;\n\tsem.array_start = jsonb_in_array_start;\n\tsem.object_end = jsonb_in_object_end;\n\tsem.array_end = jsonb_in_array_end;\n\tsem.scalar = jsonb_in_scalar;\n\tsem.object_field_start = jsonb_in_object_field_start;\n\n\tpg_parse_json(lex, &sem);\n\n\t/* after parsing, the item member has the composed jsonb structure */\n\tPG_RETURN_POINTER(JsonbValueToJsonb(state.res));\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"miscadmin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline Datum jsonb_from_cstring(char *json, int len);",
            "static size_t checkStringLen(size_t len);",
            "static JsonbParseState *clone_parse_state(JsonbParseState *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic inline Datum jsonb_from_cstring(char *json, int len);\nstatic size_t checkStringLen(size_t len);\nstatic JsonbParseState *clone_parse_state(JsonbParseState *state);\n\nstatic inline Datum\njsonb_from_cstring(char *json, int len)\n{\n\tJsonLexContext *lex;\n\tJsonbInState state;\n\tJsonSemAction sem;\n\n\tmemset(&state, 0, sizeof(state));\n\tmemset(&sem, 0, sizeof(sem));\n\tlex = makeJsonLexContextCstringLen(json, len, true);\n\n\tsem.semstate = (void *) &state;\n\n\tsem.object_start = jsonb_in_object_start;\n\tsem.array_start = jsonb_in_array_start;\n\tsem.object_end = jsonb_in_object_end;\n\tsem.array_end = jsonb_in_array_end;\n\tsem.scalar = jsonb_in_scalar;\n\tsem.object_field_start = jsonb_in_object_field_start;\n\n\tpg_parse_json(lex, &sem);\n\n\t/* after parsing, the item member has the composed jsonb structure */\n\tPG_RETURN_POINTER(JsonbValueToJsonb(state.res));\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unsupported jsonb version number %d\"",
            "version"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pq_getmsgtext",
          "args": [
            "buf",
            "buf->len - buf->cursor",
            "&nbytes"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgint",
          "args": [
            "buf",
            "1"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic inline Datum jsonb_from_cstring(char *json, int len);\nstatic size_t checkStringLen(size_t len);\n\nDatum\njsonb_recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\tint\t\t\tversion = pq_getmsgint(buf, 1);\n\tchar\t   *str;\n\tint\t\t\tnbytes;\n\n\tif (version == 1)\n\t\tstr = pq_getmsgtext(buf, buf->len - buf->cursor, &nbytes);\n\telse\n\t\telog(ERROR, \"unsupported jsonb version number %d\", version);\n\n\treturn jsonb_from_cstring(str, nbytes);\n}"
  },
  {
    "function_name": "jsonb_in",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
    "lines": "96-102",
    "snippet": "Datum\njsonb_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *json = PG_GETARG_CSTRING(0);\n\n\treturn jsonb_from_cstring(json, strlen(json));\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/jsonapi.h\"",
      "#include \"utils/json.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"miscadmin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jsonb_from_cstring",
          "args": [
            "json",
            "strlen(json)"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "jsonb_from_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb.c",
          "lines": "226-250",
          "snippet": "static inline Datum\njsonb_from_cstring(char *json, int len)\n{\n\tJsonLexContext *lex;\n\tJsonbInState state;\n\tJsonSemAction sem;\n\n\tmemset(&state, 0, sizeof(state));\n\tmemset(&sem, 0, sizeof(sem));\n\tlex = makeJsonLexContextCstringLen(json, len, true);\n\n\tsem.semstate = (void *) &state;\n\n\tsem.object_start = jsonb_in_object_start;\n\tsem.array_start = jsonb_in_array_start;\n\tsem.object_end = jsonb_in_object_end;\n\tsem.array_end = jsonb_in_array_end;\n\tsem.scalar = jsonb_in_scalar;\n\tsem.object_field_start = jsonb_in_object_field_start;\n\n\tpg_parse_json(lex, &sem);\n\n\t/* after parsing, the item member has the composed jsonb structure */\n\tPG_RETURN_POINTER(JsonbValueToJsonb(state.res));\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/jsonapi.h\"",
            "#include \"utils/json.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"miscadmin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline Datum jsonb_from_cstring(char *json, int len);",
            "static size_t checkStringLen(size_t len);",
            "static JsonbParseState *clone_parse_state(JsonbParseState *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nstatic inline Datum jsonb_from_cstring(char *json, int len);\nstatic size_t checkStringLen(size_t len);\nstatic JsonbParseState *clone_parse_state(JsonbParseState *state);\n\nstatic inline Datum\njsonb_from_cstring(char *json, int len)\n{\n\tJsonLexContext *lex;\n\tJsonbInState state;\n\tJsonSemAction sem;\n\n\tmemset(&state, 0, sizeof(state));\n\tmemset(&sem, 0, sizeof(sem));\n\tlex = makeJsonLexContextCstringLen(json, len, true);\n\n\tsem.semstate = (void *) &state;\n\n\tsem.object_start = jsonb_in_object_start;\n\tsem.array_start = jsonb_in_array_start;\n\tsem.object_end = jsonb_in_object_end;\n\tsem.array_end = jsonb_in_array_end;\n\tsem.scalar = jsonb_in_scalar;\n\tsem.object_field_start = jsonb_in_object_field_start;\n\n\tpg_parse_json(lex, &sem);\n\n\t/* after parsing, the item member has the composed jsonb structure */\n\tPG_RETURN_POINTER(JsonbValueToJsonb(state.res));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "json"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CSTRING",
          "args": [
            "0"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/jsonapi.h\"\n#include \"utils/json.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"parser/parse_coerce.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/transam.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nDatum\njsonb_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *json = PG_GETARG_CSTRING(0);\n\n\treturn jsonb_from_cstring(json, strlen(json));\n}"
  }
]