[
  {
    "function_name": "binary_upgrade_set_missing_value",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_upgrade_support.c",
    "lines": "197-210",
    "snippet": "Datum\nbinary_upgrade_set_missing_value(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\ttable_id = PG_GETARG_OID(0);\n\ttext\t   *attname = PG_GETARG_TEXT_P(1);\n\ttext\t   *value = PG_GETARG_TEXT_P(2);\n\tchar\t   *cattname = text_to_cstring(attname);\n\tchar\t   *cvalue = text_to_cstring(value);\n\n\tCHECK_IS_BINARY_UPGRADE;\n\tSetAttrMissing(table_id, cattname, cvalue);\n\n\tPG_RETURN_VOID();\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/extension.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/heap.h\"",
      "#include \"catalog/binary_upgrade.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define CHECK_IS_BINARY_UPGRADE\t\t\t\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (!IsBinaryUpgrade)\t\t\t\t\t\t\t\t\t\t\\\n\t\tereport(ERROR,\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t(errcode(ERRCODE_CANT_CHANGE_RUNTIME_PARAM),\t\\\n\t\t\t\t (errmsg(\"function can only be called when server is in binary upgrade mode\")))); \\\n} while (0)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VOID",
          "args": [],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetAttrMissing",
          "args": [
            "table_id",
            "cattname",
            "cvalue"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text_to_cstring",
          "args": [
            "value"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "text_to_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "181-197",
          "snippet": "char *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nchar *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_P",
          "args": [
            "2"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_P",
          "args": [
            "1"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "0"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"commands/extension.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/heap.h\"\n#include \"catalog/binary_upgrade.h\"\n#include \"postgres.h\"\n\n#define CHECK_IS_BINARY_UPGRADE\t\t\t\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (!IsBinaryUpgrade)\t\t\t\t\t\t\t\t\t\t\\\n\t\tereport(ERROR,\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t(errcode(ERRCODE_CANT_CHANGE_RUNTIME_PARAM),\t\\\n\t\t\t\t (errmsg(\"function can only be called when server is in binary upgrade mode\")))); \\\n} while (0)\n\nDatum\nbinary_upgrade_set_missing_value(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\ttable_id = PG_GETARG_OID(0);\n\ttext\t   *attname = PG_GETARG_TEXT_P(1);\n\ttext\t   *value = PG_GETARG_TEXT_P(2);\n\tchar\t   *cattname = text_to_cstring(attname);\n\tchar\t   *cvalue = text_to_cstring(value);\n\n\tCHECK_IS_BINARY_UPGRADE;\n\tSetAttrMissing(table_id, cattname, cvalue);\n\n\tPG_RETURN_VOID();\n}"
  },
  {
    "function_name": "binary_upgrade_set_record_init_privs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_upgrade_support.c",
    "lines": "186-195",
    "snippet": "Datum\nbinary_upgrade_set_record_init_privs(PG_FUNCTION_ARGS)\n{\n\tbool\t\trecord_init_privs = PG_GETARG_BOOL(0);\n\n\tCHECK_IS_BINARY_UPGRADE;\n\tbinary_upgrade_record_init_privs = record_init_privs;\n\n\tPG_RETURN_VOID();\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/extension.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/heap.h\"",
      "#include \"catalog/binary_upgrade.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define CHECK_IS_BINARY_UPGRADE\t\t\t\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (!IsBinaryUpgrade)\t\t\t\t\t\t\t\t\t\t\\\n\t\tereport(ERROR,\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t(errcode(ERRCODE_CANT_CHANGE_RUNTIME_PARAM),\t\\\n\t\t\t\t (errmsg(\"function can only be called when server is in binary upgrade mode\")))); \\\n} while (0)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VOID",
          "args": [],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOOL",
          "args": [
            "0"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"commands/extension.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/heap.h\"\n#include \"catalog/binary_upgrade.h\"\n#include \"postgres.h\"\n\n#define CHECK_IS_BINARY_UPGRADE\t\t\t\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (!IsBinaryUpgrade)\t\t\t\t\t\t\t\t\t\t\\\n\t\tereport(ERROR,\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t(errcode(ERRCODE_CANT_CHANGE_RUNTIME_PARAM),\t\\\n\t\t\t\t (errmsg(\"function can only be called when server is in binary upgrade mode\")))); \\\n} while (0)\n\nDatum\nbinary_upgrade_set_record_init_privs(PG_FUNCTION_ARGS)\n{\n\tbool\t\trecord_init_privs = PG_GETARG_BOOL(0);\n\n\tCHECK_IS_BINARY_UPGRADE;\n\tbinary_upgrade_record_init_privs = record_init_privs;\n\n\tPG_RETURN_VOID();\n}"
  },
  {
    "function_name": "binary_upgrade_create_empty_extension",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_upgrade_support.c",
    "lines": "119-184",
    "snippet": "Datum\nbinary_upgrade_create_empty_extension(PG_FUNCTION_ARGS)\n{\n\ttext\t   *extName;\n\ttext\t   *schemaName;\n\tbool\t\trelocatable;\n\ttext\t   *extVersion;\n\tDatum\t\textConfig;\n\tDatum\t\textCondition;\n\tList\t   *requiredExtensions;\n\n\tCHECK_IS_BINARY_UPGRADE;\n\n\t/* We must check these things before dereferencing the arguments */\n\tif (PG_ARGISNULL(0) ||\n\t\tPG_ARGISNULL(1) ||\n\t\tPG_ARGISNULL(2) ||\n\t\tPG_ARGISNULL(3))\n\t\telog(ERROR, \"null argument to binary_upgrade_create_empty_extension is not allowed\");\n\n\textName = PG_GETARG_TEXT_PP(0);\n\tschemaName = PG_GETARG_TEXT_PP(1);\n\trelocatable = PG_GETARG_BOOL(2);\n\textVersion = PG_GETARG_TEXT_PP(3);\n\n\tif (PG_ARGISNULL(4))\n\t\textConfig = PointerGetDatum(NULL);\n\telse\n\t\textConfig = PG_GETARG_DATUM(4);\n\n\tif (PG_ARGISNULL(5))\n\t\textCondition = PointerGetDatum(NULL);\n\telse\n\t\textCondition = PG_GETARG_DATUM(5);\n\n\trequiredExtensions = NIL;\n\tif (!PG_ARGISNULL(6))\n\t{\n\t\tArrayType  *textArray = PG_GETARG_ARRAYTYPE_P(6);\n\t\tDatum\t   *textDatums;\n\t\tint\t\t\tndatums;\n\t\tint\t\t\ti;\n\n\t\tdeconstruct_array(textArray,\n\t\t\t\t\t\t  TEXTOID, -1, false, 'i',\n\t\t\t\t\t\t  &textDatums, NULL, &ndatums);\n\t\tfor (i = 0; i < ndatums; i++)\n\t\t{\n\t\t\tchar\t   *extName = TextDatumGetCString(textDatums[i]);\n\t\t\tOid\t\t\textOid = get_extension_oid(extName, false);\n\n\t\t\trequiredExtensions = lappend_oid(requiredExtensions, extOid);\n\t\t}\n\t}\n\n\tInsertExtensionTuple(text_to_cstring(extName),\n\t\t\t\t\t\t GetUserId(),\n\t\t\t\t\t\t get_namespace_oid(text_to_cstring(schemaName), false),\n\t\t\t\t\t\t relocatable,\n\t\t\t\t\t\t text_to_cstring(extVersion),\n\t\t\t\t\t\t extConfig,\n\t\t\t\t\t\t extCondition,\n\t\t\t\t\t\t requiredExtensions);\n\n\tPG_RETURN_VOID();\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/extension.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/heap.h\"",
      "#include \"catalog/binary_upgrade.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define CHECK_IS_BINARY_UPGRADE\t\t\t\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (!IsBinaryUpgrade)\t\t\t\t\t\t\t\t\t\t\\\n\t\tereport(ERROR,\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t(errcode(ERRCODE_CANT_CHANGE_RUNTIME_PARAM),\t\\\n\t\t\t\t (errmsg(\"function can only be called when server is in binary upgrade mode\")))); \\\n} while (0)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VOID",
          "args": [],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InsertExtensionTuple",
          "args": [
            "text_to_cstring(extName)",
            "GetUserId()",
            "get_namespace_oid(text_to_cstring(schemaName), false)",
            "relocatable",
            "text_to_cstring(extVersion)",
            "extConfig",
            "extCondition",
            "requiredExtensions"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text_to_cstring",
          "args": [
            "extVersion"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "text_to_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "181-197",
          "snippet": "char *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nchar *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_namespace_oid",
          "args": [
            "text_to_cstring(schemaName)",
            "false"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetUserId",
          "args": [],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "GetUserId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
          "lines": "386-391",
          "snippet": "Oid\nGetUserId(void)\n{\n\tAssertState(OidIsValid(CurrentUserId));\n\treturn CurrentUserId;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pidfile.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pg_shmem.h\"",
            "#include \"storage/latch.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/fd.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"common/file_perm.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/htup_details.h\"",
            "#include <utime.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/param.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Oid\tCurrentUserId = InvalidOid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nstatic Oid\tCurrentUserId = InvalidOid;\n\nOid\nGetUserId(void)\n{\n\tAssertState(OidIsValid(CurrentUserId));\n\treturn CurrentUserId;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lappend_oid",
          "args": [
            "requiredExtensions",
            "extOid"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_extension_oid",
          "args": [
            "extName",
            "false"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TextDatumGetCString",
          "args": [
            "textDatums[i]"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deconstruct_array",
          "args": [
            "textArray",
            "TEXTOID",
            "-1",
            "false",
            "'i'",
            "&textDatums",
            "NULL",
            "&ndatums"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "deconstruct_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3460-3519",
          "snippet": "void\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\n\nvoid\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "6"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "6"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "5"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "NULL"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "5"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "4"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "NULL"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "4"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "3"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOOL",
          "args": [
            "2"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"null argument to binary_upgrade_create_empty_extension is not allowed\""
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "3"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "2"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "1"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "0"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"commands/extension.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/heap.h\"\n#include \"catalog/binary_upgrade.h\"\n#include \"postgres.h\"\n\n#define CHECK_IS_BINARY_UPGRADE\t\t\t\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (!IsBinaryUpgrade)\t\t\t\t\t\t\t\t\t\t\\\n\t\tereport(ERROR,\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t(errcode(ERRCODE_CANT_CHANGE_RUNTIME_PARAM),\t\\\n\t\t\t\t (errmsg(\"function can only be called when server is in binary upgrade mode\")))); \\\n} while (0)\n\nDatum\nbinary_upgrade_create_empty_extension(PG_FUNCTION_ARGS)\n{\n\ttext\t   *extName;\n\ttext\t   *schemaName;\n\tbool\t\trelocatable;\n\ttext\t   *extVersion;\n\tDatum\t\textConfig;\n\tDatum\t\textCondition;\n\tList\t   *requiredExtensions;\n\n\tCHECK_IS_BINARY_UPGRADE;\n\n\t/* We must check these things before dereferencing the arguments */\n\tif (PG_ARGISNULL(0) ||\n\t\tPG_ARGISNULL(1) ||\n\t\tPG_ARGISNULL(2) ||\n\t\tPG_ARGISNULL(3))\n\t\telog(ERROR, \"null argument to binary_upgrade_create_empty_extension is not allowed\");\n\n\textName = PG_GETARG_TEXT_PP(0);\n\tschemaName = PG_GETARG_TEXT_PP(1);\n\trelocatable = PG_GETARG_BOOL(2);\n\textVersion = PG_GETARG_TEXT_PP(3);\n\n\tif (PG_ARGISNULL(4))\n\t\textConfig = PointerGetDatum(NULL);\n\telse\n\t\textConfig = PG_GETARG_DATUM(4);\n\n\tif (PG_ARGISNULL(5))\n\t\textCondition = PointerGetDatum(NULL);\n\telse\n\t\textCondition = PG_GETARG_DATUM(5);\n\n\trequiredExtensions = NIL;\n\tif (!PG_ARGISNULL(6))\n\t{\n\t\tArrayType  *textArray = PG_GETARG_ARRAYTYPE_P(6);\n\t\tDatum\t   *textDatums;\n\t\tint\t\t\tndatums;\n\t\tint\t\t\ti;\n\n\t\tdeconstruct_array(textArray,\n\t\t\t\t\t\t  TEXTOID, -1, false, 'i',\n\t\t\t\t\t\t  &textDatums, NULL, &ndatums);\n\t\tfor (i = 0; i < ndatums; i++)\n\t\t{\n\t\t\tchar\t   *extName = TextDatumGetCString(textDatums[i]);\n\t\t\tOid\t\t\textOid = get_extension_oid(extName, false);\n\n\t\t\trequiredExtensions = lappend_oid(requiredExtensions, extOid);\n\t\t}\n\t}\n\n\tInsertExtensionTuple(text_to_cstring(extName),\n\t\t\t\t\t\t GetUserId(),\n\t\t\t\t\t\t get_namespace_oid(text_to_cstring(schemaName), false),\n\t\t\t\t\t\t relocatable,\n\t\t\t\t\t\t text_to_cstring(extVersion),\n\t\t\t\t\t\t extConfig,\n\t\t\t\t\t\t extCondition,\n\t\t\t\t\t\t requiredExtensions);\n\n\tPG_RETURN_VOID();\n}"
  },
  {
    "function_name": "binary_upgrade_set_next_pg_authid_oid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_upgrade_support.c",
    "lines": "109-117",
    "snippet": "Datum\nbinary_upgrade_set_next_pg_authid_oid(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\tauthoid = PG_GETARG_OID(0);\n\n\tCHECK_IS_BINARY_UPGRADE;\n\tbinary_upgrade_next_pg_authid_oid = authoid;\n\tPG_RETURN_VOID();\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/extension.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/heap.h\"",
      "#include \"catalog/binary_upgrade.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define CHECK_IS_BINARY_UPGRADE\t\t\t\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (!IsBinaryUpgrade)\t\t\t\t\t\t\t\t\t\t\\\n\t\tereport(ERROR,\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t(errcode(ERRCODE_CANT_CHANGE_RUNTIME_PARAM),\t\\\n\t\t\t\t (errmsg(\"function can only be called when server is in binary upgrade mode\")))); \\\n} while (0)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VOID",
          "args": [],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "0"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"commands/extension.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/heap.h\"\n#include \"catalog/binary_upgrade.h\"\n#include \"postgres.h\"\n\n#define CHECK_IS_BINARY_UPGRADE\t\t\t\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (!IsBinaryUpgrade)\t\t\t\t\t\t\t\t\t\t\\\n\t\tereport(ERROR,\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t(errcode(ERRCODE_CANT_CHANGE_RUNTIME_PARAM),\t\\\n\t\t\t\t (errmsg(\"function can only be called when server is in binary upgrade mode\")))); \\\n} while (0)\n\nDatum\nbinary_upgrade_set_next_pg_authid_oid(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\tauthoid = PG_GETARG_OID(0);\n\n\tCHECK_IS_BINARY_UPGRADE;\n\tbinary_upgrade_next_pg_authid_oid = authoid;\n\tPG_RETURN_VOID();\n}"
  },
  {
    "function_name": "binary_upgrade_set_next_pg_enum_oid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_upgrade_support.c",
    "lines": "98-107",
    "snippet": "Datum\nbinary_upgrade_set_next_pg_enum_oid(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\tenumoid = PG_GETARG_OID(0);\n\n\tCHECK_IS_BINARY_UPGRADE;\n\tbinary_upgrade_next_pg_enum_oid = enumoid;\n\n\tPG_RETURN_VOID();\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/extension.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/heap.h\"",
      "#include \"catalog/binary_upgrade.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define CHECK_IS_BINARY_UPGRADE\t\t\t\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (!IsBinaryUpgrade)\t\t\t\t\t\t\t\t\t\t\\\n\t\tereport(ERROR,\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t(errcode(ERRCODE_CANT_CHANGE_RUNTIME_PARAM),\t\\\n\t\t\t\t (errmsg(\"function can only be called when server is in binary upgrade mode\")))); \\\n} while (0)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VOID",
          "args": [],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "0"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"commands/extension.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/heap.h\"\n#include \"catalog/binary_upgrade.h\"\n#include \"postgres.h\"\n\n#define CHECK_IS_BINARY_UPGRADE\t\t\t\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (!IsBinaryUpgrade)\t\t\t\t\t\t\t\t\t\t\\\n\t\tereport(ERROR,\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t(errcode(ERRCODE_CANT_CHANGE_RUNTIME_PARAM),\t\\\n\t\t\t\t (errmsg(\"function can only be called when server is in binary upgrade mode\")))); \\\n} while (0)\n\nDatum\nbinary_upgrade_set_next_pg_enum_oid(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\tenumoid = PG_GETARG_OID(0);\n\n\tCHECK_IS_BINARY_UPGRADE;\n\tbinary_upgrade_next_pg_enum_oid = enumoid;\n\n\tPG_RETURN_VOID();\n}"
  },
  {
    "function_name": "binary_upgrade_set_next_toast_pg_class_oid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_upgrade_support.c",
    "lines": "87-96",
    "snippet": "Datum\nbinary_upgrade_set_next_toast_pg_class_oid(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\treloid = PG_GETARG_OID(0);\n\n\tCHECK_IS_BINARY_UPGRADE;\n\tbinary_upgrade_next_toast_pg_class_oid = reloid;\n\n\tPG_RETURN_VOID();\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/extension.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/heap.h\"",
      "#include \"catalog/binary_upgrade.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define CHECK_IS_BINARY_UPGRADE\t\t\t\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (!IsBinaryUpgrade)\t\t\t\t\t\t\t\t\t\t\\\n\t\tereport(ERROR,\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t(errcode(ERRCODE_CANT_CHANGE_RUNTIME_PARAM),\t\\\n\t\t\t\t (errmsg(\"function can only be called when server is in binary upgrade mode\")))); \\\n} while (0)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VOID",
          "args": [],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "0"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"commands/extension.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/heap.h\"\n#include \"catalog/binary_upgrade.h\"\n#include \"postgres.h\"\n\n#define CHECK_IS_BINARY_UPGRADE\t\t\t\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (!IsBinaryUpgrade)\t\t\t\t\t\t\t\t\t\t\\\n\t\tereport(ERROR,\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t(errcode(ERRCODE_CANT_CHANGE_RUNTIME_PARAM),\t\\\n\t\t\t\t (errmsg(\"function can only be called when server is in binary upgrade mode\")))); \\\n} while (0)\n\nDatum\nbinary_upgrade_set_next_toast_pg_class_oid(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\treloid = PG_GETARG_OID(0);\n\n\tCHECK_IS_BINARY_UPGRADE;\n\tbinary_upgrade_next_toast_pg_class_oid = reloid;\n\n\tPG_RETURN_VOID();\n}"
  },
  {
    "function_name": "binary_upgrade_set_next_index_pg_class_oid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_upgrade_support.c",
    "lines": "76-85",
    "snippet": "Datum\nbinary_upgrade_set_next_index_pg_class_oid(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\treloid = PG_GETARG_OID(0);\n\n\tCHECK_IS_BINARY_UPGRADE;\n\tbinary_upgrade_next_index_pg_class_oid = reloid;\n\n\tPG_RETURN_VOID();\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/extension.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/heap.h\"",
      "#include \"catalog/binary_upgrade.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define CHECK_IS_BINARY_UPGRADE\t\t\t\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (!IsBinaryUpgrade)\t\t\t\t\t\t\t\t\t\t\\\n\t\tereport(ERROR,\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t(errcode(ERRCODE_CANT_CHANGE_RUNTIME_PARAM),\t\\\n\t\t\t\t (errmsg(\"function can only be called when server is in binary upgrade mode\")))); \\\n} while (0)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VOID",
          "args": [],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "0"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"commands/extension.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/heap.h\"\n#include \"catalog/binary_upgrade.h\"\n#include \"postgres.h\"\n\n#define CHECK_IS_BINARY_UPGRADE\t\t\t\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (!IsBinaryUpgrade)\t\t\t\t\t\t\t\t\t\t\\\n\t\tereport(ERROR,\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t(errcode(ERRCODE_CANT_CHANGE_RUNTIME_PARAM),\t\\\n\t\t\t\t (errmsg(\"function can only be called when server is in binary upgrade mode\")))); \\\n} while (0)\n\nDatum\nbinary_upgrade_set_next_index_pg_class_oid(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\treloid = PG_GETARG_OID(0);\n\n\tCHECK_IS_BINARY_UPGRADE;\n\tbinary_upgrade_next_index_pg_class_oid = reloid;\n\n\tPG_RETURN_VOID();\n}"
  },
  {
    "function_name": "binary_upgrade_set_next_heap_pg_class_oid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_upgrade_support.c",
    "lines": "65-74",
    "snippet": "Datum\nbinary_upgrade_set_next_heap_pg_class_oid(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\treloid = PG_GETARG_OID(0);\n\n\tCHECK_IS_BINARY_UPGRADE;\n\tbinary_upgrade_next_heap_pg_class_oid = reloid;\n\n\tPG_RETURN_VOID();\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/extension.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/heap.h\"",
      "#include \"catalog/binary_upgrade.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define CHECK_IS_BINARY_UPGRADE\t\t\t\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (!IsBinaryUpgrade)\t\t\t\t\t\t\t\t\t\t\\\n\t\tereport(ERROR,\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t(errcode(ERRCODE_CANT_CHANGE_RUNTIME_PARAM),\t\\\n\t\t\t\t (errmsg(\"function can only be called when server is in binary upgrade mode\")))); \\\n} while (0)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VOID",
          "args": [],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "0"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"commands/extension.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/heap.h\"\n#include \"catalog/binary_upgrade.h\"\n#include \"postgres.h\"\n\n#define CHECK_IS_BINARY_UPGRADE\t\t\t\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (!IsBinaryUpgrade)\t\t\t\t\t\t\t\t\t\t\\\n\t\tereport(ERROR,\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t(errcode(ERRCODE_CANT_CHANGE_RUNTIME_PARAM),\t\\\n\t\t\t\t (errmsg(\"function can only be called when server is in binary upgrade mode\")))); \\\n} while (0)\n\nDatum\nbinary_upgrade_set_next_heap_pg_class_oid(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\treloid = PG_GETARG_OID(0);\n\n\tCHECK_IS_BINARY_UPGRADE;\n\tbinary_upgrade_next_heap_pg_class_oid = reloid;\n\n\tPG_RETURN_VOID();\n}"
  },
  {
    "function_name": "binary_upgrade_set_next_toast_pg_type_oid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_upgrade_support.c",
    "lines": "54-63",
    "snippet": "Datum\nbinary_upgrade_set_next_toast_pg_type_oid(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\ttypoid = PG_GETARG_OID(0);\n\n\tCHECK_IS_BINARY_UPGRADE;\n\tbinary_upgrade_next_toast_pg_type_oid = typoid;\n\n\tPG_RETURN_VOID();\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/extension.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/heap.h\"",
      "#include \"catalog/binary_upgrade.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define CHECK_IS_BINARY_UPGRADE\t\t\t\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (!IsBinaryUpgrade)\t\t\t\t\t\t\t\t\t\t\\\n\t\tereport(ERROR,\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t(errcode(ERRCODE_CANT_CHANGE_RUNTIME_PARAM),\t\\\n\t\t\t\t (errmsg(\"function can only be called when server is in binary upgrade mode\")))); \\\n} while (0)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VOID",
          "args": [],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "0"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"commands/extension.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/heap.h\"\n#include \"catalog/binary_upgrade.h\"\n#include \"postgres.h\"\n\n#define CHECK_IS_BINARY_UPGRADE\t\t\t\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (!IsBinaryUpgrade)\t\t\t\t\t\t\t\t\t\t\\\n\t\tereport(ERROR,\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t(errcode(ERRCODE_CANT_CHANGE_RUNTIME_PARAM),\t\\\n\t\t\t\t (errmsg(\"function can only be called when server is in binary upgrade mode\")))); \\\n} while (0)\n\nDatum\nbinary_upgrade_set_next_toast_pg_type_oid(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\ttypoid = PG_GETARG_OID(0);\n\n\tCHECK_IS_BINARY_UPGRADE;\n\tbinary_upgrade_next_toast_pg_type_oid = typoid;\n\n\tPG_RETURN_VOID();\n}"
  },
  {
    "function_name": "binary_upgrade_set_next_array_pg_type_oid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_upgrade_support.c",
    "lines": "43-52",
    "snippet": "Datum\nbinary_upgrade_set_next_array_pg_type_oid(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\ttypoid = PG_GETARG_OID(0);\n\n\tCHECK_IS_BINARY_UPGRADE;\n\tbinary_upgrade_next_array_pg_type_oid = typoid;\n\n\tPG_RETURN_VOID();\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/extension.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/heap.h\"",
      "#include \"catalog/binary_upgrade.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define CHECK_IS_BINARY_UPGRADE\t\t\t\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (!IsBinaryUpgrade)\t\t\t\t\t\t\t\t\t\t\\\n\t\tereport(ERROR,\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t(errcode(ERRCODE_CANT_CHANGE_RUNTIME_PARAM),\t\\\n\t\t\t\t (errmsg(\"function can only be called when server is in binary upgrade mode\")))); \\\n} while (0)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VOID",
          "args": [],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "0"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"commands/extension.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/heap.h\"\n#include \"catalog/binary_upgrade.h\"\n#include \"postgres.h\"\n\n#define CHECK_IS_BINARY_UPGRADE\t\t\t\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (!IsBinaryUpgrade)\t\t\t\t\t\t\t\t\t\t\\\n\t\tereport(ERROR,\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t(errcode(ERRCODE_CANT_CHANGE_RUNTIME_PARAM),\t\\\n\t\t\t\t (errmsg(\"function can only be called when server is in binary upgrade mode\")))); \\\n} while (0)\n\nDatum\nbinary_upgrade_set_next_array_pg_type_oid(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\ttypoid = PG_GETARG_OID(0);\n\n\tCHECK_IS_BINARY_UPGRADE;\n\tbinary_upgrade_next_array_pg_type_oid = typoid;\n\n\tPG_RETURN_VOID();\n}"
  },
  {
    "function_name": "binary_upgrade_set_next_pg_type_oid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_upgrade_support.c",
    "lines": "32-41",
    "snippet": "Datum\nbinary_upgrade_set_next_pg_type_oid(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\ttypoid = PG_GETARG_OID(0);\n\n\tCHECK_IS_BINARY_UPGRADE;\n\tbinary_upgrade_next_pg_type_oid = typoid;\n\n\tPG_RETURN_VOID();\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/extension.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/heap.h\"",
      "#include \"catalog/binary_upgrade.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define CHECK_IS_BINARY_UPGRADE\t\t\t\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (!IsBinaryUpgrade)\t\t\t\t\t\t\t\t\t\t\\\n\t\tereport(ERROR,\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t(errcode(ERRCODE_CANT_CHANGE_RUNTIME_PARAM),\t\\\n\t\t\t\t (errmsg(\"function can only be called when server is in binary upgrade mode\")))); \\\n} while (0)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VOID",
          "args": [],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "0"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"commands/extension.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/heap.h\"\n#include \"catalog/binary_upgrade.h\"\n#include \"postgres.h\"\n\n#define CHECK_IS_BINARY_UPGRADE\t\t\t\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (!IsBinaryUpgrade)\t\t\t\t\t\t\t\t\t\t\\\n\t\tereport(ERROR,\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t(errcode(ERRCODE_CANT_CHANGE_RUNTIME_PARAM),\t\\\n\t\t\t\t (errmsg(\"function can only be called when server is in binary upgrade mode\")))); \\\n} while (0)\n\nDatum\nbinary_upgrade_set_next_pg_type_oid(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\ttypoid = PG_GETARG_OID(0);\n\n\tCHECK_IS_BINARY_UPGRADE;\n\tbinary_upgrade_next_pg_type_oid = typoid;\n\n\tPG_RETURN_VOID();\n}"
  }
]